#INCLUDE "GPEXCALC.CH"
#Include 'Protheus.ch'

Static lValHorAdic   := Type("P_VALHOADIC") != "U" .AND. P_VALHOADIC
Static __lMemCalc

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³          ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador  ³ Data   ³ FNC            ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³10/01/2013³M12RH01         ³Unificacao das Folhas. Projeto Versao 12 ³±±
±±³            ³          ³REQ.: 04_01     ³                                         ³±±
±±³Tiago Malta ³26/11/2013³M12RH01         ³13 SALARIO PRIMEIRA PARCELA Versao 12    ³±±
±±³            ³          ³REQ.: 18_48     ³                                         ³±±
±±³Renata      ³29/04/2014³TPKANK          ³Na funcao Sindical, substituido opcao do ³±±
±±³            ³          ³				  ³calculo para afast. O e P, pelo opcao do  ³±±
±±³            ³          ³				  ³tipo de ausencia.						 ³±±
±±³Flavio C.   ³09/06/2014³TPUOTR     	   ³REPLICA V11 Ajuste p/ tratar nova opcao  ³±±
±±³            ³          ³           	   ³preenchimento do campo X14_RECFAT.		 ³±±
±±³Mauricio T. ³24/07/2014³TQDPY8     	   ³Inclusao do tratamento da variavel aPeri ³±±
±±³            ³          ³           	   ³odo caso a rotina executora nao possir a ³±±
±±³            ³          ³           	   ³variavel declarada. Exclusao do tipo M   ³±±
±±³            ³          ³           	   ³para gravacao na tabela SRC. A partir da ³±±
±±³            ³          ³           	   ³versao 12 o calculo passa a buscar a info³±±
±±³            ³          ³           	   ³rmacao na tabela de Tarefas.             ³±±
±±³Allyson M.  ³30/07/2014³TQ7146    	   ³Ajuste em fCInss() na verificacao de     ³±±
±±³            ³          ³          	   ³alteracao da verba de Id 0168. 			 ³±±
±±³Allyson M.  ³15/08/2014³TQIEK9    	   ³Ajuste em fPerFatEmp() p/ considerar como³±±
±±³            ³          ³          	   ³base de calculo p/ desoneracao a receita ³±±
±±³            ³          ³          	   ³bruta total deduzida das exclusoes. Antes³±±
±±³            ³          ³          	   ³considerava a base liquida, ou seja, a   ³±±
±±³            ³          ³          	   ³receita bruta deduzida das exclusoes e   ³±±
±±³            ³          ³          	   ³exportacoes.  							 ³±±
±±³Everson SP  ³05/12/14³TQPLI03           ³Ajuste na CalDsrHex() para forcar a      ³±±
±±³            ³          ³                ³gravacao de Outros DSR ao calcular       ³±±
±±³            ³          ³                ³o dissidio.                              ³±±
±±³Allyson M.  ³05/01/2015³TQMFVF    	   ³Ajuste p/ calculo de dissidio validar se ³±±
±±³            ³          ³          	   ³houve pagamento de periculosidade, insa- ³±±
±±³            ³          ³          	   ³lubridade e/ou adicional por tempo de    ³±±
±±³            ³          ³          	   ³servico no mes original.				 ³±±
±±³Wag Mobile  ³29/01/2015³TRAYPF    	   ³Incorporação da base de calculo da comis-³±±
±±³            ³          ³          	   ³são para comissionistas 				 ³±±
±±³Allyson M.  ³20/02/2015³TRHKAT    	   ³Ajuste p/ apurar corretamente a diferenca³±±
±±³            ³          ³          	   ³dos valores na rescisao complementar por ³±±
±±³            ³          ³          	   ³dissidio.  				 				 ³±±
±±³Flavio Corr.³04/02/15  ³PCDEF-11847	   ³Ajuste para valorização de adicionais qdo³±±
±±³            ³          ³          	   ³chamado do roteiro INC					 ³±±
±±³Allyson M.  ³04/03/2015³TRIA28    	   ³Ajuste em fSalProf() p/ nao considerar   ³±±
±±³            ³          ³          	   ³tarefas no salario caso seja professor   ³±±
±±³            ³          ³                ³aulista e 13o. p/ somente efetuar  		 ³±±
±±³            ³          ³                ³pagamento de medias.					 ³±±
±±³Christiane V³30/04/2015³TQXON7          ³Alterada a fórmula fliquido() para gravar³±±
±±³            ³          ³                ³a data do pagamento ao gravar o Líquido. ³±±
±±³Raquel Hager³05/10/2015³TTNHL2          ³Alterada fMatriz() para nao incorporar na³±±
±±³            ³          ³                ³Folha verbas já incorporadas nas Ferias  ³±±
±±³Nivia Ferrei³28/10/2015³PCREQ-5350      ³Produtização Gestão publica V12          ³±±
±±³            ³          ³				   ³Ajuste nas categorias		  		     ³±±
±±³Allyson M.  ³29/12/2015³TUALY1    	   ³Ajuste em CalDsrHex() p/ considerar os   ³±±
±±³            ³          ³          	   ³dias nao trabalhados no calculo de DSR de³±±
±±³            ³          ³                ³hora extra quando P_LPROPDSR esta com .T.³±±
±±³Allyson M.  ³05/01/2016³TUCUTQ    	   ³Ajuste em CalDsrHex() p/ considerar as   ³±±
±±³            ³          ³          	   ³horas normais e descanso do cabecalho da ³±±
±±³            ³          ³                ³rescisao (tratamento era efetuado na 11 )³±±
±±³Raquel Hager³10/02/2016³TUJQLJ		   ³Ajuste na funcao fMatriz para passar a   ³±±
±±³            ³          ³                ³gravar a Data de Referência.             ³±±
±±³Raquel Hager³30/03/2016³TUKV34		   ³Ajuste na funcao SalFam para considerar  ³±±
±±³            ³          ³                ³nDiasP no caso de ADMISSAO.              ³±±
±±³Raquel Hager³20/04/2016³TV0922		   ³Ajuste na funcao fVlDiss para nao        ³±±
±±³            ³          ³                ³ valorizar verba informada.			     ³±±
±±³Claudinei S.³04/05/2016³TUCJR5		   ³Incluido controle de calculo do DSR s/ HE³±±
±±³            ³          ³                ³proporcional a afastamentos e ferias.	 ³±±
±±³Claudinei S.³11/05/2016³TUCJR5|TUVQAB   ³Ajustada a variavel que ira considerar ou³±±
±±³            ³          ³                ³nao as ferias para o DSR Prop. de HE.	 ³±±
±±³Raquel Hager³20/05/2016³TV0922		   ³Remocao de ajuste indevido na funcao     ³±±
±±³            ³          ³                ³ fVlDiss.          			             ³±±
±±³Claudinei S.³02/06/2016³TVIAIX		   ³Ajuste na chamada da IncorpSal na fMatriz³±±
±±³            ³          ³                ³p/ considerar o tipo da verba (Prov/Desc)³±±
±±³Gabriel A.  ³06/06/2016³TVGKFO          ³Ajuste para priorizar o valor das verbas ³±±
±±³            ³          ³                ³informadas e no cálculo de líquido para  ³±±
±±³            ³          ³                ³verbas de pagamento obrigatório.         ³±±
±±³Allyson M.  ³13/06/2016³TVHO32          ³Ajuste para não valorizar verbas calcula-³±±
±±³            ³          ³                ³das obtidas pelo fechamento(tipo F)      ³±±
±±³Gabriel A.  ³24/06/2016³TVJSOG          ³Ajuste em fMatriz() p/ nao incorporar o  ³±±
±±³            ³          ³                ³adicional proporcionalizado do calculo de³±±
±±³            ³          ³                ³ferias pois o valor integral ja é somado ³±±
±±³            ³          ³                ³no calculo do adicional                  ³±±
±±³Allyson M.  ³29/07/2016³TVLPAL          ³Ajuste em fMatriz() p/ proporcionalização³±±
±±³            ³          ³                ³considerar os dias de FGTS      		 ³±±
±±³Gabriel A.  ³26/09/2016³TVSEYW          ³Ajuste no cálculo de DRS para            ³±±
±±³            ³          ³                ³comissionado puro.                       ³±±
±±³Claudinei S.³07/10/2016³TWAWG1		   ³Ajuste em SalFam para considerar verbas  ³±±
±±³            ³          ³                ³do grupo 0 para a base de calculo, quando³±±
±±³            ³          ³                ³Horistas com jornada variável.			 ³±±
±±³Allyson M.  ³26/10/2016³TWHDNC          ³Ajuste em fSalario() p/ verificar o MNE  ³±±
±±³            ³          ³                ³P_DIASRES quando for rescisão      		 ³±±
±±ºRaquel Hager³10/10/2016³TWKEU2          ³Realizados ajustes para execução de robô ³±±
±±º            ³          ³                ³de testes para cálculo de rescisão compl.³±±
±±º            ³          ³                ³com período aberto na função CalDsrHex.	 ³±±
±±³Claudinei S.³02/12/2016³TWAWG1/MRH-233  ³Ajuste em SalFam para não buscar mais as ³±±
±±³            ³          ³                ³incidências no array APDV, em algumas    ³±±
±±³            ³          ³                ³situações o APDV estava diferente do APD,³±±
±±³            ³          ³                ³gerando error.log.                       ³±±
±±³Renan Borges³21/12/2016³MRH-2787        ³Ajuste para calcular adiantamento de pro-³±±
±±³            ³          ³                ³fessores corretamente sem gerar a verba  ³±±
±±³            ³          ³                ³de tarefa.                               ³±±
±±³Renan Borges³21/12/2016³MRH-3148        ³Ajuste para calcular folha de professores³±±
±±³            ³          ³                ³proporcional quando houver afastamento.  ³±±
±±³Gabriel A.  ³31/10/2016³TWIONM          ³Ajuste para proporcionalizar o salário   ³±±
±±³            ³          ³                ³família corretamente quando há múltiplos ³±±
±±³            ³          ³                ³vínculos.                                ³±±
±±³Renan Borges³28/12/2016³MRH-3145        ³Ajuste para calcular folha de professores³±±
±±³            ³          ³                ³de acordo os dias de calculo do cadastro ³±±
±±³            ³          ³                ³de períodos.                             ³±±
±±³Raquel Hager³09/01/2017³MRH-3442        ³Ajuste na função SalFam para montar base ³±±
±±³            ³          ³                ³de cálculo corretamente quando Horista   ³±±
±±³            ³          ³                ³com Jornada Variável.                    ³±±
±±³Raquel Hager³09/01/2017³MRH-2970        ³Ajuste no fMatriz para atualização do    ³±±
±±³            ³          ³                ³a SalBase quando este for diferente do   ³±±
±±³            ³          ³                ³gravado pela primeira vez.               ³±±
±±³Raquel Hager³09/01/2017³MRH-3444        ³Ajuste na função CalDSRHex para usar o   ³±±
±±³            ³          ³                ³mnemônico P_DSRCCMAT para controle de    ³±±
±±³            ³          ³                ³padamento do DSR centralizado pelo Centro³±±
±±³            ³          ³                ³de Custo da Matrícula (padrão do sistema)³±±
±±³            ³          ³                ³ou gerar o DSR pelo Centro de Custo da   ³±±
±±³            ³          ³                ³verba de base.                           ³±±
±±³M. Silveira ³26/01/2017³MRH-4657 	   ³Ajuste em CalDsrHex p/considerar as horas³±±
±±³            ³          ³          	   ³conforme a tabela do Ponto: P_LDSRHRSP.  ³±±
±±³Gabriel A.  ³26/01/2017³MRH-4868        ³Ajuste no cálculo de rescisão para       ³±±
±±³            ³          ³                ³horista quando são lançadas horas na RGB.³±±
±±³Renan Borges³31/01/2017³MRH-5615        ³Ajusta para no calculo de professor seja ³±±
±±³            ³          ³                ³calculado os dias trabalhados corretamen-³±±
±±³            ³          ³                ³te, de acordo com o cadastro de periodos,³±±
±±³            ³          ³                ³e quando houver afastamento.             ³±±
±±³Marcos Couts³28/09/2017³DRHESOCP-1362   ³Realizar os ajustes necessários para que ³±±
±±³            ³          ³                ³ao ser gerado a rescisão coletiva, não   ³±±
±±³            ³          ³                ³seja apresentado errorlog no calculo de  ³±±
±±³            ³          ³                ³Calculo de Dsr Sobre Horas Extras        ³±±
±±³Eduardo K.  ³13/10/2017³MPRIMESP-11722  ³Ajuste para proporcionalizar verbas      ³±±
±±³            ³          ³                ³corretamente quando existir prorrogação  ³±±
±±³            ³          ³                ³de licença maternidade.                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CALC_ARRE³ Autor ³ Equipe de RH          ³ Data ³ 01/03/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ calcula Arredondamento                                     ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Calc_Arre(nVal,nArred,nValarr,cSemana)
Local nResto := Mod(nVal,nArred)

If Round(nResto,2) > 0.00
	nValarr := ( nArred - nResto )
	nVal    := ( nVal  +  nValarr )
Else
	nValarr := 0.00
EndIf

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fSalario ³ Autor ³ Mauro                 ³ Data ³ 29.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula Salario Dia Hora e Mes                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fSalario(Salario,Salhora,Saldia,Salmes,Tipo)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Codigo = Codigo da Verba que deseja                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fSalario(Salario,SalHora,SalDia,SalMes,cTipo,cAnMes,cNroPagto, cCatMensal)
Local aArea			:= GetArea()
Local cKeySeek		:= ""
Local dData			:= CtoD("//")
Local lMAprendiz  	:= GetMvRH("MV_MAPREND",,.F.)
Local nDiasCalc		:= 0
Local nHrsCalc		:= 0
Local nValor		:= 0
Local cMes			:= ""
Local cAno			:= ""
Local nNumSemana	:= 0
Local nDiasSem		:= 7

DEFAULT cCatMensal    := "M"

If ExistFunc("fUsaGFP") .and. fUsaGFP()	//Se utiliza o modulo de Gestao de Folha Publica - SIGAGFP, acrescenta as novas categorias para mensalistas
	cCatMensal += "*0*1*2*3*4*5*6*7*8*9"
EndIf

If cPaisLoc == "BRA" .And. SRA->RA_CATFUNC == "S"
	If Type("P_NTOTDIAS") == "U"
		SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_NTOTDIAS")
	EndIf
	nDiasSem := P_NTOTDIAS
EndIf

If cPaisLoc == "RUS"
	cCatMensal += "*R"
EndIf

DEFAULT cAnMes      := If(Empty(cAnMes),(If(Type("cAnoMes") # "U", cAnoMes, MesAno(dDataBase))), cAnMes)
DEFAULT cNroPagto	:= If(Empty(cNroPagto),(If(Type("cSemana") # "U", cSemana, "01")), cNroPagto)

	cMes			:= SubStr(cAnMes,5,2)
	cAno			:= SubStr(cAnMes,1,4)
	dData			:= CtoD("01/" + cMes + "/" + cAno)

	dbSelectArea("RCF")
	dbSetOrder(5)  // RCF_FILIAL+RCF_PER+RCF_SEMANA+RCF_ANO+RCF_MES+RCF_PROCES+DTOS(RCF_DTINI)+DTOS(RCF_DTFIM)+RCF_MODULO
	cKeySeek	:= cAnMes + cNroPagto + cAno + cMes + SRA->RA_PROCES
	If RCF->( dbSeek(xFilial("RCF") + cKeySeek) )
		If cPaisLoc == "BRA" .And. Type("cTipoRot") # "U" .And. cTipoRot == "4" .And. (RCF->RCF_DPERIO == 31  .Or. RCF->RCF_MES == "02")
			SetMnemonicos(SRA->RA_FILIAL, NIL, .T., "P_DIASRES", .T.)
			If P_DIASRES = 1
				nDiasCalc	:= RCF->RCF_DPERIO
			Else
				nDiasCalc	:= RCF->RCF_DCALCM
			EndIf
		Else
			nDiasCalc	:= RCF->RCF_DCALCM
		EndIf
	ElseIf ( nModulo == 19 .Or. nModulo == 95 ) .And. AllTrim(GetNewPar('MV_NGINTER','N')) == 'M'
		//quanto integrado MNT X RM, não se utiliza periodos (RCF), portanto o calculo segue a regra antiga da v11
		// para alimentar a tabela de funcionarios da Manutenção (ST1)
		nDiasCalc	:= 30
	EndIf

	If nDiasCalc > 0 .And. SRA->RA_HRSDIA > 0
		nHrsCalc := Round((SRA->RA_HRSDIA * nDiasCalc),2)
	elseIf SRA->RA_HRSMES > 0
		nHrsCalc := SRA->RA_HRSMES
	EndIf

	// Menor Aprendiz
	If SRA->RA_CATEG = '07' .And. lMAprendiz

		If nDiasCalc > 0 .And. SRA->RA_HRSMES > 0
			nHrsCalc := SRA->RA_HRSMES
		EndIf

		 Do Case
			Case F_ULTDIA(dData) == 31
				nNumSemana := 4.428571
			Case F_ULTDIA(dData) == 30
				nNumSemana := 4.285714
			Case F_ULTDIA(dData) == 29
				nNumSemana := 4.142857
			Case F_ULTDIA(dData) == 28
				nNumSemana := 4
		EndCase
		If SRA->RA_CATFUNC = "H"
			nValor :=  nHrsCalc  / 5
			nValor := (nValor * nNumSemana) * SRA->RA_SALARIO
			SalMes := (nValor * 7 ) / 6
		ElseIf SRA->RA_CATFUNC $ cCatMensal
				Salmes := SRA->RA_SALARIO
		EndIf
		RestArea(aArea)
		Salario  := SalMes
		Return
	EndIf

	If ( SRA->RA_CATFUNC $ cCatMensal )
		SalMes := SRA->RA_SALARIO
	EndIf

	If ( SRA->RA_CATFUNC $ "C*P*A*E" )
		If ( SRA->RA_TIPOPGT == "S" )
			SalMes := ( SRA->RA_SALARIO / 7 ) * nDiasCalc
		EndIf
		If ( SRA->RA_TIPOPGT == "M" )
			SalMes :=  SRA->RA_SALARIO
		EndIf
	EndIf

	If ( SRA->RA_CATFUNC $ "H*G*T" )
		SalMes:= SRA->RA_SALARIO * nHrsCalc
	EndIf

	If ( SRA->RA_CATFUNC == "D" )
		SalMes:= SRA->RA_SALARIO * nDiasCalc
	EndIf

	If ( SRA->RA_CATFUNC == "S" )
		SalMes:= ( SRA->RA_SALARIO / nDiasSem  ) * nDiasCalc
	EndIf

	If ( SRA->RA_TIPOPGT == "M" )
		If ( SRA->RA_CATFUNC $ cCatMensal .or. SRA->RA_CATFUNC $ "C*P*A*E" )
			SalDia := SRA->RA_SALARIO / nDiasCalc
			SalHora := SRA->RA_SALARIO /  (nDiasCalc  *    SRA->RA_HRSDIA)
		EndIf
		If ( SRA->RA_CATFUNC $ "H*T*G" )
			SalDia:=  SRA->RA_SALARIO * SRA->RA_HRSDIA
			SalHora:= SRA->RA_SALARIO
		EndIf
		If ( SRA->RA_CATFUNC == "D" )
			SalDia:= SRA->RA_SALARIO
			SalHora:= SRA->RA_SALARIO /  SRA->RA_HRSDIA
		EndIf
	EndIf

	If ( SRA->RA_TIPOPGT == "S" )
		If ( SRA->RA_CATFUNC $ "H*G" )
			SalHora:= SRA->RA_SALARIO
			SalDia:=  (SRA->RA_SALARIO * SRA->RA_HRSDIA)
		EndIf
		If ( SRA->RA_CATFUNC $ "S*T*C*P*A*E" )
			If ( SRA->RA_CATFUNC == "S" )
				SalDia:= ( SRA->RA_SALARIO / nDiasSem )
				SalHora:= (SRA->RA_SALARIO / nDiasSem)  /  SRA->RA_HRSDIA
			Else
				SalDia:= ( SRA->RA_SALARIO / 7 )
				SalHora:= (SRA->RA_SALARIO / 7)  /  SRA->RA_HRSDIA
			EndIf
		EndIf
		If ( SRA->RA_CATFUNC == "D" )
			SalHora:= SRA->RA_SALARIO /  SRA->RA_HRSDIA
			SalDia:= SRA->RA_SALARIO
		EndIf
	EndIf

	Salario  := SalMes

	RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Salfam   ³ Autor ³ Mauro                 ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo do Salario Familia                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCodfol   = Matriz Contendo as Ref. das Verbas             ³±±
±±³          ³ Sal_famil = Valor a Ser Calculado Passado como Referencia  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SalFam(aCodfol,Sal_Famil,cGrava,dDataDem)
Local 	aArea		:= GetArea()
Local   aSRBArea	:= SRB->(GetArea())

Local   nSalAux 	:= Salario
Local   nSalMulV	:= 0
Local	nVb			:= 0
Local   nPosVbApd	:= 0
Local 	cVerbas_Aux	:= ""
Local 	cFil 		:= xFilial("SRV")
Local	llDepSf		:= Iif(SRA->(FieldPos("RA_DEPSF"))>0,.T.,.F.)
Local	nQtdeDepSF	:= 0
Local 	nIdade   	:= 0
Local 	dDaCalc		:= dDataAte //Atualizacao da Variavel ddacalc para não utilizar o DDATABASE
Local	lSaldoSal	:= .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se for calc.p/funcionario com  multiplos vinculos, tenho q³
//³ utilizar o salario que foi acumulado de todas as matricu- ³
//³ las p/gerar o sal.Familia                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("lUtiMultiV")<> "U" .and. lUtiMultiV
	nSalAux  := Max(Salario,SRA->RA_SALARIO)
	nSalMulV := fBuscaPd(aCodFol[318,1],"V",cSemana)
	nSalAux  := Max(nSalMulV,nSalAux)
EndIf

If SRA->RA_TPCONTR == "3" .And. !Empty(aConvocacao[1]) .And. !aConvocacao[6]
	Aeval( aPd ,{ |X| SomaInc(X,21,@NSFINTERM, , , , , , ,aCodfol) })
	NSFINTERM += nSalAux
	Return
EndIf
dDatadem := If(dDatadem = Nil,SRA->RA_DEMISSA,dDatadem)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Array que contem as variaveis criadas por fVarRot()       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("aVarRot") = "U"
	aVarRot := {}
EndIf

If llDepSf
	If Val(SRA->RA_DEPSF) > 0

	    //-- Somente para o BRASIL aplica as regras de validade de idade para considerar os dependentes
	    //-- validos para o beneficio do salario-familia
		If cPaisLoc == "BRA"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Controla idade dos dependentes Salario Familia            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea( "SRB" )
			//-- Se nao existir dependentes de salario familia assume o
			//-- registrado no cadastro de funcionarios (legado)
			If ! dbSeek(SRA->RA_FILIAL + SRA->RA_MAT)
				nQtdeDepSF := VAL(SRA->RA_DEPSF)
			Else
				//Verificar se existem dependentes
				While SRB->(!Eof() .And. SRB->RB_FILIAL + SRB->RB_MAT == SRA->RA_FILIAL + SRA->RA_MAT)

					//-- Somente se o dependente for filho/Outros
					If (Upper(SRB->RB_GRAUPAR) <>"C")

					    //-- *** Somente se não houver limite de idade  ou
						If (SRB->RB_TIPSF == "1")
							nQtdeDepSF += 1
						//-- *** Dependente ate 14 anos
						//-- ****** Nascidos ate a data de calculo
						ElseIF (SRB->RB_TIPSF == "2") .and. ;
						 	   ( AnoMes(ddacalc)>= AnoMes(SRB->RB_DTNASC) )
		 					    //-- Menor de 14 anos ou igual a 14 mas, nesse ultimo caso, completa anos
		 					    //-- ate o mes de referencia inclusive
		 					    //-- Exemplo: Nascto: 01/10/11 ou 31/10/11 e calculo referente a 'Outubro',
		 					    //-- o dependente devera ser considerado.
		 					    //-- No entanto, na folha referente a 'Novembro', o dependente nao devera ser
		 					    //-- considerado no SF pois ja se trata do mes seguinte ao do aniversario de
		 					    //-- 14 anos.
	 							nIdade   	:= CALC_IDADE(ddacalc,SRB->RB_DTNASC)
		 						If ( nIdade < 14 )  .or. ;
		 						   ( 	( nIdade = 14 ) .and. ;
		 						   		( MesAno(ddacalc) <= MesAno(YearSum( SRB->RB_DTNASC , 14 ) ) );
		 						   	)
									nQtdeDepSF += 1
								EndIf

			 			EndIf

					EndIf
					SRB->(dbSkip())
				EndDo
			EndIf
			RestArea(aSRBArea)
		Else
			nQtdeDepSF := VAL(SRA->RA_DEPSF)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Para semanalistas, deve calcular somente na ultima semana ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( SRA->RA_TIPOPGT = "S" .And. ! lUltSemana ) .And. If( SRA->RA_CATFUNC = "S", cTipoRot <> "4", .T. )
			Return
		EndIf

		If SRA->RA_TPCONTR != "3"
			nSalfami_b := 0.00
		Else
			nSalfami_b += NSFINTERM
		EndIf

		If Ascan(aPd, { |X| X[1] = aCodfol[34,1] .And. X[9] # "D"}) = 0

			// As verbas de DSR horista e Hrs. Atividade devem ser buscadas diretamente do aPd,
			// pois nao devem possuir incidencia para salario familia.
			// SOMA INCIDENCIA PARA SALARIO FAMILIA
			Aeval( aPd ,{ |X| SomaInc(X,21,@nSalfami_B, , , , , , ,aCodfol) })

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Proporcionaliza salario conforme as hrs efetivamente      ³
			//³ trabalhadas no mes                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If  !P_SALFHOR .And. (cTipoRot == "4" .Or. cRot == fGetRotOrdinar( , SRA->RA_FILIAL ) ) .And. SRA->RA_CATFUNC $ "H*T*G*C"
				nSalAux	:= Round( ( SalHor * Round( NHORASTRAB, MsDecimais(1) ) ), MsDecimais(1)) + Round( ( SalHor * Round( DESCANSO, MsDecimais(1) )  ), MsDecimais(1))

				//Recompoe a base do comissionado puro, para ficar compativel ao calculo feito pelo HomologNet no MTE.
				If SRA->RA_CATFUNC == "C" .And. nSalAux == 0
					nSalfami_B := Round( ( (nSalFami_b / DiasTrab) * nDiasC ), MsDecimais(1))
				EndIf
			EndIf

			// SE JORNADA VARIAVEL, BUSCA O VALOR DO SALÁRIO DAS VERBAS DO GRUPO 0
			If SRA->RA_CATFUNC = "H" .And. SRA->(ColumnPos( "RA_HOJORVA")) > 0 .And. SRA->RA_HOJORVA = "1"
				//Busca as verbas que estão no grupo 0, campo RV_GRPVERB = 0
				GP140GrpVerb(cFil,@cVerbas_Aux,"0",.T.)
				For nVb := 1 To Len(cVerbas_Aux) Step 3
					If lSaldoSal .And. aCodFol[0032,1] $ SubStr(cVerbas_Aux,nVb,3)
						lSaldoSal := .F.
						If (nPosVbApd := Ascan(aPd, { |X| X[1] = aCodFol[0048,1] .And. X[9] # "D"})) > 0
							nSalFami_b += aPd[nPosVbApd,5]
						Endif
					Endif
					If (nPosVbApd := Ascan(aPd, { |X| X[1] = SubStr(cVerbas_Aux,nVb,3) .And. X[9] # "D"})) > 0
						//Se a verba já compor a base de salário familia não será considerada.
						If RetValSRV(aPd[nPosVbApd,1],SRA->RA_FILIAL,"RV_SALFAMI") <> "S"
							//Verifica o tipo da verba para saber se ela será somada ou subtraída da base de salário família.
							If RetValSRV(aPd[nPosVbApd,1],SRA->RA_FILIAL,"RV_TIPOCOD") == "2"
								Aeval( aPd ,{ |X|  If( X[1] ==  SubStr(cVerbas_Aux,nVb,3), nSalFami_b -= X[5],Nil) } )
							Else
								Aeval( aPd ,{ |X|  If( X[1] ==  SubStr(cVerbas_Aux,nVb,3), nSalFami_b += X[5],Nil) } )
							Endif
						Endif
					EndIf
				Next nVb
			Else
				// SOMA O SALARIO BASE AUTOMATICAMENTE NA BASE SAL.FAMILIA
				nSalFami_b += If(nDiasMat > 0 .And. RetValSRV(aCodFol[040,1],SRA->RA_FILIAL,"RV_SALFAMI") == "S", nSalAux / nDiasC * DiasTrab, nSalAux )
			EndIf

			// SOMA O VALOR DA MEDIA DE COMISSAO CALCULADA PARA AFASTAMENTO POR AUXILIO MATERNIDADE
			If aCodFol[238,1] # Space(3) .And. RetValSRV(aCodFol[238,1],SRA->RA_FILIAL,"RV_SALFAMI") == "S"
				nSalFami_b += fVarRot("nMedComiss")
			EndIf

			// SOMA O VALOR DA BASE DE INSS DE OUTRAS EMPRESAS NA BASE DE CALCULO DO SALARIO FAMILIA
			// SOMENTE DEVERA CONFIGURAR A VERBA 288 COM "SIM" SE A EMPRESA NAO UTILIZAR MULTIPLOS VINCULOS
			If aCodFol[288,1] # Space(3) .And. RetValSRV(aCodFol[288,1],SRA->RA_FILIAL,"RV_SALFAMI") == "S"
				Aeval( aPd ,{|X| nSalFami_b += If(X[1] == aCodFol[288,1] .And. X[9] <> "D",X[5],0) })
			EndIf

			// CALCULO DO SALARIO FAMILIA PROPORCIONAL
			DiasFamil :=  If(GetMvRH("MV_SALFD")= "S",nDiasC,P_QTDIAMES)
			DiasBase  :=  If(GetMvRH("MV_SALFD")= "S",nDiasC,P_QTDIAMES)


			If GetMvRH("MV_SALFP") = "S"
				If YEAR(SRA->RA_ADMISSA)=YEAR(dDataAte).AND.MONTH(SRA->RA_ADMISSA)=MONTH(dDataAte).AND.DAY(SRA->RA_ADMISSA) # 1
					// Assume Dias de Cálculo para caso de ADMISSAO
					Diasfamil := If(GetMvRH("MV_SALFD")= "S",nDiasP,Diasfamil)
					Diasfamil := DiasFamil - Day(SRA->RA_ADMISSA) + 1
					If !Empty(dDatadem)
						Diasfamil := (Day(dDatadem) - Day(SRA->RA_ADMISSA)+1)
					EndIf
				Elseif  ! Empty(dDataDem)
					DiasFamil := Day(dDataDem)
				EndIf
			EndIf

			//Se foi admitido no mês, inclui verbas de adicionais integrais
			If AnoMes(SRA->RA_ADMISSA) == cPeriodo .and. ( nSalfami_B <= nLIMSF2 .or. nSalfami_B <= nLIMSF1 ) .and. nPeric + nInsalub + nAdtServ > 0
				For nVb := 1 to Len(aPd)
					If aPd[nVb,9] == "D"
						Loop
					EndIf
					If aPd[nVb,1] $ aCodFol[36,1] + "/" + aCodFol[1281,1] .and. nPeric > 0 .and. RetValSRV(aPd[nVb,1], SRA->RA_FILIAL, "RV_SALFAMI") == "S"
						nSalfami_B -= aPd[nVb,5]
						nSalFami_B += nPeric
					EndIf
					If aPd[nVb,1] $ aCodFol[37,1] + "/" + aCodFol[38,1] + "/" + aCodFol[39,1] + "/" + aCodFol[1282,1] .and. nInsalub > 0 .and. RetValSRV(aPd[nVb,1], SRA->RA_FILIAL, "RV_SALFAMI") == "S"
						nSalfami_B -= aPd[nVb,5]
						nSalFami_B += nInsalub
					EndIf
					If aPd[nVb,1] $ aCodFol[1,1] + "/" + aCodFol[2,1] + "/" + aCodFol[3,1] + "/" + aCodFol[4,1] + "/" + aCodFol[5,1] + "/" + aCodFol[1283,1] + "/" + aCodFol[1284,1] + "/" + aCodFol[1285,1] + "/" + aCodFol[1286,1] + "/" + aCodFol[1287,1] .and. nAdtServ > 0 .and. RetValSRV(aPd[nVb,1], SRA->RA_FILIAL, "RV_SALFAMI") == "S"
						nSalfami_B -= aPd[nVb,5]
						nSalFami_B += nAdtServ
					EndIf 
				Next nVb
			EndIf

			If nSalfami_b <= nLIMSF1
				SAL_FAMIL := nQtdeDepSF * nVAL_SF1 / DiasBase * DiasFamil
				SAL_FAMIL := Min( (nQtdeDepSF * nVAL_SF1), SAL_FAMIL)		// Ajuste p/nao extrapolar o limite do beneficio
			Elseif nSalfami_b <= nLIMSF2
				SAL_FAMIL := nQtdeDepSF * nVAL_SF2 / DiasBase * DiasFamil
				SAL_FAMIL := Min( (nQtdeDepSF * nVAL_SF2), SAL_FAMIL)		// Ajuste p/nao extrapolar o limite do beneficio
			EndIf
			If ((SRA->RA_TIPOPGT = "S") .And. (SRA->RA_CATFUNC $ "S*T") .And. ! lUltSemana .And. If( SRA->RA_CATFUNC = "S", cTipoRot <> "4", .T. )) .Or. (SRA->RA_TPCONTR == "3" .And. NSFINTERM == 0 .AND. Empty(aConvocacao[1]))
				SAL_FAMIL := 0
			EndIf

			If cGrava # Nil .And. cGrava = "S" .And. SAL_FAMIL > 0
				If SRA->RA_TPCONTR == "3"
					nOrdGrPd++
					aadd(aSalBase,{aCodfol[34,1],nSalfami_b,nOrdGrPd})
				EndIf
				FMatriz(aCodfol[34,1],SAL_FAMIL,nQtdeDepSF)
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fHECodCorr  ³ Autor ³ Mauricio MR         ³ Data ³26/12/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica a existencia de Cod HE para comissionista puro     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA090/GPEA100/GPEXCALC                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fHECodCorr(cFilSRA, cCodCorr, cCodSRV)
Local aArea		:= GetArea()
Local aAreaSRV	:= GetArea("SRV")

Local caliasSRV := 'SRV'
Local cFilSRV	:= xFilial("SRV",cFilSRA)

Local lRet		:=.F.

DEFAULT cCodSRV	:= ''

cAliasSRV := GetNextAlias()
BeginSql alias cAliasSRV
	SELECT SRV.RV_COD,SRV.RV_CODCORR, SRV.RV_HE
	FROM %table:SRV% SRV
	WHERE SRV.RV_FILIAL = %exp:cFilSRV%
		  AND SRV.RV_CODCORR =  %exp:cCodCorr%
		  AND SRV.%NotDel%
EndSql

While (cAliasSRV)->( !Eof() )
    //-- Se a Verba de Hora Extra for codigo correspondente de outra, aborta a pesquisa
	If !Empty( (cAliasSRV)->RV_CODCORR ) .and.  ((cAliasSRV)->RV_CODCORR == cCodCorr ) .and.  ( (cAliasSRV)->RV_HE == 'S' )
		lRet		:=.T.
		cCodSRV		:=  (cAliasSRV)->RV_COD
		Exit
	EndIf
	(cAliasSRV)->( DbSkip() )
EndDo

(cAliasSRV)->(DbCloseArea())

RestArea( aAreaSRV )
RestArea( aArea )

Return lRet



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fHrTrabDesc ³ Autor ³ Mauricio MR        ³ Data ³ 26.12.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo das Horas Trabalhadas							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nHrsEfTrab =  Horas Efetivas Trabalhadas	                  ³±±
±±³          ³ cSemana    =  Semana referenciada		                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fHrTrabDesc(nHrsEfTrab,cSemana)

Local nPosCFol := 0 // Verba de Comissão Folha
Local nPosCRes := 0 // Verba de Comissão Rescisão.
nHrsEfTrab:= 0
nDiasTrab := 0
nDiasDSR  := 0

If !(cTipoRot == "4") // Se não for rescisão, busca pelo ID de comissão da Folha.
	nPosCFol := Ascan(aPd, { |X| X[1] = aCodfol[165,1] .And. X[3] = cSemana .And. X[9] # "D"})
Else
	// Se for rescisão, procura pelo ID de comissão Rescisão
	nPosCRes := Ascan(aPd, { |X| X[1] = aCodfol[121,1] .And. X[3] = cSemana .And. X[9] # "D"})
EndIf

If ( nPosCFol > 0 .Or. nPosCRes > 0 .Or. SRA->RA_CATFUNC == "C" )
    //Horas Efetivamente Trabalhadas
    If ( aCodfol[638,1] # Space(3) )
		If (nPos :=  Ascan(aPd, { |X| X[1] = aCodfol[638,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] # "C"})) > 0
			nHrsEfTrab:= aPd[nPos,4]
		EndIf
	EndIf

	//-- Se nao existir horas efetivamente trabalhadas obtem atraves dos dias trabalhados/contrato
	If Empty(nHrsEfTrab)
		//Horas Efetivamente Trabalhadas a partir dos dias trabalhados
	    If ( aCodfol[989,1] # Space(3) )
			If (nPos :=  Ascan(aPd, { |X| X[1] = aCodfol[989,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] # "C"})) > 0
				nDiasTrab:= aPd[nPos,4]
			EndIf
		EndIf

		If Empty(nDiasTrab) .and. SRA->RA_CATFUNC == "C" .and. cTipoRot == "4" .and. DiasTrab > 0
			nDiasTrab := DiasTrab
		EndIf

		//Se nao existir dias trabalhados, obtem as horas contratuais/Composicao mes/Turno/Periodo
		If Empty(nDiasTrab)
		   	If Normal > 0
		 		nHrsEfTrab := 	Normal
		   	Else
			   	nHrsEfTrab := SRA->RA_HRSMES //Consideramos todas as horas sem a deducao das horas de DSR.
		   	EndIf
		Else
		   	//Compor as horas efetivas a partir dos dias trabalhados no contrato (SRA)
		   	nHrsEfTrab := ( SRA->RA_HRSEMAN / 6 ) * nDiasTrab
		EndIf
	EndIf
EndIf

Return(Nil)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GeraTarefa³ Autor ³ Equipe R.H.           ³ Data ³ 11.12.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo de Tarefeiros                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GeraTarefa(dDataDe,dDataAte,aTarefas,cGrava)
Local aArea			:= GetArea()
Local aFalHE		:= {}
Local bDataDe   	:= &( "{ || " + "MesAno(SRO->RO_DATA) }" )
Local bDataAte  	:= &( "{ || " + "MesAno(SRO->RO_DATAATE) }" )
Local cChaveBus 	:= SRA->RA_FILIAL + SRA->RA_MAT
Local cCCAtual  	:= ""
Local cCodTarefa
Local nValTarefa
Local nCnt
Local cTipVerba
Local nPos
Local cPerAtual 	:= ""
Local cItAtual  	:= ""
Local cClAtual  	:= ""
Local cTarHE		:= ""
Local cTarFal		:= ""
Local cTab			:= "S070"
Local lItemClVl 	:= GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local cItCt 		:= If(lItemClVl,SRA->RA_ITEM,'')
Local cClCt 		:= If(lItemClVl,SRA->RA_CLVL,'')
Local dDtInTar		:= Ctod("//")
Local dDtFiTar		:= Ctod("//")
Local dDtFimTar		:= Ctod("//")
Local lGeraTarefa 	:= .T.
Local nTarTot		:= 0
Local nQtdSem		:= 0
Local nQtdTar		:= 0 // Proporcionalizar qtde. semanas pela qtde. de dias da tarefa
Local nQtDTarM		:= 0
Local nHrsExt		:= 0
Local nHrsFal		:= 0
Local nValHE		:= 0
Local nValFal		:= 0
Local nUltDia		:= 0
Local nDNTrab		:= 0
Local nPosTab		:= 0
Local nTarAux		:= 0

local aPer			:= {}
local lultSem
local nPosSe		:= 0
Local lPropTar   := GetMvRH("MV_PROPTAR",,.F.)

Private aTarAux   	:= {}

if Type("nDiasC") == "U" .AND. Type("aPeriodo") == "U"

	CPERIODO 	:= IF(EMPTY(CPERIODO),GETPERIODCALC(),CPERIODO)
    CROT 		:= IF(EMPTY(CROT),GETROTEXEC(),CROT)
    CROT 		:= IF(CROT=="INC",FGETROTORDINAR(),CROT)

    FCARPERIODO( CPERIODO , CROT , @aPer, @lultSem, @nPosSe)

     IF ( LEN(aPer) > 0 )
     	nDiasC := aPer[nPosSe,20]
     EndIf

EndIf

If CROT == "ADI"
	cGrava := "N"
EndIf

If Type("aPeriodo") <> "U" .AND. Len(aPeriodo) > 0
	cPerAtual := aPeriodo[nPosSem,15] + aPeriodo[nPosSem,16]		 //RCF_ANO + RCF_MES //Periodo de calculo
Else
	cPerAtual := MesAno( dDatade )
EndIf

lNewProf := GetMVRH("MV_NCPROF",,"2") == "1" .and. SRA->( RA_CATFUNC $ "I*J" )

If Type("aOrigTar") == "U" .Or. !Empty(aOrigTar)
	aOrigTar := {}
EndIf

//-- Verificar se estou em rescisao complementar fora do mes para ajustar o mes e ano aberto
If Type("cCompl") <> "U" .And. cCompl == "S" .And. Type("lProxMes") <> "U" .And. lProxMes
	cPerAtual := MesAno(dDatadem)
EndIf

If Type("aErrProc") == "U"
	aErrProc := Array(1,0)
EndIf

If Type("aAfaTar") == "U"
	aAfaTar := {}
EndIf

aTarefas	:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Gera Tarefas a partir do array aPd - Movimento Mensal		   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cGrava = "S" .And. !Empty(dDataDe)
	For nCnt := 1 To Len(aPd)
		lGeraTarefa	:= .T.
		cCodTarefa := RetValSrv(aPd[nCnt,1],SRA->RA_FILIAL,"RV_TAREFA")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Este teste verifica se o conteudo do campo RV_TAREFA contem o  |
		//| codigo da tarefa, pois podera conter tambem [S]im ou [N]ao.    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(AllTrim(cCodTarefa)) == 3 .And. aPd[nCnt,6] $ "H/D" .And. aPd[nCnt,9] # "D"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Caso esteja na incorporacao, a verba tenha menos de 1 parcela e|
			//| a rescisao estiver no mes seguinte, nao criaremos a tarefa pois|
			//| esta tarefa nao faz parte da rescisao no mes seguinte.         |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Type("P_SALINC") <> "U" .And. P_SALINC
				If aPd[nCnt,8] <= 1
					If Type("lRescMSeg") <> "U" .And. lRescMSeg
						lGeraTarefa	:= .F.
					EndIf
				EndIf
			EndIf
			If lGeraTarefa
				If (nPosTab := fPosTab( cTab,cPerAtual,"=",2,cCodTarefa,"=",4)) == 0
					nPosTab := fPosTab( cTab,Space(6),"=",2,cCodTarefa,"=",4)
				EndIf

				If nPosTab > 0
					cTipVerba   := RetValSRV(aPd[nCnt,1],SRA->RA_FILIAL,"RV_TIPOCOD")
					nValTarefa  := fTabela(cTab,nPosTab,6)
					aPd[nCnt,5] := aPd[nCnt,4] * nValTarefa
					Aadd( aTarefas , { aPd[nCnt,1], aPd[nCnt,5], aPd[nCnt,12], aPd[nCnt,4], aPd[nCnt,2], aPd[nCnt,10], cTipVerba, "SRC", "2", aPd[nCnt,13], aPd[nCnt,14], 0, 0, 0, "", "", 0, 0, aPd[nCnt,18] } )
				EndIf
			EndIf
		EndIf
	Next nCnt
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Array que contera as tarefas acumuladas por Verba+C.C.		   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aTarAux := aClone(aTarefas)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Gera Tarefas a partir do arquivo SRO - Lancamentos de Tarefas  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea( "SRO" )
dbSeek( cChaveBus )
While !EOF() .And. ( cChaveBus == SRO->RO_FILIAL + SRO->RO_MAT )
	lCalcTarefa := .F.

	If SRO->RO_TIPO $ "1*3" //1-Tarefa Fixa / 3-Aditamento Fixo
		If Empty(cPerAtual)      .Or. ( Eval(bDataDe)  <= cPerAtual .And.;
		  (Empty(SRO->RO_DATAATE) .Or.   Eval(bDataAte) >= cPerAtual) )
			lCalcTarefa := .T.
        EndIf
	Else //2-Tarefa Variavel / 4-Aditamento Variavel
		If !Empty(dDataDe)
			If (SRO->RO_DATA    <= dDataAte) .And. ( Empty(SRO->RO_DATAATE) .Or.;
			   (SRO->RO_DATAATE >= dDataDe) )
				lCalcTarefa := .T.
			EndIf
		EndIf
	EndIf
	If lCalcTarefa .And. Ascan( aTarefas, { |X| X[1] == SRO->RO_VERBA .And. X[8] == "SRC" }) == 0
		cCCAtual  := If(Empty(SRO->RO_CC), SRA->RA_CC, SRO->RO_CC)
		cItAtual  := If(lItemClVl,If( Empty(SRO->RO_ITEM), cItCt, SRO->RO_ITEM), "" )
		cClAtual  := If(lItemClVl,If( Empty(SRO->RO_CLVL), cClCt, SRO->RO_CLVL), "" )
		cTipVerba := RetValSRV(SRO->RO_VERBA,SRO->RO_FILIAL,"RV_TIPOCOD")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Buscar valores atualizados das tarefas no dissidio retroativo e|
		//| na rescisao complementar.                                      |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( Type("lDissidio") # "U" .And. lDissidio ) .Or. ( Type("cCompl") # "U" .And. cCompl == "S" )
			If (nPosTab := fPosTab( cTab,cPerAtual,"=",2,SRO->RO_CODTAR,"=",4)) == 0
				nPosTab := fPosTab( cTab,Space(6),"=",2,SRO->RO_CODTAR,"=",4)
			EndIf
			If nPosTab > 0
				nTarTot := SRO->RO_VALTOT / SRO->RO_VALOR * fTabela(cTab,nPosTab,6)
			EndIf
		Else
			nTarTot	:= SRO->RO_VALTOT
		EndIf

		nQtdSem := SRO->RO_QTDSEM
		nQtdTar	:= SRO->RO_QUANT

		nHrsExt	:= nHrsFal	:=	nValHE	:=	nValHE	:=	nQtDTarM	:=	nDNTrab	:=	0
		cTarHE	:= cTarFal	:= ""

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Inclui todas as tarefas lancadas com seus valores originais    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nQtdTar > 0
			Aadd( aOrigTar, { SRO->RO_VERBA, nTarTot, nQtdSem, nQtdTar, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Novo tratamento para o calculo de professores.                 |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lNewProf

			nUltDia := f_UltDia( Stod( cPerAtual + "01" ) ) // Ultimo dia do mes

			// Ajuste da data de inicio da tarefa no mes
			dDtInTar := If( MesAno(SRO->RO_DATA) == cPerAtual, SRO->RO_DATA, Stod( cPerAtual + "01" ) )

			// Ajuste da data final da tarefa no mes
			dDtFiTar := If( Empty(SRO->RO_DATAATE) .Or. MesAno(SRO->RO_DATAATE) > cPerAtual, Stod( cPerAtual + StrZero( nUltDia, 2 ) ), SRO->RO_DATAATE )

			// Ajusta data final da tarefa de acordo com demissao
			If Type("dDataDem") # "U" .And. !Empty(dDataDem) .And. MesAno(dDataDem) == MesAno(dDtFiTar) .And. dDataDem < dDtFiTar
				dDtFiTar := dDataDem

				If dDtInTar > dDataDem
					dDtInTar := dDataDem + 1 // Adiciona 1 dia na data de inicio para tarefas iniciadas apos demissao para zerar calculo
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Calcula qtde. de dias da tarefa no mes						   |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nQtDTarM := dDtFiTar - dDtInTar + 1

			If nQtDTarM > 0

				nQtDTarM := If( nQtDTarM > nDiasC, nDiasC, nQtDTarM ) // Limitar a geracao das tarefas a 30 dias no mes
				If SRO->RO_TIPO $ "1/3" .or. (lPropTar .And. SRO->RO_TIPO $ "2/4")
					nQtDTarM -= ( Min(nDiasAfas,nDiasC) - nDiasMat )// Abater afastamentos dos dias da tarefa
				EndIf

				If nQtDTarM == nDiasP // RCF_DPERIO
					nQtDTarM := nDiasC
				EndIf
				nQtdSem		:= NoRound( SRO->RO_QTDSEM / nDiasC * nQtDTarM, MsDecimais(1) ) // Proporcionalizar qtde. semanas pela qtde. de dias da tarefa
				nQtdTar		:= NoRound( SRO->RO_QUANT / nDiasC * nQtDTarM, MsDecimais(1) ) // Proporcionalizar qtde. semanas pela qtde. de dias da tarefa
				nTarAux     := nTarTot
				nTarTot		:= nTarTot / nDiasC * nQtDTarM // Proporcionalizar tarefa total pela qtde. de dias da tarefa
				nHrsExt		:= SRO->RO_HRSEXT
				nHrsFal		:= SRO->RO_HRSFAL
			EndIf

			If ( ( nHrsExt + nHrsFal ) > 0 )
				If (nPosTab := fPosTab( cTab,cPerAtual,"=",2,SRO->RO_CODTAR,"=",4)) == 0
					nPosTab := fPosTab( cTab,Space(6),"=",2,SRO->RO_CODTAR,"=",4)
				EndIf
				If nPosTab > 0
					cTarHE	:= fTabela(cTab,nPosTab,9)
					cTarFal	:= fTabela(cTab,nPosTab,10)

					If nHrsExt > 0 .And. fIncide(cTarHE)
						nPos := aScan( aPdv, { |x| x[1] == cTarHE } )
						nValHE	:= nHrsExt * SRO->RO_VALOR * aPdv[ nPos, 2 ] / 100
					EndIf

					If nHrsFal > 0 .And. fIncide(cTarFal)
						nPos := aScan( aPdv, { |x| x[1] == cTarFal } )
						nValFal	:= nHrsFal * SRO->RO_VALOR * aPdv[ nPos, 2 ] / 100
					EndIf
				EndIf
			EndIf
		EndIf

		dbSelectArea( "SRO" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Inclui todas as tarefas lancadas (necessario p/Calculo do DSR) |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nQtdTar > 0 .Or. (nValHE + nValFal) > 0
            If (SRA->RA_CATFUNC $ "I*J")
				Aadd( aTarefas, { SRO->RO_VERBA, nTarTot, nQtdSem, nQtdTar, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
			Else
				dDtFimTar := If( !Empty(SRO->RO_DATAATE), SRO->RO_DATAATE, dDataAte )
				dDtFimTar := If( dDtFimTar > dDataAte, dDataAte, dDtFimTar )
				Aadd( aTarefas, { SRO->RO_VERBA, nTarTot, nQtdSem, nQtdTar, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal, dDtFimTar } )
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Totaliza tarefas por Verba+Centro de Custo (para Lanc. no SRC) |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPos := Ascan( aTarAux, { |X| X[1] == SRO->RO_VERBA .And. X[5] == cCCAtual .And. X[10] == cItAtual  .And. X[11] == cClAtual} )

			If lNewProf .and. nDiasMat > 0 .and. nTarTot > 0 .and. ( SRO->RO_TIPO $ "1/3" .or. (lPropTar .And. SRO->RO_TIPO $ "2/4") )
				nTarAux     := nTarAux / nDiasC * ( nQtDTarM - nDiasMat )
			Else
				nTarAux := nTarTot
			EndIf

			If nPos > 0
				aTarAux[nPos,02] += nTarAux
				aTarAux[nPos,03] += nQtdSem
				aTarAux[nPos,04] += nQtdTar
				aTarAux[nPos,12] += nQtDTarM
				aTarAux[nPos,13] += nHrsExt
				aTarAux[nPos,14] += nHrsFal
				aTarAux[nPos,17] += nValHE
				aTarAux[nPos,18] += nValFal
			Else
				Aadd( aTarAux, { SRO->RO_VERBA, nTarAux, nQtdSem, nQtdTar, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Totaliza tarefas por Verba+Centro de Custo (para Lanc. no SRC) |
		//| das horas-extras dos professores.                              |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nHrsExt > 0 .And. !Empty(cTarHE) .And. nValHE > 0
			nPos := Ascan( aFalHE, { |X| X[1] == cTarHE .And. X[5] == cCCAtual .And. X[10] == cItAtual  .And. X[11] == cClAtual} )
			If nPos > 0
				aFalHE[nPos,02] += nValHE
				aFalHE[nPos,03] += nQtdSem
				aFalHE[nPos,04] += nHrsExt
				aFalHE[nPos,12] += nQtDTarM
				aFalHE[nPos,13] += nHrsExt
				aFalHE[nPos,14] += nHrsFal
				aFalHE[nPos,17] += nValHE
				aFalHE[nPos,18] += nValFal
			Else
				Aadd( aFalHE, { cTarHE, nValHE, nQtdSem, nHrsExt, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Totaliza tarefas por Verba+Centro de Custo (para Lanc. no SRC) |
		//| das faltas dos professores.                                    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nHrsFal > 0 .And. !Empty(cTarFal) .And. nValFal > 0
			nPos := Ascan( aFalHE, { |X| X[1] == cTarFal .And. X[5] == cCCAtual .And. X[10] == cItAtual  .And. X[11] == cClAtual} )
			If nPos > 0
				aFalHE[nPos,02] += nValFal
				aFalHE[nPos,03] += nQtdSem
				aFalHE[nPos,04] += nHrsFal
				aFalHE[nPos,12] += nQtDTarM
				aFalHE[nPos,13] += nHrsExt
				aFalHE[nPos,14] += nHrsFal
				aFalHE[nPos,17] += nValHE
				aFalHE[nPos,18] += nValFal
			Else
				Aadd( aFalHE, { cTarFal, nValFal, nQtdSem, nHrsFal, cCCAtual, SRO->RO_DATA, cTipVerba, "SRO", SRO->RO_TIPO, cItAtual, cClAtual, nQtDTarM, nHrsExt, nHrsFal, cTarHE, cTarFal, nValHE, nValFal } )
			EndIf
		EndIf
	EndIf

	SRO->( dbSkip() )
EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Ponto de Entrada para alterar o conteudo do array aTarefas     |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("GPTAREFA")
	EXECBLOCK("GPTAREFA",.F.,.F.)
EndIf

If lNewProf .And. aScan( aTarAux, { |x| x[9] == "1" } ) == 0
	If Empty( aErrProc[1] )
		aAdd( aErrProc[1], PadR( OemtoAnsi(STR0029), 16 ) + PadR( OemtoAnsi(STR0030), 13 ) + OemtoAnsi(STR0031) + CRLF )  //"Filial" ### "Matrícula" ### "Nome"
	EndIf

	aAdd( aErrProc[1], PadR( SRA->RA_FILIAL, 16 ) + PadR( SRA->RA_MAT, 13 ) + SRA->RA_NOME + CRLF )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Grava as Tarefas em aPd ou no Movimento Mensal - SRC		   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("lUtiMultiV") == "U" .And. cGrava # Nil .And. Len( aTarefas ) > 0
	If cGrava = "S"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| X[6]="SRC" indica que a tarefa ja esta em aPD (nao sera gerada)|
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipoRot $ "3*4*5*6*"  // FER / RES / 131 / 132
			AeVal( aTarAux	, { |X| If(!(X[8]$"SRC*RGB") .And. x[9] = "1", IncorpSal(x[02]), (If(cTipoRot $ "3*4" ,FMatriz(X[01],  X[02],X[04],    ,X[5],"V"  ,     ,    ,    ,    ,       ,    ,X[3]   ,X[10],X[11]), ""))) } )
	   		AeVal( aFalHE	, { |X| If(!(X[8]$"SRC*RGB") .And. x[9] = "1", IncorpSal(x[02]), "") } )
		Else
			AeVal( aTarAux	, { |X| If(!(X[8]$"SRC*RGB"), FMatriz(X[01],  X[02],X[04],    ,X[5],"V"  ,     ,    ,    ,    ,       ,    ,X[3]   ,X[10],X[11]), "") } )
	   		AeVal( aFalHE	, { |X| If(!(X[8]$"SRC*RGB"), FMatriz(X[01],  X[02],X[04],    ,X[5],"V"  ,     ,    ,    ,    ,       ,    ,X[3]   ,X[10],X[11]), "") } )
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fDsrTarefa³ Autor ³ Emerson Rosa de Souza ³ Data ³ 25.07.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo do DSR sobre as tarefas                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fDsrTarefa(aTarefas,aDsrTarefa,cGrava)
Local nValorDsr   := 0
Local nNroTarefa  := 0
Local nDiasTrab	  := 0
Local aDsrAux     := {}
Local cCcGerados  := ""
Local nCnt, nCnt1

aDsrTarefa := {}

If Len(aTarefas) > 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Soma os valores da Tarefa por Data e por Centro de Custo       |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCnt := 1 To Len(aTarefas)
		//-- O DSR de tarefeiro eh o resultado da soma dos valores das tarefas produzidas na semana dividido pelos
		//-- dias efetivamente trabalhados.
		//-- Ex: No. tarefas executadas na semana: 25
		//-- 	 Dias trabalhados na semana: 6
		//--     Valor da tarefa: R$ 10,00
		//--     Salario: 25 * R$ 10,00 = R$ 250,00
		//--     RSR: R$ 250,00 / 6 = R$ 41,66
		If ( SRA->RA_CATFUNC == "T" )
			nPos := Ascan( aDsrAux , { |X| X[2] == aTarefas[nCnt,5] } )
			If nPos > 0
				aDsrAux[nPos,1] += aTarefas[nCnt,2]
				aDsrAux[nPos,3] := If( aTarefas[nCnt,06] < aDsrAux[nPos,03], aTarefas[nCnt,06], aDsrAux[nPos,03] )
				aDsrAux[nPos,4] := If( aTarefas[nCnt,19] > aDsrAux[nPos,04], aTarefas[nCnt,19], aDsrAux[nPos,04] )
			Else
				Aadd( aDsrAux , { aTarefas[nCnt,2], aTarefas[nCnt,5], aTarefas[nCnt,6], aTarefas[nCnt,19] } )
			EndIf
		Else
			nPos := Ascan( aDsrAux , { |X| X[2] == aTarefas[nCnt,5] .And. X[3] == aTarefas[nCnt,6] } )
			If nPos > 0
				aDsrAux[nPos,1] += aTarefas[nCnt,2]
			Else
				Aadd( aDsrAux , { aTarefas[nCnt,2], aTarefas[nCnt,5], aTarefas[nCnt,6] } )
			EndIf
		EndIf
	Next nCnt
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Calcula o DSR por Centro de Custo 							   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCnt1 := 1 To Len(aDsrAux)
		If !(aDsrAux[nCnt1,2] $ cCcGerados)
			nValorDsr  := nNroTarefa := 0
			cCcGerados += aDsrAux[nCnt1,2]+"*"
			Aeval( aDsrAux, {|X| If( X[2]==aDsrAux[nCnt1,2], nValorDsr  += X[1], "") } )
			//-- Inicializacao para nao calcular
			nDiasTrab := 0
			nDiasDSR  := 0
			If ( SRA->RA_CATFUNC == "T" )
			    //-- Verifica a existencia dos identificadores de dias Trabalhados e de Descanso
			    //-- Para obter as informacoes
			    If ( aCodfol[989,1] # Space(3) .and. aCodfol[990,1] # Space(3))
					If (nPos :=  Ascan(aPd, { |X| X[1] = aCodfol[989,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] # "C"})) > 0
						nDiasTrab :=  aPd[nPos,4]
					EndIf
					If (nPos :=  Ascan(aPd, { |X| X[1] = aCodfol[990,1] .And. X[3] = cSemana .And. X[9] # "D" .And. X[7] # "C"})) > 0
						nDiasDSR :=  aPd[nPos,4]
					EndIf
				EndIf

				//-- Se nao existir dias trabalhados, considera os dias do periodo como trablahados
				If Empty(nDiasTrab)
					//-- Assume o pagamento de 1 dia de DSR para o periodo
					nDiasDSR	:= 1
					nDiasTrab 	:= ( DateDiffDay( aDsrAux[nCnt1,4], aDsrAux[nCnt1,3] ) + 1 )
					Aadd(  aDsrTarefa , { aCodfol[33,1] , Round( (nValorDsr / nDiasTrab) * nDiasDSR, 2 ) , nDiasDSR, aDsrAux[nCnt1,2] } )
				Else
					Aadd(  aDsrTarefa , { aCodfol[33,1] , Round( (nValorDsr / nDiasTrab) * nDiasDSR, 2 ) , nDiasDSR, aDsrAux[nCnt1,2] } )
				EndIf
			Else
				Aeval( aDsrAux, {|X| If( X[2]==aDsrAux[nCnt1,2], nNroTarefa ++     , "") } )
				Aadd(  aDsrTarefa , { aCodfol[33,1] , Round( nValorDsr / nNroTarefa, 2 ), nNroTarefa, aDsrAux[nCnt1,2] } )
			EndIf
		EndIf
	Next nCnt1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Grava o DSR em aPd ou no Movimento Mensal - SRC				   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cGrava # Nil .And. Len( aDsrTarefa ) > 0
		If cGrava = "S"
			AeVal( aDsrTarefa , { |X| FMatriz(X[1],X[2],X[3], ,X[4],"V",,,,,,,X[3]) } )
		EndIf
	EndIf
EndIf

Return Nil


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FMatriz  ³ Autor ³ Mauro                 ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao Para Adicionar Verbas na Matriz                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCod       =  Codigo da Verba                              ³±±
±±³          ³ nValor     =  Valor da Verba                               ³±±
±±³          ³ nHoras     =  Horas da Verba  --   Opcional                ³±±
±±³          ³ cSem       =  Semana da Verba --   Opcional                ³±±
±±³          ³ cCct       =  Centro de Custo --   Opcional                ³±±
±±³          ³ cTip1      =  Tipo da Verba   --   Horas Dias Valor        ³±±
±±³          ³ cTip2      =  Origem da Verba --   Opcional                ³±±
±±³          ³ nPar       =  Parcela da Verba--   Opcional                ³±±
±±³          ³ cDel       =  se Deletada "D" --   Opcional                ³±±
±±³          ³ cMes       =  Data de Pagto da Verba                       ³±±
±±³          ³ lAltera    =  Altera os conteudos mesmo que Verba ja exista³±±
±±³          ³               em aPD                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fMatriz(uParam1,uParam2,uParam3,uParam4,uParam5,uParam6,uParam7,uParam8,uParam9,uParam10,uParam11,uParam12,uParam13,uParam14,uParam15,uParam16, uParam17, uParam18, uParam19, uParam20, uParam21, uParam22, uParam23, uParam24, uParam25, uParam26, uParam27, uParam28)/*
Function fMatriz(cCod, nValor, nHoras, cSem, cCct, cTip1, cTip2, nPar, cDel, dMes, lAltera, cSeq, nQtdSem, cItCt, cClCt, cNumID, lEmpres, cIdCmpl, dDtaRef, lPropDia, nValInteg, lNewValor, cConvoc, lIncorp, cLotPLS, cCodRda, cFilMat, cCodBenOP)*/

Local lItemClVl := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local cCod		:= uParam1
Local nValor	:= uParam2
Local nHoras 	:= If(uParam3 = Nil , 0.00 , uParam3)
Local cSem   	:= If(uParam4 = Nil , cSemana , uParam4)
Local cCct   	:= If(uParam5 = Nil , If (!lDissidio, Sra->Ra_cc, fDissCC()),uParam5)
Local cTip1  	:= If(uParam6 = Nil , RetValSrv(cCod,SRA->RA_FILIAL,"RV_TIPO ") , uParam6) //Fdesc("SRV",cCod,"RV_TIPO ",,xfilial("SRV",SRA->RA_FILIAL),1), uParam6)
Local cTip2  	:= If(uParam7 = Nil .Or. uParam7 = " ", "C" , uParam7)
Local nPar   	:= If(uParam8 = Nil , 0 , uParam8)
Local cDel   	:= If(uParam9 = Nil , " " , uParam9)
Local lAltera	:= If(uParam11 = Nil, .F. , uParam11)
Local cSeq 	    := If(uParam12 = Nil," ",uParam12)
Local nQtdSem   := If(uParam13 = Nil, 0, uParam13)
Local cIdCmpl	:= If(uParam18 == Nil,"",uParam18)
Local cItCt
Local cClCt
Local dMes
Local dDtaRef
Local lEmpres	:= If(uParam17 == Nil, .F., uParam17)
Local lTemEmpC  := SRK->( FieldPos( "RK_EMPCONS" ) # 0 ) //Campo so existe no Brasil, mantido fieldpos
Local lPropDia	:= .F.
Local nValInteg := 0
Local nPosPdv	:= 0
Local nPosSB	:= 0
Local nBaseAux	:= 0
Local nOrdAux	:= 0
Local cCodCor	:= ""
Local nPosOrig	:= 0
Local cConvoc	:= ""
Local lIncorp
Local cLotPLS
Local cCodRda
Local cCodBenOP	:= ""

// Var. Complemento da 2a. parcela em Folha
Local nP132Inf	:= 0
Local lPdCmp132	:= cTipoRot == "6" .and. lCalcFol .and. Type("aPdFol") # "U"

DEFAULT uParam14 := If(lItemClVl,SRA->RA_ITEM,'')
DEFAULT uParam15 := If(lItemClVl,SRA->RA_CLVL,'')
DEFAULT uParam10 := CtoD("//")
DEFAULT uParam16 := ""
DEFAULT uParam19 := CtoD("//")
DEFAULT uParam20 := .F.
DEFAULT uParam21 := 0
DEFAULT uParam22 := .F.
DEFAULT uParam23 := GetConvocCalc()
DEFAULT uParam24 := RetValSRV(cCod, SRA->RA_FILIAL, "RV_INCORP") == "S"
DEFAULT uParam25 := ""
DEFAULT uParam26 := ""
DEFAULT uParam27 := SRA->RA_FILIAL + SRA->RA_MAT
DEFAULT uParam28 := GetBenOP()

cItCt 	  := uParam14
cClCt 	  := uParam15
dMes 	  := uParam10
cNumID	  := uParam16
dDtaRef   := If (!Empty(uParam19), uParam19, If(DDATAATE = Nil , CtoD("//"), DDATAATE))
lPropDia  := uParam20
nValInteg := uParam21
cTip1	  := If(Empty(cTip1),"V",cTip1)
lNewValor := uParam22
cConvoc	  := uParam23
lIncorp   := uParam24
cLotPLS	  := uParam25
cCodRda	  := uParam26
cFilMat   := uParam27
cCodBenOP := uParam28

If !(cPaisLoc == "BRA") .and. FindFunction("fXMatriz")
	fXMatriz(uParam1,uParam2,uParam3,uParam4,uParam5,uParam6,uParam7,uParam8,uParam9,uParam10,uParam11,uParam12,uParam13,uParam14,uParam15,uParam16)
	Return
EndIf

// Não grava Valor ou Hora negativa e nao grava Valor e hora simultaneamente nulos.
// A gravacao de informacao negativa sera PERMITIDA SE for proveniente de RESCISAO (cTip2 igual a I ou R)
If cCod # Nil .And. cCod # "   " .And. nValor # Nil .And. ;
	( nValor >= 0.00 .or. ( nValor < 0.00 .and. cTip2 $ ("IR") )) .and. ;
	( nHoras >= 0.00 .or. ( nHoras < 0.00 .and. cTip2 $ ("IR") )) .and.;
    ( !(Empty(nValor) .and. Empty(nHoras) ) .or. (cTipoRot == "4" .and. cCompl == "S") )

	//--Verifica se a verba existe no cadastro de verbas e
	//--Carrega na Matriz de Incidencias as Verbas
	If FIncide(cCod)

		nPos := Ascan(aPd, { |X| X[1] == cCod .And. X[3] = cSem .And. X[2] = cCct .And. x[11]= cSeq .and. x[13] = cItCt .and. x[14] = cClCt .and. (x[15] = cNumID .Or. x[7] == "I") } )

		// Tratamento para recalcular as verbas de 13º na apuração de sua diferença em folha,
		// para os casos em que as verbas de 13o. foram informadas (origem "I") no roteiro '132'
		// e não foram informadas no roteiro 'FOL'
		If lPdCmp132
			nP132Inf := Ascan(aPdFol, { |X| X[1] == cCod .And. X[3] = cSem .And. X[2] = cCct .And. x[11]= cSeq .and. x[13] = cItCt .and. x[14] = cClCt .and. (x[15] = cNumID .Or. x[7] == "I") } )
		EndIf

		If nPos = 0

			nValInteg 	:= If(nValInteg == 0,nValor,nValInteg)
			nPosPdv 	:=  Ascan(aPdv, { |X| X[1] = cCod } )
			If Len(aPdv) > 0 .And. nPosPdv > 0 .And. aPdv[nPosPdv][18] == "S" .And. !( ( IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD") ) .And. cTip2 $ "I/G" .And. ( (aPdv[nPosPdv, 37] $ "0036/1281/" .And. SRA->RA_PERICUL == 0) .Or. (aPdv[nPosPdv, 37] $ "0037/0038/0039/1282/" .And. SRA->RA_INSMAX == 0) ) .And. (aPdv[nPosPdv, 7 ] != "N " .Or. aPdv[nPosPdv, 7 ] != "N ") )//Não efetua incorporação na Provisão caso seja periculosidade/insalubridade, funcionário não tem o adicional configurado no cadastro, a verba foi incluída/gerada manualmente e possui configuração para médias
				// Não incorpora novamente se for uma verba de origem FERIAS
				If !(cTipoRot <> "3" .And. cTip2 $ "K*F") .And. lIncorp .And. !IsInCallStack("S_CMEDFER") .And. !IsInCallStack("fEncarCc") .And. !IsInCallStack("S_GRADIFER") .And. !IsInCallStack("S_GRVADI13");
					.And. !(Len(aCodFol) > 0 .And. aPdv[nPosPdv][1] $ (aCodFol[1296,1]+"/"+aCodFol[1297,1]+"/"+aCodFol[1298,1]+"/"+aCodFol[1299,1]) .And. aPdv[nPosPdv][18] == 'S');// Não incorporar novamente pela rotina de buscar médias, pois o SalHora já está incorporado.
					.And. (SRA->RA_TPCONTR != "3" .Or. cSem == cSemana)//não incorporar verba de semana anterior de intermitente
					//Se tiver dias trabalhados, pula o processamento abaixo nas fórmulas de gravação dos adicionais sobre maternidade porque a geração do adicional sobre o salário já incorpora o valor total
					If !( cTipoRot == "1" .And. DiasTrab > 0 .And. (IsInCallStack("S_GCONFMAT") .Or. IsInCallStack("S_GTRANMAT") .Or. IsInCallStack("S_GPERIMAT") .Or. IsInCallStack("S_GINSMAT")) )
						//Verifica se a verba é de desconto, se for deverá ser abatido o valor e não somado
						If aPdv[nPosPdv][27] == "2"
							IncorpSal(nValor,,.T.)
						Else
							IncorpSal(nValor)
						EndIf
					EndIf
				EndIf
			EndIf

			If lPropDia .And. If(SRA->RA_TIPOPGT == "S" .And. SRA->RA_CATFUNC == "S", DiasTrab + DiasDSR + nDiasPg - nDiasMat <> nDiasC , DiasTrab + nDiasPg - nDiasMat - nDPrgSalMa <> nDiasC )
				fPropor(@nValor,@nHoras,cTip1,nValInteg,nDiasC)
				//Dias proporcionais Periculosidade
				If SRA->RA_TPCONTR == "3" .And. cTipoRot == "4" .And. aPdv[nPosPdv][1] == aCodFol[36,1] .And. !Empty(aConvocacao[5])
					nHoras := aConvocacao[5]
				EndIf
			EndIf

			nOrdGrPd++ //Mnemonico incrementado a cada novo item incluido no aPd

			If ( nPosSB := aScan(aSalBase, { |X| cCod $ X[1] } ) ) == 0
				If IsInCallStack( "fCarMvto" ) .Or. IsInCallStack( "S_GRVSAL" )
					nBaseAux := Salario
				Else
					nBaseAux := If(Type("SalMes") == "N",SalMes,nValor)
				EndIf
				nOrdAux  := nOrdGrPd
			Else
				nBaseAux := aSalBase[nPosSB,2]
				nOrdAux  := aSalBase[nPosSB,3]
				nOrdGrPd--
			EndIf

			Aadd( aPd, { cCod, cCct, cSem, nHoras, Round(nValor, 2), cTip1, cTip2, nPar, cDel, dMes, cSeq, nQtdSem, cItCt, cClCt, cNumID, lEmpres, cIdCmpl, dDtaRef, nValInteg, nBaseAux, AllTrim(STR(nOrdAux)), cConvoc, cLotPLS, cCodRDA, cFilMat, cCodBenOP } )

		ElseIf	(nPos # 0 .And. cDel # "D" .And. ( aPd[nPos,9] = "D" .OR. lAltera = .T. ) .And. aPd[nPos,7] # "I") .Or. aPd[nPos,9] == "D" .Or.;
				(lPdCmp132 .And. nP132Inf == 0 .And. cDel # "D")

			nValInteg 	:= If(nValInteg == 0,nValor,nValInteg)
			nPosPdv 	:=  Ascan(aPdv, { |X| X[1] = cCod } )
			If Len(aPdv) > 0 .and. nPosPdv > 0 .and. aPdv[nPosPdv][18] == "S"
				// Não incorpora novamente se for uma verba de origem FERIAS
				If !(cTipoRot <> "3" .And. cTip2 == "K") .And. !( !Empty(aPdv[nPosPdv][37]) .And. cTip2 == "I" ) .And. lIncorp .and. !IsInCallStack("fEncarCc") //Não incorpora se estiver rateando pois a verba já foi incorporada no inicio do processo.
					IncorpSal(aPd[nPos,5],nValor)
				EndIf
			EndIf

			If lPropDia .AND. DiasTrab > 0 .AND. DiasTrab + nDiasPG <> nDiasC
				fPropor(@nValor,@nHoras,cTip1,nValInteg,nDiasC)
			EndIf

			aPd[nPos,5]  := Round(nValor,2)
			aPd[nPos,4]  := nHoras
			aPd[Npos,9]  := cDel
			aPd[Npos,10] := dMes
			aPd[nPos,6]  := cTip1
			aPd[nPos,7]	 := cTip2
			aPd[nPos,12] := nQtdSem
			aPd[nPos,19] := nValInteg
			//-- Tratamento para desconto do emprestimo consignado
			If (lTemEmpC , aPd[nPos,16] := lEmpres , )

			// Atualiza Valor Base
			nPosSB := aScan(aSalBase, { |X| cCod $ X[1] } )
			If nPosSB > 0
				If aPd[nPos,20] <> aSalBase[nPosSB,2]
					aPd[nPos,20] := aSalBase[nPosSB,2]
					aPd[nPos,21] := AllTrim(STR(aSalBase[nPosSB,3]))
				EndIf
			EndIf
			If Len(aPd[nPos]) >= 25
				aPd[nPos,25] := cFilMat
			EndIf
		ElseIf lNewValor
			nValor := aPd[nPos,5]
		EndIf
	EndIf

	cCodCor := RetValSrv(cCod,SRA->RA_FILIAL, "RV_CODCORR" )
	If (ISINCALLSTACK("S_CADIFFER") .Or. ISINCALLSTACK("S_INSSFOL") .Or. ISINCALLSTACK("S_CALAFAS") ) .And. !Empty(cCodCor) .And. FIncide(cCodCor) .And. cTipoRot $ "1*4"

		nPos := Ascan(aPd, { |X| X[1] == cCodCor .And. X[3] = cSem .And. X[2] = cCct .And. x[11]= cSeq .and. x[13] = cItCt .and. x[14] = cClCt .and. (x[15] = cNumID .Or. x[7] == "I") } )
		nPosOrig := Ascan(aPd, { |X| X[1] == cCod .And. X[3] = cSem .And. X[2] = cCct .And. x[11]= cSeq .and. x[13] = cItCt .and. x[14] = cClCt .and. (x[15] = cNumID .Or. x[7] == "I") } )

		If nPos = 0
			aAdd( aPd, aClone(aPd[nPosOrig]) )
			aPd[Len(aPd)][1] := cCodCor
		ElseIf (nPos # 0 .And. cDel # "D" .And. ( aPd[nPos,9] = "D" .OR. lAltera = .T. ) .And. aPd[nPos,7] # "I") .Or. aPd[nPos,9] == "D"

			aPd[nPos,5]  := aPd[nPosOrig,5]
			aPd[nPos,4]  := aPd[nPosOrig,4]
			aPd[Npos,9]  := aPd[nPosOrig,9]
			aPd[Npos,10] := aPd[nPosOrig,10]
			aPd[nPos,6]  := aPd[nPosOrig,6]
			aPd[nPos,7]	 := aPd[nPosOrig,7]
			aPd[nPos,12] := aPd[nPosOrig,12]
			aPd[nPos,19] := aPd[nPosOrig,19]
			//-- Tratamento para desconto do emprestimo consignado
			If (lTemEmpC , aPd[nPos,16] := aPd[nPosOrig,16] , )
		ElseIf lNewValor
			nValor := aPd[nPosOrig,5]
		EndIf
	EndIf
EndIf

Return nValor

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FIncide  ³ Autor ³ Mauro                 ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inclui a Verba que foi adicionada na matriz de verba na    ³±±
±±³          ³ Matriz de Incidencia                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCod       =  Codigo da Verba                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FIncide(cCod)
Local nPos 		:= 0
Local lRet 		:= .T.
Local cMainTmp	:= "SRV"
Local aArea

Static lCodDsr  := SRV->( ColumnPos("RV_CODDSR") ) > 0
Static lBsCCivi := SRV->( ColumnPos("RV_BSCCIVI") ) > 0
Static lBasCal  := SRV->( ColumnPos("RV_BASCAL") ) > 0
Static lTCMARG  := SRV->( ColumnPos("RV_TCMARG") ) > 0

nPos := ASCAN(aPdv, { |Y| Y[1]=cCod })

If nPos = 0

	aArea		:= GetArea()

	(cMainTmp)->(DbSetOrder(1))

	lTemPd := (cMainTmp)->(MsSeek(xFilial("SRV",SRA->RA_FILIAL) + cCod))//PosSrv(cCod,SRA->RA_FILIAL)

	If lTemPd

		Aadd(aPdv,{cCod,;																//  1-Codigo
		If ((cMainTmp)->RV_PERC > 0,(cMainTmp)->RV_PERC,100),;                          //  2-Percentual da Verba
								         		(cMainTmp)->RV_CODCORR,;				//  3-Codigo Correspondente
		If (Empty((cMainTmp)->RV_INSS)	    ,"N",(cMainTmp)->RV_INSS)   ,;  			//  4-Incidencia Base INSS
		If (Empty((cMainTmp)->RV_IR)  	    ,"N",(cMainTmp)->RV_IR)     ,;  			//  5-Incidencia Base IR
		If (Empty((cMainTmp)->RV_FGTS)	    ,"N",(cMainTmp)->RV_FGTS)   ,;  			//  6-Incidencia Base FGTS
		If (Empty((cMainTmp)->RV_MED13)		,"N",(cMainTmp)->RV_MED13)  ,;  			//  7-Incidencia Media 13o
		If (Empty((cMainTmp)->RV_MEDFER) 	,"N",(cMainTmp)->RV_MEDFER) ,;  			//  8-Incidencia Media Ferias
		If (Empty((cMainTmp)->RV_PERICUL) 	,"N",(cMainTmp)->RV_PERICUL) ,;  			//  9-Incidencia Base Periculosidade
		If (Empty((cMainTmp)->RV_INSALUB) 	,"N",(cMainTmp)->RV_INSALUB) ,;  			// 10-Incidencia Base Insalubridade
		If (Empty((cMainTmp)->RV_REFFER)  	,"N",(cMainTmp)->RV_REFFER)  ,;  			// 11-Se Refere a Ferias
		If (Empty((cMainTmp)->RV_REF13)  	,"N",(cMainTmp)->RV_REF13)  ,;  			// 12-Se Refere a 13o Salario
		If (Empty((cMainTmp)->RV_ADIANTA) 	,"N",(cMainTmp)->RV_ADIANTA) ,;  			// 13-Se Refere a Adiantamento
		If (Empty((cMainTmp)->RV_RAIS)  	,"N",(cMainTmp)->RV_RAIS)   ,;  			// 14-Incidencia para RAIS
		If (Empty((cMainTmp)->RV_DIRF)  	,"N",(cMainTmp)->RV_DIRF) 	 ,;  			// 15-Incidencia para DIRF
		If (Empty((cMainTmp)->RV_DSRHE) 	,"N",(cMainTmp)->RV_DSRHE)  ,;  			// 16-Incidencia para DSR S/ Horas
		If (Empty((cMainTmp)->RV_HE)  	    ,"N",(cMainTmp)->RV_HE)     ,;  			// 17-Se e Verba de Hora Extras
		If (Empty((cMainTmp)->RV_INCORP)  	,"N",(cMainTmp)->RV_INCORP)  ,;  			// 18-Se a Verba Incorpora Salario
		If (Empty((cMainTmp)->RV_ADICTS)  	,"N",(cMainTmp)->RV_ADICTS)  ,;  			// 19-Verba Adic. Tempo Servico
		If (Empty((cMainTmp)->RV_SINDICA) 	,"N",(cMainTmp)->RV_SINDICA) ,;  			// 20-Incidencia Base Contrib. Sindical
		If (Empty((cMainTmp)->RV_SALFAMI) 	,"N",(cMainTmp)->RV_SALFAMI) ,;  			// 21-Incidencia Base Sal. Familia
		If (Empty((cMainTmp)->RV_SEGVIDA) 	,"N",(cMainTmp)->RV_SEGVIDA) ,;  			// 22-Incidencia Base Seguro Vida
		If (Empty((cMainTmp)->RV_MEDAVI)  	,"N",(cMainTmp)->RV_MEDAVI)  ,;  			// 23-Incidencia Media Aviso Previo
		If (Empty((cMainTmp)->RV_CONVCOL) 	,"N",(cMainTmp)->RV_CONVCOL) ,;  			// 24-Incidencia Base Convencao Coletiva
		If (Empty((cMainTmp)->RV_DEDINSS) 	,"N",(cMainTmp)->RV_DEDINSS) ,;  			// 25-Verba Deduz da Guia INSS
		If (Empty((cMainTmp)->RV_MEDREAJ) 	,"N",(cMainTmp)->RV_MEDREAJ) ,;  			// 26-Se e Media Reajustavel
		If (Empty((cMainTmp)->RV_TIPOCOD) 	,"3",(cMainTmp)->RV_TIPOCOD) ,;  			// 27-Tipo do Codigo 1=Prov.,2=Desc.,3=Base
		If (Empty((cMainTmp)->RV_PENSAO)	,"N",(cMainTmp)->RV_PENSAO) ,;  			// 28-Incidencia para Pensao Alimenticia
		If (Empty((cMainTmp)->RV_DSRPROF)	,"N",(cMainTmp)->RV_DSRPROF),; 				// 29-Incidencia para DSR Professores
		If (Empty((cMainTmp)->RV_HRSATIV)	,"N",(cMainTmp)->RV_HRSATIV),; 				// 30-Incidencia para Horas Atividade Professores
		If (Len(AllTrim((cMainTmp)->RV_TAREFA))#3,"   ",(cMainTmp)->RV_TAREFA),;		// 31-Codigo da Tarefa
		If (lCodDsr .and. Len(AllTrim((cMainTmp)->RV_CODDSR)) == 3,(cMainTmp)->RV_CODDSR, "   "),; 			// 32-Codigo DSR
		If (!lBsCCivi .OR. Empty((cMainTmp)->RV_BSCCIVI),"2",(cMainTmp)->RV_BSCCIVI),; 	// 33-Incidencia Base Construção civil
		If (!lBasCal .OR. Empty((cMainTmp)->RV_BASCAL),"1",(cMainTmp)->RV_BASCAL),;   	// 34-Base para calculo (Salario Base ou Salario Incorporado)
		If (Empty((cMainTmp)->RV_INSSFER)	,"2",(cMainTmp)->RV_INSSFER),; 				// 35-Se incide INSS nas ferias
		If (Empty((cMainTmp)->RV_CODMSEG)	,"2","1" ),; 								// 36-Se eh verba de mes seguinte, toda verba de mes seguinte deve ter a sua equivalente definidia no RV_CODMSEG
		If (Empty((cMainTmp)->RV_CODFOL)	,"",(cMainTmp)->RV_CODFOL ),;				// 37-CODFOL
		If (!lTCMARG .OR. Empty((cMainTmp)->RV_TCMARG), "2", (cMainTmp)->RV_TCMARG)}) 	// 38-Se verba será considerada no cálculo da margem consignável do funcionário. Valores: 1=sim, 2=não. Projeto TOTVS Consignado
	Else
		lRet := .F.
	EndIf

	RestArea( aArea )

EndIf

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SomaInc  ³ Autor ³ Mauro                 ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Soma  das Verbas da Matriz com Incidencia para o Codigo    ³±±
±±³          ³ da Matriz de Incidencia                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aPd        =  Codigo da Verba                              ³±±
±±³          ³ nElem      =  Elemento da Matriz de Incidencia a ser Somado³±±
±±³          ³ nBas       =  Variavel a Ser Somado Passar com Ref.        ³±±
±±³          ³ nCond1     =  Condicao 1 para Soma   Opcional        Opc.  ³±±
±±³          ³ nPar1      =  Paramentro de Comparacao da Condicao 1 Opc.  ³±±
±±³          ³ nCond2     =  Condicao 2 para Soma                   Opc.  ³±±
±±³          ³ nPar2      =  Paramentro de Comparacao cond. 2       Opc.  ³±±
±±³          ³ nMes       =  Caso deseje somar det. Mes                   ³±±
±±³          ³ lSemana    =  .T. soma todas as semanas                    ³±±
±±³          ³               .F. soma somente a semana do c lculo         ³±±
±±³          ³ aCodFol    =  Array das Verbas                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SomaInc(aPd, nElem, nBas, nCond1, cPar1, nCond2, cPar2, nMes, lSemana, aCodFol, SalHora, nHorInc, lChkMes, nPosHora, nPosVal, lCarInc, lPensao)

Local nValor 	:= nValorP := nValorD := nHoras := nValAux := 0.00
Local lTemEmpC  := SRK->( FieldPos( "RK_EMPCONS" ) # 0 )
Local cFaltas	:= aCodfol[54,1]+"/"+aCodfol[242,1]+"/"+aCodfol[244,1]+"/"+aCodfol[55,1]+"/"+aCodfol[243,1]+"/"+aCodfol[245,1]

DEFAULT lChkMes	 := .T.
DEFAULT lCarInc	 := .F.
DEFAULT nPosHora := 4
DEFAULT nPosVal	 := 5
DEFAULT lPensao	 := .F.

DEFAULT __lMemCalc 	:= (cPaisLoc == "BRA" .And. fMemCalc())

If SalHora = Nil
    Salhora := 0
EndIf
If nBas = Nil
   nBas = 0
EndIf
If nHorInc = nil
   nHorInc = 0
EndIf

// Quando verba for Deletada ou quando for emprestimo consignado nao Soma
If ( aPd[9] = "D" .Or. ( lTemEmpC .And. aPd[16] == .T. ) )
	Return
EndIf

lSemana := If( lSemana = Nil,.T.,lSemana )

//--Quando nao for semanalista  nao somar semana diferente da selecionada.
If !lSemana
	If !Empty( aPd[3] ) .And. aPd[3] # cSemana
	  Return
	EndIf
Else  //--Quando for para somar tudo nao somar semana superior ao calculo.
	If aPd[3] > cSemana
	  Return
	EndIf
EndIf

nPos := Ascan(aPdv, { |Y| Y[1] = aPd[1] })

If nPos == 0 .and. lCarInc //Se não encontrou as incidências da verba e é contrato intermitente, busca as incidências.
	fIncide(aPd[1])
	nPos := Ascan(aPdv, { |Y| Y[1] = aPd[1] })
EndIf

If (nPos > 0 .And. nElem > 2 .And. aPdv[nPos,nElem] $ "1S" ) .Or. ;
	(nPos > 0 .And. (nElem = 0 .Or. nElem = 1 .Or. nElem = 2))

	nValAux := aPd[nPosHora]

	If nValAux == 0 .and. nPosHora <> 4 //Tratamento para o caso de existir customizacoes que alimentam o aPD sme informar o novo campo
		nValAux := aPd[4]
	EndIf

    // Somar para  Peric. e Insal. o valor das horas sem acrescimo da verba
    If (nElem = 9 .And. GetMvRH("MV_PERICVH") = 'H' .And. nValAux > 0.00 .And. aPd[6] = 'H' .And. ( aCodFol[35,1] == aPd[1] .or. aPdv[nPos,17] = 'S' .Or. aPd[1] $ cFaltas .Or. aPdv[nPos,9] == 'S')) .Or.;
       (nElem= 10 .And. GetMvRH("MV_INSALVH") = 'H' .And. nValAux > 0.00 .And. aPd[6] = 'H' .And. ( aCodFol[35,1] == aPd[1] .or. aPdv[nPos,17] = 'S' .Or. aPd[1] $ cFaltas .Or. aPdv[nPos,10] == 'S'))
		If lValHorAdic
			nValAux := aPd[4] * If( aPdv[nPos,2] > 0, aPdv[nPos,2] / 100, 1 )
		Else
			nValAux := aPd[4]
		EndIf
       //-- Provento
       If aPdv[nPos,27] == '1'
           nValor := nValAux * Salhora
		//--Desconto
       ElseIf aPdv[nPos,27]=='2'
           nValor := (nValAux * Salhora) * (-1)
       EndIf
       nHoras := If (aPd[6] = 'H',nValAux,0)   // Horas da Verba
    //--Provento
    ElseIf aPdv[nPos,27] == '1' .or. ( (aPd[1] == AcodFol[007,1] ) .and. cTipoRot=="2" .and. (Type("lUtiMultiV")<> "U" .and. lUtiMultiV ) ) .Or. (cTipoRot == "1" .And. nElem == 5 .And. aPd[1] == aCodFol[1660,1])
		nValor  := aPd[nPosVal]
		nValorP := aPd[nPosVal]
        nHoras := If (aPd[6] = 'H',nValAux,0)   // Horas da Verba
    //--Desconto
    ElseIf aPdv[nPos,27] == '2'
		nValor  := aPd[nPosVal] * (-1)
		nValorD := aPd[nPosVal]
        nHoras := If (aPd[6] = 'H',nValAux * (-1),0)   // Horas da Verba
	//--Codigos de Deducao Inss p/Base de Ir
    ElseIf ( aPd[1] = aCodFol[167,1] .Or. aPd[1] = aCodFol[168,1] .Or. aPd[1] = aCodFol[169,1] .Or. aPd[1] = aCodFol[0624,1] ) .And. ( nElem # 0 )
		nValor  := aPd[nPosVal] * (-1)
	//--Codigos de Deducao Inss p/Base de Ir validos somente em 2004
    ElseIf ( aPd[1] = aCodFol[408,1] .Or. aPd[1] = aCodFol[409,1] .Or. aPd[1] = aCodFol[410,1] ) .And. ( nElem # 0 )
		nValor  := aPd[nPosVal] * (-1)
	Else
		nValor := nValorP := nValorD := 0.00
    EndIf

	// Verifica se Mes deve ser Igual ao do Lancamento e sempre considera adiantamento
	If aPd[10] # Nil .And. ! Empty( aPd[10] ) .And. lChkMes
		If nMes # Nil .And. nMes # MONTH(aPd[10]) .And. aPd[1] # AcodFol[007,1]
			nValor := 0.00
		EndIf
	EndIf

	// Soma Todos Elementos da Matriz Ex.:0 = Liquido, 1 - So Provento , 2 - Desconto
	If nElem = 0  .Or. nElem = 1 .Or. nElem = 2
		If nElem = 0
			nBas += Round(nValor,2)
		ElseIf nElem = 1
			nBas += Round(nValorP,2)
		ElseIf nElem = 2
			nBas += Round(nValorD,2)
		EndIf
		Return
	EndIf

    // Verifica se Atende as Condicoes
    If nCond1 == NIl .And. nCond2 == NIl .or. nCond1 == 0 .and. nCond2 == 0
      	nBas     += nValor
       	nHorInc  += nHoras
		If __lMemCalc .And. lPensao
			fAddMemLog("Código da verba - descrição: " + aPd[1] + " - " + AllTrim( RetValSRV(aPd[1], SRA->RA_FILIAL, "RV_DESC" ) ), 1, 4)
			fAddMemLog("Valor: R$ " + AllTrim(Transform( nValor, "@E 999,999,999,999.99" )), 1, 4)
		EndIf
    ElseIf nCond1 # Nil .And. nCond1 # 0 .And. aPdv[nPos,nCond1] == cPar1 .And. nCond2 == Nil
        nBas     += nValor
        nHorInc  += nHoras
	ElseIf nCond1 # Nil .And. nCond2 # Nil .And. nCond1 # 0 .And. nCond2 # 0
		If aPdv[nPos,nCond1] = cPar1  .And. aPdv[nPos,nCond2] = cPar2
            nBas    += nValor
            nHorInc += nHoras
			If __lMemCalc .And. lPensao
				fAddMemLog("Código da verba - descrição: " + aPd[1] + " - " + AllTrim( RetValSRV(aPd[1], SRA->RA_FILIAL, "RV_DESC" ) ), 1, 4)
				fAddMemLog("Valor: R$ " + AllTrim(Transform( nValor, "@E 999,999,999,999.99" )), 1, 4)
			EndIf
        EndIf
    EndIf
EndIf

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CalDsrHex ³ Autor ³ Equipe RH             ³ Data ³28/03/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo de Dsr Sobre Horas Extras                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CalDsrHex (aCodfol,nValDsr,nHorDsr,cFlag)                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCodfol  =  Matriz com referencias das Verbas.             ³±±
±±³          ³ nValDsr  =  Valor do Calculo Passar Como Referencias.      ³±±
±±³          ³ nHorDsr  =  N§ de Horas Passar Como Referencia             ³±±
±±³          ³ cGrava   =  Ve se Grava na Propria Funcao                  ³±±
±±³          ³ cFlag    =  Controla Flag da Rescisao                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CalDsrHex(aCodfol,nValDsr,nHorDsr,cGrava,cFlag,nHrsTrab,nHrsDesc,nOpcao)
Local nValDsrn 	:= nValDsrc := nValDsrO := 0
Local nHorDsrn 	:= nHorDsrc := nHorDsrO:= 0
Local Dsrhrex_O	:= 0
Local cCodSep 	:= ""
Local cBkpPer	:= ""
Local cCodDsr	:= ""
Local dBkpDe	:= cToD("//")
Local aBaseDsr	:= {}
Local aAuxDSR 	:= {}
Local lIncODSR	:= GetMvRH( "MV_INCODSR",, .F. )
Local lProAux	:= lPropDia
Local nx		:= 0
Local ny        := 0
Local nPosPd	:= 0
Local cTipv		:= "H"

Local nDSRDTrab := 0
Local nDSRDNTrab:= 0
Local nDSRProp	:= 0
Local nSvHrsDesc:= Descanso
Local nSvHrsTrab:= Normal
Local nBkpHDesc	:= If( nHrsDesc==Nil, If(Descanso=0,1,Descanso), If(nHrsDesc=0,1,nHrsDesc) )
Local nBkpHTrab	:= If( nHrsTrab==Nil, If(Normal=0,1,Normal), If(nHrsTrab=0,1,nHrsTrab) )
Local lPDsrAdm	:= .F.
Local lPDsrDem	:= .F.
Local lPDsrAfa	:= .F.
Local lPDsrFer	:= .F.
Local lDSRCCMat	:= .T. // Valor default do mnemônico P_DSRCCMAT, representa padrão do sistema
Local lGrv		:= Nil
Local dDtIniPer	:= cTod("//")
Local dDtFimPer
Local nz 		:= 0
Local nPosExt 	:= 0
Local lDSRPon   := Type("P_LDSRHRSP") # "U" .AND. P_LDSRHRSP
Local oModel	:= {}
Local nCont		:= 0
Local nHrsDia	:= 0
Local nInfNorm	:= 0
Local nInfDesc	:= 0
Local NormalSV 	:= Normal
Local DescansoSV:= Descanso
Local lRotinc	:= GETROTEXEC() == "INC"
Local lSALHDSR	:= .F.
Local lCalcResc := IsInCallStack("GPEM040")
Local nBaseHor	:= 0

Local aPeriodo2 := {}
Local lUltSem2	:= .F.
Local nPosSem2	:= 0

Default nOpcao := 2

If cTipoRot == "1" .and. !lDissidio .and. cSitFolh == "D" //Se for folha e funcionário estiver demitido, não calcula DSR.
	Return Nil
EndIf

If lRotinc
	nOpcao := 2
EndIf

If Type("P_CPROPDSR") # "U"
	If "1" $ P_CPROPDSR
		lPDsrAdm := .T.
	Endif
	If "2" $ P_CPROPDSR
		lPDsrDem := .T.
	Endif
	If "3" $ P_CPROPDSR
		lPDsrAfa := .T.
	Endif
	If "4" $ P_CPROPDSR
		lPDsrFer := .T.
	Endif
Endif

If Type("P_DSRCCMAT") # "U"
	lDSRCCMat := P_DSRCCMAT  // .T. - Define pagamento do DSR centralizado no Centro de Custo da Matrícula
EndIf						// .F. - Define pagamento do DSR pelo Centro de Busco da verba Base

//Deve considerar o salrio e dsr horista informado na RGB para a base de calculo das demais verbas?
If cPaisLoc == "BRA"
	lSALHDSR := If( Type("P_SALHDSR") == "U", .F., P_SALHDSR)
EndIf

//Altera mnemonico para que nao seja proporcionalizado as verbas
 lPropDia := .F.

If lCalcResc .Or. IsBlind()
	If cCompl == "S"
		// Carrega período do mês da rescisão
		FCarPeriodo( AnoMes(dDataDem), cRot, @aPeriodo2, @lUltSem2, @nPosSem2)
		If Len(aPeriodo2) > 0 .And. nPosSem2 > 0
			Normal := aPeriodo2[nPosSem2, 24] * SRA->RA_HRSDIA
        	Descanso := aPeriodo2[nPosSem2, 07] * SRA->RA_HRSDIA
		EndIf	
	EndIf	
	If cCompl != "S" .Or. nPosSem2 == 0
		Descanso	:= If(M->RG_DESCANS == Nil, Descanso, M->RG_DESCANS)
		Normal		:= If(M->RG_NORMAL == Nil, Normal, M->RG_NORMAL)
	EndIf
EndIf

If nOpcao == 1
	If lDSRPon
		nHrsTrab := nTUteis
		nHrsDesc := nTNUteis
	Else
		nHrsTrab := Normal
		nHrsDesc := Descanso
	EndIf
ElseIf nOpcao == 2
	If lDSRPon
		nHrsTrab := nTUteis
		nHrsDesc := nTNUteis
	EndIf
	If (IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD") .Or. IsInCallStack("GPER080")) .And. lRotinc
		Normal := NSVNORMAL
		Descanso := NSVDESCAN
    EndIf
	cFlag	:= If (cFlag == Nil," ",cFlag)
	If SRA->RA_TPCONTR == '3' .and. Normal == 0
		nHrsTrab:= If ( nHrsTrab == Nil , If (Normal=0,aConvocacao[7],Normal) , If (nHrsTrab=0,aConvocacao[7],nHrsTrab))
		nHrsDesc:= If ( nHrsDesc == Nil , If (Descanso=0,1,Descanso) , If (nHrsDesc=0,1,nHrsDesc))
	Else
		nHrsTrab:= If ( nHrsTrab == Nil , If (Normal=0,1,Normal) , If (nHrsTrab=0,1,nHrsTrab))
		nHrsDesc:= Iif( nHrsDesc == Nil, Iif(Descanso == 0 .And. ( cTipoRot != "1" .Or. ( nPosSem == 0 .Or. (Len(aPeriodo) > 0 .And. aPeriodo[nPosSem, 7] > 0) ) ), 1, Descanso), Iif(nHrsDesc == 0, 1, nHrsDesc) )
	EndIf
	nHrTDsr := 0

	//--Verifica se existe identificadores de comissao folha e comissao rescisao
	//--se existir ira efetuar o calculo do DSR separado do DSR s/Variaveis
	If aCodFol[166,1] # Space(3)
		cCodSep := aCodFol[165,1]+"/"+aCodFol[347,1]+"/"
	Endif
	If aCodFol[122,1] # Space(3)
		cCodSep += aCodFol[121,1]
	Endif

	//--Calculo do DSR S/Variaveis
	If aCodfol[35,1] # SPACE(3)

		aAuxDSR := {}

		If lDSRCCMat // DSR centralizado pelo Centro de Custo da Matrícula

			Dsrhrex_B := 0.0
			If cFlag = "F"
		      Aeval(aPd,{ |X| If(! X[1] $ cCodSep, SomaInc(X, 16, @Dsrhrex_B, 11, "S", , , , .F., aCodFol,, @nHrTDsr), "")})
			Else
		      Aeval(aPd,{ |X| If(! X[1] $ cCodSep, SomaInc(X, 16, @Dsrhrex_B, 11, "N", , , , .F., aCodFol,, @nHrTDsr), "")})
			EndIf
			aAdd(aAuxDSR, { SRA->RA_CC, Dsrhrex_B, "" }) // Centro de Custo , Valor , Verba Base HE

		Else // DSR de acordo com o Centro de Custo da Verba de Base HE
			For nz := 1 to Len(aPd)
				If ! aPd[nz,1] $ cCodSep .And. RetValSRV(aPd[nz,1], SRA->RA_FILIAL, "RV_DSRHE" ) == "S" .And. ;
					 (RetValSRV(aPd[nz,1], SRA->RA_FILIAL, "RV_REFFER" ) == If(cFlag == "F", "S","N")) .And.;
					 aPd[nz,9] # "D"
					nPosExt := aScan(aAuxDSR,{|x| x[1] == aPd[nz,2] .And. x[3] == aPd[nz,1] })
					If nPosExt > 0
						aAuxDSR[nPosExt][2] += aPd[nz][5]
					Else
						aAdd(aAuxDSR,{ aPd[nz,2], aPd[nz,5], aPd[nz,1] }) // Centro de Custo , Valor , Verba Base HE
					EndIf
				EndIf
			Next nz
		EndIf

		//DSR proporcional ao dias trabalhados na Admissao/Rescisao/Afastamento/Ferias

		If !lDSRPon .And. ( lPDsrAdm .OR. lPDsrDem .OR. lPDsrAfa .OR. lPDsrFer )

			nSvHrsDesc := nHrsDesc
			nSvHrsTrab := nHrsTrab

			If lCalcResc .And. cCompl == "S"
				cBkpPer		:= cPeriodo
				dBkpDe		:= dDataDe
				cPeriodo	:= AnoMes(dDataDem)
				dDataDe		:= cToD("01/" + SubStr( cPeriodo, 5, 2 ) + "/" + SubStr( cPeriodo, 1, 4 ))
			EndIf

			dDtIniPer := If( AnoMes(SRA->RA_ADMISSA) == CPERIODO .And. lPDsrAdm, SRA->RA_ADMISSA, DDATADE )
			dDtFimPer := If( !Empty(dDataDem) .And. lPDsrDem, dDataDem, DDATAATE )

		  	FTrabCalen(	 CPERIODO	,;		//01-- Periodo
	                     @nDSRDTrab	,;		//02-- Dias Trabalhados
	                     @nDSRDNTrab,;		//03-- Dias Nao Trabalhados
	                     @nDSRProp 	,;		//04-- Dias de DSR
	                     0		 	,;		//05-- Dias Nao Uteis de Vale Transporte
	                     0		   	,;		//06-- Dias uteis de Vale Transporte
	                     0 		  	,; 		//07-- Dias de Diferenca de Vale Transporte
	                     0		 	,;		//08-- Qtde de Horas de DSR
	                     @nHrsTrab	,;		//09-- Qtde de HoraS Trabalhadas
	                     0			,;		//10-- Dias de Vale Refeicao
	                     0		  	,;		//11-- Dias totais de V.T. Dias Uteis
	                     0		 	,;		//12-- Dias totais de V.T. Dias Nao uteis
	                     cSemana	,;		//13-- Numero de Pagamento
	                     lPDsrAfa	,;		//14-- Proporcional a Afastamento
	                     lPDsrAdm	,;		//15-- Proporcional a Admissao
	                     dDtFimPer	,;		//16-- Data Fim do Periodo
	                     CROT		,;		//17-- Roteiro
	                     dDtIniPer	,;		//18-- Data inicial para pesquisa (opcional)
	                     0			,;		//19-- Verbas de tipos de afastamentos (opcional)
						 0			,;		//20-- Dias de Vale Alimentacao
                     	 0			,;		//21-- Dias uteis
                     	 lPDsrFer	)		//22-- Considera as férias do array aafas


		 	nHrsDesc := Round( SRA->RA_HRSDIA * nDSRProp, 2 )	//Dias DSR
		 	nHrsTrab := Round( SRA->RA_HRSDIA * (nDSRDTrab + nDSRDNTrab), 2 )	//Dias Trabalhados+Dias Nao Trabalhados
			If lCalcResc .And. cCompl == "S"
				cPeriodo	:= cBkpPer
				dDataDe		:= dBkpDe
			EndIf

		ElseIf lDSRPon .And. !lPDsrAdm .And. !lPDsrDem .And. !lPDsrAfa .And. !lPDsrFer

			fHTrabCalen( DDATADE, DDATAATE )
			If lCalcResc .Or. IsBlind()
				Descanso := If(M->RG_DESCANS == Nil, Descanso, M->RG_DESCANS)
				Normal	 := If(M->RG_NORMAL == Nil, Normal, M->RG_NORMAL)
			Else
				Descanso := nSvHrsDesc
				Normal	 := nSvHrsTrab
			EndIf
			nHrsTrab := nTUteis
			nHrsDesc := nTNUteis

		 EndIf

		For nx := 1 to Len(aAuxDSR)
			nPosPd := Ascan(aPd,{ |X| X[1] == aCodfol[35,1] .And. x[3] == cSemana .And. X[9] # "D"})
			If aAuxDSR[nx][2] > 0
				If lDissidio
					lGrv := .T.
					nPDis := Ascan(aPdOld,{ |X| X[1] == aCodfol[35,1] .And. X[3] = cSemana})
					nValDsr := ( (aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
					nHorDsr := If( Salhora > 0, nValDsr / Salhora, 0 )
				ElseIf nPosPd > 0 .And. aPd[nPosPd,6] $ "H"
					If aPd[nPosPd,7] $ "I*G"
						nValDsr := ((aAuxDSR[nx][2] * aPd[nPosPd,4] ) / nHrsTrab )
						nHorDsr := aPd[nPosPd,4]
					Else
						nValDsr := ((aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
						nHorDsr := If( Salhora > 0 .And. Salario > 0 , nValDsr / Salhora , 0 )
					EndIf
				Elseif nPosPd  = 0
					nValDsr := ((aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
					nHorDsr := If( Salhora > 0 .And. Salario > 0 , nValDsr / Salhora , 0 )
				EndIf

				nValDsrO := nValDsr
				nHorDsrO := nHorDsr

				If cGrava # Nil .And. cGrava = "S" .And. nValDsr > 0
					// Inclusao do mesmo tratamento para gravacao da verba com ID 035, forcando a gravacao em HORAS
					If lDSRCCMat
						nPosExt	:= 0
						If lCalcResc .And. cCompl == "S"
							nPosExt	:= Ascan(aPd,{ |X| X[1] == aCodfol[35,1] .And. x[2] == aAuxDSR[nx][1] .And. x[3] == cSemana .And. X[9] # "D" .and. x[7] == "C" }) //Se já foi gravada nesse cálculo, regrava
						EndIf
						FMatriz(aCodfol[35,1],nValDsr,nHorDsr,,,"H",,,,,lGrv .Or. nPosExt>0,,,,,,,,,lPropDia)
					Else
						// Se a verba de Horas for Informada, gravar verba de DSR com Centro de Custo/Item Contábil/Classe de Valor
						// da Verba Informada
						nPosExt	:= Ascan(aPd,{ |X| X[1] == aCodfol[35,1] .And. x[2] == aAuxDSR[nx][1] .And. x[3] == cSemana .And. X[9] # "D"})
						If nPosExt > 0
							aPd[nPosExt][4] += nHorDsr
							aPd[nPosExt][5] += nValDsr
						Else
							FMatriz(aCodfol[35,1],nValDsr,nHorDsr,,aAuxDSR[nx][1],"H",,,,,lGrv)
						EndIf
					EndIf
				EndIf
			EndIf
		Next nx
	EndIf

	//--Calculo do Dsr S/Comissao Folha de Pagamento
	If aCodfol[166,1] # SPACE(3)
		Dsrhrex_C := 0.00
		Aeval(aPd,{ |X| If(X[1]$aCodFol[165,1]+'*'+aCodFol[347,1],SomaInc(X,16,@Dsrhrex_C, , , , , ,.F.,aCodFol),"")})
		nPos := Ascan(aPd,{ |X| X[1] = aCodfol[166,1] .And. X[3] = cSemana .And. X[9] # "D"})

		If nPos > 0 .And. aPd[nPos,6] $ "H"
			nValDsr := ((Dsrhrex_C * aPd[nPos,4] ) / nHrsTrab )
			nHorDsr := aPd[nPos,4]
		Elseif nPos  = 0
			nValDsr := ((Dsrhrex_C * nHrsDesc ) / nHrsTrab )
			nHorDsr := nHrsDesc
		EndIf
		nValDsrc := nValDsr
		nHorDsrc := nHorDsr

		// Verifica se grava na Matriz
		If cGrava # Nil .And. cGrava = "S" .And. nValDsr > 0
			FMatriz(aCodfol[166,1],nValDsr,nHorDsr)
		EndIf
	EndIf

	If cGrava = Nil .And. cGrava # "S"
		nValDsr := nValDsrn + nValDsrc
		nHorDsr := nHorDsrn + nHorDsrc
	EndIf

	//--Calculo do DSR S/Comissies Rescisao
	IF aCodfol[122,1] # SPACE(3)
		Dsrhrex_C := 0.00
		Aeval(aPd,{ |X| If(X[1]$ aCodFol[121,1],SomaInc(X,16,@Dsrhrex_C, , , , , ,.F.,aCodFol),"")})

		nPos := Ascan(aPd,{ |X| X[1] = aCodfol[122,1] .And. X[3] = cSemana .And. X[9] # "D"})
		If nPos > 0 .And. aPd[nPos,6] $ "H"
			nValDsr := ((Dsrhrex_C * aPd[nPos,4] ) / nHrsTrab )
			nHorDsr := aPd[nPos,4]
		Elseif nPos  = 0
			nValDsr := ((Dsrhrex_C * nHrsDesc) / nHrsTrab )
			nHorDsr := nHrsDesc
		EndIf
		nValDsrC += nValDsr
		nHorDsrC += nHorDsr

		// Verifica se grava na Matriz
		If cGrava # Nil .And. cGrava = "S" .And. nValDsr > 0
			FMatriz(aCodfol[122,1],nValDsr,nHorDsr)
		EndIf
	Endif
EndIf

If ( ( nOpcao == 1 .And. lIncODSR .And. !lDissidio ) .Or. ( ( nOpcao == 2 .And. !lIncODSR ) .Or. lDissidio ) )
	//--Calculo dos outros DSR
	If !lHoJorVa .And. SRA->RA_CATFUNC == "H" .And. cTipoRot != "1" .And. lSALHDSR
		//Percorre o aPd em busca das verbas de salário horista (Id 0032) e DSR horista (Id 0033)
		For nCont := 1 To Len(aPd)
			If aPd[nCont,1] == aCodFol[032,1] .And. aPd[nCont,9] != "D" .And. AllTrim( aPd[nCont,3] ) == AllTrim( cSemana ) .And. aPd[nCont,7] == "I"
				nInfNorm	+= aPd[nCont,4]
			EndIf
			If aPd[nCont,1] == aCodFol[033,1] .And. aPd[nCont,9] != "D" .And. AllTrim( aPd[nCont,3] ) == AllTrim( cSemana ) .And. aPd[nCont,7] == "I"
				nInfDesc	+= aPd[nCont,4]
			EndIf
		Next nCont

		//Caso tenha informado a verba de salário horista, utiliza as horas informadas
		If nInfNorm > 0
			Normal := nInfNorm
			//Caso possua afastamento, divide as horas pelas dias trabalhados e multiplica pelos dias de cálculo para considerar as horas previstas no mês
			If nDiasAfas > 0
				Normal := (Normal / DiasTrab * nDiasC)
			EndIf

			nHrsDia := (Normal / aPeriodo[nPosSem,24] * aPeriodo[nPosSem,20] / nDiasC)
			//Caso tenha informado a verba de DSR horista, utiliza as horas informadas
			If nInfDesc > 0
				Descanso := nInfDesc
			Else
				Descanso := nHrsDia * aPeriodo[nPosSem,7]
			EndIf

			//Verifica a quantidade de horas trabalhadas por dia, de acordo com as horas informadas
			nHrsDia := (Normal + Descanso) / nDiasC

			//Retira a incorporação das variáveis de salário, pois foram consideradas as horas cadastrais
			Salario -= (SRA->RA_SALARIO * nHrsCal)
			SalMes 	-= (SRA->RA_SALARIO * nHrsCal)
			SalDor 	-= (SRA->RA_SALARIO * SRA->RA_HRSDIA)
			SalDia 	-= (SRA->RA_SALARIO * SRA->RA_HRSDIA)

			//Efetua a incorporação das variáveis de salário, com base nas horas trabalhadas
			nHrsCal := nHrsDia * nDiasC
			Salario	+= (SRA->RA_SALARIO * nHrsCal)
			SalMes 	+= (SRA->RA_SALARIO * nHrsCal)
			SalDor 	+= (SRA->RA_SALARIO * nHrsDia)
			SalDia 	+= (SRA->RA_SALARIO * nHrsDia)

			If Descanso > 0
				lGrv := IIf( lDissidio, .T., Nil ) //Forca a gravacao no calculo do dissidio
				nBaseHor := IIf( lDissidio, SalHor, SRA->RA_SALARIO )
				FMatriz(aCodFol[033,1],(nBaseHor * Descanso ),Descanso,,,"H",,,,,lGrv)
			EndIf
		EndIf
	EndIf

	For nx := 1 to Len(aPdv)

		cCodDsr	:= aPdv[nx,32] //Codigo informado para calculo do DSR (RV_CODDSR)

		If Empty(cCodDsr) .or. ( nInfNorm > 0 .and. cCodDsr == aCodFol[033,1] ) //Se horas foram informadas, DSR Horista já foi calculado acima.
			Loop
		Endif

		nPos := Ascan( aBaseDsr, {|x| x[1] == cCodDsr } )
		If nPos = 0
			cTipV := RetValSRV( cCodDsr, SRA->RA_FILIAL, "RV_TIPO" )
			aadd (aBaseDsr, { cCodDsr, aPdv[nx, 1],cTipV } )    //Codigo DSR, Verba
		Else
			aBaseDsr[nPos, 2] += "/" + aPdv[nx, 1]
		EndIf
	Next nx

	For ny:= 1 to Len(aBaseDsr)

		aAuxDSR 	:= {}
		If cTipoRot != "3"
			Dsrhrex_O	:= 0
		EndIf

		If lDSRCCMat // DSR centralizado pelo Centro de Custo da Matrícula
			Aeval ( aPd, {|X| If( x[1] $ aBaseDsr[ ny, 2] .and. x[3] == cSemana .and. x[9] # "D", Dsrhrex_O += x[5], 0 ) } )
			aAdd(aAuxDSR,{ SRA->RA_CC ,Dsrhrex_O, "" }) // Centro de Custo , Valor , Verba Base HE
		Else // DSR de acordo com o Centro de Custo da Verba de Base HE
			For nz := 1 to Len(aPd)
				If aPd[nz,1] $ aBaseDsr[ ny, 2] .and. aPd[nz,3] == cSemana .and. aPd[nz,9] # "D"
					nPosExt := aScan(aAuxDSR,{|x| x[1] == aPd[nz,2] .And. x[3] == aPd[nz,1] })
					If nPosExt > 0
						aAuxDSR[nPosExt][2] += aPd[nz][5]
					Else
						aAdd(aAuxDSR,{ aPd[nz,2],aPd[nz,5], aPd[nz,1] }) // Centro de Custo , Valor , Verba Base
					EndIf
				EndIf
			Next nz
		EndIf

		For nx := 1 to Len(aAuxDSR)
			nPosPd := Ascan(aPd,{ |X| X[1] == aBaseDsr[ ny, 1] .And. x[3] == cSemana .And. X[9] # "D"})
			If aAuxDSR[nx][2] > 0
				If lDissidio
					nPDis := Ascan(aPdOld,{ |X| X[1] == aBaseDsr[ ny, 1] .And. X[3] = cSemana})
					nValDsr := ( (aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
					nHorDsr := If( Salhora > 0, nValDsr / Salhora, 0 )
				ElseIf nPosPd > 0 .And. aPd[nPosPd,6] $ "H"
					If aPd[nPosPd,7] $ "I*G"
						nValDsr := ((aAuxDSR[nx][2] * aPd[nPosPd,4] ) / nHrsTrab )
						nHorDsr := aPd[nPosPd,4]
					Else
						nValDsr := ((aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
						nHorDsr := If( Salhora > 0 .And. Salario > 0 , nValDsr / Salhora , 0 )
					EndIf
				Elseif nPosPd  = 0
					nValDsr := ((aAuxDSR[nx][2] * nHrsDesc ) / nHrsTrab )
					nHorDsr := If( Salhora > 0 .And. Salario > 0 , nValDsr / Salhora , 0 )
			   	EndIf

				nValDsrO := nValDsr
				nHorDsrO := nHorDsr

		 		If cGrava # Nil .And. cGrava = "S" .And. nValDsr > 0
					// Inclusao do mesmo tratamento para gravacao da verba com ID 035, forcando a gravacao em HORAS
					lGrv := If( lDissidio, .T., Nil ) //Forca a gravacao no calculo do dissidio
					If lDSRCCMat // DSR centralizado pelo Centro de Custo da Matrícula
						FMatriz(aBaseDsr[ny, 1],nValDsr,nHorDsr,,,aBaseDsr[ny, 3],,,,,lGrv)
						Dsrhrex_O := 0
					Else
						// Se a verba de Horas for Informada, gravar verba de DSR com Centro de Custo/Item Contábil/Classe de Valor
						// da Verba Informada
						nPosExt	:= Ascan(aPd,{ |X| X[1] == aBaseDsr[ny, 1] .And. x[2] == aAuxDSR[nx][1] .And. x[3] == cSemana .And. X[9] # "D"})
						If nPosExt > 0
							aPd[nPosExt][4] += nHorDsr
							aPd[nPosExt][5] += nValDsr
						Else
							FMatriz(aBaseDsr[ny, 1],nValDsr,nHorDsr,,aAuxDSR[nx][1],aBaseDsr[ny, 3],,,,,lGrv)
						EndIf
					EndIf
				EndIf
			EndIf
		Next nx
	Next ny
EndIf

//Restaura os valores originais de Horas Trabalhadas e DSR
If (lPDsrAdm .OR. lPDsrDem .OR. lPDsrAfa .OR. lPDsrFer) .And. ( nSvHrsDesc > 0 .Or. nSvHrsTrab > 0 )
	nHrsDesc := nSvHrsDesc
	nHrsTrab := nSvHrsTrab
EndIf

If lCalcResc
	If SRA->RA_CATFUNC == "H" .And. Empty( M->RG_DESCANS + M->RG_NORMAL )
		oModel := FWModelActive()
		oModel:GetModel("GPEM040_MSRG"):SetValue("RG_NORMAL" , Normal  )
		oModel:GetModel("GPEM040_MSRG"):SetValue("RG_DESCANS", Descanso)
	EndIf
	Descanso	:= nSvHrsDesc
	Normal		:= nSvHrsTrab
EndIf

If lDSRPon
	nHrsDesc := nBkpHDesc
	nHrsTrab := nBkpHTrab
EndIf

If ( IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD") ) .And. lRotinc
	Normal := NormalSV
	Descanso := DescansoSV
EndIf
//-- Somar os Dsr para retorno da nas variaveis enviadas como Parametros
nValDsr 	:= nValDsrN + nValDsrC + nValDsrO
nHorDsr 	:= nHorDsrN + nHorDsrC + nHorDsrO
lPropDia	:= lProAux

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³fChkLicRem³ Autor ³ Emerson Rosa de Souza ³ Data ³26/05/00  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna dias de licenca remunerada (24/12,25/12,31/12,01/01)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCalcFimAq(dDtIni,cTipoRet)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nDPriMes - Dias do Primeiro Mes ( 24/12,25/12 e 31/12 )    |±±
±±³          ³ nDSegMes - Dias do Segundo  Mes ( 01/01 )			      |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fChkLicRem(dDtIniRef,dDtFimRef,nDMes12,nDMes01,cDia2501)
Local aDLicRem,dDtLicRem,nDl,cAno
Local dDtFimAux := dDtFimRef

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| O conteudo "S" do parametro foi mantido p/ compatibilizacao|
//| com versoes anteriores. O parametro agora pode conter as   |
//| datas 24/12,25/12,31/12 e 01/01                            |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cDia2501 := If( cDia2501 == "S", "25/12,01/01", cDia2501 )

nDMes12  := nDMes01 := 0
aDLicRem  := { "24/12", "25/12", "31/12", "01/01" }
cAno      := StrZero(Year(dDtIniRef),4)
For nDl := 1 To Len(aDLicRem)
	If aDLicRem[nDl] $ cDia2501
		If nDl # 4
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica os dias de licenca das datas 24/12, 25/12 e 31/12   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dDtLicRem := CTOD(aDLicRem[nDl]+"/"+cAno,"DDMMYY")
			If dDtIniRef <= dDtLicRem .And. dDtFimAux >= dDtLicRem
				If Month(dDtIniRef) == Month(dDtLicRem)
					nDMes12 ++
				Else
					nDMes01 ++
				EndIf
				dDtFimAux ++
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica os dias de licenca da data 01/01    				 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dDtLicRem := CTOD(aDLicRem[nDl]+"/"+StrZero(Val(cAno)+1,4),"DDMMYY")
			If dDtIniRef <= dDtLicRem .And. dDtFimAux >= dDtLicRem
				nDMes01 ++
			Else
				dDtLicRem := CTOD(aDLicRem[nDl]+"/"+StrZero(Val(cAno),4),"DDMMYY")
				If dDtIniRef <= dDtLicRem .And. dDtFimAux >= dDtLicRem
					nDMes12 ++
				EndIf
			EndIf
		EndIf
	EndIf
Next nDl
Return Nil



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fLiquido ³ Autor ³ Mauro                 ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do L¡quido                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fliquido(aCodfol,nArred,lIns,lSfam)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aCodFol   - Matriz Com Codigos da Folha                     ³±±
±±³          ³cCodliq   - Verba de Gravacao do Liquido                    ³±±
±±³          ³nArred    - Valor a Ser Arredondado                         ³±±
±±³          ³cCodArred - Verba de Grav. do Arredondamento                ³±±
±±³          ³lIns      - .F. OU .F. para Gravar Insuficiencia de saldo   ³±±
±±³          ³cCodIns   - Verba de Grav. da Insuficiencia                 ³±±
±±³          ³lObrigat  - .T. Para Obrigatoriedade da Verba no Liquido    ³±±
±±³          ³lGrava    - .T. Para Gravar o Liquido, Arred. e Insuf.      ³±±
±±³          ³lDemiss   - .T. Para Considerar Funcionarios Demitidos na Ge³±±
±±³          ³                racao de Insuficiencia de Saldo			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fLiquido(aCodfol,cCodliq,nArred,cCodArred,lIns,cCodIns,lObrigat,lGrava,lDemiss)

Local nObrigat	:= 0.00
Local nPos		:= 0.00
Local nApd		:= 0.00
Local nLenApd	:= If( Type("aPd") == "A" , Len( aPd ) , 0.00 )

//--Situacao do Funcionario na data de referencia
cSitFolh	:= If( Type("cSitFolh")=="U",SRA->RA_SITFOLH,cSitFolh)

DEFAULT aCodFol 	:= {}
DEFAULT cCodLiq		:= Space(03)
DEFAULT nArred		:= 0.00
DEFAULT cCodArred	:= Space(03)
DEFAULT lIns		:= .F.
DEFAULT cCodIns		:= Space(03)
DEFAULT lGrava		:= .T.
DEFAULT lObrigat	:= .F.
DEFAULT lDemiss		:= .F.

If cTipoRot == "1" .And. cPaisLoc == "BRA" .And. cSitFolh # "D" .And. !(SRA->RA_CATFUNC $ 'E*G') .and. !lDissidio .And. SRA->RA_TPCONTR != "3"
	fGerArr13()
EndIf

// Liquido/Arredondamento/Insuficiencia
nLiquido := 0.00

// Soma Para compor o Liquido
Aeval( aPd ,{ |x| SomaInc(x,0,@nLiquido,,,,,,.F.,aCodFol ) } )
If SRA->RA_TPCONTR == "3"
	Aeval( aPdConvoc ,{ |x| SomaInc(x,0,@nLiquido,,,,,,.F.,aCodFol ) } )
EndIf

// Verifica o valor dos Proventos Obrigatorios
If lObrigat
	For nApd := 1 To nLenApd
		If aPD[ nApd , 3 ] == cSemana .and. aPd[ nApd , 9 ] # "D" .and. ;
		Upper(RetValSrv(aPD[ nApd , 1 ],SRA->RA_FILIAL,"RV_OBRIGAT") ) == "S"
			nObrigat += aPd[ nApd , 5 ]
		EndIf
	Next nApd
EndIf

If Type("cCalcInf") != "U" .and. cCalcInf == "S" // GetMvRH("MV_CALCINF")
	nObrigat := 0
EndIf

nVAL_ARRE := VLR_INS := 0.00

If ( nLiquido < 0.00  .or. ( lObrigat .and. nliquido < nObrigat) ) .and. lIns
	// CALCULO DO PROVENTO INSUFICIENCIA DE SALDO
	// QUANDO HA VERBAS OBRIGATORIAS O VALOR DO LIQUIDO DEVE
	// SER IGUAL AO MESMO, E NUNCA ZERO, NESTES CASOS
	nVlr_ins := 0.00
	If !( cSitFolh $ "D*E" ) .or. ( cSitFolh == "D" .and. lDemiss )
		If Round(nLiquido,2) < 0.00 .Or. ( lObrigat .and. Round(nLiquido,2) < nObrigat)
			If Round(nLiquido,2) < 0.00
				nVlr_ins = (nLiquido * -1) + nObrigat
				nLiquido := nObrigat
			ElseIF lObrigat
				nVlr_ins := nObrigat - nLiquido
            	nLiquido := nObrigat
			EndIf
		EndIf
	ElseIF Round( nLiquido , 2 ) < 0.00
		nVlr_ins = ( nLiquido * -1 )
    EndIf
	If nVlr_ins # 0
		If lGrava
			FMatriz( cCodIns , nVlr_ins )
			If cSemana # Nil .And. !lUltSemana .And. cSemana # Space(2) .And. SRA->RA_TIPOPGT = "S" .And. nArred == 0.00
				nPos := Ascan( aPeriodo , { |x| x[2] == cSemana } )
				GravaSrc(SRA->RA_FILIAL,SRA->RA_MAT,aCodFol[046,1],Ctod("  /  /  "),SRA->RA_CC,aPeriodo[nPos+1,2],"V","G",0,nVlr_ins,0)
			EndIf
		EndIf
	EndIf
EndIf

//--Calcula Arredondamento
If nArred > 0.00 .and. nLiquido > 0 .and. !(cTipoRot == "5" .and. aPergunte[4,3] == 1) .And. cTipoRot != "N"
	nLiquido := Round( nLiquido , 2 )
	// --- Procura Arredondamento
	If cCodarred # SPACE(3) .and. Ascan(aPd, { |x| x[1] == cCodarred .and. x[3] == cSemana .and. x[9] # "D"} ) == 0
		nSALV_ARR := nArred
		CALC_ARRE(@nLIQUIDO, @nArred, @nVAL_ARRE,cSemana)
		nArred := nSALV_ARR
		If lGrava
			FMatriz(cCodArred,nVal_Arre,,,,,,,,dData_Pgto)
		EndIf
	EndIf
EndIf

//-- Grava‡ao do Liquido
//-- Grava‡ao do Liquido
If Ascan(aPd,{ |x| x[1] == cCodLiq .and. x[3] == cSemana .and. x[9] # "D"}) == 0
	If lGrava
		fMatriz(cCodLiq,nLiquido,,,,,,,,dData_Pgto)
		If cTipoRot == "N"
			fMatriz(aCodFol[1658,1],nLiquido,,,,,,,,dData_Pgto)
		EndIf
	EndIf
EndIf

Return( If( !lGrava , nObrigat , 0 ) )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fHistFer ³ Autor ³ Emerson Rosa de Souza ³ Data ³06/02/99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava o historico caso haja perda de periodo                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fHistFer()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ dIniDtBas  -Inicio do periodo aquisitivo                   |±±
±±³          ³ dFimDtBas  -Fim do periodo aquisitivo                      |±±
±±³          ³ dDiasAf    -Dias de afastamento do periodo                 |±±
±±³          ³ dDescTipAfa-Descricao do afastamento que ocasionou a perda |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fHistFer(dIniDtBas,dFimDtBas,nDiasAf,cDescTipAfa)
Local cAlias := Alias()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Grava no Arquivo de historico o Periodo de Ferias Perdido    |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SRH")
If ! dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+Dtos(dIniDtBas))
	RecLock("SRH",.T.)
Else
	RecLock("SRH",.F.)
EndIf
SRH->RH_FILIAL  := SRA->RA_FILIAL
SRH->RH_MAT     := SRA->RA_MAT
SRH->RH_SALMES  := 0
SRH->RH_SALDIA  := 0
SRH->RH_SALHRS  := 0
SRH->RH_DATABAS := dIniDtBas
SRH->RH_DBASEAT := dFimDtBas
SRH->RH_DFERVEN := 30
SRH->RH_DFERIAS := 0
SRH->RH_DABONPE := 0
SRH->RH_PERC13S := 0
SRH->RH_DATAINI := CTOD("")
SRH->RH_DATAFIM := CTOD("")
SRH->RH_DFALTAS := 0
SRH->RH_DAFASTA := nDiasAf
SRH->RH_DTAVISO := CTOD("")
SRH->RH_DTRECIB := CTOD("")
SRH->RH_SALMIN  := 0
SRH->RH_DIALREM := 0
SRH->RH_DIALRE1 := 0
SRH->RH_TIPCAL  := "N"
SRH->RH_MEDATU  := "N"
SRH->RH_OBSERVA := cDescTipAfa

MsUnlock()
dbSelectArea(cAlias)

Return Nil




/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fSalProf ³ Autor ³ Emerson               ³ Data ³ 06.08.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula Salario Dia Hora e Mes da categoria Professor      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fSalProf(Salario,Salhora,Saldia,Salmes,Tipo)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fSalProf(Salario,SalHora,SalDia,SalMes,aTarefas,aSalProf,lDsrHrsAtiv)
Local nCnt1,nCnt2,nCnt3
Local nVlDsrProf := 0
Local nVlHrsAtiv := 0
Local nVlDsrHrs  := 0
Local nPos		 := 0
Local nValor	 := 0
Local aBsDsrProf := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
Local aBsHrsAtiv := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
Local aBsDsrHrs  := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
Local aTotTarefa := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
Local nFixaTotal := 1				//  Sera sempre 1 pois buscara a parte fixa para o SALMES do Professor
Local lDsrBsHAtv := SRV->( RetValSRV(aCodFol[033,1],SRA->RA_FILIAL,"RV_HRSATIV") ) == "S" // Dsr base para Hora atividade
Local lHAtvBsDsr := SRV->( RetValSRV(aCodFol[317,1],SRA->RA_FILIAL,"RV_DSRPROF") ) == "S" // Hora atividade base para Dsr
Local aSvTaref	 := aClone( aTarefas )

DEFAULT lDsrHrsAtiv := GetMvRH("MV_DSRHATV",,.T.)         //  Calcula Primeiro o DSR depois Horas Atividade

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Elementos:   1-Fixa         2-Variavel     3-Total			    ³
//³             N1-Salario     N2-DSR         N3-Horas Atividade	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aSalProf := { { 0,0,0 }, { 0,0,0 }, { 0,0,0 } }
aOSlPrf		:= { { 0,0,0 }, { 0,0,0 }, { 0,0,0 } }

For nCnt3 := 1 To 2

	nVlDsrProf := nVlHrsAtiv := nVlDsrHrs  := 0
	aBsDsrProf := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
	aBsHrsAtiv := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
	aBsDsrHrs  := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total
	aTotTarefa := { 0, 0, 0 }    //  1-Fixa    2-Variavel    3-Total

	If nCnt3 == 1
		aTarefas := aClone( aOrigTar )
	Else
		aTarefas := aClone( aSvTaref )
	EndIf

	For nCnt1 := 1 To Len(aTarefas)
		If aTarefas[nCnt1,7] == "1"  // Provento


			If Len(aTarefas[nCnt1]) > 17
				nValor := aTarefas[nCnt1, 2] + aTarefas[nCnt1, 17] - aTarefas[nCnt1, 18]
			Else
				nValor := aTarefas[nCnt1, 2]
			EndIf

			// Posiciona na Verba para calcular salario do professor
			SRV->( PosSrv(aTarefas[nCnt1,1],SRA->RA_FILIAL) )

			// Totaliza proventos para calculo do DSR
			If SRV->RV_DSRPROF == "S"
				If aTarefas[nCnt1,9] $ "1*3"
					aBsDsrProf[1] += nValor
				ElseIf aTarefas[nCnt1,9] $ "2*4"
					aBsDsrProf[2] += nValor
				EndIf
				aBsDsrProf[3] += nValor
			EndIf

			// Totaliza proventos para calculo das Horas Atividade
			If SRV->RV_HRSATIV == "S"
				If aTarefas[nCnt1,9] $ "1*3"
					aBsHrsAtiv[1] += nValor
				ElseIf aTarefas[nCnt1,9] $ "2*4"
					aBsHrsAtiv[2] += nValor
				EndIf
				aBsHrsAtiv[3] += nValor
			EndIf

			// Totaliza proventos que incidam DSR e Hora atividade
			If lRecriaDsr .and. SRV->RV_DSRPROF == "S" .and. SRV->RV_HRSATIV == "S"
				If aTarefas[nCnt1,9] $ "1*3"
					aBsDsrHrs[1] += nValor
				ElseIf aTarefas[nCnt1,9] $ "2*4"
					aBsDsrHrs[2] += nValor
				EndIf
				aBsDsrHrs[3] += nValor
			EndIf

			// Totaliza Tarefas de proventos
			If aTarefas[nCnt1,9] $ "1*3"        // Fixa
				aTotTarefa[1] += nValor
			ElseIf aTarefas[nCnt1,9] $ "2*4"    // Variavel
				aTotTarefa[2] += nValor
			EndIf
			aTotTarefa[3] += nValor // Total
		EndIf
	Next nCnt1

	// Composicao do salario do Professor - Fixas/Variaveis/Total
	For nCnt2 := 1 To 3
		If lDsrHrsAtiv // Calcula DSR e sobre ele a Hora Atividade
			nVlDsrProf := Round( aBsDsrProf[nCnt2] * aParProf[2], 2)
			nVlDsrHrs  := If ( lRecriaDsr , Round( aBsDsrHrs[nCnt2] * aParProf[2], 2), nVlDsrProf) //Somente horas de DSR que incidam horas atividades
			nVlHrsAtiv := Round((aBsHrsAtiv[nCnt2] + If(lDsrBsHAtv,nVlDsrHrs,0) ) * aParProf[3], 2)
		Else           // Calcula Hora Atividade e sobre ela o DSR
			If !lDsrBsHAtv
				nVlHrsAtiv := Round(aBsHrsAtiv[nCnt2]  * aParProf[3], 2)
				nVlDsrProf := Round((aBsDsrProf[nCnt2] + If(lHAtvBsDsr,nVlHrsAtiv,0) ) * aParProf[2], 2)
			Else
				nVlDsrProf := Round( aBsDsrProf[nCnt2] * aParProf[2], 2)
				nVlHrsAtiv := Round((aBsHrsAtiv[nCnt2] + nVlDsrProf ) * aParProf[3], 2)
			EndIf
		EndIf

		If nCnt3 == 1
			aOSlPrf[nCnt2,1] := aTotTarefa[nCnt2]	// Salario
			aOSlPrf[nCnt2,2] := nVlDsrProf			// DSR
			aOSlPrf[nCnt2,3] := nVlHrsAtiv 			// Horas Atividade
		Else
			aSalProf[nCnt2,1] := aTotTarefa[nCnt2] // Salario
			aSalProf[nCnt2,2] := nVlDsrProf			// DSR
			aSalProf[nCnt2,3] := nVlHrsAtiv 		// Horas Atividade
		EndIf
	Next nCnt2
Next nCnt3

aTarefas := aClone( aSvTaref )

//Regrava Horas Atividade somente se mnemonico for true
If lRecriaDsr
	If ( nPos := Ascan(aPd, { |X| X[1] = aCodFol[317,1] .and. X[9] # "D" }) ) > 0 .and. !( aPd[nPos][5] == nVlHrsAtiv )
		aPd[nPos][5] := nVlHrsAtiv
	EndIf
EndIf

If Type("lUtiMultiV") == "U"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se veio de fSalInc() calcula o salario somente sobre as tarefas ³
	//³ fixas, caso contrario calcula sobre as tarefas fixas e variaveis³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lNewProf
		If nDiasAfas > 0 .And. DiasTrab > 0
			SalMes  := Salario := ( (aSalProf[nFixaTotal, 1] + aSalProf[nFixaTotal, 2] + aSalProf[nFixaTotal, 3]) / DiasTrab * nDiasC)
		Else
			SalMes  := Salario := aSalProf[nFixaTotal, 1] + aSalProf[nFixaTotal, 2] + aSalProf[nFixaTotal, 3]
		EndIf
	Else
		SalMes  := Salario := aOSlPrf[nFixaTotal, 1] + aOSlPrf[nFixaTotal, 2] + aOSlPrf[nFixaTotal, 3]
	EndIf

	SalDia  := SalDor  := SalMes / nDiasC
	SalHora := SalHor  := SalMes / nHrsCal
	Salario := SalMes
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fPSlProf ³ Autor ³ Equipe Rh             ³ Data ³ 14/10/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Proporcionaliza salario do professor                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fPSlProf()									              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fPSlProf(aTarefas,lProp,lDsrHrsAtiv)
Local nCnt
Local lDsrBsHAtv := SRV->( RetValSRV(aCodFol[033,1],SRA->RA_FILIAL,"RV_HRSATIV") ) == "S" // Dsr base para Hora atividade
Local lHAtvBsDsr := SRV->( RetValSRV(aCodFol[317,1],SRA->RA_FILIAL,"RV_DSRPROF") ) == "S" // Hora atividade base para Dsr
Local nVlDsrProf := 0
Local nVlHrsAtiv := 0
Local nVADsrProf := 0	// Valor do DSR de Professores para tarefas variaveis
Local nVAHrsAtiv := 0	// Valor da Hora Atividade de Professores para tarefas variaveis
Local nPos		 := 0
Local nPosTar	 := 0
Local lPropTar   := GetMvRH("MV_PROPTAR",,.F.)   //-- Indica se deve clcular o salario variavel proporcionalmente aos dias trabalhados no mes.
Local aTarAux	 := {}

DEFAULT lDsrHrsAtiv := .T.         //  Calcula Primeiro o DSR depois Horas Atividade
DEFAULT aTarefas := {}
DEFAULT lProp    := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Situacao do Funcionario na data de referencia				 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cSitFolh := If( Type("cSitFolh")=="U",SRA->RA_SITFOLH,cSitFolh )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Admitido no mes de processamento             				 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lAdmissao	:= If( Type("lAdmissao")=="U",MesAno(SRA->RA_ADMISSA) == MesAno(dDataAte),lAdmissao)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao proporcionaliza qdo. novo calulo: MV_NCPROF = 1          ³
//³ Proporcionaliza afastados nao demitidos ou conforme parametro³
//³ Proporcionaliza admitidos no mes tambem.                     ³
//³ Proporcionaliza Tarefas nas rescisao considerando MV_PROPTAR ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( ( !Empty(cSitFolh) .And. cSitFolh # "D" ) .Or. lProp .Or. lAdmissao .or. ( !Empty(dDataDem) .and. lPropTar ) ) .And. !lNewProf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Proporcionaliza as tarefas referente ao salario do professor ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCnt := 1 To Len(aTarefas)
		nVlHrsAtiv := 0
		nVlDsrProf := 0
		nPos := Ascan(aPd, { |X| X[1] + X[2] = aTarefas[nCnt,1] + aTarefas[nCnt,5]  .And. X[9] # 'D'})
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Qdo Tarefa eh variavel e sao pagas numa mesma verba, no aPD   ³
		//³elas ja vem somadas, portanto não posso proporcionalizar-las  ³
		//³tantas vezes qtas forem o numero de lancamentos no aTarefas   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPosTar	:=ascan(aTarAux , {|x| X == aTarefas[nCnt,1] + aTarefas[nCnt,5] }  )

		If nPos > 0 .and. nPosTar <= 0
			If aTarefas[nCnt,9] == "1" .or.  ( lPropTar  .and.  aTarefas[nCnt,9] == "2")
				aPd[nPos,4] := (aPd[nPos,4] / nDiasC ) * Diastrab
				aPd[nPos,5] := Round( aPd[nPos,5] / nDiasC * Diastrab, MsDecimais(1))
				//-- Desconsidera elemento se o valor resultante for nulo
				If aTarefas[nCnt,9] == "1" .and. Empty(aPd[nPos,5])
					aPd[nPos,9] :='D'
				EndIf
				aadd(aTarAux, aTarefas[nCnt,1] + aTarefas[nCnt,5] ) 						//-- Utilizada para nao permitir que uma mesma verba proveniente do aTarefa seja proprorcionalizada novamente
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Guarda o valor de hora atividade e dsr s/tarefas variaveis.  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SRV->( PosSrv(aTarefas[nCnt,1],SRA->RA_FILIAL) )
				If lDsrHrsAtiv // Calcula DSR e sobre ele a Hora Atividade
					If SRV->RV_DSRPROF == "S"
						nVlDsrProf := Round(aPd[nPos,5] * aParProf[2], 2)
					EndIf
					If SRV->RV_HRSATIV == "S"
						nVlHrsAtiv := Round((aPd[nPos,5] + If(lDsrBsHAtv,nVlDsrProf,0) ) * aParProf[3], 2)
					EndIf
				Else           // Calcula Hora Atividade e sobre ela o DSR
					If SRV->RV_HRSATIV == "S"
						nVlHrsAtiv := Round(aPd[nPos,5]  * aParProf[3], 2)
					EndIf
					If SRV->RV_DSRPROF == "S"
						nVlDsrProf := Round((aPd[nPos,5] + If(lHAtvBsDsr,nVlHrsAtiv,0) ) * aParProf[2], 2)
					EndIf
				EndIf
				nVADsrProf += nVlDsrProf
				nVAHrsAtiv += nVlHrsAtiv
			EndIf
		EndIf
	Next nCnt
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Proporcionaliza o DSR                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPos := Ascan(aPd, { |X| X[1] = aCodFol[033,1] .And. X[9] # 'D'})
	If nPos > 0
		aPd[nPos,5] := aPd[nPos,5] - nVADsrProf
		aPd[nPos,4] := (aPd[nPos,4] / nDiasC ) * Diastrab
		aPd[nPos,5] := Round( aPd[nPos,5] / nDiasC * Diastrab, MsDecimais(1))
		aPd[nPos,5] := aPd[nPos,5] + nVADsrProf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Proporcionaliza as Horas Atividades                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPos := Ascan(aPd, { |X| X[1] = aCodFol[317,1] .And. X[9] # 'D'})
	If nPos > 0
		aPd[nPos,5] := aPd[nPos,5] - nVAHrsAtiv
		aPd[nPos,4] := (aPd[nPos,4] / nDiasC ) * Diastrab
		aPd[nPos,5] := Round( aPd[nPos,5] / nDIasC * Diastrab, MsDecimais(1))
		aPd[nPos,5] := aPd[nPos,5] + nVAHrsAtiv
	EndIf
EndIf

Return Nil



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fDIndProf ºAutor  ³Emerson             º Data ³  26/05/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Apura os dias indenizados referente a demissao antes do 	  º±±
±±º          ³termino do semestre ou no periodo de recesso.               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fDIndProf(nDiasIndP,dDatSemInf,dDatRecInf,nDIndSem,nDIndRec)
Local aArea     := Getarea()
Local nDiasVenc := nDiasProp := 0
Local dPIDem1Sm := CtoD("")
Local dPIDem2Sm := CtoD("")
Local dFimPer2	:= CtoD("")
Local cMIni1Sm	, cMFim1Sm	, cMIni2Sm	,cMFim2Sm
Local dDtIni1Sm , dDtFim1Sm	, dDtIniPSm
Local dDatCalc 	, dDtIni2Sm	, dDtFim2Sm
Local nAnoIni	, nAnoFim

DEFAULT dDatSemInf := CTOD("")
DEFAULT dDatRecInf := CTOD("")

nA13oIndP := nDiasIndP := nDIndSem := nDIndRec := 0

dbSelectArea( "RCE" )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MNEMONICOS ESPECIAIS - DE ACORDO COM CADA SINDICATO			 ³
//³ Caso o usuario precise configurar para cada sindicato, devera³
//³ criar os campos no cadastro de sindicato RCE e, atraves das  ³
//³ formulas, igualar os mnemonicos aos campos do RCE.           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//P_PIDEM1SM := "DD/MM"   //"Dia/Mes p/demissao sem pgto indeniz. 1o.Sm"
//P_PIDEM2SM := "DD/MM"   //"Dia/Mes p/demissao sem pgto indeniz. 2o.Sm"
//P_CCAVITRA := "N"		 //"Conta aviso como dias trab. na indenizacao"
//P_PAGRECES := "N"		 //"Pagar indenizacao referente o recesso"
//P_PAGINDFD := "N"       //"Pagar os dias indeniz. sobre ferias e 13o"
//P_NDRECALS := "0"       //"Dias de recesso ate o inicio do Proximo Ano Letivo "

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Data utilizada para o calculo                            	 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dDatCalc := dDataDem + If( P_CCAVITRA == "S", nDiasAv, 0 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Meses do periodo letivo                                  	 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cMIni1Sm := Substr(RCE->RCE_INI1SM,3,2)  //Mes inicial 1o. semestre
cMFim1Sm := Substr(RCE->RCE_FIM1SM,3,2)  //Mes final   1o. semestre
cMIni2Sm := Substr(RCE->RCE_INI2SM,3,2)  //Mes inicial 2o. semestre
cMFim2Sm := Substr(RCE->RCE_FIM2SM,3,2)  //Mes final   1o. semestre

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta data de inicio e fim do 1o. semestre					 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nAnoFim   	:= Year(dDatCalc)
nAnoIni   	:= If( cMIni1Sm <= cMFim1Sm, nAnoFim, nAnoFim - 1 )
dDtIni1Sm 	:= Ctod( Transform(RCE->RCE_INI1SM, "@R 99/99") + "/" + Strzero( nAnoIni,   4), "DDMMYY")
dDtFim1Sm 	:= Ctod( Transform(RCE->RCE_FIM1SM, "@R 99/99") + "/" + Strzero( nAnoFim,   4), "DDMMYY")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta data de inicio do proximo semestre 					 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dDtIniPSm := Ctod( Transform(RCE->RCE_INI1SM, "@R 99/99") + "/" + Strzero( nAnoFim+1, 4), "DDMMYY")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta data de inicio e fim do 2o. semestre					 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nAnoFim   := Year(dDatCalc)
nAnoIni   := If( cMIni2Sm <= cMFim2Sm, nAnoFim, nAnoFim - 1 )
dDtIni2Sm := Ctod( Transform(RCE->RCE_INI2SM,"@R 99/99") + "/" + Strzero( nAnoIni, 4), "DDMMYY")
dDtFim2Sm := Ctod( Transform(RCE->RCE_FIM2SM,"@R 99/99") + "/" + Strzero( nAnoFim, 4), "DDMMYY")
dFimPer2  := Ctod( Transform(RCE->RCE_FIM2SM,"@R 99/99") + "/" + Strzero( year(dDataDem),   4), "DDMMYY")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta a data ideal para efetuar a demissao             		 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( P_PIDEM1SM )
	dPIDem1Sm  := Ctod( Transform(P_PIDEM1SM,"@R 99/99") + "/" + Strzero( Year(dDtIni1Sm), 4), "DDMMYY")
EndIf
If !Empty( P_PIDEM1SM )
	dPIDem2Sm  := Ctod( Transform(P_PIDEM1SM,"@R 99/99") + "/" + Strzero( Year(dDtIni2Sm), 4), "DDMMYY")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Utiliza a data de apuracao informada.						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( dDatSemInf )
	dDatCalc := dDatSemInf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Apura os dias de Semestralidade								 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If dDatCalc > dDtIni1Sm .And. dDatCalc < dDtFim1Sm
	nDIndSem := dDtFim1Sm - dDatCalc
	If !Empty( dPIDem1Sm ) .And. dDatCalc <= dPIDem1Sm
		nDIndSem := 0
	EndIf
ElseIf dDatCalc > dDtIni2Sm .And. dDatCalc < dDtFim2Sm
	nDIndSem := dDtFim2Sm - dDatCalc
	If !Empty( dPIDem2Sm ) .And. dDatCalc <= dPIDem2Sm
		nDIndSem := 0
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Utiliza a data de apuracao informada.						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( dDatRecInf )
	dDatCalc := dDatRecInf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Apura os dias de Recesso									 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If P_PAGRECES == "S"
	If dDatCalc < dDtIni1Sm
		nDIndRec := dDtIni1Sm - dDatCalc
	ElseIf dDatCalc > dDtFim1Sm .And. dDatCalc < dDtIni2Sm
		nDIndRec := dDtIni2Sm - dDatCalc
	ElseIf dDatCalc > dDtFim2Sm .And. dDatCalc < dDtIniPSm
		nDIndRec := dDtIniPSm - dDatCalc
	ElseIf P_NDRECALS > 0 .and. year(dDatCalc)> year(dDataDem)
		If dDatCalc > dFimPer2 .and. dDatCalc < (dFimPer2+ P_NDRECALS)
			nDIndRec := (dFimPer2+ P_NDRECALS) - dDatCalc
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Totaliza os dias de Semestralidade + Recesso                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nDiasIndP := nDIndSem + nDIndRec

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Apura os avos de ferias e 13o. por conta dos dias Indenizados³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If P_PAGINDFD == "S" .And. nDiasIndP > 0
	nDiasVenc  := 0
	nDiasProp  := 0
	Calc_Fer(dDatCalc,dDatCalc+nDiasIndP,@nDiasVenc,@nDiasProp)
	nDFerIndP   := nDiasVenc + nDiasProp
	fAvos13(@nA13oIndP,dDatCalc+nDiasIndP,0,0,,,dDatCalc)
EndIf

RestArea( aArea )

Return Nil




/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fSalDiss ³ Autor ³ Andreia dos Santos    ³ Data ³ 14.07.03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula Salario Dia Hora e Mes                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fSalDiss(Salario,Salhora,Saldia,Salmes,Tipo)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fSalDiss( Salario, SalHora, SalDia, SalMes, cTipo, cTipAum )
Local aArea			:= GetArea()
Local cDatarq		:= StrZero( Year( dDataAte ), 4, 0 ) + StrZero( Month( dDataAte ),2)
Local cPerAux		:= ""
Local cAnoMesPesq	:= cMesAnoCalc//Left( cAnoMes, 4 ) + Right( cAnoMes, 2 )
Local cCatFunc		:= SRA->RA_CATFUNC
Local cTipoPgt		:= SRA->RA_TIPOPGT
Local cAliasDis		:= "RHH"
Local lMAprendiz  	:= GetMvRH("MV_MAPREND",,.F.)
Local lAchou 		:= .F.
Local lDifInc		:= .F.
Local cMes			:= SubStr(cAnoMes,5,2)
Local cAno			:= SubStr(cAnoMes,1,4)
Local cPDs			:= ACODFOL[13,1]+"/"+ACODFOL[14,1]+"/"+ACODFOL[19,1]+"/"+ACODFOL[20,1]+"/"+ACODFOL[64,1]+"/"+ACODFOL[65,1]+"/"+ACODFOL[70,1]
Local dData			:= CtoD("01/" + cMes + "/" + cAno)
Local nNumSemana	:= 0
Local nDiasCalc		:= 0
Local nHrsMes		:= 0
Local nHrsDia		:= 0
Local nValor		:= 0
Local nBaseSal		:= 0
Local nBaseAux		:= 0
Local nPisoSal		:= 0
Local nSalAnt		:= SalMes
Local nCond			:= Nil

If cTipoRot == "3"
	nCond := 11
ElseIf cTipoRot == "4"
	nCond := 12
EndIf

nDisSalInc := 0

Aeval( aPd ,{ |x| If( (!(AllTrim(x[7]) $ "P*S*A*K*C*R*V") .OR. x[1] $ ACODFOL[28,1]+"/"+ACODFOL[348,1]) .AND. !(x[1] $ CPDS), SomaInc(X,18,@nDisSalInc,nCond,"S" , , , , ,aCodfol),) }) //SOMA AS VERBAS QUE INCORPORAM SALÁRIO

//Utiliza os dias de cálculo de aPeriodo pois em fCarPeriodo o array é criado com os dados da época.
nDiasCalc	:= APERIODO[NPOSSEM,20]

If SRA->RA_CATFUNC == "M" .AND. Day(SRA->RA_ADMISSA) > 1 .AND. AnoMes(SRA->RA_ADMISSA) == CPERIODO
	nDiasCalc := IF( ( APERIODO[NPOSSEM,18] == 31 .OR. APERIODO[NPOSSEM,16] == "02" ) .AND. P_DIASADM == 1, APERIODO[NPOSSEM,18], APERIODO[NPOSSEM,20])
EndIf

nHrsDia := SRA->RA_HRSDIA

SR9->(DbSetOrder(1))

If SR9->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + "RA_HRSMES "))
	While SR9->( !Eof() ) .and. SRA->RA_FILIAL + SRA->RA_MAT == SR9->R9_FILIAL+SR9->R9_MAT .AND. ("RA_HRSMES" $ SR9->R9_CAMPO)
		If SR9->R9_DATA <= dDataAte
			nHrsMes := Val( SR9->R9_DESC )
		Else
			Exit
		EndIf

		SR9->( dbSkip() )
	EndDo

	If nHrsMes > 0
		nHrsDia := Round(( nHrsMes / 30 ),4)
		nHrsMes := Round(( nHrsDia * nDiasCalc),2)
		Normal  := aPeriodo[nPosSem,24] * nHrsDia
		Descanso:= aPeriodo[nPosSem,07] * nHrsDia
		NHRSCAL := Round((nHrsDia * NDIASC),2) //Mnemonico
	EndIf
EndIf

If nDiasCalc > 0 .And. nHrsDia > 0 .and. nHrsMes == 0
	If SRA->RA_CATFUNC == 'H' .and. cTipoRot $ "5/6"
		nHrsMes := SRA->RA_HRSMES
	else
		nHrsMes := Round((nHrsDia * nDiasCalc),2)
	EndIf
EndIf

dbSelectArea( 'SR3' )
If !Empty(SR3->(INDEXKEY(2)))
	dbSetorder(2)
EndIf

If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT )
	While SR3->(!EOF()) .AND. SR3->R3_FILIAL + SR3->R3_MAT == SRA->RA_FILIAL + SRA->RA_MAT
		If SR3->R3_PD == '000' .and. mesAno(SR3->R3_DATA) <= cDatarq
	      	cCatFunc := fDesc( "SR7", SR3->R3_MAT+DTOS(SR3->R3_DATA)+SR3->R3_SEQ+SR3->R3_TIPO, "R7_CATFUNC", , SRA->RA_FILIAL, 2 )
	      	cTipoPgt := fDesc( "SR7", SR3->R3_MAT+DTOS(SR3->R3_DATA)+SR3->R3_SEQ+SR3->R3_TIPO, "R7_TIPOPGT", , SRA->RA_FILIAL, 2 )
	 	EndIf
	 	SR3->(DbSkip())
	 EndDo
EndIf

lAchou := (cAliasDis)->(	dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cAnoMesPesq + cDatarq + "000" ) )

If cTipoRot == "3" .and. lCalcFol .and. (!lAchou .OR. ( cPeriodo < cSvSetPer .and. SRA->RA_CATFUNC == cCatFunc ) ) .and. (nDiasFMS + NDIASABMS) > 0//Se for calculo de diferença de férias e existir dias de férias no mês seguinte, procura pelo dissidio no mes seguinte.
	cPerAux		:= StrZero( Year( MonthSum(dDataAte,1) ), 4, 0 ) + StrZero( Month( MonthSum(dDataAte,1) ),2)
	lAchou := (cAliasDis)->(	dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cAnoMesPesq + cPerAux + "000" ) )
	If !lAchou //Se não encontrou no mes atual, retorna para o ms anterior
		lAchou := (cAliasDis)->(	dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cAnoMesPesq + cDatarq + "000" ) )
	EndIf
EndIf

If lAchou

	Begin Sequence
		// Menor Aprendiz
		If SRA->RA_CATEG = '07' .And. lMAprendiz
			 Do Case
				Case F_ULTDIA(dData) == 31
					nNumSemana := 4.428571
				Case F_ULTDIA(dData) == 30
					nNumSemana := 4.285714
				Case F_ULTDIA(dData) == 29
					nNumSemana := 4.142857
				Case F_ULTDIA(dData) == 28
					nNumSemana := 4
			EndCase
			If cCatFunc = "H"
				nValor :=  nHrsMes  / 5
				nValor := (nValor * nNumSemana) * (cAliasDis)->&((cAliasDis)+"_CALC")
				SalMes := (nValor * 7 ) / 6
			ElseIf cCatFunc = "M"
			   	Salmes := (cAliasDis)->&((cAliasDis)+"_CALC")
			EndIf
			Salario  := SalMes
			Break
		EndIf

		If Type("P_LDIFINC") <> "U" .And. P_LDIFINC .And. fDifIncorp()
			nBaseSal := SalMes
			lDifInc	 := .T.
		Else
			nBaseSal := (cAliasDis)->&((cAliasDis)+"_CALC")
		EndIf

		If cTipoRot == "3" .And. AnoMes(SRH->RH_DATAINI) < cSvSetPer
			nBaseAux := 0

			If SR3->(dbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
				While SR3->(!EOF()) .AND. SR3->R3_FILIAL + SR3->R3_MAT == SRA->RA_FILIAL + SRA->RA_MAT
					If SR3->R3_PD == '000' .and. AnoMes(SR3->R3_DATA) == cSvSetPer .And. SR3->R3_VALOR > nBaseSal .And. cCatFunc == fDesc( "SR7", SR3->R3_MAT+DTOS(SR3->R3_DATA)+SR3->R3_SEQ+SR3->R3_TIPO, "R7_CATFUNC", , SRA->RA_FILIAL, 2 )
						nBaseAux := nBaseSal := SR3->R3_VALOR
				 	EndIf
				 	SR3->(DbSkip())
				 EndDo
				 If nBaseAux > 0
					If cCatFunc $ "M"
						nPisoSal := nPisoMes
					ElseIf cCatFunc $ "C*P*A*E"
						If cTipoPgt = "M"
							nPisoSal  := nPisoMes
						ElseIf cTipoPgt = "S"
							nPisoSal  := nPisoDia * 7
						EndIf
					ElseIf cCatFunc $ "H*T*G*"
						nPisoSal  := nPisoHora
					ElseIf cCatFunc $ "D"
						nPisoSal  := nPisoDia
					ElseIf cCatFunc $ "S"
						nPisoSal  := nPisoDia * 7
					EndIf
				 EndIf
			EndIf

			If nBaseSal == 0 //Se não houve alteração salarial no mês de retorno das férias
				If cCatFunc $ "M"
					nBaseSal := SRH->RH_SALARIO
					nPisoSal := nPisoMes
				ElseIf cCatFunc $ "C*P*A*E"
					If cTipoPgt = "M"
						nBaseSal  := SRH->RH_SALARIO
						nPisoSal  := nPisoMes
			   		ElseIf cTipoPgt = "S"
			   			nBaseSal  := SRH->RH_SALDIA * 7
			   			nPisoSal  := nPisoDia * 7
			   		EndIf
				ElseIf cCatFunc $ "H*T*G*"
					nBaseSal  := SRH->RH_SALHRS
					nPisoSal  := nPisoHora
				ElseIf cCatFunc $ "D"
					nBaseSal  := SRH->RH_SALDIA
					nPisoSal  := nPisoDia
				ElseIf cCatFunc $ "S"
					nBaseSal  := SRH->RH_SALDIA * 7
					nPisoSal  := nPisoDia * 7
				EndIf
			EndIf

			If lDifInc
				nBaseSal := If (!Empty(RHH->RHH_VALOR), nBaseSal + RHH->RHH_VALOR, nBaseSal * (1+ (RHH->RHH_INDICE/100)))
			EndIf
			If nPisoSal > nBaseSal
				nBaseSal := nPisoSal
			EndIf
		EndIf

		If cCatFunc $ "M"
			SalMes  := nBaseSal
			SalHora	:= nBaseSal / nHrsMes
			SalDia	:= nBaseSal / nDiasCalc
		ElseIf cCatFunc $ "C*P*A*E"
			If cTipoPgt = "M"
				SalMes  := nBaseSal
				SalHora := nBaseSal / nHrsMes
				SalDia	:= nBaseSal / nDiasCalc
	   		ElseIf cTipoPgt = "S"
	   			SalMes  := nBaseSal / 7 * nDiasCalc
	   			SalHora := ( nBaseSal / 7 ) / nHrsDia
				SalDia	:= nBaseSal / 7
	   		EndIf
	    ElseIf cCatFunc $ "H*T*G*"
				SalMes  := nBaseSal * nHrsMes
				SalHora := nBaseSal
				SalDia	:= nBaseSal * nHrsDia
		ElseIf cCatFunc $ "D"
				SalMes  := nBaseSal * nDiasCalc
				SalHora := nBaseSal / nHrsMes
				SalDia	:= nBaseSal
		ElseIf cCatFunc $ "S"
	   			SalMes  := nBaseSal / 7 * nDiasCalc
	   			SalHora := ( nBaseSal / 7 ) / nHrsDia
				SalDia	:= nBaseSal / 7
		EndIf

		SALARIO := SALMES
	    SALHOR  := SALHORA
	    SALDOR  := SALDIA

    End Sequence

    If nSalAnt <> Salmes .and. nDisSalInc > 0 //Soma os valores incorporados na fCarMvto()
    	SalMes += nDisSalInc
    EndIf

EndIf

RestArea(aArea)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncoa    ³fVlDiss   ºAutor  ³Andreia Santos      º Data ³  29/09/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calcula o reajuste do dissidio para verbas lancadas em valorº±±
±±º          ³Verifica se foi criado o campo RV_VALDISS e se ele esta com º±±
±±º          ³"sim" para calculo da verba lancada em valor.               º±±
±±º          ³Essa funcao devera ser chamada atraves de uma formula, apos º±±
±±º          ³testar se o mnemonico "lDissidio" e verdadeiro.             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVlDiss()

Local nPerc		:= 0
Local nX		:= 1

// Tratamento da existencia da Nova tabela de Dissidio Permanente (RHH)
Local cAliasDis
Local cDataArq

If cTipoRot <> "4"
	//-- Nao executa teste do cadastro de formulas pois a funcao nao foi idealizada para tanto
	If  TYPE("CMESANODISS") <> "U"
	    cAliasDis	:= Iif( Sx2ChkTable( "RHH" ), "RHH", "TRB" )
	    cDataArq	:= StrZero( Year( dDataAte ), 4, 0 ) + StrZero( Month( dDataAte ), 2 )
		If Select( cAliasDis ) > 0
			If (cAliasDis)->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cMesAnoDiss + cDataArq + "000" ) )
				nPerc := (cAliasDis)->&((cAliasDis)+"_INDICE")

				If nPerc == 0 .and. nValAum > 0
					//Obtem o percentual de aumento com base no valor fixo do reajuste
					nPerc := Round( ( ( (cAliasDis)->&((cAliasDis)+"_CALC") * 100 ) / (cAliasDis)->&((cAliasDis)+"_VL") ) - 100, 6)
				EndIf

				For nX := 1 to len(aPD)
					If aPd[nX,6] == "V"
				 	   	If RetValSRV(aPd[nX,1], SRA->RA_FILIAL, "RV_VALDISS") == "1" .And. (cPaisLoc != "BRA" .Or. aScan( aDissInf, { | X | SRA->RA_FILIAL + SRA->RA_MAT + cRotOrig + cPeriodo + cSemPag + aPd[nX,1] == X[1] + X[2] + X[3] + X[4] + X[5] + X[6] .And. x[7] == aPd[nX,5] } ) == 0)
							aPd[nX,5]	:= aPd[nX,5] * (1+ (nPerc/100))
							If aPd[nX,19] < aPd[nX,5]
								aPd[nX,19]  := aPd[nX,5] //Se foi lançamento fixo proporcional a verba integral foi gravada pela fCalcRG1
							EndIf
				 	   	EndIf
					EndIf
				Next
			EndIf
		EndIf
	EndIf
Else
	If lRescDis
		nPerc   := Round(((SRA->RA_SALARIO - SRG->RG_SALMES) * 100) / SRG->RG_SALMES,2)
		For nX := 1 to Len(aPD)
			If aPd[nX,6] =="V"
		 	   	If RetValSRV(aPd[nX,1],SRA->RA_FILIAL,"RV_VALDISS")=="1"
					aPd[nX,5]	:= aPd[nX,5] * (1+ (nPerc/100))
		 	   	EndIf
			EndIf
		Next nX
	EndIf
EndIf

Return( .T. )

/*/{Protheus.doc} fDissCC
Buscar o centro de custo à época do cálculo
@author Henrique Ferreira v.1
		Leandro Drumond   v.2
@since 01/10/2018
@param
@type static function
/*/
Static Function fDissCC()

Local cCusto  := SRA->RA_CC
Local uRet

If HMGet(oPercDif, SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo, uRet)
	cCusto := uRet[4]
EndIf

Return cCusto


/*/{Protheus.doc} function FMARGCS
Funcao que realiza o calculo da margem consignavel para o funcionario.
@author  Hugo de Oliveira
@since   08/12/2020
@version 1.0
/*/
Function FMARGCS()
	Local cConsigPd  := ""
    Local nMargem    := 0
    Local nSoma      := 0
    Local nVlPercent := 0

    cConsigPd := aCodFol[1857,1]

    If !Empty(cConsigPd)
        aEval(aPD, { |X| SomaInc(X, 38, @nSoma, Nil, Nil, Nil, Nil, Nil, Nil, aCodFol)})
    
        nVlPercent := RetValSRV(cConsigPd, cFilAnt, "RV_PERC") / 100
        nMargem    := nSoma * nVlPercent

        // Gera a verba para o calculo da folha
        fMatriz(cConsigPd, nMargem) // Realiza a gravacao de mais uma linha no array de verbas(aPd).
    EndIf
Return
