#INCLUDE "PONM1070.CH"
#INCLUDE "PROTHEUS.CH"  
#INCLUDE "PONCALEN.CH" 

   
Static lPonCalmBlock
Static lPonCalrBlock
Static lPonCalaTotBlock
Static lPonCaldBlock
Static lPonCalHeBlock
Static lPnm070CposBlock              
Static lPnmBh01Block   
Static lPnm07001Block
Static lPnmDSR01Block   
Static lPnmDSR02Block   
Static lPonEveContBlock


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ PONM070  ³ Autor ³ Fernando Joly Siquini ³ Data ³ 19/01/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Consolidacao de Resultados (Calculo Mensal)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ SIGAPON				             						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Marinaldo   ³16/04/01³Melhor³Utilizacao da Funcao GetTabArred() para  a³±±
±±³            ³--------³------³Montagem dos Arredondamentos e da   Funcao³±±
±±³            ³--------³------³GetTabExtra() para a Montagem dos Tipos de³±±
±±³            ³--------³------³Horas Extras. Ambas efetuando o   Tratamen³±±
±±³            ³--------³------³to de Acordo com o Turno de aTabCalend.   ³±±
±±³Marinaldo   ³09/05/01³Melhor³Gravacao dos Eventos nos Apontamentos    e³±±
±±³            ³--------³------³Banco de Horas por Centro de Custo.       ³±±
±±³Marinaldo   ³06/09/01³Acerto³ Gerar Refeicoes em Resultados mesmo   que³±±
±±³            ³--------³------³ Nao Hajam Apontamentos.                  ³±±
±±³Mauricio MR ³08/10/01³Acerto³ Leitura de Todos os Abonos do SPK para a ³±±
±±³            ³--------³------³ correta apropriacao dos Eventos relaciona³±± 
±±³            ³--------³------³ dos aos abonos. Antes, os abonos nao eram³±± 
±±³            ³--------³------³ lidos e as horas eram acumuladas em eve- ³±±
±±³            ³--------³------³ ntos diversos.							  ³±±  
±±³Marinaldo   ³18/10/01³Acerto³ A Cada Mudanca de Periodo Atualizar  auto³±±
±±³            ³--------³------³ maticamente as Perguntas Referentes ao pe³±±  
±±³            ³--------³------³ riodo De/Ate e Verificar, quando as datas³±±  
±±³            ³--------³------³ forem informadas pelo usuario, se   estao³±±  
±±³            ³--------³------³ dentro do Periodo de Apontamento em  aber³±±  
±±³            ³--------³------³ to e Inclusao da Funcao fChkSX1()		  ³±±  
±±³Mauricio MR ³24/10/01³Acerto³ Correcao controle sobre abonos. Reinicia-³±±
±±³            ³--------³010637³ lizada variaveis cAbono.				  ³±± 
±±³            ³--------³010777³                         				  ³±± 
±±³            ³--QNC---³001694³                            			  ³±± 
±±³Marinaldo   ³23/10/01³Acerto³ Tratamento dos Tipos de Horas Extras  "A"³±±
±±³            ³--------³------³ e "B" na Apuracao do Banco de Horas e no ³±± 
±±³            ³--------³------³ Calculo Mensal quando o Periodo de  Apura³±± 
±±³            ³--------³------³ cao das Horas Extras for diferente de Dia³±± 
±±³            ³--------³------³ rio									  ³±± 
±±³Marinaldo   ³01/11/01³Melhor³ Inclusao do Ponto de Entrada PONCALR para³±±
±±³            ³--------³------³ tratamento especifico de Refeicoes		  ³±± 
±±³Marinaldo   ³06/11/01³010922³Tratamento de Troca de Regra de  Apontamen³±±
±±³            ³--------³------³to.    									  ³±±
±±³Mauricio MR ³23/11/01³004933³Desconto de DSR sem Cadastro de Arredonda-³±±
±±³            ³--------³------³mento.        					          ³±±
±±³Marinaldo   ³23/11/01³Acerto³Reformulacao da Logica para o   Tratamento³±±
±±³            ³--------³------³do campo PA_NUMATRA				          ³±±
±±³Marinaldo   ³26/11/01³Melhor³Utilizacao da Funcao PonDestroyStatic()que³±±
±±³            ³--------³------³sera utilizada para Reinicializar as Varia³±±
±±³            ³--------³------³veis Staticas do SIGAPON				  ³±±
±±³Mauricio MR ³30/11/01³Melhor³Substituicao da Funcao GetNewPar pela     ³±±
±±³            ³--------³------³GetMv.        					          ³±± 
±±³Mauricio MR ³10/12/01³Acerto³Complementacao Parametros em fAbonos:     ³±±
±±³            ³--------³------³TpMarca e C.C.					          ³±± 
±±³Mauricio MR ³28/12/01³Acerto³A)Criado paramentro lLimDSR.              ³±±
±±³            ³--------³------³Limita Desconto de DSR ao Periodo de Apura³±±
±±³            ³--------³------³cao. Se o periodo for Mensal,por exemplo, ³±±
±±³            ³--------³------³teremos 1  Desconto DSR, Quinzenal 2 Desco³±±
±±³            ³--------³------³nto DSR,... Antes estava gerando Desconto ³±±
±±³            ³--------³------³baseado no no. de ocorrencias de DSR e qdo³±±
±±³            ³--------³------³limitavamos a tabela de arredondamento nao³±±
±±³            ³--------³------³funcionava.                               ³±±
±±³Mauricio MR ³07/01/02³012308³A)Acerto na fDescDSR.                     ³±±
±±³            ³--------³------³Correcao no Posicionamento do SPK devido  ³±±
±±³            ³--------³------³ao uso da fAbonos. Nao considerava a exis-³±±
±±³            ³--------³------³tencia de mais de um motivo para o mesmo  ³±±
±±³            ³--------³------³abono e deixava de verificar quais motivos³±±
±±³            ³--------³------³abonavam as horas para calculo de Desc.DSR³±±
±±³Marinaldo   ³08/02/02³Melhor³Utilizacao da Funcao HrsSem2OneDsr()  para³±±
±±³            ³--------³------³Apuracao das Horas de DSR correspondente a³±±
±±³            ³--------³------³1 Dia. da Semana						  ³±±
±±³Marinaldo   ³21/02/02³Melhor³Substituicao do Help "FORAPER" pelo   Help³±±
±±³            ³--------³------³"PONFORAPER"    						  ³±±
±±³Marinaldo   ³01/03/02³Acerto³Alterada fCalcPer() por estar dando   erro³±±
±±³            ³--------³------³quando a Apuracao do Atraso era Semanal. O³±±
±±³            ³--------³------³Indice do Array aTotEve estava como nX Qdo³±±
±±³            ³--------³------³o Correto seria nT.						  ³±±
±±³MauricioMR  ³11/03/02³Melhor³Retirada da Verificacao de Cod.Folha no E-³±±
±±³            ³--------³------³vento associado ao Abono,no momento em es-³±±
±±³            ³--------³------³te eh adicionado ao aTotais. Visto que so-³±±
±±³            ³--------³------³mente devemos verificar ao gravar no SPB- ³±±
±±³            ³--------³------³Resultados. Alem disso, nao era possivel  ³±±
±±³            ³--------³------³gerar lancamento em B.Horas.              ³±± 
±±³MauricioMR  ³14/03/02³Acerto³Carrega Todos os Eventos que possuem Id.de³±±
±±³            ³--------³------³Ponto mas sem integracao com a Folha.Antes³±±
±±³            ³--------³------³carregava-se somente aqueles que iam para ³±± 
±±³            ³--------³------³B.Horas ou Integracao com a Folha.        ³±± 
±±³Marinaldo   ³11/04/02³Melhor³Modificada Chamada a    PonDestroyStatic()³±±
±±³            ³--------³------³para que reinicialize todas as Statics  do³±± 
±±³            ³--------³------³SIGAPON.								  ³±± 
±±³            ³--------³------³Inclusao da Variavel cFilSPD que   servira³±± 
±±³            ³--------³------³Para armazenar o Conteudo da Filial do SPD³±± 
±±³            ³--------³------³Alteracao na Chamada em GetTabArred() e in³±± 
±±³            ³--------³------³clusao da funcao RetTabArred() para a  car³±± 
±±³            ³--------³------³ga das Tabelas de Arredondamentos de DSR e³±± 
±±³            ³--------³------³Alteracao na Chamada a GetTabExtra()      ³±± 
±±³            ³--------³------³Utilizacao de MsSeek() para posicionamento³±± 
±±³            ³--------³------³na Regra de Apontamento na Funcao fDescDsr³±± 
±±³Marinaldo   ³03/05/02³Melhor³Verificar a Existencia dos Pontos de Entra³±±
±±³            ³        ³      ³da no Inicio do Programa.                 ³±±
±±³Marinaldo   ³06/05/02³Acerto³Se na Ultima Semana Funcionario tivesse  e³±±
±±³            ³        ³      ³vento para desconto de DSR e nao   tivesse³±±
±±³            ³        ³      ³DSR a ser descontado Sistema Gerava Evento³±±
±±³            ³        ³      ³de Falta/Atraso Mes Seguinte Autorizado ou³±±
±±³            ³        ³      ³nao Autorizado. Mas, se fossem geradas  as³±±
±±³            ³        ³      ³marcacoes para essa ultima semana de forma³±±
±±³            ³        ³      ³a nao ser gerado evento que incidisse   no³±±
±±³            ³        ³      ³Desconto de DSR o sistema nao estava   apa³±±
±±³            ³        ³      ³gando o evento de DSR Mes Seguinte Gerado ³±±
±±³Mauricio MR ³09/05/02³14827 ³ Na apuracao de horas extras diferente de ³±±
±±³            ³--------³------³ Diaria (SPA->PA_PERHEXT <> "D"),calcula- ³±± 
±±³            ³--------³------³ se a funcao fApurBh(). Essa funcao deduz ³±±
±±³            ³--------³------³ do total de horas extras as horas que de-³±±
±±³            ³--------³------³ verao ir para o B.Horas (se SP9->P9_Bhor-³±±
±±³            ³--------³------³ ras = "S"). Para funcionarios cujo campo ³±±
±±³            ³--------³------³ SRA->RA_ACUMBH = "N" (nao acumula H.Ex-  ³±±
±±³            ³--------³------³ HE no B.Horas) o total de HE era zerado e³±±
±±³            ³--------³------³ as H.E. nao eram desmembradas segundo a  ³±±
±±³            ³--------³------³ Tabela de H.E.. Para eliminar a nao con- ³±±
±±³            ³--------³------³ formidade, verificamos o conteudo do cam-³±±
±±³            ³--------³------³ po SRA->RA_ACUMBH e se for = "N" deixamos³±±
±±³            ³--------³------³ de chamar a fApurBH().                   ³±± 
±±³            ³--------³------³B)Retirada a expressao que verifica a exis³±± 
±±³            ³--------³------³ tencia do campo RA_ACUMBH.               ³±± 
±±³            ³--------³------³C)Definicao da data para DSR e Saidas como³±± 
±±³            ³--------³------³ sendo a dData fim do periodo de aponta-  ³±±
±±³            ³--------³------³ mento do Horario Movel (PA_PERHMOV).     ³±±
±±³Marinaldo   ³10/08/02³Melhor³Carregar Periodo de Apontamento de  acordo³±±
±±³            ³--------³------³com a Filial							  ³±±
±±³Marinaldo   ³26/08/02³Melhor³Novo Tratamento para o Abono de Horas     ³±±
±±³Marinaldo   ³04/09/02³Melhor³Inclusao do Parametro MV_DSRPPER          ³±±
±±³Marinaldo   ³23/09/02³Melhor³Tratamento para o novo parametro MV_ARRINT³±±
±±³            ³        ³      ³E que ira definir se o Arredondamento  das³±±
±±³            ³        ³      ³Horas sera feito pela parte    fracionaria³±±
±±³            ³        ³      ³ou integral das Horas					  ³±±
±±³Marinaldo   ³20/12/02³Melhor³Substituicao dos Helps pela geracao do Log³±±
±±³            ³        ³      ³de Inconsistencias						  ³±±
±±³Marinaldo   ³20/12/02³Acerto³Passagem da Filial do Cadastro de Funciona³±±
±±³            ³        ³      ³rios pra a fCargaId(). Sistema nao  estava³±±
±±³            ³        ³      ³Carregando corretamente os Eventos do  Pon³±±
±±³            ³        ³      ³to Quando o SX5 era Exclusivo			  ³±±
±±³Marinaldo   ³07/01/03³Melhor³Nao Mostrar mais o nome do funcionario mas³±±
±±³            ³        ³      ³a Evolucao percentual do calculo Mensal pa³±±
±±³            ³        ³      ³ra GAnho de Performance                   ³±±
±±³            ³        ³      ³Substituicao da processa com uma barra  de³±±
±±³            ³        ³      ³Gauge pela com duas barras				  ³±±
±±³Marinaldo   ³28/01/03³Melhor³Inclusao de Query para selecao das informa³±±
±±³            ³        ³      ³coes do SPC               				  ³±±
±±³MauricioMR  ³10/03/03³Melhor³Inclusao de Tratamento de deducao de Abono³±±
±±³            ³        ³      ³das horas do evento (MV_ABOSEVE)para compa³±±
±±³            ³        ³      ³tibilizar com a versao 609.				  ³±±
±±³MauricioMR  ³25/09/03³66063 ³A)Alterada a chamada da funcao fGeraExtra ³±±
±±³            ³        ³      ³para tratar corretamente o escalonamento  ³±±
±±³            ³        ³      ³de horas extras com apuracao diferente de ³±±
±±³            ³        ³      ³diaria.									  ³±±
±±³            ³        ³Acerto³Liberado Periodo de Calculo Mensal para   ³±±
±±³            ³        ³      ³fora do Periodo de Apontamento.			  ³±±
±±³MauricioMR  ³15/10/03³Acerto³Alterada a Funcao fDescDSR para abonar    ³±±
±±³            ³        ³      ³descontos de DSR quando este ocorrer em   ³±±
±±³            ³        ³      ³datas posteriores a demissao ou durante  o³±±
±±³            ³        ³      ³periodo de afastamento.				  	  ³±±
±±³MauricioMR  ³15/10/03³Bops  ³Eliminada a referencia a funcao fApurBh().³±±
±±³            ³        ³66264 ³Dessa forma, passamos a escalonar todas as³±±
±±³            ³        ³      ³horas extras antes de apurarmos o Banco de³±±
±±³            ³        ³      ³Horas. Antes, as horas na primeira faixa  ³±±
±±³            ³        ³      ³do tipo do dia,quando iam para o banco,nao³±±
±±³            ³        ³      ³eram escalonadas.						  ³±±
±±³MauricioMR  ³30/10/03³Bops  ³Alterada a funcao fEveGerPA() para manter ³±±
±±³            ³        ³67511 ³a data do evento apontado em periodo ante ³±±
±±³            ³        ³      ³rior.Dessa maneira evitamos de descontar  ³±±
±±³            ³        ³      ³o DSR em funcao de faltas ocorridas ante- ³±±                         
±±³            ³        ³      ³rior ao periodo em aberto, por exemplo.	  ³±±
±±³MauricioMR  ³06/11/03³QNC   ³Eliminada a funcao fEveGerPA() para evitar³±±
±±³            ³        ³01412 ³a duplicidade de eventos carregados pela  ³±±
±±³            ³        ³      ³GetLastApo.								  ³±±
±±|Marinaldo   ³21/04/04³Melhor³Tratamento nos Lock dos Registros e Delete|±±  
±±|Mauricio MR ³28/04/04³Melhor³Tratamento de cFilAnt para Integridade	  |±±
±±³Igor Franzoi³10/05/07³      ³Verificar campos a mais para Query p/ SRA ³±± 
±±³Erika K.    ³02/06/08³------³Alteracao no CH e nome de pergunte para   ³±±
±±³            ³        ³      ³compatibilizar dicionarios Mexico e R 1.2.³±±
±±³Leandro Dr. ³14/08/08³------³Ajuste na gravacao das marcacoes de       ³±±
±±³            ³        ³      ³refeicao e banco de horas.                ³±±
±±³Alceu P.    ³02/12/10³SDATZ9³Ajuste na Query que seleciona reg. na SPC ³±±
±±³Leandro DR  ³18/08/11³Melhor³Ajuste p/ considerar divisao de apontamtos³±±
±±³Claudinei S.³11/07/12³TFFVR5³Ajuste na PNM070Proc para que o RV_ACUMULA³±±
±±³            ³        ³      ³acumule as verbas nos resultados na - BOL.³±±
±±³M. Silveira ³10/10/13³THXEEZ³Corrigido o nome da variavel do C.Custo na³±±
±±³            ³        ³      ³chamada das funcoes fGeraTot e fGeraExtra.³±±
±±³Renan Borges³15/02/16³TUEWFT³Ajuste para acumular os resultados mensais³±±
±±³            ³        ³      ³ da bolivia, por mês e não por semana.    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function PONM070() 

Local aArea			:= GetArea()
Local aSays			:= {}
Local aButtons		:= {}
Local cSvFilAnt		:= cFilAnt
Local lBarG1ShowTm 	:= .F.
Local lBarG2ShowTm 	:= .F.
Local nOpcA			:= 0

Private cCadastro   := OemToAnsi( STR0006 ) // 'Consolidacao de Resultados'
Private dPerIni		:= Ctod("//")
Private dPerFim		:= Ctod("//")
Private lAbortPrint := .F.
Private lEveCont	:= ( SP9->(FieldPos(	"P9_EVECONT" )) <> 0 )
Private lAcumEveCont:= ( SP9->(FieldPos(	"P9_ACECONT" )) <> 0 )

Private cCond		:= "1"	  // 1 - Somente periodos abertos
Private cPeriodo 	:= ""	  // Codigo do Periodo
Private cProcesso 	:= ""	  // Codigo do Processo 
Private cNumPagto   := ""	  // Num. de Pagto
Private cRot		:= "PON"  // Roteiro de Calculo

Private oPeriodo		    := RHPERIODO():New()

DEFAULT lPonCalmBlock		:= ExistBlock( "PONCALM"  	)
DEFAULT lPonCalrBlock		:= ExistBlock( "PONCALR"  	)
DEFAULT lPonCalaTotBlock	:= ExistBlock( "PONCALATOT"	)
DEFAULT lPonCaldBlock		:= ExistBlock( "PONCALD"  	)
DEFAULT lPonCalHeBlock		:= ExistBlock( "PONCALHE" 	)
DEFAULT lPnm070CposBlock	:= ExistBlock( "PNM070CPOS"	)
DEFAULT lPnmBh01Block		:= ExistBlock( "PNM070BH01"	)
DEFAULT lPnm07001Block		:= ExistBlock( "PNM07001"	)   
DEFAULT lPnmDSR01Block		:= ExistBlock( "PNMDDSR01"	)
DEFAULT lPnmDSR02Block		:= ExistBlock( "PNMDDSR02"	)
DEFAULT lPonEveContBlock    := ExistBlock( "PNMEVECONT"	)    
    
Pergunte("PONM070", .F. )

cProcesso  := mv_par01
cPeriodo   := mv_par02		
cNumPagto  := mv_par03

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inicializa propriedades do objeto Periodo					   ³
³ O RCH deverah sempre ser compartilhado.					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
oPeriodo:cRoteiro	:= "PON"
oPeriodo:cFilRCH	:= 	xFilial('RCH')

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ So Executa se os Modos de Acesso dos Arquivos Relacionados es³
³ tiverm OK e se For Encontrado o Periodo de Apontamento.      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF ValidArqPon() 

	AADD(aSays,OemToAnsi( STR0003 ) )// 'Esta rotina tem  como objetivo apurar o resultado  final'
	AADD(aSays,OemToAnsi( STR0004 ) )// 'dos eventos calculados em um Per¡odo, possibilitando sua'
	AADD(aSays,OemToAnsi( STR0005 ) )// 'manuten‡„o antes de realizar o Fechamento Mensal.       '
	
	AADD(aButtons, { 5,.T.,{|| Pergunte("PONM070",.T. ) } } )
	AADD(aButtons, { 1,.T.,{|o| nOpcA := 1,IF(gpconfOK(),FechaBatch(),nOpcA := 0 ) }} )
	AADD(aButtons, { 2,.T.,{|o| FechaBatch() }} )
	FormBatch( cCadastro, aSays, aButtons )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Reinicializa Variaveis Staticas para o Consolidacao de 	  ³
	| Resultados (Calculo Mensal)								  |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	PonDestroyStatic()

	IF ( nOpcA == 1 )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se deve Mostrar Calculo de Tempo nas BarGauge			 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		lBarG1ShowTm := ( SuperGetMv("MV_PNSWTG1",NIL,"N") == "S" )
		lBarG2ShowTm := ( SuperGetMv("MV_PNSWTG2",NIL,"S") == "S" )
		/*                               
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Executa o Processo de Leitura/Apontamento       					 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		Proc2BarGauge(  { || PNM070Proc() } , STR0001 , NIL , NIL , .T. , lBarG1ShowTm , lBarG2ShowTm ) // 'Realizando consolidacao de resultados (calculo mensal)... '
	EndIF

EndIF

cFilAnt := cSvFilAnt
RestArea( aArea )
	
Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ PONM070Processa ³ Autor ³ Wiliam R.      ³ Data ³ 30/04/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Processa o fechamento Mensal                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ SIGAPON				             						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static FUNCTION PNM070Proc()

//-- Variaveis Locais
* Caracter         
Local cSvFilAnt		:= cFilAnt
Local cLastFil   	:= "__cLastFil__"
Local cFilTnoOld	:= "__cFilTnoOld__"
Local cFilTnoAtu	:= "__cFilTnoAtu__"
Local cOldFilTnoSeq	:= "__cOldFilTnoSeq__"
Local cAtuFilTnoSeq	:= "__cAtuFilTnoSeq__"
Local cFilTnoDe		:= ""
Local cFilTnoAte	:= ""
Local cFilialDe  	:= ""
Local cFilialAte 	:= ""
Local cCCDe      	:= ""
Local cCCAte     	:= ""
Local cTurnoDe   	:= ""
Local cTurnoAte  	:= ""
Local cMatDe     	:= ""
Local cMatAte    	:= ""
Local cRegraDe   	:= ""
Local cRegraAte  	:= ""
Local cNomeDe    	:= ""
Local cNomeAte   	:= ""
Local cSituacoes 	:= ""
Local cCategoria 	:= ""  
Local cNomeArray 	:= ""
Local cAcessaSRA	:= &("{ || " + ChkRH("PONM070","SRA","2") + "}")
Local cEveMesA		:= ""
Local cVerbCont		:= ""
Local cFilSPD		:= ""
Local cFilSP6		:= ""
Local cFilSP4		:= ""
Local cFilSP9		:= ""
Local cFilSRV		:= "" 
Local cFilSPC		:= ""
Local cFilSPI		:= ""
Local cFilSPB		:= ""
Local cTimeIni		:= Time()
Local cAliasSPB		:= "SPB"
Local cAliasQSPB	:= cAliasSPB
Local cAliasSPC		:= "SPC"
Local cAliasQSPC	:= cAliasSPC
Local cAliasSPI		:= "SPI"
Local cAliasQSPI	:= cAliasSPI
Local cPerAnot 		:= ""
Local cPerAtra		:= ""
Local cPerSaia 		:= ""
Local cPerHext		:= ""
Local cPerHmov		:= ""
Local cPerDdsr		:= ""
Local cDescDSR		:= ""
Local cRefeit		:= ""
Local cRegra		:= ""
Local cEveAbono		:= ""   
Local cEvBhAB		:= ""
Local cEvBhAP		:= ""
Local cMsgBarG1		:= ""
Local cMsgErr		:= ""
Local cVerbaCont	:= ""
Local cVerba		:= ""
Local cVerbasDiarias:= ""
Local cMsg			:= ""   
Local cMvModFol		:= "1"

* Data
Local dDtIni		:= Ctod("//")

* Array
Local aAreaSRA	 	:= SRA->( GetArea() )
Local aTabPadrao	:= {}
Local aTotais    	:= {}
Local aBHAcum    	:= {}
Local aCodigos	 	:= {}
Local aResult	 	:= {}
Local aCodRef	 	:= {}
Local aEveCont	 	:= {}
Local aArred_D	 	:= {}
Local aAbonos	 	:= {}
Local aAbonosPer	:= {}
Local aEvesIds		:= {}
Local aRecsSR6		:= {}
Local aSvLogDet		:= {}
Local aLogAboEve	:= {}
Local aRecsBarG		:= {}
Local aSpaFields	:= {}
Local aSpaInfo		:= {}
Local aSp6Fields	:= {}
Local aSp6Info		:= {}
Local aSp9Fields	:= {}
Local aSp9Info		:= {}
Local aResultRCH	:= {}

*Bloco
Local bSraScope

* L¢gico
Local lLoop      	:= .F.
Local lAcumBH    	:= .F.    
Local lAddEveCont   := .F.
Local lHorasTab	 	:= .F.
Local lDsrProp   	:= .F.
Local lLimDSR	 	:= .F.
Local lDsrPPer		:= .F.
Local lMvAcmHExt 	:= .F.
Local lMvArrInte	:= .F.
Local lMvAbosEve	:= .F.
Local lExistInfo 	:= .F.	
Local lSR6Comp		:= Empty( xFilial( "SR6" ) )
Local lIncProcG1	:= .T.
Local lSP9Comp		:= Empty( xFilial( "SP9" ) )
Local lSRVComp		:= Empty( xFilial( "SRV" ) )
Local lMvSubAbAp	:= .F.
Local lMvDedAbBH	:= .T.
Local lMvFolVBh		:= .F.
Local lMvDDSRFer 	:= .T.   


                  
* N£m‚rico
Local nX         	:= 0
Local nHrAbon    	:= 0
Local nHoras     	:= 0
Local nPosBH		:= 0
Local nTBHoras   	:= 0
Local nW		 	:= 0
Local nLenAbo	 	:= 0
Local nLenSPI		:= 0	
Local nLenSPB		:= 0	
Local nCodAut		:= 0
Local nBHAcum		:= 0
Local nTotais		:= 0
Local nLastRec		:= 0
Local nLastProc		:= 0
Local nPosSP4		:= 0
Local nRecsSR6		:= 0
Local nTolNotu		:= 0
Local nTolAtra		:= 0
Local nTolSaia		:= 0	
Local nTolHePe		:= 0
Local nNumAtra		:= 0 
Local nHorasAb		:= 0
Local nIncPercG1	:= 0
Local nIncPercG2	:= 0
Local nCount1Time	:= 0
Local nT			:= 0
Local nOrderRCH		:= 0

* Undefined
Local uRetBlock

#IFDEF TOP
   	Local aStruSRA		:= {}
	Local aCposSRA		:= {}
	Local aTempSRA		:= SRA->( dbStruct() )
	Local aSpbFields	:= SPB->( dbStruct() )
	Local aSpcFields	:= SPC->( dbStruct() )
	Local aSpiFields	:= SPI->( dbStruct() )
	Local cIniData		:= ""
	Local cFimData		:= ""
	Local cQuery	 	:= ""
	Local cWhere		:= ""
	Local cSPBQuery		:= ""
	Local cRCHQuery		:= ""
	Local cSPBSvQuery	:= ""
	Local cSPCQuery		:= ""
	Local cSPCSvQuery	:= ""
	Local cSPIQuery		:= ""
	Local cSPISvQuery	:= ""
	Local cRchFields	:= ""
	Local cRCHFilter	:= ""
	Local cSvFil	    := ""
	Local cSvMat		:= ""
	Local cSvPosto		:= ""
	Local cSvDepto		:= ""
	Local cSvCodFunc	:= ""
	Local cSvPeriodo	:= ""
	Local cSvProcesso	:= ""
	Local cSvNumPag		:= ""
	Local cSvRoteiro	:= ""
	Local cSvIniData	:= ""
	Local cSvFimData	:= ""
	Local cOrderSRA		:= ""
	Local lQueryOpened	:= .F.
	Local lSraQryOpened	:= .F.
	Local nSpbFields	:= Len( aSpbFields	)
	Local nSpcFields	:= Len( aSpcFields	)
	Local nSpiFields	:= Len( aSpiFields	)
	Local nContField	:= Len( aTempSRA	)
	Local nPosPer		:= 0
	Local nPosProc 		:= 0
	Local nPosDtIni 	:= 0
	Local nPosDtFim 	:= 0
	Local nPosDtFec 	:= 0
	Local nPosDtPgto	:= 0
	Local nPosRchFil	:= 0
	Local nProcRch		:= 0
	Local nPosNumPag	:= 0
#ENDIF

Local aRchFields	:= RCH->( dbStruct() )

//-- Variaveis Private
* Caracter
Private cSaiAnte	:= ""
Private cPagaHrs	:= ""
Private cPagaDSR	:= ""
Private cFilSPA		:= ""
Private cArrCalc	:= ""

* Data
Private dDataIni	:= Ctod("//")
Private dDataFim	:= Ctod("//")

* Array
Private aTabCalend	:= {}
Private aTotAdiN	:= {}
Private aTotAtra	:= {}
Private aTotSAnt	:= {}
Private aTotPgHD	:= {}
Private aTotHExt	:= {}
Private aTotHENt	:= {}
Private aCodAut		:= {}
Private aTotSem		:= {}
Private aLogDet		:= {}
Private aLogTitle	:= {}

* L¢gico
Private lFuncAcBH	:= .T.

* N£m‚rico
Private nBHDe		:= 0
Private nBHAte		:= 0
Private nPercAgBh	:= 0
Private nPercAgFl	:= 0

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carregando as Perguntas                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Pergunte("PONM070",.F.) 

#IFDEF TOP
	MakeSqlExpr( "PONM070" )
#ELSE
	MakeAdvplExpr( "PONM070" )
#ENDIF

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Parametros para controle de Processo 						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cProcesso  := mv_par01
cPeriodo   := mv_par02		
cNumPagto  := mv_par03

cFilialDe  := mv_par04
cFilialAte := mv_par05
cCCDe      := mv_par06
cCCAte     := mv_par07
cTurnoDe   := mv_par08
cTurnoAte  := mv_par09
cMatDe     := mv_par10
cMatAte    := mv_par11
cRegraDe   := mv_par12
cRegraAte  := mv_par13
cNomeDe    := mv_par14
cNomeAte   := mv_par15
cSituacoes := mv_par16
cCategoria := mv_par17
lHorasTab  := IF( mv_par18 == 1 , .T. , lHorasTab ) //-- 1=Hrs Tabela - 2=Hrs Apont.
dDataIni   := mv_par19
dDataFim   := mv_par20
cTipoRefDe := mv_par21
cTipoRefAte:= mv_par22

For nX := 1 To Len(aRchFields)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Guarda a posicao dos campos data inicil/final e processo	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( aRchFields[nX,01] == "RCH_FILIAL" )
		nPosRchFil := nX
	ElseIf ( aRchFields[nX,01] == "RCH_DTINI" )
		nPosDtIni  := nX
	ElseIf ( aRchFields[nX,01] == "RCH_DTFIM" )
		nPosDtFim  := nX
	ElseIf ( aRchFields[nX,01] == "RCH_PROCES" )
		nPosProc   := nX
	ElseIf ( aRchFields[nX,01] == "RCH_DTFECH" )
		nPosDtFec  := nX
	ElseIf ( aRchFields[nX,01] == "RCH_PER")
		nPosPer	   := nX
	ElseIf ( aRchFields[nX,01] == "RCH_NUMPAG" )
		nPosNumPag := nX
	ElseIf ( aRchFields[nX,01] == "RCH_DTPAGO" )
		nPosDtPgto := nX
	EndIf
	
	If (nX > 1)
		cRchFields += " , " + aRchFields[ nX, 01 ]
	Else
		cRchFields += aRchFields[ nX, 01 ]
	EndIf

Next

#IFDEF TOP
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega o filtro do RCH conforme os parametros selecionados  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cRCHFilter := "% "
	cRCHFilter += " RCH_FILIAL = '"+xFilial( "RCH" )+"' "
	If !Empty(mv_par01)
		cRCHFilter += " AND RCH_PROCES = '"+cProcesso+"'"
	EndIf
	If !Empty(mv_par02)
		cRCHFilter += " AND RCH_PER = '"+cPeriodo+"'"
	EndIf
	If !Empty(mv_par03)
		cRCHFilter += " AND RCH_NUMPAG = '"+cNumPagto+"'"
	EndIf
	cRCHFilter += " AND RCH_ROTEIR = '"+oPeriodo:cRoteiro+"'"
	cRCHFilter += " %"
	
	cRchFields := "% "+cRchFields+" %"

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Seleciona todos os periodos								  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cRCHQuery := GetNextAlias()
	
	BeginSql Alias cRCHQuery
		column RCH_DTINI as Date, RCH_DTFIM as Date , RCH_DTFECH as Date
	   	%NoParser%
		SELECT 
			%Exp:cRchFields%
		FROM 
			%Table:RCH% RCH
		WHERE 
			%Exp:cRCHFilter% AND
			RCH.%NotDel%
		ORDER BY 
			%Order:RCH%
	EndSql	
	
#ELSE

	cRCHQuery := "RCH"
	nOrderRCH := (cRCHQuery)->(dbsetOrder(RetOrder("RCH","RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR")))

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega o filtro do RCH conforme os parametros selecionados  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cRCHFilter += xFilial("RCH")+cProcesso+cPeriodo+cNumPagto

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seleciona a area de trabalho								  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	dbSelectArea(cRCHQuery)
	(cRCHQuery)->(dbSetOrder(nOrderRCH))
	(cRCHQuery)->(dbSeek(cFilter))	

#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Percorre os periodos selecionados							  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	
aAdd( aResultRCH, {} )
For nX := 1 To Len(aRchFields)
	aAdd( aResultRCH[Len(aResultRCH)], (cRCHQuery)->&(aRchFields[nX,01]) )
Next
	
#IFDEF TOP
	(cRCHQuery)->(dbCloseArea())
#ENDIF

cOrderSRA := SqlOrder( SRA->( IndexKey() ) )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inicializa os arquivos a serem utilizados                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
dbSelectArea("SP5") //-- Refei‡”es
dbSetOrder(1)

dbSelectArea("SP6") //-- Motivos de Abono / Justificativa
dbSetOrder(1)

dbSelectArea("SP9") //-- Eventos
dbSetOrder(1)

dbSelectArea("SRV") //-- Verbas
dbSetOrder(1)

dbSelectArea("SPA") //-- Regras de Apontamento
dbSetOrder(1)

dbSelectArea("SPB") //-- Resultados
dbSetOrder(1)

dbSelectArea("SPC") //-- Apontamentos
dbSetOrder(1)

dbSelectArea("SRA") //-- Funcion rios
dbSetOrder(4)

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega os Campos para a PosSpa()							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdd( aSpaFields , "PA_PERANOT" )	//01
aAdd( aSpaFields , "PA_PERATRA" )	//02
aAdd( aSpaFields , "PA_PERSAIA" )	//03
aAdd( aSpaFields , "PA_PERHEXT" )	//04
aAdd( aSpaFields , "PA_PERHMOV" )	//05
aAdd( aSpaFields , "PA_PERDDSR" )	//06
aAdd( aSpaFields , "PA_DESCDSR" )	//07
aAdd( aSpaFields , "PA_REFEIT"  )	//08
aAdd( aSpaFields , "PA_TOLNOTU" )	//09
aAdd( aSpaFields , "PA_TOLATRA" )	//10
aAdd( aSpaFields , "PA_TOLSAIA" )	//11
aAdd( aSpaFields , "PA_TOLHEPE" )	//12
aAdd( aSpaFields , "PA_NUMATRA" )	//13

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega os Campos para a PosSp6()							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdd( aSp6Fields , "P6_EVENTO"  )	//01
aAdd( aSp6Fields , "P6_ABHORAS" )	//02

aAdd( aSp9Fields , "P9_BHORAS" )	//01
aAdd( aSp9Fields , "P9_BHNDE"  )	//02	
aAdd( aSp9Fields , "P9_BHNATE" )	//03
aAdd( aSp9Fields , "P9_BHPERC" )	//04
aAdd( aSp9Fields , "P9_BHAGRU" )	//05
aAdd( aSp9Fields , "P9_BHVAL"  )	//06
aAdd( aSp9Fields , "P9_PBH"    )	//07
aAdd( aSp9Fields , "P9_PFOL"   )	//08
aAdd( aSp9Fields , "P9_CODFOL" )	//09


/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Efetua o calculo, periodo a periodo						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If ( !Empty(aResultRCH[1,nPosProc]) .and. !Empty(aResultRCH[1,nPosPer]) )

Begin Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Ajusta Estruturas											   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !PonStruct( Nil, Nil, {|x|( VerSP5Struct() ) } )
   Break
Endif

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega o Periodo de acordo com os periodos  selecionados	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	oPeriodo:cProcesso 	:=	aResultRCH[1,nPosProc]
	oPeriodo:cPeriodo 	:=	aResultRCH[1,nPosPer ]
	oPeriodo:cNumPagto	:= 	aResultRCH[1,nPosNumPag]
	oPeriodo:GetPer()
	
	dPerIni	:= oPeriodo:dDataIni
	dPerFim	:= oPeriodo:dDataFim
	
	dDataIni   := dPerIni
	dDataFim   := dPerFim
	
	cIniData	:= Dtos( dPerIni )
	cFimData	:= Dtos( dPerFim )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa Filial/Turno De/Ate							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cFilTnoDe	:= ( cFilialDe + cTurnoDe )
	cFilTnoAte	:= ( cFilialAte + cTurnoAte )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria o Bloco dos Funcionarios que atendam ao Scopo	   	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSraScope := { || (;
							( RA_TNOTRAB	>= cTurnoDe		.and. RA_TNOTRAB	<= cTurnoAte	) .and. ;
							( RA_FILIAL 	>= cFilialDe	.and. RA_FILIAL 	<= cFilialAte	) .and. ;
							( RA_REGRA 		>= cRegraDe		.and. RA_REGRA 		<= cRegraAte	) .and. ;
							( RA_NOME 		>= cNomeDe		.and. RA_NOME 		<= cNomeAte		) .and. ;
							( RA_MAT 		>= cMatDe		.and. RA_MAT 		<= cMatAte		) .and. ;
							( RA_CC 		>= cCCDe		.and. RA_CC 		<= cCCAte		) .and. ;
							( RA_PROCES		=  oPeriodo:cProcesso	) ;							
						 );
				 }

	#IFNDEF TOP

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica o Total de Registros a Serem Processados            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aRecsBarG := {}
		CREATE SCOPE aRecsBarG FOR SRA->( Eval( bSraScope ) )
		SRA->( dbSeek( cFilialDe , .T. ) )
		nLastRec := SRA->( ScopeCount( aRecsBarG ) )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Procura primeiro funcion rio.                               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		SRA->( dbSeek( cFilTnoDe , .T. ) )

	#ELSE
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Seta apenas os Campos do SRA que serao Utilizados           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aAdd( aCposSRA , "RA_FILIAL"	)
		aAdd( aCposSRA , "RA_MAT" 		)	
		aAdd( aCposSRA , "RA_NOME"		)
		aAdd( aCposSRA , "RA_CC"		)
		aAdd( aCposSRA , "RA_TNOTRAB"	)
		aAdd( aCposSRA , "RA_SEQTURN"	)
		aAdd( aCposSRA , "RA_REGRA"  	) 
		aAdd( aCposSRA , "RA_ADMISSA"  	)
		If cPaisLoc == "MEX"
			aAdd( aCposSRA , "RA_FECREI"  	)
		EndIf
		aAdd( aCposSRA , "RA_DEMISSA"  	)
		aAdd( aCposSRA , "RA_CATFUNC"  	)
		aAdd( aCposSRA , "RA_SITFOLH"  	)
		aAdd( aCposSRA , "RA_HRSEMAN" 	)
		aAdd( aCposSRA , "RA_HRSMES" 	)
		aAdd( aCposSRA , "RA_ACUMBH" 	)
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica e Seta os campos a mais incluidos no Mex             ³
		³28/02/2008													   ³
		³Os campos novos criados no SRA foram incluidos na funcao	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/				
		fAdCpoSra(aCposSra)	
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ponto de Entrada para Campos do Usuario                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lPnm070CposBlock )
			IF ( ValType( uRetBlock := ExecBlock("PNM070CPOS",.F.,.F.,aCposSRA) ) == "A" )
				IF Len( uRetBlock ) >= Len( aCposSRA )
					aCposSRA	:= aClone( uRetBlock )
					uRetBlock	:= NIL
				EndIF
			EndIF
		EndIF
			
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Abandona o Processamento									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lAbortPrint )
			//'O Calculo Mensal Foi Cancelado Pelo Usuario'
			aAdd( aLogDet , STR0010 )
			Break
		EndIF

		For nX := 1 To nContField
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Abandona o Processamento									   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lAbortPrint )
				//'O Calculo Mensal Foi Cancelado Pelo Usuario'
				aAdd( aLogDet , STR0010 )	
				Break
			EndIF
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega os Campos do SRA para a Montagem da Query			   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF aScan( aCposSRA , { |x| Upper(AllTrim(x)) == Upper( AllTrim( aTempSRA[ nX , 1 ] ) ) } ) > 0
				aAdd( aStruSRA , aClone( aTempSRA[ nX ] ) )
			EndIF
		Next nX

		nContField	:= Len( aStruSRA )
		cQuery := "SELECT "
		For nX := 1 To nContField
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Abandona o Processamento									   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lAbortPrint )
				//'O Calculo Mensal Foi Cancelado Pelo Usuario'
				aAdd( aLogDet , STR0010 )	
				Break
			EndIF
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inclui os Campos na Montagem da Query						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cQuery += aStruSRA[ nX , 1 ] + ", "
		Next nX
		cQuery := SubStr( cQuery , 1 , Len( cQuery ) - 2 )
		cQuery += " FROM "+InitSqlName("SRA")+" SRA "
		cWhere := " WHERE "
		cWhere += " SRA.RA_FILIAL>='"+cFilialDe+"' AND "
		cWhere += " SRA.RA_FILIAL<='"+cFilialAte+"' AND "
		cWhere += " SRA.RA_TNOTRAB>='"+cTurnoDe+"' AND "	
		cWhere += " SRA.RA_TNOTRAB<='"+cTurnoAte+"' AND "
		cWhere += " SRA.RA_MAT>='"+cMatDe+"' AND "	
		cWhere += " SRA.RA_MAT<='"+cMatAte+"' AND "
		cWhere += " SRA.RA_NOME>='"+cNomeDe+"' AND "	
		cWhere += " SRA.RA_NOME<='"+cNomeAte+"' AND "
		cWhere += " SRA.RA_REGRA>='"+cRegraDe+"' AND "	
		cWhere += " SRA.RA_REGRA<='"+cRegraAte+"' AND "
		cWhere += " SRA.RA_CC>='"+cCCDe+"' AND "	
		cWhere += " SRA.RA_CC<='"+cCCAte+"' AND "
		cWhere += " SRA.RA_PROCES='"+oPeriodo:cProcesso+"' AND "		
		cWhere += " SRA.D_E_L_E_T_=' ' "
		cQuery += cWhere
		cQuery += "ORDER BY "+cOrderSRA
		cQuery := ChangeQuery(cQuery)
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Abandona o Processamento									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lAbortPrint )
			//'O Calculo Mensal Foi Cancelado Pelo Usuario'
			aAdd( aLogDet , STR0010 )	
			Break
		EndIF
		SRA->( dbCloseArea() ) //Fecha o SRA para uso da Query
		IF ( lSraQryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),"SRA",.T.,.T.) )
			For nX := 1 To nContField
				IF ( aStruSRA[nX,2] <> "C" )
					TcSetField("SRA",aStruSRA[nX,1],aStruSRA[nX,2],aStruSRA[nX,3],aStruSRA[nX,4])
				EndIF
			Next nX
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica o Total de Registros a Serem Processados            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cQuery := "SELECT COUNT(*) NLASTREC "
			cQuery += "FROM "+InitSqlName("SRA")+" SRA "
			cQuery += cWhere
			cQuery := ChangeQuery(cQuery)
        	IF ( MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),"__QRYCOUNT",.T.,.T.) )
				nLastRec := __QRYCOUNT->NLASTREC
				__QRYCOUNT->( dbCloseArea() )
            Else
				MsAguarde( { || SRA->( dbEval( { || ++nLastRec } ) ) } , STR0033 + STR0034 )	//'Aguarde...'###'Selecionaldo Funcionarios'
				SRA->( dbGotop() )
			EndIF
		Else
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Restaura Arquivo Padrao e Ordem                             ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			ChkFile( "SRA" )
			SRA->( dbSetOrder( 04 ) )
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica o Total de Registros a Serem Processados            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			aRecsBarG := {}
			CREATE SCOPE aRecsBarG FOR SRA->( Eval( bSraScope ) )
			SRA->( dbSeek( cFilialDe , .T. ) )
			nLastRec := SRA->( ScopeCount( aRecsBarG ) )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Procura primeiro funcion rio.                               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			SRA->( dbSeek( cFilTnoDe , .T. ) )
		EndIF
	#ENDIF

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa Mensagem para a IncProcG2() ( Funcionarios )	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IncProcG2( STR0008  , .F. )	// 'Processando...'

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Atualiza a Mensagem para a IncProcG2() ( Funcionarios )	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	BarGauge2Set( nLastRec )
                                                              
/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica o Modelo de folha pagto usado no Mexico			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/   
	If cPaisLoc = "MEX"
	 	cMvModFol		:= SuperGetMv("MV_MODFOL",NIL,"1")
    Endif
    
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Processa o Calculo Mensal                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	While SRA->( !Eof() .and. ( ( cFilTnoAtu := ( RA_FILIAL + RA_TNOTRAB ) ) >= cFilTnoDe ) .and. ;
		                        ( cFilTnoAtu <= cFilTnoAte ) )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Consiste filtro do intervalo De / Ate                        ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF SRA->( !Eval( bSraScope ) )
			SRA->( dbSkip() )
			Loop
 		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Aborta o processamento                                       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lAbortPrint )
			//'O Calculo Mensal Foi Cancelado Pelo Usuario'
			aAdd( aLogDet , STR0010 )	
			Break
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Atualiza a Mensagem para a IncProcG1() ( Turnos )			   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cAtuFilTnoSeq := ( cFilTnoAtu + SRA->RA_SEQTURN )
		IF !( cOldFilTnoSeq == cAtuFilTnoSeq )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Atualiza o Filial/Turno/Sequencias Anteriores				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cOldFilTnoSeq := cAtuFilTnoSeq
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Atualiza a Mensagem para a BarGauge do Turno 				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			//"Filial:"###"Turno:"###"Sequencia:"
			cMsgBarG1 := SRA->( STR0026 + " " + RA_FILIAL + " - " + STR0027 + " " + RA_TNOTRAB + " - " + Left(AllTrim( fDesc( "SR6" , RA_TNOTRAB , "R6_DESC" , NIL , RA_TNOTRAB , 01 ) ),50) + " " + STR0028 + " " + RA_SEQTURN )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Houve Troca de Filial para Verificacai dos Turnos³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF !( cLastFil == SRA->RA_FILIAL ) //A Atribuicao a cLastFil sera feita abaixo
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Obtem o % de Incremento da 2a. BarGauge					   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				nIncPercG1 := SuperGetMv( "MV_PONINC1" , NIL , 5 , SRA->RA_FILIAL )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Obtem o % de Incremento da 2a. BarGauge					   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				nIncPercG2 := SuperGetMv( "MV_PONINCP" , NIL , 5 , SRA->RA_FILIAL )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Realimenta a Barra de Gauge para os Turnos de Trabalho       ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF ( !lSR6Comp .or. ( nRecsSR6 == 0 ) )
					CREATE SCOPE aRecsSR6 FOR ( R6_FILIAL == cLastFil .or. Empty( R6_FILIAL ) )
					nRecsSR6 := SR6->( ScopeCount( aRecsSR6 ) )
				EndIF
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Define o Contador para o Processo 1                          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				--nCount1Time
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Define o Numero de Elementos da BarGauge                     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				BarGauge1Set( nRecsSR6 )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Inicializa Mensagem na 1a BarGauge                           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IncProcG1( cMsgBarG1 , .F. )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Reinicializa a Filial/Turno Anterior                         ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cFilTnoOld := "__cFilTnoOld__"
			EndIF
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica se Deve Incrementar a Gauge ou Apenas Atualizar a Men³
			³sagem														   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lIncProcG1 := !( cFilTnoOld == cFilTnoAtu ) )
				cFilTnoOld := cFilTnoAtu
			EndIF
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Incrementa a Barra de Gauge referente ao Turno				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IncPrcG1Time( cMsgBarG1 , nRecsSR6 , cTimeIni , .F. , nCount1Time , nIncPercG1 , lIncProcG1 )
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Movimenta a R‚gua de Processamento do Processamento Principal³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IncPrcG2Time( STR0032 , nLastRec , cTimeIni , .T. , 2 , nIncPercG2 )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Consiste a Categoria										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !( SRA->RA_SITFOLH $ cSituacoes )
			SRA->( dbSkip() )
			Loop
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Consiste a Categoria										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !( SRA->RA_CATFUNC $ cCategoria )
			SRA->( dbSkip() )
			Loop
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Consiste controle de acessos e filiais validas               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF SRA->( !(RA_FILIAL $ fValidFil()) .or. !Eval(cAcessaSRA) )
			SRA->(dbSkip()) 
			Loop
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se as H.E. do funcionario vao para Banco de Horas  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
        lFuncAcBH := !( SRA->RA_ACUMBH == "N" )
               
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Cria Array com c¢digos autorizados de Eventos e Horas Extras ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !( SRA->RA_FILIAL == cLastFil )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Atualiza a Filial Anterior								   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cLastFil	:= SRA->RA_FILIAL	//A atribuicao de cLastFil devera ser feita aqui
            cFilAnt		:= cLastFil	
		
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega as Filiais dos Arquivoss                             ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cFilSP4 := fFilFunc("SP4")
			cFilSP6 := fFilFunc("SP6")
			cFilSP9 := fFilFunc("SP9")
			cFilSRV := fFilFunc("SRV")
			cFilSPA := fFilFunc("SPA")
			cFilSPB	:= fFilFunc("SPB")
			cFilSPC	:= fFilFunc("SPC")
			cFilSPI	:= fFilFunc("SPI")

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Carregar os Mv's de acordo com a Filial					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			lMvAcmHExt	:= ( Upper(AllTrim(SuperGetMv("MV_ACMHEXT",NIL,"N",cLastFil))) == "S" )	//--Verifica se Acumula Hora Extra para o Escalonamento	
			lMvArrInte	:= ( Upper(AllTrim(SuperGetMv("MV_ARRINTE",NIL,"N",cLastFil))) == "S" )	//--Define se ira considerar o Arredondamento Integral das Horas
			lMvAbosEve	:= ( Upper(AllTrim(SuperGetMv("MV_ABOSEVE",NIL,"N",cLastFil))) == "S" )	//--Verifica se Deduz as horas abonadas das horas do evento Sem a necessidade de informa o Codigo do Evento no motivo de abono que abona horas
			lDsrProp   	:= ( Upper(AllTrim(SuperGetMv("MV_DSRPROP",NIL,"N",cLastFil))) == "S" )	//--Desconto de DSR proporcional
			lLimDSR	 	:= ( Upper(AllTrim(SuperGetMv("MV_LIMDSR" ,NIL,"N",cLastFil))) == "S" )	//--Variavel Para Limitar Desconto de DSR ao Periodo de Apuracao do Mesmo
			lDsrPPer	:= ( Upper(AllTrim(SuperGetMv("MV_DSRPPER",NIL,"S",cLastFil))) == "S" )	//--Verifica se gerara evento de desconto de DSR para o proximo periodo
			lMvSubAbAp	:= ( Upper(AllTrim(SuperGetMv("MV_SUBABAP",NIL,"N",cLastFil))) == "S" )	//--Verifica se Quando Abono nao Abonar Horas e Possuir codigo de Evento, se devera Gera-lo em outro evento e abater suas horas das Horas Calculadas
			lMvDedAbBH	:= ( Upper(AllTrim(SuperGetMv("MV_DEDABBH",NIL,"S",cLastFil))) == "S" )	//-- A horas apontadas sofrerao deducao das horas abonadas de um evento que vai para banco de horas e esta relacionado a um motivo de abonos que abona horas.
			lMvFolVBh	:= ( Upper(AllTrim(SuperGetMv("MV_FOLVBH" ,NIL,"N",cLastFil))) == "S" )	//-- A horas apontadas sofrerao deducao das horas abonadas de um evento se o destino das horas apontadas for diferente do destino das horas abonadas.
			cArrCalc	:= Upper(AllTrim(SuperGetMv("MV_ARRCALC",NIL,"B",cLastFil)))			//--Indica se o Arredondamento a maior das horas separadas pelos percentuais dos Eventos serao para o Banco de Horas ou para a Folha de Pagamento
			nBHDe		:= SuperGetMv("MV_BHDE"		,NIL,0,cLastFil)							//--Numero Inicial de Horas que ira compor para acumular no Banco de Horas. Devera estar especificado em Horas. Ex. 0.01 a 999.99
			nBHAte		:= SuperGetMv("MV_BHATE"	,NIL,0,cLastFil)							//--Numero Final de Horas que ira compor para acumular no Banco de Horas. Devera estar especificado em Horas. Ex. 0.01 a 999.99
			nPercAgBh	:= SuperGetMv("MV_PERAGBH"	,NIL,0,cLastFil)							//--Indica o percentual que sera enviado para o Banco de Horas de Eventos com apuracao por Agrupamento. em Horas. Ex. 0 100
			nPercAgFl	:= SuperGetMv("MV_PERAGFL"	,NIL,0,cLastFil)							//--Indica o percentual que sera enviado para a Folha de Pagto de Eventos com apuracao por Agrupamento.de Pagto de Eventos com apuracao por Agrupamento.
			lMvDDSRFer	:= ( (SuperGetMv("MV_DDSRFER"  ,NIL,1,cLastFil)) == 1  )		        //--Verifica se o Desconto do DSR incide sobre o feriado	
           
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Reinicializa cIniData e cFimData Quando TOP e nao As/400      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			#IFDEF TOP
				cIniData	:= Dtos( dPerIni )
				cFimData	:= Dtos( dPerFim )
			#ENDIF
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Reinicializa cVerbasDiarias								   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF !( lSRVComp )
				cVerbasDiarias		:= ""
			EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Informacoes em aCosAut						   	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF Empty( cVerbasDiarias )
			
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Preenche String de Verbas Diarias							  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				SRV->( dbSeek( cFilSRV , .T. ) )
				While ( SRV->( !Eof() .and. ( cFilSRV == RV_FILIAL ) ) )
					
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Aborta o processamento                                       ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF ( lAbortPrint )
						//'O Calculo Mensal Foi Cancelado Pelo Usuario'
						aAdd( aLogDet , STR0010 )	
						Break
					EndIF
                    If (SRV->RV_ACUMULA = "1")
                       cVerbasDiarias+=SRV->RV_COD+"."
                    Endif
                    
					SRV->(dbSkip())
				End While
	        Endif
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Reinicializa aCodAut apenas se os arquivos SP9 nao for compar³
			³ tilhado         											   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF !( lSP9Comp )
				aCodAut := {}
				aEveCont	:= {} 
				cVerba		:= ""
				cVerbaCont	:= ""
			EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Informacoes em aCosAut						   	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF Empty( aCodAut )
			
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Preenche o Array aCodAut com as Horas Extras				  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				SP4->( dbSeek( cFilSP4 , .T. ) )
				While ( SP4->( !Eof() .and. ( cFilSP4 == P4_FILIAL ) ) )
					
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Aborta o processamento                                       ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF ( lAbortPrint )
						//'O Calculo Mensal Foi Cancelado Pelo Usuario'
						aAdd( aLogDet , STR0010 )	
						Break
					EndIF

					cEvento := SP4->P4_CODAUT
					IF PosSP9( cEvento , cFilSP9 , NIL , 1 , .F. )
						aSp9Info := PosSP9( cEvento , cFilSP9 , aSp9Fields	, 1 , .F. )
						IF ( (nPosSP4:=aScan( aCodAut, { |x| x[1] == cEvento } )) == 0 )
							aAdd( aCodAut , Array( 14 ) )
							nCodAut := Len( aCodAut )
							aCodAut[ nCodAut , 01 ] := cEvento
							IF !( SP4->P4_TIPO $ "A*B*C*D*E*F*G*H" )
								aCodAut[ nCodAut , 02 ] := If( Val( SP4->P4_TIPO ) >= 5 , "HENA" , "HEDA" )
							Else
								aCodAut[ nCodAut , 02 ] := If( SP4->P4_TIPO$ "B*D*F*H" , "HENA" , "HEDA" )
							EndIF	
							aCodAut[ nCodAut , 03 ] := "N"
							aCodAut[ nCodAut , 04 ] := aSp9Info[1]
							aCodAut[ nCodAut , 05 ] := ""
							aCodAut[ nCodAut , 06 ] := aSp9Info[2]
							aCodAut[ nCodAut , 07 ] := aSp9Info[3]
							aCodAut[ nCodAut , 08 ] := aSp9Info[4]
							aCodAut[ nCodAut , 09 ] := IF( ( nBHDe + nBHAte ) > 0 .and. aSp9Info[5] == "S" , "S" , "N" )
							aCodAut[ nCodAut , 10 ] := aSp9Info[6]
							aCodAut[ nCodAut , 11 ] := aSp9Info[7]
							aCodAut[ nCodAut , 12 ] := aSp9Info[8]
							aCodAut[ nCodAut , 13 ] := aSp9Info[9]
							aCodAut[ nCodAut , 14 ] := {SP4->P4_TIPO}
						Else 
							If ( Ascan(aCodAut[ nPosSP4 , 14 ], SP4->P4_TIPO) == 0 )
								AADD(aCodAut[ nPosSP4 , 14 ],  SP4->P4_TIPO )
							Endif	
						EndIF
					EndIF
					SP4->(dbSkip())
				End While
	
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Preenche o Array aCodAut com os Eventos (Menos DSR Mes Ant.)³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				SP9->( dbSeek( cFilSP9 , .T. ) )
				While ( SP9->( !Eof() .and. ( cFilSP9 == P9_FILIAL ) ) )
	
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Aborta o processamento                                       ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF ( lAbortPrint )
						//'O Calculo Mensal Foi Cancelado Pelo Usuario'
						aAdd( aLogDet , STR0010 )	
						Break
					EndIF
	
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Carrega Evento que ainda nao foi carregado se:			       ³
					³Vai para Banco de Horas ou Intregracao com Folha ( com excecao³
					³Saida Antecipada periodo Anterior) ou Evento com Identificador³
					³de Ponto mas sem Integracao com Folha  					   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF	SP9->(;
									(;
										( P9_BHORAS == "S" );
										.or.;
										(;
											!Empty( P9_CODFOL );
											.and.;
											( P9_IDPON # "022A" );
										);	
						            	.or.;
						            	(;
					    	        		Empty( P9_CODFOL );
					           				.and.;
						            		!Empty( P9_IDPON );
						            	 );
					    			);
					    			.and.;
					    			( aScan( aCodAut, { |x| x[1] == P9_CODIGO } ) == 0 );
					    		)	
						aAdd( aCodAut , Array( 14 ) )
						nCodAut := Len( aCodAut )
						aCodAut[ nCodAut , 01 ] := SP9->P9_CODIGO
						aCodAut[ nCodAut , 02 ] := SP9->P9_IDPON
						aCodAut[ nCodAut , 03 ] := SP9->P9_DESCDSR
						aCodAut[ nCodAut , 04 ] := SP9->P9_BHORAS
						aCodAut[ nCodAut , 05 ] := "D"
						aCodAut[ nCodAut , 06 ] := SP9->P9_BHNDE
						aCodAut[ nCodAut , 07 ] := SP9->P9_BHNATE
						aCodAut[ nCodAut , 08 ] := SP9->P9_BHPERC
						aCodAut[ nCodAut , 09 ] := IF( ( nBHDe + nBHAte ) > 0 .and. SP9->P9_BHAGRU == "S" , "S" , "N" )
						aCodAut[ nCodAut , 10 ] := SP9->P9_BHVAL
						aCodAut[ nCodAut , 11 ] := SP9->P9_PBH
						aCodAut[ nCodAut , 12 ] := SP9->P9_PFOL
						aCodAut[ nCodAut , 13 ] := SP9->P9_CODFOL
						aCodAut[ nCodAut , 14 ] := {SPACE(1)}
					EndIF
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Preenche o Array aCodAut com os Abonos					  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					//--Se existe o campo de Evento Contador
					If lEveCont                                           
					    //-- Verifica se nao foi carregado o evento do ponto
						If !( ( lAddEveCont:= Empty( aEveCont) ) )
							lAddEveCont:= ( Ascan(aEveCont, {|x| x[1] == SP9->P9_CODIGO } ) == 0 )
						Endif	
						//-- Se o Evento possuir Evento Contador Associado
					   	If lAddEveCont .AND. !Empty(SP9->P9_EVECONT )
					   		AADD(aEveCont, { SP9->P9_CODIGO, SP9->P9_EVECONT, NIL } ) 
					   		
					   		nRecno:=SP9->(Recno())
					   		
					   		cVerbaCont+= If(!Empty( ( cVerba:= PosSP9( SP9->P9_EVECONT , cFilSP9 , "P9_CODFOL" , 1, .T. ) ) ), cVerba, "")
					   		aEveCont[Len(aEveCont),3] := If (lAcumEveCont, (SP9->P9_ACECONT$"2"),.T.) 
					   		
					   		SP9->(DbGoto(nRecno))
					   	Endif	
					Endif
					SP9->( dbSkip() )
				End While

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Preenche o Array aCodAut com os Abonos					  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				SP6->( dbSeek( cFilSP6 , .T. ) )
				While ( SP6->( !Eof() .and. ( cFilSP6 == P6_FILIAL ) ) )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Aborta o processamento                                       ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF ( lAbortPrint )
						//'O Calculo Mensal Foi Cancelado Pelo Usuario'
						aAdd( aLogDet , STR0010 )
						Break
					EndIF
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Carrega o Evento do Motivo de Abono                          ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					cEvento := SP6->P6_EVENTO
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se o Conteudo do parametro MV_ABOSEVE for igual a "N" e o Abo³
					³ no Abonar Horas o Codigo de Evento do Abono devera estar  pre³
					³ enchido													   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF (;
							!( lMvAbosEve );
							.and.;
							( SP6->P6_ABHORAS == "S" );
							.and.;
							Empty( cEvento );
						)
						SP6->( aAdd( aLogAboEve , P6_CODIGO + " " + P6_DESC ) )
						SP6->( dbSkip() )
						Loop
					EndIF
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se o Evento do Motivo de Abono Nao Estiver Vazio             ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF (;
							!Empty(cEvento);
							.and.;
							PosSP9( cEvento , cFilSP9 , NIL , 1 , .F. );
						)	
						aSp9Info := PosSP9( cEvento , cFilSP9 , aSp9Fields	, 1 , .F. )
						aAdd( aCodAut , Array( 14 ) )
						nCodAut := Len( aCodAut )
						aCodAut[ nCodAut , 01 ] := cEvento
						aCodAut[ nCodAut , 02 ] := "ABOA"
						aCodAut[ nCodAut , 03 ] := "N"
						aCodAut[ nCodAut , 04 ] := aSp9Info[1]
						aCodAut[ nCodAut , 05 ] := "D"
						aCodAut[ nCodAut , 06 ] := aSp9Info[2]
						aCodAut[ nCodAut , 07 ] := aSp9Info[3]
						aCodAut[ nCodAut , 08 ] := aSp9Info[4]
						aCodAut[ nCodAut , 09 ] := IF( ( nBHDe + nBHAte ) > 0 .and. aSp9Info[5] == "S" , "S" , "N" )
						aCodAut[ nCodAut , 10 ] := aSp9Info[6]
						aCodAut[ nCodAut , 11 ] := aSp9Info[7]
						aCodAut[ nCodAut , 12 ] := aSp9Info[8]
						aCodAut[ nCodAut , 13 ] := aSp9Info[9]
						aCodAut[ nCodAut , 14 ] := {SPACE(1)}
					EndIF
					SP6->( dbSkip() )
				End While
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega no Log de Ocorrencias os Motivos de Abono sem Eventos³
				³ e Aborta o Processamento									   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			    IF ( ( nW := Len( aLogAboEve ) ) > 0 )
			    	For nX := 1 To nW
			    		//'O motivo de Abono: '###' Abona Horas esta sem codigo de Evento devidamente preenchido.'
			    		aAdd( aLogDet , STR0035 + aLogAboEve[ nX ] + STR0036 )
			    	Next nX
			    	Break
			    EndIF	
			EndIF
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se os Codigos Foram Carregados                      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF Empty( aCodAut )
				//'Nao foi possivel Realizar o Calculo Mensal' ###'Verifique se existem Eventos cadastrados no SP9 (Cadastro de Eventos)'
				aAdd( aLogDet , STR0002  + " " + STR0016 )
				Break
			EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Nao carregar novamente o cadastro de eventos qdo o mesmo for³
			³ compartilhado												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF (;
					!Empty(cFilSP9);
					.or.;
					( Len(aCodigos) == 0 );
				)	
				aCodigos := {}
				IF !fCargaId(@aCodigos,cLastFil,.F.)
					//'Nao foi possivel Realizar o Calculo Mensal' ###'Verifique se existem Eventos cadastrados no SP9 (Cadastro de Eventos)'
					aAdd( aLogDet , STR0002  + " " + STR0016 )
					Break
				EndIF
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carregae alteracao no Log e porque existem Identificadores do³
				³ Ponto nao vinculado a Eventos								   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
            	aSvLogDet	:= aClone( aLogDet )
            	aEvesIds	:= GetEveIdPon( aCodigos , cLastFil , @aLogDet )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se houve alteracao no Log e porque existem Identificadores do³
				³ Ponto nao vinculado a Eventos								   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
            	IF !fCompArray( aLogDet , aSvLogDet )
            		Break
            	EndIF
            	aSvLogDet := {}
            EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inicializa os codigos de Horas Normais e DSR				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF (;
					Empty( cPagaHrs := aEvesIds[ 001 , 02 ] );
					.or.;
					Empty( cPagaDSR := aEvesIds[ 002 , 02 ] );
				 )
				//'Nao foi possivel Realizar o Calculo Mensal' ###'Verifique se Existem Eventos para os Identificadores 001A e 002A'
				aAdd( aLogDet , STR0002  + " " + STR0017 )
				Break
			EndIF
		
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Evento de Saida Antecipada								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSaiAnte := aEvesIds[ 014 , 02 ]

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Reinicializa Array com os Codigos de Refeicao				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			aCodRef := {}
		
		EndIF //Final da Verificacao de Troca de Filial

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega a Regra do Cadastro de Funcionarios				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cRegra := SRA->RA_REGRA

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se a regra de valida‡„o do funcion rio ‚ v lida	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !( PosSPA( cRegra , cFilSPA , NIL , 1 , .F. ) )
			//'A Regra: '###'Nao Esta Cadastrada no SPA (Cadastro de Regras)'
			SRA->( aAdd( aLogDet , STR0011 + " " + cRegra + " " +  STR0012 ) )	
			//'Nao Foi Possivel Evetuar o Calculo para o Funcionario:"###'da Filial: '###'e Turno: '
			SRA->( aAdd( aLogDet , STR0013 + " " + RA_MAT + " - " + AllTrim(RA_NOME) + " " + STR0014 + " " + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB ) ) 
			SRA->( dbSkip() )
			Loop
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as informacoes do SPA                               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aSpaInfo := PosSPA( cRegra , cFilSPA , aSpaFields , 1 , .F. )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do Campo PA_PERANOT                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cPerAnot := aSpaInfo[1]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do Campo PA_PERATRA                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cPerAtra := aSpaInfo[2]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do Campo PA_PERSAIA                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cPerSaia := aSpaInfo[3]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do Campo PA_PERHEXT                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cPerHext := aSpaInfo[4]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do Campo PA_PERHMOV                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cPerHmov :=	aSpaInfo[5]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do Campo PA_PERDDSR                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cPerDdsr := aSpaInfo[6]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do Campo PA_DESCDSR                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cDescDSR := aSpaInfo[7]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do Campo PA_REFEIT                       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cRefeit	 := aSpaInfo[8]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do campo PA_TOLNOTU                  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nTolNotu := aSpaInfo[9]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do campo PA_TOLATRA                  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nTolAtra := aSpaInfo[10]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do campo PA_TOLSAIA                  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nTolSaia  := aSpaInfo[11]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do campo PA_TOLHEPE                  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nTolHePe  := aSpaInfo[12]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o conteudo do campo PA_NUMATRA                  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nNumAtra  := Val( aSpaInfo[13] )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Defini‡„o de Eventos que passem de um mˆs para outro		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( Empty( cEveMesA := IF( cDescDSR == "S" , aEvesIds[ 022 , 02 ] , aEvesIds[ 021 , 02 ] ) ) )
			//'Nao foi possivel Realizar o Calculo Mensal' ###'Verifique se Existem Eventos para os Identificadores 022A e 021N'
			aAdd( aLogDet , STR0002  + " " + STR0018 )
			Break
		EndIF
	
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Consiste Admissao e Demissao                                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF SRA->(;
					( fDtaAdmis() > dPerFim );
					.or.;
					(;
						!Empty( RA_DEMISSA );
						.and.;
						( RA_DEMISSA < dPerIni );
					);
				)
			SRA->( dbSkip() )
			Loop
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Atualiza os Periodos de Apuracao p/Banco de Horas			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nCodAut := Len(aCodAut)
		For nT := 1 To nCodAut
			IF ( aCodAut[nT,2] == "004A" )			// Periodo Apuracao das Horas Noturnas
				aCodAut[nT,5] := cPerAnot
			ElseIF ( aCodAut[nT,2] == "012A" )		// Periodo Apuracao dos Atrasos
				aCodAut[nT,5] := cPerAtra
			Else
				aCodAut[nT,5] := cPerHext			//Periodo Apuracao das Horas Extras
			EndIF
		Next nT

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Cria a Tabela de Horario Padrao do Funcionario				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aTabCalend := {}
		IF SRA->( !CriaCalend(dPerIni,dPerFim,RA_TNOTRAB,RA_SEQTURN,@aTabPadrao,@aTabCalend,RA_FILIAL,RA_MAT,RA_CC ) )
			//'Nao voi possivel Montar o Calendario para o Funcionario: '###'da Filial: '###'e Turno: '###'O Calculo Mensal nao foi efetuado para este funcionario.'
			SRA->( aAdd( aLogDet , STR0019 + " " + RA_MAT + " - " + AllTrim(RA_NOME) + " " + STR0014 + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB + ". " + STR0020 ) )
			SRA->( dbSkip() )
			Loop
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Reinicializa os Arrays										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aTotais  := {}
		aTotAdiN := {}
		aTotAtra := {}
		aTotSAnt := {}
		aTotPgHD := {}
		aTotHExt := {}
		aTotHENt := {}
		aResult	 := {}
		aTotSem  := {}

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Obtem os abonos Para o Periodo								  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( Alias() != "SX6" )
			dbSelectArea("SX6")
		EndIf
		aAbonosPer := {}
		fAbonosPer( @aAbonosPer , dPerIni , dPerFim , cLastFil , SRA->RA_MAT )
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se nao for DSR proporcional Carrega as Tabelas de Arredondamen³
		³to															   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !( lDsrProp )
			cFilSPD	 := cLastFil
			aArred_D := GetTabArred( @cFilSPD , SRA->RA_TNOTRAB , "D" )
			aArred_D := RetTabArred( aArred_D , cFilSPD , SRA->RA_TNOTRAB , "D" )
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Gerar o Desconto do D.S.R. (017N/018A) baseado no   Arredonda³
		³mento de DSR ou Gerar o Desconto do DSR Limitados ao Total do³
		³DSR (1 Dia)												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF (;
				( lDsrProp );
				.or.;
				!Empty( aArred_D );
			)
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Carrega os Resultados Anteriores para a Apuracao e Geracao  do³
			³desconto do DSR. Quando Tiver codigo/quantidade informada  con³
			³siderar o codigo/quanditade Informada para a apuracao do   Des³
			³conto do DSR. O 5o. Parametro da GetLastApo() eh que ira  efeu³
			³ar o Tratamento (Troca) dos dados referente ao apontado   pelo³
			³informado.													   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			aResult := GetLastApo( dPerIni , dPerFim , NIL , NIL , .T. )
		
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Efetua o Calculo e a Geracao do Desconto do DSR               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			fDescDsr(@aResult,aTabCalend,aCodigos,aArred_D,cPerDdsr,dPerIni,dPerFim,@aTotais,lDsrProp,lLimDSR,lDsrPPer,aAbonosPer,cDescDSR,nNumAtra, lMvDDSRFer)
		EndIF	

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ponto de Entrada                                             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lPoncalmBlock )
 			ExecBlock("PONCALM" , .F., .F.)
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se nao for Top Posiciona no Funcionario, Caso contrario monta³
		³ Query														   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFNDEF TOP
			( cAliasQSPC )->( dbSeek( cFilSPC + SRA->RA_MAT , .F. ) )
		#ELSE
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Quando a Expressao da Query nao estiver definida monta-a     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF Empty( cSPCQuery )
				cAliasQSPC	:= ( "__Q" + cAliasSPC + "QRY" )
				cSPCQuery	:= "SELECT "
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carregando os Campos do SPC na Query						   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				For nX := 1 To nSpcFields
					cSPCQuery += aSpcFields[ nX , 01 ] + ", "
				Next nX
				cSPCQuery := SubStr( cSPCQuery , 1 , Len( cSPCQuery ) - 2 ) 
				cSPCQuery += " FROM " + InitSqlName( cAliasSPC ) + " " + cAliasSPC + " "
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Montando a Condicao										   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPCQuery += "WHERE "
				cSPCQuery += cAliasSPC + "."
				cSPCQuery += "PC_FILIAL='"+cLastFil+"'"
				cSPCQuery += " AND "
				cSPCQuery += cAliasSPC + "."
				cSPCQuery += "PC_MAT='"+SRA->RA_MAT+"'"				
				//cSPCQuery += " AND "
				//cSPCQuery += cAliasSPC + "."				
				//cSPCQuery += "PC_POSTO = '"+SRA->RA_POSTO+"'"
				//cSPCQuery += " AND "
				//cSPCQuery += cAliasSPC + "."				
				//cSPCQuery += "PC_DEPTO = '"+SRA->RA_DEPTO+"'"				
				//cSPCQuery += " AND "
				//cSPCQuery += cAliasSPC + "."				
				//cSPCQuery += "PC_CODFUNC = '"+SRA->RA_CODFUNC+"'"
				cSPCQuery += " AND "
				cSPCQuery += cAliasSPC + "."				
				cSPCQuery += "PC_PROCES = '"+oPeriodo:cProcesso+"'"
				cSPCQuery += " AND "
				cSPCQuery += cAliasSPC + "."				
				cSPCQuery += "PC_PERIODO = '"+oPeriodo:cPeriodo+"'" 
				cSPCQuery += " AND "
				cSPCQuery += cAliasSPC + "."				
				cSPCQuery += "PC_NUMPAG = '"+oPeriodo:cNumPagto+"'"
				cSPCQuery += " AND "
				cSPCQuery += cAliasSPC + "."				
				cSPCQuery += "PC_ROTEIR = '"+oPeriodo:cRoteiro+"'"
				cSPCQuery += " AND "
				cSPCQuery += " ( "
				cSPCQuery += cAliasSPC + "."
				cSPCQuery += "PC_DATA>='"+cIniData+"'"
				cSPCQuery += " AND "
				cSPCQuery += cAliasSPC + "."
				cSPCQuery += "PC_DATA<='"+cFimData+"'"
				cSPCQuery += " ) AND "
				cSPCQuery += cAliasSPC + ".D_E_L_E_T_=' ' "
				cSPCQuery += "ORDER BY " + SqlOrder( (cAliasSPC)->( IndexKey() ) )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Guarda os Valores Anteriores                                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPCSvQuery	:= cSPCQuery
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Caso contrario, apenas substitui os valores                  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPCQuery	:= StrTran( cSPCSvQuery	, ( "PC_FILIAL='"+cSvFil+"'"	) , ( "PC_FILIAL='"+cLastFil+"'"	) )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_MAT='"+cSvMat+"'"		) , ( "PC_MAT='"+SRA->RA_MAT+"'"	) )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_DATA>='"+cSvIniData+"'" ) , ( "PC_DATA>='"+cIniData+"'"		) )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_DATA<='"+cSvFimData+"'" ) , ( "PC_DATA<='"+cFimData+"'"		) )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_POSTO = '"+cSvPosto+"'"	) , ( "PC_POSTO = '"+SRA->RA_POSTO+"'"	) )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_DEPTO = '"+cSvDepto+"'"	) , ( "PC_DEPTO = '"+SRA->RA_DEPTO+"'"	) )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_CODFUNC = '"+cSvCodFunc+"'"	) , ( "PC_CODFUNC = '"+SRA->RA_CODFUNC+"'"	) )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_PROCES = '"+cSvProcesso+"'"	) , ( "PC_PROCES = '"+oPeriodo:cProcesso+"'") )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_PERIODO = '"+cSvPeriodo+"'"	) , ( "PC_PERIODO = '"+oPeriodo:cPeriodo+"'" ) )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_NUMPAG = '"+cSvNumPag+"'"	) , ( "PC_NUMPAG = '"+oPeriodo:cNumPagto+"'" ) )
				cSPCQuery	:= StrTran( cSPCQuery	, ( "PC_ROTEIR = '"+cSvRoteiro+"'"	) , ( "PC_ROTEIR = '"+oPeriodo:cRoteiro+"'" ) )

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Guarda os Valores Anteriores                                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPCSvQuery	:= cSPCQuery
			EndIF
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Utiliza ChangeQuery() para Remontar a Query                  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPCQuery := ChangeQuery( cSPCQuery )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se conseguiu Montar a Query Seta os Campos                   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cSPCQuery),cAliasQSPC,.T.,.T.) )
				For nX := 1 To nSpcFields
					IF !( aSpcFields[ nX , 02 ] == "C" )
						TcSetField(cAliasQSPC,aSpcFields[nX,01],aSpcFields[nX,02],aSpcFields[nX,03],aSpcFields[nX,04])
					EndIF
				Next nX
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Caso contrario Utiliza o processo Padrao                     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cAliasQSPC	:= cAliasSPC
				( cAliasQSPC )->( dbSeek( cFilSPC + SRA->RA_MAT  , .F. ) )
			EndIF
		#ENDIF
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Percorre o SPC Carrega Todos os Eventos do Periodo           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		While ( ( cAliasQSPC )->( !Eof() .and. ( cFilSPC + SRA->RA_MAT ) == ( PC_FILIAL + PC_MAT ) ) )			
				
			#IFNDEF TOP
				If (cAliasQSCP)->( ;
								PC_PROCES != oPeriodo:cProcesso .and. ;
								PC_PERIODO != oPeriodo:cPeriodo .and. ;
								PC_NUMPAG != oPeriodo:cNumPagto .and. ;
								PC_ROTEIR != oPeriodo:cRoteiro		  ;
							  )
					(cAliasQSPC)->(dbSkip())
					Loop
				EndIf			
			#ENDIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Aborta o processamento                                       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lAbortPrint )
				//'O Calculo Mensal Foi Cancelado Pelo Usuario'
				aAdd( aLogDet , STR0010 )
				Break
			EndIF
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Limita a Leitura somente dos Apontamentos do periodo.		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( cAliasQSPC )->( ( PC_DATA < dPerIni ) .or. ( PC_DATA > dPerFim ) )
				( cAliasQSPC )->( dbSkip() )
				Loop
			EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Quando as Horas Foram Calculadas Pela Tabela so considera  os³
			³ Eventos de Horas Nao Realizadas Quando o Tipo da Verba na  Fo³
			³ lha de Pagamento (GPE) for de Base						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF (;
					( lHorasTab );
					.and.;
					( cAliasQSPC )->(;
										( PC_PD $ aEvesIds[ 005 , 02 ] );
										.or.;
										( PC_PD $ aEvesIds[ 006 , 02 ] );
									);	
				)	
				IF ( ( cAliasQSPC )->PC_PD  $ aEvesIds[ 005 , 02 ] )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Posiciona no SP9 para obter o Codigo para a Folha			   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF PosSP9( aEvesIds[ 005 , 02 ] , cLastFil , NIL , 1 , .F. )
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Posiciona no SRV e Verifica se o Evento e de Base			   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF !( PosSrv( aEvesIds[ 005 , 02 ] , cLastFil , "RV_TIPOCOD" ) == "3" )
							( cAliasQSPC )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				ElseIF ( ( cAliasQSPC )->PC_PD  $ aEvesIds[ 006 , 02 ] )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Posiciona no SP9 para obter o Codigo para a Folha			   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF PosSP9( aEvesIds[ 006 , 02 ] , cLastFil , NIL , 1 , .F. )
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Posiciona no SRV e Verifica se o Evento e de Base			   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF !( PosSrv( aEvesIds[ 006 , 02 ] , cLastFil , "RV_TIPOCOD" ) == "3" )
							( cAliasQSPC )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
			EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Existe codigo Informado               		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			lExistInfo	:= !Empty(( cAliasQSPC )->PC_PDI)

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega o Codigo do Evento e a Quantidade de Horas		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cEvento	:= ( cAliasQSPC )->( IF( lExistInfo , PC_PDI		, PC_PD     ) )
			nHoras	:= ( cAliasQSPC )->( IF( lExistInfo , IF( !Empty( PC_QUANTI ) , PC_QUANTI , PC_QUANTC ) , PC_QUANTC ) )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se Nenhum Codigo foi Informado e Se Existirem Abonos		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF !( lExistInfo )
				aAbonos	:=	{}
				( cAliasQSPC )->(fAbonos(		PC_DATA		,;	//01 - Data do Abono
												PC_PD		,;	//02 - Evento do Abono
												NIL			,;	//03 - Hora Inicial do Abono
												@aAbonos	,;	//04 - Array onde serao carregados os Abonos
												PC_TPMARCA	,;	//05 - Tipo de Marcacao
												PC_CC		,;	//06 - Centro de Custo
												aAbonosPer	,;	//07 - Array com Todos os Abonos do Periodo
												AllTrim(PC_CODFUNC)	,;	//08 - Funcao
												PC_DEPTO	,;	//09 - Depto 
												PC_POSTO	,;	//10 - Posto  
												AllTrim(PC_PROCES)	,;	//11 - Processo
												PC_PERIODO	,;	//12 - Periodo
												PC_ROTEIR	,;	//13 - Roteiro
												PC_NUMPAG	;	//14 - NumPagto								
										);
								)
								
								
				nLenAbo		:= Len( aAbonos ) 
				nHorasAb	:= 0 
				cEvBhAP		:= ( cAliasQSPC )->( PosSP9( PC_PD , cFilSP9 , "P9_BHORAS" , 1 , .F. ) )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Varre todos os Abonos para a Data/Evento					   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				For nW := 1 To nLenAbo
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Carrega as Informacoes do SP6      						   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					aSp6Info := PosSP6( aAbonos[ nW , AABONOS_CODIGO ] , cFilSP6 , aSp6Fields , 1 , .F. )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Obtem o Evento Relacionado ao Abono						   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					cEveAbono	:= aSp6Info[1]
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Obtem a Hora Abonada               						   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					nHrAbon		:= aAbonos[ nW , AABONOS_HORAS_ABO ]
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Verifica se o Motivo de Abono Abona Horas					   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF ( aSp6Info[2] == "S" )
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Adiciona o Abono no Array									   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF !Empty( cEveAbono )
							( cAliasQSPC )->(;
												fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
															PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
															nHrAbon			,;	//03 -> Horas para Soma ou Geracao
															0				,;	//04 -> Valor para Soma ou Geracao
															cEveAbono		,;	//05 -> Evento do Ponto para Pesquisa
															PC_CC			,;	//06 -> Centro de Custo para Comparacao
															cLastFil		,;	//07 -> Filial para Pesquisa no SP9
															NIL				,;	//08 -> Verba da Folha
															NIL				,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
															PC_CODFUNC 		,;	//10 -> Funcao para Comparacao
															PC_DEPTO		,;	//11 -> Depto  para Comparacao   
															PC_POSTO 		,;	//12 -> Posto  para Comparacao   
															PC_PROCES		,;	//13 -> Processo para Comparacao   
															PC_ROTEIR		,;	//14 -> Roteiro para Comparacao   
															PC_PERIODO		,;	//15 -> Periodo para Comparacao   
															PC_NUMPAG	 	;	//16 -> NumPagto para Comparacao  															
														 );
											) 
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³          Verifica a existencia de contador de eventos e registra o  numero de ocorrencias.		  ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						    fContaEvento(lEveCont,lAcumEveCont, nHrAbon, @aEveCont, cEveAbono, @aTotais, dPerIni, dPerFim, aTabCalend, cLastFil, cAliasQSPC)							 
											 
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Se o parametro MV_DEDABBH existir ou estiver setado p/ "Sim" e|
							³Se o Evento do Abono for para Banco de Horas, deduz as   Horas³
							³de Abono das Horas Apontadas para que soh a diferenca seja  en³
							³viada para apuracao das Horas que irao para a Folha.          ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							If lMvDedAbBH
								cEvBhAB:= PosSP9( cEveAbono , cFilSP9 , "P9_BHORAS" , 1 , .F. ) 
								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Se o parametro MV_FolVBh estiver setado p/ "Sim" e se o desti-|
								³no das horas apontadas e o destino das horas abonadas com     ³
								³evento associado são diferentes, deduz-se das horas apontadas ³
								³as horas abonadas. 									       ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								If lMvFolVBH
									IF cEvBhAP <> cEvBhAB
										nHoras := __TimeSub( nHoras , nHrAbon )
									EndIF
								Else
									IF ( cEvBhAB == "S" )
										nHoras := __TimeSub( nHoras , nHrAbon )
									EndIF
								Endif		
							Endif	
						Else           
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Se nao Tiver Evento relacionado ao Motivo de Abono acumula  as³
							³Horas Abonadas que serao posteriormente deduzidas das Horas  A³
							³pontadas													   ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							nHorasAb := __TimeSum( nHorasAb , aAbonos[ nW , AABONOS_HORAS_ABO ] )
						EndIF
					Else
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Se Motivo de Abono Nao Abona Horas e o Codigo do Evento Relaci³
						³onado ao Abono nao Estiver Vazio, Eh como se fosse uma  altera³
						³racao do Codigo de Evento. Ou seja, Vai para os Totais      as³
						³Horas do Abono que serao subtraidas das Horas Calculadas (  Po³
						³deriamos Chamar esta operacao de "Informados via Abono" ).	   ³
						³Para que esse processo seja feito o Parametro MV_SUBABAP  deve³
						³ra ter o Conteudo igual a "S"								   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF ( ( lMvSubAbAp ) .and. !Empty( cEveAbono ) )
							( cAliasQSPC )->(;
												fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
															PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
															nHrAbon			,;	//03 -> Horas para Soma ou Geracao
															0				,;	//04 -> Valor para Soma ou Geracao
															cEveAbono		,;	//05 -> Evento do Ponto para Pesquisa
															PC_CC			,;	//06 -> Centro de Custo para Comparacao
															cLastFil		,;	//07 -> Filial para Pesquisa no SP9
															NIL				,;	//08 -> Verba da Folha
															NIL				,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
															PC_CODFUNC 		,;	//10 -> Funcao para Comparacao
															PC_DEPTO		,;	//11 -> Depto  para Comparacao   
															PC_POSTO 		,;	//12 -> Posto  para Comparacao   
															PC_PROCES		,;	//13 -> Processo para Comparacao   
															PC_ROTEIR		,;	//14 -> Roteiro para Comparacao   
															PC_PERIODO		,;	//15 -> Periodo para Comparacao   
															PC_NUMPAG	 	;	//16 -> NumPagto para Comparacao  															
														 );
											)			 
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³          Verifica a existencia de contador de eventos e registra o  numero de ocorrencias.		  ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						    fContaEvento(lEveCont, lAcumEveCont, nHrAbon, @aEveCont,cEveAbono, @aTotais, dPerIni, dPerFim, aTabCalend, cLastFil, cAliasQSPC)
																	
							nHoras := __TimeSub( nHoras , nHrAbon )
						EndIF
		 			EndIF
		 		Next nW 
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Deduz Horas de Abono das Horas Apontadas. Somente valido   qdo³
				³solicitado que no Cadastro do Motivo de Abonos  MV_ABOSEVE )  ³
				³aceite abono de horas sem a especificacao do codigo de  evento³
				³associado (para compatibilizar com a v.609, onde podia-se dedu³
				³zir os abonos diretamente da verba). Desse modo, as horas  nao³
				³serao a soma das horas de faltas/atrasos/saidas.			   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		 		IF ( ( lMvAbosEve ) .and. ( nHoras > 0 ) )
			 		nHoras := __TimeSub( nHoras , nHorasAb )
			 	EndIF

	   			/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Verifica se existem eventos informados (Evento divido - SPK)  ³
				³e os inclui no array aTotais().                               ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/			 	
		 		( cAliasQSPC )->(;
		 							fGeraRFK(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
		 										@nHoras			,;	//02 -> Total de horas do evento
		 										cLastFil		,;	//03 -> Filial do funcionario
		 										PC_MAT			,;	//04 -> Matricula do funcionario
		 										PC_DATA			,;	//05 -> Data para Pesquisa e Gravacao no aTotais
												PC_PD			,;	//06 -> Evento SPC
									   			PC_PROCES		,;	//07 -> Processo para Comparacao   
												PC_ROTEIR		,;	//08 -> Roteiro para Comparacao   
												PC_PERIODO		,;	//09 -> Periodo para Comparacao   
												PC_NUMPAG	 	;	//10 -> NumPagto para Comparacao
										 );
								)														
		 	EndIF
		 			
			//-- Define o Nome do Array a ser utilizado
			cNomeArray := ""
			IF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "004A" } ) > 0 )
				cNomeArray := "aTotAdiN"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "012A" } ) > 0 )
				cNomeArray := "aTotAtra"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "014A" } ) > 0 )
				cNomeArray := "aTotSAnt"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] $ "001Aú002A" } ) > 0 )
				cNomeArray := "aTotPgHD"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "HEDA" } ) > 0 )
				cNomeArray := "aTotHExt"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento .and.x[2] == "HENA" } ) > 0 )
				cNomeArray := "aTotHENt"
			ElseIF ( aScan( aCodAut, {|x| x[1] == cEvento } ) > 0 )
				cNomeArray := "aTotais"
			EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³          Verifica a existencia de contador de eventos e registra o  numero de ocorrencias.		  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		    fContaEvento(lEveCont,lAcumEveCont, nHoras, @aEveCont, cEvento, @aTotais, dPerIni, dPerFim, aTabCalend, cLastFil, cAliasQSPC)
			
			//-- Adiciona os Eventos no Array
			IF ( cNomeArray == "aTotais" )
				( cAliasQSPC )->(;
									fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
												PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras			,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												cEvento			,;	//05 -> Evento do Ponto para Pesquisa
												PC_CC			,;	//06 -> Centro de Custo para Comparacao
												cLastFil		,;	//07 -> Filial para Pesquisa no SP9
												NIL				,;	//08 -> Verba da Folha
												NIL				,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
												PC_CODFUNC 		,;	//10 -> Funcao para Comparacao
												PC_DEPTO		,;	//11 -> Depto  para Comparacao   
												PC_POSTO 		,;	//12 -> Posto  para Comparacao   
												PC_PROCES		,;	//13 -> Processo para Comparacao   
												PC_ROTEIR		,;	//14 -> Roteiro para Comparacao   
												PC_PERIODO		,;	//15 -> Periodo para Comparacao   
												PC_NUMPAG	 	;	//16 -> NumPagto para Comparacao  															
											 );
								 )			
			ElseIF !Empty(cNomeArray)
				( cAliasQSPC )->(;
									fGeraTot(	&(cNomeArray)	,;	//01 -> Array com os Totais do Ponto
												PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras			,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												cEvento			,;	//05 -> Evento do Ponto para Pesquisa
												PC_CC			,;	//06 -> Centro de Custo para Comparacao
												cLastFil		,;	//07 -> Filial para Pesquisa no SP9
												NIL				,;	//08 -> Verba da Folha
												NIL				,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
												PC_CODFUNC 		,;	//10 -> Funcao para Comparacao
												PC_DEPTO		,;	//11 -> Depto  para Comparacao   
												PC_POSTO 		,;	//12 -> Posto  para Comparacao   
												PC_PROCES		,;	//13 -> Processo para Comparacao   
												PC_ROTEIR		,;	//14 -> Roteiro para Comparacao   
												PC_PERIODO		,;	//15 -> Periodo para Comparacao   
												PC_NUMPAG	 	;	//16 -> NumPagto para Comparacao  															
											 );
								)			
			EndIF
	
			( cAliasQSPC )->( dbSkip() ) //-- Pr¢ximo Evento

		End While
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Fecha a Query do SPC										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFDEF TOP
			IF ( lQueryOpened )
				( cAliasQSPC )->( dbCloseArea() )
				dbSelectArea("SRA")
			EndIF
		#ENDIF	

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Adicional Noturno											  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		fCalcPer( aTotAdiN ,  @aTotais , "AdiN" , cPerAnot  , nTolNotu )
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Atrasos													  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		fCalcPer( aTotAtra ,  @aTotais , "Atra" , cPerAtra  , nTolAtra )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Saida antecipada											  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		fCalcPer( aTotSAnt ,  @aTotais , "SANT" , cPerSaia  , nTolSaia )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Horas Extras												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !fCalcHExt( dPerIni , dPerFim , aTotHExt , aTotHENt , @aTotais , aTabCalend , aCodAut , lMvAcmHExt , cPerHext , nTolHePe , @cMsgErr )
			//'O Calculo Mensal nao sera efetuado.'###'Nao foi Possivel Carregar os Tipos de Horas Extras.'
			aAdd( aLogDet , STR0022 + " " + STR0021 )
			IF !Empty( cMsgErr )
				aAdd( aLogDet , cMsgErr )
			EndIF
			Break
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Horas / DSR												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !fCalcPHD( aTotPgHD,  @aTotais, aTabPadrao , aTabCalend , lHorasTab , lMvAcmHExt , cPerHmov , @cMsgErr )
			//'O Calculo Mensal nao sera efetuado.'###'Nao foi Possivel Carregar os Tipos de Horas Extras.'
			aAdd( aLogDet , STR0022 + " " + STR0021 )
			IF !Empty( cMsgErr )
				aAdd( aLogDet , cMsgErr )
			EndIF
			Break
		EndIF
	
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Transfere os Eventos para Banco de Horas					  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aBHAcum  := {}
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ponto de Entrada para tratamento de eventos antes do BH.     ³
		³ Permite a redefinicao de verbas em funcao de limites persona-³
		³ lizados para cada verba e que difere dos criterios disponi-  ³
		³ lizados no cadastro de eventos para o calculo do BH.		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lPnm07001Block )
			IF ( ValType( aRetBlock := ExecBlock("PNM07001",.F.,.F.,{aClone(aTotais), aClone(aBHAcum)}) ) == "A" )
			   aTotais		:= If( ValType(aRetBlock[1]) == "A", aRetBlock[1] , aTotais	)
			   aBHAcum		:= If( ValType(aRetBlock[2]) == "A", aRetBlock[2] , aBHAcum	)
			EndIF
		EndIF
				  
		fCalcBH(@aTotais,@aBHAcum)

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Aborta o processamento                                       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lAbortPrint )
			//'O Calculo Mensal Foi Cancelado Pelo Usuario'
			aAdd( aLogDet , STR0010 )
			Break
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se nao for Top Posiciona no Funcionario, Caso contrario monta³
		³ Query														   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFNDEF TOP
			( cAliasQSPI )->( dbSeek( cFilSPI + SRA->RA_MAT , .F. ) )
		#ELSE
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Quando a Expressao da Query nao estiver definida monta-a     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF Empty( cSPIQuery )
				cAliasQSPI	:= ( "__Q" + cAliasSPI + "QRY" )
				cSPIQuery := "SELECT "
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carregando os Campos do SPC na Query						   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				For nX := 1 To nSpiFields
					cSPIQuery += aSpiFields[ nX , 01 ] + ", "
				Next nX
				cSPIQuery += "R_E_C_N_O_ RECNO "
				cSPIQuery += " FROM " + InitSqlName( cAliasSPI ) + " " + cAliasSPI
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Montando a Condicao										   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPIQuery += " WHERE "
				cSPIQuery += cAliasSPI + "."
				cSPIQuery += "PI_FILIAL='"+cLastFil+"'"
				cSPIQuery += " AND "
				cSPIQuery += cAliasSPI + "."
				cSPIQuery += "PI_MAT='"+SRA->RA_MAT+"'"
				//cSPIQuery += " AND "
				//cSPIQuery += cAliasSPI + "."				
				//cSPIQuery += "PI_POSTO = '"+SRA->RA_POSTO+"'"
				//cSPIQuery += " AND "
				//cSPIQuery += cAliasSPI + "."				
				//cSPIQuery += "PI_DEPTO = '"+SRA->RA_DEPTO+"'"				
				//cSPIQuery += " AND "
				//cSPIQuery += cAliasSPI + "."				
				//cSPIQuery += "PI_CODFUNC = '"+SRA->RA_CODFUNC+"'"
				cSPIQuery += " AND "
				cSPIQuery += cAliasSPI + "."				
				cSPIQuery += "PI_PROCES = '"+oPeriodo:cProcesso+"'"
				cSPIQuery += " AND "
				cSPIQuery += cAliasSPI + "."				
				cSPIQuery += "PI_PERIODO = '"+oPeriodo:cPeriodo+"'" 
				cSPIQuery += " AND "								
				cSPIQuery += " ( "
				cSPIQuery += 		cAliasSPI + "."
				cSPIQuery += 		"PI_DATA>='"+cIniData+"'"
				cSPIQuery += 		" AND "
				cSPIQuery += 		cAliasSPI + "."
				cSPIQuery += 		"PI_DATA<='"+cFimData+"'"
				cSPIQuery += " )"
				cSPIQuery += " AND "
				cSPIQuery += cAliasSPI + ".D_E_L_E_T_=' ' "
				cSPIQuery += "ORDER BY " + SqlOrder( (cAliasSPI)->( IndexKey() ) )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Guarda os Valores Anteriores                                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPISvQuery	:= cSPIQuery
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Caso contrario, apenas substitui os valores                  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPIQuery	:= StrTran( cSPISvQuery , ( "PI_FILIAL='"+cSvFil+"'"	) , ( "PI_FILIAL='"+cLastFil+"'"	) )
				cSPIQuery	:= StrTran( cSPIQuery   , ( "PI_MAT='"+cSvMat+"'"		) , ( "PI_MAT='"+SRA->RA_MAT+"'"	) )
				cSPIQuery	:= StrTran( cSPIQuery	, ( "PI_DATA>='"+cSvIniData+"'" ) , ( "PI_DATA>='"+cIniData+"'"		) )
				cSPIQuery	:= StrTran( cSPIQuery	, ( "PI_DATA<='"+cSvFimData+"'" ) , ( "PI_DATA<='"+cFimData+"'"		) )				
				cSPIQuery	:= StrTran( cSPIQuery	, ( "PI_POSTO = '"+cSvPosto+"'"	) , ( "PI_POSTO = '"+SRA->RA_POSTO+"'"	) )
				cSPIQuery	:= StrTran( cSPIQuery	, ( "PI_DEPTO = '"+cSvDepto+"'"	) , ( "PI_DEPTO = '"+SRA->RA_DEPTO+"'"	) )
				cSPIQuery	:= StrTran( cSPIQuery	, ( "PI_CODFUNC = '"+cSvCodFunc+"'"	) , ( "PI_CODFUNC = '"+SRA->RA_CODFUNC+"'"	) )
				cSPIQuery	:= StrTran( cSPIQuery	, ( "PI_PROCES = '"+cSvProcesso+"'"	) , ( "PI_PROCES = '"+oPeriodo:cProcesso+"'") )
				cSPIQuery	:= StrTran( cSPIQuery	, ( "PI_PERIODO = '"+cSvPeriodo+"'"	) , ( "PI_PERIODO = '"+oPeriodo:cPeriodo+"'" ) )

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Guarda os Valores Anteriores                                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPISvQuery	:= cSPIQuery
			EndIF
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Utiliza ChangeQuery() para Remontar a Query                  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPIQuery := ChangeQuery( cSPIQuery )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se conseguiu Montar a Query Seta os Campos                   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cSPIQuery),cAliasQSPI,.T.,.T.) )
				For nX := 1 To nSpiFields
					IF !( aSpiFields[ nX , 02 ] == "C" )
						TcSetField(cAliasQSPI,aSpiFields[nX,01],aSpiFields[nX,02],aSpiFields[nX,03],aSpiFields[nX,04])
					EndIF
				Next nX
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Caso contrario Utiliza o processo Padrao                     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cAliasQSPI	:= cAliasSPI
				( cAliasQSPI )->( dbSeek( cFilSPI + SRA->RA_MAT  , .F. ) )
			EndIF
		#ENDIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega Informacoes Anteriores do SPI              		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aSPI:={}
		While ( ( cAliasQSPI )->( !Eof() .and. cFilSPI + SRA->RA_MAT == PI_FILIAL + PI_MAT ) )
		
			#IFNDEF TOP
				If (cAliasQSCP)->( ;
								PC_PROCES != oPeriodo:cProcesso .and. ;
								PC_PERIODO != oPeriodo:cPeriodo ;
							  )
					(cAliasQSPC)->(dbSkip())
					Loop
				EndIf			

			#ENDIF
			IF ( cAliasQSPI )->( ( PI_DATA >= dPerIni ) .and. ( PI_DATA <= dPerFim ) )
				aAdd( aSPI , Array( 14 ) )
				nLenSPI := Len( aSPI )
				aSPI[ nLenSPI , 01 ] := ( cAliasQSPI )->( PI_DATA 	)
				aSPI[ nLenSPI , 02 ] := ( cAliasQSPI )->( PI_PD   	)
				aSPI[ nLenSPI , 03 ] := ( cAliasQSPI )->( PI_QUANT	)
				aSPI[ nLenSPI , 04 ] := ( cAliasQSPI )->( PI_QUANTV )
				#IFNDEF TOP
					aSPI[ nLenSPI , 05 ] := ( cAliasQSPI )->( Recno() )
				#ELSE
					IF !( lQueryOpened  )
						aSPI[ nLenSPI , 05 ] := ( cAliasQSPI )->( Recno() )
					Else
						aSPI[ nLenSPI , 05 ] := ( cAliasQSPI )->( RECNO )
					EndIF	
				#ENDIF	
				aSPI[ nLenSPI , 06 ] := ( cAliasQSPI )->( PI_CC			)
				aSPI[ nLenSPI , 07 ] := 0
				aSPI[ nLenSPI , 08 ] := ( cAliasQSPI )->( PI_CODFUNC		)
				aSPI[ nLenSPI , 09 ] := ( cAliasQSPI )->( PI_DEPTO			)				
				aSPI[ nLenSPI , 10 ] := ( cAliasQSPI )->( PI_POSTO			)				
				aSPI[ nLenSPI , 11 ] := ( cAliasQSPI )->( PI_PROCES		)				
				aSPI[ nLenSPI , 13 ] := ( cAliasQSPI )->( PI_PERIODO		)				
				aSPI[ nLenSPI , 12 ] := ( cAliasQSPI )->( PI_ROTEIR		)
				aSPI[ nLenSPI , 14 ] := ( cAliasQSPI )->( PI_NUMPAG		)
			EndIF
			( cAliasQSPI )->( dbSkip() )
		End While

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Fecha a Query do SPI										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFDEF TOP
			IF ( lQueryOpened )
				( cAliasQSPI )->( dbCloseArea() )
				dbSelectArea("SRA")
			EndIF
		#ENDIF	

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Efetua a grava‡„o do Array aBHAcum no arquivo SPI			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( ( nBHAcum := Len(aBHAcum) ) > 0 )
			For nX := 1 To nBHAcum
				IF ( aBHAcum[nX, 3] > 0 )
					IF ( nPos := aScan( aSPI , { |x| 	x[01] == aBHAcum[ nX,01 ] .and. ;
														x[02] == aBHAcum[ nX,02 ] .and. ;
														x[06] == aBHAcum[ nX,05 ] .and. ;
														x[08] == aBHAcum[ nX,06 ] .and. ;
														x[09] == aBHAcum[ nX,07 ] .and. ;
														x[10] == aBHAcum[ nX,08 ] .and. ;
														x[11] == aBHAcum[ nX,09 ] .and. ;
														x[12] == aBHAcum[ nX,10 ] .and. ;
														x[13] == aBHAcum[ nX,11 ] .and. ;
														x[14] == aBHAcum[ nX,12 ] 		;
												} ;
									);
						) > 0
						IF aSPI[nPos,3] # aBHAcum[nX,3] .or. aSPI[nPos,4] # aBHAcum[nX,4]
							SPI->(dbGoTo(aSPI[nPos,5]))
							IF !SPI->( RecLock( "SPI", .F. , .T. ) )
								Loop
							EndIF
							nValorV			:= Round(fConvHr(aBHAcum[nX,3],"D")*(aBHAcum[nX,4]/100),2)
							nValorV			:= fConvhr(nValorV,"H")
							SPI->PI_CC		:= IF( Empty(aBHAcum[nX,5]) , SRA->RA_CC , aBHAcum[nX,5] )
							SPI->PI_QUANT	:= aBHAcum[nX,3]
							SPI->PI_QUANTV	:= nValorV
							SPI->PI_CODFUNC	:= IF( Empty(aBHAcum[nX,06]) , SRA->RA_CODFUNC		, aBHAcum[nX,06] ) 
							SPI->PI_DEPTO	:= IF( Empty(aBHAcum[nX,07]) , SRA->RA_DEPTO		, aBHAcum[nX,07] ) 
							SPI->PI_POSTO  	:= IF( Empty(aBHAcum[nX,08]) , SRA->RA_POSTO		, aBHAcum[nX,08] ) 
							SPI->PI_PROCES  := IF( Empty(aBHAcum[nX,09]) , SRA->RA_PROCES		, aBHAcum[nX,09] ) 
							SPI->PI_PERIODO := IF( Empty(aBHAcum[nX,11]) , oPeriodo:cPeriodo	, aBHAcum[nX,11] ) 						
							SPI->PI_ROTEIR  := IF( Empty(aBHAcum[nX,10]) , oPeriodo:cRoteir 	, aBHAcum[nX,10] ) 
							SPI->PI_NUMPAG  := IF( Empty(aBHAcum[nX,12]) , oPeriodo:cNumPagto	, aBHAcum[nX,12] ) 							

							SPI->( MsUnlock() )
						EndIF
						aDel(aSPI, nPos)
						aSize(aSPI, Len(aSPI)-1)
					Else
						IF !SPI->( RecLock( "SPI" , .T. ) )
							Loop
						EndIF
						nValorV := Round(fConvHr(aBHAcum[nX,3],"D")*(aBHAcum[nX, 4]/100),2)
						nValorV := fConvhr(nValorV,"H")
						SPI->PI_FILIAL	:= cFilSPI
						SPI->PI_MAT		:= SRA->RA_MAT
						SPI->PI_PD		:= aBHAcum[nX, 2]
						SPI->PI_CC		:= IF( Empty(aBHAcum[nX,5]) , SRA->RA_CC , aBHAcum[nX,5] )
						SPI->PI_DATA	:= aBHAcum[nx, 1]
						SPI->PI_QUANT	:= aBHAcum[nX, 3]
						SPI->PI_QUANTV	:= nValorV
						SPI->PI_FLAG	:= "G"
						SPI->PI_CODFUNC	:= IF( Empty(aBHAcum[nX,06]) , SRA->RA_CODFUNC		, aBHAcum[nX,06] ) 
						SPI->PI_DEPTO	:= IF( Empty(aBHAcum[nX,07]) , SRA->RA_DEPTO		, aBHAcum[nX,07] ) 
						SPI->PI_POSTO  	:= IF( Empty(aBHAcum[nX,08]) , SRA->RA_POSTO		, aBHAcum[nX,08] ) 
						SPI->PI_PROCES  := IF( Empty(aBHAcum[nX,09]) , SRA->RA_PROCES		, aBHAcum[nX,09] ) 
						SPI->PI_PERIODO := IF( Empty(aBHAcum[nX,11]) , oPeriodo:cPeriodo	, aBHAcum[nX,11] ) 
						SPI->PI_ROTEIR  := IF( Empty(aBHAcum[nX,10]) , oPeriodo:cRoteir 	, aBHAcum[nX,10] ) 
						SPI->PI_NUMPAG  := IF( Empty(aBHAcum[nX,12]) , oPeriodo:cNumPagto	, aBHAcum[nX,12] ) 																		
						
						SPI->( MsUnlock() )
					EndIF
				EndIF
			Next nX
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Apaga so SPI as informacoes que nao foram recalculadas	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nLenSPI := Len(aSPI)
		For nX := 1 To nLenSPI
			SPI->( dbGoTo( aSPI[ nX , 5 ] ) )
			// So apaga se for Gerado
			IF SPI->( PI_FLAG == "G" .and.PI_STATUS <> "B" )
				IF SPI->( RecLock( "SPI" , .F. ) )
					IF !SPI->( FkDelete( @cMsgErr ) )
						SPI->( RollBackDelTran( cMsgErr ) )
					EndIF
					SPI->( MsUnLock() )
				EndIF
			EndIF
		Next nX

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se nao for Top Posiciona no Funcionario, Caso contrario monta³
		³ Query														   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFNDEF TOP
			( cAliasQSPB )->( dbSeek( cFilSPB + SRA->RA_MAT , .F. ) )
		#ELSE
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Quando a Expressao da Query nao estiver definida monta-a     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF Empty( cSPBQuery )
				cAliasQSPB	:= ( "__Q" + cAliasSPB + "QRY" )
				cSPBQuery := "SELECT "
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carregando os Campos do SPC na Query						   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				For nX := 1 To nSpbFields
					cSPBQuery += aSpbFields[ nX , 01 ] + ", "
				Next nX
				cSPBQuery += "R_E_C_N_O_ RECNO "
				cSPBQuery += " FROM " + InitSqlName( cAliasSPB ) + " " + cAliasSPB
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Montando a Condicao										   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPBQuery += " WHERE "
				cSPBQuery += cAliasSPB + "."
				cSPBQuery += "PB_FILIAL='"+cLastFil+"'"
				cSPBQuery += " AND "				
				cSPBQuery += cAliasSPB + "."
				cSPBQuery += "PB_MAT='"+SRA->RA_MAT+"'"
				//cSPBQuery += " AND "
				//cSPBQuery += cAliasSPB + "."				
				//cSPBQuery += "PB_POSTO = '"+SRA->RA_POSTO+"'"
				//cSPBQuery += " AND "
				//cSPBQuery += cAliasSPB + "."				
				//cSPBQuery += "PB_DEPTO = '"+SRA->RA_DEPTO+"'"				
				//cSPBQuery += " AND "
				//cSPBQuery += cAliasSPB + "."				
				//cSPBQuery += "PB_CODFUNC = '"+SRA->RA_CODFUNC+"'"
				cSPBQuery += " AND "
				cSPBQuery += cAliasSPB + "."				
				cSPBQuery += "PB_PROCES = '"+oPeriodo:cProcesso+"'"
				cSPBQuery += " AND "
				cSPBQuery += cAliasSPB + "."				
				cSPBQuery += "PB_PERIODO = '"+oPeriodo:cPeriodo+"'" 
				cSPBQuery += " AND "
				cSPBQuery += cAliasSPB + "."				
				cSPBQuery += "PB_ROTEIR = '"+oPeriodo:cRoteiro+"'"
				cSPBQuery += " AND "
				cSPBQuery += cAliasSPB + ".D_E_L_E_T_=' ' "
				cSPBQuery += "ORDER BY " + SqlOrder( (cAliasSPB)->( IndexKey() ) )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Guarda os Valores Anteriores                                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPBSvQuery	:= cSPBQuery
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Caso contrario, apenas substitui os valores                  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPBQuery	:= StrTran( cSPBSvQuery , ( "PB_FILIAL='"+cSvFil+"'"	) , ( "PB_FILIAL='"+cLastFil+"'"	) )
				cSPBQuery	:= StrTran( cSPBQuery   , ( "PB_MAT='"+cSvMat+"'"		) , ( "PB_MAT='"+SRA->RA_MAT+"'"	) )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_DATA>='"+cSvIniData+"'" ) , ( "PB_DATA>='"+cIniData+"'"		) )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_DATA<='"+cSvFimData+"'" ) , ( "PB_DATA<='"+cFimData+"'" 	) )			
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_POSTO = '"+cSvPosto+"'"	) , ( "PB_POSTO = '"+SRA->RA_POSTO+"'"	) )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_DEPTO = '"+cSvDepto+"'"	) , ( "PB_DEPTO = '"+SRA->RA_DEPTO+"'"	) )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_CODFUNC = '"+cSvCodFunc+"'"	) , ( "PB_CODFUNC = '"+SRA->RA_CODFUNC+"'"	) )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_PROCES = '"+cSvProcesso+"'"	) , ( "PB_PROCES = '"+oPeriodo:cProcesso+"'") )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_PERIODO = '"+cSvPeriodo+"'"	) , ( "PB_PERIODO = '"+oPeriodo:cPeriodo+"'" ) )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_NUMPAG = '"+cSvNumPag+"'"	) , ( "PB_NUMPAG = '"+oPeriodo:cNumPagto+"'" ) )
				cSPBQuery	:= StrTran( cSPBQuery	, ( "PB_ROTEIR = '"+cSvRoteiro+"'"	) , ( "PB_ROTEIR = '"+oPeriodo:cRoteiro+"'" ) )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Guarda os Valores Anteriores                                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cSPBSvQuery	:= cSPBQuery
			EndIF
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Utiliza ChangeQuery() para Remontar a Query                  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cSPBQuery := ChangeQuery( cSPBQuery )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se conseguiu Montar a Query Seta os Campos                   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cSPBQuery),cAliasQSPB,.T.,.T.) )
				For nX := 1 To nSpbFields
					IF !( aSpbFields[ nX , 02 ] == "C" )
						TcSetField(cAliasQSPB,aSpbFields[nX,01],aSpbFields[nX,02],aSpbFields[nX,03],aSpbFields[nX,04])
					EndIF
				Next nX
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Caso contrario Utiliza o processo Padrao                     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cAliasQSPB	:= cAliasSPB
				( cAliasQSPB )->( dbSeek( cFilSPB + SRA->RA_MAT , .F. ) )
			EndIF
		#ENDIF
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega os Dados Anteriores do SPB                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aSPB:={}
		While ( ( cAliasQSPB )->( !Eof() .and.cFilSPB + SRA->RA_MAT == PB_FILIAL + PB_MAT ) )
			
			#IFNDEF TOP
				If (cAliasQSCP)->( ;
								PC_PROCES != oPeriodo:cProcesso .and. ;
								PC_PERIODO != oPeriodo:cPeriodo .and. ;
								PC_NUMPAG != oPeriodo:cNumPagto .and. ;
								PC_ROTEIR != oPeriodo:cRoteiro		  ;
							  )
					(cAliasQSPC)->(dbSkip())
					Loop
				EndIf			
			#ENDIF
			
			aAdd( aSPB , Array( 21 ) )  
			nLenSPB := Len( aSPB )
			aSPB[ nLenSPB , 01 ] := ( cAliasQSPB )->( PB_DATA	)
			aSPB[ nLenSPB , 02 ] := ( cAliasQSPB )->( PB_PD		)
			aSPB[ nLenSPB , 03 ] := ( cAliasQSPB )->( PB_HORAS	)
			#IFNDEF TOP
				aSPB[ nLenSPB , 04 ] := ( cAliasQSPB )->( Recno() )
			#ELSE
				IF !( lQueryOpened )
					aSPB[ nLenSPB , 04 ] := ( cAliasQSPB )->( Recno() )
				Else
					aSPB[ nLenSPB , 04 ] := ( cAliasQSPB )->( RECNO	)
				EndIF	
			#ENDIF	
			aSPB[ nLenSPB , 05 ] := ( cAliasQSPB )->( PB_CC			)
			aSPB[ nLenSPB , 06 ] := ( cAliasQSPB )->( PB_VALOR		)
			aSPB[ nLenSPB , 07 ] := ( cAliasQSPB )->( PB_TIPO2		)
			aSPB[ nLenSPB , 08 ] := ( cAliasQSPB )->( PB_CODFUNC	)
			aSPB[ nLenSPB , 09 ] := ( cAliasQSPB )->( PB_DEPTO		)
			aSPB[ nLenSPB , 10 ] := ( cAliasQSPB )->( PB_POSTO		)
			aSPB[ nLenSPB , 11 ] := ( cAliasQSPB )->( PB_PROCES		)
			aSPB[ nLenSPB , 12 ] := ( cAliasQSPB )->( PB_ROTEIR		)
			aSPB[ nLenSPB , 13 ] := ( cAliasQSPB )->( PB_PERIODO	)
			aSPB[ nLenSPB , 14 ] := ( cAliasQSPB )->( PB_SEMANA		)
			aSPB[ nLenSPB , 15 ] := ( cAliasQSPB )->( PB_D1			)
			aSPB[ nLenSPB , 16 ] := ( cAliasQSPB )->( PB_D2			)
			aSPB[ nLenSPB , 17 ] := ( cAliasQSPB )->( PB_D3			)
			aSPB[ nLenSPB , 18 ] := ( cAliasQSPB )->( PB_D4			)
			aSPB[ nLenSPB , 19 ] := ( cAliasQSPB )->( PB_D5			)
			aSPB[ nLenSPB , 20 ] := ( cAliasQSPB )->( PB_D6			)
			aSPB[ nLenSPB , 21 ] := ( cAliasQSPB )->( PB_D7			)				
			( cAliasQSPB )->( dbSkip() )
		End While
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Fecha a Query do SPB										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFDEF TOP
			IF ( lQueryOpened )
				( cAliasQSPB )->( dbCloseArea() )
				dbSelectArea("SRA")
			EndIF
		#ENDIF	
               
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Refeit¢rio												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( cRefeit == "S" )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Ponto de Entrada Para Tratamento Especifico para Refeicoes    ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lPoncalrBlock )
				IF ( ValType( uRetBlock := ExecBlock( "PONCALR" , .F. , .F. , { aTotais , aCodRef } ) ) == "A" )
					IF ( Len( uRetBlock ) > 0 )
						IF ( ValType( uRetBlock[1] ) == "A" )
							aTotais	:= aClone( uRetBlock[1] )
						EndIF
						IF ( ( Len( uRetBlock ) > 1 ) .and. ( ValType( uRetBlock[2] ) == "A" ) )
							aCodRef	:= aClone( uRetBlock[2] )
						EndIF
					EndIF
					uRetBlock	:= NIL
				EndIF
			Else
				fCalRefeit( cLastFil , SRA->RA_MAT , @aTotais , @aCodRef )
			EndIF
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ponto de Entrada Antes da Totalizacao dos Eventos que    irao³
		³ para a Folha de Pagamento                                    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lPonCalaTotBlock )
			uRetBlock := ExecBlock(;
										"PONCALATOT",;
										.F.,;
										.F.,;
										{;
											SRA->RA_FILIAL,;		//ParamIxb[1] <-> Filial do Funcionario
											SRA->RA_MAT,;			//ParamIxb[2] <-> Matricula do Funcionario
											aClone( aTotais ),;		//ParamIxb[3] <-> Array aTotais
											dPerIni,;				//ParamIxb[4] <-> Periodo Incial do Apontamento
											dPerFim,;				//ParamIxb[5] <-> Periodo Final do Apontamento
											aClone( aTabCalend );	//ParamIxb[6] <-> Array com o Calendario de Marcacoes
										},;
										.F.;
					 			 )
			IF ( ValType( uRetBlock ) == "A" )
				aTotais := aClone( uRetBlock )
			EndIF
			uRetBlock := NIL
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Grava no SPB sem alimentar as caixas de semana para TODOS os³
		³ paises menos para os paises nas  condicoes abaixo			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/                               
		If ! ( ( cPaisLoc == 'MEX' .and. cMvModFol == "2" ) .or. ( cPaisLoc $ 'ARG/EQU/VEN/PER/COL/PTG' ) )
				
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Totaliza de Acordo com as Verbas da Folha					  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			fTotEve( @aTotais , .T., cVerbasDiarias )
		
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Grava as Informacoes no SPB								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( ( nTotais := Len(aTotais) ) > 0 )
				For nX := 1 To nTotais
					IF (;
							( aTotais[nX,ATOTAIS_HORAS] > 0 );
							.and.;
							( aScan(aCodAut, {|x| x[1] == aTotais[nX,ATOTAIS_EVENTO_PONTO] .and.!Empty( x[13] ) } ) > 0 );
						)
						//Se for uma verba diaria, procura pela chave inteira
						If ( aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] $ cVerbasDiarias )
							  nPos := aScan(aSPB, {|x| 	x[01] == aTotais[nX,ATOTAIS_DATA] 				.and. x[02] == aTotais[nX,ATOTAIS_CODIGO_FOLHA] .and.;
														x[05] == aTotais[nX,ATOTAIS_CENTRO_DE_CUSTO] 	.and. x[08] == aTotais[nX,ATOTAIS_FUNCAO] .and.;
														x[09] == aTotais[nX,ATOTAIS_DEPTO ]				.and. x[10] == aTotais[nX,ATOTAIS_POSTO] .and.;
														x[11] == aTotais[nX,ATOTAIS_PROCESSO]			.and. x[12] == aTotais[nX,ATOTAIS_ROTEIRO] .and.;
														x[13] == aTotais[nX,ATOTAIS_PERIODO]			.and. x[14] == aTotais[nX,ATOTAIS_NUM_PAGTO] ;
												   };
											)
						//Do contratio nao pesquisa a data, pois a eventual gravacao anterior foi feita com a database
						Else
							  nPos := aScan(aSPB, {|x| 	x[02] == aTotais[nX,ATOTAIS_CODIGO_FOLHA] .and.;
														x[05] == aTotais[nX,ATOTAIS_CENTRO_DE_CUSTO] 	.and. x[08] == aTotais[nX,ATOTAIS_FUNCAO] .and.;
														x[09] == aTotais[nX,ATOTAIS_DEPTO ]				.and. x[10] == aTotais[nX,ATOTAIS_POSTO] .and.;
														x[11] == aTotais[nX,ATOTAIS_PROCESSO]			.and. x[12] == aTotais[nX,ATOTAIS_ROTEIRO] .and.;
														x[13] == aTotais[nX,ATOTAIS_PERIODO]			.and. x[14] == aTotais[nX,ATOTAIS_NUM_PAGTO] ;
												   };
											)						
						EndIf
						
						IF ( nPos  > 0 )
							IF ( (aSPB[nPos,3] # aTotais[nX,ATOTAIS_HORAS]) .or. (aSPB[nPos,6] # aTotais[nX,ATOTAIS_VALOR]) ) .AND. ( aSPB[nPos,7] <> "I")
								SPB->(dbGoTo(aSPB[nPos,4]))
								IF !SPB->( RecLock( "SPB" , .F. , .T. ) )
									Loop
								EndIF
								SPB->PB_HORAS 	:= fConvHr(aTotais[nX, ATOTAIS_HORAS], "D")   
								SPB->PB_VALOR	:= aTotais[ nX , ATOTAIS_VALOR ]
								IF ( aTotais[ nX , ATOTAIS_VALOR ] > 0  )  
										SPB->PB_TIPO1	:=  "V" 
								ElseIF ( aScan( aCodRef , { |x| x == aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] } ) > 0 ) .OR. 	 ;	
							   		    ( aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] $ cVerbaCont	) 		
										SPB->PB_TIPO1	:= 	"D" 
								Else
										SPB->PB_TIPO1	:=  "H" 
								Endif              
								SPB->PB_CODFUNC := aTotais[nX,ATOTAIS_FUNCAO]
								SPB->PB_DEPTO 	:= aTotais[nX,ATOTAIS_DEPTO]							
								SPB->PB_POSTO 	:= aTotais[nX,ATOTAIS_POSTO]
								SPB->PB_PROCES	:= aTotais[nX,ATOTAIS_PROCESSO]							
								SPB->PB_ROTEIR 	:= aTotais[nX,ATOTAIS_ROTEIRO]
								SPB->PB_PERIODO := aTotais[nX,ATOTAIS_PERIODO]								
								SPB->PB_SEMANA  := aTotais[nX,ATOTAIS_NUM_PAGTO]								
								SPB->( MsUnlock() )
							EndIF
							aDel(aSPB, nPos)
							aSize(aSPB, Len(aSPB)-1)
						ElseIF !Empty( aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] )
							IF !SPB->( RecLock( "SPB" , .T. ) )
								Loop
							EndIF
							SPB->PB_FILIAL := cFilSPB
							SPB->PB_CC     := IF( Empty( aTotais[ nX , ATOTAIS_CENTRO_DE_CUSTO ] ) , SRA->RA_CC , aTotais[ nX , ATOTAIS_CENTRO_DE_CUSTO ] )
							SPB->PB_MAT    := SRA->RA_MAT
							SPB->PB_PD     := aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] 
							SPB->PB_HORAS  := fConvHr(aTotais[ nX , ATOTAIS_HORAS ], "D")
							SPB->PB_DATA   := If ( aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] $ cVerbasDiarias, aTotais[nX,ATOTAIS_DATA], sToD(aResultRCH[1, nPosDtPgto]) )
							IF ( aTotais[ nX , ATOTAIS_VALOR ] > 0  )  
									SPB->PB_TIPO1	:=  "V" 
							ElseIF ( aScan( aCodRef , { |x| x == aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] } ) > 0 ) .OR. 	 ;	
						   		    ( aTotais[ nX , ATOTAIS_CODIGO_FOLHA ] $ cVerbaCont	) 		
									SPB->PB_TIPO1	:= 	"D" 
							Else
									SPB->PB_TIPO1	:=  "H" 
							Endif
							SPB->PB_TIPO2  := "G" 
							SPB->PB_VALOR  := aTotais[ nX , ATOTAIS_VALOR ]
							
							SPB->PB_CODFUNC := aTotais[nX,ATOTAIS_FUNCAO]  
							SPB->PB_DEPTO 	:= aTotais[nX,ATOTAIS_DEPTO]							
							SPB->PB_POSTO 	:= aTotais[nX,ATOTAIS_POSTO]
							SPB->PB_PROCES	:= aTotais[nX,ATOTAIS_PROCESSO]							
							SPB->PB_ROTEIR 	:= aTotais[nX,ATOTAIS_ROTEIRO]
							SPB->PB_PERIODO := aTotais[nX,ATOTAIS_PERIODO]								
							SPB->PB_SEMANA  := aTotais[nX,ATOTAIS_NUM_PAGTO]						
							SPB->( MsUnlock() )
						EndIF
					EndIF
				Next nX
			EndIF
		
		ElseIf ( ( cPaisLoc == 'MEX' .and. cMvModFol == "2" ) .or. ( cPaisLoc $ 'ARG/EQU/VEN/PER/COL/PTG' ) )
		
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Grava as Informacoes no SPB								  ³
			³ Efetua a gravacao no SPB com as verbas, agrupadas por semana³
			³ gravando na data o dia inicial da semana correspondente	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Constroi as semanas do periodo atual						  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			fSemanas( @aTotSem, oPeriodo:dDataIni, oPeriodo:dDataFim )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Separa as verbas nas semanas								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			fSepVerSem( @aTotSem, aTotais, cVerbasDiarias )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Grava os resultados no SPB								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/			
			fGravaSpb( cFilSPB,;
					   SRA->RA_MAT,;
					   SRA->RA_PROCES,;
				 	   oPeriodo:cRoteiro,;
					   oPeriodo:cPeriodo,;
					   oPeriodo:cNumPagto,;
					   SRA->RA_DEPTO,;
					   SRA->RA_POSTO,;
					   SRA->RA_PROCES,;
					   cVerbaCont,;
					   aCodAut,;
					   aCodRef,;
					   aSPB,;
					   aTotSem,;
					   cVerbasDiarias;
					    )

		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Apaga so SPB as informacoes que nao foram recalculadas	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nLenSPB := Len( aSPB )
		For nX := 1 To nLenSPB
			SPB->( dbGoTo( aSPB[ nX,4 ] ) )
			// So apaga se for Gerado
			IF ( SPB->PB_TIPO2 == "G" )
				IF SPB->( RecLock( "SPB" , .F. ) )
					IF !SPB->( FkDelete( @cMsgErr ) )
						SPB->( RollBackDelTran( cMsgErr ) )
					EndIF
					SPB->( MsUnlock() )
				EndIF
			EndIF
		Next nX

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ponto de Entrada de Saida                                    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lPoncaldBlock )
 			ExecBlock("PONCALD" , .F. , .F. )
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva as Variaveis para a Modificacao das Querys			   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFDEF TOP
			cSvFil	    := cLastFil
			cSvMat		:= SRA->RA_MAT
			cSvIniData	:= cIniData
			cSvFimData	:= cFimData
			
			cSvPosto	:= SRA->RA_POSTO
			cSvDepto	:= SRA->RA_DEPTO
			cSvCodFunc	:= SRA->RA_CODFUNC
			
			cSvPeriodo	:= oPeriodo:cPeriodo
			cSvProcesso	:= oPeriodo:cProcesso
			cSvNumPag	:= oPeriodo:cNumPagto
			cSvRoteiro	:= oPeriodo:cRoteiro
			
		#ENDIF	

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Pr¢ximo Funcion rio										   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		SRA->( dbSkip() )

	End While	

End Sequence

Else

	cMsg := STR0037	// "Periodo nao Cadastrado!"
	MsgInfo( cMsg )

EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Fecha a Query do SRA e Restaura o Padrao                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
#IFDEF TOP
	IF ( lSraQryOpened )
		SRA->( dbCloseArea() )
		ChkFile( "SRA" )
	EndIF	
#ENDIF

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Gera o Log de Inconsistencias                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF !Empty( aLogDet )
	fMakeLog( { aLogDet } , aLogTitle , "PONM070" )
EndIF

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Conteudo Original da Filial de Entrada			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cFilAnt:= cSvFilAnt

RestArea( aAreaSRA )

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ fCalcPer  ³ Autor ³ Fernando Joly Siquini³ Data ³ 20/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula Eventos com Totaliza‡„o por Per¡odo.               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ PONM070							             			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aTotAdiN = Array multidimencional com os Adicionais Not.   ³±±
±±³          ³ aTotais  = Array multidimencional com os Totais.           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalcPer( aTotEve , aTotais , cTipo , cPeriodo  , nTolera )

Local dDtIni   		:= Ctod("//")
Local dData    		:= Ctod("//")
Local nX       		:= 0
Local nC       		:= 0
Local nT       		:= 0
Local nTotPer  		:= 0
Local nTotal   		:= 0
Local nTotEve		:= 0
Local nPeriodo		:= 0

If ( ( nTotEve := Len(aTotEve) ) > 0 )

	If ( ( cPeriodo == "D" ) .or. ( cPeriodo == "M" ) ) // Tolerancia Diaria ou Mensal
		If ( cPeriodo == "M" )
			aEval(aTotEve, {|x| nTotPer := __TimeSum(x[ATOTAIS_HORAS],nTotPer) })
			If ( nTotPer <= nTolera )
				Return( NIL )
			Endif
		Endif
		For nX := 1 To nTotEve
			fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
						aTotEve[nX,ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						aTotEve[nX,ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
						0									,;	//04 -> Valor para Soma ou Geracao
						aTotEve[nX,ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
						aTotEve[nX,ATOTAIS_CENTRO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9
						NIL									,;	//08 -> Verba da Folha
						NIL									,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
						aTotEve[nX,ATOTAIS_FUNCAO]			,;	//10 -> Funcao para Comparacao 
						aTotEve[nX,ATOTAIS_DEPTO]			,;	//11 -> Depto  para Comparacao   
						aTotEve[nX,ATOTAIS_POSTO] 			,;	//12 -> Posto  para Comparacao   
						aTotEve[nX,ATOTAIS_PROCESSO]		,;	//13 -> Processo para Comparacao   
						aTotEve[nX,ATOTAIS_ROTEIRO]			,;	//14 -> Roteiro para Comparacao   
						aTotEve[nX,ATOTAIS_PERIODO]			,;	//15 -> Periodo para Comparacao   
						aTotEve[nX,ATOTAIS_NUM_PAGTO]		;	//16 -> NumPagto para Comparacao  															
					)
		Next nX

	ElseIF ( cPeriodo == "Q" ) // Tolerancia Quinzenal
		dData := ( dPerIni + 14 )
		For nC := 1 To 2
			nTotPer := 0
			If ( nC == 1 ) // Primeira Quinzena
				aEval(aTotEve, {|x| If( x[ATOTAIS_DATA] >= dPerIni .and.x[ATOTAIS_DATA] <= dData, nTotPer := __TimeSum(x[ATOTAIS_HORAS],nTotPer), Nil) })
			Else			// Segunda Quinzena
				aEval(aTotEve, {|x| If( x[ATOTAIS_DATA] >= (dData+1) .and.x[ATOTAIS_DATA] <= dPerFim, nTotPer := __TimeSum(x[ATOTAIS_HORAS],nTotPer), Nil) })
			Endif
			If ( nTotPer > nTolera )
				nTotEve := Len(aTotEve)
				For nX := 1 To nTotEve
					If (;
							(;
								( nC == 1 );
								.and.;
								( aTotEve[nx,ATOTAIS_DATA] >= dPerIni );
								.and.;
								( aTotEve[nx,ATOTAIS_DATA] <= dData );
							);
							.or.;
							(;
								( nC == 2 );
								.and.;
								( aTotEve[nx,ATOTAIS_DATA] >= ( dData + 1 ) );
								.and.;
								( aTotEve[nx,ATOTAIS_DATA] <= dPerFim );
							);	
						)	
						fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
									aTotEve[nX,ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
									aTotEve[nX,ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
									0									,;	//04 -> Valor para Soma ou Geracao
									aTotEve[nX,ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
									aTotEve[nX,ATOTAIS_CENTRO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
									SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9
									NIL									,;	//08 -> Verba da Folha
									NIL									,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
									aTotEve[nX,ATOTAIS_FUNCAO]			,;	//10 -> Funcao para Comparacao 
									aTotEve[nX,ATOTAIS_DEPTO]			,;	//11 -> Depto  para Comparacao   
									aTotEve[nX,ATOTAIS_POSTO] 			,;	//12 -> Posto  para Comparacao   
									aTotEve[nX,ATOTAIS_PROCESSO]		,;	//13 -> Processo para Comparacao   
									aTotEve[nX,ATOTAIS_ROTEIRO]			,;	//14 -> Roteiro para Comparacao   
									aTotEve[nX,ATOTAIS_PERIODO]			,;	//15 -> Periodo para Comparacao   
									aTotEve[nX,ATOTAIS_NUM_PAGTO] 		;	//16 -> NumPagto para Comparacao  															
								)
					Endif
				Next nX
			Endif
		Next Nc

	ElseIF ( cPeriodo == "S" ) // Tolerancia Semanal
		dDtIni		:= dPerIni
		nPeriodo	:= ( dPerFim - dPerIni )
		For nX := 0 To nPeriodo
			dData    := ( dPerIni + nX )
			aEval(aTotEve, {|x| If( x[ATOTAIS_DATA] == dData , nTotPer := __TimeSum(x[ATOTAIS_HORAS],nTotPer), Nil) })
			If ( ( Dow(dData) == 1 ) .or. ( nX == nPeriodo ) )
				If nTotPer > nTolera
					nTotEve := Len(aTotEve)
					For nT:=1 To nTotEve
						If aTotEve[nT,ATOTAIS_DATA] >= dDtIni .and.aTotEve[nT,ATOTAIS_DATA] <= dData
							fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
										aTotEve[nT,ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
										aTotEve[nT,ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
										0									,;	//04 -> Valor para Soma ou Geracao
										aTotEve[nT,ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
										aTotEve[nT,ATOTAIS_CENTRO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
										SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9										
										NIL									,;	//08 -> Verba da Folha
										NIL									,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
										aTotEve[nT,ATOTAIS_FUNCAO]			,;	//10 -> Funcao para Comparacao 
										aTotEve[nT,ATOTAIS_DEPTO]			,;	//11 -> Depto  para Comparacao   
										aTotEve[nT,ATOTAIS_POSTO] 			,;	//12 -> Posto  para Comparacao   
										aTotEve[nT,ATOTAIS_PROCESSO]		,;	//13 -> Processo para Comparacao   
										aTotEve[nT,ATOTAIS_ROTEIRO]			,;	//14 -> Roteiro para Comparacao   
										aTotEve[nT,ATOTAIS_PERIODO]			,;	//15 -> Periodo para Comparacao   
										aTotEve[nT,ATOTAIS_NUM_PAGTO] 		;	//16 -> NumPagto para Comparacao  															
									)
						Endif
					Next nT
				EndIf
				dDtIni := dData
				nTotPer  := 0
			EndIf
		Next nX
	EndIf
EndIf

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ fCalcPHD  ³ Autor ³ Fernando Joly Siquini³ Data ³ 26/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula o Pagamento de horas e DSR com Tot. por Per¡odo.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ PONM070							   						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aTotAdiN = Array multidimencional com as Horas e DSR.      ³±±
±±³          ³ aTotais  = Array multidimencional com os Totais.           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalcPHD( aTotPgHD, aTotais, aTabPadrao , aTabCalend , lHorasTab , lMvAcmHExt , cPerHmov , cMsgErr )

Local aTabExtra		:= {}
Local aTabPHD   	:= {}
Local aTurnosPHD	:= {} 
Local cPeriodoHM	:= ""
Local cXCusto		:= ""
Local cXFuncao		:= "" 
Local cXDepto		:= ""
Local cXPosto		:= ""	
Local cXProcesso	:= "" 
Local cXRoteiro		:= ""
Local cXPeriodo		:= ""
Local cXNumPag		:= ""
Local dData     	:= Ctod("//")
Local dDtAfa		:= Ctod("//")
Local dDtRet		:= Ctod("//")
Local lRet			:= .T.
Local lAfasta		:= .F. 
Local nX        	:= 0
Local nPagaHRS  	:= 0
Local nPagaDSR  	:= 0
Local nQtdDSR   	:= 0
Local nTolHrs   	:= 0
Local nTolInt   	:= 0
Local nTotPer   	:= 0
Local nTolera   	:= 0
Local nTotal    	:= 0
Local nSaiAnt   	:= 0
Local nHExtras  	:= 0
Local nOneDSR   	:= 0
Local nPosCalend   	:= 0
Local nTotPgHD		:= 0
Local nTabPHD		:= 0
Local nPeriodo		:= 0

cPeriodoHM := cPerHmov

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Reinicializa as Statics em ToScheduleOverTime()			  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
RstToScheduleOverTime()

IF ( lHorasTab ) //So Monta Calendario Qdo. Horas/DSR for pela Tabela
	//-- Nao foi passado centro de custo como parametro para que CriaCalend()
	//-- nao apure as excecoes.
	IF !CriaCalend(	dDataIni	  								,;
					dDataFim	   								,;
					SRA->RA_TNOTRAB								,;
					fQualSeq(aTabCalend,aTabPadrao,dDataIni)	,;
					aTabPadrao									,;
					@aTabPHD									,;
					SRA->RA_FILIAL								,;
					SRA->RA_MAT									,;
					SRA->RA_CC									,;
					@aTurnosPHD									 ;
				   )
		//'Nao voi possivel Montar o Calendario para o Funcionario: '###'da Filial: '###'e Turno: '###'O Calculo Mensal nao foi efetuado para este funcionario.'
		SRA->( aAdd( aLogDet , STR0019 + " " + RA_MAT + " - " + AllTrim(RA_NOME) + " " + STR0014 + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB + ". " + STR0020 ) )
		Return( NIL )
	EndIF
	// Remonta Calendario de Acordo com fQualSeq() Caso Haja Troca de Turno no Periodo
	IF !Empty( aTurnosPHD )
		IF !CriaCalend(	dDataIni	  											,;
						dDataFim	   											,;
						SRA->RA_TNOTRAB											,;
						fQualSeq(@aTabPHD,aTabPadrao,dDataIni,aTurnosPHD[1,1])	,;
						aTabPadrao												,;
						@aTabPHD												,;
						SRA->RA_FILIAL											,;
						SRA->RA_MAT												,;
						SRA->RA_CC												,;
						aTurnosPHD									 			 ;
					   )
			//'Nao voi possivel Montar o Calendario para o Funcionario: '###'da Filial: '###'e Turno: '###'O Calculo Mensal nao foi efetuado para este funcionario.'
			SRA->( aAdd( aLogDet , STR0019 + " " + RA_MAT + " - " + AllTrim(RA_NOME) + " " + STR0014 + RA_FILIAL + " " + STR0015 + " " + RA_TNOTRAB + ". " + STR0020 ) )
			Return( NIL )
		EndIF
	EndIF
EndIF

If ( ( nTotPgHD := Len(aTotPgHD) ) > 0 )

	//-- Calcula Horas Trabalhadas e Pag. DSR de acordo com a Tabela
	nTabPHD := Len(aTabPHD)
	For nX := 1 To nTabPHD
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Soma Horas e DSR de Acordo com a Tabela                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( aTabPHD[nX, 4] == "1E" )
			dDtAfa := aTabPHD[ nX , CALEND_POS_INI_AFAST ]
			dDtRet := aTabPHD[ nX , CALEND_POS_FIM_AFAST ]
			IF (;
					( lAfasta := aTabPHD[ nX, CALEND_POS_AFAST ] );
					.and.;
					( aTabPHD[ nX , CALEND_POS_DATA ] >= dDtAfa );
					.and.;
					( aTabPHD[nX,CALEND_POS_DATA] <= IF( Empty( dDtRet ) , aTabPHD[nX,CALEND_POS_DATA] , dDtRet ) );
				)	
				Loop
			EndIF
			IF ( aTabPHD[nX,CALEND_POS_DATA] < fDtaAdmis() )
				Loop
			EndIF	
			IF (;
					(;
						( aTabPHD[nX,CALEND_POS_FERIADO] );
						.and.;
						( aTabPHD[nX,CALEND_POS_TIPO_DIA] != "S" );
					);
					.or.;
					( aTabPHD[nX,CALEND_POS_TIPO_DIA] == "D" );
				)	
				nQtdDSR ++
			EndIF
		EndIF
		IF (;
				( aTabPHD[nX,CALEND_POS_TIPO_DIA] == "S" );
				.and.;
				( aTabPHD[nX,CALEND_POS_DATA] >= fDtaAdmis() );
				.and.;
				!( lAfasta );
			)	
			IF ( Substr( aTabPHD[nX,CALEND_POS_TIPO_MARC] , -1 ) == "E" )
				nPagaHrs := aTabPHD[nX,CALEND_POS_HRS_TRABA]
				fGeraTot(	@aTotais																								,;	//01 -> Array com os Totais do Ponto
							aTabPHD[nX,CALEND_POS_DATA]																				,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							nPagaHrs																								,;	//03 -> Horas para Soma ou Geracao
							0																										,;	//04 -> Valor para Soma ou Geracao
							cPagaHrs																								,;	//05 -> Evento do Ponto para Pesquisa
							IF( !Empty(aTabPHD[nX,CALEND_POS_CC]),aTabPHD[nX,CALEND_POS_CC],SRA->RA_CC )							,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL																							,;	//07 -> Filial para Pesquisa no SP9
							NIL																										,;	//08 -> Verba da Folha
							NIL																										,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
							IF( !Empty(aTabPHD[nX,CALEND_POS_CODFUNC])	,aTabPHD[nX,CALEND_POS_CODFUNC]		,SRA->RA_CODFUNC )		,;	//10 -> Funcao para Comparacao															
							IF( !Empty(aTabPHD[nX,CALEND_POS_DEPTO])	,aTabPHD[nX,CALEND_POS_DEPTO]		,SRA->RA_DEPTO	 )		,;	//11 -> Depto  para Comparacao   
							IF( !Empty(aTabPHD[nX,CALEND_POS_POSTO])	,aTabPHD[nX,CALEND_POS_POSTO]		,SRA->RA_POSTO	 )		,;	//12 -> Posto  para Comparacao   
							IF( !Empty(aTabPHD[nX,CALEND_POS_PROCESSO])	,aTabPHD[nX,CALEND_POS_PROCESSO]	,oPeriodo:cProcesso )	,;	//13 -> Processo para Comparacao   
							IF( !Empty(aTabPHD[nX,CALEND_POS_ROTEIRO])	,aTabPHD[nX,CALEND_POS_ROTEIRO]		,oPeriodo:cRoteiro )	,;	//14 -> Roteiro para Comparacao   
							IF( !Empty(aTabPHD[nX,CALEND_POS_PERIODO])	,aTabPHD[nX,CALEND_POS_PERIODO]		,oPeriodo:cPeriodo	)	,;	//15 -> Periodo para Comparacao   
							IF( !Empty(aTabPHD[nX,CALEND_POS_NUM_PAGTO]),aTabPHD[nX,CALEND_POS_NUM_PAGTO]	,oPeriodo:cNumPagto )	;	//16 -> NumPagto para Comparacao  															
					)
			EndIF
		EndIF
	Next nX
	
	nOneDSR := Int(SRA->RA_HRSMES/30)
	nOneDSR += ((SRA->RA_HRSMES/30-Int(SRA->RA_HRSMES/30))*60)/100
	For nX := 1 to nQtdDSR
		nPagaDSR := __TimeSum(nPagaDSR, nOneDSR)
	Next nX

	If ( lHorasTab )
		fGeraTot(	@aTotais			,;	//01 -> Array com os Totais do Ponto
					dDataBase			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
					nPagaDSR			,;	//03 -> Horas para Soma ou Geracao
					0					,;	//04 -> Valor para Soma ou Geracao
					cPagaDSR			,;	//05 -> Evento do Ponto para Pesquisa
					SRA->RA_CC			,;	//06 -> Centro de Custo para Comparacao
					SRA->RA_FILIAL		,;	//07 -> Filial para Pesquisa no SP9  
					NIL					,;	//08 -> Verba da Folha
					NIL					,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
					SRA->RA_CODFUNC		,;	//10 -> Funcao para Comparacao	
					SRA->RA_DEPTO		,;	//11 -> Depto  para Comparacao   
					SRA->RA_POSTO 		,;	//12 -> Posto  para Comparacao   
					SRA->RA_PROCES		,;	//13 -> Processo para Comparacao   
					oPeriodo:cRoteiro	,;	//14 -> Roteiro para Comparacao   
					oPeriodo:cPeriodo	,;	//15 -> Periodo para Comparacao   
					oPeriodo:cNumPagto	;	//16 -> NumPagto para Comparacao  															
				)					
	ElseIf ( ( cPeriodoHM == "D" ) .and. !( lHorasTab ) )
		For nX := 1 To nTotPgHD
			fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
						aTotPgHD[nX,ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						aTotPgHD[nX,ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
						0									,;	//04 -> Valor para Soma ou Geracao
						aTotPgHD[nX,ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
						aTotPgHD[nX,ATOTAIS_CENTRO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9
						NIL									,;	//08 -> Verba da Folha
						NIL									,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
						aTotPgHD[nX,	ATOTAIS_FUNCAO]		,;  //10 -> Funcao Custo para Comparacao															
						aTotPgHD[nX,	ATOTAIS_DEPTO]		,;	//11 -> Depto  para Comparacao   
						aTotPgHD[nX,	ATOTAIS_POSTO] 		,;	//12 -> Posto  para Comparacao   
						aTotPgHD[nX,	ATOTAIS_PROCESSO]	,;	//13 -> Processo para Comparacao   
						aTotPgHD[nX,	ATOTAIS_ROTEIRO]	,;	//14 -> Roteiro para Comparacao   
						aTotPgHD[nX,	ATOTAIS_PERIODO]	,;	//15 -> Periodo para Comparacao   
						aTotPgHD[nX,	ATOTAIS_NUM_PAGTO] 	;	//16 -> NumPagto para Comparacao  															
					)
		Next nX
	Else
		nPeriodo := ( dPerFim - dPerIni )
		For nX := 0 To nPeriodo
			
			dData := ( dPerIni + nX )
			//-- Soma Horas Trabalhadas no Per¡odo
			aEval(aTotPgHD, {|x| If( ( x[ATOTAIS_DATA] == dData ) .and. ( x[ATOTAIS_EVENTO_PONTO]  == cPagaHrs ), nTotPer := __TimeSum( x[ATOTAIS_HORAS] , nTotPer ) , NIL ) } )

			//-- Soma Horas Previstas no Per¡odo
			If ( ( nPosCalend := aScan(aTabCalend, {|x| x[CALEND_POS_DATA] == dData .and.x[CALEND_POS_TIPO_MARC] == "1E" })) > 0 )
				If TipodeDia(aTabCalend[nPosCalend]) == "S" 
					cOrdem := aTabCalend[nPosCalend,CALEND_POS_ORDEM]
					//-- Soma as Horas Previstas Trabalhadas
					aEval(aTabCalend, { |x| If(x[CALEND_POS_ORDEM] == cOrdem .and. SubStr(x[CALEND_POS_TIPO_MARC],2,1) == "E", nTolHrs := __TimeSum(nTolHrs, x[CALEND_POS_HRS_TRABA]),NIL)})
					//-- Verifica todas as saidas e caso seja intervalo soma as horas
					aEval(aTabCalend, { |x| If(x[CALEND_POS_ORDEM] == cOrdem .and. SubStr(x[CALEND_POS_TIPO_MARC],2,1) == "S", nTolInt := __TimeSum(nTolInt, x[CALEND_POS_HRS_INTER]),NIL)})
				Endif
			EndIf
                            
			If (;
					( ( cPeriodoHM == "S" ) .and. ( Dow( dData ) == 1 ) );
					.or.;
					( ( cPeriodoHM == "Q" ) .and. ( nX == 14 ) );
					.or.;
					( ( cPeriodoHM $ "SQM" ) .and. ( nX == nPeriodo ) );
				)	

				nTolera := nTolHrs

				If ( nTotPer < nTolera )
					nSaiAnt		:= __TimeSum(nSaiAnt, __TimeSub(nTolera, nTotPer))
					nTotal		:= __TimeSum(nTotal, nTotPer)
				ElseIf ( nTotPer > nTolera )
					nHExtras	:= __TimeSum(nHExtras, __TimeSub(nTotPer, nTolera))
					nTotal		:= __TimeSum(nTotal, nTolera)
				Else
					nTotal		:= __TimeSum(nTotal, nTotPer)
				EndIf

				nTolHrs  := 0
				nTolInt	 := 0
				nTolDSR  := 0
				nTotPer  := 0

			EndIf

		Next nX

		//-- Gera Pag. DSR
		For nX := 1 To nTotPgHD
			If aTotPgHD[nX,ATOTAIS_EVENTO_PONTO] == cPagaDSR
				fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
							aTotPgHD[nX,ATOTAIS_DATA]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							aTotPgHD[nX,ATOTAIS_HORAS]			,;	//03 -> Horas para Soma ou Geracao
							0									,;	//04 -> Valor para Soma ou Geracao
							aTotPgHD[nX,ATOTAIS_EVENTO_PONTO]	,;	//05 -> Evento do Ponto para Pesquisa
							aTotPgHD[nX,ATOTAIS_CENTRO_DE_CUSTO]	,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9
							NIL									,;	//08 -> Verba da Folha
							NIL									,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
							aTotPgHD[nX,ATOTAIS_FUNCAO]			,;	//10 -> Centro de Custo para Comparacao															
							aTotPgHD[nX,ATOTAIS_DEPTO]			,;	//11 -> Depto  para Comparacao   
							aTotPgHD[nX,ATOTAIS_POSTO] 			,;	//12 -> Posto  para Comparacao   
							aTotPgHD[nX,ATOTAIS_PROCESSO]		,;	//13 -> Processo para Comparacao   
							aTotPgHD[nX,ATOTAIS_ROTEIRO]		,;	//14 -> Roteiro para Comparacao   
							aTotPgHD[nX,ATOTAIS_PERIODO]		,;	//15 -> Periodo para Comparacao   
							aTotPgHD[nX,ATOTAIS_NUM_PAGTO]		;	//16 -> NumPagto para Comparacao  							
						)
			EndIf
		Next nX

		//-- Procura o Centro de Custo / Funcao  / etc Correspondente na Data
		IF ( ( nPosCalend := aScan( aTabCalend, {|x| x[CALEND_POS_DATA] == dData .and.x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0 )
			cXCusto 	:= If ( Empty( aTabCalend[nPosCalend,CALEND_POS_CC] )		, SRA->RA_CC		, aTabCalend[nPosCalend,CALEND_POS_CC] )
			cXFuncao	:= If ( Empty( aTabCalend[nPosCalend,CALEND_POS_CODFUNC] )	, SRA->RA_CODFUNC	, aTabCalend[nPosCalend,CALEND_POS_CODFUNC] )
			cXDepto		:= If ( Empty( aTabCalend[nPosCalend,CALEND_POS_DEPTO] )	, SRA->RA_DEPTO		, aTabCalend[nPosCalend,CALEND_POS_DEPTO] )
			cXPosto		:= If ( Empty( aTabCalend[nPosCalend,CALEND_POS_POSTO] )	, SRA->RA_POSTO		, aTabCalend[nPosCalend,CALEND_POS_POSTO] )
			cXProcesso	:= If ( Empty( aTabCalend[nPosCalend,CALEND_POS_PROCESSO] )	, SRA->RA_PROCES	, aTabCalend[nPosCalend,CALEND_POS_PROCESSO] )			
			cXRoteiro	:= If ( Empty( aTabCalend[nPosCalend,CALEND_POS_ROTEIRO] )	, oPeriodo:cRoteiro	, aTabCalend[nPosCalend,CALEND_POS_ROTEIRO] )
			cXPeriodo	:= If ( Empty( aTabCalend[nPosCalend,CALEND_POS_PERIODO] )	, oPeriodo:cPeriodo	, aTabCalend[nPosCalend,CALEND_POS_PERIODO] )
			cXNumPagto	:= If ( Empty( aTabCalend[nPosCalend,CALEND_POS_NUM_PAGTO])	, oPeriodo:cNumPagto, aTabCalend[nPosCalend,CALEND_POS_NUM_PAGTO] )
		Else
			cXCusto 	:= SRA->RA_CC
			cXFuncao	:= SRA->RA_CODFUNC
			cXDepto		:= SRA->RA_DEPTO
			cXProcesso	:= SRA->RA_PROCES
			cXRoteiro	:= oPeriodo:cRoteiro
			cXPeriodo	:= oPeriodo:cPeriodo
			cXNumpagto	:= oPeriodo:cNumPagto
		EndIF

		//-- Gera Horas
		fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
					dData								,;	//02 -> Data para Pesquisa e Gravacao no aTotais
					nTotal								,;	//03 -> Horas para Soma ou Geracao
					0									,;	//04 -> Valor para Soma ou Geracao
					cPagaHrs							,;	//05 -> Evento do Ponto para Pesquisa
					cXCusto								,;	//06 -> Centro de Custo para Comparacao
					SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9
					NIL									,;	//08 -> Verba da Folha
					NIL									,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
					cXFuncao							,;	//10 -> Funcao para Comparacao															
					cXDepto								,;	//11 -> Depto  para Comparacao   
					cXPosto 							,;	//12 -> Posto  para Comparacao   
					cXProcesso							,;	//13 -> Processo para Comparacao   
					cXRoteiro							,;	//14 -> Roteiro para Comparacao   
					cXPeriodo							,;	//15 -> Periodo para Comparacao   
					cXNumPagto	 						;	//16 -> NumPagto para Comparacao  					
				)

		//-- Gera Saidas Antecipadas
		If ( nSaiAnt > 0 )
			fGeraTot(	@aTotais							,;	//01 -> Array com os Totais do Ponto
						dData								,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						nSaiAnt								,;	//03 -> Horas para Soma ou Geracao
						0									,;	//04 -> Valor para Soma ou Geracao
						cSaiAnte							,;	//05 -> Evento do Ponto para Pesquisa
						cXCusto								,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL						,;	//07 -> Filial para Pesquisa no SP9  
						NIL									,;	//08 -> Verba da Folha
						NIL									,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
						cXFuncao							,;	//10 -> Funcao para Comparacao															
						cXDepto								,;	//11 -> Depto  para Comparacao   
						cXPosto 							,;	//12 -> Posto  para Comparacao   
						cXProcesso							,;	//13 -> Processo para Comparacao   
						cXRoteiro							,;	//14 -> Roteiro para Comparacao   
						cXPeriodo							,;	//15 -> Periodo para Comparacao   
						cXNumPagto							;	//16 -> NumPagto para Comparacao  					
					)
		EndIf

		//-- Gera Horas Extras
		IF ( nHExtras > 0 )
			IF ( nPosCalend > 0 )
				//-- Carrega tabela de Horas Extras / Horas Extras Noturnas
				IF ( lRet := GetTabExtra( @aTabExtra , SRA->RA_FILIAL , aTabCalend[ nPosCalend , CALEND_POS_TURNO ] , .F. , .T. , NIL , NIL , @cMsgErr ) )
					fGeraExtra(;
									aTabExtra,;
									"1",;
									nHExtras,;
									0,;
									{},;
									@aTotais,;
									dData,;
									"FEC",;
									NIL,;
									NIL,;
									cXCusto,;
									NIL,;
									lMvAcmHExt,;
									NIL,;  
									cXFuncao							,;	//15 -> Funcao para Comparacao															
									cXDepto								,;	//16 -> Depto  para Comparacao   
									cXPosto 							,;	//17 -> Posto  para Comparacao   
									cXProcesso							,;	//18 -> Processo para Comparacao   
									cXRoteiro							,;	//19 -> Roteiro para Comparacao   
									cXPeriodo							,;	//20--> Periodo para Comparacao   
									cXNumPagto							;	//21 -> NumPagto para Comparacao  					
								)
				EndIF	
			EndIF
		EndIF
		
	EndIf
EndIf

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fCalcHExt³Autor³Fernando Joly Siquini 1a.Ver³Data³02/02/1998³±±
±±³          ³         ³Autor³Marinaldo de Jesus    2a.Ver³Data³22/07/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Calcula o Pagamento de Horas Extras com Tot. por Per¡odo.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³PONM070							       					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³lRet                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³<Vide Parametros Formais>									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalcHExt(	dPerIni 	,;
							dPerFim		,;
							aTotHExt	,;
							aTotHENt	,;
							aTotais		,;
							aTabCalend	,;
							aCodAut		,;
							lMvAcmHExt	,;
							cPerHext	,;
							nTolHePe	,;
							cMsgErr		 ;
						   )

Local lRet	:= .T.

Local aTabExtra
Local aExtAllTipos
Local aExtTipo
Local aCodTipos

Local bBlkSorTot
Local bBlkAscData
Local bBlkAscCale
Local bBlkAscNData
Local bBlkAscNEven
Local bBlkAscNtData
Local bBlkAscNtEven

Local cTpoExtra
Local cStrTipos
Local cLastTpoExtra
Local cMemVarTpHe

Local dData

Local nLoop
Local nLoopTipo
Local nTipo
Local nCodAut
Local nCodsAut
Local nLenTipo
Local nTipDiurna
Local nTipNoturna
Local nPosTipo
Local nPosCalend
Local nPosData
Local nTolHExt
Local nPeriodo

Begin Sequence

	bBlkSorTot := { |x,y|	( 	x[ ATOTAIS_DTOS_DATA 		] 	+ ;
								x[ ATOTAIS_EVENTO_PONTO 	] 	+ ;
								x[ ATOTAIS_CENTRO_DE_CUSTO 	] 	+ ;
								x[ ATOTAIS_FUNCAO 			] 	+ ;
								x[ ATOTAIS_DEPTO  			] 	+ ;
								x[ ATOTAIS_POSTO  			] 	+ ;
								x[ ATOTAIS_PROCESSO			] 	+ ;
								x[ ATOTAIS_ROTEIRO 			] 	+ ;
								x[ ATOTAIS_PERIODO			] 	+ ;																
								x[ ATOTAIS_NUM_PAGTO		] 	  ;																								
							);
	 						<;
	 						( 	y[ ATOTAIS_DTOS_DATA 		] 	+ ;
	 							y[ ATOTAIS_EVENTO_PONTO 	] 	+ ;
	 							Y[ ATOTAIS_CENTRO_DE_CUSTO 	] 	+ ;
	 							Y[ ATOTAIS_FUNCAO 			]	+ ;
								Y[ ATOTAIS_DEPTO  			] 	+ ;
								Y[ ATOTAIS_POSTO  			] 	+ ;
								Y[ ATOTAIS_PROCESSO			] 	+ ;
								Y[ ATOTAIS_ROTEIRO 			] 	+ ;
								Y[ ATOTAIS_PERIODO			] 	+ ;																
								Y[ ATOTAIS_NUM_PAGTO		] 	  ;																								
	 						);
	 			  }

	aSort( aTotHExt , NIL , NIL , bBlkSorTot )
	aSort( aTotHENt , NIL , NIL , bBlkSorTot )

	IF ( cPerHext == "D" )

		nTipDiurna	:= Len( aTotHExt )
		nTipNoturna := Len( aTotHENt )

		For nTipo := 1 To nTipDiurna
			
			fGeraTot(	@aTotais									,;	//01 -> Array com os Totais do Ponto
						aTotHExt[ nTipo , ATOTAIS_DATA ]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						aTotHExt[ nTipo , ATOTAIS_HORAS ]			,;	//03 -> Horas para Soma ou Geracao
						0											,;	//04 -> Valor para Soma ou Geracao
						aTotHExt[ nTipo , ATOTAIS_EVENTO_PONTO ]	,;	//05 -> Evento do Ponto para Pesquisa
						aTotHExt[ nTipo , ATOTAIS_CENTRO_DE_CUSTO ]	,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL							 	,;	//07 -> Filial para Pesquisa no SP9
						NIL											,;	//08 -> Verba da Folha
						NIL											,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
						aTotHExt[ nTipo , ATOTAIS_FUNCAO		]	,;	//10 -> Funcao para Comparacao	 
						aTotHExt[ nTipo , ATOTAIS_DEPTO			]	,;	//11 -> Depto  para Comparacao   
						aTotHExt[ nTipo , ATOTAIS_POSTO			]	,;	//12 -> Posto  para Comparacao   
						aTotHExt[ nTipo , ATOTAIS_PROCESSO		]	,;	//13 -> Processo para Comparacao   
						aTotHExt[ nTipo , ATOTAIS_ROTEIRO		]	,;	//14 -> Roteiro para Comparacao   
						aTotHExt[ nTipo , ATOTAIS_PERIODO		]	,;	//15 -> Periodo para Comparacao   
						aTotHExt[ nTipo , ATOTAIS_NUM_PAGTO 	]	;	//16 -> NumPagto para Comparacao  					
					)																										
		
		Next nTipo

		For nTipo := 1 To nTipNoturna
	
			fGeraTot(	@aTotais									,;	//01 -> Array com os Totais do Ponto
						aTotHENt[ nTipo , ATOTAIS_DATA ]			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
						aTotHENt[ nTipo , ATOTAIS_HORAS ]			,;	//03 -> Horas para Soma ou Geracao
						0											,;	//04 -> Valor para Soma ou Geracao
						aTotHENt[ nTipo , ATOTAIS_EVENTO_PONTO ]	,;	//05 -> Evento do Ponto para Pesquisa
						aTotHENt[ nTipo , ATOTAIS_CENTRO_DE_CUSTO ]	,;	//06 -> Centro de Custo para Comparacao
						SRA->RA_FILIAL							 	,;	//07 -> Filial para Pesquisa no SP9
						NIL											,;	//08 -> Verba da Folha
						NIL											,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
						aTotHENt[ nTipo , ATOTAIS_FUNCAO		]	,;	//10 -> Funcao para Comparacao	 
						aTotHENt[ nTipo , ATOTAIS_DEPTO			]	,;	//11 -> Depto  para Comparacao   
						aTotHENt[ nTipo , ATOTAIS_POSTO			]	,;	//12 -> Posto  para Comparacao   
						aTotHENt[ nTipo , ATOTAIS_PROCESSO		]	,;	//13 -> Processo para Comparacao   
						aTotHENt[ nTipo , ATOTAIS_ROTEIRO		]	,;	//14 -> Roteiro para Comparacao   
						aTotHENt[ nTipo , ATOTAIS_PERIODO		]	,;	//15 -> Periodo para Comparacao   
						aTotHENt[ nTipo , ATOTAIS_NUM_PAGTO 	]	;	//16 -> NumPagto para Comparacao  					
					)
		
		Next nTipo
		
		Break
	
	EndIF

	aCodTipos		:= {}
	aExtAllTipos	:= {}

	bBlkAscData		:= { |x| ( x[ ATOTAIS_DATA ] == dData ) }
	bBlkAscCale		:= { |x| ( x[CALEND_POS_DATA] == dData ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) }
	bBlkAscNData	:= { |x| ( ( dData == x[5] ) .and. ( aTotHExt[ nPosData , ATOTAIS_EVENTO_PONTO ] $ x[2] ) ) }
	bBlkAscNEven	:= { |x| ( aTotHExt[ nPosData , ATOTAIS_EVENTO_PONTO ] $ x[2] ) }
	bBlkAscNtData	:= { |x| ( ( dData == x[5] ) .and. ( aTotHENt[ nPosData , ATOTAIS_EVENTO_PONTO ] $ x[2] ) ) }
	bBlkAscNtEven	:= { |x| ( aTotHENt[ nPosData , ATOTAIS_EVENTO_PONTO ] $ x[2] ) }

	cTpoExtra		:= "__cTpoExtra__"
	cLastTpoExtra	:= "__cLastTpoExtra__"

	nTolHExt		:= nTolHePe
	nCodsAut		:= Len( aCodAut )
	nPeriodo		:= ( dPerFim - dPerIni )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Reinicializa as Statics em ToScheduleOverTime()			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RstToScheduleOverTime()

	For nLoop := 0 To nPeriodo

		dData		:= ( dPerIni + nLoop )
		
		//-- Carrega Tabela de Horas Extras para o Turno da Data
		IF ( ( nPosCalend := aScan( aTabCalend, bBlkAscCale ) ) > 0 )
			IF !( lRet := GetTabExtra( @aTabExtra , SRA->RA_FILIAL , aTabCalend[ nPosCalend , CALEND_POS_TURNO ] , .F. , .T. , NIL , NIL , @cMsgErr ) )
				Break
			EndIF
		EndIF
		
		cStrTipos	:= fTpoExtra( dData , aClone( aTabCalend ) )
		/*/Acrescenta os tipos de hora extra de intervalo, 
		para serem calculadas as horas extras de intervalo/*/
		cStrTipos += "-"+GetTpExInt( SubStr( cStrTipos,1,1 ) , .F. ) + "-" + GetTpExInt( SubStr( cStrTipos,3,1 ), .T. )
		//Corre Cada um dos Tipos Presentes na string cStrTipos. Ex. '5-1-A-B' 
		For nLoopTipo := 1 To 7 Step 2
		    //Obtem o Tipo de Hora Extra. Ex. '5' na primeira vez e '1' no segundo laco.
		    cTpoExtra:= Substr(cStrTipos,nLoopTipo,1)
		    
				// Cria a Variavel acumuladora do Tipo de HE
				cMemVarTpHe := ( "nHETp" + cTpoExtra )
				IF !IsMemVar( cMemVarTpHe )
					SetMemVar( cMemVarTpHe , 0 , .T. )
				EndIF

				//-- Obtem todas as Faixas de HE do Tipo Lido
				aExtTipo := GetExTipo( aTabExtra , cTpoExtra )
				aAdd( aExtAllTipos , { cTpoExtra , aClone( aExtTipo ) } )
				nLenTipo := Len( aExtTipo )
				IF !( lRet := ( nLenTipo > 0 ) )
					Break
				EndIF
								
				//-- Corre Cada Faixa 
				For nTipo := 1 To nLenTipo
					//-- Gera Informacoes Adicionais para cada faixa 	
					IF ( ( nPosTipo := aScan( aCodTipos , { |x| ( x[1] == aExtTipo[ nTipo , 1 ] ) .and. ( x[5] == dData ) } ) ) == 0 )
						aAdd( aCodTipos , { aExtTipo[ nTipo , 1 ] , "" , {} , aClone( aTabExtra ) , dData } )
						nPosTipo := Len( aCodTipos )
					EndIF
				    //-- Obtem todos os codigos de HE para o Tipo Lido
					For nCodAut := 1 To nCodsAut  
						If ( Ascan(aCodAut[ nCodAut , 14 ], aExtTipo[ nTipo , 1 ] ) <> 0 )
					 		IF !( aCodAut[ nCodAut , 1 ] $ aCodTipos[ nPosTipo , 2 ] )
					 			aCodTipos[ nPosTipo , 2 ] += ( aCodAut[ nCodAut , 1 ] + "/"  )
					 		EndIF
					 	EndIF
					Next nCodAut
				Next nTipo
		Next nLoopTipo        

		nPosData := 0
		While ( ( nPosData := aScan( aTotHExt , bBlkAscData , ++nPosData ) ) > 0 )
			IF ( ( nPosTipo := aScan( aCodTipos , bBlkAscNData ) ) == 0 )
				IF ( ( nPosTipo := aScan( aCodTipos , bBlkAscNEven ) ) == 0 )
					Loop
				EndIF
			EndIF
			cMemVarTpHe := ( "nHETp" + aCodTipos[ nPosTipo , 1 ] )
			SetMemVar( cMemVarTpHe , __TimeSum( GetMemVar( cMemVarTpHe ) , aTotHExt[ nPosData , ATOTAIS_HORAS ] ) )
			aAdd( aCodTipos[ nPosTipo , 3 ] , ;
											{ aTotHExt[ nPosData , ATOTAIS_HORAS 			]	,;	//01
											  aTotHExt[ nPosData , ATOTAIS_CENTRO_DE_CUSTO 	]	,;	//02
											  aTotHExt[ nPosData , ATOTAIS_DATA 			]	,;	//03
											  aTotHExt[ nPosData , ATOTAIS_FUNCAO			]	,;	//04
											  aTotHExt[ nPosData , ATOTAIS_DEPTO 			]	,;	//05
											  aTotHExt[ nPosData , ATOTAIS_POSTO			]	,;	//06
											  aTotHExt[ nPosData , ATOTAIS_PROCESSO			]	,;	//07
											  aTotHExt[ nPosData , ATOTAIS_ROTEIRO			]	,;	//08
											  aTotHExt[ nPosData , ATOTAIS_PERIODO			]	,;	//09
											  aTotHExt[ nPosData , ATOTAIS_NUM_PAGTO		]	;	//10
											  } )
		End While

		nPosData := 0
		While ( ( nPosData := aScan( aTotHENt , bBlkAscData , ++nPosData ) ) > 0 )
			IF ( ( nPosTipo := aScan( aCodTipos , bBlkAscNtData ) ) == 0 )
				IF ( ( nPosTipo := aScan( aCodTipos , bBlkAscNtEven ) ) == 0 )
					Loop
				EndIF
			EndIF
			cMemVarTpHe := ( "nHETp" + aCodTipos[ nPosTipo , 1 ] )
			SetMemVar( cMemVarTpHe , __TimeSum( GetMemVar( cMemVarTpHe ) , aTotHENt[ nPosData , ATOTAIS_HORAS ] ) )
			aAdd( aCodTipos[ nPosTipo , 3 ] , ;
											{ aTotHENt[ nPosData , ATOTAIS_HORAS 			]	,;	//01
											  aTotHENt[ nPosData , ATOTAIS_CENTRO_DE_CUSTO 	]	,;	//02
											  aTotHENt[ nPosData , ATOTAIS_DATA 			]	,;	//03
											  aTotHENt[ nPosData , ATOTAIS_FUNCAO			]	,;	//04
											  aTotHENt[ nPosData , ATOTAIS_DEPTO 			]	,;	//05
											  aTotHENt[ nPosData , ATOTAIS_POSTO			]	,;	//06
											  aTotHENt[ nPosData , ATOTAIS_PROCESSO			]	,;	//07
											  aTotHENt[ nPosData , ATOTAIS_ROTEIRO			]	,;	//08
											  aTotHENt[ nPosData , ATOTAIS_PERIODO			]	,;	//09
											  aTotHENt[ nPosData , ATOTAIS_NUM_PAGTO		]	; 	//10
											  } )											
		End While

		IF (;
				(;
						( cPerHext == "S" );
						.and.;
						( Dow( dData ) == 1 );
				);
				.or.;
				(;
						( cPerHext == "Q" );
						.and.;
						( nLoop == 14 );
				);
				.or.;
				(;
						( cPerHext $ "SQM" );
						.and.;
						( nLoop == nPeriodo );
				);
			)
	
			IF !( lRet := fGerHExt(;
										dData			,;
										@aTotais		,;
										aExtAllTipos	,;
										aCodTipos		,;
										nTolHExt		,;
										aTabCalend		,;
										lMvAcmHExt		,;
										cPerHext		 ;
									);
				)
				Break
			EndIF

		EndIF
	
	Next nLoop

End Sequence
	
Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fGerHExt ³Autor³Marinaldo de Jesus          ³Data³22/07/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Efetua a Geracao de Horas Extras com Tot. por Per¡odo.   	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso  	 ³fCalcHExt() no PONM070			       					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³lRet                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³<Vide Parametros Formais>									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fGerHExt(	dData			,;
							aTotais 		,;
							aExtAllTipos	,;
							aCodTipos		,;
							nTolHExt		,;
							aTabCalend		,;
							lMvAcmHExt		,;
							cPerHext		 ;
						)

Local lRet := .T.

Local aTabExtra

Local cXCusto
Local cAuxCusto
Local cXFuncao
Local cAuxFuncao
Local cXDepto
Local cAuxDepto
Local cXPosto
Local cAuxPosto
Local cXProceso
Local cAuxProcesso

Local cAuxRoteiro
Local cAuxPeriodo
Local cAuxNumPagto

Local cMemVarTpHe

Local nPosCalend
Local nTipo
Local nTipos
Local nHrCc
Local nHrCcs

Local uRetBlock

Begin Sequence

	IF ( ( nPosCalend := aScan( aTabCalend, {|x| ( x[CALEND_POS_DATA] == dData ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } ) ) > 0 )
		cAuxCusto 	:= aTabCalend[ nPosCalend , CALEND_POS_CC 		]
		cAuxFuncao	:= aTabCalend[ nPosCalend , CALEND_POS_CODFUNC 	]
		cAuxDepto	:= aTabCalend[ nPosCalend , CALEND_POS_DEPTO 	]
		cAuxPosto	:= aTabCalend[ nPosCalend , CALEND_POS_POSTO 	]
		cAuxProcesso:= aTabCalend[ nPosCalend , CALEND_POS_PROCESSO ]
		cAuxRoteiro	:= aTabCalend[ nPosCalend , CALEND_POS_ROTEIRO 	]								
		cAuxPeriodo	:= aTabCalend[ nPosCalend , CALEND_POS_PERIODO 	]								
		cAuxNumPagto:= aTabCalend[ nPosCalend , CALEND_POS_NUM_PAGTO]												
		IF Empty( cAuxCusto )
			cAuxCusto := SRA->RA_CC
		EndIF
		IF Empty( cAuxFuncao )
			cAuxFuncao := SRA->RA_CODFUNC
		EndIF
		IF Empty( cAuxDepto )
			cAuxDepto := SRA->RA_DEPTO
		EndIF
		IF Empty( cAuxPosto )
			cAuxPosto := SRA->RA_POSTO
		EndIF
		IF Empty( cAuxProcesso )
			cAuxProcesso := SRA->RA_PROCES
		EndIF
		IF Empty( cAuxRoteiro )
			cAuxRoteiro := oPeriodo:cRoteiro
		EndIF								
		IF Empty( cAuxPeriodo )
			cAuxPeriodo := oPeriodo:cPeriodo
		EndIF								
		IF Empty( cAuxNumpagto )
			cAuxNumPagto := oPeriodo:cNumPagto
		EndIF												
	EndIF

	IF ( lPoncalHeBlock )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³O Ponto de Entrada PONCALHE recebera como parametro o ParamIxb que eh um Ar³
		³ray com tres Elementos,sendo o Primeiro o Clone do Array aCodTipos, o    Se³
		³gundo o Clone do Array aTabCalend o Terceiro o Clone o Array aExtAllTipos. ³
		³Estarao disponiveis tambem as variaveis Privates nHetp? onde ?  corresponde³
		³aos tipos de Horas Extras 1, 2, 3, 4, 5,...A,B....					        ³
		³													  						³
		³Para Visualiza-los no Ponto de Entrada proceder da seguinte forma:			³
		³															  				³
		³User Function PonCalHe()									  				³
		³															  				³
		³Local __aCodTipos		:= aClone( ParamIxb[1] )				  			³
		³Local __aTabCalend 	:= aClone( ParamIxb[2] )				  			³
		³Local __aExtAllTipos	:= aClone( ParamIxb[3] )				  			³
		³Local cMemVarTpHe                             					  			³
		³Local nLoop                                  					  			³
		³Local nLoops                                  					  			³
		³Local nTipo                                  					  			³
		³Local nTipos                                  					  			³
		³...														  				³
		³//Verificando se as Variaveis Privates estao disponiveis					³
		³nTipos := Len( __aExtAllTipos )							  				³
		³For nTipo := 1 To nTipos									  				³
		³   nLoops := Len( __aExtAllTipos )											³
		³   For nLoop := 1 To nLoops								  				³
		³		cMemVarTpHe := ( "nHETp" + __aExtAllTipos[ nTipo , nLoop , 1 ] )	³
		³		SetMemVar( cMemVarTpHe , 0 )										³
		³	Next nLoop												  				³
		³Next nTipo													  				³
		³...															  			³
		³Return( aClone( __aCodTipos ) )				  				  			³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		uRetBlock := ExecBlock(;
									"PONCALHE",;
									.F.,;
									.F.,;
									{;
										aClone( aCodTipos 		),;
										aClone( aTabCalend 		),;
										aClone( aExtAllTipos	);
									},;
									.F.;
				 				)
		IF ( ValType( uRetBlock ) == "A" )
			aCodTipos := aClone( uRetBlock )
		EndIF
	EndIF

	nTipos := Len( aCodTipos )
	For nTipo := 1 To nTipos
		nHrCcs := Len( aCodTipos[ nTipo , 3 ] )
		For nHrCc := 1 To nHrCcs
			cMemVarTpHe := ( "nHETp" + aCodTipos[ nTipo , 1 ] )
			IF ( GetMemVar( cMemVarTpHe ) > nTolHExt )
				cXCusto		:= IF( Empty( aCodTipos[ nTipo , 3 , nHrCc , 2 ] ) , cAuxCusto 		, aCodTipos[ nTipo , 3 , nHrCc , 2 ] )
				cXFuncao	:= IF( Empty( aCodTipos[ nTipo , 3 , nHrCc , 4 ] ) , cAuxFuncao		, aCodTipos[ nTipo , 3 , nHrCc , 4 ] )
				cXDepto		:= IF( Empty( aCodTipos[ nTipo , 3 , nHrCc , 5 ] ) , cAuxDepto		, aCodTipos[ nTipo , 3 , nHrCc , 5 ] )				
				cXPosto		:= IF( Empty( aCodTipos[ nTipo , 3 , nHrCc , 6 ] ) , cAuxPosto		, aCodTipos[ nTipo , 3 , nHrCc , 6 ] )				
				cXProcesso	:= IF( Empty( aCodTipos[ nTipo , 3 , nHrCc , 7 ] ) , cAuxProcesso	, aCodTipos[ nTipo , 3 , nHrCc , 7 ] )				
				cXRoteiro	:= IF( Empty( aCodTipos[ nTipo , 3 , nHrCc , 8 ] ) , cAuxRoteiro	, aCodTipos[ nTipo , 3 , nHrCc , 8 ] )				
				cXPeriodo	:= IF( Empty( aCodTipos[ nTipo , 3 , nHrCc , 9 ] ) , cAuxPeriodo	, aCodTipos[ nTipo , 3 , nHrCc , 9 ] )				
				cXNumPagto	:= IF( Empty( aCodTipos[ nTipo , 3 , nHrCc , 10] ) , cAuxNumPagto	, aCodTipos[ nTipo , 3 , nHrCc , 10] )				

				fGeraExtra(;
								aCodTipos[ nTipo , 4 ],;
								aCodTipos[ nTipo , 1 ],;
								aCodTipos[ nTipo , 3 , nHrCc , 1 ],;
								0,;
								{},;
								@aTotais,;
								dData,;
								"FEC",;
								cPerHext,;
								!( lMvAcmHExt ),;
								cXCusto,;
								NIL,;
								lMvAcmHExt,;
								lMvAcmHExt,;            
								cXFuncao							,;	//15 -> Funcao para Comparacao															
								cXDepto								,;	//16 -> Depto  para Comparacao   
								cXPosto 							,;	//17 -> Posto  para Comparacao   
								cXProcesso							,;	//18 -> Processo para Comparacao   
								cXRoteiro							,;	//19 -> Roteiro para Comparacao   
								cXPeriodo							,;	//20--> Periodo para Comparacao   
								cXNumPagto							;	//21 -> NumPagto para Comparacao  					
							)
			EndIF
		Next nHrCc
		aCodTipos[ nTipo , 3 ] := {}
	Next nTipo

	nTipos := Len( aExtAllTipos )
	For nTipo := 1 To nTipos
		aEval( aExtAllTipos[ nTipo , 2 ] , { |x| SetMemVar( ( "nHETp" + x[ 1 ] ) , 0 ) } )
	Next nTipo

End Sequence

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fCalRefeit ³ Autor ³ Equipe Advanced RH   ³ Data ³ 10/02/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula as refei‡”es do Funcion rio.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ PONM070							   						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cFil     = String com a Filial do Funcion rio.             ³±±
±±³          ³ cMat     = String com a Matricula do Funcion rio.          ³±±
±±³          ³ aTotais  = Array multidimencional com os Totais.           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalRefeit( cFil , cMat , aTotais , aCodRef )

Local nPos	:= 0

DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT aTotais 	:= {}
DEFAULT aCodRef 	:= {}

//-- Posiciona no Inicio das Marcacoes de Refeicao do Funcionario
IF SP5->( dbSeek( cFil + cMat, .F.) )
    
	//-- Corre Marcacoes Refeicao para a Matricula Lida
	While ( SP5->( !Eof() .and. ( cFil + cMat ) == ( P5_FILIAL + P5_MAT ) ) )
	
		//-- Verifica se marcacao esta Dentro do periodo 
		IF SP5->( ( P5_DATA < dPerIni ) .or. ( P5_DATA > dPerFim ) )
		   SP5->( dbSkip() )
		   Loop
		EndIF
   	
   	    //-- Verifica se Tipo de Refeicao esta Dentro do Intervalo de Tipos Escolhido
		IF SP5->(;
					( P5_TIPOREF < cTipoRefDe );
					.or.;
					( P5_TIPOREF > cTipoRefAte );
					.or.;
				 	(;
				 		( P5_HORA == 0 );
				 		.and.;
				 		( P5_VALREF == 0 );
				 	);
				 )
		   SP5->( dbSkip() )
		   Loop
		EndIF

		IF ( SP5->P5_GERAFOL ==	"S" )
		    //Calcula Desc.Refeicao Parte Funcionario 
			nPos := fGeraTot(	@aTotais		,;	//01 -> Array com os Totais do Ponto
								SP5->P5_DATA	,;	//02 -> Data para Pesquisa e Gravacao no aTotais
								1				,;	//03 -> Horas para Soma ou Geracao
								SP5->P5_DESCFUN	,;	//04 -> Valor para Soma ou Geracao
								SP5->P5_PD		,;	//05 -> Evento do Ponto para Pesquisa
								SP5->P5_CC		,;	//06 -> Centro de Custo para Comparacao
								SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9
								NIL				,;	//08 -> Verba da Folha
								NIL				,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
								SP5->P5_CODFUNC ,;	//10 -> Funcao para Comparacao 
								SP5->P5_DEPTO	,;	//11 -> Depto 
								SP5->P5_POSTO	,;	//12 -> Posto  
								SP5->P5_PROCES	,;	//13 -> Processo
								SP5->P5_ROTEIR	,;	//14 -> Roteiro
								SP5->P5_PERIODO	,;	//15 -> Periodo
								SP5->P5_NUMPAG	;	//16 -> NumPagto																							
							)
			IF ( ( nPos > 0 ) .and.( aScan( aCodRef , { |x| x == aTotais[ nPos , 04 ] } ) == 0 ) )
				aAdd( aCodRef , aTotais[ nPos , 04 ] )
			EndIF
		EndIF
		 
		//-- Calcula Desc.Refeicao Parte Empresa
		nPos := fGeraTot(	@aTotais						,;	//01 -> Array com os Totais do Ponto
							SP5->P5_DATA					,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							1								,;	//03 -> Horas para Soma ou Geracao
							SP5->( P5_VALREF - P5_DESCFUN )	,;	//04 -> Valor para Soma ou Geracao
							SP5->P5_PDEMPR					,;	//05 -> Evento do Ponto para Pesquisa
							SP5->P5_CC						,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL	 				,;	//07 -> Filial para Pesquisa no SP9
							NIL								,;	//08 -> Verba da Folha
							NIL								,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
							SP5->P5_CODFUNC 				,;	//10 -> Funcao para Comparacao 
							SP5->P5_DEPTO					,;	//11 -> Depto 
							SP5->P5_POSTO					,;	//12 -> Posto  
							SP5->P5_PROCES					,;	//13 -> Processo
							SP5->P5_ROTEIR					,;	//14 -> Roteiro
							SP5->P5_PERIODO					,;	//15 -> Periodo
							SP5->P5_NUMPAG					;	//16 -> NumPagto																							
						)
		IF ( ( nPos > 0 ) .and.aScan( aCodRef , { |x| x == aTotais[ nPos , 04 ] } ) == 0 )
			aAdd( aCodRef , aTotais[ nPos , 04 ] )
		EndIF

		SP5->( dbSkip() )

	End While
	
EndIF

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fCalcBH    ³ Autor ³ Aldo Marini Junior   ³ Data ³ 20/11/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula os Eventos para Banco de Horas                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ PONM070				             						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³ Nil                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aTotais  = Array multidimencional com os Totais.           ³±±
±±³          ³ aBHAcum  = Array multidimencional com os Totais p/B.Horas  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCalcBH(aTotais,aBHAcum)

Local aRetBlock		:= {}
Local aTotAux		:= {}
Local aAux			:= {}

Local cPerApur		:= "D"

Local dDatIni		:= Ctod("//")

Local lAcumBH		:= .F.
Local lPositivo		:= .F.
Local lAgrup		:= .F.

Local nPosBH		:= 0
Local nT			:= 0
Local nB			:= 0
Local nCt			:= 0
Local nPosE			:= 0
Local nValBH		:= 0
Local nValHoras		:= 0
Local nTBHoras		:= 0
Local nPos			:= 0
Local nValCalcB		:= 0
Local nValCalcF		:= 0
Local nT1			:= 0
Local nLenEveBh		:= 0
Local nLenBhAcum	:= 0
Local nTotais		:= 0
Local nAux			:= 0
Local nEveBH		:= 0
Local nPeriodo		:= 0
Local nX			:= 0

Private aEveBh	:= {}

// Ordena o array por Evento+Data+Centro de Custo
aSort( aTotais , NIL , NIL , { |x,y| (;
										x[ATOTAIS_EVENTO_PONTO		]	+	;
										x[ATOTAIS_DTOS_DATA			]	+	;
										x[ATOTAIS_CENTRO_DE_CUSTO	] 	+	;
										x[ATOTAIS_FUNCAO			]	+	; 
										x[ATOTAIS_DEPTO  			] 	+ 	;
										x[ATOTAIS_POSTO  			] 	+	;
										x[ATOTAIS_PROCESSO			] 	+	;
										x[ATOTAIS_ROTEIRO 			] 	+	;
										x[ATOTAIS_PERIODO			] 	+	;																
										x[ATOTAIS_NUM_PAGTO			] 	  	;										
									);	
									<; 
									(;							 
										y[ATOTAIS_EVENTO_PONTO		]	+	;
										Y[ATOTAIS_DTOS_DATA			]	+	;
										y[ATOTAIS_CENTRO_DE_CUSTO	]	+	;
										Y[ATOTAIS_FUNCAO			] 	+	; 
										Y[ATOTAIS_DEPTO  			] 	+ 	;
										Y[ATOTAIS_POSTO  			] 	+	;
										Y[ATOTAIS_PROCESSO			] 	+	;
										Y[ATOTAIS_ROTEIRO 			] 	+	;
										Y[ATOTAIS_PERIODO			] 	+	;																
										Y[ATOTAIS_NUM_PAGTO			] 	  	;																		
									);										
							};
		)

//-- Se Nao Acumula horas para B.Horas do Funcionario, entao totaliza eventos
IF !( lFuncAcBH )
	fTotEve( @aTotais )
	Return( .T. )
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define os codigos do Eventos p/Banco de Horas                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nTotais := Len(aTotais)
For nT := 1 To nTotais
	If (;
			( aScan(aEveBH,  { |X| aTotais[nT,ATOTAIS_EVENTO_PONTO] == X[1] } ) == 0 );
			.and.;
	   		( ( nPosBH := aScan(aCodAut, { |X| x[1]== aTotais[nT,ATOTAIS_EVENTO_PONTO] .and.x[4] == "S" } )) > 0 );
	   	)	
		aAdd( aEveBH , Array( 09 ) )
		nLenEveBh := Len( aEveBH )
		aEveBH[ nLenEveBh , 01 ] := aTotais[nT,ATOTAIS_EVENTO_PONTO]	// 1 - Codigo do Evento
		aEveBH[ nLenEveBh , 02 ] := aCodAut[nPosBH,05]  				// 2 - Periodo de Apuracao
		aEveBH[ nLenEveBh , 03 ] := aCodAut[nPosBH,06]  				// 3 - Numero de Horas De
		aEveBH[ nLenEveBh , 04 ] := aCodAut[nPosBH,07]  				// 4 - Numero de Horas Ate
		aEveBH[ nLenEveBh , 05 ] := aCodAut[nPosBH,08]  				// 5 - Percentual de Valorizacao do Evento
		aEveBH[ nLenEveBh , 06 ] := aCodAut[nPosBH,09]  				// 6 - Agrupa Evento (S/N)
		aEveBH[ nLenEveBh , 07 ] := aCodAut[nPosBH,10]  				// 7 - Valores Totais ou Proporcional a Faixa
		aEveBH[ nLenEveBh , 08 ] := aCodAut[nPosBH,11]  				// 8 - Percentual para Banco de Horas
		aEveBH[ nLenEveBh , 09 ] := aCodAut[nPosBH,12]  				// 9 - Percentual para Folha de Pagto
		If ( aCodAut[nPosBH,9] == "S" )
			lAgrup:= .T.
		Endif
	Endif
Next

// Apuracao p/ BH quando Evento for Apuracao c/Agrupamento
If ( lAgrup )
	aAux:={}
	nTotais := Len(aTotais)
	For nT := 1 To nTotais
		// x[1] - Codigo do Evento
		// x[2] - Acumula Banco de Horas
		// x[3] - Agrupa Lancamentos
		If ( aScan(aCodAut, { |x| x[1] == aTotais[nT,ATOTAIS_EVENTO_PONTO] .and.x[4] == "S" .and.x[9] == "S" }) > 0 )
			aAdd(aAux,{aTotais[nT,ATOTAIS_DATA], aTotais[nT,ATOTAIS_EVENTO_PONTO], aTotais[nT,ATOTAIS_HORAS], nT })
		Endif
	Next nT

	IF ( ( nPercAgBh + nPercAgFl ) > 0 )
		nAux := Len(aAux)
		For nCt := 1 To nAux

			nValCalcB := 0
            nValCalcF := 0
                
			// Percentual para Banco de Horas
			nValCalcB := Round(fConvHr(aTotais[aAux[nCt,4],ATOTAIS_HORAS],"D")*(nPercAgBh/100),2)
			nValCalcB := fConvhr(nValCalcB,"H")
                
			// Percentual para Folha
			nValCalcF := Round(fConvHr(aTotais[aAux[nCt,4],ATOTAIS_HORAS],"D")*(nPercAgFl/100),2)
			nValCalcF := fConvhr(nValCalcF,"H")
                
			If ( ( nPercAgBh + nPercAgFl ) == 100 )
               	If nValCalcB > 0
					If ( cArrCalc == "F" )
						nValCalcF := __TimeSub( aTotais[aAux[nCt,4],ATOTAIS_HORAS],nValCalcB)
					Else
                        nValCalcB := __TimeSub( aTotais[aAux[nCt,4],ATOTAIS_HORAS],nValCalcF)
					Endif
				Endif
			Else
				If ( cArrCalc == "F" )
					If ( ( nValCalcF > 0 ) .and. ( nValCalcB == 0 ) )
						nValCalcF := __TimeSub( aTotais[aAux[nCt,4],ATOTAIS_HORAS],nValCalcF)
					Endif
				Else
					If ( ( nValCalcB > 0 ) .and. ( nValCalcF == 0 ) )
                        nValCalcB := __TimeSub( aTotais[aAux[nCt,4],ATOTAIS_HORAS],nValCalcB)
					Endif
				Endif
			Endif

            If ( nValCalcF > 0 )
   				aTotais[aAux[nCt,4],ATOTAIS_HORAS] := nValCalcF
   			Else
				aTotais[aAux[nCt,4],ATOTAIS_HORAS] := 0
   			Endif
            
			If ( nValCalcB > 0 )
				If ( ( nPos := aScan(aBHAcum, {|x| x[1] == aTotais[aAux[nCt,4],ATOTAIS_DATA] .and.x[2] == aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] .and.x[5] == aTotais[aAux[nCt,4],ATOTAIS_CENTRO_DE_CUSTO] .and. x[6] == aTotais[aAux[nCt,4],ATOTAIS_FUNCAO] } ) ) > 0 )
					aBHAcum[nPos,3] := __TimeSum(aBHAcum[nPos,3],nValCalcB)
				Else
					aAdd( aBHAcum , Array( 12 ) )
					nLenBhAcum := Len( aBHAcum )
					aBHAcum[ nLenBhAcum , 01 ] := aTotais[aAux[nCt,4],ATOTAIS_DATA]
					aBHAcum[ nLenBhAcum , 02 ] := aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO]
					aBHAcum[ nLenBhAcum , 03 ] := nValCalcB
					IF ( (nPosE:=aScan(aEveBH, { |X| aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] == X[1] } ) ) > 0 )
						aBHAcum[ nLenBhAcum , 04 ] := aEveBH[nPosE,5]
					Else
						aBHAcum[ nLenBhAcum , 04 ] := 0
					Endif
					aBHAcum[ nLenBhAcum , 05 ] := aTotais[aAux[nCt,4],ATOTAIS_CENTRO_DE_CUSTO	] 
					aBHAcum[ nLenBhAcum , 06 ] := aTotais[aAux[nCt,4],ATOTAIS_FUNCAO			] 
					aBHAcum[ nLenBhAcum , 07 ] := aTotais[aAux[nCt,4],ATOTAIS_DEPTO   			] 
					aBHAcum[ nLenBhAcum , 08 ] := aTotais[aAux[nCt,4],ATOTAIS_POSTO				] 
					aBHAcum[ nLenBhAcum , 09 ] := aTotais[aAux[nCt,4],ATOTAIS_PROCESSO			] 
					aBHAcum[ nLenBhAcum , 10 ] := aTotais[aAux[nCt,4],ATOTAIS_ROTEIRO			] 
					aBHAcum[ nLenBhAcum , 11 ] := aTotais[aAux[nCt,4],ATOTAIS_PERIODO			] 
					aBHAcum[ nLenBhAcum , 12 ] := aTotais[aAux[nCt,4],ATOTAIS_NUM_PAGTO			]
					IF ( nValCalcF <= 0 )
						aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] := Space(3)
					EndIF	
				EndIf
			Endif

		Next nCt

	Else

		// Soma os eventos e verifica se fara parte do Banco de Horas
		// Quando o Tipo For 1 - Provento ou 3 Base sera somado como Provento
		// Quando o Tipo For 2 - Desconto Sera somado como Desconto

		// Horas Normais
		aEval(	aAux, {	|x|	IF(	PosSP9( x[2] , SRA->RA_FILIAL , "P9_TIPOCOD" , 1 , .F. ) $ "1*3",;
							 		nTBHoras :=__TimeSum(nTBHoras,x[3]),;
							 		nTBHoras :=__TimeSub(nTBHoras,x[3]);
							   );
					   };
			  )

		nTBHoras := Abs( nTBHoras )

		nA := 1
		IF ( nTBHoras > 0 )
			//--Procura a faixa de horas
			If ( ( nTBHoras >= nBHDe ) .and. ( nTBHoras <= nBHAte ) )
				nAux := Len(aAux)
				For nCt := 1 To nAux
					If ( nPos := aScan(aBHAcum, {|x| x[1] == aTotais[aAux[nCt,4],ATOTAIS_DATA] .and.x[2] == aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] .and.x[5] == aTotais[aAux[nCt,4],ATOTAIS_CENTRO_DE_CUSTO] .and. x[6] == aTotais[aAux[nCt,4],ATOTAIS_FUNCAO] } ) ) > 0
						aBHAcum[nPos, 3] := __TimeSum(aBHAcum[nPos,3],aTotais[aAux[nCt,4],ATOTAIS_HORAS])
					Else
						aAdd( aBHAcum , Array( 12 ) )
						nLenBhAcum := Len( aBHAcum )
						aBHAcum[ nLenBhAcum , 01 ] := aTotais[aAux[nCt,4],ATOTAIS_DATA]
						aBHAcum[ nLenBhAcum , 02 ] := aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO]
						aBHAcum[ nLenBhAcum , 03 ] := aTotais[aAux[nCt,4],ATOTAIS_HORAS]
						IF (nPosE:=aScan(aEveBH, { |X| aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] == X[1] } ) ) > 0
							aBHAcum[ nLenBhAcum , 04 ] := aEveBH[nPosE,5]
						Else
							aBHAcum[ nLenBhAcum , 04 ] := 0
						Endif
						aBHAcum[ nLenBhAcum , 05 ] := aTotais[aAux[nCt,4],ATOTAIS_CENTRO_DE_CUSTO	] 	
						aBHAcum[ nLenBhAcum , 06 ] := aTotais[aAux[nCt,4],ATOTAIS_FUNCAO			]	
						aBHAcum[ nLenBhAcum , 07 ] := aTotais[aAux[nCt,4],ATOTAIS_DEPTO   			] 
						aBHAcum[ nLenBhAcum , 08 ] := aTotais[aAux[nCt,4],ATOTAIS_POSTO				] 
						aBHAcum[ nLenBhAcum , 09 ] := aTotais[aAux[nCt,4],ATOTAIS_PROCESSO			] 
						aBHAcum[ nLenBhAcum , 10 ] := aTotais[aAux[nCt,4],ATOTAIS_ROTEIRO			] 
						aBHAcum[ nLenBhAcum , 11 ] := aTotais[aAux[nCt,4],ATOTAIS_PERIODO			] 
						aBHAcum[ nLenBhAcum , 12 ] := aTotais[aAux[nCt,4],ATOTAIS_NUM_PAGTO			]
					EndIf
					aTotais[aAux[nCt,4],ATOTAIS_EVENTO_PONTO] := Space(3)
				Next nCt
			Endif
		Endif
	Endif
Endif

// Apuracao p/ BH quando Evento for Apuracao Independente
nEveBH := Len(aEveBH)
For nT:=1 To nEveBH
	
	If ( aEveBH[nT,6] == "S" )
		Loop
	Endif
	
	dDatIni  := dPerIni
	nTBHoras := 0
	cPerApur := aEveBH[nT,2]
	lAcumBH  := .F.

	If ( ( aEveBH[nT,8] + aEveBH[nT,9] ) > 0 )
		nTotais := Len(aTotais)
		For nT1 := 1 To nTotais
			If ( aEveBH[nT,1] == aTotais[nT1,ATOTAIS_EVENTO_PONTO] )

				nValCalcB := 0
                nValCalcF := 0
                
				// Percentual para Banco de Horas
				nValCalcB := Round(fConvHr(aTotais[nT1,ATOTAIS_HORAS],"D")*(aEveBH[nT,8]/100),2)
				nValCalcB := fConvhr(nValCalcB,"H")

				// Percentual para Folha
				nValCalcF := Round(fConvHr(aTotais[nT1,ATOTAIS_HORAS],"D")*(aEveBH[nT,9]/100),2)
				nValCalcF := fConvhr(nValCalcF,"H")

                If ( ( aEveBH[nT,8] + aEveBH[nT,9] ) == 100 )
	               	If ( nValCalcB > 0 )
						If ( cArrCalc == "F" )
							nValCalcF := __TimeSub( aTotais[nT1,ATOTAIS_HORAS],nValCalcB)
						Else
	                        nValCalcB := __TimeSub( aTotais[nT1,ATOTAIS_HORAS],nValCalcF)
						Endif
					Endif
				Else
					If ( cArrCalc == "F" )
						If ( ( nValCalcF > 0 ) .and. ( nValCalcB == 0 ) )
							nValCalcF := __TimeSub( aTotais[nT1,ATOTAIS_HORAS],nValCalcF)
						Endif
					Else
						If ( ( nValCalcB > 0 ) .and. ( nValCalcF == 0 ) )
	                        nValCalcB := __TimeSub( aTotais[nT1,ATOTAIS_HORAS],nValCalcB)
						Endif
					Endif
                Endif
                 
				If ( nValCalcB > 0 )
					If ( nPos := aScan(aBHAcum, {|x| x[1] == aTotais[nT1,ATOTAIS_DATA] .and.x[2] == aTotais[nT1,ATOTAIS_EVENTO_PONTO] .and.x[5] == aTotais[nT1,ATOTAIS_CENTRO_DE_CUSTO] .and. x[6] == aTotais[nT1,ATOTAIS_FUNCAO]  } ) ) > 0
						aBHAcum[nPos,3] := __TimeSum(aBHAcum[nPos,3],nValCalcB)
					Else
						aAdd(aBHAcum,{ ;
										aTotais[nT1,ATOTAIS_DATA]				,;
										aTotais[nT1,ATOTAIS_EVENTO_PONTO	]	,;
										nValCalcB								,;
										aEveBH[nT,5]							,;
										aTotais[nT1,ATOTAIS_CENTRO_DE_CUSTO	]	,;
										aTotais[nT1,ATOTAIS_FUNCAO			]	,; 
										aTotais[nT1,ATOTAIS_DEPTO  			] 	,;
										aTotais[nT1,ATOTAIS_POSTO  			] 	,;
										aTotais[nT1,ATOTAIS_PROCESSO		] 	,;
										aTotais[nT1,ATOTAIS_ROTEIRO 		] 	,;
										aTotais[nT1,ATOTAIS_PERIODO			] 	,;																
										aTotais[nT1,ATOTAIS_NUM_PAGTO		] 	;												
									};
							)
					EndIf
				Endif

	            If ( nValCalcF > 0 )
	   				aTotais[nT1,ATOTAIS_HORAS] := nValCalcF
	   			Else
					aTotais[nT1,ATOTAIS_HORAS] 			:= 0
					aTotais[nT1,ATOTAIS_EVENTO_PONTO]	:= Space(3)
	   			Endif

			Endif		
		Next
	Else

		nPeriodo := ( dPerFim - dPerIni )
		For nX := 0 To nPeriodo
			dData := dPerIni + nX
			aEval(aTotais, {|x| If(x[ATOTAIS_DATA]==dData .and.x[ATOTAIS_EVENTO_PONTO]==aEveBH[nT,1],;
							   nTBHoras:=__TimeSum(nTBHoras,x[ATOTAIS_HORAS]), Nil)})
			If (;
					( cPerApur ==  "D" );
					.or.;
					( ( cPerApur == "S" ) .and. ( Dow(dData) == 1 ) );
					.or.;
					( ( cPerApur == "Q" ) .and. ( nX == 14 ) );
					.or.;
					( ( cPerApur $ "DSQM" ) .and. ( nX == nPeriodo ) );
				)	
	
				// Calcula Horas para Banco
				If nTBHoras >= aEveBH[nT,3] .and.nTBHoras <= aEveBH[nT,4]
					lAcumBH := .T.
					If aEveBH[nT,7] == "P"
						nTBHoras := If(aEveBH[nT,3] > 0.01,__TimeSub(nTBHoras,aEveBH[nT,3]),nTBHoras)
					Endif
				ElseIf nTBHoras > aEveBH[nT,4] .and.aEVeBH[nT,7] == "P"
					lAcumBH := .T.
					nTBHoras := If(aEveBH[nT,3] == 0.01,aEveBH[nT,4],__TimeSub(aEveBH[nT,4],aEveBH[nT,3]))
				Endif
	            
	           	/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Ponto de Entrada para BH com tratamento Parcial              ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF ( lPnmBh01Block )
					IF ( ValType( aRetBlock := ExecBlock("PNM070BH01",.F.,.F.,{dData, cPerApur, aEveBH[nT,1], aClone(aTotais), aClone(aBHAcum), aClone(aEveBH), lAcumBH, nTBHoras}) ) == "A" )
					   aTotais		:= If( ValType(aRetBlock[1]) == "A", aRetBlock[1] , aTotais	)
					   aBHAcum		:= If( ValType(aRetBlock[2]) == "A", aRetBlock[2] , aBHAcum	)
					   lAcumBH		:= If( ValType(aRetBlock[3]) == "L", aRetBlock[3] , lAcumBH	)
					   nTBHoras		:= If( ValType(aRetBlock[4]) == "N", aRetBlock[4] , nTBHoras	)
					EndIF
				EndIF
	
				If ( lAcumBH )
					lAcumBH	:= .F.
					nValBh 	:= 0
					nCt    	:= 1
					nTotais := Len(aTotais)
					While ( ( nValBh <= nTBHoras ) .and. ( nCt <= nTotais ) )
						If (;
								( aTotais[nCt,ATOTAIS_EVENTO_PONTO] == aEveBH[nT,1] );
								.and.;
								( dDatIni <= aTotais[nCt,ATOTAIS_DATA] );
								.and.;
								( dData >= aTotais[nCt,ATOTAIS_DATA] );
							)	
							nValHoras := aTotais[nCt,ATOTAIS_HORAS]
							nValBh    := __TimeSum(nValBh,aTotais[nCt,ATOTAIS_HORAS])
							If ( nValBh > nTBHoras )
								nValHoras := __TimeSub(nValBh,nTBHoras)
								nValHoras := __TimeSub(aTotais[nCt,ATOTAIS_HORAS],nValHoras)
								aTotais[nCt,ATOTAIS_HORAS]	:= __TimeSub( aTotais[nCt,ATOTAIS_HORAS],nValHoras)
							Endif
	
							If ( ( nPos := aScan(aBHAcum, {|x| x[1] == aTotais[nCt,ATOTAIS_DATA] .and.x[2] == aTotais[nCt,ATOTAIS_EVENTO_PONTO] .and.x[5] == aTotais[nCt,ATOTAIS_CENTRO_DE_CUSTO] .and. x[6] == aTotais[nCt,ATOTAIS_FUNCAO] } ) ) > 0 )
								aBHAcum[nPos,3] := __TimeSum(aBHAcum[nPos,3], aTotais[nCt,ATOTAIS_HORAS] )
							Else
								aAdd(aBHAcum,{ ;
												aTotais[nCt,ATOTAIS_DATA]				,;
												aTotais[nCt,ATOTAIS_EVENTO_PONTO]		,;
												nValHoras								,;
												aEveBH[nT,5]							,;
												aTotais[nCt,ATOTAIS_CENTRO_DE_CUSTO	]	,;
												aTotais[nCt,ATOTAIS_FUNCAO			]	,;
												aTotais[nCt,ATOTAIS_DEPTO  			] 	,;
												aTotais[nCt,ATOTAIS_POSTO  			] 	,;
												aTotais[nCt,ATOTAIS_PROCESSO		] 	,;
												aTotais[nCt,ATOTAIS_ROTEIRO 		] 	,;
												aTotais[nCt,ATOTAIS_PERIODO			] 	,;																
												aTotais[nCt,ATOTAIS_NUM_PAGTO		] 	;												
											};
									)
							EndIf
	
							If ( nValBh <= nTBHoras )
								aTotais[nCt,ATOTAIS_EVENTO_PONTO] := Space(3)
							Endif
	
						Endif
						nCt++
					End While
				Endif
				nTBHoras	:= 0
				dDatIni		:= dData + 1
			EndIf
		Next nX
	Endif
Next nT

fTotEve( @aTotais )

Return( .T. )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fTotEve	  ³ Autor ³ Marinaldo de Jesus    ³ Data ³11/05/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Totalizacao dos Eventos                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTotais - Array com os Eventos                              ³
³          ³lCodFol - Totalizar pelos Codigos da Folha                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aTotais                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PONM070                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fTotEve( aTotais , lFolha, cVerbasDiarias )

Local aTotAux	:= aClone( aTotais )
Local bBlkTot	:= { || NIL  }
Local bBlkSor	:= { || NIL }
Local nT		:= 0
Local nLenTot	:= Len( aTotAux )

DEFAULT cVerbasDiarias := ""                                                         

aTotais := {}

IF ( lFolha := IF( ( lFolha == NIL ) .or. ( ValType( lFolha ) != "L" ) , .F. , lFolha ) )
	bBlkTot := { |e|	( IF(  ( e[ ATOTAIS_CODIGO_FOLHA ] $ cVerbasDiarias  ), ;
								(	e[ ATOTAIS_DATA ] == aTotAux[ nT , ATOTAIS_DATA ]  ),;
									.T.;
						 	);
						 );	
					  	.and.;
						( e[ ATOTAIS_CODIGO_FOLHA ] == aTotAux[ nT , ATOTAIS_CODIGO_FOLHA ] );
					  	.and.;
					  	( e[ ATOTAIS_CENTRO_DE_CUSTO ] == aTotAux[ nT , ATOTAIS_CENTRO_DE_CUSTO ] );
						.and.;
					  	( e[ ATOTAIS_FUNCAO] == aTotAux[ nT , ATOTAIS_FUNCAO ] );					  	
						.and.;
					  	( e[ ATOTAIS_DEPTO] == aTotAux[ nT , ATOTAIS_DEPTO ] );
					  	.and.;
					  	( e[ ATOTAIS_POSTO] == aTotAux[ nT , ATOTAIS_POSTO ] );
					  	.and.;
					  	( e[ ATOTAIS_PROCESSO] == aTotAux[ nT , ATOTAIS_PROCESSO ] );
					  	.and.;
					  	( e[ ATOTAIS_ROTEIRO] == aTotAux[ nT , ATOTAIS_ROTEIRO ] );					  	
					  	.and.;
					  	( e[ ATOTAIS_PERIODO] == aTotAux[ nT , ATOTAIS_PERIODO ] );					  	
					  	.and.;
					  	( e[ ATOTAIS_NUM_PAGTO] == aTotAux[ nT , ATOTAIS_NUM_PAGTO ] );					  						  						  	
			   }
	bBlkSor := { |x,y|	( 	x[ ATOTAIS_CODIGO_FOLHA 	] 	+	;
						 	x[ ATOTAIS_DTOS_DATA 		] 	+	;
						 	x[ ATOTAIS_CENTRO_DE_CUSTO 	] 	+	;
						 	x[ ATOTAIS_FUNCAO 			] 	+	;  
							x[ ATOTAIS_DEPTO  			] 	+ 	;
							x[ ATOTAIS_POSTO  			] 	+	;
							x[ ATOTAIS_PROCESSO			] 	+	;
							x[ ATOTAIS_ROTEIRO 			] 	+	;
							x[ ATOTAIS_PERIODO			] 	+	;																
							x[ ATOTAIS_NUM_PAGTO		] 	  	;							 	
						);
						<							 ;
						(;
							y[ ATOTAIS_EVENTO_PONTO		]	+	;
							Y[ ATOTAIS_DTOS_DATA		]	+	;
							y[ ATOTAIS_CENTRO_DE_CUSTO	]	+	;
							Y[ ATOTAIS_FUNCAO			] 	+	; 
							Y[ ATOTAIS_DEPTO  			] 	+ 	;
							Y[ ATOTAIS_POSTO  			] 	+	;
							Y[ ATOTAIS_PROCESSO			] 	+	;
							Y[ ATOTAIS_ROTEIRO 			] 	+	;
							Y[ ATOTAIS_PERIODO			] 	+	;																
							Y[ ATOTAIS_NUM_PAGTO		] 	  	;																		
  						);							
			}
Else
	bBlkTot := { |e|	( e[ ATOTAIS_DATA ] == aTotAux[ nT , ATOTAIS_DATA ] );
					  	.and.;
						( e[ ATOTAIS_EVENTO_PONTO ] == aTotAux[ nT , ATOTAIS_EVENTO_PONTO ] );
						.and.;
						( e[ ATOTAIS_CENTRO_DE_CUSTO ] == aTotAux[ nT , ATOTAIS_CENTRO_DE_CUSTO ] ); 
						.and.;
					  	( e[ ATOTAIS_FUNCAO] == aTotAux[ nT , ATOTAIS_FUNCAO ] ); 
						.and.;
					  	( e[ ATOTAIS_DEPTO] == aTotAux[ nT , ATOTAIS_DEPTO ] );
					  	.and.;
					  	( e[ ATOTAIS_POSTO] == aTotAux[ nT , ATOTAIS_POSTO ] );
					  	.and.;
					  	( e[ ATOTAIS_PROCESSO] == aTotAux[ nT , ATOTAIS_PROCESSO ] );
					  	.and.;
					  	( e[ ATOTAIS_ROTEIRO] == aTotAux[ nT , ATOTAIS_ROTEIRO ] );					  	
					  	.and.;
					  	( e[ ATOTAIS_PERIODO] == aTotAux[ nT , ATOTAIS_PERIODO ] );					  	
					  	.and.;
					  	( e[ ATOTAIS_NUM_PAGTO] == aTotAux[ nT , ATOTAIS_NUM_PAGTO ] );					  						  						  	
		   }					  		

	bBlkSor := { |x,y|	( 	x[ ATOTAIS_CODIGO_FOLHA 	] 	+	;
						 	x[ ATOTAIS_DTOS_DATA 		] 	+	;
						 	x[ ATOTAIS_CENTRO_DE_CUSTO 	] 	+	;
						 	x[ ATOTAIS_FUNCAO 			] 	+	;  
							x[ ATOTAIS_DEPTO  			] 	+ 	;
							x[ ATOTAIS_POSTO  			] 	+	;
							x[ ATOTAIS_PROCESSO			] 	+	;
							x[ ATOTAIS_ROTEIRO 			] 	+	;
							x[ ATOTAIS_PERIODO			] 	+	;																
							x[ ATOTAIS_NUM_PAGTO		] 	  	;							 	
						);
						<							 ;
						(;
							y[ ATOTAIS_EVENTO_PONTO		]	+	;
							Y[ ATOTAIS_DTOS_DATA		]	+	;
							y[ ATOTAIS_CENTRO_DE_CUSTO	]	+	;
							Y[ ATOTAIS_FUNCAO			] 	+	; 
							Y[ ATOTAIS_DEPTO  			] 	+ 	;
							Y[ ATOTAIS_POSTO  			] 	+	;
							Y[ ATOTAIS_PROCESSO			] 	+	;
							Y[ ATOTAIS_ROTEIRO 			] 	+	;
							Y[ ATOTAIS_PERIODO			] 	+	;																
							Y[ ATOTAIS_NUM_PAGTO		] 	  	;																		
  						); 							
			}
EndIF

For nT := 1 To nLenTot
	IF !Empty( aTotAux[ nT , ATOTAIS_EVENTO_PONTO ] )
		IF ( ( nPos := aScan( aTotais , bBlkTot ) ) > 0 )
			aTotais[ nPos , ATOTAIS_HORAS	] := __TimeSum( aTotais[ nPos , ATOTAIS_HORAS ] , aTotAux[ nT , ATOTAIS_HORAS ] )
			aTotais[ nPos , ATOTAIS_VALOR	] := ( aTotais[ nPos , ATOTAIS_VALOR ] + aTotAux[ nT , ATOTAIS_VALOR ] )
		Else
			aAdd( aTotais , aClone( aTotAux[ nT ] ) )
		EndIF
	EndIF
Next nT

aSort( aTotais , NIL , NIL , bBlkSor  )

Return( aTotais )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ fDescDsr  ³ Autor ³Equipe Advanced RH     ³ Data ³20/01/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcular o Desconto de DSR.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ < Vide Parametros Formais >								   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ < Vide Parametros Formais >								   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Apontamento                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fDescDsr(	aResult		,; //Array com os resultados do apontamento
							aTabCalend	,; //Array com Calendario do turno
							aCodigos	,; //Array com os C¢digos de Eventos
							aArred_D	,; //Array com os Arredondamentod para DSR
							cPeriodo	,; //Indica o per¡odo para calculo (S, Q ou M)      
							dPerini		,; //Periodo Inicial do Apontamento
							dPerFim		,; //Periodo Final   do Apontamento
							aTotais		,; //Array com os resultados do calculo mensal
							lDsrProp	,; //Verifica se o Desconto Sera Baseado no Arredondamento ou em 1 Dia de Trabalho
							lLimDSR     ,; //Indica se Limita Desc de DSR ao Periodo de Apuracao do Mesmo.
							lDsrPPer	,; //Verifica se sera Gerado Evento para desconto de DSR no Proximo Periodo
							aAbonosPer	,; //Array com Todos os Abonos do Periodo para o Funcionario
							cDescDSR	,; //Conteudo do Campo PA_DESCDSR	
							nNumAtra	,; //Conteudo do Campo PA_NUMATRA	
							lMvDDSRFer	;  //Define se realiza o desconto para dias de Feriado
						 )

Local cFilSP6    	:= fFilFunc( "SP6" )
Local nDiaDSR	 	:= HrsSem2OneDsr( SRA->RA_HRSEMAN )	//-- Calcula o Dia de DSR que corresponde a um Dia de Trabalho do Funcionario

Local aAbonos  
Local aRetBlock
Local aTabPer   //Contem os dias agrupados pela quantidade de partes definidas pelo periodo de apuracao
Local cTipo
Local cDSR
Local cDSRMS
Local cEveDDSR
Local cAbonaDesc
Local dData
Local dProxPer
Local lTrabaFer   
Local lExecPad	:= .T.
Local nDesc
Local nHoras
Local nHrsOcorr
Local nNumOcorr
Local nGravaDesc
Local nPos
Local nAbono
Local nAbonos
Local nHrsEfetAbono
Local nHrsAbo
Local nResult
Local nResults
Local nPeriodo
Local nPeriodos
Local nNextPer
Local nPerItem
Local nPerItens
Local nArred
Local nArreds   

Begin Sequence
	
	//-- Variaveis ja inicializadas
	cPeriodo := IF( cPeriodo == NIL .or. Empty( cPeriodo ) , "S" , cPeriodo )
	
	DEFAULT lDsrPPer	:= .T.

	//-- Verifica se existe o Evento para desconto do D.S.R. no Mes
	IF ( ( nPos := aScan( aCodigos , { |x| x[2] == IF( ( cDescDSR == "S" ) , "018A" , "017N" ) } ) ) == 0 )
		//'O Calculo de Desconto de DSR nao Foi Efetuado'###'Verifique se Existem Eventos para os Identificadores 018A e 017N'
		IF ( aScan( aLogDet , { |x| ( x == ( STR0025 + " " + STR0024 ) ) } ) == 0 )
			aAdd( aLogDet , ( STR0025 + " " + STR0024 ) )
		EndIF
		Break
	EndIF
	//-- Definicao do Evento para desconto do D.S.R. no Mes
	cDSR := aCodigos[nPos,1]

	//-- Verifica se existe o Evento para desconto do D.S.R. no Mes Seg
	IF ( ( nPos := aScan( aCodigos , { |x| x[2] == IF( ( cDescDSR == "S" ) , "022A" , "021N" ) } ) ) == 0 )
		//'O Calculo de Desconto de DSR nao Foi Efetuado'###'Verifique se Existem Eventos para os Identificadores 022A e 021N'
		IF ( aScan( aLogDet , { |x| ( x == ( STR0025 + " " +STR0018 ) ) } ) == 0 )
			aAdd( aLogDet , ( STR0025 + " " +STR0018 ) )
		EndIF	
		Break
	EndIF
	//-- Definicao do Evento para desconto do D.S.R. no Mes Seg
	cDSRMS := aCodigos[nPos,1]

	//-- Defini‡„o das Verbas que tenham Incidencia para Desconto de D.S.R.
	cEveDDSR := ""
	aEval(aCodigos, { |x| cEveDDSR += IF( ( x[3] == "S" ) , x[1] + "ú" , "" ) } )
	IF ( Len( cEveDDSR ) == 0 )
		//'O Calculo de Desconto de DSR nao Foi Efetuado'###'Nao Existem Eventos com Incidencia para DSR. Acerte as Incidencias no Cadastro de Eventos (SP9)'
		IF ( aScan( aLogDet , { |x| ( x == ( STR0025 + " " + STR0023 ) ) } ) == 0 )
			aAdd( aLogDet , ( STR0025 + " " + STR0023 ) )
		EndIF
		Break
	EndIF

	//-- Monta o calendario dividido em per¡odos de APURACAO ( S, Q ou M )
	aTabPer	:= {}
	aAdd( aTabPer , {} )
	nPeriodos	:= ( dPerFim - dPerIni )
	dData		:= ( dPerIni - 1 )
	dProxPer	:= ( dPerFim + 1 )
	nArreds		:= Len( aArred_D )

	For nPeriodo := 0 To nPeriodos
	
		++dData
		
		cTipo := "N"
	
		//-- Variavel para Abonar Desconto em DSR ocorridos apos a Demmissao ou Durante o periodo de
		//-- Afastamento
	    cAbonaDesc	:= ""
	
		//-- Desconsidera Datas Superiores a Demissao
		IF SRA->( !Empty( RA_DEMISSA ) .and. ( RA_DEMISSA < dData ) )
			cAbonaDesc := "A"
		EndIF
		
		IF ( ( nPos := aScan( aTabCalend , { |x| ( ( x[1] == dData ) .and. ( x[4] == "1E" ) ) } ) ) > 0 )
		    //-- Verifica se Funcionario Esta afastado na Data
			IF ( lAfasta := aTabCalend[ nPos, CALEND_POS_AFAST ] )
		 		IF (;
		 				( dData >= aTabCalend[ nPos , CALEND_POS_INI_AFAST ] );
		 				.and.;
		 				( dData <= IF( Empty( aTabCalend[ nPos , CALEND_POS_FIM_AFAST ] ) , dData , aTabCalend[ nPos , CALEND_POS_FIM_AFAST ] ) );
		 			)	
		   			cAbonaDesc := "A"
		 		EndIF
	    	EndIF
			//Verifica se funcionario Trabalha em dias feriados
			lTrabaFer := aTabCalend[ nPos , CALEND_POS_TRAB_FERIADO ]
			IF (;
					!( lTrabaFer );
					.and.;
					aTabCalend[ nPos , CALEND_POS_FERIADO ];
					.and.;
					( aTabCalend[ nPos , CALEND_POS_EXCECAO ] # "E" );
				 )  
				//- Se Desconta DSR para Feriado  
				If lMvDDSRFER
					cTipo := "F"   
				//- Se Nao Desconta DSR para Feriado mas o Feriado e o DSR ocorrem no mesmo dia
				//- Forca desconto somento do DSR
				ElseIF ( aTabCalend[ nPos , CALEND_POS_TIPO_ORIG_DIA ] == "D" ) 
					cTipo:= "D"
				Endif	
			ElseIF ( aTabCalend[ nPos , CALEND_POS_TIPO_DIA ] == "D" ) 
				cTipo := "D"
			EndIF
		EndIF
	
		aAdd( aTabPer[ Len( aTabPer ) ] , { dData , cTipo , 0 , cAbonaDesc } )
	
		IF (;
				(;
					(;
						( cPeriodo == "S" );
						.and.;
						( Dow( dData ) == 1 );
					);
					.or.;
					(;
						( cPeriodo == "Q" );
						.and.;
						( nPeriodo == 14 );
					);
				);				
				.and.;
				( nPeriodo < nPeriodos );
			)	
			aAdd( aTabPer , {} )
		EndIF
	
	Next nPeriodo
	
	//-- Obtem o Numero de Elementos do aResult
	nResults := Len( aResult )

	//-- Processa individualmente cada Per¡odo do Calend rio
	nPeriodos := Len( aTabPer )
	For nPeriodo := 1 To nPeriodos
	    nGravaDesc	:= 0
	    nNextPer	:= ( nPeriodo + 1 )
		//-- Soma as ocorrˆncias de Verbas com Desconto para D.S.R. no Per¡odo
		nPerItens := Len( aTabPer[ nPeriodo ] )
		For nPerItem := 1 To nPerItens
			dData	:= aTabPer[ nPeriodo , nPerItem , 1 ]
			//Verifica se Tem Evento para o Desconto de DSR
			nPos	:= aScan( aResult , { |x| ( x[1] == dData ) .and. ( x[2] $ cEveDDSR ) } )
			IF ( nPos == 0 )
				Loop
			EndIF
			For nResult := nPos To nResults
				IF ( aResult[ nResult , ARESULT_DATA ] <> dData )
					Exit
				EndIF
				IF ( aResult[ nResult , ARESULT_EVENTO ] $ cEveDDSR )
					//-- Total de Faltas/Atrasos, Base para Calculo do Desc DSR
					nHrsaDesc		:= aResult[ nResult , ARESULT_HORAS ]
					nHrsEfetAbono	:= 0
					//-- Se Existirem Abonos Verifica se os Abonos abonam Faltas que compoem
					//-- a Base para Calculo do Desc de DSR

					IF (;
						( nHrsAbo := fAbonos(;
													dData									,;	//01 - Data do Abono
													aResult[ nResult , ARESULT_EVENTO ]		,;	//02 - Evento do Abono
													NIL										,;	//03 - Hora Inicial do Abono
													@aAbonos								,;	//04 - Array onde serao carregados os Abonos
													aResult[ nResult , ARESULT_TPMARCA ]	,;	//05 - Tipo de Marcacao
													aResult[ nResult , ARESULT_CC ]			,;	//06 - Centro de Custo
													aAbonosPer			 					,;	//07 - Array com Todos os Abonos do Periodo
													aResult[ nResult , ARESULT_FUNCAO ]		,;	//08 - Funcao
													aResult[ nResult , ARESULT_DEPTO ]		,;	//09 - Depto 
													aResult[ nResult , ARESULT_POSTO ]		,;	//10 - Posto  
													aResult[ nResult , ARESULT_PROCESSO ]	,;	//11 - Processo
													aResult[ nResult , ARESULT_PERIODO ]	,;	//12 - Periodo
													aResult[ nResult , ARESULT_ROTEIRO ]	,;	//13 - Roteiro													
													aResult[ nResult , ARESULT_NUM_PAGTO ]	;	//14 - NumPagto	
											 ); 
						 ) > 0;
						)
						
						//-- Corre Todos os Abonos do Evento
						nAbonos := Len( aAbonos )
						For nAbono := 1 To nAbonos
						    //-- Posiciona no Motivo/ Justificativa de cada Abono
						    IF SP6->( MsSeek( cFilSP6 + aAbonos[ nAbono , AABONOS_CODIGO ] ) )
						       //-- Verifica se o Motivo abona Desc.DSR e, entao, nao compoe a
						       //-- base de faltas/atrasos para calculo do Desconto de DSR
						       IF ( SP6->P6_ABDSR $ " S" )
							      nHrsEfetAbono := __TimeSum( nHrsEfetAbono , aAbonos[ nAbono , AABONOS_HORAS_ABO ] )
							   EndIF
	                        EndIF
	                    Next nAbono
					    //-- Do Total de Horas que formam a Base para Desc de DSR
					    //-- Retira-se o total de horas que abonam Desc DSR
						nHrsaDesc := __TimeSub( aResult[ nResult , ARESULT_HORAS ] , nHrsEfetAbono )
					EndIF
				    //-- Armazena o Total de Faltas/Atrasos jah deduzidos os Abonos se houverem
					aTabPer[ nPeriodo , nPerItem , 3] := __TimeSum( aTabPer[ nPeriodo , nPerItem , 3 ] , nHrsaDesc )
				EndIF
			Next nResult
		Next nPerItem
	
		//-- Define o no. de horas de ocorrˆncias no Per¡odo
		//-- Totaliza o no. de dias com ocorrˆncias no Per¡odo
		nHrsOcorr := ( nNumOcorr := 0 )
		
		aEval( aTabPer[ nPeriodo ] ,  {  	|x|											    	 ;
											IF( x[ 3 ] > 0										,;
												(   											 ;
													nHrsOcorr := __TimeSum( nHrsOcorr , x[ 3 ] ),;
												  	++nNumOcorr	                                 ;
												 )												,;
												 NIL											 ;
											   )												 ;
										}														 ;
			  )
		 
		//-- Efetua os Descontos para os dias de D.S.R. e Feriados no Per¡odo.
	 	nDesc := 0     
	 	
		IF ( lPnmDSR02Block )                             
		 	IF ( ValType( aRetBlock := ExecBlock("PNMDDSR02",.F.,.F.,;
		 																{;
																			aTabCalend	,; //01 - Array com Calendario do turno
																			aResult		,; //02 - Array com os Resultados do apontamento
																			aTotais		,; //03 - Array com os eventos para Valores de Desconto de DSR
																			aArred_D	,; //04 - Array com os Arredondamento para DSR
																			cPeriodo	,; //05 - Indica o per¡odo para calculo (S, Q ou M)      
																			lDsrProp	,; //06 - Verifica se o Desconto Sera Baseado no Arredondamento ou em 1 Dia de Trabalho (parametro "MV_DSRPROP")
																			lLimDSR     ,; //07 - Indica se Limita Desc de DSR ao Periodo de Apuracao do Mesmo (parametro "MV_LIMDSR").
																			lDsrPPer	,; //08 - Verifica se sera Gerado Evento para desconto de DSR no Proximo Periodo (parametro "MV_DSRPPER").
																			lMvDDSRFer	,; //09 - Define se realiza o desconto para dias de Feriado (parametro "MV_DDSRFER").
																			cDSR		,; //10 - Codigo do Evento de Desconto do DSR.	
																			nNumAtra	,; //11 - Contreudo do Campo PA_NUMATRA	
																			aTabPer		,; //12 - Array com as informacoes do Periodo para Calculo do Desc. de DSR
																			nPeriodo	,; //13 - Posicao do array 
																			nHrsOcorr   ,; //14 - Total de Horas de Eventos de Desconto para o Periodo de Apuracao do Desc DSR
																			nNumOcorr   ,; //15 - Qtde de ocorrencias dos Eventos de Desconto para o Periodo de Apuracao do Desc DSR
																			nDiaDSR		 ; //16 - Horas para desconto do DSR
		 																	;
		 																};
		 										) ) == "A" )
			   	lExecPad:= IF( ValType(aRetBlock[1]) == "L", aRetBlock[1], .F. 	 )
			   	nDesc	:= IF( ValType(aRetBlock[2]) == "N", aRetBlock[2], 0 		 )
			   	aTotais := IF( ValType(aRetBlock[3]) == "A", aRetBlock[3], aTotais ) 	
	    	Else
		   	 	lExecPad:= .F.
	    	EndIF
		EndIF    
	    
	    /*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Executa Calculo Padrao do Desconto de DSR					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

	    If 	lExecPad
		    //-- Se o Parametro de Desconto de DSR for 'Nao', Calcula o Desconto baseado
		    //-- na Tabela de Arredondamento. 
		    IF !( lDsrProp )
	
				For nArred := 1 To nArreds
					
					nDesc	:= 0
					nHoras	:= aArred_D[ nArred , 3 ]
	
					//-- Desconto de 1 DSR a cada ocorrˆncia de DSR ou Feriado por Per¡odo
					nPerItens := Len( aTabPer[ nPeriodo ] )
					For nPerItem := 1 To nPerItens
						dData	:= aTabPer[ nPeriodo , nPerItem , 1 ]
						IF ( ( aTabPer[ nPeriodo , nPerItem , 2 ] $ "D/F" ) .and. ( dData >= fDtaAdmis() ) )
						    //-- Calcula Qtde de Descontos
							++nDesc
							IF (;
									(;
										( nNumOcorr > nNumAtra );
										.or.;
										( nNumAtra == 0 );
									 );
									.and.;
							   		(;
							   			( nHrsOcorr >= aArred_D[ nArred , 1 ] );
							   			.and.;
							   			( nHrsOcorr <= aArred_D[ nArred , 2 ] );
							   		);
							   		.and.;
							   		( aTabPer[ nPeriodo , nPerItem , 4 ] <> "A" );
							   	)	
					            //-- Se Limita o Desc de DSR a um Por Periodo e ainda nao o calculou
								//-- ou Se Desconta 1 DSR a cada ocorrˆncia de DSR por Per¡odo
								IF ( ( ( lLimDSR ) .and. Empty( nGravaDesc ) ) .or. !( lLimDSR ) )
									fGeraTot(	@aTotais			,;	//01 -> Array com os Totais do Ponto
												dData				,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras				,;	//03 -> Horas para Soma ou Geracao
												0					,;	//04 -> Valor para Soma ou Geracao
												cDsr				,;	//05 -> Evento do Ponto para Pesquisa
												SRA->RA_CC			,;	//06 -> Centro de Custo para Comparacao
												SRA->RA_FILIAL		,;	//07 -> Filial para Pesquisa no SP9 
												NIL					,;	//08 -> Verba da Folha
												NIL					,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
												SRA->RA_CODFUNC 	,;	//10 -> Funcao para Comparacao																					
												SRA->RA_DEPTO		,;	//11 -> Depto  para Comparacao   
												SRA->RA_POSTO 		,;	//12 -> Posto  para Comparacao   
												SRA->RA_PROCES		,;	//13 -> Processo para Comparacao   
												oPeriodo:cRoteiro	,;	//14 -> Roteiro para Comparacao   
												oPeriodo:cPeriodo	,;	//15 -> Periodo para Comparacao   
												oPeriodo:cNumPagto	;	//16 -> NumPagto para Comparacao  															
											)
									++nGravaDesc
								EndIF
							EndIF
						EndIF
	
					Next nPerItem
	
				Next nArred
	
			Else
	
				nDesc  := 0
				
				//-- Desconto de 1 DSR a cada ocorrˆncia de DSR por Per¡odo
				nPerItens := Len( aTabPer[ nPeriodo ] )
				//-- Corre Todos os Dias do Periodo Lido
				For nPerItem := 1 To nPerItens
					dData  := aTabPer[ nPeriodo , nPerItem , 1 ]
					nHoras := 0
					IF (;
							( aTabPer[ nPeriodo , nPerItem , 2 ] $ "D/F" );
							.and.;
							( dData >= fDtaAdmis() );
						)	
						//-- Calcula Qtde de Descontos
						++nDesc
						//-- Se o Numero de Ocorrencias de Faltas/Atrasos superar o limite Informado
						//-- Gera Desconto
						IF (;
								(;
									( nNumOcorr > nNumAtra );
									.or.;
									( nNumAtra == 0 );
								);
								.and.;
								( aTabPer[ nPeriodo , nPerItem ,4 ] <> "A" );
							)	
							
							
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Ponto de Entrada para Desconto de DSR			               ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							IF ( lPnmDSR01Block )                             
								nHoras := nHrsOcorr 
								IF ( ValType( aRetBlock := ExecBlock("PNMDDSR01",.F.,.F.,{dData, nHoras, nNumOcorr, nNumAtra,  1 }) ) == "A" )
								   nHoras		:= If( ValType(aRetBlock[1]) == "N", aRetBlock[1] , nHoras		)
								EndIF 
								fGeraTot(	@aTotais			,;	//01 -> Array com os Totais do Ponto
											dData				,;	//02 -> Data para Pesquisa e Gravacao no aTotais
											nHoras				,;	//03 -> Horas para Soma ou Geracao
											0					,;	//04 -> Valor para Soma ou Geracao
											cDsr				,;	//05 -> Evento do Ponto para Pesquisa
											SRA->RA_CC			,;	//06 -> Centro de Custo para Comparacao
											SRA->RA_FILIAL		,;	//07 -> Filial para Pesquisa no SP9
											NIL					,;	//08 -> Verba da Folha
											NIL					,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
											SRA->RA_CODFUNC 	,;	//10 -> Funcao para Comparacao																					
											SRA->RA_DEPTO		,;	//11 -> Depto  para Comparacao   
											SRA->RA_POSTO 		,;	//12 -> Posto  para Comparacao   
											SRA->RA_PROCES		,;	//13 -> Processo para Comparacao   
											oPeriodo:cRoteiro	,;	//14 -> Roteiro para Comparacao   
											oPeriodo:cPeriodo	,;	//15 -> Periodo para Comparacao   
											oPeriodo:cNumPagto	;	//16 -> NumPagto para Comparacao  															
										)

							Else
							
								//-- Se Limita o Desc de DSR a um Por Periodo e ainda nao o calculou
								//-- ou Se Desconta 1 DSR a cada ocorrˆncia de DSR por Per¡odo
								IF ( ( ( lLimDSR ) .and. Empty( nGravaDesc ) ) .or. !( lLimDSR ) )
									
								
						
									nHoras := __TimeSub( nDiaDSR , nHrsOcorr )
									//-- Garante que Seja Descontado do DSR ate a sua Totalizacao
									nHoras := IF( nHoras <= 0 , nDiaDSR , nHrsOcorr ) 
								
									
									
									fGeraTot(	@aTotais			,;	//01 -> Array com os Totais do Ponto
												dData				,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras				,;	//03 -> Horas para Soma ou Geracao
												0					,;	//04 -> Valor para Soma ou Geracao
												cDsr				,;	//05 -> Evento do Ponto para Pesquisa
												SRA->RA_CC			,;	//06 -> Centro de Custo para Comparacao
												SRA->RA_FILIAL		,;	//07 -> Filial para Pesquisa no SP9
											 	NIL					,;	//08 -> Verba da Folha
												NIL					,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
												SRA->RA_CODFUNC 	,;	//10 -> Funcao para Comparacao																					
												SRA->RA_DEPTO		,;	//11 -> Depto  para Comparacao   
												SRA->RA_POSTO 		,;	//12 -> Posto  para Comparacao   
												SRA->RA_PROCES		,;	//13 -> Processo para Comparacao   
												oPeriodo:cRoteiro	,;	//14 -> Roteiro para Comparacao   
												oPeriodo:cPeriodo	,;	//15 -> Periodo para Comparacao   
												oPeriodo:cNumPagto	;	//16 -> NumPagto para Comparacao  															
											)
																
									++nGravaDesc
								EndIF
							EndIF
						Endif	
					EndIF
				Next nPerItem
			EndIF
	    EndIF
	        
		//-- Em per¡odos sem DSR as horas de ocorr. v„o para o pr¢ximo Per¡odo
		IF ( nDesc == 0 )
			IF ( nPeriodo < nPeriodos )
				aTabPer[ nNextPer , 1 , 3 ] := __TimeSum( aTabPer[ nNextPer , 1 , 3 ] , nHrsOcorr )
			ElseIF ( lDsrPPer ) //Se Gera DSR para o Proximo Periodo
				//-- Gera Pr¢ximo Desconto de D.S.R.
				IF SPC->( MsSeek( SRA->( RA_FILIAL + RA_MAT ) + cDSrMS + Dtos( dProxPer ) ) )
					IF SPC->( RecLock( "SPC" , .F. ) )
						IF ( nHrsOcorr > 0 )
							SPC->PC_FILIAL	:= SRA->RA_FILIAL
							SPC->PC_MAT		:= SRA->RA_MAT
							SPC->PC_PD		:= cDsrMS
							SPC->PC_DATA	:= dProxPer
							SPC->PC_QUANTC	:= nHrsOcorr
							SPC->PC_CC		:= SRA->RA_CC
							SPC->PC_CODFUNC	:= SRA->RA_CODFUNC
							SPC->PC_DEPTO	:= SRA->RA_DEPTO	
							SPC->PC_POSTO	:= SRA->RA_POSTO	
							SPC->PC_PROCES	:= SRA->RA_PROCES	
							SPC->PC_PERIODO	:= cPeriodo			
							SPC->PC_ROTEIR	:= oPeriodo:cRoteiro
							SPC->PC_NUMPAG	:= oPeriodo:cNumPagto	
						Else
							SPC->( dbDelete() )
						EndIF
						SPC->( MsUnLock() )
					EndIF	
				ElseIF ( nHrsOcorr > 0 )
					IF SPC->( RecLock( "SPC" , .T. ) )
						SPC->PC_FILIAL	:= SRA->RA_FILIAL
						SPC->PC_MAT		:= SRA->RA_MAT
						SPC->PC_PD		:= cDsrMS
						SPC->PC_DATA	:= dProxPer
						SPC->PC_QUANTC	:= nHrsOcorr
						SPC->PC_CC		:= SRA->RA_CC         
						SPC->PC_CODFUNC	:= SRA->RA_CODFUNC	
						SPC->PC_DEPTO	:= SRA->RA_DEPTO	
						SPC->PC_POSTO	:= SRA->RA_POSTO	
						SPC->PC_PROCES	:= SRA->RA_PROCES	
						SPC->PC_PERIODO	:= oPeriodo:cPeriodo			
						SPC->PC_ROTEIR	:= oPeriodo:cRoteiro
						SPC->PC_NUMPAG	:= oPeriodo:cNumPagto											
						SPC->( MsUnLock() )
					EndIF
				EndIF
			ElseIF !( lDsrPPer ) //Se Nao Gera DSR para o Proximo Periodo e Forca a Geracao do Desconto do DSR na Ultima Semana
				//Se gerou Dsr para o Proximo Periodo Exclui para gerar o Desconto no Mes
				IF SPC->( MsSeek( SRA->( RA_FILIAL + RA_MAT ) + cDSrMS + Dtos( dProxPer ) ) )
					IF SPC->( RecLock( "SPC" , .F. ) )
						SPC->( dbDelete() )
						SPC->( MsUnLock() )
					EndIF
				EndIF
				dData  := dPerFim
			    //-- Se o Parametro de Desconto de DSR for 'Nao', Calcula o Desconto baseado
			    //-- na Tabela de Arredondamento. 
			    IF !( lDsrProp )
					For nArred := 1 To nArreds
						nHoras := aArred_D[ nArred , 3 ]
						IF ( dData >= fDtaAdmis() )
					    	//-- Calcula Qtde de Descontos
							IF (;
									(;
										( nNumOcorr > nNumAtra );
										.or.;
										( nNumAtra == 0 );
									);
									.and.;
									(;
										( nHrsOcorr >= aArred_D[ nArred , 1 ] );
										.and.;
										( nHrsOcorr <= aArred_D[ nArred , 2 ] );
									);
								)		
					            //-- Se Limita o Desc de DSR a um Por Periodo e ainda nao o calculou
								//-- ou Se Desconta 1 DSR a cada ocorrˆncia de DSR por Per¡odo
								IF ( ( ( lLimDSR ) .and. Empty( nGravaDesc ) ) .or. !( lLimDSR ) )
									fGeraTot(	@aTotais			,;	//01 -> Array com os Totais do Ponto
												dData				,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras				,;	//03 -> Horas para Soma ou Geracao
												0					,;	//04 -> Valor para Soma ou Geracao
												cDsr				,;	//05 -> Evento do Ponto para Pesquisa
												SRA->RA_CC			,;	//06 -> Centro de Custo para Comparacao
												SRA->RA_FILIAL		,;	//07 -> Filial para Pesquisa no SP9
											 	NIL					,;	//08 -> Verba da Folha
												NIL					,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
												SRA->RA_CODFUNC 	,;	//10 -> Funcao para Comparacao		
												SRA->RA_DEPTO		,;	//11 -> Depto  para Comparacao   
												SRA->RA_POSTO 		,;	//12 -> Posto  para Comparacao   
												SRA->RA_PROCES		,;	//13 -> Processo para Comparacao   
												oPeriodo:cRoteiro	,;	//14 -> Roteiro para Comparacao   
												oPeriodo:cPeriodo	,;	//15 -> Periodo para Comparacao   
												oPeriodo:cNumPagto	;	//16 -> NumPagto para Comparacao  																																
											)
								EndIF
							EndIF
						EndIF
					Next nArred
				Else
					nHoras := 0
					IF ( dData >= fDtaAdmis() )
						//-- Se o Numero de Ocorrencias de Faltas/Atrasos superar o limite Informado
						//-- Gera Desconto
						IF ( ( nNumOcorr > nNumAtra ) .or. ( nNumAtra == 0 ) ) 
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Ponto de Entrada para Desconto de DSR			               ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							IF ( lPnmDSR01Block ) 
								nHoras := nHrsOcorr 
								IF ( ValType( aRetBlock := ExecBlock("PNMDDSR01",.F.,.F.,{dData, nHoras, nNumOcorr, nNumAtra,  2 }) ) == "A" )
								   nHoras		:= If( ValType(aRetBlock[1]) == "N", aRetBlock[1] , nHoras		)
								EndIF 
								fGeraTot(	@aTotais			,;	//01 -> Array com os Totais do Ponto
											dData				,;	//02 -> Data para Pesquisa e Gravacao no aTotais
											nHoras				,;	//03 -> Horas para Soma ou Geracao
											0					,;	//04 -> Valor para Soma ou Geracao
											cDsr				,;	//05 -> Evento do Ponto para Pesquisa
											SRA->RA_CC			,;	//06 -> Centro de Custo para Comparacao
											SRA->RA_FILIAL		,;	//07 -> Filial para Pesquisa no SP9
										 	NIL					,;	//08 -> Verba da Folha
											NIL					,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
											SRA->RA_CODFUNC 	,;	//10 -> Funcao para Comparacao																					
											SRA->RA_DEPTO		,;	//11 -> Depto  para Comparacao   
											SRA->RA_POSTO 		,;	//12 -> Posto  para Comparacao   
											SRA->RA_PROCES		,;	//13 -> Processo para Comparacao   
											oPeriodo:cRoteiro	,;	//14 -> Roteiro para Comparacao   
											oPeriodo:cPeriodo	,;	//15 -> Periodo para Comparacao   
											oPeriodo:cNumPagto	;	//16 -> NumPagto para Comparacao  	
										)
							Else
								//-- Se Limita o Desc de DSR a um Por Periodo e ainda nao o calculou
								//-- ou Se Desconta 1 DSR a cada ocorrˆncia de DSR por Per¡odo
								IF ( ( ( lLimDSR ) .and. Empty( nGravaDesc ) ) .or. !( lLimDSR ) )
									nHoras := __TimeSub( nDiaDSR , nHrsOcorr )
									//-- Garante que Seja Descontado do DSR ate a sua Totalizacao
									nHoras := IF( ( nHoras <= 0 ) , nDiaDSR , nHrsOcorr )
									fGeraTot(	@aTotais			,;	//01 -> Array com os Totais do Ponto
												dData				,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												nHoras				,;	//03 -> Horas para Soma ou Geracao
												0					,;	//04 -> Valor para Soma ou Geracao
												cDsr				,;	//05 -> Evento do Ponto para Pesquisa
												SRA->RA_CC			,;	//06 -> Centro de Custo para Comparacao
												SRA->RA_FILIAL		,;	//07 -> Filial para Pesquisa no SP9
												NIL					,;	//08 -> Verba da Folha
												NIL					,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
												SRA->RA_CODFUNC 	,;	//10 -> Funcao para Comparacao																					
												SRA->RA_DEPTO		,;	//11 -> Depto  para Comparacao   
												SRA->RA_POSTO 		,;	//12 -> Posto  para Comparacao   
												SRA->RA_PROCES		,;	//13 -> Processo para Comparacao   
												oPeriodo:cRoteiro	,;	//14 -> Roteiro para Comparacao   
												oPeriodo:cPeriodo	,;	//15 -> Periodo para Comparacao   
												oPeriodo:cNumPagto	;	//16 -> NumPagto para Comparacao  													
											)
							    Endif
							EndIF
						EndIF
					EndIF
				EndIF
			EndIF
		Else
			/*
			
			-- Define se Gera DSR para o Proximo Periodo --
			
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se ultima semana do periodo, apresentar desconto de DSR enviando p/ o proximo ³
			³periodo a qtde. de horas de ocorrencias (faltas/atrasos), isto eh, podemos	   ³
			³ter um DSR na ultima semana e uma falta. Sera gerado um desconto de DSR. No   ³
			³entanto, pode ocorrer um DSR/feriado na primeira semana do proximo periodo e  ³
			³as faltas/atrasos do periodo atual deverao ser consideradas p/ descontar esse ³
			³DSR/feriado (proximo periodo).												   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			*/
			
			IF ( nPeriodo == nPeriodos ) .And. ( lDsrPPer )
				//-- Gera Pr¢ximo Desconto de D.S.R.
				IF SPC->( MsSeek( SRA->( RA_FILIAL + RA_MAT ) + cDSrMS + Dtos( dProxPer ) ) )
					IF SPC->( RecLock( "SPC" , .F. ) )
						IF ( nHrsOcorr > 0 )
							SPC->PC_FILIAL	:= SRA->RA_FILIAL
							SPC->PC_MAT		:= SRA->RA_MAT
							SPC->PC_PD		:= cDsrMS
							SPC->PC_DATA	:= dProxPer
							SPC->PC_QUANTC	:= nHrsOcorr
							SPC->PC_CC		:= SRA->RA_CC
							SPC->PC_CODFUNC	:= SRA->RA_CODFUNC	
							SPC->PC_DEPTO	:= SRA->RA_DEPTO	
							SPC->PC_POSTO	:= SRA->RA_POSTO	
							SPC->PC_PROCES	:= SRA->RA_PROCES	
							SPC->PC_PERIODO	:= oPeriodo:cPeriodo			
							SPC->PC_ROTEIR	:= oPeriodo:cRoteiro
							SPC->PC_NUMPAG	:= oPeriodo:cNumPagto							
						Else
							SPC->( dbDelete() )
						EndIF
						SPC->( MsUnLock() )
					EndIF	
				ElseIF ( nHrsOcorr > 0 )
					IF SPC->( RecLock( "SPC" , .T. ) )
						SPC->PC_FILIAL	:= SRA->RA_FILIAL
						SPC->PC_MAT		:= SRA->RA_MAT
						SPC->PC_PD		:= cDsrMS
						SPC->PC_DATA	:= dProxPer
						SPC->PC_QUANTC	:= nHrsOcorr
						SPC->PC_CC		:= SRA->RA_CC
						SPC->PC_CODFUNC	:= SRA->RA_CODFUNC	
						SPC->PC_DEPTO	:= SRA->RA_DEPTO	
						SPC->PC_POSTO	:= SRA->RA_POSTO	
						SPC->PC_PROCES	:= SRA->RA_PROCES	
						SPC->PC_PERIODO	:= oPeriodo:cPeriodo			
						SPC->PC_ROTEIR	:= oPeriodo:cRoteiro
						SPC->PC_NUMPAG	:= oPeriodo:cNumPagto						
						SPC->( MsUnLock() )
					EndIF
				EndIF
			EndIf
					
		EndIF //( nDesc == 0 )
	
	Next nPeriodo

End Sequence
	
Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fContaEvento     ³ Autor ³Mauricio MR     ³ Data ³25/10/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Conta o numero de ocorrencias de um evento com horas apura- ³±±
±±³          ³das.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Ver Parametros formais     								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³PONM070	 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fContaEvento(lEveCont,lAcumEveCont, nHoras, aEveCont,cEvento, aTotais, dPerIni, dPerFim, aTabCalend, cLastFil, cAliasQSPC)
Local lContaEvento	:= .F.
Local nPos			:= 0
Local uRetBlock 

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica a existencia de contador de eventos e registra o     ³
³numero de ocorrencias										   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
//--Se existe o campo de Evento Contador
If lEveCont .AND. !Empty(nHoras)
 	//-- Verifica se nao foi carregado o evento do ponto
	If !( Empty( aEveCont) )
		 If  !( Empty( nPos:= Ascan( aEveCont, {|x| x[1] == cEvento } ) ) )
			
			lContaEvento	:= .T.

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ponto de Entrada Antes da Totalizacao dos Eventos Contadores ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( lPonEveContBlock )
				uRetBlock := ExecBlock(;
											"PNMEVECONT",;
											.F.,;
											.F.,;
											{;
												aClone( aTotais ),;			//ParamIxb[1] <-> Array aTotais
												dPerIni,;					//ParamIxb[2] <-> Periodo Inicial do Apontamento
												dPerFim,;					//ParamIxb[3] <-> Periodo Final do Apontamento
												aClone( aTabCalend ),;		//ParamIxb[4] <-> Array com o Calendario de Marcacoes
												aEveCont[nPos,2]	,;		//ParamIxb[5] <-> Evento Contador Ponto para Pesquisa
												nHoras				;		//ParamIxb[6] <-> Horas do Evento do Corrente
											},;
											.F.;
						 			 )
				IF ( ValType( uRetBlock ) == "A" )
					aTotais 		:= aClone( uRetBlock[1] )
                    lContaEvento	:= uRetBlock[2]
				EndIF
				uRetBlock := NIL
			EndIF 
			If lContaEvento 
			 	( cAliasQSPC )->(;
									fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
												PC_DATA			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												1				,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												aEveCont[nPos,2],;	//05 -> Evento do Ponto para Pesquisa
												PC_CC			,;	//06 -> Centro de Custo para Comparacao
												cLastFil		,;	//07 -> Filial para Pesquisa no SP9  
												NIL				,;	//08 -> Verba da Folha
											    If(lAcumEveCont,aEveCont[nPos,3],Nil),;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
												PC_CODFUNC 		,;	//10 -> Funcao para Comparacao																					
												PC_DEPTO		,;	//11 -> Depto  para Comparacao   
												PC_POSTO 		,;	//12 -> Posto  para Comparacao   
												PC_PROCES		,;	//13 -> Processo para Comparacao   
												PC_ROTEIR		,;	//14 -> Roteiro para Comparacao   
												PC_PERIODO		,;	//15 -> Periodo para Comparacao   
												PC_NUMPAG	 	;	//16 -> NumPagto para Comparacao  															
											);
								 )
			Endif					 
		 Endif					 
	 Endif
Endif 

Return ( NIL )			
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³TipodeDia		   ³ Autor ³Mauricio MR     ³ Data ³02/12/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica o Tipo de Dia 									  ³±±
±±³          ³das.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Ver Parametros formais     								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³PONM070	 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/

Function TipodeDia( aItemTabCalend )
Local cTipoDia
Local lTrbFeriado

//Verifica Afastamento no Dia
If !Empty( aItemTabCalend[ CALEND_POS_TIP_AFAST] )
   cTipoDia := "!!"
Else 
	//Verifica Feriado, Se trabalha em Feriado e Excecao
   lTrbFeriado	:= aItemTabCalend[ CALEND_POS_TRAB_FERIADO ]
   cTipoDia	:= IF( aItemTabCalend[ CALEND_POS_FERIADO ] , IF(  aItemTabCalend[ CALEND_POS_EXCECAO ]  == "E" , aItemTabCalend[ CALEND_POS_TIPO_DIA ] , IF(!lTrbFeriado,"F",aItemTabCalend[ CALEND_POS_TIPO_DIA ] ) ) , aItemTabCalend[ CALEND_POS_TIPO_DIA ] )                  
Endif
Return( cTipoDia )    
 


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fSemanas  ³Autor³Igor Franzoi		        ³Data³22/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Monta um array com todas as semanas do periodo selecionado	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fSemanas( aSemana, dDtaIni, dDtaFim )

//Local nCont   := 0
Local dIniSem := dDtaIni
Local dFimSem := dDtaIni
//Local dDtaAux := dDtaIni

Do While ( dIniSem <= dDtaFim )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define qual a data inicial/final da Semana				   ³
	| Caso semana sempre iniciada na Segunda-Feira				   |
	| Independente do Periodo - ou seja, monta todas as semanas com|	
	| o primeiro dia sendo a Segunda-Feira						   |		
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	/*For nCont := 1 To 7
		If ( Dow(dDtaAux) == 2 )
			dIniSem := dDtaAux
			dFimSem := (dIniSem+6)
			Exit		
		ElseIf ( Dow(dDtaAux) == nCont )
			dIniSem := ((dDtaAux-nCont)+2)
			dFimSem := (dIniSem+6)
			Exit
		EndIf
	Next*/

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define qual a data inicial/final da Semana				   ³
	| Caso semana sempre iniciada na Segunda-Feira				   |
	| Dependente do Periodo - ou seja, monta a primeira semana com |
	| o primeiro dia sendo o o dia do periodo, e todos as outras   |		
	| semanas sao iniciadas na Segunda-Feira dentro deste periodo  |			
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	/*For nCont := 1 To 7
		If ( Dow(dDtaAux+nCont) == 1 )
			dIniSem := dDtaAux
			dFimSem := (dDtaAux+nCont)
			Exit		
		EndIf
	Next*/
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define qual a data inicial/final da Semana				   ³
	| As semanas sao criadas conforme o periodo selecionado		   |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/	
	dFimSem := (dIniSem+6)
	
	aAdd( aSemana, { dIniSem, dFimSem, {} } )
	
	dIniSem := (dFimSem+1)
	
EndDo

Return (NIL)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fSepVerSem³Autor³Igor Franzoi		        ³Data³24/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Separa as verbas, por semana e totaliza a semana			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fSepVerSem( aSemana, aTotDia, cVerbasDiarias )

Local nX   	   := 0
Local nCont	   := 0
Local nDia	   := 0	
Local nPosData := 0
Local nPosEven := 0

DEFAULT cVerbasDiarias := ""

For nX := 1 To Len(aTotDia)
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se a data estiver compreendia pela semana, gera esta verba   ³
	³ dentro desta semana e RV_ACUMULA = SIM					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If ( ( ( nPos := aScan( aSemana, { |x| (x[1] <= aTotDia[nX,ATOTAIS_DATA]) .and. (x[2] >= aTotDia[nX,ATOTAIS_DATA] ) } ) ) > 0 ) .and.;
		( !(aTotDia[nX,ATOTAIS_CODIGO_FOLHA] $ cVerbasDiarias) ) )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se existe elemento de verba, verifica se a verba de aTotDia  ³
		³ ja esta na semana										   	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( ( ( nPosEven := aScan( aSemana[nPos,03], { |x| x[03] == aTotDia[nX,ATOTAIS_CODIGO_FOLHA] .and. x[04] == aTotDia[nX,ATOTAIS_CENTRO_DE_CUSTO] .and.;
														     x[07] == aTotDia[nX,ATOTAIS_FUNCAO] 		.and. x[08] == aTotDia[nX,ATOTAIS_DEPTO] .and.;
														     x[09] == aTotDia[nX,ATOTAIS_POSTO] 		.and. x[10] == aTotDia[nX,ATOTAIS_PROCESSO] .and.;
														     x[11] == aTotDia[nX,ATOTAIS_PERIODO] 		.and. x[12] == aTotDia[nX,ATOTAIS_ROTEIRO] .and.;
														     x[13] == aTotDia[nX,ATOTAIS_NUM_PAGTO] ;
									    			   };                 	
								   );
		        ) > 0 );
		   )
		
			aSemana[ nPos, 03, nPosEven , 02 ] := ( aSemana[ nPos, 03, nPosEven, 02 ] + aTotDia[ nX , ATOTAIS_HORAS ] )
			aSemana[ nPos, 03, nPosEven , 05 ] := ( aSemana[ nPos, 03, nPosEven, 05 ] + aTotDia[ nX , ATOTAIS_VALOR ] )
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Coloca nos campos D*(1-7) o resultado conforme a Data		   ³
			³ EX: 01/01/2008 = Terca-Feira, o Evento gerado nesta data,    ³
			³ 	  se localiza no campo D2, caso o inicio do periodo em 	   ³
			³ 	  01/01/2008											   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			nDia := fDiaArray( aTotDia[ nX, ATOTAIS_DATA	] )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Coloca nos campos D*(1-7) o resultado conforme Sequencia	   ³
			³ EX: 01/01/2008 = Terca-Feira, o Evento gerado nesta data,    ³
			³ 	  se localiza no campo D1, caso o inicio do periodo em 	   ³
			³ 	  01/01/2008											   ³			
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/			
			//nDia++
			
			aSemana[ nPos, 03, nPosEven, nDia ] := aTotDia[ nX , ATOTAIS_HORAS	]
		
		Else
		
			aAdd( aSemana[nPos,03], Array(20) )	
				
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 01 ] := aTotDia[ nX , ATOTAIS_EVENTO_PONTO		] //01 - Codigo do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 02 ] := aTotDia[ nX , ATOTAIS_HORAS				] //02 - Quantidade total do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 03 ] := aTotDia[ nX , ATOTAIS_CODIGO_FOLHA		] //03 - Codigo para a Folha
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 04 ] := aTotDia[ nX , ATOTAIS_CENTRO_DE_CUSTO	] //04 - Centro de Custo do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 05 ] := aTotDia[ nX , ATOTAIS_VALOR				] //05 - Valor do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 06 ] := aTotDia[ nX , ATOTAIS_DTOS_DATA			] //06 - String de Data
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 07 ] := aTotDia[ nX , ATOTAIS_FUNCAO		   		] //07 - Funcao do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 08 ] := aTotDia[ nX , ATOTAIS_DEPTO 		   		] //08 - Depto  do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 09 ] := aTotDia[ nX , ATOTAIS_POSTO 				] //09 - Posto  do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 10 ] := aTotDia[ nX , ATOTAIS_PROCESSO 			] //10 - Processo do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 11 ] := aTotDia[ nX , ATOTAIS_PERIODO	 		] //11 - Periodo do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 12 ] := aTotDia[ nX , ATOTAIS_ROTEIRO			] //12 - Roteiro do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 13 ] := aTotDia[ nX , ATOTAIS_NUM_PAGTO			] //13 - NumPagto do Evento
			
			nDia := fDiaArray( aTotDia[ nX, ATOTAIS_DATA	] )
			//nDia := 14
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), nDia ] := aTotDia[ nX , ATOTAIS_HORAS	] 
		
		EndIf
	Else

		If ( ( nPos := aScan( aSemana, { |x| (x[1] <= aTotDia[nX,ATOTAIS_DATA]) .and. (x[2] >= aTotDia[nX,ATOTAIS_DATA] ) } ) ) > 0 )
		
			aAdd( aSemana[nPos,03], Array(20) )	
		
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 01 ] := aTotDia[ nX , ATOTAIS_EVENTO_PONTO		] //01 - Codigo do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 02 ] := aTotDia[ nX , ATOTAIS_HORAS				] //02 - Quantidade total do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 03 ] := aTotDia[ nX , ATOTAIS_CODIGO_FOLHA		] //03 - Codigo para a Folha
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 04 ] := aTotDia[ nX , ATOTAIS_CENTRO_DE_CUSTO	] //04 - Centro de Custo do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 05 ] := aTotDia[ nX , ATOTAIS_VALOR				] //05 - Valor do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 06 ] := aTotDia[ nX , ATOTAIS_DTOS_DATA			] //06 - String de Data
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 07 ] := aTotDia[ nX , ATOTAIS_FUNCAO		   		] //07 - Funcao do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 08 ] := aTotDia[ nX , ATOTAIS_DEPTO 		   		] //08 - Depto  do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 09 ] := aTotDia[ nX , ATOTAIS_POSTO 				] //09 - Posto  do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 10 ] := aTotDia[ nX , ATOTAIS_PROCESSO 			] //10 - Processo do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 11 ] := aTotDia[ nX , ATOTAIS_PERIODO	 		] //11 - Periodo do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 12 ] := aTotDia[ nX , ATOTAIS_ROTEIRO			] //12 - Roteiro do Evento
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), 13 ] := aTotDia[ nX , ATOTAIS_NUM_PAGTO			] //13 - NumPagto do Evento	
	
			nDia := fDiaArray( aTotDia[ nX, ATOTAIS_DATA	] )
			aSemana[ nPos, 03, Len(aSemana[nPos,03]), nDia ] := aTotDia[ nX , ATOTAIS_HORAS	]

		EndIf
				
	EndIf
Next

Return (NIL)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fDiaArray ³Autor³Igor Franzoi		        ³Data³26/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna qual o indice para o array do campo a ser gravado	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fDiaArray( dData )

Local nIndice

Do Case
	Case ( Dow(dData) == 1 )
		nIndice := 20
	Case ( Dow(dData) == 2 )
		nIndice := 14	
	Case ( Dow(dData) == 3 )
		nIndice := 15	
	Case ( Dow(dData) == 4 )
		nIndice := 16	
	Case ( Dow(dData) == 5 )
		nIndice := 17	
	Case ( Dow(dData) == 6 )
		nIndice := 18	
	Case ( Dow(dData) == 7 )
		nIndice := 19	
EndCase

Return nIndice

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGravaSpb ³Autor³Igor Franzoi		        ³Data³26/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Grava os registros no SPB									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGravaSpb( cFil,;
						   cMat,;
						   cProcesso,;
						   cRoteiro,;
						   cPeriodo,;
						   cNumPagto,;
						   cDepto,;
						   cPosto,;
						   cCodFunc,;
						   cVerba,;
						   aCodAut,;
						   aCodRef,;
						   aRegSpb,;
						   aSemana,;
						   cVerbasDiarias )
						   

Local lRet    := .F.
Local nSem    := 0
Local nVer	  := 0
Local nPosSpb := 0

For nSem := 1 To Len(aSemana)
	If ( Len(aSemana[nSem,03]) > 0 )
		For nVer := 1 To Len(aSemana[nSem,03])			
			If ( ( aSemana[ nSem, 03, nVer, 02 ] > 0 ) .and. ;
				( ( aScan(aCodAut, { |x| x[1] == aSemana[ nSem, 03, nVer, 01 ]  .and. !Empty(x[13]) } ) ) > 0 )	)	
				If ( ;
					( ( nPosSpb := aScan(aRegSpb, {|x| x[01] == aSemana[ nSem, 01 ] .and. x[02] == aSemana[ nSem, 03, nVer, 03 ] .and.;
													x[05] == aSemana[ nSem, 03, nVer, 04 ] .and. x[08] == aSemana[ nSem, 03, nVer, 07 ] .and.;
													x[09] == aSemana[ nSem, 03, nVer, 08 ] .and. x[10] == aSemana[ nSem, 03, nVer, 09 ] .and.;
													x[11] == aSemana[ nSem, 03, nVer, 10 ] .and. x[12] == aSemana[ nSem, 03, nVer, 12 ] .and.;
													x[13] == aSemana[ nSem, 03, nVer, 11 ] .and. x[14] == aSemana[ nSem, 03, nVer, 13 ] ;
			 								};
		 							)) > 0 );
					)
										
					If ( (aRegSpb[nPosSpb,3] # aSemana[ nSem, 03, nVer, 02 ]) .or. (aRegSpb[nPosSpb,6] # aSemana[ nSem, 03, nVer, 05 ]) ) .and. (aRegSpb[nPosSpb,7] <> "I")
						SPB->(dbGoTo(aRegSpb[nPosSpb,4]))
						
						If !SPB->( RecLock( "SPB" , .F. , .T. ) )
							Loop
						EndIf
						
						//SPB->PB_HORAS	:= fConvHr(aSemana[ nSem, 03, nVer, 02 ], "D") //02 - Quantidade total do Evento
						SPB->PB_VALOR   := aSemana[ nSem, 03, nVer, 05 ] //05 - Valor do Evento
						
						If ( aSemana[ nSem, 03, nVer, 05 ] > 0 )
							SPB->PB_TIPO1	:=  "V"
						ElseIf ( aScan( aCodRef, { |x| x == aSemana[ nSem, 03, nVer, 03 ] } ) > 0 ) .or. ( aSemana[ nSem, 03, nVer, 03 ] $ cVerba )
							SPB->PB_TIPO1	:= 	"D"
						Else
							SPB->PB_TIPO1	:=  "H"
						EndIf
						
						SPB->PB_CODFUNC := aSemana[ nSem, 03, nVer, 07 ] //07 - Funcao do Evento
						SPB->PB_DEPTO   := aSemana[ nSem, 03, nVer, 08 ] //08 - Depto  do Evento
						SPB->PB_POSTO   := aSemana[ nSem, 03, nVer, 09 ] //09 - Posto  do Evento
						SPB->PB_PROCES  := aSemana[ nSem, 03, nVer, 10 ] //10 - Processo do Evento
						SPB->PB_PERIODO := aSemana[ nSem, 03, nVer, 11 ] //11 - Periodo do Evento
						SPB->PB_ROTEIR  := aSemana[ nSem, 03, nVer, 12 ] //12 - Roteiro do Evento
						SPB->PB_SEMANA  := aSemana[ nSem, 03, nVer, 13 ] //13 - NumPagto do Evento
		
						SPB->PB_D1 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 14 ]), 0, aSemana[ nSem, 03, nVer, 14 ]), "D") //14 - Segunda
						SPB->PB_D2 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 15 ]), 0, aSemana[ nSem, 03, nVer, 15 ]), "D") //15 - Terca
						SPB->PB_D3 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 16 ]), 0, aSemana[ nSem, 03, nVer, 16 ]), "D") //16 - Quarta
						SPB->PB_D4 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 17 ]), 0, aSemana[ nSem, 03, nVer, 17 ]), "D") //17 - Quinta
						SPB->PB_D5 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 18 ]), 0, aSemana[ nSem, 03, nVer, 18 ]), "D") //18 - Sexta
						SPB->PB_D6 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 19 ]), 0, aSemana[ nSem, 03, nVer, 19 ]), "D") //19 - Sabado
						SPB->PB_D7 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 20 ]), 0, aSemana[ nSem, 03, nVer, 20 ]), "D") //20 - Domingo
							
						SPB->PB_HORAS	:= SPB->PB_D1 + SPB->PB_D2 + SPB->PB_D3 + SPB->PB_D4 + SPB->PB_D5 + SPB->PB_D6 + SPB->PB_D7
							
						lRet := .T.

					EndIf

					aDel(aSPB, nPosSpb)
					aSize(aSPB, Len(aSPB)-1)
	
				ElseIf !Empty( aSemana[ nSem, 03, nVer, 03 ] )
				
					SPB->( RecLock( "SPB" , .T. ) )
					
					SPB->PB_FILIAL  := cFil
					SPB->PB_MAT     := cMat
					
					If !(aSemana[ nSem, 03, nVer, 03 ] $ cVerbasDiarias)
						SPB->PB_DATA    := aSemana[ nSem, 01 ]
					Else
						SPB->PB_DATA    := StoD(aSemana[ nSem, 03, nVer, 06 ])
					EndIf
					
					//SPB->PB_HORAS	:= fConvHr( aSemana[ nSem, 03, nVer, 02 ], "D" ) //02 - Quantidade total do Evento

					If ( aSemana[ nSem, 03, nVer, 05 ] > 0 )
						SPB->PB_TIPO1	:=  "V"
					ElseIf ( aScan( aCodRef, { |x| x == aSemana[ nSem, 03, nVer, 03 ] } ) > 0 ) .or. ( aSemana[ nSem, 03, nVer, 03 ] $ cVerba )
						SPB->PB_TIPO1	:= 	"D"
					Else
						SPB->PB_TIPO1	:=  "H"
					EndIf
					
					SPB->PB_TIPO2  := "G"				
					SPB->PB_PD      := aSemana[ nSem, 03, nVer, 03 ] //03 - Codigo para a Folha
					SPB->PB_CC      := aSemana[ nSem, 03, nVer, 04 ] //04 - Centro de Custo do Evento
					SPB->PB_VALOR   := aSemana[ nSem, 03, nVer, 05 ] //05 - Valor do Evento

					SPB->PB_CODFUNC := aSemana[ nSem, 03, nVer, 07 ] //07 - Funcao do Evento
					SPB->PB_DEPTO   := aSemana[ nSem, 03, nVer, 08 ] //08 - Depto  do Evento
					SPB->PB_POSTO   := aSemana[ nSem, 03, nVer, 09 ] //09 - Posto  do Evento
					SPB->PB_PROCES  := aSemana[ nSem, 03, nVer, 10 ] //10 - Processo do Evento
					SPB->PB_PERIODO := aSemana[ nSem, 03, nVer, 11 ] //11 - Periodo do Evento
					SPB->PB_ROTEIR  := aSemana[ nSem, 03, nVer, 12 ] //12 - Roteiro do Evento
					SPB->PB_SEMANA  := aSemana[ nSem, 03, nVer, 13 ] //13 - NumPagto do Evento
				
					SPB->PB_D1 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 14 ]), 0, aSemana[ nSem, 03, nVer, 14 ]), "D") //14 - Segunda
					SPB->PB_D2 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 15 ]), 0, aSemana[ nSem, 03, nVer, 15 ]), "D") //15 - Terca
					SPB->PB_D3 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 16 ]), 0, aSemana[ nSem, 03, nVer, 16 ]), "D") //16 - Quarta
					SPB->PB_D4 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 17 ]), 0, aSemana[ nSem, 03, nVer, 17 ]), "D") //17 - Quinta
					SPB->PB_D5 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 18 ]), 0, aSemana[ nSem, 03, nVer, 18 ]), "D") //18 - Sexta
					SPB->PB_D6 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 19 ]), 0, aSemana[ nSem, 03, nVer, 19 ]), "D") //19 - Sabado
					SPB->PB_D7 := fConvHr(If( Empty(aSemana[ nSem, 03, nVer, 20 ]), 0, aSemana[ nSem, 03, nVer, 20 ]), "D") //20 - Domingo
						
					SPB->PB_HORAS	:= SPB->PB_D1 + SPB->PB_D2 + SPB->PB_D3 + SPB->PB_D4 + SPB->PB_D5 + SPB->PB_D6 + SPB->PB_D7
						
					lRet := .T.
					
				EndIf
				SPB->( MsUnlock() )			
			EndIf				
		Next
	EndIf
Next

Return (lRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Pnm400TrnP	 	³Autor³  Igor Franzoi	  ³ Data ³07/02/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir o parametro MV_PAR01 para variavel private		³
|		   |cProcesso    											    |
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pnm070TrnP()

cProcesso := &( ReadVar() )

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Pnm400VP  ³Autor³Igor Franzoi               ³Data³06/02/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Periodo digitado na Consulta Padrao				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pnm070VP()

Local cOldAlias := Alias()
Local cFilRCH	:= xFilial("RCH")
Local cMsg

Local lRet 		:= .T.

Begin Sequence

	IF !( lRet := NaoVazio() )
		Break
	EndIF

	DbSelectArea( "RCH" )
	RCH->( dbsetOrder( Retorder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+DTOS(RCH_DTFECH)" ) ) )
	RCH->( dbSeek( cFilRCH + MV_PAR01 + MV_PAR02 + SPACE(6) , .F. ) )

	If RCH->( Eof() )
		lRet := .F.
		cMsg := STR0037	// "Periodo nao Cadastrado!"
		MsgInfo( cMsg )
	Else
		cPeriodo := MV_PAR02 
	EndIf

End Sequence
	
DbSelectArea(cOldAlias)

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGeraRFK  ³Autor³Leandro Drumond            ³Data³16/08/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Inclui no array aTotais eventos da RFK.      				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                       		                  	   			³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGeraRFK( aTot , nHors , cFil , cMat , dData , cPD , cProc , cRoteiro , cPer , cNumPag )

Local aArea 	:= GetArea()
Local cSeekKey 	:= ''

//So executa se existir a tabela RFK
If VerRFKStruct()

	cSeekKey := xFilial('RFK') + cMat + DtoS(dData) + cPD + cProc + cPer + cRoteiro + cNumPag
	
	If RFK->(dbSeek(cSeekKey))
	
		While RFK->(!Eof() .and. RFK_FILIAL+RFK_MAT+DtoS(RFK_DATA)+RFK_PD+RFK_PROCES+RFK_PERIOD+RFK_ROTEIR+RFK_NUMPAG == cSeekKey )
	
			( "RFK" )->(;
							fGeraTot(			@aTot	 		,;	//01 -> Array com os Totais do Ponto
												dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
												RFK_HRSINF		,;	//03 -> Horas para Soma ou Geracao
												0				,;	//04 -> Valor para Soma ou Geracao
												RFK_PDI			,;	//05 -> Evento do Ponto para Pesquisa
												RFK_CC			,;	//06 -> Centro de Custo para Comparacao
												cFil			,;	//07 -> Filial para Pesquisa no SP9
												NIL				,;	//08 -> Verba da Folha
												NIL				,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
												RFK_CODFUN 		,;	//10 -> Funcao para Comparacao
												RFK_DEPTO		,;	//11 -> Depto  para Comparacao   
												RFK_POSTO 		,;	//12 -> Posto  para Comparacao   
												cProc			,;	//13 -> Processo para Comparacao   
												cRoteiro		,;	//14 -> Roteiro para Comparacao   
												cPer			,;	//15 -> Periodo para Comparacao   
												cNumPag		 	;	//16 -> NumPagto para Comparacao  															
											 );
								)
								
			nHors := __TimeSub( nHors , RFK->RFK_HRSINF )
			
			RFK->(dbSkip())
		
		EndDo
	EndIf
EndIf

RestArea(aArea)

Return Nil

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³VerRFKStruct³Autor³Leandro Drumond          ³Data³09/12/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica existencia da tabela RFK.		      				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                       		                  	   			³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function VerRFKStruct()

Local aArea		:= GetArea()
Local aSX3Area  := SX3->(GetArea())
Local lRet		:= .F.

SX3->(DbSetOrder(2))

If SX3->( dbSeek("RFK_MAT"))
	lRet := .T.
EndIf

RestArea(aSX3Area)
RestArea(aArea)

Return (lRet)
