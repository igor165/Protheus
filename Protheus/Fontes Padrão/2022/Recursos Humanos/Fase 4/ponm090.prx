#INCLUDE "PONM1090.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "PONCALEN.CH"
    
Static lPnm090CposBlock	:= ExistBlock( "PNM090CPOS" )
Static oTmpLog
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se a Execucao eh no AS/400                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
#IFDEF TOP
	Static lExInAs400 := ExeInAs400()
#ENDIF



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ PONM090  ³ Autor ³Marinaldo de Jesus     ³ Data ³14/05/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Fechamento Mensal                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ SIGAPON							   						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Mauricio MR ³08.08.01³      ³ Criado Tratamento para Acumular Refeicao ³±±
±±³Marinaldo   ³15/10/01³Melhor³ Destravar corretamente os Registros Trava³±±
±±³            ³--------³------³ dos com RecLock()                        ³±±
±±³Marinaldo   ³16/10/01³Melhor³ Retirada da referencia a Funcao  RetSeq()³±±
±±³            ³--------³------³ que era utilizada para retornar a  primei³±±
±±³            ³--------³------³ ra Sequencia do Proximo Periodo de Aponta³±±
±±³            ³--------³------³ mento. A proxima sequencia sera obtida  a³±±
±±³            ³--------³------³ partir do Proprio Calendario de Marcacoes³±±
±±³            ³--------³------³ e Gravar Registro na Tabela de Trocas  de³±±
±±³            ³--------³------³ Turno onde constarao o Ultimo Turno/Seque³±±
±±³            ³--------³------³ cia Trabalhado x Proximo Turno/Sequencia ³±±
±±³Marinaldo   ³16/10/01³Acerto³ Nao Carregar as Excecoes na Montagem   do³±±
±±³            ³--------³------³ Calendario.		  					  ³±±
±±³Marinaldo   ³16/10/01³Acerto³ Considerar a Data de Admissao Quando a Da³±±
±±³            ³--------³------³ ta do Proximo Periodo for maior que     a³±±
±±³            ³--------³------³ admissao na Tabela de Trocas de Turno.	  ³±±
±±³Marinaldo   ³16/10/01³Melhor³ No Fechamento, alem de atualizar a Sequen³±±
±±³            ³--------³------³ cia de Turno atualizar o Turno.		  ³±±
±±³Marinaldo   ³23/10/01³Melhor³ Inclusao da Funcao Generica  Pn230Acumula³±±
±±³            ³--------³------³ que sera utilizada no Fechamento   Mensal³±±
±±³            ³--------³------³ do Ponto para Acumular os Arquivos    Men³±±
±±³            ³--------³------³ sais e Garantir o Destravamento das  Tabe³±±
±±³            ³--------³------³ las apos o Processo de Fechamento.       ³±±
±±³Marinaldo   ³05/11/01³Acerto³ So deletar dos arquivos de Movimento   os³±±
±±³            ³--------³------³ registros que tenham sido acumulados.    ³±±
±±³Marinaldo   ³06/11/01³010922³Tratamento de Troca de Regra de  Apontamen³±±
±±³            ³--------³------³to.    									  ³±±
±±³Marinaldo   ³23/11/01³Melhor³Nao Mostrar Help em Ma280FLock()    Quando³±±
±±³            ³        ³------³estiver Tentando Travar os Arquivos   para³±±
±±³            ³        ³------³Limpar os Regristros Deletados e nem  abor³±±
±±³            ³        ³------³tar o Programa fPack_Pon()                ³±±
±±³Marinaldo   ³07/02/02³Melhor³Substituicao da Funcao Static  fPack_Pon()³±±
±±³            ³        ³------³Pela Funcao Generica fPackGpe()			  ³±±
±±³            ³        ³Acerto³Retirada da verificacao dos campos:  PF_RE³±±
±±³            ³        ³      ³GRADE e PF_REGRAPA, pois esses campos   ja³±±
±±³            ³        ³      ³foram devidamente incluidos no SX3, para a³±±
±±³            ³        ³      ³versao 7.10, atraves do ATUSX.			  ³±±
±±³Marinaldo   ³29/07/02³Acerto³Gravar corretamente a Proxima Sequencia no³±±
±±³            ³        ³      ³Cadastro de Trocas de Turnos  			  ³±±
±±³Marinaldo   ³30/07/02³Melhor³Utilizar GetInfoPosTab() para retornar   a³±±
±±³            ³        ³      ³ultima Ordem do Periodo de Apontamento.   ³±±
±±³            ³        ³      ³Inclusao da referencia ao PONCALEN.CH     ³±±
±±³            ³        ³Acerto³Reinicializar as Variaveis do Calendario  ³±±
±±³Marinaldo   ³03/09/02³Melhor³Atualizar as Perguntas que dependem do  pe³±±
±±³            ³        ³      ³riodo de Apontamento					  ³±±
±±³Marinaldo   ³06/01/03³Melhor³Nao Mostrar mais o nome do funcionario mas³±±
±±³            ³        ³      ³a Evolucao percentual do Fechamento Mensal³±±
±±³            ³        ³      ³para ganho de performance          		  ³±±
±±³            ³        ³      ³Substituicao da processa com uma barra  de³±±
±±³            ³        ³      ³Gauge pela com duas barras				  ³±±
±±³Marinaldo   ³09/04/03³Acerto³Se usuario Tiver informado Troca de  Turno³±±
±±³            ³        ³      ³Para o Inicio do Proximo Periodo, manter a³±±
±±³            ³        ³      ³Troca de Turno Informada pelo usuario     ³±±
±±³Marinaldo   ³16/09/03³Acerto³So Efetuar a Atualizacao do Turno,  Sequen³±±
±±³            ³        ³      ³cia de Turno e Regra apos acumular   todos³±±
±±³            ³        ³      ³os funcionarios de forma a evitar  desposi³±±
±±³            ³        ³      ³cionamento de Registro					  ³±±
±±|Marinaldo   ³21/04/04³Melhor³Tratamento nos Lock dos Registros e Delete|±± 
±±|MauricoMR   ³10/01/07³Melhor³Implementacao de Log de ocorrencias (rela-|±± 
±±|            ³        ³      ³torio), registro de filial/funcionario em |±± 
±±|            ³        ³      ³processamento para posterior retomada no  |±± 
±±|            ³        ³      ³ponto de uma eventual interrupcao e inclu-|±± 
±±|            ³        ³      ³sao de querys para os arquivos abordados. |±± 
±±³Igor Franzoi³10/05/07³      ³Verificar campos a mais para Query p/ SRA ³±±
±±³Leandro DR  ³06/02/08³Melhor³Sumarizacao por processo, roteiro, periodo³±±
±±³ 		   ³		³      ³e num. pagto. Inclusao de perguntes       |±±
±±³Erika K.    ³02/06/08³------³Alteracao no CH para integracao de diciona³±±
±±³ 		   ³		³      ³rios Mexico e R 1.2.                      |±±
±±³Leandro Dr. ³13/08/08³151978³Incluida funcao para ajustar traducao dos ³±±
±±³ 		   ³		³      ³perguntes (SX1).                          |±±
±±º=======================================================================º±± 
±±º                         *** Versao 11.5***                            º±± 
±±º=======================================================================º±± 
±±ºEmerson     ³31/12/10³29618/³Ajuste para nova interface 11. Com a      º±±
±±ºCampos      ³        ³  2010³aplicação do parametro MV_ECMFTPP que     º±±
±±º            ³        ³      ³afirma ser a versão 11.5 do Protheus      º±±
±±³Leandro Dr. ³26/12/11³TEGACJ³Ajuste no nome do arquivo de log para que ³±±
±±³ 		   ³		³      ³seja possivel o fechamento simultaneo de  |±±
±±³ 		   ³		³      ³dois processos.							  |±±
±±³Cícero Alves³05/03/15³TRUFR3³Retirada da função AjustaSX1			  ³±±
±±³ 		   ³		³      ³										  |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Ponm090()

Local aArea			:= GetArea()
Local aSraArea		:= SRA->(GetArea())
Local aButtons		:= {}  

Local aExclusFiles	:= {} 

Local nLoop
Local nLoops     
Local cDbfLog		:= "P90LOG"  
Local cMens			:= ""   
Local cSvFilAnt		:= cFilAnt
Local lLocked		:= .F.
Local lBarG1ShowTm 	:= .F.
Local lBarG2ShowTm 	:= .F.  
Local lRetomaProcess:= .F.		
Local nOpcA			:= 0

Local cMsgInfo			:=  STR0047  //"Outro usuário está utilizando a rotina de Fechamento Mensal."
Local cMayIUseCode		:= ""

DEFAULT lPnm090CposBlock := ExistBlock( "PNM090CPOS" )

Private cCadastro   := OemToAnsi(STR0001)	// "Fechamento do Ponto"
Private aLogfile	:= {}  					// Array para conter as ocorrencias a serem impressas  
Private cAuxInd		:= "" 					// Variavel auxiliar para apagar o arquivo de indice do LOG

Private oPeriodo	:= RHPERIODO():New()

Private	cProcesso	:=	""
Private	cPeriodo	:=  ""
Private	cRoteiro	:= 	""
Private	cNumPagto	:= 	""
Private nMarcProc	:= 	0
Private dPerIni		:= Ctod("//")
Private dPerFim		:= Ctod("//")

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Ajusta Estruturas											   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !PonStruct( Nil, Nil, {|x|( VerRFAStruct() .and. VerSP5Struct() ) } )
	   Break
	Endif

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ So Executa se os Modos de Acesso dos Arquivos Relacionados es³
	³ tiverm OK e se Tiver Funcionario Cadastrado no SRA.          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF !(;
			ValidArqPon();								//Verifica o Modo de Acesso dos Arquivos
			.and.;              	
			ChkVazio("SRA");							//O SRA nao pode estar vazio	
		)	
		Break
	EndIF

	#IFDEF TOP
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Abre arquivo de log de interrupcao                           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !fOpenLog(@cDbfLog)
			AADD(aLogFile, STR0039) // "Nao foi possivel criar arquivo de registro de ocorrencias."
			Break
		Else
		    (cDbfLog)->(DbGoTop())  
		    /*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se houve interrupcao do processamento antes de encerra-lo			³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

	        IF  fVerPerOpen(cDbfLog)                                                  
		         /*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Abre Janela e Exibe os dados da uitima Filial/Funcionario Lidos quando ocorreu³
				³ a interrupcao.																³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	        	lRetomaProcess := ShowOnFech(cCadastro, cDbfLog)
	        EndIF	

		EndIF	 
	#ENDIF 	

	 /*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Abre Janela e Exibe os dados referentes as filiais a serem processadas.       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/	
	If !ShowPonMes(  cCadastro, ,lRetomaProcess, cDbfLog )
		#IFDEF TOP
			(cDbfLog)->(dbCloseArea())
		#ENDIF
		Break	//Usuario nao confirmou o Fechamento
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Um "processo/roteiro/periodo/num pagto" nao pode ser executado|
	|mais que uma vez simultaneamente					 		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cMayIUseCode := cProcesso + cRoteiro + cPeriodo + cNumPagto

	IF !( lPonm090 := WhileYesNoWait(;
					 					{ || MayIUseCode( cMayIUseCode ) }	,;	//Bloco a Ser Executando Enquando ( Devera Retornar Valor Logico )
					 					1000								,;	//Numero de Tentativas
					 					.T.									,;	//Se podera Encerrar as as Tentativas ( Button Cancel Enabled )
					 					cMsgInfo							,;	//Mensagem de Corpo para a MsgInfo
					 					cCadastro							,;	//Titulo para a MsgInfo 
					 					NIL									,;	//Mensagem de Corpo para a MsgYesNo //"Tentar novamente?"
					 					cCadastro							,;	//Titulo para a MsgYesNo
					 					NIL									,;	//Mensagem de corpo para a ProcWaiting //"Tentanto executar novamente."
					 					cCadastro							 ;	//Titulo para a ProcWaiting
					 				  );
		)										
		Break
	EndIF

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se deve Mostrar Calculo de Tempo nas BarGauge			 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	lBarG1ShowTm := ( SuperGetMv("MV_PNSWTG1",NIL,"N") == "S" )
	lBarG2ShowTm := ( SuperGetMv("MV_PNSWTG2",NIL,"S") == "S" )
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Processa o Fechamento Mensal do Ponto                        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	Proc2BarGauge( { |lEnd| Pnm090Processa( lRetomaProcess, cDbfLog ) } , cCadastro , NIL , STR0019 , .F. , lBarG1ShowTm , lBarG2ShowTm )	//"Processados:"

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Libera o Codigo Exclusivo ja Utilizado						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
Leave1Code ( cMayIUseCode )  
	
		
cFilAnt := cSvFilAnt
RestArea( aArea )
RestArea( aSraArea )                                         	

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PONM090Processa³Autor³Marinaldo de Jesus	³ Data ³14/05/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Processa o Fechamento Mensal do Ponto Eletronico           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ SIGAPON							             			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Pnm090Processa( lRetomaProcess, cDbfLog )

Local aTabCalend	:= {}
Local aTabPadrao	:= {}   
Local aTurnos		:= {}
Local aPeriodos		:= {}
Local aInfo			:= {}	
Local aRecsSRA		:= {} 
Local aNextPer		:= {}
Local aAreaRFA		:= {}

#IFDEF TOP
 	Local aCposSRA		:= {}
	Local aStruSRA		:= {}  
	Local aTempSRA		:= SRA->( dbStruct() )
	Local cQuery	 	:= ""
	Local cFixQuery		:= ""	
	Local cSRAIndexKey	:= ""   
	Local lSraQryOpened	:= .F.
	Local nContField	:= Len(aTempSRA)
	Local uRet			:= NIL
	Local nX     
	Local cMsgYesNo     := ""
#ENDIF  

Local adbStructs	:= Array( 04 , 05 )
Local bSraWhile		:= { || .T. }
Local bWhileP5PN	:= { || .T. }
Local bCondP5PN		:= { || .T. }
Local bWhileP8PG	:= { || .T. }
Local bCondP8PG		:= { || .T. }
Local bWhilePCPH	:= { || .T. }
Local bCondPCPH		:= { || .T. }
Local bWhilePBPL	:= { || .T. }
Local bCondPBPL		:= { || .T. }  

Local cAliasSRA		:= "SRA"	
Local cCampos		:= ""
Local cFilMat		:= ""
Local cFil			:= ""
Local cMat			:= ""
Local cChave		:= ""
Local dUltDataApo	:= Space( TamSx3( "P8_DATAAPO  " )[1] )
Local cFilDe		:= ""
Local cFilAte		:= ""
Local cLastFil		:= "__cLastFil__"   
Local cSvOldFil		:= cFilAnt
Local cTimeIni		:= Time()
Local cNextTno 		:= ""
Local cNextSeq 		:= ""
Local cNextReg 		:= ""
Local cLastTno 		:= ""
Local cLastSeq 		:= ""
Local cLastReg 		:= ""
Local cNextPer		:= "" 
Local cNextTnoSra	:= ""
Local cNextSeqSra	:= ""
Local cNextRegSra   := ""
Local cMsgBarG1		:= ""
Local cMsgPer		:= ""
Local cMsgErr		:= ""
Local dNextPerIni	:= Ctod("//")
Local dNextPerFim	:= Ctod("//")
Local dNextTroca	:= Ctod("//")
Local dLasPer		:= Ctod("//")
Local lAtuSeq		:= .F.
Local lPerCompleto	:= .F.
Local lDeleted		:= .T.
Local nOrdemSP5		:= RetOrdem( "SP5" )
Local nOrdemSP8		:= RetOrdem( "SP8" )
Local nOrdemSPB		:= RetOrdem( "SPB" )
Local nOrdemSPC		:= RetOrdem( "SPC" )
Local nOrdemSRA		:= RetOrdem( "SRA" , "RA_FILIAL+RA_TNOTRAB" )
Local nTamCalen		:= 0.00
Local nPeriodo		:= 0.00
Local nPeriodos		:= 0.00
Local nLastRec		:= 0.00
Local nIncPercG1	:= 0.00
Local nIncPercG2	:= 0.00
Local nRecsBarG		:= 0.00
Local nLoop			:= 0.00
Local nLoops		:= 0.00 
Local nPosTurno		:= 0.00 
Local nPosTab		:= 0.00 
Local nFunProc		:= 0
Local nOrd			:= 0
Local nHorFim		:= 0.00
Local nPerAntNext	:= 0

Private nTotRegs		:= 0 			// Total de Registros
Private nTotFunc		:= 0			// Total de Funcionarios Acumulados no campo de controle
Private cMesProc   		:= "  "			// Mes do Fechamento
Private cAnoProc    	:= "    "		// Ano do Fechamento
Private lNextPer   		:= .T.			// Proximo Periodo de fechamento esta OK 

If FindFunction("SPFilterOff")   //   Alteracao referente ao projeto: SuperFiltro
   SPFilterOff( { "SRA" } )      //   Desabilita filtro no alias - SRA.
EndIf

dNextPerIni := ( dPerFim + 1 ) 
dNextPerFim := dNextPerIni 

cChave := cProcesso + cRoteiro + cPeriodo + cNumPagto
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Monta os Blocos Condicionais para o Acumulado de Refeicoes    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
bWhileP5PN	:= { || P5_FILIAL + P5_MAT == cFilMat }
bCondP5PN	:= { || (;
					 fDHtoNS(P5_DATA, P5_HORA) <= fDHtoNS(dLasPer, nHorFim) ) .or. ;
					 (cAliasSRA)->( RA_SITFOLH == "D" .and. RA_DEMISSA <= dPerFim ;
					 );
				}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega a Estrutura do SPN ( Acumulado de Refeicoes )         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
adbStructs[ 01 , 01 ] := "SPN"
adbStructs[ 01 , 02 ] := SPN->( dbStruct() )
adbStructs[ 01 , 03 ] := SP5->( dbStruct() ) 
adbStructs[ 01 , 04 ] := {||"SELECT " + adbStructs[ 01 , 05 ] + " FROM "		 + InitSqlName("SP5")+" SP5 "	+;
									"WHERE "+;
										"SP5.P5_FILIAL = '"+ cFil+ "' AND SP5.P5_MAT = '"+ cMat +"' " +; 
										"AND ( "+; 
											"SP5.D_E_L_E_T_ = ' ' "+;
											")";	
						  }				
adbStructs[ 01 , 05 ]	:= fCampos("SP5",adbStructs[ 01 , 03 ]) 

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Monta os Blocos Condicionais para o Acumulado de Marcacoes	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
bWhileP8PG	:= { || P8_FILIAL + P8_MAT == cFilMat  }
                  
bCondP8PG	:= 	{ ||( P8_DATAAPO <= dPerFim  .or. (cAliasSRA)->( RA_SITFOLH == "D" .and. RA_DEMISSA <= dPerFim )) }
		  	     
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega a Estrutura do SPG ( Acumulado de Marcacoes )         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
adbStructs[ 02 , 01 ] := "SPG"
adbStructs[ 02 , 02 ] := SPG->( dbStruct() )
adbStructs[ 02 , 03 ] := SP8->( dbStruct() )
adbStructs[ 02 , 04 ] := {||"SELECT " + adbStructs[ 02 , 05 ] + " FROM "			 + InitSqlName("SP8")+" SP8 "	+;
									"WHERE "+;
										"SP8.P8_FILIAL = '"+ cFil+ "' AND SP8.P8_MAT = '"+ cMat +"' " +; 
										"AND ( "+; 
											"SP8.D_E_L_E_T_ = ' ' "+;
											")";	
						  }
adbStructs[ 02 , 05 ]	:= fCampos("SP8",adbStructs[ 02 , 03 ]) 						  

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Monta os Blocos Condicionais para o Acumulado de Apontamentos ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
bWhilePCPH	:= { || PC_FILIAL + PC_MAT == cFilMat }
bCondPCPH	:= { || PC_DATA <= dPerFim .or. (cAliasSRA)->( RA_SITFOLH == "D" .and. RA_DEMISSA <= dPerFim ) }

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega a Estrutura do SPH ( Acumulado de Apontamentos )      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
adbStructs[ 03 , 01 ] := "SPH"
adbStructs[ 03 , 02 ] := SPH->( dbStruct() )
adbStructs[ 03 , 03 ] := SPC->( dbStruct() ) 
adbStructs[ 03 , 04 ] := {||"SELECT " + adbStructs[ 03 , 05 ] + " FROM "			 + InitSqlName("SPC")+" SPC "	+;
									"WHERE "+;
										"SPC.PC_FILIAL = '"+ cFil+ "' AND SPC.PC_MAT = '"+ cMat +"' " +; 
										"AND ( "+; 
											"SPC.D_E_L_E_T_ = ' ' "+;
											")";	
						  }
adbStructs[ 03 , 05 ]	:= fCampos("SPC",adbStructs[ 03 , 03 ]) 						  						  
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Monta os Blocos Condicionais para o Acumulado de Resultados   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
bWhilePBPL	:= { || PB_FILIAL + PB_MAT == cFilMat }
bCondPBPL	:= { || PB_DATA <= dPerFim }

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega a Estrutura do SPH ( Acumulado de Resultados )        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
adbStructs[ 04 , 01 ] := "SPL"
adbStructs[ 04 , 02 ] := SPL->( dbStruct() )
adbStructs[ 04 , 03 ] := SPB->( dbStruct() ) 
adbStructs[ 04 , 04 ] := {||"SELECT " + adbStructs[ 04 , 05 ] + " FROM "			 + InitSqlName("SPB")+" SPB "	+;
									"WHERE "+;
											"SPB.PB_FILIAL = '" + cFil +"' AND SPB.PB_MAT ='" + cMat + "' " +; 
									"AND "+;
											"(SPB.PB_DATA <= '" + Dtos(dPerFim) + "')" +;
									"AND ( "+; 
											"SPB.D_E_L_E_T_ = ' ' "+;
										")";		
						  }
adbStructs[ 04 , 05 ]	:= fCampos("SPB",adbStructs[ 04 , 03 ]) 						  						  						  
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega os Campos dos Arquivos Mensais e suas Respectivas posi³
³coes														   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Ponm090CposMes( @adbStructs )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega Perguntas                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Pergunte("PONM090",.F.)

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Se for uma reAlimenta Variaveis de Memoria com o Conteudo das Perguntas    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

If  lRetomaProcess	                
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Alimenta Variaveis de Memoria com o Conteudo das Perguntas    ³
	³Se nao existir registro da filial do funcionario espera-se    ³
	³que todas as filais tenham sido processadas restanto apenas   ³
	³o registro do novo periodo de apontamento. Por seguranca      ³
	³reprocessamos a ultima filial.								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/ 
	cProcesso	:=	(cDbfLog)->PROCESSO
	cPeriodo	:=  (cDbfLog)->PERIODO
	cRoteiro	:= 	(cDbfLog)->ROTEIRO
	cNumPagto	:= 	(cDbfLog)->NUMPAGTO
	nTotRegs	:= 	Val((cDbfLog)->TOTREG)
	nTotFunc	:=  Val((cDbfLog)->TOTFUN)

Else
 	cProcesso	:=	MV_PAR01
	cPeriodo	:=  MV_PAR02
	cRoteiro	:= 	MV_PAR03
	cNumPagto	:= 	MV_PAR04
Endif	
	
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega Log do Inicio do Processo de Fechamento			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aAdd(aLogFile, STR0048  + Dtoc(MsDate()) + ', as ' + Time() + '.') //"- Inicio do Fechamento Mensal em "
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Atualiza a Mensagem para a IncProcG1() (Cadastro de Empresas)³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
CREATE SCOPE aInfo FOR ( M0_CODIGO == cEmpAnt )

BarGauge1Set( ( nRecsBarG := SM0->( ScopeCount( aInfo ) ) ) )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Seta a Ordem do Cadastro de Funcionarios                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
SRA->( dbSetOrder( nOrdemSRA ) )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Apura Numero de Funcionarios a serem Processados			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
#IFDEF TOP                      
	IF	!lExInAs400
		cSRAIndexKey := SRA->( IndexKey() )
	    AADD(aCposSRA, "RA_FILIAL"		)
	    AADD(aCposSRA, "RA_MAT"			)
	    AADD(aCposSRA, "RA_CC"			)
	    AADD(aCposSRA, "RA_TNOTRAB"		)    
	    AADD(aCposSRA, "RA_SEQTURN"		)
	    AADD(aCposSRA, "RA_REGRA"		)
	    AADD(aCposSRA, "RA_SITFOLH"		)
	    AADD(aCposSRA, "RA_DEMISSA"		)
	    AADD(aCposSRA, "RA_ADMISSA"		)

		If cPaisLoc == "MEX"
			aAdd( aCposSRA , "RA_FECREI"  	)
		EndIf
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica e Seta os campos a mais incluidos no Mex             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/				
		fAdCpoSra(aCposSra)	    
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ponto de Entrada para Campos do Usuario                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lPnm090CposBlock )
			IF ( ValType( uRet := ExecBlock("PNM090CPOS",.F.,.F.,aCposSRA) ) == "A" )
				IF Len( uRet ) >= Len( aCposSRA )
					aCposSRA := aClone(uRet)
					uRet	 := NIL
				EndIF
			EndIF
		EndIF
	   
		For nX := 1 To nContField
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega os Campos do SRA para a Montagem da Query			   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF aScan( aCposSRA , { |x| Upper(AllTrim(x)) == Upper( AllTrim( aTempSRA[ nX , 1 ] ) ) } ) > 0.00
				aAdd( aStruSRA , aClone( aTempSRA[ nX ] ) )
			EndIF
		Next nX
		aCposSRA	:= aTempSRA := NIL
	    
		nContField:= Len(aStruSRA)
		
		cQuery:= "SELECT "
		
		For nX := 1 To nContField
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inclui os Campos na Montagem da Query						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cQuery += aStruSRA[ nX , 1 ] + ", "
		Next nX                   
	
	   	cQuery += "R_E_C_N_O_ RECNO "
		cQuery += "FROM "+InitSqlName("SRA")+" SRA "   
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta a Query Condicional             					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/ 
		cFixQuery := "SRA.RA_PROCES='"+cProcesso+"'"
		cFixQuery += " AND "
		cFixQuery += "SRA.D_E_L_E_T_=' ' "

		cQuery += "WHERE "
		cQuery += cFixQuery

		cQuery += "ORDER BY "+SqlOrder( cSRAIndexKey )
		cQuery := ChangeQuery(cQuery)    
	EndIF    

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta e Abre a Query    									   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/  
	IF	!lExInAs400  
	    cAliasSRA:=( "__Q" + "SRA" + "QRY" )
		IF ( lSraQryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSRA,.T.,.T.) )
	
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Seta os Campos que nao Sao Caracteres						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			For nX := 1 To nContField
				IF ( aStruSRA[nX,2] <> "C" )
					TcSetField(cAliasSRA,aStruSRA[nX,1],aStruSRA[nX,2],aStruSRA[nX,3],aStruSRA[nX,4])
				EndIF
			Next nX
		
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica o Total de Registros a Serem Processados            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cQuery := "SELECT COUNT(*) NLASTREC "
			cQuery += "FROM "+InitSqlName("SRA")+" SRA "  

			cQuery += "WHERE "
			cQuery += cFixQuery

			cQuery := ChangeQuery(cQuery)
	     
	        IF ( MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),"__QRYCOUNT",.T.,.T.) )
				nLastRec := __QRYCOUNT->NLASTREC
				__QRYCOUNT->( dbCloseArea() )
	        Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Apenas quando  for uma retomada de processo.                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF lRetomaProcess
					
					CREATE SCOPE aRecsSRA FOR ( RA_PROCES = cProcesso )
					//"Aguarde! "###"Selecionando Funcionarios..."
					MsAguarde( { || nLastRec := SRA->( ScopeCount( aRecsSRA ) ) } , STR0020 + STR0014 )
				
				Else
			
					nLastRec := SRA->( RecCount() )
			
				EndIF
				SRA->( dbGotop() )
			EndIF
			cFixQuery := ""	
		
		EndIF
	EndIF
	
	IF !lSraQryOpened
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Restaura Arquivo Padrao 			                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cAliasSRA:= "SRA"
		dbSelectArea(cAliasSRA)
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Apenas quando o SPO nao for compartilhado ou se for uma reto-³
		³ mada de processo.    						                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF lRetomaProcess
			
			CREATE SCOPE aRecsSRA FOR ( RA_PROCES = cProcesso )
			//"Aguarde! "###"Selecionando Funcionarios..."
			MsAguarde( { || nLastRec := (cAliasSRA)->( ScopeCount( aRecsSRA ) ) } , STR0020 + STR0014 )
		
		Else
	
			nLastRec := (cAliasSRA)->( RecCount() )
	
		EndIF
	EndIF	
#ELSE

	nLastRec := (cAliasSRA)->( RecCount() )

#ENDIF

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Reinicializa aRecsSRA que sera utilizada para armazenar a Pro³
³ ximo Turno/Sequencia e Regra								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRecsSRA := {}                                 

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inicializa a Mensagem para a IncProcG2() ( Funcionarios )	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IncProcG2( OemToAnsi( STR0015 ) , .F. )	//"Processando..."

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inicia regua de processamento.                               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
BarGauge2Set( nLastRec )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Posiciona na Filial                                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/ 
(cAliasSRA)->( dbGotop() )

Begin Sequence
	aNextPer := {}
	If !Ponm090ValFech( @aNextPer , nPerAntNext )
		If !lNextPer
			cMsgPer := oPeriodo:cMsgPerNextNotFound		// "Próximo Período de Apontamento não foi encontrado. Cadastre-o para continuar."
			MsgInfo( cMsgPer , OemToAnsi( STR0007 ) ) 	// "Aten‡„o"
			Break
		Else
			If nPerAntNext == 1
				cMsgPer := oPeriodo:cMsgPerAntOpened    // "Período de Apontamento anterior não foi fechado."
			ElseIf nPerAntNext == 2
				cMsgPer := oPeriodo:cMsgPerNextClosed   // "Próximo Período de Apontamento está fechado."
			EndIf
			MsgInfo( cMsgPer , OemToAnsi( STR0007 ) ) 	// "Aten‡„o"
			Break
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta o Bloco para While no SRA                              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/  
	bSraWhile := { ||( cFil := RA_FILIAL ),( cMat := RA_MAT ), .T. }	

    //ATENCAO: GRAVAR LOG DO PROCESSO
   	#IFDEF TOP  
    		fGravaLog(	cDbfLog		,;  // Alias do arquivo log
						cLastFil	,; 	// Filial do Usuario
						cProcesso	,; 	// Processo do Usuario
						cRoteiro	,; 	// Roteiro do USuario
						cPeriodo	,; 	// Periodo do Usuario
						cNumPagto	,;  // Num Pagto
						""			,;	// Matricula do funcionario em processamento
						""		 	,;	// Turno do funcionario em processamento
						""			,;	// Sequencia do turno do funcionario em processamento
						""			,;	// Regra do funcionario em processamento
						""  	 	;	// Alias em processamento 
			) 
	#ENDIF
	
	While (cAliasSRA)->( !Eof() .and. Eval( bSraWhile )  ) 
	 	/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Caso nao seja o processo definido no pergunte, nao processa  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/ 
        #IFDEF TOP 
			If !lExInAs400
				If !(cAliasSRA)->RA_PROCES == cProcesso
					Loop
				EndIf
			EndIf
		#ENDIF

	 	/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se o processamento foi interrompido anteriormente   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/	
		IF lRetomaProcess           
		   IF ( (cAliasSRA)->(RA_FILIAL + RA_PROCES + RA_TNOTRAB + RA_SEQTURN + RA_REGRA + RA_MAT ) < (cDbfLog)->(FILIAL + PROCESSO + TNOTRAB + SEQTURN + REGRA + MAT) )
		        (cAliasSRA)->(DbSkip())
		        Loop
		   Endif
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Uma vez posicionado no ponto de parada, deixa de consistir os³
			³ demais funcionarios/filial, pois a chave de comparacao       ³
			³ devera ser maior que a inicial, apesar que os funcionarios ja³
			³ processados poderao ser reavaliados no caso do resultado da  ³
			³ troca ser uma nova chave maior que a do ponto da interrupcao.³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/	
			lRetomaProcess	:= .F.   
		Endif

		IF !( cLastFil == cFil )		
	    	aAdd( aLogFile , STR0060 + " " + cFil )	// 'Processo: '			

	    	cLastFil := cFil  
	    	cFilAnt	 := cLastFil
	    		    
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem o % de Incremento da 2a. BarGauge					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			nIncPercG1 := SuperGetMv( "MV_PONINC1" , NIL , 5 , cLastFil )
			/*                         
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem o % de Incremento da 2a. BarGauge					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			nIncPercG2 := SuperGetMv( "MV_PONINCP" , NIL , 5 , cLastFil )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Atualiza a Mensagem para a IncProcG1() 					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cMsgBarG1 := ( STR0060 + " " + cFil + " - " + AllTrim( aInfo[3] ) ) ////"Filial:"			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inicializa Mensagem na 1a BarGauge                           ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IncProcG1( cMsgBarG1 , .F. )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Incrementa a Barra de Gauge referente a Filial				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IncPrcG1Time( cMsgBarG1 , nRecsBarG , cTimeIni , .T. , 1 , nIncPercG1 )
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Movimenta a R‚gua de Processamento                           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IncPrcG2Time( OemToAnsi( STR0019 ) , nLastRec , cTimeIni , .F. , 2 , nIncPercG2 )	//"Processados:"
	
		 /*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Posiciona no funcionario do arquivo SRA Padrao						    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFDEF TOP
			IF ( lSraQryOpened )
				nRecnoSRA := (cAliasSRA)->RECNO
				SRA->( dbGoto( nRecnoSRA ) ) 	
			Else                                   
				nRecnoSRA := 	SRA->( Recno() )
			EndIF
		#ELSE
			nRecnoSRA := 	SRA->( Recno() )
		#ENDIF
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Obtem a Filial e Matricula do Funcionario                              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cFilMat := ( (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT ) 

	 	#IFDEF TOP 
		    		fGravaLog(		cDbfLog						,;  // Alias do arquivo log
									SRA->RA_FILIAL				,; 	// Filial do Usuario
									cProcesso					,; 	// Processo do Usuario
									cRoteiro					,; 	// Roteiro do USuario
									cPeriodo					,; 	// Periodo do Usuario
									cNumPagto					,;  // Num Pagto
									SRA->RA_MAT					,;	// Matricula do funcionario em processamento
									SRA->RA_TNOTRAB		 		,;	// Turno do funcionario em processamento
									SRA->RA_SEQTURN				,;	// Sequencia do turno do funcionario em processamento
									SRA->RA_REGRA				,;	// Regra do funcionario em processamento
									"SRA"  	 					;	// Alias em processamento 
								) 		   

			 /*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Bloqueia o Funcionario no SRA verdadeiro 							    ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/   
			While .T.	
				IF ! PonLockRegs( "SRA", { nRecnoSRA } , { cFilMat }, 5 , 5 ) 
					cMsgYesNo 	:= STR0031	//"Cadastro de funcionários (SRA)em uso por outro usuário."
					cMsgYesNo 	+= CRLF
					cMsgYesNo 	+= STR0032 //"Tentar novamente?"	
					IF MsgYesNo(cMsgYesNo, STR0030) // Atencao
					   Loop
					Endif   
					cMsgYesNo := OemToAnsi(STR0028)+CRLF	//"Não foi possível concluir o processo."	
					MsgAlert( cMsgYesNo , OemToAnsi( STR0007 ) ) //" A  T  E  N  C  A  O "
					
					AADD(aLogFile, STR0031) //"Cadastro de funcionários (SRA)em uso por outro usuário."
					AADD(aLogFile, STR0034 + SRA->RA_MAT + " - " + SRA->RA_NOME) //"Filial/Matricula: " + XX - AAAAAAAAAAAAAAAAAAAAAAAAAAAA
					
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Desbloqueia Registros e Arquivos										³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					 PonFreeLocks( "SRA" , nRecnoSRA ) 
	                Break
				Else
					Exit
				EndIF
			End While 
	  	#ENDIF
			
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Reinicializa Variaveis                                                 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		( aTabCalend := {} , nTamCalen := 0.00 , dUltDataApo := Ctod("//"), aTurnos:= {} )
		
	    /*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se Atualizar a Sequencia, Cria o Calendario de Marcacoes      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lAtuSeq := !(cAliasSRA)->( ( RA_DEMISSA < dPerIni .and. !Empty( RA_DEMISSA ) ) ) )
			
	    	/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Cria o Calendario de Marcacoes do Funcionario                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF SRA->(	CriaCalend(	dPerIni		,; //01 -> Data Inicial do Periodo
									dNextPerFim ,; //02 -> Data Final do Periodo
									RA_TNOTRAB	,; //03 -> Turno Para a Montagem do Calendario
									RA_SEQTURN	,; //04 -> Sequencia Inicial para a Montagem Calendario
									@aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
									@aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
									RA_FILIAL	,; //07 -> Filial para a Montagem da Tabela de Horario
									RA_MAT		,; //08 -> Matricula para a Montagem da Tabela de Horario
									NIL			,; //09 -> Centro de Custo para a Montagem da Tabela
									@aTurnos	,; //10 -> Array com as Trocas de Turno
									NIL			,; //11 -> Array com Todas as Excecoes do Periodo
									NIL 		,; //12 -> Se executa Query para a Montagem da Tabela Padrao
									.F.			,; //13 -> Se executa a funcao se sincronismo do calendario
									.F.			,; //14 -> Se Forca a Criacao de Novo Calendario
									NIL			,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
									NIL			,; //16 -> .T. Determina a Criacao/Carga do Calendario Fisico
									NIL			,; //17 -> .T. Caso exista calendario fisico 
									NIL			,; //18 -> Data inicial do calendario fisico
									NIL			,; //19 -> Data final do calendario fisico 
									.T.			 ; //20 -> .T. determina que o calendario sera gravado no caso de nao existir
								);
					  	)

					  		
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Guarda o Posicionamento do Ultimo dia Do Calendario ( Neste Ca³
				³so o Ultimo dia Corresponde ao Inicio do Proximo Periodo de  A³				
				³pontamento )												   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF ( ( nTamCalen := Len( aTabCalend ) ) > 0.00 )
					
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Obtem Turno, Sequencia e Regra referente ao Primeiro dia do  ³
					³  Novo periodo. Essas informacoes serao utilizadas para criar ³
					³  a troca de turno do primeiro dia do proximo periodo (se for ³
					³  necessario ).											   ³					
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					nPosTab:= 0
					cNextTno := GetInfoPosTab(	CALEND_POS_TURNO		,;	//01 - Posicao em aTabCalend para Obtencao da Informacao
												"1E"					,;	//02 - Flag da Marcacao "1E,1S,..."
												dNextPerIni				,;	//03 - Data em aTabCalend
												aTabCalend			 	,;	//04 - Calendario de Marcacoes
												NIL						,;	//05 -> Tabela de Horario Padrao
												NIL						,;	//06 -> Periodo Inicial de Apontamento
												NIL						,;	//07 -> Periodo Final de Apontamento	
												NIL						,;	//08 -> Informacao Referente a Funcionario
												NIL						,;	//09 -> Turno de Trabalho
												NIL						,;	//10 -> Sequencia
												NIL						,;	//11 -> Filial
												NIL						,;  //12 -> Carrega Excecoes 
												NIL						,;	//13 -> Bloco para Pesquisa em aTabCalend
												@nPosTab				;	//14 -> Retorno da Posicao do aTabCalend 	
					   						  )
					cNextSeq :=  If( Empty(nPosTab), Space(1), aTabCalend[ nPosTab , CALEND_POS_SEQ_TURNO 	] )
					cNextReg  := If( Empty(nPosTab), Space(1), aTabCalend[ nPosTab , CALEND_POS_REGRA	    ] )
												    			 
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Verifica a Ultima Data de Apontamento do Calendario           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					nPosTab:= 0
					dUltDataApo:= GetInfoPosTab(	CALEND_POS_DATA_APO		,;	//01 - Posicao em aTabCalend para Obtencao da Informacao
													"1E"					,;	//02 - Flag da Marcacao "1E,1S,..."
													dPerFim					,;	//03 - Data em aTabCalend
													aTabCalend				,;	//04 - Calendario de Marcacoes
								   					NIL						,;	//05 -> Tabela de Horario Padrao
													NIL						,;	//06 -> Periodo Inicial de Apontamento
													NIL						,;	//07 -> Periodo Final de Apontamento	
													NIL						,;	//08 -> Informacao Referente a Funcionario
													NIL						,;	//09 -> Turno de Trabalho
													NIL						,;	//10 -> Sequencia
													NIL						,;	//11 -> Filial
													NIL						,;  //12 -> Carrega Excecoes 
													NIL						,;	//13 -> Bloco para Pesquisa em aTabCalend
													@nPosTab				;	//14 -> Retorno da Posicao do aTabCalend 	
						   						  )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Obtem Ultimo Turno, Sequencia e Regra do Periodo Atual confor³
					³  me Calendario de Marcacao. Essas informacoes serao utiliza- ³
					³  das para criar a troca de turno do primeiro dia do proximo  ³
					³  periodo ( ser for necessario ).				               ³					
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					cLastTno := If( Empty(nPosTab), Space(1), aTabCalend[ nPosTab , CALEND_POS_TURNO 		] )
					cLastSeq := If( Empty(nPosTab), Space(1), aTabCalend[ nPosTab , CALEND_POS_SEQ_TURNO 	] )
					cLastReg := If( Empty(nPosTab), Space(1), aTabCalend[ nPosTab , CALEND_POS_REGRA	   	] )
					
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Obtem Turno, Sequencia e Regra da Ultima troca do            ³
					³  Novo periodo. Essas informacoes serao utilizadas para atua- ³
					³  lizar o cadastro de funcionarios.					 	   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/ 
					nPosTurno:=0   
					If !Empty(aTurnos)
						aeval(aTurnos,{|x,y| If ( ( x[2]>= dNextPerIni .AND. x[2]<= dNextPerFim ), nPosTurno:=Y, NIL) } )
				   	Endif
				   	/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se nao foi cadastrada troca de turno para o Proximo Periodo  ³
					³ assume a troca projetada para o primeiro dia do Novo periodo.³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/ 
					IF Empty( nPosTurno ) 
						cNextTnoSra	:= cNextTno
						cNextSeqSra	:= cNextSeq
						cNextRegSra := cNextReg 					 
					Else
						cNextTnoSra	:= aTurnos[nPosTurno,1] 
						cNextSeqSra	:= aTurnos[nPosTurno,3]
						cNextRegSra := aTurnos[nPosTurno,5] 
					Endif
					
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Seleciona a data do periodo inicial/final para os lancamentos³
					| de refeicoes a partir do calendario montado para cada	um dos |  
					| funcionarios.												   |
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					
					If (aTabCalend[nPosTab,1] == dPerFim) .and. (aTabCalend[nPosTab,2] == aTabCalend[nPosTab+1,2])					
						nOrd := nPosTab

						Do While aTabCalend[nOrd,2] == aTabCalend[nPosTab,2]
							dLasPer  := aTabCalend[nOrd][CALEND_POS_LIM_MARCACAO][1]
					   		nHorFim  := aTabCalend[nOrd][CALEND_POS_LIM_MARCACAO][2]
							nOrd++
						EndDo
					EndIf					
					
				EndIF
			EndIF
	
		EndIF
	
	    /*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Inicio da  Gravacao dos Acumulados                           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

		  /*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Refeicoes													   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/   
			Ponm090Acumula("SP5","SPN",nOrdemSP5,bWhileP5PN,bCondP5PN,cFilMat,adbStructs, cFil, cMat)
		
		    /*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Marcacoes													   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			Ponm090Acumula("SP8","SPG",nOrdemSP8,bWhileP8PG,bCondP8PG,cFilMat,adbStructs, cFil, cMat)
	       		
		    /*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Apontamentos												   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			Ponm090Acumula("SPC","SPH",nOrdemSPC,bWhilePCPH,bCondPCPH,cFilMat,adbStructs, cFil, cMat)
	
		    /*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Resultados   											   	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			Ponm090Acumula("SPB","SPL",nOrdemSPB,bWhilePBPL,bCondPBPL,cFilMat,adbStructs, cFil, cMat)

			If nMarcProc == 1
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Elimina os Dados do Arquivo de Transferencia				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				fDelRFA()
			EndIf	    
	    /*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Final da Gravacao dos Acumulados                             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		
   		fGravaLog(	cDbfLog			,;  // Alias do arquivo log
					SRA->RA_FILIAL	,; 	// Filial do Usuario
					cProcesso		,; 	// Processo do Usuario
					cRoteiro		,; 	// Roteiro do USuario
					cPeriodo		,; 	// Periodo do Usuario
					cNumPagto		,;  // Num Pagto
					SRA->RA_MAT		,;	// Matricula do funcionario em processamento
					SRA->RA_TNOTRAB	,;	// Turno do funcionario em processamento
					SRA->RA_SEQTURN	,;	// Sequencia do turno do funcionario em processamento
					SRA->RA_REGRA	,;	// Regra do funcionario em processamento
					"SRA"  	 		,;	// Alias em processamento
					nTotRegs		,;  // Total de registros processados para o funcionario
					nTotFunc		,;  // Total de funcionarios processados ate o momento
					.F.	 	 		 ;  // Se .T. grava tudo em branco
				)		

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Atualiza a Sequencia do Proximo Periodo de Apontamento       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( ( lAtuSeq ) .and. ( nTamCalen > 0.00 ) )
			 nFunProc ++
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Ja Existe Troca de Turno para o Inicio do Proximo³
			³ Periodo. Se Nao existir, cria.							   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			dNextTroca	:= Max( dNextPerIni , fDtaAdmis() )
			cNextPer	:= Dtos( dNextTroca )
			IF !SPF->( dbSeek( ( cFilMat + cNextPer ) , .F. ) )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Grava Turno e Sequencia Referente ao Proximo Periodo na Tabela³
				³de Troca de Turno "SPF"									   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF SPF->( RecLock( "SPF" , .T. ) )
					SPF->PF_FILIAL	:= cFil
					SPF->PF_MAT		:= cMat
					SPF->PF_DATA	:= dNextTroca
					SPF->PF_TURNODE	:= cLastTno
					SPF->PF_SEQUEDE	:= cLastSeq
					SPF->PF_REGRADE	:= cLastReg
					SPF->PF_TURNOPA	:= cNextTno
					SPF->PF_SEQUEPA	:= cNextSeq
					SPF->PF_REGRAPA	:= cNextReg
					SPF->( MsUnLock() ) 
				Else
					AADD(aLogFile, STR0035+Dtoc(dNextTroca)) // "Nao foi possivel incluir a troca de turno: "
					AADD(aLogFile, STR0034 + cFil + "/" + cMat + " - " + (cAliasSRA)->RA_NOME) //"Filial/Matricula: " + XX - AAAAAAAAAAAAAAAAAAAAAAAAAAAA	
					AADD(aLogFile, STR0036 + cLastTno+"/"+cLastSeq+"/"+ cLastReg+Space(5)+STR0037 + cNextTno+"/"+cNextSeq+"/"+ cNextReg) // "Turno/Sequencia/Regra DE: " #####  "Turno/Sequencia/Regra PARA: "
				EndIF	
			EndIF
	        
	        #IFNDEF TOP 
		         /*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Armazena Proximo Turno/Sequencia e Regra para Atualizacao  do³
				³ SRA fora desse While pois se alterarmos aqui estaremos mudan ³
				³ do a ordem de leitura e o fechamento estarah comprometido.   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				SRA->( aAdd( aRecsSRA , { Recno() , cNextTnoSra , cNextSeqSra , cNextRegSra , cProcesso , cPeriodo , cRoteiro , cNumPagto} ) )
			#ELSE
	        
		 	    /*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Grava Proximos Turno/Sequencia/Regra no SRA				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		         /*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Quando for top podemos alterar as informacoes do Cadastro de ³
				³ Funcionarios pois estamos lendo uma QUERY e posicionando     ³
				³ no SRA, nao alteramos a ordem de leitura da Query apesar de  ³
				³ modificarmos os campos da chave de indice do SRA             ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					
				IF SRA->( RecLock( "SRA" , .F. ) )
					SRA->RA_TNOTRAB := cNextTnoSra
					SRA->RA_SEQTURN	:= cNextSeqSra
					SRA->RA_REGRA	:= cNextRegSra
					SRA->RA_PRCFCH  := cProcesso
					SRA->RA_PERFCH  := cPeriodo
					SRA->RA_ROTFCH  := cRoteiro
					SRA->RA_NUPFCH  := cNumPagto
					SRA->( MsUnLock() )
				Else  
					AADD(aLogFile, STR0031) //"Cadastro de funcionários (SRA)em uso por outro usuário."
					AADD(aLogFile, STR0034 + cFil + "/" + cMat + " - " + SRA->RA_NOME) //"Filial/Matricula: " + XX - AAAAAAAAAAAAAAAAAAAAAAAAAAAA
					AADD(aLogFile, STR0035) // "Nao foi possivel incluir a troca de turno: "
					AADD(aLogFile, STR0038 + cNextTnoSra+"/"+cNextSeqSra+"/"+ cNextRegSra) // "Turno/Sequencia/Regra: " ###/##/##  
				EndIF
	
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Garante que todos os Registros Estarao Desboqueados         ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				PonFreeLocks() 
	
			#ENDIF
		EndIF		

	    /*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Pr¢ximo funcion rio.                                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
    	(cAliasSRA)->( dbSkip() )
	    
	End While
    
    #IFNDEF TOP 

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Atualiza Turno, Sequencia e Regra no SRA para CodeBase com as³
		³ informacoes de armazenadas durante a leitura do SRA. Nao pode³
		³ mos alterar essas informacoes dentro do WHILE pois estariamos³
		³ alterando os campos chaves do indice de leitura do SRA.      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nLoops := Len( aRecsSRA )
		BarGauge2Set( nLoops )
		For nLoop := 1 To nLoops
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Movimenta a R‚gua de Processamento                           ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IncPrcG2Time( STR0021 , nLoops , cTimeIni , .F. , 3 , nIncPercG2 )	//"Atualizando Turno, Sequencia e Regra no Cadastro de Funcionarios..."
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Atualializando Turno, Sequencia e Regra no SRA               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			SRA->( dbGoto( aRecsSRA[ nLoop , 01 ] ) )
			cFilAnt := SRA->RA_FILIAL
			
			IF SRA->( RecLock( "SRA" , .F. ) )
				SRA->RA_TNOTRAB := aRecsSRA[ nLoop , 02 ]
				SRA->RA_SEQTURN	:= aRecsSRA[ nLoop , 03 ]
				SRA->RA_REGRA	:= aRecsSRA[ nLoop , 04 ]
				SRA->RA_PRCFCH  := aRecsSRA[ nLoop , 05 ]
				SRA->RA_PERFCH  := aRecsSRA[ nLoop , 06 ]
				SRA->RA_ROTFCH  := aRecsSRA[ nLoop , 07 ]
				SRA->RA_NUPFCH  := aRecsSRA[ nLoop , 08 ]
				SRA->( MsUnLock() ) 
			EndIF
		Next nLoop
		aRecsSRA := {}

    #ENDIF  


		Begin Transaction

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Grava campos de controle - RG8                                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			fGrvRG8( nTotRegs , nTotFunc ) 
	
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Gravacao do Historico de Periodos - Auditoria                ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			fGrvRCI()		

			If FindFunction("SPFilterOff")  //   Alteracao referente ao projeto: SuperFiltro
			   SPFilterOff( { "RCH" } )     //   Desabilita filtro no alias - RCH.
			
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Fechamento do Periodo na tabela RCH                          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				RecLock("RCH",.F.)                 // Bloqueio registro RCH
				RCH->RCH_DTFECH	:= dDataBase 
				RCH->RCH_STATUS	:= " " 
				RCH->RCH_PERSEL := '2'				// Periodo Não selecionado
				("RCH")->( MsUnlock() )
			
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Marca o proximo periodo como selecionado                    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				nRecno	:= RCH->(Recno()) 
				If aNextPer[1,12]> 0 
					RCH->( dbGoto( aNextPer[1,12] ) )
					RecLock(("RCH"),.F.)                 // Bloqueio registro RCH
					RCH->RCH_PERSEL := '1'
					RCH->( MsUnlock() )
					RCH->( dbGoto( nRecno ) )
				Endif
				
				SPFilterOff( { "RCH" }, .F. )   //   Habilita Filtro no Alias - RCH.
			EndiF
		End Transaction 
		

	#IFDEF TOP 
 		fGravaLog( cDbfLog			,;  // Alias do arquivo log
					""				,; 	// Filial do Usuario
					""				,; 	// Processo do Usuario
					""				,; 	// Roteiro do USuario
					""				,; 	// Periodo do Usuario
					""				,;  // Num Pagto
					""				,;	// Matricula do funcionario em processamento
					""		 		,;	// Turno do funcionario em processamento
					""				,;	// Sequencia do turno do funcionario em processamento
					""				,;	// Regra do funcionario em processamento
					""  	 		,;	// Alias em processamento
					0				,;	// Total de registros processados para o funcionario
					0				,;  // Total de funcionarios processados ate o momento					
					.T.				;   // Grava tudo em branco
				)				
	#ENDIF	
End Sequence

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Fecha a Query do SRA e Restaura o Padrao                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
#IFDEF TOP
	IF ( lSraQryOpened )
		(cAliasSRA)->( dbCloseArea() )
	EndIF	
#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Numero de Funcionarios Processados					  	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cMsgLog := ( STR0059 + StrZero( nFunProc , 10 ) + "." )
aAdd( aLogFile , cMsgLog )										// '- Numero de Funcionarios Processados: '

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega Log do Fim do Processo de Fechamento			  	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aAdd(aLogFile, STR0049  + Dtoc(MsDate()) + ', as ' + Time() + '.') //"- Fim do Fechamento Mensal em "

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³  Grava e Imprime Log										  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
fMakeLog( { aLogFile } , { STR0033 } , NIL , .T. , FunName() ) //'Log de Ocorrencias:'

If FindFunction("SPFilterOff")
   SPFilterOff( { "SRA" },.F. )    //   Desabilita filtro no alias - SRA.
EndIf

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Ponm090Acumula³Autor³ Marinaldo de Jesus  ³ Data ³22/10/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir para os Acumulados os dados do Mes a ser Fechado ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³PONM090   												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Ponm090Acumula(	cAliasMes 	,; //Alias do Arquivo Mensal
								cAliasAcu 	,; //Alias do Arquivo Acumulado
								nOrdem    	,; //Ordem dos Arquivos
								bWhile	  	,; //Bloco para a Iteracao While	
								bCond	  	,; //Bloco para condicao especifica
								cFilMat	  	,; //Filial + Matricula do Funcionario	 
								adbStructs	,; //Array com a Estrutura dos Acumulados
								cFil		,; // Filial
								cMat		; // Matricula 
							   )      
Local aArea			:= GetArea()							   
Local aCposAcu		:= {}
Local aCposMes		:= {}
Local cMsgErr		:= ""  
Local cAliasQuery 	:= ""
Local cQuery		:= ""
Local lQueryOpened  := .F.
Local lDeleted		:= .T.
Local nCpo			:= 0.00
Local nCposAcu		:= 0.00
Local nCposMes		:= 0.00
Local nFieldMes		:= 0.00
Local nPosStruct	:= 0.00  
Local nX			:= 0
Local uCntMes		:= NIL      
Local cSvFilAnt		:= cFilAnt
Local lAtuQtFunc 	:= .F.
Local lAtuQtRegs 	:= .F.

Begin Sequence
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega as Estruturas dos Arquivos					           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF ( ( nPosStruct := aScan( adbStructs , { |x| x[1] == cAliasAcu } ) ) > 0.00 )
		aCposAcu := aClone( adbStructs[ nPosStruct , 02 ] )
		aCposMes := aClone( adbStructs[ nPosStruct , 03 ] )
	EndIF
	IF ( ( nCposAcu := Len( aCposAcu ) ) == 0.00 )
		Break
	EndIF
	
	nCposMes := Len( aCposMes )   

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Inicia o Processo de Transferencia para os Acumulados         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	#IFNDEF TOP  
		cAliasQuery:= cAliasMes
		( cAliasMes )->( dbSetOrder( nOrdem ) )
		IF !( cAliasMes )->( dbSeek( cFilMat , .F. ) )
			Break
		EndIF
	#ELSE
		IF !lExInAs400  
			cQuery		:= Eval(adbStructs[ nPosStruct , 04 ]) 
			( cAliasMes )->( dbSetOrder( nOrdem ) )
			cQuery 		+= " ORDER BY " + SqlOrder( (cAliasMes)->( IndexKey() ) )
			cQuery 		:= ChangeQuery( cQuery )
			cAliasQuery := ( "__Q" + cAliasMes + "QRY" )
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nCposMes
					IF !( aCposMes[ nX , 02 ] == "C" )
						TcSetField(cAliasQuery,aCposMes[nX,01],aCposMes[nX,02],aCposMes[nX,03],aCposMes[nX,04])
					EndIF
				Next nX
				( cAliasQuery )->( dbGotop() )
			Else                   
				cAliasQuery:= cAliasMes
				( cAliasMes )->( dbSetOrder( nOrdem ) )
				IF !( cAliasMes )->( dbSeek( cFilMat , .F. ) )
					Break
				EndIF
			EndIF
		Else
			cAliasQuery:= cAliasMes
			( cAliasMes )->( dbSetOrder( nOrdem ) )
			IF !( cAliasMes )->( dbSeek( cFilMat , .F. ) )
				Break
			EndIF
		EndIF			
	#ENDIF 
	
	While ( cAliasQuery )->( !Eof() .and. Eval( bWhile ) )
	    
		If lAtuQtRegs
			lAtuQtRegs := .F.
			nTotRegs++
		EndIf	    
	    /*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Posiciona no funcionario do arquivo do mes no caso do alias do laco    ³
		³ser uma query.														    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFDEF TOP
			IF ( lQueryOpened )
				(cAliasMes)->( dbGoto( (cAliasQuery)->RECNO ) ) 	
			Endif                                   
		#ENDIF

	    /*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Transfere os Dados para o Arquivo de Acumulados               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/		
		IF ( cAliasMes )->( Eval( bCond ) )
	    	/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Trava o Registro do Arquivo Mensal                            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( cAliasMes )->( RecLock( cAliasMes , .F. ) )
		    	/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Novo Registro nos Acumulados                                  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF ( cAliasAcu )->( RecLock( cAliasAcu , .T. ) )
			    	/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Percorre Todos os Campos do Arquivo de Acumulado              ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					For nCpo := 1 To nCposAcu
				    	/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³So Acumula conteudo de Campo Existente                        ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF ( ( nFieldMes := aCposAcu[ nCpo , Len( aCposAcu[ nCpo ] ) , 02 ] ) > 0.00 )
							uCntMes := ( cAliasMes )->( FieldGet( nFieldMes ) )
							( cAliasAcu )->( FieldPut( nCpo , uCntMes ) )
							If cAliasAcu == "SPL"
								lAtuQtFunc := .T.
								lAtuQtRegs := .T.
							EndIf
						EndIF
					Next nCpo
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Destrava Registro dos Acumulados                              ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					( cAliasAcu )->( MsUnLock() )

					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Elimina os Dados do Arquivo Mensal e Destrava o Registro      ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					lDeleted := fDelMes( cAliasMes, (cAliasMes)->(Recno()) )
										
					( cAliasMes )->( MsUnlock() )
				EndIF
			EndIF	
		EndIF

		( cAliasQuery )->( dbSkip() )
	End While

End Sequence

If lAtuQtFunc
	nTotFunc ++
EndIf

#IFDEF TOP 
	IF lQueryOpened
		(cAliasQuery)->(dbCloseArea())
	Endif
#EndIF
                    
RestArea(aArea)

Return( lDeleted )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Ponm090CposMes³Autor³ Marinaldo de Jesus  ³ Data ³11/04/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Achar os Campos dos Arquivos Mensais conforme Acumulados    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³PONM090   												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Ponm090CposMes( adbStructs )
                
Local aCposMes		:= {}			
Local aAlias 		:= { { "SPN" , "SP5" } , { "SPG" , "SP8" } , { "SPH" , "SPC" } , { "SPL" , "SPB" } }
Local cCpoAcu		:= ""
Local cPrefixoCpo	:= ""
Local nAlias		:= 0.00
Local nCpo			:= 0.00
Local nPosAlias		:= 0.00
Local nAtPrefix   	:= 0.00
Local nLstPrefix	:= 0.00
Local nLenCposMes	:= 0.00
Local nPosCpo		:= 0.00

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Varre Arquivo de Acumulado e Monta Campo Correspondente no  Mo³
³vimento													   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nAlias := 1 To Len( aAlias )
	IF ( ( nPosAlias := aScan( adbStructs , { |x| x[1] == aAlias[ nAlias , 01 ] } ) ) > 0.00 )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Carrega o Prefixo do campo referente ao arquivo Mensal		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cPrefixoCpo	:= PrefixoCpo( aAlias[ nAlias , 02 ] )
		aAdd( aCposMes , { aAlias[ nAlias , 01 ] , {} } )
		nLenCposMes := Len( aCposMes )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Varre Todos os Campos do arquivo de acumulados para  encontrar³
		³o correspondente Mensal									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		For nCpo := 1 To Len( adbStructs[ nPosAlias , 02 ]  )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Obtem o Campo do Arquivo Acumulado						   	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cCpoAcu := adbStructs[ nPosAlias , 02 , nCpo , 01 ]
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Obtem o Campo do Arquivo Mensal conforme campo do Acumulado   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			nAtPrefix   := At( "_" , cCpoAcu )
			nLstPrefix	:= ( Len( cCpoAcu ) - ( nAtPrefix - 1 ) )
			cCpoMes 	:= ( cPrefixoCpo + SubStr( cCpoAcu , nAtPrefix , nLstPrefix ) )
			aAdd( aCposMes[ nLenCposMes , 02 ] , { cCpoAcu , cCpoMes ,  ( aAlias[ nAlias , 02 ] )->( FieldPos( cCpoMes ) ) } )
		Next nCpo
	EndIF
Next nAlias

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega o Campo e seu Respectivo posicionamento em adbStructs ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nAlias := 1 To Len( aCposMes )
	IF ( ( nPosAlias := aScan( adbStructs , { |x| x[1] == aCposMes[ nAlias , 01 ] } ) ) > 0.00 )
		For nCpo := 1 To Len( aCposMes[ nAlias , 02 ] )
			IF ( ( nPosCpo := aScan( adbStructs[ nPosAlias , 02 ] , { |x| x[1] == aCposMes[ nAlias , 02 , nCpo , 01  ] } ) ) > 0.00 )
				aAdd( adbStructs[ nPosAlias , 02 , nPosCpo ] , { aCposMes[ nAlias , 02 , nCpo , 02 ] , aCposMes[ nAlias , 02 , nCpo , 03 ] } )
			EndIF
		Next nCpo
	EndIF
Next nAlias

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³ReOpenFiles   ³Autor³Equipe Advanded RH   ³ Data ³11/03/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reabre os Arquivos em Modo Compartilhado					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³PONM090   												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function ReOpenFiles( aFilesReOpen )

Local nLoop
Local nLoops

nLoops := Len( aFilesReOpen )
For nLoop := 1 To nLoops
    ( aFilesReOpen[ nLoop ] )->( dbCloseArea() )
    ChkFile( aFilesReOpen[ nLoop ] )
Next nLoop

Return( NIL )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ShowPonMes	³ Autor ³Mauricio MR		   ³ Data ³07/10/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Exibe Mensagem de Advertencia e Periodos de Apontamento das  ³
³          ³filiais														 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static Function ShowPonMes(  cCadastro, cFil, lRetomaProcess, cDbfLog)

Local aSvKeys		:= GetKeys()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Declaração de arrays para dimensionar tela		         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aGDCoord		:= {}
Local aListBox		:= {}
Local aButtons		:= {}
Local aSays			:= {}

Local cTextSay		:= ''	
Local cDatas		:= ''
Local cSays			:= ''
Local cSvFilAnt		:= cFilAnt

Local nFatLstBox       
Local lRet			:= .F.   
Local nI			:= 0
Local nPosIni		:= 0     
Local nType			:= 0

Local oDlg 			:= NIL
Local oListBox		:= NIL 
Local oGroup1		:= NIL 
Local oSay			:= NIL
Local oFont			:= NIL
Local oFont2		:= NIL
Local oDatas

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdvSize		:= MsAdvSize()
aAdvSize[5]	:=	(aAdvSize[5]/100) * 70	//horizontal
aAdvSize[6]	:=  (aAdvSize[6]/100) * 70	//Vertical
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }					 
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )
aGdCoord	:= { (aObjSize[1,1]+3), (aObjSize[1,2]+5), (((aObjSize[1,3])/100)*65), (((aObjSize[1,4])/100)*68) }	//1,3 Vertical /1,4 Horizontal

cSays +=OemToAnsi( STR0008 ) + ' ' + OemToAnsi( STR0009 )	// "Este programa tem o objetivo de Efetuar o Fechamento Mensal do Ponto e"#"Atualizar as Sequencias das Tabelas de Horario Padrao no Cadastro.    " 

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Se nao for retomada de processo, permite selecionar os dados do  ³
³processo, periobe todas as filiais.							  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF !lRetomaProcess
   	aAdd(aButtons, { 5,.T.,{|| Pergunte("PONM090",.T. ), cProcesso	:=	MV_PAR01, cPeriodo	:=  MV_PAR02, cRoteiro	:= 	MV_PAR03, cNumPagto	:= 	MV_PAR04, nMarcProc := MV_PAR05, CargaDados(@cDatas, @aListBox, lRetomaProcess) } } )
    Pergunte("PONM090",.F. )	
    
	cProcesso	:=	MV_PAR01
	cPeriodo	:=  MV_PAR02
	cRoteiro	:= 	MV_PAR03
	cNumPagto	:= 	MV_PAR04
	nMarcProc   :=  MV_PAR05
Else
   	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se for uma retomada, assume os dados do arquivo temporario.   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	Pergunte("PONM090",.F. ) 
	cProcesso	:=	(cDbfLog)->PROCESSO
	cPeriodo	:=  (cDbfLog)->PERIODO
	cRoteiro	:= 	(cDbfLog)->ROTEIRO
	cNumPagto	:= 	(cDbfLog)->NUMPAGTO
	nTotRegs	:= 	Val((cDbfLog)->TOTREG)
	nTotFunc	:=  Val((cDbfLog)->TOTFUN)
	nMarcProc   :=  MV_PAR05
EndIF

nMarcProc 	:= 	MV_PAR05

CargaDados(@cDatas, @aListBox, lRetomaProcess)

aAdd(aButtons, { 1,.T.,{|o| lRet := .T.,IF(GpconfOk(STR0012),oDlg:End(), lRet := .F. ) } } )
aAdd(aButtons, { 2,.T.,{|o| oDlg:End(), lRet := .F. } } )

DEFINE FONT oFont 	NAME "Arial" SIZE 0,-11 BOLD
DEFINE FONT oFont2 	NAME "Arial" SIZE 0,-11 

DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL
@ aGdCoord[1],aGdCoord[2]	GROUP oGroup TO (((aObjSize[1,3])/100)*20), aGdCoord[4] LABEL "" OF oDlg PIXEL
oGroup:oFont:= oFont

@ (((aObjSize[1,3])/100)*22),aGdCoord[2]	GROUP oGroup1 TO (((aObjSize[1,3])/100)*53),aGdCoord[4] LABEL OemToAnsi(STR0022) OF oDlg PIXEL				
oGroup1:oFont:=oFont

@ (((aObjSize[1,3])/100)*55),aGdCoord[2] 	GROUP oGroup TO aGdCoord[3], (((aObjSize[1,4])/100)*25) LABEL OemToAnsi(STR0061) OF oDlg PIXEL	// Periodo a ser fechado:
oGroup:oFont:= oFont

@ aGdCoord[1]+5,aGdCoord[2]+5	GET oMemo VAR cSays MEMO SIZE aGdCoord[4]-15,(((aObjSize[1,3])/100)*20)-aGdCoord[1]-10 PIXEL OF oDlg READONLY

@ (((aObjSize[1,3])/100)*26),aGdCoord[2]+5 LISTBOX oListBox FIELDS HEADERS ;
									 OemToAnsi( STR0024 )									 			,;	//"Processo"
									 OemToAnsi( STR0023 )									 			,;	//"Roteiro"
									 OemToAnsi( STR0025 )									 			,;	//"Periodo"
									 OemToAnsi( STR0026 )									 			,;	//"Num. Pagto"
									 OemToAnsi( STR0062 )									 			;	//"Processadas"
							COLSIZES ;                                                                                    
									 GetTextWidth(0,Replicate("B",5))							  		,;	//"Processo"
									 GetTextWidth(0,Replicate("B",3))							  		,;	//"Roteiro"
									 GetTextWidth(0,Replicate("B",6))						 			,;	//"Periodo"
									 GetTextWidth(0,Replicate("B",2))						 			,;	//"Num. Pagto"
									 GetTextWidth(0,Replicate("B",10))						 			;	//"Processadas"
							SIZE aGdCoord[4]-15,(((aObjSize[1,3])/100)*52)-(((aObjSize[1,3])/100)*26)-3  OF oDlg PIXEL 
oListBox:SetArray(aListBox)
oListBox:bLine:={ || LinhaLstBox( oListBox , aListBox) }

@ (((aObjSize[1,3])/100)*59), aGdCoord[2]+5 SAY oDatas Var cDatas SIZE 060,10 OF oDlg PIXEL FONT oFont	    

For nI:=1 to Len(aButtons)
	nType:= aButtons[nI,1]
	SButton():New( (((aObjSize[1,3])/100)*58), (((aObjSize[1,4])/100)*40) + nPosIni, nType,aButtons[nI,3],oDlg,.T.,,)	
	nPosIni+=  32
Next nI

ACTIVATE MSDIALOG oDlg CENTERED 

RestKeys( aSvKeys , .T. )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetName		³ Autor ³Mauricio MR		   ³ Data ³05/10/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ObTem o Nome do Arquivo a apartir do SX2				     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
/*Static Function GetName(cAlias)

  Local cTabela	:= ""
  Local aArea	:= GetArea()
  Local aAreaSX2:= SX2->(GetArea())

  dbSelectArea("SX2")
  
  SX2->( dbSetOrder(1) )
  If SX2->(dbSeek( cAlias ) )
	cTabela := X2Nome()
  EndIf         
  
  RestArea(aAreaSX2)
  RestArea(aArea)
  
Return (cTabela)*/

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Pn090Open	³ Autor ³Mauricio MR		   ³ Data ³06/10/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se foi possivel abrir os arquivos compartilhados    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
Function Pn090Open(cMsg, cAviso)

Local aFilesOpen 	:=	{"SP5", "SPN", "SP8", "SPG","SPB","SPL","SPC", "SPH", "SPF"}    
Local aExclusFiles	:=	{}
Local nLoop
Local nLoops
Local lLocked	:= .F.

DEFAULT cAviso	:= STR0007  //Aviso
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Efetua o Travamento dos Arquivos                             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nLoops := Len( aFilesOpen )  

For nLoop := 1 To nLoops
	//-- Verifica se foi possível abrir o arquivo
	IF !( lLocked := ChkFile( aFilesOpen[ nLoop ],.F.) ) 
		cMsg := STR0029	//"O Fechamento do SIGAPON está sendo executado. Tente mais tarde."	
		//-- Recompoe o array com somente os arquivos abertos exclusivamente.
		aFilesOpen	:=aClone(aExclusFiles)
		//-- Reabre os arquivos sem exclusividade
		ReOpenFiles( aFilesOpen )
		Exit
	EndIF 
	//-- Armazena arquivos que foram abertos com exclusividade
	AADD(aExclusFiles, aFilesOpen[ nLoop ] )
Next nLoop 

Return (lLocked)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fOpenLog	³ Autor ³Mauricio MR		   ³ Data ³28/12/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cria/Abre arquivo de LOG								     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
#IFDEF TOP
	Static Function fOpenLog(cDbfLog)

	Local lRet			:= .T.
	Local aFields		:= {}
	Local aIndice := {"PROCESSO","PERIODO","ROTEIRO","NUMPAGTO"}
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se alias ja estiver em uso, fecha-o para posterior abertura		  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/		
	
	If Select(cDbfLog) > 0
		dbSelectArea(cDbfLog)
		dbCloseArea()
	Endif
	
	If oTmpLog <> Nil
		oTmpLog:Delete()
		Freeobj(oTmpLog)
	EndIf
	
    oTmpLog := FWTemporaryTable():New(cDbfLog)    
		
	Begin Sequence
		
			AADD(aFields, { "USUARIO"	,"C",Len(cUsuario)				,0} )		
			AADD(aFields, { "FILIAL"	,"C",TamSX3("PO_FILIAL")[1]		,0} )
			AADD(aFields, { "PROCESSO"	,"C",5							,0} )	
			AADD(aFields, { "ROTEIRO"	,"C",3							,0} )	
			AADD(aFields, { "PERIODO"	,"C",6							,0} )	
			AADD(aFields, { "NUMPAGTO"	,"C",2							,0} )
			AADD(aFields, { "MAT"		,"C",TamSX3("RA_MAT")[1]		,0} )
			AADD(aFields, { "TNOTRAB"	,"C",TamSX3("RA_TNOTRAB")[1]	,0} )
			AADD(aFields, { "SEQTURN"	,"C",TamSX3("RA_SEQTURN")[1]	,0} )
			AADD(aFields, { "REGRA"		,"C",TamSX3("RA_REGRA")[1]		,0} )
			AADD(aFields, { "ALIASMES"	,"C",3							,0} )
			AADD(aFields, { "TOTREG"	,"C",8							,0} )
			AADD(aFields, { "TOTFUN"	,"C",8							,0} )
			
			oTmpLog:SetFields(aFields)
    		oTmpLog:AddIndex( "01", aIndice )
    		oTmpLog:Create()
				
	End
		
	Return (lRet)  
#ENDIF 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGravaLog	³ Autor ³Mauricio MR		   ³ Data ³28/12/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Registra dados do funcionario em processo de fechamento      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
#IFDEF TOP
	Static Function fGravaLog(	cDbfLog		,; 	// Alias do arquivo log
								cFilLog	 	,; 	// Filial do Periodo  de Apontamento
								cProcLog	,; 	// Processo
								cRotLog		,; 	// Roteiro
								cPerLog		,; 	// Periodo
								cNrPagLog	,;  // Num Pagto
								cMatlog		,;	// Matricula do funcionario em processamento
								cTnoTrabLog	,;	// Turno do funcionario em processamento
								cSeqTurnLog	,;	// Sequencia do turno do funcionario em processamento
								cRegraLog	,;	// Regra do funcionario em processamento
								cAliasMesLog,;	// Alias em processamento
								nTotRegs	,;  // Total de registros processados para o funcionario
								nTotFun		,;  // Total de funcionarios processados ate o momento
								lApagaTudo	 ;  //Se .T. grava tudo em branco
							)
					
	Local cMsgErr		:= ""
	Local lPn090Inclui	:= .T.

	DEFAULT lApagaTudo := .F.
	
	   Begin Transaction

		  If !( (cDbfLog)->(dbSeek(cProcLog+cPerLog+cRotLog+cNrPagLog)) )
		  	lPn090Inclui := .T.
		  Else
		  	lPn090Inclui := .F.	
		  EndIf
		  		  		    
		  RecLock(cDbfLog,lPn090Inclui) 
		  If !lApagaTudo		
			  (cDbfLog)->USUARIO	:= cUsuario
   		  Else
			  (cDbfLog)->USUARIO	:= ""
				If !( cDbfLog )->( FkDelete( @cMsgErr ) )
				   ( cDbfLog )->( RollBackDelTran( cMsgErr ) )
				EndIf
			  fErase(cAuxInd)			  
	      EndIf

		  //Ultima filial que estava sendo processada - Processo/Periodo/Roteiro/NumPagto processados
		  (cDbfLog)->FILIAL		:= If(cFilLog 		== NIL	, (cDbfLog)->FILIAL		, cFilLog	 	)
		  (cDbfLog)->PROCESSO	:= If(cProcLog	 	== NIL	, (cDbfLog)->PROCESSO	, cProcLog 		)  
		  (cDbfLog)->ROTEIRO	:= If(cRotLog	 	== NIL	, (cDbfLog)->ROTEIRO	, cRotLog	 	)
		  (cDbfLog)->PERIODO	:= If(cPerLog	 	== NIL	, (cDbfLog)->PERIODO	, cPerLog	 	)
		  (cDbfLog)->NUMPAGTO	:= If(cNrPagLog	 	== NIL	, (cDbfLog)->NUMPAGTO	, cNrPagLog	 	)
		  
          //Dados do funcionario
		  (cDbfLog)->MAT		:= If(cMatlog 		== NIL	, (cDbfLog)->MAT		, cMatlog 		)
		  (cDbfLog)->TNOTRAB	:= If(cTnoTrabLog	== NIL	, (cDbfLog)->TNOTRAB	, cTnoTrabLog	)
		  (cDbfLog)->SEQTURN	:= If(cSeqTurnLog	== NIL	, (cDbfLog)->SEQTURN	, cSeqTurnLog	)
		  (cDbfLog)->REGRA		:= If(cRegraLog		== NIL	, (cDbfLog)->REGRA		, cRegraLog		)
		  (cDbfLog)->ALIASMES	:= If(cAliasMesLog 	== NIL	, (cDbfLog)->ALIASMES	, cAliasMesLog 	)
		  
		  //Totais de processamento
		  (cDbfLog)->TOTREG	:= If(nTotRegs 	== NIL	, (cDbfLog)->TOTREG	, AllTrim(Str(nTotRegs)) )
		  (cDbfLog)->TOTFUN	:= If(nTotFun 	== NIL	, (cDbfLog)->TOTFUN	, AllTrim(Str(nTotFun))  )

		  (cDbfLog)->( MsUnlock() )
		  
		End Transaction
				 
	Return (Nil)
#ENDIF
	                      
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ShowOnFech	³ Autor ³Mauricio MR		   ³ Data ³02/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Exibe Mensagem de Advertencia de Fechamento Interrompido	 ³
³          ³abruptamente.												 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
#IFDEF TOP 
	Static Function ShowOnFech(  cCadastro, cDbfLog )

	Local aArea			:= GetArea()   
	Local aAreaSM0		 
	Local aSRAArea		:= SRA->(GetArea())
	Local aSvKeys		:= GetKeys()
	Local aAdvSize		:= MsAdvSize( .T. , .T. , 50 )
	Local aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
	Local aObjCoords    := {}
	Local aGpLboxCoords	:= {}  
	Local aButtonCoords	:= {}
	Local aButtons		:= {}
	Local aObjSize     	:= {}
	Local aLboxCoords	:= {}	
	Local aListBox		:= {}  
	
	Local cSays			:= ''
	Local cTextSay		:= ''	
	Local nFatLstBox       
	Local lRet			:= .F.   
	Local nI			:= 0
	Local nPosIni		:= 0     
	Local nType			:= 0  
	Local nTop			:= 15
	
	Local oDlg 			:= NIL
	Local oListBox		:= NIL 
	Local oGroup1		:= NIL 
	Local oSay			:= NIL
	Local oFont			:= NIL
	Local oFont2		:= NIL
	
	aAdd( aObjCoords , { 100 , 100 , .T. , .F. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords ) 
	aGpLboxCoords	:= { aObjSize[1,1]+10,aObjSize[1,2]+10,aObjSize[1,4]-20,aObjSize[1,3]-20}
	aButtonCoords	:= { aObjSize[1,1],aObjSize[1,2],aObjSize[1,3], aObjSize[1,4]}
	nFatLstBox		:= RetFatListBox( aGpLboxCoords[4]-20 )
	aLboxCoords		:= { aGpLboxCoords[1],aGpLboxCoords[2],aGpLboxCoords[3],(aGpLboxCoords[4])/100*nFatLstBox}	
	
	cSays += OemToAnsi( STR0040 )	// "A operação anterior de Fechamento Mensal não foi concluída de forma normal. Deseja continuar a partir do ponto de interrupção."
		
	aAdd(aButtons, { 1,.T.,{|o| lRet := .T.,IF(GpconfOk(STR0012),oDlg:End(), lRet := .F. ) } } ) //"Confirma o Fechamento Mensal?"
	aAdd(aButtons, { 2,.T.,{|o| oDlg:End(), lRet := .F. } } )
	
	DEFINE FONT oFont 	NAME "Arial" SIZE 0,-11 BOLD
	DEFINE FONT oFont2 	NAME "Arial" SIZE 0,-15
	
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL
	
	cTextSay 	:= "{ | u | If( PCount() == 0, cSays, cSays:= u ) }"
	oSay 		:= TMultiGet():New( 0.20	,0		, &cTextSay			,oDlg  		,aObjSize[1,4]	,aObjSize[1,3]/5	, oFont2,				,				,	,	,,,,,,,.T.,, , ,.T., .F. )
	
	SRA->( dbSetOrder( RetOrdem( "SRA" , "RA_FILIAL+RA_MAT" ) ) )
	SRA->( dbSeek( (cDbfLog)->(FILIAL+MAT) ) )
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	|Obtem a descricao da Filial caso a interrupcao tenha ocorrido ³
	|apos o fechamento de um funcionario e faltou fechar o periodo ³
	|da filial ou antes de iniciar o fechamento de uma filial	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	@ aObjSize[1,1] + nTop,aObjSize[1,2]	GROUP oGroup1 TO aObjSize[1,3]+10,aObjSize[1,4] LABEL OemToAnsi(STR0041) OF oDlg PIXEL		//"O processo será retomado a partir do funcionário abaixo:"
	oGroup1:oFont:=oFont
	
	While (cDbfLog)->( !Eof() )
		(cDbfLog)->( aAdd(aListBox,{FILIAL, PROCESSO , ROTEIRO , PERIODO , NUMPAGTO , TNOTRAB, SEQTURN, REGRA, MAT, SRA->RA_NOME}))
		(cDbfLog)->(dbSkip())
	EndDo
	
	(cDbfLog)->(dbGoTop())
   
	@ aLboxCoords[1]+nTop,aLboxCoords[2] LISTBOX oListBox FIELDS HEADERS ;
											 OemToAnsi( STR0013 )									 			,;	//"Filial"
											 OemToAnsi( STR0024 )									 			,;	//"Processo"
											 OemToAnsi( STR0023 )									 			,;	//"Roteiro"
											 OemToAnsi( STR0025 )									 			,;	//"Periodo"
											 OemToAnsi( STR0026 )									 			,;	//"Num. Pagto"
											 OemToAnsi( STR0042 )									 			,;	//"Turno"
											 OemToAnsi( STR0043 )									 			,;	//"Seq"
											 OemToAnsi( STR0044 )									 			,;	//"Regra"
											 OemToAnsi( STR0045 )									 			,;	//"Matricula"
											 OemToAnsi( STR0046 )									 			;	//"Nome"									 
									COLSIZES ;                                                                                    
											 GetTextWidth(0,Replicate("B",TAMSX3("RA_FILIAL")[1]))				,;	//"Filial" do funcionario
		 									 GetTextWidth(0,Replicate("B",5))							  		,;	//"Processo"
											 GetTextWidth(0,Replicate("B",3))							  		,;	//"Roteiro"
											 GetTextWidth(0,Replicate("B",6))						 			,;	//"Periodo"
											 GetTextWidth(0,Replicate("B",2))						 			,;	//"Num. Pagto"
											 GetTextWidth(0,Replicate("B",TAMSX3("RA_TNOTRAB")[1]+3))	  		,;	//"Turno"
											 GetTextWidth(0,Replicate("B",TAMSX3("RA_SEQTURN")[1]+3))	 		,;	//"Seq"
											 GetTextWidth(0,Replicate("B",TAMSX3("RA_REGRA")[1]+3))	 	   		,;	//"Regra"
											 GetTextWidth(0,Replicate("B",TAMSX3("RA_MAT")[1]))	 				,;	//"Matricula"
											 GetTextWidth(0,Replicate("B",TAMSX3("RA_NOME")[1]))	 			;	//"Nome"									 
									SIZE aLboxCoords[3],aLboxCoords[4] OF oDlg PIXEL 
		
	oListBox:SetArray(aListBox)
	oListBox:bLine:={ || LineLstBox( oListBox ) }
	
	nPosIni:=  aObjSize[1,4] - ( Len(aButtons) * 32)
	For nI:=1 to Len(aButtons)
		nType:= aButtons[nI,1]
		SButton():New( aObjSize[1,3]+15, nPosIni, nType,aButtons[nI,3],oDlg,.T.,,)	
		nPosIni+=  32
	Next nI
	
	ACTIVATE MSDIALOG oDlg CENTERED 
	
	RestKeys( aSvKeys , .T. )
	
	RestArea(aArea)  
	RestArea(aSRAArea)
	
	Return( lRet )
	
#ENDIF 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fCampos  	³ Autor ³Mauricio MR		   ³ Data ³03/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Monta Lista de campos para Query do Alias informado			 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fCampos(cAlias, aCpos)

Local cCampos 	:= ""
Local nCpos		:= Len(aCpos)
Local nX

For nX := 1 To nCpos
	cCampos+= aCpos[nX,01]+","
Next nX

cCampos:= cCampos + cAlias + '.R_E_C_N_O_ RECNO '

Return (cCampos) 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fVerPerOpen	³ Autor ³Mauricio MR		   ³ Data ³25/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se Considera o registro de interrupcao do processo. ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PONM090														 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
#IFDEF TOP 
	Static Function fVerPerOpen(cDbfLog)                                                  

	Local lRet		:= .F. 
	
	//Local cArqPrc := (cDbfLog)->PROCESSO
	//Local cArqPer := (cDbfLog)->PERIODO
	//Local cArqRot := (cDbfLog)->ROTEIRO
	//Local cArqNPg := (cDbfLog)->NUMPAGTO
		
	Begin Sequence             
	
		//-- Verifica se houve interrupcao
		IF !Empty( (cDbfLog)->USUARIO ) .or. !Empty( (cDbfLog)->(PROCESSO) )
	
		   	//-- Se o periodo da interrupcao for diferente do periodo de apontamento nao considera a interrupcao
		    //If ( cUsuario  <> (cDbfLog)->USUARIO  )
		    //   Break
		    //EndIf
		    
		    //Considera chave do processo/periodo selecionados para ponto de interrupcao
		    //If (  (cArqPrc+cArqPer+cArqRot+cArqNPg) != (cProcesso+cPeriodo+cRoteiro+cNumPagto) )
			//	Break		    
		    //EndIf
		    	
		    lRet:= .T.
	
		Endif		        
	
	End
	
	Return (lRet)
	
#ENDIF 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CargaDados	³ Autor ³Leandro DR 		   ³ Data ³30/01/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica a data do período selecionado no pergunte e monta o ³
|		   |Array alistbox que será usado para montar o objeto listbox 	 |
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PONM090														 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
Static Function CargaDados(cDatas , aListBox, lRetomaProcess)

Local cMarcProc := ''

oPeriodo:cPeriodo  := cPeriodo
oPeriodo:cRoteiro  := cRoteiro
oPeriodo:cNumPagto := cNumPagto
oPeriodo:cProcesso := cProcesso

oPeriodo:GetPer()

dPerIni := oPeriodo:dDataIni
dPerFim := oPeriodo:dDataFim

cDatas			:= ( DTOC(oPeriodo:dDataIni) + " - "  + DTOC(oPeriodo:dDataFim))

If nMarcProc == 1
	cMarcProc := STR0063    //Descartar
ElseIf nMarcProc == 2
	cMarcProc := STR0064    //Manter
EndIf

//Esvazia o array para manter sempre apenas 1 elemento na listbox
aListBox := {}

aAdd( aListBox, { cProcesso , cRoteiro , cPeriodo , cNumPagto , cMarcProc } )	

Return(NIL)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³LinhaLstBox	³ Autor ³Leandro DR 		   ³ Data ³30/01/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Monta linha do objeto listbox								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PONM090														 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  

Static Function LinhaLstBox( oListBox , aListBox )

Local abLine	:= {}  
Local nX		:= 0

For nX := 1 to 5
	aAdd( abLine , aListBox[ 1 , nX ] )
Next

Return( aClone( abLine ) )


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGrvRCI       ³Autor³Microsiga			  ³ Data ³31/01/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gravacao do Historico de Periodos - Auditoria            	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fGrvRCI			     										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PONM090                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGrvRCI()

Local aArea := GetArea()
Local cKey  := xFilial("RCI") + RCH->( RCH_PROCES + RCH_PER + RCH_NUMPAG + RCH_ROTEIR )

Begin Sequence

	DbSelectArea( "RCI" )
	RCI->( dbSetOrder( RetOrdem( "RCI" , "RCI_FILIAL+RCI_PROCES+RCI_PER+RCI_NUMPAG+RCI_ROTEIR" ) ) )

	If !( ("RCI")->(dbSeek(cKey)) )
		RecLock("RCI",.T.)
	
		RCI->RCI_FILIAL 	:= RCH->RCH_FILIAL
		RCI->RCI_PER		:= RCH->RCH_PER
		RCI->RCI_NUMPAG		:= RCH->RCH_NUMPAG
		RCI->RCI_PROCES		:= RCH->RCH_PROCES
		RCI->RCI_ROTEIR		:= RCH->RCH_ROTEIR

	Else
		RecLock("RCI",.F.)
	EndIf
	RCI->RCI_MES		:= RCH->RCH_MES
	RCI->RCI_ANO		:= RCH->RCH_ANO
	RCI->RCI_DTFEC		:= dDataBase
	RCI->RCI_HORFEC		:= Time()

	RCI->( MsUnlock() )
End Sequence

RestArea( aArea )

Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGrvRG8      ºAutor  ³Microsiga           º Data ³  31/01/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                               º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Static Function fGrvRG8( nTotRegs,nTotFunc ) 

Local aArea 	:= GetArea() 
Local cAliasRCH := "RCH"

Begin Sequence 

	//-- RG8_FILIAL + RG8_MODORI  + RG8_PERORI + RG8_NPGORI + RG8_PRCORI+  RG8_ROTORI + RG8_MODCOR  + RG8_PERCOR +  RG8_NPGCOR + RG8_PROCOR+  RG8_ROTC 
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ O Fechamento eh unico e portanto sempre sera gerado um novo ³
	³ registro                                                    ³	
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
	DbSelectArea( "RG8" ) 
	RecLock("RG8",.T.) 	 

	RG8->RG8_FILIAL 	:= (cAliasRCH)->RCH_FILIAL
	RG8->RG8_PERORI		:= (cAliasRCH)->RCH_PER   
	RG8->RG8_NPGORI		:= (cAliasRCH)->RCH_NUMPAG
	RG8->RG8_PRCORI		:= (cAliasRCH)->RCH_PROCES
	RG8->RG8_ROTORI		:= (cAliasRCH)->RCH_ROTEIR
	RG8->RG8_ANOORI		:= (cAliasRCH)->RCH_ANO 
	RG8->RG8_MESORI		:= (cAliasRCH)->RCH_MES 
	RG8->RG8_MODORI		:=  cModulo 
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ O periodo correspondente devera ser gerada automaticamente  ³
	³ na tabela e devera ser igual ao Per.Origem para o fechamento³	
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	RG8->RG8_PERCOR		:= (cAliasRCH)->RCH_PER 
	RG8->RG8_NPGCOR		:= (cAliasRCH)->RCH_NUMPAG
	RG8->RG8_PROCOR		:= (cAliasRCH)->RCH_PROCES
	RG8->RG8_ROTCOR		:= (cAliasRCH)->RCH_ROTEIR
	RG8->RG8_ANOCOR		:= (cAliasRCH)->RCH_ANO   
	RG8->RG8_MESCOR		:= (cAliasRCH)->RCH_MES   
	RG8->RG8_MODCOR		:=  cModulo 

	RG8->RG8_QTREGS	:= nTotRegs 
	RG8->RG8_QTFUNC	:= nTotFunc  

	MsUnlock()

End Sequence 

RestArea(aArea) 

Return ( Nil ) 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Ponm090ValFech³Autor³Leandro Drumond      ³ Data ³31/01/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Fechamento do Mes Anterior e Mes Seguinte 		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Ponm090ValFech() 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Ponm090ValFech( aNextPer , nPerAntNext )

Local aArea		:= GetArea()
Local lRet 		:= .T. 
Local cAliasRCH := "RCH"

DEFAULT aNextPer := {}

nPerAntNext 	:= 0

Begin Sequence
	DbSelectArea( cAliasRCH )
	RCH->(DbSetOrder( 4 )) // RCH_FILIAL + RCH_PROCES + RCH_ROTEIR + RCH_PER + RCH_NUMPAG
	DbSeek( oPeriodo:cFilRCH + oPeriodo:cProcesso + oPeriodo:cRoteiro + oPeriodo:cPeriodo + oPeriodo:cNumPagto, .F. )
	If (cAliasRCH)->( Eof() )
		lRet := .F.
		Break
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Validacao do Periodo Anterior                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	(cAliasRCH)->( DbSkip(-1) )
	If 	( (cAliasRCH)->( !BOF() ))		   				 .and.	;
		( (cAliasRCH)->RCH_FILIAL == oPeriodo:cFilRCH   ).and.	;
		( (cAliasRCH)->RCH_PROCES == oPeriodo:cProcesso ).and. 	;
		( (cAliasRCH)->RCH_ROTEIR == oPeriodo:cRoteiro  ).and.	;
		( Empty( (cAliasRCH)->RCH_DTFECH ) )

		aAdd( aLogFile, oPeriodo:cMsgPerAntOpened ) // "Período de Apontamento anterior não foi fechado."
		lRet := .F.
		nPerAntNext := 1

	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Validacao do Periodo Seguinte                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If (cAliasRCH)->( BOF() )
		(cAliasRCH)->( DbSkip() )
	Else
		(cAliasRCH)->( DbSkip(+2) )
	EndIf
	If 	( (cAliasRCH)->( !Eof() ) ) 					  .and. ;
		( (cAliasRCH)->RCH_FILIAL == oPeriodo:cFilRCH   ) .and. ;
		( (cAliasRCH)->RCH_PROCES == oPeriodo:cProcesso ) .and. ;
		( (cAliasRCH)->RCH_ROTEIR == oPeriodo:cRoteiro  ) .and. ;
		( !Empty( (cAliasRCH)->RCH_DTFECH ) )

		aAdd( aLogFile, oPeriodo:cMsgPerNextClosed) // "Próximo Período de Apontamento está fechado."
		lRet := .F.
		nPerAntNext := 2

	ElseIf 	( ( (cAliasRCH)->( !Eof() ) ) 				 		 .and. ;
			( ( (cAliasRCH)->RCH_FILIAL <> oPeriodo:cFilRCH )	 .or.  ;
			( (cAliasRCH)->RCH_PROCES <> oPeriodo:cProcesso )  	 .or.  ;
			( (cAliasRCH)->RCH_ROTEIR <> oPeriodo:cRoteiro  ) ) ).or.  ;
			( (cAliasRCH)->( Eof() ))

		lNextPer := .F.
		lRet := .F.
		aAdd( aLogFile, oPeriodo:cMsgPerNextNotFound ) // "Próximo Período de Apontamento não foi encontrado. Cadastre-o para continuar."
	
	Else
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Array com as informacoes do proximo periodo - Transf. Verbas  ³
		³Periodo de Controle da Semana                                 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aAdd( aNextPer, { 	(cAliasRCH)->RCH_FILIAL	,;
							(cAliasRCH)->RCH_PER	,;
							(cAliasRCH)->RCH_NUMPAG	,;
							(cAliasRCH)->RCH_PROCES	,;
							(cAliasRCH)->RCH_ROTEIR	,;
							(cAliasRCH)->RCH_MES	,;
							(cAliasRCH)->RCH_ANO	,;
							(cAliasRCH)->RCH_DTPAGO	,;
							(cAliasRCH)->RCH_DTINI	,;
							(cAliasRCH)->RCH_DTFIM	,;
							.T.						,;
							(cAliasRCH)->(Recno())  ;							
					} )

		//Adiciona o proximo periodo no array do oPeriodo
		oPeriodo:aADDPer({{	(cAliasRCH)->RCH_FILIAL	,;		//01
							(cAliasRCH)->RCH_PROCES	,;      //02
							(cAliasRCH)->RCH_PER	,;		//03
							(cAliasRCH)->RCH_ROTEIR	,;		//04
							(cAliasRCH)->RCH_NUMPAG	,;		//05
							(cAliasRCH)->RCH_DTINI	,;		//06
							(cAliasRCH)->RCH_DTFIM	,;		//07
							(cAliasRCH)->RCH_DTFECHA,;		//08
							(cAliasRCH)->RCH_ANO	,;		//09
							(cAliasRCH)->RCH_MES	 ;		//10
					}} )
						
		While (cAliasRCH)->( !Eof() ) .and. (cAliasRCH)->RCH_FILIAL == oPeriodo:cFilRCH .and. ;
			  (cAliasRCH)->RCH_PROCES == oPeriodo:cProcesso .and. (cAliasRCH)->RCH_ROTEIR == oPeriodo:cRoteiro
			 If (cAliasRCH)->RCH_PER == oPeriodo:cPeriodo .and. (cAliasRCH)->RCH_NUMPAG == oPeriodo:cNumPagto
			 	(cAliasRCH)->( DbSkip() )
			 Else
			 	Exit
			 EndIf			  
		EndDo
		               
		If (cAliasRCH)->( Eof() ) .and. !((cAliasRCH)->RCH_FILIAL == oPeriodo:cFilRCH .and. ;
 		   (cAliasRCH)->RCH_PROCES == oPeriodo:cProcesso .and. (cAliasRCH)->RCH_ROTEIR == oPeriodo:cRoteiro)
			lNextPer := .F.
			lRet := .F.
		EndIf
	EndIf
	
	//Posiciona no registro inicial	
	DbSeek( oPeriodo:cFilRCH + oPeriodo:cProcesso + oPeriodo:cRoteiro + oPeriodo:cPeriodo + oPeriodo:cNumPagto, .F. )	
End Sequence

RestArea( aArea )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fDelMes		  ³Autor³Igor Franzoi		  ³ Data ³14/05/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Deleta os registros do Alias - Fisicamente se for Top		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   |fDelMes( cFil, cMat, cAliasMes, bCond )						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponm090                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fDelMes( cAlias, nRecno )

Local lRet  := .T.
Local aArea := GetArea()



#IFNDEF TOP

	Local cMsgErr	  := ""
	If !( cAlias )->( lRet := FkDelete( @cMsgErr ) )
	   ( cAlias )->( RollBackDelTran( cMsgErr ) )
	EndIf
	
#ELSE

	Local cDelet	  := ""
	Local cRetSqlName := InitSqlName(cAlias)

	If !lExInAs400
		cDelet    := "% "+cAlias+".D_E_L_E_T_ = ' ' %"
		cCpoRecno := "R_E_C_N_O_"
	Else
		cDelet    := "% "+cAlias+".@DELETED@ = ' ' %"
	    cCpoRecno := "RRN("+cRetSqlName+")"
	EndIf
	
	cQuery := "DELETE FROM " + cRetSqlName + " "	
    cQuery += " WHERE "
    cQuery += cRetSqlName + "." + cCpoRecno + " = " + AllTrim(Str(nRecno)) + " "
    
    TcSqlExec( cQuery )
	
	TcRefresh( cRetSqlName )
       
#ENDIF

RestArea(aArea)

Return ( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fDelRFA		  ³Autor³Igor Franzoi		  ³ Data ³12/05/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Deleta os registros do RFA - Fisicamente se for Top			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   |fDelRFA() 													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponm090                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fDelRFA()

Local aAreaRFA 	  := GetArea()
Local lRet 	      := .T.
Local cAlias   	  := "RFA"
Local cCracha	  := SRA->RA_CRACHA

#IFDEFTOP
	Local cQuery   	  := ""
	Local cAliasQry	  := ""
	Local cCpoRecno	  := ""
	Local cDelet      := ""
	Local cFilter	  := ""
	Local cQueryDelet := ""
	Local cRetSqlName := InitSqlName(cAlias)
	Local nMinRec := 0
	Local nMaxRec := 0
	Local cRecno	  := ""
	
If !lExInAs400
	cDelet    := "% RFA.D_E_L_E_T_ = ' ' %"
	cCpoRecno := "R_E_C_N_O_"
Else
	cDelet    := "% RFA.@DELETED@ = ' ' %"
    cCpoRecno := "RRN("+cRetSqlName+")"
EndIf

	cAliasQry := GetNextAlias()

	cFilter := "% RFA_CRACHA = '"+cCracha+"'"
	cFilter += " AND RFA_FLAG = '1' %"

	BeginSql alias cAliasQry
		column RFA_DATA	as Date
		%NoParser%
		SELECT 
			MAX(RFA_DATA) as RFA_DATA,
			MIN(RFA.R_E_C_N_O_) MINREC, 
			MAX(RFA.R_E_C_N_O_) MAXREC
		FROM 
			%Table:RFA% RFA
		WHERE 
			%Exp:cFilter% AND
			%Exp:cDelet%
	EndSql
	
	nMinRec := (cAliasQry)->(MINREC)
	nMaxRec := (cAliasQry)->(MAXREC)

	If !Empty(nMinRec)
			
		cQuery := "DELETE FROM " + cRetSqlName
		 
		While ( nMinRec <= nMaxRec )		
            cRecno := " WHERE "
            cRecno += "("
            cRecno +=  cCpoRecno + " >= " + AllTrim( Str( nMinRec , 18 , 0 ) )
            cRecno += " AND "
            cRecno += cCpoRecno + " <= " + AllTrim( Str( ( nMinRec += 1024 ) , 18 , 0 ) )     
            cRecno += ") AND "
            cQueryDelet := ( cQuery + cRecno + SubStr( AllTrim(cFilter), 3,Len(AllTrim(cFilter))-3 ) )

            TcSqlExec( cQueryDelet )
		End While
		
		TcRefresh( cRetSqlName )
		lRet := .T.
	EndIf
    
	(cAliasQry)->( DbCloseArea() )

#ELSE

	Local cMsgErr  	  := ""

	DbSelectArea(cAlias)
	If (cAlias)->( RecLock( cAlias , .F. ) )			
		While (cAlias)->( !Eof() .and. RFA_CRACHA = cCracha )
			If (cAlias)->(RFA_FLAG) = "1"
				If !(cAlias)->( lDeleted := FkDelete( @cMsgErr ) )
					(cAlias)->( RollBackDelTran( cMsgErr ) )
				EndIF
   			EndIf
	   			(cAlias)->( dbSkip() )
	   		End While
		(cAlias)->( MsUnlock() )
	EndIf

#ENDIF

RestArea(aAreaRFA)

Return ( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Pm090Proc	 	³Autor³  Leandro Drumond  ³ Data ³08/05/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir o parametro MV_PAR01 para variavel private		³
|		   |cProcesso    											    |
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pm090Proc()

Local lRet := .T.

cProcesso := &( ReadVar() )

lRet := PonX1Valid(cProcesso)

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Pm090Per	 	³Autor³  Leandro Drumond  ³ Data ³08/05/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir o parametro MV_PAR02 para variavel private		³
|		   |cPeriodo    											    |
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pm090Per()

Local cChave := cProcesso
Local lRet := .T.

If !Empty(cRoteiro)
	cChave += cRoteiro
Else
	cChave += "PON"
EndIf

cPeriodo := &( ReadVar() )

cChave += cPeriodo

lRet := PonX1Valid(cChave)

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Pm090Rot	 	³Autor³  Leandro Drumond  ³ Data ³08/05/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir o parametro MV_PAR03 para variavel private		³
|		   |cRoteiro    											    |
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pm090Rot()

Local lRet := .T.

cRoteiro := &( ReadVar() )

lRet := PonX1Valid(cProcesso+cRoteiro)

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Pm090NPag	 	³Autor³  Leandro Drumond  ³ Data ³08/05/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir o parametro MV_PAR04 para variavel private		³
|		   |cNumPag	    											    |
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pm090NPag()

Local lRet := .T.

cNumPagto := &( ReadVar() )

lRet := PonX1Valid(cProcesso+cRoteiro+cPeriodo+cNumPagto)

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Pnm090FPer³Autor³Igor Franzoi               ³Data³14/05/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtrar os periodos para selecao 							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pnm090FPer()

Local cOldAlias := Alias()
Local cFilRCH	:= xFilial("RCH")
Local cMsg

Local lRet 		:= .T.

Begin Sequence

	IF !( lRet := NaoVazio() )
		Break
	EndIF

	DbSelectArea( "RCH" )
	RCH->( dbsetOrder( Retorder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+DTOS(RCH_DTFECH)" ) ) )
	RCH->( dbSeek( cFilRCH + MV_PAR01 + MV_PAR02 + SPACE(6) , .F. ) )

	If RCH->( Eof() )
		lRet := .F.
		cMsg := STR0012	// "Periodo nao Cadastrado!"
		MsgInfo( cMsg )
	Else
		cPeriodo := MV_PAR02 
	EndIf

End Sequence
	
DbSelectArea(cOldAlias)

Return( lRet )
