#INCLUDE "PONX1FUN.CH"
#INCLUDE "PONCALEN.CH"
#INCLUDE "PROTHEUS.CH"  
   
#DEFINE DPORT1510  "25/11/09"



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³              ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS/FNC  ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Igor Franzoi³16/10/08³           ³Tratamento para Continuacao de Sequencia  ³±±
±±³            ³        ³           ³do Calendario do Funcionario              ³±±
±±³Leandro Dr. ³01/10/09³           ³Tratamento para que ordem do calendario   ³±±
±±³            ³        ³           ³seja gravada corretamente quando parte do ³±±
±±³            ³        ³           ³periodo estiver previamente gravado.      ³±±
±±³Francisco Jr³17/11/09³           ³Compatibilizacao fonte para uso na Versao ³±±
±±³            ³        ³           ³Corporativa - Utilizando tb com FWCODEMP- ³±±
±±³            ³        ³           ³              FWGETTAMFILIAL.             ³±±
±±³Natie       ³19/03/10³006184     ³Inclusao do tratamento para a Portaria    ³±±
±±³            ³        ³           ³1510 - fc Port1510()                      ³±±
±±Ã============================================================================´±± 
±±³                             *** Versao 11.5 ***                            ³±± 
±±Ã============================================================================´±± 
±±³Emerson     ³31/12/10³29618/     ³Ajuste para nova interface 11. Com a      ³±±
±±³Campos      ³        ³  2010     ³aplicação do parametro MV_ECMFTPP que     ³±±
±±³            ³        ³           ³afirma ser a versão 11.5 do Protheus      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Ademar Jr.  ³01/02/11³002358/2011³-PTG-Ajuste da funcao fFeriado() para tra-³±±
±±³            ³        ³           ³ tar os novos campos do Novo Modelo de Ca-³±±
±±³            ³        ³           ³ dastro de Feriados.                      ³±±
±±³Erika K.    ³28/06/11³013131/2011³Aleracao da funcao GetInfoPosTab (criacao ³±±
±±³            ³        ³           ³do operador HORAS_HABILES).               ³±±
±±³Tiago Malta ³05/07/11³014521/2011³Alterado telas para a versao p11.5.       ³±±    
±±³Claudinei S.³07/03/12³005717/2012³Ajuste para que seja feita a marcacao cor-³±±
±±³            ³        ³     TEQGXI³reta quando existirem excecoes BOL.       ³±± 
±±³Claudinei S.³21/05/12³     TEWMB1³Ajuste na CalendCria para que seja feita  ³±±
±±³            ³        ³           ³troca de turno corret. quando ja existir. ³±±
±±³Gustavo M.  ³24/05/12³     TEWMB1³Ajuste para verificar a sequencia.		   ³±±
±±³R.Berti     ³17/09/12³		 	³Ajuste da funcao fFeriado() ref. error log³±±
±±³            ³        ³           ³"SetOrder - Index not found. on FFERIADO" ³±±
±±³Luis Artuso ³22/10/13³	  THUDOC³Ajuste na funcao fBuscaDia() para verifi- ³±±
±±³            ³        ³           ³car o retorno do codigo da funcao.  	   ³±±
±±³M. Silveira ³24/10/13³     THVXOF³Ajuste na GetInfoPosTab p/ fazer a carga  ³±±
±±³            ³        ³           ³do Inic.Padrao mais rapida na troca turno.³±±
±±³Claudinei S.³08/11/13³028259/2013³Ajuste na funcao PerAponta() para evitar  ³±±
±±³            ³        ³     THZEVW³msg. solicitando MV_PAPONTA nas Ausencias.³±±
±±³Luis Artuso ³17/03/14³005748/2014³Ajuste em fGeraExtra para nao gerar error ³±±
±±³            ³        ³     TIJVXO³log.                                      ³±±
±±³Claudinei S.³22/04/14|     TPDNQ3³Ajuste na PonRelationFile() para incluir a³±±
±±³            ³        ³           ³validacao do modo de acesso entre as      ³±±
±±³            ³        ³           ³tabelas SR6 e RF8.                        ³±±
±±³Luis Artuso ³20/08/14|     TQFJ11³Ajuste para corrigir errorlog na rotina de³±±
±±³            ³        ³           ³faixa de HE autorizada, devido a nao ini- ³±±
±±³            ³        ³           ³cializacao da variavel 'oPeriodo'.        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na CriaCalend()  						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __dPerCalIni
Static __dPerCalFim                               
Static __aProcesso   
Static __cProcesso 
Static __nPosProcesso
Static __lPGenerico  
Static __nOrdIni

/*/                                          	
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na CalendCria()  						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aLstTabCal	:= {}
Static __aLstTabTno	:= {}	
Static __cKeyBldCal	:= "__cKeyBldCal"
Static __nFilTabTno	:= 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na fTabPadrao()  						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __nLstTabPadPos

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na fTabMarc()    						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aLstTbMarc

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na ToScheduleOverTime()					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aHeLastGera__
Static __cHeLastKey__

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na GetTabArred()					   	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aTabArr
Static __aTabFilArr

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na GetTabExtra()					   	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aTabEx
Static __lEscalonamento 
Static cFilStatic		//Para uso em DEFAULTFIL

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na fFeriado()   					   	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aFeriadoStatic

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Define o Numero Maximo de Ordens para o P8_ORDEM             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __nTamP8Ordem	:= InitP8PgOrdSize(1)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Define o Numero Maximo de Ordens para o PG_ORDEM             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __nTamPGOrdem	:= InitP8PgOrdSize(2)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Static com as Eventos carregados pela fEventos()             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aEvefEve__	:= {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Static para a fCargaId										  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static aCargaIdCache 	:= {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Static para a PutMarcAuto()								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static _aSpaHeader
Static _aSr6Header

Static _cSr6LastTno
Static _cSpaLastReg
Static _cSpceFuncao
Static _cSpceGiro
Static _cSpceRelogi

Static _nSpaHeader
Static _nSr6Header

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se a Execucao eh no AS/400                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
#IFDEF TOP
	Static lExInAs400 := ExeInAs400()
#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica a Existencia do Arquivo de Pre-Abonos.  ( Nao devera³
³constar em versoes Futuras )								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lRF0ChkTable 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na Calendcria e Turnos Opcionais	   	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aAllTnoOpc
Static __lChkTnoOpc := If( IsInCallStack("RHUPDMOD"), "", IF( ( ( SuperGetMv("MV_TNOOPC",NIL,"N") == "S" ) ) ,.T. , .F. ) )
                                       
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para uso em Query para preencher em branco		  ³
³o campo Motivo do Abono 								  	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __cLimpaMotAbo	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para uso da Geracao Automatica de Marcacoes		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lPnMcAut01	:= ExistBlock( "PNMCAUT01" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para manipulacao do calendario apos sua montagem	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lPnmTabCalen := ExistBlock( "PNMTABC01" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para manipulacao do calendario durante a geracao do dia	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lPnmTab01 := ExistBlock( "PNMTAB01" )  

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para Geracao/Carga do Calendario Fisico                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lUseCalFisico :=  If( IsInCallStack("RHUPDMOD"), "", ( SuperGetMv("MV_CALFIS",NIL,"0")  == "0" ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para utilizacao ou nao dos limites superiores informados - Mexico ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lMVLimSup	 := If( IsInCallStack("RHUPDMOD"), "", (If( cPaisLoc <> 'MEX' , .T. , (SuperGetMv("MV_LIMSUP",NIL,"1") == "1" ) ) ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para Controle de Uso do SPJ 								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lUseSPJ := If( IsInCallStack("RHUPDMOD"), "", ( SuperGetMv("MV_USESPJ",NIL,"0")  == "1" ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para Verificar se deve gravar o calendario			      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lCalDem := If( IsInCallStack("RHUPDMOD"), "", ( SuperGetMv("MV_CALDEM",NIL,"0")  == "1" ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Static dos campos do calendario - Estrutura do RF6/RF7				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static aStcStrRF6 := {}
Static aStcStrRF7 := {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Static dos campos do calendario p/ tabela RF6 - Apenas Gravacao	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static aStcRF6 := { {	"FILIAL",;
					   	"DATA"  ,;
						"ORDEM ",;
						"MAT   ",;
						"TURNO ",;
						"SEQ   ",;
						"TIPOD ",;
						"MOTIVO",;
						"P2ID  ",;
						"JORN  ",;
						"HRMENO",;
						"HRMAIS",;
						"HRINTV",;
						"HRTRAB",;
						"CODREF",;
						"TPEXT ",;
						"TPEXTN",;
						"NONAHR",;
						"INIHNT",;
						"FIMHNT",;
						"MINHNT",;
						"HNTTAB",;
						"HNTTBI",;
						"REGRA ",;
						"NUMARC",;
						"DORIG ",;
						"R8ID  ",;
						"FLAG  ",;
						"CHKTNO",;
						"PROCES",;
						"PERIOD",;
						"ROTEIR",;
						"NUMPAG",;
						"TPEXCE";
					};
				}
	
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Static dos campos do calendario p/ tabela RF7 - Apenas Gravacao	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static aStcRF7 := { { "FILIAL"  ,;
					   "DATA"    ,;
					   "MAT" 	 ,;
					   "LIE"	 ,;
					   "DATAE"   ,;
					   "ENTRA"   ,;
					   "LSE"	 ,;
					   "LIS"	 ,;
					   "DATAS"	 ,;
					   "SAIDA"   ,;
					   "LSS"	 ,;
					   "INTERV"  ,;
					   "JNDCO"   ,;
					   "HRINTV"  ,;
					   "HRTRAB"  ,;
					   "CC"      ,;
					   "DEPTO"   ,;
					   "POSTO"   ,;
					   "CODFUN"  ,;
					   "FLAG"     ;
				 };
			 }

Static 	cSX3ProcTit 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se Portaria 1510/2009 esta em vigor.				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lPort1510 := Port1510()    

/*           
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonxFun   ³ Autor ³ *EQUIPE RH ADVANCED*  ³ Data ³02/02/1996³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Biblioteca de Fun‡”es Utilizadas no M¢dulo SigaPon         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ Void                                                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Gen‚rico                                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³                     ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL. ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Erika K.    ³02/06/08³------³Alteracao de CH para integracao de diciona|
³            ³        ³      ³rios Mexico e R 1.2.                      ³
³Igor Franzoi³08/08/08³151614³Ver. de Base - Estrutura SPI(VerSPIStruct)³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³InPonxFunExec³ Autor ³Marinaldo de Jesus   ³ Data ³14/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executar Funcoes Dentro de PONXFUN                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³InPonxFunExec( cExecIn , aFormParam )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
Function InPonxFunExec( cExecIn , aFormParam )
         
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= &( cExecIn )
EndIF

Return( uRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AbreArqRel³ Autor ³ Equipe Advanced RH    ³ Data ³29/02/1996³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Abre o arquivo gerado pelo rel¢gio.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function AbreArqRel(	cTipoArq	,;	//01 -> Tipo do Arquivo a ser Aberto. "T"ext File, "D"ata File
						cArquivo	,;	//02 -> Caminho completo do arquivo
						nHandle		,;	//03 -> Handle do Arquivo ( Quando Tipo = "T" )
						lEnchoice	,;	//04 -> Se esta sendo Executado aa partir da Enchoice
						lStop		,;	//05 -> Se deve Emitir Mensagens
						cArqSrv		,;	//06 -> Nome do arquivo no server
						lCpyT2Srv	,;	//07 -> Se o arquivo foi copiado para o server
						lForceCopy	 ;	//08 -> Forca copia do arquivo para o server
					 )
Local aAuxRelo		:= {}
Local cSvAlias		:= Alias()
Local cExt			:= ""
Local cRdd			:= "DBFCDX"
Local cMsgAlert		:= ""
Local cPathSrv		:= Upper(GetPvProfString( GetEnvServer() , "StartPath" , "" , GetAdv97() ) )
Local lRet			:= .T.
Local nPos			:= 0
Local cPonArq		:= If( !Empty( SuperGetMv("MV_POARQ",.F.,"N") ), SuperGetMv("MV_POARQ",.F.,"N"), "2" )
Local cArqAux		:= ""

DEFAULT cTipoArq	:= "T"
DEFAULT cArquivo	:= ""
DEFAULT nHandle		:= 0
DEFAULT lEnchoice	:= .F.
DEFAULT lStop	  	:= .T.
DEFAULT cArqSrv		:= "" 
DEFAULT lCpyT2Srv	:= .F. 
DEFAULT lForceCopy	:= .F.

cArquivo			:= Upper( AllTrim( cArquivo ) )
nHandle				:= 0
cArqSrv				:= ""
lCpyT2Srv			:= .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Array com os alias dos arquivos abertos (s¢ para o PONA030)  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lEnchoice .and. cTipoArq == "D" )
	IF ( Type( "aAliasRelo" ) == "U" )
		_SetOwnerPrvt( "aAliasRelo" , {} )
	EndIF
	DEFAULT aAliasRelo := {}
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inicializa cTxtAlias uma Estancia Acima					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( Type( "cTxtAlias" ) == "U" )
	_SetOwnerPrvt( "cTxtAlias" )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem o Nome Real do Arquivo Sem Path e nem Extenso		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cTxtAlias := cArquivo


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Alteracao solcitada pelo Andre Gentil para contornar a situa ³
³ cao de nao gravacao de arquivo do remote para o servidor.    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
/*
IF ( ( nPos := At( ":" , cTxtAlias ) ) > 0 )
	cTxtAlias := SubStr( cTxtAlias , ++nPos )
EndIF
*/

While ( At( "\" , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "\" , cTxtAlias ) ) > 0 )
		cTxtAlias := SubStr( cTxtAlias , ++nPos )
	EndIF
End While

While ( At( "/" , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "/" , cTxtAlias ) ) > 0 )
		cTxtAlias := SubStr( cTxtAlias , ++nPos )
	EndIF
End While
While ( At( "." , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "." , cTxtAlias ) ) > 0 )
		cTxtAlias := Left( cTxtAlias , --nPos )
	EndIF
End While

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Extensao do Arquivo								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( ( nPos := At( "." , cArquivo ) ) > 0 )
	cExt := Upper( AllTrim( SubStr( cArquivo , nPos ) ) )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica a Existencia de "\" ou "/" barras separadoras de diretorio  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !( Subst( cPathSrv , 1 , 1 ) $ "\/" )
	cPathSrv := "\"+cPathSrv
EndIF
IF !( Subst( cPathSrv , -1	) $ "\/" )
	cPathSrv+= "\"
EndIF  

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Obtem o Nome do arquivo no Server 							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cArqSrv := Upper( AllTrim( ( cPathSrv + ( cTxtAlias + cExt ) ) ) )

                         
If lEnchoice
    If !Empty(aAliasRelo)   
       nPos:=0   
       For nPos:=1 To Len(aAliasRelo)
           fCloseArqRel(	aAliasRelo, nPos, 	aAliasRelo[nPos,01 ],  aAliasRelo[nPos,02 ], aAliasRelo[nPos,03 ],;
           										aAliasRelo[nPos,04 ],  aAliasRelo[nPos,05 ], aAliasRelo[nPos,06 ],;
           										cTxtAlias, cArquivo ;
           				)
       Next nPos                    
       aAuxRelo		:= Aclone(aAliasRelo)
       aAliasRelo	:= {}             
       //-- Nao considera arquivo marcados para delecao
       Aeval(aAuxRelo, {|x| If ( x[1] == "DEL", NIL, AADD(aAliasRelo,aClone(x)) ) } )
      				 
	   lCpyT2Srv	:= ( aScan( aAliasRelo , {|x| x[1] == cTxtAlias .AND. x[02] .and.    x[04 ]  == cTipoArq .and. x[06 ]  == cArquivo  } ) > 0 ) 
	Endif   
Endif		
	    
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³cPonArq - indica que só copia o arquivo para o StartPath caso ³
³o parametro MV_POARQ esteja com valor NÃO					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If (cPonArq != "1")
	If !lCpyT2Srv  .or. lForceCopy
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Copia o arquivo para o Servidor							   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lCpyT2Srv := !(;
								( cArquivo == StrTran( cArqSrv , "/" , "\" ) ) .and.;
								( cArquivo == StrTran( cArqSrv , "\" , "/" ) );
							);
			)  
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Quando o Arquivo Nao Estiver no Server     				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lCpyT2Srv := !( Upper( StrTran( cArquivo , " " , "" ) ) == Upper( StrTran( cArqSrv , " " , "" ) ) ) )
		
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Copia-o                                    				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			    //lCpyT2Srv := __CopyFile( cArquivo , cArqSrv ) //__CopyFile() Recomendacao do Fernando Ramalho ao Inves do CpyT2S() 14/10/2002 16:38h. Naldo.
		
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Alteracao solcitada pelo Andre Gentil para contornar a situa ³
				³ cao de nao gravacao de arquivo do remote para o servidor.    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		       
				IF ( ( At( ":" , cArquivo ) ) > 0 )
					lCpyT2Srv := CpyT2S( cArquivo , cPathSrv ) //CpyT2S() Recomendacao do Andre Gentil 13/12/2005 11:55h. Mauricio.
				Else
					cArquivo  := cPathSrv + cArquivo
					lCpyT2Srv := __CopyFile( cArquivo , cArqSrv ) //__CopyFile() Recomendacao do Fernando Ramalho ao Inves do CpyT2S() 14/10/2002 16:38h. Naldo.
				Endif
		        
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ No Ap7 Existe uma Nao  Conformidade com o Retorno da 	 funcao³
				³ __CopyFile(). Esta retornando NIL Quando deveria Retornar .T.³
				³ ou .F. Caso Tenha Conseguido ou Nao Copiar o Arquivo. Ate que³
				³ a Nao Conformidade Seja corrigida o valor DEFAULT da variavel³
				³ de Retorno da __CopyFile ( lCpyT2Srv ) sera False (.F.)  Caso³
				³ Contrario sera o Proprio retorno da Funcao				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				DEFAULT lCpyT2Srv := .F.
		
			EndIF
		Endif
	EndIF
EndIf


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Tratamento de acordo com o Tipo de Arquivo					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( cTipoArq == "D" )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Abre o arquivo no padr„o DBASE								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( !Empty( cTxtAlias ) .and. Select( cTxtAlias ) > 0 )
		( cTxtAlias )->( dbCloseArea() )
		IF ( Select( cSvAlias ) > 0 )
			dbSelectArea( cSvAlias )
		EndIF	
	EndIF
	IF ( lRet := MsFile( cArqSrv , NIL , cRdd ) )
		IF (;
				!( CheckExecForm( { || lRet := MsOpenDbf( .T. , cRdd , cArqSrv , cTxtAlias , .T. , .F. ) } , lStop , "NODBFFILE" ) );
				.or.;
				!( lRet );
			 )
			lRet		:= .F.
			cMsgAlert	:= ( STR0156 + " " + cArqSrv )	//'Nao foi possivel abrir o arquivo:'
		EndIF
	Else
		cMsgAlert := ( STR0058 + cArqSrv ) 				//"Arquivo do Relogio nao Encontrado no Servidor: "
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Inclui o Alias aberto para posterior fechamento			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lEnchoice .and. Select( cTxtAlias ) > 0 )
		IF  ( ( nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )) == 0 )
			aAdd( aAliasRelo , { cTxtAlias , lCpyT2Srv , cArqSrv , cTipoArq , nHandle, cArquivo } )
		Else
			aAliasRelo[ nPos , 02 ] := lCpyT2Srv
			aAliasRelo[ nPos , 03 ]	:= cArqSrv
			aAliasRelo[ nPos , 04 ]	:= cTipoArq
			aAliasRelo[ nPos , 05 ]	:= nHandle
			aAliasRelo[ nPos , 06 ]	:= cArquivo
		EndIF
	EndIF
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Abre o arquivo no padr„o ASCII								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lRet := File( cArqSrv ) ) 
	   	nPos	:= 0 
   		IF ( Type( "aAliasRelo" ) <> "U" )
		   	//-- Verifica a necessidade de abrir o arquivo caso o mesmo não esteja aberto.
		    nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )
		Endif
		If nPos == 0
			nHandle := fOpen( cArqSrv )
			IF ( fError() # 0 .or. nHandle < 0 )
				cMsgAlert := ( STR0156 + " " + cArqSrv )	//'Nao foi possivel abrir o arquivo:'
				lRet := .F.
			EndIF
		Endif	
	Else
		cMsgAlert := ( STR0058 + cArqSrv )				//"Arquivo do Relogio nao Encontrado no Servidor:
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Inclui o Alias aberto para posterior fechamento			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lEnchoice .and. nHandle > 0 )
		IF  ( ( nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )) == 0 )
			aAdd( aAliasRelo , { ALLTRIM(cTxtAlias) , lCpyT2Srv , cArqSrv , cTipoArq , nHandle, cArquivo } )
		Else
			aAliasRelo[ nPos , 02 ] := lCpyT2Srv
			aAliasRelo[ nPos , 03 ]	:= cArqSrv
			aAliasRelo[ nPos , 04 ]	:= cTipoArq
			aAliasRelo[ nPos , 05 ]	:= nHandle
			aAliasRelo[ nPos , 06 ]	:= cArquivo
		EndIF
	EndIF
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Mensagens de Nao Abertura dos Arquivos             		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lStop .and. !lRet )
	IF !Empty( cMsgAlert )
		MsgAlert( cMsgAlert , STR0059 ) //"Alerta"
	Else
		Help( "" , 1 , "A030NOPEN" )
	EndIF
EndIF

Return( lRet )


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCloseArqRel³ Autor ³ Equipe Advanced RH  ³ Data ³29/02/1996³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fecha o arquivo gerado pelo rel¢gio.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/

Static Function fCloseArqRel(aAliasRelo, nFile, cTxtAlias, lCpyT2Srv, cArqSrv, cTipoArq, nHandle, cArq, cTxt, cArquivo)

//-- Quando o arquivo a ser consultado possuir o mesmo nome de algum arquivo anteriormente lido
//-- Fecha e elimina o arquivo anterior 
If ( cTxtAlias == cTxt)  .and. ( cArq  <> cArquivo ) 
	 
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Fecha os Arquivos Abertos em AbreArqRel()					 			 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( cTipoArq == "D" )
		TxtAliasClose( cTxtAlias )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se copiou para o server, Exclui                           			 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lCpyT2Srv )
			If ( fErase(Lower( cArqSrv ) ) < 0 )
					MsgAlert( fError() , STR0059 ) //"Alerta"
			Endif   
		EndIF
	ElseIF (;
				( cTipoArq == "T" );
				.and.;
				( nHandle > 0 );
			)	
		fClose( nHandle ) 
		If ( fErase(Lower( cArqSrv ) ) < 0 )
			MsgAlert( fError() , STR0059 ) //"Alerta"
		Endif   
	EndIF
	aAliasRelo[nFile, 1] := "DEL"
Endif
Return (NIL)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ProcForm  ³ Autor ³ Wiliam                ³ Data ³ 29.02.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para tratamento da formula                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function ProcForm( cFormula )

Local bErro       := ErrorBlock( { |e| ErrorForm( e ) } )
Local lResult     := .T.

IF ( ValType( cFormula ) == "C" )
	cFormula := AllTrim( cFormula )
	IF Len(cFormula) > 0
		lResult := ExecForm( cFormula )
	EndIF
Else
	lResult := ExecForm( cFormula )
EndIF	

ErrorBlock( bErro )

Return( lResult )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ExecForm	³ Autor ³ Wiliam                ³ Data ³ 29.02.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Executa a formula e retorna o resultado                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function ExecForm( cFormula )

Local xRet
Begin Sequence
	xRet := &(cFormula)
	If !ValType( xRet ) == "C"
		Help(" ",1,"FNOCHAR" )
		xRet := .F.
	Else
		xRet := .T.
	Endif
	RECOVER
	Help(" ",1,"FORMINVAL" , , OemToAnsi( GetTitulo() ) , 5 , 0 )
	xRet := .F.
End Sequence

Return( xRet )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GetTitulo ³ Autor ³ Mauricio MR           ³ Data ³ 16.09.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Obtem o Titulo em SX3 correspondente a variavel lida       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function GetTitulo()

Local aArea			:= GetArea()
Local aAreaSX3 		:= SX3->( GetArea() )   
Local aAreaSXA 		:= SXA->( GetArea() )   
Local cCampo		:= UPPER(StrTran(ReadVar(),"M->",""))
Local cTitulo		:= ''          
Local cAlias      	:= ''
Local cFolder   	:= ''

SX3->( dbSetOrder( 02 ) ) 

//-- Obtem informacoes sobre o campo 
IF SX3->( dbSeek(cCampo) )
   cTitulo		:=  STR0154 + X3TITULO(SX3->X3_TITULO)
   cAlias		:= SX3->(X3_ARQUIVO) 
   cFolder		:= SX3->(X3_FOLDER) 
    //-- Obtem Informacoes sobre o nome da Pasta se Existir
	If !Empty(cFolder)               
		IF SXA->( dbSeek(cAlias+cFolder) )
		   cTitulo:= STR0153+ALLTRIM(XADESCRIC()) + ' / ' +cTitulo
		Endif	
	Endif
Endif	

RestArea( aAreaSXA )
RestArea( aAreaSX3 ) 
RestArea( aArea) 

Return( cTitulo )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ErrorForm ³ Autor ³ Wiliam                ³ Data ³ 29.02.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para tratamento de erros da formula                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function ErrorForm( oError )

IF ( oError:gencode > 0 )
	Break
ENDIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fTabPadrao³ Autor ³ Equipe Advanced RH    ³ Data ³ 15/03/96 ³
³		   ³		  ³ 	  ³ Ver. II - Igor Franzoi³ Data ³ 12/11/07 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna um array com a tabela de hor rio padr„o do turno.   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fTabPadrao( aTabTno , cFil , cTurno )						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTab   - Array com os Dados da Tabela                       ³
³          ³cFil   - Filial Para Pesquisa                               ³
³          ³cTurno - Turno para Pesquisa                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ lRet                                                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTabPadrao( aTabTno , cFil , cTurno , lExecQryTop , bCond )

Local aArray		:= {}
Local aCpos			:= Array(2,53)
Local aRet			:= {}
Local aLin		    := {}
Local cPrefixo		:= If( lUseSPJ, "PJ", "RF2" )
Local cAlias		:= If( lUseSPJ, "SPJ", "RF2" )
Local cAliasQuery	:= cAlias

Local cCustoSpace   := Space( GetSx3Cache( "RA_CC" 		, "X3_TAMANHO" ) )
Local cFuncaoSpace  := Space( GetSx3Cache( "RA_CODFUNC" , "X3_TAMANHO" ) )
Local cDeptoSpace	:= Space( GetSx3Cache( "RA_DEPTO" 	, "X3_TAMANHO" ) )
Local cPostoSpace	:= Space( GetSx3Cache( "RA_POSTO" 	, "X3_TAMANHO" ) )
Local cPerSpace		:= Space( GetSx3Cache( "RCH_PER" 	, "X3_TAMANHO" ) )
Local cRotSpace		:= Space( GetSx3Cache( "RCH_ROTEIR" , "X3_TAMANHO" ) )
Local cProcesSpace	:= Space( GetSx3Cache( "RCH_PROCES" , "X3_TAMANHO" ) )
Local cNumPgSpace	:= Space( GetSx3Cache( "RCH_NUMPAG" , "X3_TAMANHO" ) )
Local cCodJorn		:= Space( GetSx3Cache( "RF3_JORN" 	, "X3_TAMANHO" ) )
Local cLI1ESpace	:= Space( GetSx3Cache( "RF3_LI1E" 	, "X3_TAMANHO" ) )
Local cLS1ESpace	:= Space( GetSx3Cache( "RF3_LS1E" 	, "X3_TAMANHO" ) )
Local cLI1SSpace	:= Space( GetSx3Cache( "RF3_LI1S" 	, "X3_TAMANHO" ) )
Local cLS1SSpace	:= Space( GetSx3Cache( "RF3_LS1S" 	, "X3_TAMANHO" ) )
Local cLI2ESpace	:= Space( GetSx3Cache( "RF3_LI2E" 	, "X3_TAMANHO" ) )
Local cLS2ESpace	:= Space( GetSx3Cache( "RF3_LS2E" 	, "X3_TAMANHO" ) )
Local cLI2SSpace	:= Space( GetSx3Cache( "RF3_LI2S" 	, "X3_TAMANHO" ) )
Local cLS2SSpace	:= Space( GetSx3Cache( "RF3_LS2S" 	, "X3_TAMANHO" ) )
Local cLI3ESpace	:= Space( GetSx3Cache( "RF3_LI3E" 	, "X3_TAMANHO" ) )
Local cLS3ESpace	:= Space( GetSx3Cache( "RF3_LS3E" 	, "X3_TAMANHO" ) )
Local cLI3SSpace	:= Space( GetSx3Cache( "RF3_LI3S" 	, "X3_TAMANHO" ) )
Local cLS3SSpace	:= Space( GetSx3Cache( "RF3_LS3S" 	, "X3_TAMANHO" ) )
Local cLI4ESpace	:= Space( GetSx3Cache( "RF3_LI4E" 	, "X3_TAMANHO" ) )
Local cLS4ESpace	:= Space( GetSx3Cache( "RF3_LS4E" 	, "X3_TAMANHO" ) )
Local cLI4SSpace	:= Space( GetSx3Cache( "RF3_LI4S" 	, "X3_TAMANHO" ) )
Local cLS4SSpace	:= Space( GetSx3Cache( "RF3_LS4S" 	, "X3_TAMANHO" ) )
Local cIdExce		:= Space( GetSx3Cache( "P2_ID" 		, "X3_TAMANHO" ) )
Local cTpExce		:= Space( GetSx3Cache( "P2_TPEXCE"	, "X3_TAMANHO" ) )

Local cFilTno		:= ""
Local lRet      	:= .T.
Local nPos			:= 0
Local nLenTab		:= 0
Local nRecno		:= 0
Local nFieldTot		:= 0

Local cQuery	 		:= ""
Local cJoin				:= ""
Local cWhere			:= ""
Local cSvAlias			:= Alias()
Local cCpoRecno 		:= ""
Local lQueryOpened		:= .F.
Local nX				:= 0

Static aSpjFields

Static cQrySpjFields
Static nSpjFields

DEFAULT lExecQryTop	:= .T.

aFill( aCpos[1], Space(1) )

aCpos[1]	:= { 	{||PJ_ENTRA1}	,;	// 01 - Primeira Entrada
					{||PJ_SAIDA1}	,;	// 02 - Primeira Saida
					{||PJ_ENTRA2}	,;	// 03 - Segunda Entrada
					{||PJ_SAIDA2}	,;	// 04 - Segunda Saida
					{||PJ_ENTRA3}	,;	// 05 - Terceira Entrada
					{||PJ_SAIDA3}	,;	// 06 - Terceira Saida
					{||PJ_ENTRA4}	,;	// 07 - Quarta Entrada
					{||PJ_SAIDA4}	,;	// 08 - Quarta Saida
					{||PJ_HRSTRAB}	,;	// 09 - Numero de Horas Trabalhadas 1a. Jornada
					{||PJ_HRSTRA2}	,;	// 10 - Numero de Horas Trabalhadas	2a. Jornada
					{||PJ_HRSTRA3}	,;	// 11 - Numero de Horas Trabalhadas 3a. Jornada
					{||PJ_HRSTRA4}	,;	// 12 - Numero de Horas Trabalhadas 4a. Jornada
					{||PJ_HRSINT1}	,;	// 13 - Numero de Horas 1o. Intervalo
					{||PJ_HRSINT2}	,;	// 14 - Numero de Horas 2o. Intervalo
					{||PJ_HRSINT3}	,;	// 15 - Numero de Horas 3o. Intervalo
					{||""}			,;	// 16 - Marcacao Refere-se ao Proximo Dia
					{||0}			,;	// 17 - TabMarc("SPJ")	Numero de Marcacoes da Tabela
					{||PJ_TPDIA}	,;  // 18 - Tipo do Dia
					{||PJ_SEMANA}	,;	// 19 - Sequencia da Marcacao
					{||Val(PJ_DIA)}	,;  // 20 - Numero Correspondente ao Dia da Semana
					{||"N"}			,;  // 21 - Refere-se a Excecao
					{||""}			,;  // 22 - Motivo da Excecao
					{||PJ_TPEXT}	,;  // 23 - Tipo de Extra Normal
					{||PJ_TPEXTN}	,;	// 24 - Tipo de Extra Noturna
					{||cCustoSpace} ,;	// 25 - Centro de Custo Periodo 1
					{||cCustoSpace} ,;  // 26 - Centro de Custo Periodo 2
					{||cCustoSpace} ,;	// 27 - Centro de Custo Periodo 3
					{||cCustoSpace} ,;	// 28 - Centro de Custo Periodo 4
					{||PJ_NONAHOR} 	,;	// 29 - Aponta Nona Hora
					{||PJ_HORMENO}	,;	// 30 - Limite de Horario Inicial
					{||PJ_HORMAIS}	,;	// 31 - Limite de Horario Final
					{||PJ_JND1CON}	,;	// 32 - 1a. Jornada Continua
					{||PJ_JND2CON}	,;	// 33 - 2a. Jornada Continua
					{||PJ_JND3CON}	,;	// 34 - 3a. Jornada Continua
					{||PJ_JND4CON}	,;	// 35 - 4a. Jornada Continua
					{||PJ_CODREF} 	,;	// 36 - Codigo da Refeicao
					{||nRecno}		,;	// 37 - Recno
					{||cFuncaoSpace},;  // 38 - Codigo de funcao Periodo 1
					{||cFuncaoSpace},;  // 39 - Codigo de funcao Periodo 2
					{||cFuncaoSpace},;  // 40 - Codigo de funcao Periodo 3
					{||cFuncaoSpace},;  // 41 - Codigo de funcao Periodo 4
					{||cLI1ESpace}  ,;  // 42 - Limite inferior 1E
					{||cLS1ESpace}  ,;  // 43 - Limite superior 1E
					{||cLI1SSpace}  ,;  // 44 - Limite inferior 1S
					{||cLS1SSpace}  ,;  // 45 - Limite superior 1S
					{||cLI2ESpace}  ,;  // 46 - Limite inferior 2E
					{||cLS2ESpace}  ,;  // 47 - Limite superior 2E
					{||cLI2SSpace}  ,;  // 48 - Limite inferior 2S
					{||cLS2SSpace}  ,;  // 49 - Limite superior 2S
					{||cLI3ESpace}  ,;  // 50 - Limite inferior 3E
					{||cLS3ESpace}  ,;  // 51 - Limite superior 3E
					{||cLI3SSpace}  ,;  // 52 - Limite inferior 3S
					{||cLS3SSpace}  ,;  // 53 - Limite superior 3S
					{||cLI4ESpace}  ,;  // 54 - Limite inferior 4E
					{||cLS4ESpace}  ,;  // 55 - Limite superior 4E
					{||cLI4SSpace}  ,;  // 56 - Limite inferior 4S
					{||cLS4SSpace}	,;  // 57 - Limite superior 4S
					{||cDeptoSpace} ,;  // 58 - Codigo de departamento Periodo 1
					{||cDeptoSpace} ,;  // 59 - Codigo de departamento Periodo 2
					{||cDeptoSpace} ,;  // 60 - Codigo de departamento Periodo 3
					{||cDeptoSpace} ,;  // 61 - Codigo de departamento Periodo 4
					{||cPostoSpace} ,;  // 62 - Codigo de posto Periodo 1
					{||cPostoSpace} ,;  // 63 - Codigo de posto Periodo 2
					{||cPostoSpace} ,;  // 64 - Codigo de posto Periodo 3
					{||cPostoSpace} ,;  // 65 - Codigo de posto Periodo 4
					{||cProcesSpace},;  // 66 - Codigo de processo
					{||cNumPgSpace} ,;  // 67 - Numero de Pagamento
					{||cPerSpace}   ,;  // 68 - Codigo de Periodo
					{||cRotSpace}   ,;  // 69 - Roteiro de calculo da folhalculo da folha
					{||cCodJorn} 	,;  // 70 - Codigo de Jornada
					{||cIdExce}	    ,;  // 71 - Id da excecao
					{||cTpExce}      ;	// 72 - Tipo de excecao
         }
			
#IFDEF TOP

	IF ( lExInAs400 )
		lExecQryTop	:= .F.
	EndIF	

	IF ( lExecQryTop )
		
		DEFAULT aSpjFields	:= fStructPad()
		DEFAULT nSpjFields 	:= Len( aSpjFields )

		IF ( cQrySpjFields == NIL )
			cQrySpjFields := ""
			For nX := 1 To nSpjFields
				cQrySpjFields += aSpjFields[ nX , 01 ] + ", "
			Next nX
	    EndIF
	EndIF

#ENDIF

DEFAULT aTabTno			:= {}
DEFAULT cTurno			:= Space( GetSx3Cache( "RA_TNOTRAB" , "X3_TAMANHO" ) )
DEFAULT bCond			:= { || .T. }
DEFAULT __nLstTabPadPos	:= 0
                                       
cFil	:= xFilial( cAlias , cFil )
cFilTno := ( cFil + cTurno )

IF ( ( ( nLenTab := Len( aTabTno ) ) == 0 ) .or. ( __nLstTabPadPos > nLenTab ) )
	__nLstTabPadPos := 0
EndIF

IF ( ( __nLstTabPadPos == 0 ) .or. !( ( aTabTno[ __nLstTabPadPos , 01 ] + aTabTno[ __nLstTabPadPos , 02 ] ) == cFilTno ) )
	IF ( ( nPos := aScan( aTabTno , { |x| x[1]+x[2] == cFilTno } ) ) == 0 ) .AND. !Empty(cTurno) 
		( aAdd( aTabTno, { cFil , cTurno , aArray } ) , ( __nLstTabPadPos := ( nLenTab := Len( aTabTno ) ) ) )
		#IFDEF TOP
			IF ( lExecQryTop )
				cCpoRecno	:= IF( lExInAs400 , "RRN("+InitSqlName( cAlias )+")", "R_E_C_N_O_" )
				cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
				cQuery := "SELECT "
				cQuery += cQrySpjFields
				If lUseSPJ
					cQuery += cCpoRecno + " RECNO "
				Else
					cQuery += cAlias+"."+cCpoRecno + " RECNO "
				EndIf
				cQuery += " FROM "
				If lUseSPJ
					cQuery += InitSqlName( cAlias )
					cWhere += " WHERE "
					cWhere += "PJ_FILIAL='"+cFil+"'"
					cWhere += " AND "
					cWhere += "PJ_TURNO='"+cTurno+"'"
					cWhere += " AND "
					cWhere += "D_E_L_E_T_=' ' "
				Else
					cJoin += InitSqlName("RF2") + " RF2 "
					cJoin += " INNER JOIN " + InitSqlName("RF4") + " RF4 ON RF2.RF2_HOR = RF4.RF4_HOR "
					cJoin += " INNER JOIN " + InitSqlName("RF5") + " RF5 ON RF2.RF2_TIPOD = RF5.RF5_TIPO AND RF5.RF5_DIA  = RF4.RF4_DIA "
					cJoin += " INNER JOIN " + InitSqlName("RF3") + " RF3 ON RF4.RF4_JORN = RF3.RF3_JORN "
					cWhere += " WHERE "
					cWhere += " RF2.RF2_FILIAL = '"+cFil+"'"
					cWhere += " AND RF3.RF3_FILIAL = '"+cFil+"'"
					cWhere += " AND RF4.RF4_FILIAL = '"+cFil+"'"
					cWhere += " AND RF5.RF5_FILIAL = '"+cFil+"'"
					cWhere += " AND RF2.RF2_TURNO = '"+cTurno+"'"
					cWhere += " AND RF2.D_E_L_E_T_=' '"
					cWhere += " AND RF3.D_E_L_E_T_=' '"
				EndIf
				cQuery += cJoin + cWhere
				cQuery += " ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
				cQuery := ChangeQuery( cQuery )
				IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
					For nX := 1 To nSpjFields
						IF !( aSpjFields[ nX , 02 ] == "C" )
							TcSetField(cAliasQuery,aSpjFields[nX,01],aSpjFields[nX,02],aSpjFields[nX,03],aSpjFields[nX,04])
						EndIF
					Next nX
					lRet := ( cAliasQuery )->( !Eof() )
				Else
					cAliasQuery	:= cAlias
					lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )
				EndIF
			Else
				cAliasQuery	:= cAlias
				lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )
			EndIF
		#ELSE
			lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )
		#ENDIF
			IF ( lRet )
				While ( cAliasQuery )->( !Eof() .and. ( cFilTno == (&(cPrefixo+"_FILIAL")+&(cPrefixo+"_TURNO")) ) )
					IF !( cAliasQuery )->( Eval( bCond ) )
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
					#IFNDEF TOP
						nRecno := ( cAliasQuery )->( Recno() )
						If !lUseSpj
							fMntTabPad( cFil,;
										(cAliasQuery)->(RF2_HOR),;
										(cAliasQuery)->(RF2_TIPOD),;
										(cAliasQuery)->(RF2_SEMANA),;
										@aRet,;
										nRecno,;
										lExecQryTop,;
										lQueryOpened,;
										cAliasQuery )
							aTabTno[nLenTab,3 ] := aClone( aRet )
						Else  
						     aLin := {}
							aEval( aCpos[1], { |x| aAdd( aTabTno[nLenTab,3 ], ( cAliasQuery )->(Eval(x) )) } )						
							( cAliasQuery )->( aAdd( aTabTno[nLenTab,3 ] , aClone(aLin)  ) )
						EndIf						
					#ELSE
						IF ( ( lExecQryTop ) .and. ( lQueryOpened ) )
							nRecno := ( cAliasQuery )->( RECNO )
						Else           
							nRecno := ( cAliasQuery )->( Recno() )
						EndIF
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Monta os registros a partir das tabelas RF3/RF4/RF5		  ³
						³Caso nao esteja utilizando SPJ								  ³						
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						If !lUseSpj
							fMntTabPad( cFil,;
										(cAliasQuery)->(RF2_HOR),;
										(cAliasQuery)->(RF2_TIPOD),;
										(cAliasQuery)->(RF2_SEMANA),;
										@aRet,;
										nRecno,;
										lExecQryTop,;
										lQueryOpened,;
										cAliasQuery )
							aTabTno[nLenTab,3 ] := aClone( aRet )
						Else
						    aLin := {}
							aEval( aCpos[1], { |x| aAdd( aLin, ( cAliasQuery )->(Eval(x) )) } )
							( cAliasQuery )->( aAdd( aTabTno[nLenTab,3 ] , aClone(aLin)  ) )
						EndIf
					#EndIF
					( cAliasQuery )->( dbSkip() )	                                                            
				End While
			EndIF
		#IFDEF TOP
			IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
				( cAliasQuery )->( dbCloseArea() )
				dbSelectArea( cAlias )
				If ( !Empty(cSvAlias) .And. Select( cSvAlias ) > 0 )
					dbSelectArea( cSvAlias )
				EndIf
			EndIF
		#ENDIF
	Else
	   	If nPos > 0
			__nLstTabPadPos := nPos
		Endif
	EndIF
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fStructPad³ Autor ³ Igor Franzoi	      ³ Data ³ 13/11/07 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna um array com a estrutura(s) tabela de hor rio padr„o³
³		   ³para utilizar na query										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fStructPad()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ aStruct - Array que contem os campos da query              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
#IFDEF TOP
Static Function fStructPad()

Local aStruct := {}

Local cAlias 	:= ""
Local cAliasSPJ := "SPJ"

Local nCont
Local nFields
Local aAuxStruct := {}

If lUseSPJ
	aStruct := (cAliasSPJ)->(dbStruct())
Else
	For nCont := 1 To 4
		If( nCont == 1, cAlias := "RF2", If( nCont == 2, cAlias := "RF3", If( nCont == 3, cAlias := "RF4", cAlias := "RF5" ) ) )
		aAuxStruct := (cAlias)->(dbStruct())
		For nFields := 1 To Len(aAuxStruct)
			aAdd(aStruct, aAuxStruct[nFields])
		Next
	Next
EndIf

Return ( aStruct )
#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fMntTabPad³ Autor ³ Igor Franzoi	      ³ Data ³ 14/11/07 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Seleciona os dados do RF4/RF5/RF3							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fMntTabPad()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cFil = filial												³
³		   ³ cHor = codigo do horario									³
³		   ³ cDia = codigo do tipo de dia								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ aRet														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fMntTabPad( cFil, cHor, cDia, cSem, aRet, nRecno, lExecQryTop, lQueryOpened, cAliasQuery)

Local aCpos	  := {}
Local nCont	  := 0
Local aArea   := GetArea()

Local cAliasRF3	 := "RF3"
Local cAliasRF4  := "RF4"

Local nOrderRf4 := 0

Local aRetRF5 	 := {}

DEFAULT aRet := {}

If ( lExecQryTop .and. lQueryOpened )

	(cAliasQuery)->( aAdd( aRet,{  RF3_ENTRA1		,; // 01 - Primeira Entrada
								   RF3_SAIDA1		,; // 02 - Primeira Saida
								   RF3_ENTRA2		,; // 03 - Segunda Entrada
								   RF3_SAIDA2		,; // 04 - Segunda Saida
								   RF3_ENTRA3		,; // 05 - Terceira Entrada
								   RF3_SAIDA3		,; // 06 - Terceira Saida
								   RF3_ENTRA4		,; // 07 - Quarta Entrada
								   RF3_SAIDA4		,; // 08 - Quarta Saida
								   RF3_HRTRAB	    ,; // 09 - Numero de Horas Trabalhadas 1a. Jornada
								   RF3_HRTRA2		,; // 10 - Numero de Horas Trabalhadas	2a. Jornada
								   RF3_HRTRA3		,; // 11 - Numero de Horas Trabalhadas 3a. Jornada
								   RF3_HRTRA4		,; // 12 - Numero de Horas Trabalhadas 4a. Jornada
								   RF3_HRINT1  		,; // 13 - Numero de Horas 1o. Intervalo
								   RF3_HRINT2		,; // 14 - Numero de Horas 2o. Intervalo
								   RF3_HRINT3		,; // 15 - Numero de Horas 3o. Intervalo
								   ""       		,; // 16 - Marcacao Refere-se ao Proximo Dia
								   0				,; // 17 - TabMarc("SPJ")	Numero de Marcacoes da Tabela
								   RF5_TPDIA		,; // 18 - Tipo do Dia
								   RF2_SEMANA		,; // 19 - Sequencia da Marcacao
								   Val(RF5_DIA)		,;  // 20 - Numero Correspondente ao Dia da Semana
								   "N"				,; // 21 - Refere-se a Excecao
								   ""				,; // 22 - Motivo da Excecao
								   RF5_TPEXT		,; // 23 - Tipo de Extra Normal
								   RF5_TPEXTN		,; // 24 - Tipo de Extra Noturna
								   ""    			,; // 25 - Centro de Custo Periodo 1
								   ""    			,; // 26 - Centro de Custo Periodo 2
								   ""    			,; // 27 - Centro de Custo Periodo 3
								   ""    			,; // 28 - Centro de Custo Periodo 4
								   RF5_NONAHR   	,; // 29 - Aponta Nona Hora
								   RF3_HRMENO    	,; // 30 - Limite de Horario Inicial
								   RF3_HRMAIS    	,; // 31 - Limite de Horario Final
								   RF3_JND1CO     	,; // 32 - 1a. Jornada Continua
								   RF3_JND2CO     	,; // 33 - 2a. Jornada Continua
								   RF3_JND3CO     	,; // 34 - 3a. Jornada Continua
								   RF3_JND4CO     	,; // 35 - 4a. Jornada Continua
								   RF5_CODREF   	,; // 36 - Codigo da Refeicao
	 							   Recno			,; // 37 - Recno
								   ""				,; // 38 - Codigo de funcao Periodo 1
								   ""				,; // 39 - Codigo de funcao Periodo 1
								   ""				,; // 40 - Codigo de funcao Periodo 1
								   ""				,; // 41 - Codigo de funcao Periodo 1
								   RF3_LI1E     	,; // 42 - Limite inferior 1E
								   RF3_LS1E     	,; // 43 - Limite superior 1E
								   RF3_LI1S     	,; // 44 - Limite inferior 1S
								   RF3_LS1S     	,; // 45 - Limite superior 1S
								   RF3_LI2E     	,; // 46 - Limite inferior 2E
								   RF3_LS2E     	,; // 47 - Limite superior 2E
								   RF3_LI2S     	,; // 48 - Limite inferior 2S
								   RF3_LS2S     	,; // 49 - Limite superior 2S
								   RF3_LI3E     	,; // 50 - Limite inferior 3E
								   RF3_LS3E     	,; // 51 - Limite superior 3E
								   RF3_LI3S     	,; // 52 - Limite inferior 3S
								   RF3_LS3S     	,; // 53 - Limite superior 3S
								   RF3_LI4E     	,; // 54 - Limite inferior 4E
								   RF3_LS4E     	,; // 55 - Limite superior 4E
								   RF3_LI4S     	,; // 56 - Limite inferior 4S
								   RF3_LS4S			,; // 57 - Limite superior 4S
								   ""    			,; // 58 - Codigo de departamento Periodo 1
								   ""    			,; // 59 - Codigo de departamento Periodo 2
								   ""    			,; // 60 - Codigo de departamento Periodo 3
								   ""    			,; // 61 - Codigo de departamento Periodo 4
								   ""    			,; // 62 - Codigo de posto Periodo 1
								   ""    			,; // 63 - Codigo de posto Periodo 2
								   ""    			,; // 64 - Codigo de posto Periodo 3
								   ""    			,; // 65 - Codigo de posto Periodo 4
								   ""   			,; // 66 - Codigo de processo
								   ""     			,; // 67 - Numero de Pagamento
								   ""       		,; // 68 - Codigo de Periodo
								   ""       		,; // 69 - Roteiro de calculo da folhalculo da folha
								   RF3_JORN			,; // 70 - Codigo de Jornada
								   ""				,; // 71 - Id da excecao
								   ""				 ; // 72 - Tipo de Excecao
								};
			 			);
				)
					 			
Else

	nOrderRf4 := (cAliasRF4)->(RetOrder("RF4", "RF4_FILIAL+RF4_HOR+RF4_DIA"))
	
	(cAliasRF4)->(dbSetOrder(nOrderRf4))
	            
	aCpos		:= { 	  "RF3_ENTRA1"	,;	// 01 - Primeira Entrada
						  "RF3_SAIDA1" 	,;	// 02 - Primeira Saida
						  "RF3_ENTRA2" 	,;	// 03 - Segunda Entrada
						  "RF3_SAIDA2" 	,;	// 04 - Segunda Saida
						  "RF3_ENTRA3" 	,;	// 05 - Terceira Entrada
						  "RF3_SAIDA3" 	,;	// 06 - Terceira Saida
						  "RF3_ENTRA4" 	,;	// 07 - Quarta Entrada
						  "RF3_SAIDA4" 	,;	// 08 - Quarta Saida
						  "RF3_HRTRAB" 	,;	// 09 - Numero de Horas Trabalhadas 1a. Jornada
						  "RF3_HRTRA2" 	,;	// 10 - Numero de Horas Trabalhadas	2a. Jornada
						  "RF3_HRTRA3" 	,;	// 11 - Numero de Horas Trabalhadas 3a. Jornada
						  "RF3_HRTRA4" 	,;	// 12 - Numero de Horas Trabalhadas 4a. Jornada
						  "RF3_HRINT1" 	,;	// 13 - Numero de Horas 1o. Intervalo
						  "RF3_HRINT2" 	,;	// 14 - Numero de Horas 2o. Intervalo
						  "RF3_HRINT3" 	,;	// 15 - Numero de Horas 3o. Intervalo
						  "RF3_HRMENO"	,;	// 16 - Limite de Horario Inicial
						  "RF3_HRMAIS"	,;	// 17 - Limite de Horario Final
						  "RF3_JND1CO" 	,;	// 18 - 1a. Jornada Continua
						  "RF3_JND2CO" 	,;	// 19 - 2a. Jornada Continua
						  "RF3_JND3CO" 	,;	// 20 - 3a. Jornada Continua
						  "RF3_JND4CO" 	,;	// 21 - 4a. Jornada Continua
						  "RF3_LI1E"    ,; 	// 22 - Limite inferior 1E
						  "RF3_LS1E"    ,; 	// 23 - Limite superior 1E
						  "RF3_LI1S"    ,; 	// 24 - Limite inferior 1S
						  "RF3_LS1S"    ,; 	// 25 - Limite superior 1S
						  "RF3_LI2E"    ,; 	// 26 - Limite inferior 2E
						  "RF3_LS2E"    ,; 	// 27 - Limite superior 2E
						  "RF3_LI2S"    ,; 	// 28 - Limite inferior 2S
						  "RF3_LS2S"    ,; 	// 29 - Limite superior 2S
						  "RF3_LI3E"    ,; 	// 30 - Limite inferior 3E
						  "RF3_LS3E"    ,; 	// 31 - Limite superior 3E
						  "RF3_LI3S"    ,; 	// 32 - Limite inferior 3S
						  "RF3_LS3S"    ,; 	// 33 - Limite superior 3S
						  "RF3_LI4E"    ,; 	// 34 - Limite inferior 4E
						  "RF3_LS4E"    ,; 	// 35 - Limite superior 4E
						  "RF3_LI4S"    ,; 	// 36 - Limite inferior 4S
						  "RF3_LS4S"	,;  // 37 - Limite superior 4S   
	  					  "RF3_JORN"	 ;  // 38 - Jornada
				}
	For nCont := 1 To 7
		If ( (cAliasRF4)->( dbSeek(cFil+cHor+AllTrim(Str(nCont)))))
			
			aRetRF5 := fFindRF5( cFil, cDia, (cAliasRF4)->(RF4_DIA) )
			
			If (cAliasRF3)->( dbSeek(cFil+(cAliasRF4)->(RF4_JORN)) )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Converte campos de jornada em variaveis para calculo de horas³
				³trabalhadas conforme Turno associado a jornada lida.		  ³			
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				aEval( aCpos,{ |x| &( "M->" + x ):= (cAliasRF3)->&(x)  } )
				
				M->RF3_HRSTOT:= fHrsTrabGat("T","RF3","MB")
				M->RF3_HRTRA2:= fHrsTrabGat("H","RF3","MB","2")
				M->RF3_HRTRA3:= fHrsTrabGat("H","RF3","MB","3")
				M->RF3_HRTRA4:= fHrsTrabGat("H","RF3","MB","4")
				M->RF3_HRTRAB:= fHrsTrabGat("H","RF3","MB","1")
				(cAliasRF3)->( aAdd( aRet,{  M->RF3_ENTRA1		,; // 01 - Primeira Entrada
											 M->RF3_SAIDA1		,; // 02 - Primeira Saida
											 M->RF3_ENTRA2		,; // 03 - Segunda Entrada
											 M->RF3_SAIDA2		,; // 04 - Segunda Saida
											 M->RF3_ENTRA3		,; // 05 - Terceira Entrada
											 M->RF3_SAIDA3		,; // 06 - Terceira Saida
											 M->RF3_ENTRA4		,; // 07 - Quarta Entrada
											 M->RF3_SAIDA4		,; // 08 - Quarta Saida
											 M->RF3_HRTRAB	    ,; // 09 - Numero de Horas Trabalhadas 1a. Jornada
											 M->RF3_HRTRA2		,; // 10 - Numero de Horas Trabalhadas	2a. Jornada
											 M->RF3_HRTRA3		,; // 11 - Numero de Horas Trabalhadas 3a. Jornada
											 M->RF3_HRTRA4		,; // 12 - Numero de Horas Trabalhadas 4a. Jornada
											 M->RF3_HRINT1  	,; // 13 - Numero de Horas 1o. Intervalo
											 M->RF3_HRINT2		,; // 14 - Numero de Horas 2o. Intervalo
											 M->RF3_HRINT3		,; // 15 - Numero de Horas 3o. Intervalo
											 ""       			,; // 16 - Marcacao Refere-se ao Proximo Dia
											 0					,; // 17 - TabMarc("SPJ")	Numero de Marcacoes da Tabela
											 aRetRF5[1,2]		,; // 18 - Tipo do Dia
											 cSem				,; // 19 - Sequencia da Marcacao
											 Val(aRetRF5[1,1])	,;  // 20 - Numero Correspondente ao Dia da Semana
											 "N"				,; // 21 - Refere-se a Excecao
											 ""					,; // 22 - Motivo da Excecao
											 aRetRF5[1,4]		,; // 23 - Tipo de Extra Normal
											 aRetRF5[1,5]		,; // 24 - Tipo de Extra Noturna
											 ""    				,; // 25 - Centro de Custo Periodo 1
											 ""    				,; // 26 - Centro de Custo Periodo 2
											 ""    				,; // 27 - Centro de Custo Periodo 3
											 ""    				,; // 28 - Centro de Custo Periodo 4
											 aRetRF5[1,6]   	,; // 29 - Aponta Nona Hora
											 M->RF3_HRMENO    	,; // 30 - Limite de Horario Inicial
											 M->RF3_HRMAIS    	,; // 31 - Limite de Horario Final
											 M->RF3_JND1CO     	,; // 32 - 1a. Jornada Continua
											 M->RF3_JND2CO     	,; // 33 - 2a. Jornada Continua
											 M->RF3_JND3CO     	,; // 34 - 3a. Jornada Continua
											 M->RF3_JND4CO     	,; // 35 - 4a. Jornada Continua
											 aRetRF5[1,3]   	,; // 36 - Codigo da Refeicao
	 										 nRecno				,; // 37 - Recno
											 ""					,; // 38 - Codigo de funcao Periodo 1
											 ""					,; // 39 - Codigo de funcao Periodo 1
											 ""					,; // 40 - Codigo de funcao Periodo 1
											 ""					,; // 41 - Codigo de funcao Periodo 1
											 M->RF3_LI1E     	,; // 42 - Limite inferior 1E
											 M->RF3_LS1E     	,; // 43 - Limite superior 1E
											 M->RF3_LI1S     	,; // 44 - Limite inferior 1S
											 M->RF3_LS1S     	,; // 45 - Limite superior 1S
											 M->RF3_LI2E     	,; // 46 - Limite inferior 2E
											 M->RF3_LS2E     	,; // 47 - Limite superior 2E
											 M->RF3_LI2S     	,; // 48 - Limite inferior 2S
											 M->RF3_LS2S     	,; // 49 - Limite superior 2S
											 M->RF3_LI3E     	,; // 50 - Limite inferior 3E
											 M->RF3_LS3E     	,; // 51 - Limite superior 3E
											 M->RF3_LI3S     	,; // 52 - Limite inferior 3S
											 M->RF3_LS3S     	,; // 53 - Limite superior 3S
											 M->RF3_LI4E     	,; // 54 - Limite inferior 4E
											 M->RF3_LS4E     	,; // 55 - Limite superior 4E
											 M->RF3_LI4S     	,; // 56 - Limite inferior 4S
											 M->RF3_LS4S		,; // 57 - Limite superior 4S
											 ""    				,; // 58 - Codigo de departamento Periodo 1
											 ""    				,; // 59 - Codigo de departamento Periodo 2
											 ""    				,; // 60 - Codigo de departamento Periodo 3
											 ""    				,; // 61 - Codigo de departamento Periodo 4
											 ""    				,; // 62 - Codigo de posto Periodo 1
											 ""    				,; // 63 - Codigo de posto Periodo 2
											 ""    				,; // 64 - Codigo de posto Periodo 3
											 ""    				,; // 65 - Codigo de posto Periodo 4
											 ""   				,; // 66 - Codigo de processo
											 ""     			,; // 67 - Numero de Pagamento
											 ""       			,; // 68 - Codigo de Periodo
											 ""       			,; // 69 - Roteiro de calculo da folhalculo da folha
											 M->RF3_JORN		,; // 70 - Codigo de Jornada
											 ""					,; // 71 - Id da excecao
											 ""				 	; // 72 - Tipo de Excecao
									};
			 					);
					 		)
			EndIF
		EndIf
	Next

EndIf

RestArea( aArea )
	
Return aRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fFindRf5  ³ Autor ³ Igor Franzoi		  ³ Data ³ 14/11/07 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Seleciona os dados dos RF4									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fFindRf5()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cFil = filial												³
³		   ³ cDia = codigo do tipo de dia								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ aResRF5													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fFindRf5( cFil, cDia, cSeq )

Local cKey	    := cFil+cDia+cSeq
Local cAlias    := "RF5"
Local aArea		:= GetArea()
Local aResRF5   := {}
Local nOrderRf5 := (cAlias)->(RetOrder("RF5", "RF5_FILIAL+RF5_TIPO+RF5_DIA"))

(cAlias)->(dbSetOrder(nOrderRf5))
(cAlias)->(dbSeek(cKey))

aAdd( aResRF5, { (cAlias)->( RF5_DIA    ),;
				 (cAlias)->( RF5_TPDIA  ),;
				 (cAlias)->( RF5_CODREF ),;
				 (cAlias)->( RF5_TPEXT  ),;
				 (cAlias)->( RF5_TPEXTN ),;
				 (cAlias)->( RF5_NONAHR ); 
				};
	)
	
RestArea(aArea)

Return aResRF5

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetInfoPosTab³Autor³ Marinaldo de Jesus   ³ Data ³17/10/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Conteudo da Tabela de Horario Padrao Conforme   os³
³          ³Parametros Passados											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nSerFim                            							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetInfoPosTab(	nPosTip 	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
						cFlagMarc	,;	//02 -> Flag da Marcacao "1E,1S,..."
						dData		,;	//03 -> Data em aTabCalend
						aTabCalend	,;	//04 -> Calendario de Marcacoes
						aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						dPerIni		,;	//06 -> Periodo Inicial de Apontamento
						dPerFim		,;	//07 -> Periodo Final de Apontamento	
						lFunc		,;	//08 -> Informacao Referente a Funcionario
						cTno		,;	//09 -> Turno de Trabalho
						cSeq		,;	//10 -> Sequencia
						cFil		,;	//11 -> Filial
						lExce		,;  //12 -> Carrega Excecoes 
						bAscan		,;	//13 -> Bloco para Pesquisa em aTabCalend
						nRetPosTab  ,;	//14 -> Retorno da Posicao do aTabCalend 	
					    lSearchAll )    //15 -> Se soma todos os elementos do aTabCalend referentes a dData passada

Local aSvTabsCal	:= {}
Local dDataApo		:= ""
Local lContinua		:= .T.
Local lLastMarc		:= .F.
Local lAddInfo		:= .F.
Local nPosTab		:= 0
Local nPosTpIni		:= 0
Local nLenCalend	:= 0
Local uRet			:= NIL

IF ( ( Type("aTnoGetInfoTab") == "U" ) .or. ( Type("aTnoGetInfoTab") != "A" ) )
	Private aTnoGetInfoTab := {}
EndIF	

DEFAULT nPosTip		:= CALEND_POS_TURNO
DEFAULT cFlagMarc	:= "1E"
DEFAULT dData		:= dDataBase
DEFAULT aTabCalend	:= {}
DEFAULT aTabPadrao	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lFunc		:= .T.
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT cSeq		:= SRA->RA_SEQTURN
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT lExce		:= .F.
DEFAULT bAscan		:= { |x| x[CALEND_POS_DATA] == dData .and. x[CALEND_POS_TIPO_MARC] == cFlagMarc }
DEFAULT lSearchAll  := .F.

IF ( lLastMarc := ( ( cFlagMarc := Upper( AllTrim( cFlagMarc ) ) ) == "__LASTMARC__" ) )
	cFlagMarc := "1E"
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Recurso para tornar a carga dos inicializadores mais rapida na troca de turno ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lAddInfo := Type("aIniPadFun") <> "U" .And. IsInCallStack("INITPAD")
	If Len(aIniPadFun) > 0
		nPosTpIni := Ascan( aIniPadFun, {|x| x[1]+x[2]+x[5] == SRA->RA_FILIAL + SRA->RA_MAT + cValToChar(nPosTip) } )
		If nPosTpIni > 0
			Return( aIniPadFun[nPosTpIni,6] )	
		EndIf
	EndIf
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se o Calendario foi passado como parametro		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF Empty( aTabCalend )                                                    
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Somente considera a tabela SPO qdo for montar o Calendario  ³
	³ por Turno e para um funcionario							  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    IF !lFunc
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			lContinua := PerAponta( @dPerIni , @dPerFim , dData , NIL , cFil )
		EndIF
	Else

		If Type("oPeriodo") == "U"
			SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
		EndIf
		oPeriodo:cProcesso := SRA->RA_PROCES
		oPeriodo:GetPer() 
			
		If ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			lContinua := PerAponta( @dPerIni , @dPerFim , dData , NIL , cFil )
		EndIF	
	Endif
	IF ( lContinua )
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSvTabsCal := GetTabCal()
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Cria o Calendario de Marcacoes                  			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lContinua := CriaCalend(	dPerIni									,; //01 -> Data Inicial do Periodo
					 				Min( dPerFim , dData )					,; //02 -> Data Final do Periodo
									cTno									,; //03 -> Turno Para a Montagem do Calendario
									cSeq									,; //04 -> Sequencia Inicial para a Montagem Calendario
									@aTabPadrao								,; //05 -> Array Tabela de Horario Padrao
									@aTabCalend								,; //06 -> Array com o Calendario de Marcacoes
									cFil									,; //07 -> Filial para a Montagem da Tabela de Horario
									IF(lFunc,SRA->RA_MAT,NIL)				,; //08 -> Matricula para a Montagem da Tabela de Horario
									IF(lFunc .and. lExce,SRA->RA_CC,NIL)	,; //09 -> Centro de Custo para a Montagem da Tabela
									IF(lFunc,@aTnoGetInfoTab,NIL)			,; //10 -> Array com as Trocas de Turno
									NIL										,; //11 -> Array com Todas as Excecoes do Periodo
									NIL 									,; //12 -> Se executa Query para a Montagem da Tabela Padrao
									.F.										,; //13 -> Se executa a funcao se sincronismo do calendario
									NIL										,; //14 -> Se Forca a Criacao de Novo Calendario
									NIL  									,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
									.F.  									,; //16 -> .T. Determina a Criacao/Carga do Calendario Fisico
									NIL										,; //17 -> .T. Caso exista calendario fisico 
									NIL										,; //18 -> Data inicial do calendario fisico
									NIL										,; //19 -> Data final do calendario fisico 
									.F. 									; //20 -> .T. determina que o calendario sera gravado no caso de nao existir						
								)
	EndIF
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Efetua a Pesquisa e Retorna o Conteudo do Elemento Desejado  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lContinua )
	IF ( ( nPosTab := aScan( aTabCalend , bAscan ) ) > 0 )
		IF ( ( nPosTip > 0 ) .and. nPosTip <= Len( aTabCalend[ nPosTab ] ) )
			If lSearchAll   
				If Valtype(aTabCalend[ nPosTab, nPosTip ]) == "N" 
					uRet:= 0
					While nPosTab <= len(aTabCalend) .And. aTabCalend[ nPosTab,CALEND_POS_DATA ] == dData
						uRet += aTabCalend[ nPosTab, nPosTip ]
						++nPosTab
					End 
				Endif
			Else
				IF ( lLastMarc )
					dDataApo		:= aTabCalend[ nPosTab , CALEND_POS_DATA_APO ]
					nLenCalend	:= Len( aTabCalend )
					While ( nPosTab <= nLenCalend )
						IF !( dDataApo == aTabCalend[ nPosTab , CALEND_POS_DATA_APO ] )
							--nPosTab
							Exit
						EndIF
						IF ( nPosTab < nLenCalend )
							++nPosTab
						Else
							Exit
						EndIF
					End While	
				EndIF
				IF ( ValType( aTabCalend[ nPosTab , nPosTip ] ) == "A" )
					uRet := aClone( aTabCalend[ nPosTab , nPosTip ] )
				Else
					uRet := aTabCalend[ nPosTab , nPosTip ]
				EndIF	      
			Endif
		EndIF
	EndIF    
EndIF

If uRet # NIL .And. lAddInfo
	If Len(aIniPadFun) > 0 .And. ( nPosTpIni := Ascan( aIniPadFun, {|x| x[1]+x[2]+x[5] == SRA->RA_FILIAL + SRA->RA_MAT + cValToChar(nPosTip) } ) ) > 0
		aIniPadFun[nPosTpIni, 6] := aTabCalend[ nPosTab , nPosTip ]
	Else
		aAdd( aIniPadFun, { SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_TNOTRAB, SRA->RA_SEQTURN, "14", aTabCalend[ nPosTab , 14 ]} )
		aAdd( aIniPadFun, { SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_TNOTRAB, SRA->RA_SEQTURN,  "8", aTabCalend[ nPosTab , 08 ]} )
		aAdd( aIniPadFun, { SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_TNOTRAB, SRA->RA_SEQTURN, "23", aTabCalend[ nPosTab , 23 ]} )
	EndIf
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Se nao Obteve retorno Carrega valores DEFAULT                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( ( uRet == NIL ) .and. ( nPosTip > 0 ) )

	nRetPosTab	:= 0

	Do Case 
		Case nPosTip == CALEND_POS_DATA			; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_ORDEM		; uRet := ""
		Case nPosTip == CALEND_POS_HORA			; uRet := 0
		Case nPosTip == CALEND_POS_TIPO_MARC	; uRet := ""
		Case nPosTip == CALEND_POS_NUM_MARC 	; uRet := 0
		Case nPosTip == CALEND_POS_TIPO_DIA 	; uRet := ""
		Case nPosTip == CALEND_POS_HRS_TRABA	; uRet := 0
		Case nPosTip == CALEND_POS_SEQ_TURNO	; uRet := ""
		Case nPosTip == CALEND_POS_HRS_INTER	; uRet := 0
		Case nPosTip == CALEND_POS_EXCECAO		; uRet := ""
		Case nPosTip == CALEND_POS_MOT_EXECAO	; uRet := ""
		Case nPosTip == CALEND_POS_TIPO_HE_NOR	; uRet := ""
		Case nPosTip == CALEND_POS_TIPO_HE_NOT	; uRet := ""
		Case nPosTip == CALEND_POS_TURNO		; uRet := ""
		Case nPosTip == CALEND_POS_CC			; uRet := ""
		Case nPosTip == CALEND_POS_PG_NONA_HORA	; uRet := ""
		Case nPosTip == CALEND_POS_LIM_MARCACAO	; uRet := { Ctod("//") , 0 }
		Case nPosTip == CALEND_POS_COD_REFEICAO	; uRet := ""
		Case nPosTip == CALEND_POS_FERIADO		; uRet := .F.
		Case nPosTip == CALEND_POS_TP_HE_FER_NR	; uRet := ""
		Case nPosTip == CALEND_POS_TP_HE_FER_NT	; uRet := ""
		Case nPosTip == CALEND_POS_DESC_FERIADO ; uRet := ""
		Case nPosTip == CALEND_POS_REGRA		; uRet := ""
		Case nPosTip == CALEND_POS_AFAST		; uRet := .F.
		Case nPosTip == CALEND_POS_TIP_AFAST	; uRet := ""
		Case nPosTip == CALEND_POS_INI_AFAST	; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_FIM_AFAST	; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_INI_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_FIM_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_MIN_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_TRAB_FERIADO	; uRet := .F.
		Case nPosTip == CALEND_POS_APON_FERIAS  ; uRet := .F.
		Case nPosTip == CALEND_POS_TP_HE_NR_FER ; uRet := ""
		Case nPosTip == CALEND_POS_TP_HE_NT_FER ; uRet := ""
		Case nPosTip == CALEND_POS_PAGINT		; uRet := ""
		Case nPosTip ==	CALEND_POS_TIPO_ORIG_DIA; uRet := "" 
		Case nPosTip ==	CALEND_POS_HE_AUTO_FER  ; uRet := .T.  
		Case nPosTip ==	CALEND_POS_CODFUNC		; uRet := "" 
		Case nPosTip ==	CALEND_POS_DEPTO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_POSTO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_PERIODO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_ROTEIRO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_PROCESSO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_NUM_PAGTO	; uRet := "" 
		Case nPosTip ==	CALEND_POS_JORN			; uRet := "" 
		Case nPosTip ==	CALEND_POS_P2ID			; uRet := "" 
		Case nPosTip ==	CALEND_POS_R8ID			; uRet := "" 
		Case nPosTip ==	CALEND_POS_DATA_APO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_JND_CON		; uRet := "" 
		Case nPosTip ==	CALEND_POS_LIE			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LSE			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LIS			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LSS			; uRet := "" 

	EndCase
Else
	nRetPosTab := nPosTab
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Conteudo do Calendario por Turno        		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF	

Return( uRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstTabPadrao	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em fTabPadrao()        	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstTabPadrao()
Return( ( __nLstTabPadPos := NIL ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CriaCalend³ Autor ³ Marinaldo de Jesus    ³ Data ³15/12/2003³
³          ³          ³ Ver.02³ Mauricio MR           ³      ³30/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Alimenta um Array com o Calend rio de um Per¡odo.           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CriaCalend(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
						lCalFisico  ,; //16 -> .T. Determina a Criacao/Carga do Calendario Fisico
						lDtaCal		,; //17 -> .T. Caso exista calendario fisico 
						dIniCal		,; //18 -> Data inicial do calendario fisico
						dFimCal		,; //19 -> Data final do calendario fisico 
						lGravaCalend,; //20 -> .T. determina que o calendario sera gravado no caso de nao existir
						lRotGer		 ; //21 -> .T. determina que a rotina chamadora eh a Geracao de Calendarios (PONM400)						
					)   
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ lChkMat: .T.  - Determina a montagem do calendario do funcio³
³                 nario.               					  	  ³
³          .F.  - Determina a montagem do calendario do Turno ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local lChkMat		:= ( cMat <> NIL )	
Local lCriaCalOk	:= .T.  

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se usa Periodo Generico na montagem do calendario   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local lPGenerico	:= .F.


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ nRetorno: 												  ³
³            0 - Nao Carregou o Calendario					  ³
³            1 - Gerar Calendario Virtual e Carrega-lo		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local nRetorno		:= 0   

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Complemento de mensagem para erro do calendario, na datas	  ³
³recebidas													  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local cMsgCal		:= ""

DEFAULT lPnmTabCalen	:= ExistBlock( "PNMTABC01" )
DEFAULT lCalFisico		:= lUseCalFisico			 //.T. - Deve existir calendario fisico / .F. - Utiliza calendario Virtual
DEFAULT lGravaCalend	:= lCalDem                   //.T. - Grava Calendario / .F. Nao Grava Calendario
DEFAULT lRotGer			:= .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Objeto de controle de erros do calendario					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
If( Type("oCalendError") == "U" ) 
	oCalendError	:=SetMemVar("oCalendError" , PONERROR():New() , .T. , .T. )
	oCalendError:InitLogErrors(LoadCalError()) //Carrega tabela de erros
Endif

aTurnos     := If( ValType(aTurnos) == "U", {}, aTurnos )
aExcePer	:= If( ValType(aExcePer) == "U", {}, aExcePer )
aTabPadrao	:= If( ValType(aTabPadrao) == "U", {}, aTabPadrao )
aTabCalend  := If( ValType(aTabCalend) == "U", {}, aTabCalend )
aMarcacoes  := If( ValType(aMarcacoes) == "U", {}, aMarcacoes )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Somente permite a criacao/carga de calendario fisico se o   ³
³ parametro "MV_CALFIS" estiver setado para tanto.            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lCalFisico := If( lUseSPJ, .F., lCalFisico)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Caso seja recebida datas em branco, retorna um erro		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If ( Empty(dDataIni) .or. Empty(dDataFim) )
	If ( Type("oPeriodo") != "U" )
		cMsgCal	:= CRLF + CRLF 
		cMsgCal += OemToAnsi(STR0226) + " = " + oPeriodo:cProcesso + CRLF
		cMsgCal += OemToAnsi(STR0227) + " = " + oPeriodo:cPeriodo	+ CRLF
		cMsgCal += OemToAnsi(STR0228) + " = " + oPeriodo:cRoteiro	+ CRLF
		cMsgCal += OemToAnsi(STR0229) + " = " + oPeriodo:cNumPagto + CRLF
		cMsgCal += OemToAnsi(STR0230) + " = " + If ( oPeriodo:lPerSel, STR0125, STR0126 ) 
	EndIf
	oCalendError:SendError('04',cMsgCal, .T.) 			//"Periodo nao encontrado "
	lCriaCalOk	:= .F.
Else

	If lChkMat
		If lCalFisico 
		   /*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se utiliza Periodo Generico (MV_PAPONTA)			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !( lPGenerico := fVerPGenerico(SRA->RA_PROCES) )
				nRetorno :=	CalendFisico(	dDataIni	,; //01 -> Data Inicial do Periodo
							 				dDataFim	,; //02 -> Data Final do Periodo
											cTno		,; //03 -> Turno Para a Montagem do Calendario
											cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
											@aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
											@aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
											cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
											cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
											cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
											@aTurnos	,; //10 -> Array com as Trocas de Turno
											@aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
											lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
											lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
											lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
											@aMarcacoes ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais  
											lDtaCal		,; //16 -> .T. Caso exista calendario fisico 
											dIniCal		,; //17 -> Data inicial do calendario fisico
											dFimCal		,; //18 -> Data final do calendario fisico 
											lGravaCalend,; //19 -> .T. determina que o calendario sera gravado no caso de nao existir
											lRotGer		 ; //20 -> .T. determina que a rotina chamadora eh a Geracao de Calendarios (PONM400)
										)							 
				lCriaCalOk := If( Empty(nRetorno), .F., .T. )
			Else             
				lCalFisico := .F.
			Endif	
		Else
			lCalFisico := .F.
		EndIf
	Else
		lCalFisico := .F.
	EndIf
	
	If !lCalFisico
		lCriaCalOk:= CalendVirtual(	dDataIni	,; //01 -> Data Inicial do Periodo
					 				dDataFim	,; //02 -> Data Final do Periodo
									cTno		,; //03 -> Turno Para a Montagem do Calendario
									cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
									@aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
									@aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
									cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
									cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
									cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
									@aTurnos	,; //10 -> Array com as Trocas de Turno
									@aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
									lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
									lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
									lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
									@aMarcacoes  ;  //15 -> Array com marcacoes para tratamento de Turnos Opcionais
								)
	Endif
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Ponto de Entrada para edicao do array aTabCalend             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lPnmTabCalen )
		IF ( ValType( uRet := ExecBlock("PNMTABC01",.F.,.F., { aTabCalend, lCriaCalOk }) ) == "A" )	
			aTabCalend := aClone(uRet)
			uRet	   := NIL
		EndIF
	EndIF

EndIf

Return(lCriaCalOk)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CalendFisico  ³ Autor ³ Mauricio MR       ³ Data ³30/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cria Calendario Fisico.                                     ³
³          ³Alimenta  um Array com o Calend rio de um Per¡odo.          ³
³          ³Valida o calendario fisico, e se nao existir p/ o periodo	³
³          ³cria o calendario											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CalendFisico(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais  
						lDtaCal		,; //16 -> .T. Caso exista calendario fisico 
						dIniCal		,; //17 -> Data inicial do calendario fisico
						dFimCal		,; //18 -> Data final do calendario fisico 
						lGravaCalend,; //19 -> .T. determina que o calendario sera gravado no caso de nao existir
						lRotGer		 ; //20 -> .T. determina que a rotina chamadora eh a Geracao de Calendarios (PONM400)
					)

Local nRetorno		:= 1
Local cMsgError		:= ""

DEFAULT lDtaCal		:= .F.
DEFAULT dIniCal		:= Ctod("//")
DEFAULT dFimCal		:= Ctod("//")   
DEFAULT lRotGer		:= .F.

//Zera static. Devera ser usada apenas se existir calendario fisico previamente gravado.
__nOrdIni :=  NIL

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica se existe calendario fisico, se a data fim nao eh   ³
³ vazia														   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
If !lDtaCal
	lDtaCal := fDatMaxCal( cFil, cMat, @dFimCal, @dIniCal )
EndIf

//Se existe calendario fisico carrega
If (lDtaCal)
    
	//Caso ja exista dias previamente gravados, guarda a quantidade de ordens existentes
	//para que o trecho a ser montado comece pela ordem correta.
	If !( dDataIni > dFimCal )
		__nOrdIni :=  (dFimCal+1) - dDataIni
	EndIf
	
   	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Nao permite geracao de calendario futuro, de modo a provocar  ³
	³lacunas entre os calendarios existentes					   ³
	³Ex: Novo Calendario De: 01/02/07 Ate: 28/02/07				   ³
	³	 Calendario Existente De: 01/01/07 Ate: 25/01/07		   ³
	³Nao gera calendario para o periodo							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ((dFimCal + 1 ) < dDataIni ) .or. ( (dIniCal-1) > dDataFim )
	    cMsgError := DtoC(dDataIni) + STR0067 + DtoC(dDataFim)
		oCalendError:SendError('07',cMsgError, .T.)  // Nao foi possivel gerar o calendario para o periodo de: dDataIni ate dDataFim
		oCalendError:SendError('08',Nil, .T.)  // Somente e possivel gerar calendario para periodos consecutivos.
		Return(0)
	EndIf
   
	//Verifica se podera gerar calendario por demanda (lCalDem), ou, se forca geracao e gravacao
	//do calendario independente do parametro lCalDem
	If (lCalDem .or. lGravaCalend)
		
		If Empty(aTurnos)
			//Monta todas as trocas de turno para o periodo informado.
			fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
		EndIf
		
		If ( dDataFim > dFimCal )		
						
				//Gera o periodo posterior ao calendario				
				If !( GeraCalend(   If ( dDataIni > dFimCal, dDataIni, dFimCal+1) ,; //01 -> Data Final do Calendario
									dDataFim									  ,; //02 -> Data Final do Periodo
					 				cTno		                                  ,; //03 -> Turno Para a Montagem do Calendario
									cSeq		                                  ,; //04 -> Sequencia Inicial para a Montagem Calendario
									@aTabPadrao	                                  ,; //05 -> Array Tabela de Horario Padrao
									@aTabCalend	                                  ,; //06 -> Array com o Calendario de Marcacoes
									cFil		                                  ,; //07 -> Filial para a Montagem da Tabela de Horario
									cMat		                                  ,; //08 -> Matricula para a Montagem da Tabela de Horario
									cCc		                                 	  ,; //09 -> Centro de Custo para a Montagem da Tabela
									@aTurnos	                                  ,; //10 -> Array com as Trocas de Turno
									@aExcePer	                                  ,; //11 -> Array com Todas as Excecoes do Periodo
									lExecQryTop 	                              ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
									lSncMaMe	                                  ,; //13 -> Se executa a funcao se sincronismo do calendario
									.F.		                                 	  ,; //14 -> Se Forca a Criacao de Novo Calendario (força .F. para montar o calendario com as datas passadas
									@aMarcacoes 	                              ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
									.F.		                                 	  ,; //16 -> Gerar calendario a partir do dia Maximo do cal. Fisico - Nao zera o array TabCalend
									lGravaCalend                                   ; //17 -> .T. determina que o calendario sera gravado no caso de nao existir
					  			);
                   )
                   nRetorno := 0
                EndIf              
                
    	EndIf
		If ( dDataIni < dIniCal )
			aTabCalend := {}
			//Gera o periodo anterior ao calendario
			If !( GeraCalend(   dDataIni 										,; //01 -> Data Final do Calendario
  							    If ( dDataFim > dIniCal, dIniCal-1, dDataFim)  ,; //02 -> Data Final do Periodo
								cTno		                                 	,; //03 -> Turno Para a Montagem do Calendario
  			   					cSeq		                                 	,; //04 -> Sequencia Inicial para a Montagem Calendario
				  				@aTabPadrao	                                 	,; //05 -> Array Tabela de Horario Padrao
								@aTabCalend	                                 	,; //06 -> Array com o Calendario de Marcacoes
								cFil		                                 	,; //07 -> Filial para a Montagem da Tabela de Horario
								cMat		                                 	,; //08 -> Matricula para a Montagem da Tabela de Horario
								cCc		                                 		,; //09 -> Centro de Custo para a Montagem da Tabela
								@aTurnos	                                 	,; //10 -> Array com as Trocas de Turno
								@aExcePer	                                 	,; //11 -> Array com Todas as Excecoes do Periodo
								lExecQryTop 	                                ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe	                                 	,; //13 -> Se executa a funcao se sincronismo do calendario
								.F.		                                 		,; //14 -> Se Forca a Criacao de Novo Calendario (força .F. para montar o calendario com as datas passadas
								@aMarcacoes 	                                ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
								.F.		                                 		,; //16 -> Gerar calendario a partir do dia Maximo do cal. Fisico - Nao zera o array TabCalend
								lGravaCalend                                     ; //17 -> .T. determina que o calendario sera gravado no caso de nao existir
							);
				)
				nRetorno := 0
			EndIf
		EndIf
	ElseIf ( ( dDataIni < dIniCal ) .or. ( dDataFim > dFimCal ) )
		oCalendError:SendError('05',Nil, .T.) // Nao e possivel gerar calendario por demanda, verificar parametro MV_CALDEM
		nRetorno := 0
	EndIf

	If ( nRetorno == 1 .and. !lRotGer )
		//Carrega o calendario
		aTabCalend := {}
		CarregaCalend(	dDataIni	,; //01 -> Data Inicial do Periodo
						dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						@aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						@aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						@aTurnos	,; //10 -> Array com as Trocas de Turno
						@aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						@aMarcacoes ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
						NIL	         ; //16 -> Identifica se o periodo esta fechado(.F.)/aberto(.T.)
         )
   EndIf

Else
	//Verifica se podera gerar calendario por demanda (lCalDem), ou, se forca geracao e gravacao
	//do calendario independente do parametro lCalDem
	If (lCalDem .or. lGravaCalend)
		//Gera o periodo completo do calendario
		If !( GeraCalend( 	dDataIni     	,; //01 -> Data Final do Calendario
							dDataFim	 	,; //02 -> Data Final do Periodo
							cTno	    	,; //03 -> Turno Para a Montagem do Calendario
							cSeq	    	,; //04 -> Sequencia Inicial para a Montagem Calendario
							@aTabPadrao     ,; //05 -> Array Tabela de Horario Padrao
							@aTabCalend     ,; //06 -> Array com o Calendario de Marcacoes
							cFil	    	,; //07 -> Filial para a Montagem da Tabela de Horario
							cMat	    	,; //08 -> Matricula para a Montagem da Tabela de Horario
							cCc	    		,; //09 -> Centro de Custo para a Montagem da Tabela
							@aTurnos	    ,; //10 -> Array com as Trocas de Turno
							@aExcePer    	,; //11 -> Array com Todas as Excecoes do Periodo
							lExecQryTop  	,; //12 -> Se executa Query para a Montagem da Tabela Padrao
							lSncMaMe	    ,; //13 -> Se executa a funcao se sincronismo do calendario
							.F.	    		,; //14 -> Se Forca a Criacao de Novo Calendario (força .F. para montar o calendario com as datas passadas
							@aMarcacoes  	,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
							.F.	    		,; //16 -> Gerar calendario a partir do dia Maximo do cal. Fisico - Nao zera o array TabCalend
							lGravaCalend  	 ; //17 -> .T. determina que o calendario sera gravado no caso de nao existir
						);
			)
			nRetorno := 0
		EndIf
	Else
		oCalendError:SendError('05',Nil, .T.) // Nao e possivel gerar calendario por demanda, verificar parametro MV_CALDEM
		nRetorno := 0
	EndIf
EndIf

Return ( nRetorno )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GeraCalend    ³ Autor ³ Igor Franzoi      ³ Data ³14/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gera o calendario na tabela fisica						    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GeraCalend( dDataIni	,; //01 -> Data Final do Calendario
					 		dDataFim	,; //02 -> Data Final do Periodo
							cTno		,; //03 -> Turno Para a Montagem do Calendario
							cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
							aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
							aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
							cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
							cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
							cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
							aTurnos		,; //10 -> Array com as Trocas de Turno
							aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
							lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
							lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
							lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
							aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
							lTabCalen	,; //16 -> Nao zerar o array aTabCalend - Calendario Complementar
						    lGravaCalend ; //17 -> .T. determina que o calendario sera gravado no caso de nao existir																											
				)
		
Local lRet	  := .T.
Local lVrtGer := .F.

DEFAULT lTabCalen := .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se nPosIni estiver preenchido, o inicio da gravacao do cal. ³
³ sera feito apos esta posicao, pois o inicio do calendario	  ³
³ fisico ja existe, e foi gravado anteriormente				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If ( Empty(aTabCalend), nPosIni := 0 , nPosIni := (Len(aTabCalend)+1)  )

	lVrtGer := CalendVirtual(	dDataIni	,; //01 -> Data Inicial do Periodo
				 				dDataFim	,; //02 -> Data Final do Periodo
								cTno		,; //03 -> Turno Para a Montagem do Calendario
								cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
								@aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
								@aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
								cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
								cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
								cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
								@aTurnos	,; //10 -> Array com as Trocas de Turno
								@aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
								lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
								lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
								@aMarcacoes ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
								lTabCalen	;  //16 -> Nao zerar o array aTabCalend - Calendario Complementar
				)
				
	//-- Verifica se grava calendario			
	If lVrtGer
		If lGravaCalend
			If !(lRet := GravaCalend( cFil		,; //01 -> Filial para a Montagem da Tabela de Horario
				    				 cMat		,; //02 -> Matricula para a Montagem da Tabela de Horario
									 aTabCalend	,; //03 -> Array com o Calendario de Marcacoes
									 nPosIni	 ; //04 -> Posicao inicial do array aTabCalend
				   				    );
			    )
				oCalendError:SendError('06',Nil, .T.)//Nao foi possivel gravar calendario
			EndIF
		EndIf
	Else
		//Ocorreu alguma inconsistencia na montagem do calendario virtual. Ver mensagem de erro na funcao CalendCria.
		lRet := .F.
	EndIf

Return lRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GravaCalend   ³ Autor ³ Igor Franzoi      ³ Data ³14/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Grava os dados do calendario virtual nas tabelas 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GravaCalend(	cFil		,; //01 -> Filial para a Montagem da Tabela de Horario
								cMat		,; //02 -> Matricula para a Montagem da Tabela de Horario
								aTabCalend	;  //03 -> Array com o Calendario
   				)

Local lRet 		:= .F.
Local nElem  	:= 0
Local aArea  	:= GetArea()
Local cAliasRF6 := "RF6"

Local nRecnoRF6
Local nRecnoRF7

Local cPreRF6  := cAliasRF6+"_"

Local dDataApoAnt
Local dDtaApo
Local dDtaMai	:= CtoD('')
Local dDtaMen	:= CtoD('')
Local cTurno
Local cDepto
Local cPosto

Local nHorMai   := 0
Local nHorMen   := 0
Local nNumMarc  := 0
Local nTotHrInt := 0
Local nTotHrTra := 0
Local nX		:= 0

#DEFINE CABEC_  01

#DEFINE FILIAL_ 01
#DEFINE DATA_   02
#DEFINE ORDEM_  03
#DEFINE	MAT_    04
#DEFINE TURNO_  05
#DEFINE SEQ_    06
#DEFINE TIPOD_  07
#DEFINE	MOTIVO_ 08
#DEFINE	P2ID_	09
#DEFINE JORN_	10
#DEFINE HRMENO_ 11
#DEFINE HRMAIS_ 12
#DEFINE HRINTV_ 13
#DEFINE HRTRAB_ 14
#DEFINE CODREF_ 15
#DEFINE TPEXT_  16
#DEFINE TPEXTN_ 17
#DEFINE NONAHR_ 18
#DEFINE INIHNT_ 19
#DEFINE FIMHNT_ 20
#DEFINE MINHNT_ 21
#DEFINE HNTTAB_ 22
#DEFINE HNTTBI_ 23
#DEFINE REGRA_  24
#DEFINE NUMARC_ 25
#DEFINE DORIG_  26
#DEFINE R8ID_	27
#DEFINE	FLAG_   28
#DEFINE CHKTNO_ 29
#DEFINE PROCES_ 30
#DEFINE PERIOD_ 31
#DEFINE ROTEIR_ 32
#DEFINE NUMPAG_ 33
#DEFINE TPEXCE_	34

Begin Transaction

	For nElem := 1 To Len(aTabCalend)
	
		If dDataApoAnt != aTabCalend[ nElem, CALEND_POS_DATA_APO ]

			dDataApoAnt := aTabCalend[ nElem, CALEND_POS_DATA_APO ]
			dDtaApo   	:= aTabCalend[ nElem, CALEND_POS_DATA_APO ]
			cTurno    	:= aTabCalend[ nElem, CALEND_POS_TURNO    ]
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Conta o numero de marcacoes								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If Empty(aTabCalend[nElem,CALEND_POS_NUM_MARC])
				nNumMarc := 1
			Else
				nNumMarc := aTabCalend[ nElem, CALEND_POS_NUM_MARC ]
			EndIf		
			
			nTotHrInt := aTabCalend[ nElem, CALEND_POS_HRS_INTER ]
			nTotHrTra := aTabCalend[ nElem, CALEND_POS_HRS_TRABA ]
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Insere o HorMais para o primeiro registro da ordem, depois   ³
			³insere vazio ate o ultimo registro da ordem para inserir o   |
			|HorMenos													  |
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			
			If Empty(nHorMen)
				nHorMen := aTabCalend[ nElem, CALEND_POS_LIM_MARCACAO, 2 ]
			Else
				nHorMen := nHorMen
			EndIf

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica o ultimo elemento do dia para pegar a data limite   ³
			³superior.                                                    |
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/			
			If !( ( nX := aScan( aTabCalend , { |x| x[CALEND_POS_DATA_APO] == dDataApoAnt + 1 } ) ) > 0 )
				nX := Len(aTabCalend)
			Else
				nX--
			EndIf
            //Data limite inferior
			dDtaMen		:= aTabCalend[ nElem, CALEND_POS_LIM_MARCACAO, 1 ]
			//Data Limite superior
			dDtaMai		:= aTabCalend[ nX   , CALEND_POS_LIM_MARCACAO, 1 ]

			RecLock(cAliasRF6, .T., .F.)
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,FILIAL_]) := cFil
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,DATA_  ]) := dDtaApo
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,ORDEM_ ]) := aTabCalend[ nElem, CALEND_POS_ORDEM         ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,MAT_   ]) := cMat
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TURNO_ ]) := aTabCalend[ nElem, CALEND_POS_TURNO         ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,SEQ_   ]) := aTabCalend[ nElem, CALEND_POS_SEQ_TURNO     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TIPOD_ ]) := aTabCalend[ nElem, CALEND_POS_TIPO_DIA      ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,MOTIVO_]) := aTabCalend[ nElem, CALEND_POS_MOT_EXECAO    ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,JORN_  ]) := aTabCalend[ nElem, CALEND_POS_JORN          ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,CODREF_]) := aTabCalend[ nElem, CALEND_POS_COD_REFEICAO  ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TPEXT_ ]) := aTabCalend[ nElem, CALEND_POS_TIPO_HE_NOR   ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TPEXTN_]) := aTabCalend[ nElem, CALEND_POS_TIPO_HE_NOT   ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,NONAHR_]) := aTabCalend[ nElem, CALEND_POS_PG_NONA_HORA  ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,INIHNT_]) := aTabCalend[ nElem, CALEND_POS_INI_H_NOT     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,FIMHNT_]) := aTabCalend[ nElem, CALEND_POS_FIM_H_NOT     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,MINHNT_]) := aTabCalend[ nElem, CALEND_POS_MIN_H_NOT     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HNTTAB_]) := ""
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HNTTBI_]) := ""
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,REGRA_ ]) := aTabCalend[ nElem, CALEND_POS_REGRA         ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,DORIG_ ]) := aTabCalend[ nElem, CALEND_POS_TIPO_ORIG_DIA ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,P2ID_  ]) := aTabCalend[ nElem, CALEND_POS_P2ID		   ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TPEXCE_]) := aTabCalend[ nElem, CALEND_POS_TPEXCE		   ]				
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,R8ID_  ]) := aTabCalend[ nElem, CALEND_POS_R8ID		   ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HRMENO_]) := nHorMen
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,CHKTNO_]) := "N"
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,PROCES_]) := aTabCalend[ nElem, CALEND_POS_PROCESSO      ]
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,PERIOD_]) := aTabCalend[ nElem, CALEND_POS_PERIODO       ]
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,ROTEIR_]) := aTabCalend[ nElem, CALEND_POS_ROTEIRO       ]
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,NUMPAG_]) := aTabCalend[ nElem, CALEND_POS_NUM_PAGTO     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,FLAG_  ]) := "I"
			( cAliasRF6 )->( MsUnlock() )

			( cAliasRF6 )->( fkCommit() )
			nRecnoRF6 := ( cAliasRF6 )->( Recno() )
			RecLock(cAliasRF6, .F., .F.)

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Grava o item do calendario - Entrada						  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				GrvItem( cFil, cMat, nElem, aTabCalend, @nRecnoRF7, dDtaMen, dDtaMai )

		Else

			dDataApoAnt := aTabCalend[ nElem, CALEND_POS_DATA_APO 	]
			cTurno    	:= aTabCalend[ nElem, CALEND_POS_TURNO   	]
			
			If Empty(aTabCalend[ nElem, CALEND_POS_NUM_MARC])
				nNumMarc++
			Else
				nNumMarc := aTabCalend[ nElem, CALEND_POS_NUM_MARC]
			EndIf

             nTotHrInt := SomaHoras( nTotHrInt, aTabCalend[ nElem, CALEND_POS_HRS_INTER ] )
             nTotHrTra := SomaHoras( nTotHrTra, aTabCalend[ nElem, CALEND_POS_HRS_TRABA ] )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Grava o item do calendario - Saida						  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			GrvItem( cFil, cMat, nElem, aTabCalend, @nRecnoRF7, dDtaMen, dDtaMai )

			nHorMai := If( Empty(nHorMai), aTabCalend[ nElem, CALEND_POS_LIM_MARCACAO, 2 ], nHorMai )
			
			If !Empty(nHorMai)
				(cAliasRF6)->( dbGoTo( nRecnoRF6 ) )
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HRMAIS_]) := nHorMai
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HRINTV_]) := nTotHrInt
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HRTRAB_]) := nTotHrTra
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,NUMARC_]) := nNumMarc

				(cAliasRF6 )->(MsUnlock())
				(cAliasRF6 )->(fkCommit())
				nHorMai := 0
				nHorMen := 0
			EndIf

		EndIf
	
	Next
	
	lRet := .T.

End Transaction

RestArea( aArea )

Return ( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GrvItem		  ³ Autor ³ Igor Franzoi      ³ Data ³14/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Grava os itens do Calendario							    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aTabCalend = Array do Calendario							³
³		   ³ nPos 	    = Posicao atual no array aTabCalend 			³
³		   ³ aTabCalend = Array do Calendario							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GrvItem( cFil, cMat, nPos, aTabCalend, nRecnoRF7, dDtaMen, dDtaMai )

Local lRet 		:= .F.
Local cAliasRF7 := "RF7"
Local cPrefRF7	:= cAliasRF7+"_"
Local cPagInt	:= "0"

#DEFINE ITEM_	01

#DEFINE FILIAL_ 01
#DEFINE DATA_   02
#DEFINE MAT_    03
#DEFINE LIE_    04
#DEFINE DATAE_  05
#DEFINE ENTRA_  06
#DEFINE LSE_    07
#DEFINE LIS_    08
#DEFINE DATAS_  09
#DEFINE SAIDA_  10
#DEFINE LSS_    11
#DEFINE INTERV_ 12
#DEFINE JNDCO_  13
#DEFINE HRINTV_ 14
#DEFINE HRTRAB_ 15
#DEFINE CC_     16
#DEFINE DEPTO_  17
#DEFINE POSTO_  18
#DEFINE CODFUN_ 19
#DEFINE FLAG_   20

If ( "I" $ aTabCalend[ nPos, CALEND_POS_PAGINT    ] )
	cPagInt := "1"
EndIf	

If ( SubStr( aTabCalend[ nPos, CALEND_POS_TIPO_MARC ],2,1 ) == "E" )

	RecLock(cAliasRF7, .T., .F.)
	
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,FILIAL_]) := cFil
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,DATA_  ]) := aTabCalend[ nPos, CALEND_POS_DATA_APO  ]  //Data apontamento
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,MAT_   ]) := cMat

		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,LIE_   ]) := aTabCalend[ nPos, CALEND_POS_LIE  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,DATAE_ ]) := aTabCalend[ nPos, CALEND_POS_DATA ]  	//Data da marcacao
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,ENTRA_ ]) := aTabCalend[ nPos, CALEND_POS_HORA ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,LSE_   ]) := aTabCalend[ nPos, CALEND_POS_LSE  ]

		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,INTERV_]) := cPagInt
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,JNDCO_ ]) := aTabCalend[ nPos, CALEND_POS_JND_CON   ]
	
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,HRTRAB_]) := aTabCalend[ nPos, CALEND_POS_HRS_TRABA ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,CC_    ]) := aTabCalend[ nPos, CALEND_POS_CC    	  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,DEPTO_ ]) := aTabCalend[ nPos, CALEND_POS_DEPTO 	  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,POSTO_ ]) := aTabCalend[ nPos, CALEND_POS_POSTO 	  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,CODFUN_]) := aTabCalend[ nPos, CALEND_POS_CODFUNC  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,FLAG_  ]) := "I"
		
	(cAliasRF7)->(MsUnlock())
	(cAliasRF7)->(fkCommit())
	
	nRecnoRF7 := (cAliasRF7)->(Recno())

	RecLock(cAliasRF7, .F., .F.)
	
	lRet := .T.

Else

	(cAliasRF7)->(dbGoTo( nRecnoRF7 ))	
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,LIS_   ]) := aTabCalend[ nPos, CALEND_POS_LIS  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,DATAS_ ]) := aTabCalend[ nPos, CALEND_POS_DATA ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,SAIDA_ ]) := aTabCalend[ nPos, CALEND_POS_HORA ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,LSS_   ]) := aTabCalend[ nPos, CALEND_POS_LSS  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,HRINTV_]) := aTabCalend[ nPos, CALEND_POS_HRS_INTER ]
	( cAliasRF7 )->( MsUnlock() )
	
	lRet := .T.

EndIf

Return lRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CarregaCalend ³ Autor ³ Igor Franzoi	  ³ Data ³19/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega o calendario fisico para o array					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function CarregaCalend(	dDataIni	,; //01 -> Data Inicial do Periodo
								dDataFim	,; //02 -> Data Final do Periodo
								cTno		,; //03 -> Turno Para a Montagem do Calendario
								cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
								aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
								aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
								cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
								cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
								cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
								aTurnos		,; //10 -> Array com as Trocas de Turno
								aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
								lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
								lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
								aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
								lAcumulado	 ; //16 -> Identifica se o periodo esta fechado(.F.)/aberto(.T.)
				)

Local aArea   := GetArea()
Local nRet    := 0
Local nCal    := 0 
Local nReg	  := 0
Local nPos	  := 0
Local nExc	  := 0
Local nMaxReg := 0
Local nRegAux := 0

Local cKey 	  := ""
Local cKeyRf7 := ""

Local nOrderRf6 := ""
Local nOrderRf7 := ""

Local nHora		:= 0
Local nTrcTno	:= 0
Local nTno		:= 0
Local nSeq		:= 0
Local nHorMen	:= 0
Local nHorMai	:= 0
Local nIniHnt 	:= 0
Local nFimHnt 	:= 0
Local nMinHnt 	:= 0
Local nLimMarc	:= 0
Local nLimInfE 	:= 0
Local nLimSupE 	:= 0
Local nLimInfS	:= 0
Local nLimSupS	:= 0
Local nTipMarc	:= 0
Local nNumMarc	:= 0
Local nHrTrab	:= 0
Local nHrInte	:= 0
Local nSerial   := 0

 /*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Montagem do Calendario                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local cFilSPJ 	  := xFilial( If (lUseSPJ,"SPJ","RF2") , cFil )
Local cRegra	  := ""
Local cTurno	  := ""
Local cCcCal	  := ""
Local cDepto      := ""
Local cPosto	  := ""
Local cCodRef	  := ""
Local cPagInt     := ""
Local cP3Desc	  := ""
Local cIdAfas	  := ""
Local cTipoDia	  := ""
Local cIdExce	  := ""
Local cTpExce	  := ""
Local cTpExt	  := ""
Local cTpExtN	  := ""
Local cNonaHr     := ""
Local cCodPro 	  := ""
Local cNumPag 	  := ""
Local cCodPer 	  := ""
Local cCodRot 	  := ""
Local cCodJor 	  := ""
Local cMotExc 	  := ""
Local cNewReg	  := ""
Local cRegOrig	  := ""
Local cFuncCal	  := ""
Local cJndCont	  := ""
Local cP3TpExt	  := ""
Local cTipAfast	  := ""
Local cTipDorig   := ""
Local cP3TpExtN	  := ""
Local cTpExNorFer := ""
Local cTpExNotFer := ""

Local nFimHnot	  := 23.59

Local lRet			 := .F.
Local lAfast	     := .F.
Local lFeriado	     := .F.
Local lAponFer       := .F.
Local lExceData	     := .F.
Local lAfastaPer     := .F.
Local lHeAutoFer     := .F.
Local lAllTnoOpc     := .F.
Local lTrbFeriado    := .F.
Local lTnoSubstituto := .F.
Local lTrocaTno      := .F.

Local dDataCal	:= Ctod("//")
Local dDataApo	:= Ctod("//")
Local dIniAfas	:= Ctod("//")
Local dFimAfas	:= Ctod("//")
Local dDataLimE := Ctod("//")
Local dDataLimS := Ctod("//")
Local dData		:= Ctod("//")

Local cAliasRF6 := "RF6"
Local cAliasRF7 := "RF7"

Local cOrdem   := ""
Local dDataAnt := Ctod("//")

Local cCpos	   := ""
Local lSrvType := NIL

Local aTabTno	:= {}
Local aCpos	    := {}
Local aSP6Cache := {}
Local aSpAux	:= {}
Local aSPACpo	:= {}
Local aSr6Cpo   := {}
Local aTrcTno   := {}
Local aAuxTno   := {}
Local aAllExc   := {}
Local aDataApo 	:= {}
Local aSpaInfo  := {}
Local aSr6Info  := {}
Local aTabOrig	:= {}
Local aExcecoes := {}
Local aTabTurno := {}
Local aDiaTurnoOk := {}

Local aAfasta
Local nFields
Local cJoin
Local cWhere
Local cOrder

Local cAliasQry

DEFAULT aTabCalend   := {}
DEFAULT __aAllTnoOpc := {}

cKey 	 := cFil+cMat
lSrvType := If( Type("lSrvType") == "U", lExInAs400, lSrvType )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem as Informacoes em Cache do Turno de Trabalho          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aSr6Cpo := {;
		"R6_INIHNOT"	,;	//01
		"R6_FIMHNOT"	,;	//02
		"R6_MINHNOT"	,;	//03
		"R6_APODFER"	,;	//04
		"R6_TPEXFER"	,;	//05
		"R6_TPEXFEN"	,;	//06
		"R6_AUTOHEF"	,;	//07
		"R6_TNOOPC"  	;	//08
}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Campos recuperados do SPA - Paga intervalo / Trab. Feriado  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aSPACpo := { "PA_PAGINT", "PA_FERIADO" }

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta os campos da Query									  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If Empty(aStcStrRF6)
	aStcStrRF6 := RF6->(dbStruct())
EndIf

For nFields := 1 To Len(aStcStrRF6)
	cCpos += aStcStrRF6[ nFields, 01 ] + ", "
	aAdd( aCpos, aStcStrRF6[ nFields, 01 ] )
Next 

If Empty(aStcStrRF7)
	aStcStrRF7 := RF7->(dbStruct())
EndIf

For nFields := 1 To Len(aStcStrRF7)
	cCpos += aStcStrRF7[ nFields, 01 ] + If( nFields != Len(aStcStrRF7), ", ", "" )
	aAdd( aCpos, aStcStrRF7[ nFields, 01 ] )
Next

#IFDEF TOP
	
	cAliasQry := GetNextAlias()
	cCpos += ", RF6.R_E_C_N_O_ RF6RECNO, RF7.R_E_C_N_O_ "
	cCpos := "%"+cCpos+"%"
	
 	cJoin := "% RF6.RF6_FILIAL  = RF7.RF7_FILIAL "
	cJoin += " AND RF6.RF6_MAT = RF7.RF7_MAT	%"

	cWhere := "% RF6.RF6_FILIAL = '"+cFil+"' "
	cWhere += " AND RF6.RF6_MAT = '"+cMat+"' "
	cWhere += " AND RF6.RF6_DATA >= '"+Dtos(dDataIni)+"' "
	cWhere += " AND RF6.RF6_DATA <= '"+Dtos(dDataFim)+"' "
	cWhere += " AND RF6.RF6_DATA = RF7.RF7_DATA %"
	
	cOrder := "% RF6.RF6_FILIAL, RF6.RF6_MAT, RF6.RF6_DATA, RF6.RF6_TURNO %"
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Seleciona os dados do cabecalho e item do calendario		  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	
	BeginSql alias cAliasQry
		column RF6_DATA as Date, RF7_DATA as Date, RF7_DATAE as Date, RF7_DATAS as Date
		SELECT 		%exp:cCpos%
		FROM 		%table:RF6% RF6
		INNER JOIN  %table:RF7% RF7
		ON 			%exp:cJoin%
		WHERE 		%exp:cWhere% AND
					RF6.%NotDel% AND
					RF7.%NotDel%
		ORDER BY    %exp:cOrder%				
	EndSql
	
	IF Empty( aTurnos )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Trocas de Turno/Regra do Periodo				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		DEFAULT aTurnos := {}
		lTrocaTno := fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
	Else
		lTrocaTno := .T.
	EndIF
	//Verifica se for MENOR ou igual, não existindo assume SRA
	IF ( ( nPos := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) > 0 )
		cTno 	:= aTurnos[ nPos , 01 ]
		cSeq	:= aTurnos[ nPos , 03 ]
		cRegra 	:= aTurnos[ nPos , 05 ]
	Else
		If ( ( nPos := aScan( aTurnos , { |x| x[2] < dDataIni } ) ) > 0 )
			cTno 	:= aTurnos[ nPos , 01 ]
			cSeq	:= aTurnos[ nPos , 03 ]
			cRegra 	:= aTurnos[ nPos , 05 ]
		Else
			cRegra	:= SRA->RA_REGRA
		EndIf
	EndIF	

	fTabPadrao( @aTabPadrao , @cFilSPJ , cTno , lExecQryTop )
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem todos os Turnos Opcionais			                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
	lAllTnoOpc := .F.
	If __lChkTnoOpc
		If lTrocaTno                     
			For nTno:= 1 To Len(aTurnos)               
				//-- Carrega todos os horarios opcionais do turno
		    	If LoadTnoOpc(cFilSPJ, aTurnos[nTno, 1],__aAllTnoOpc, @aTabPadrao)
		    	   lAllTnoOpc := .T.
		    	Endif   
		    Next
		Else
			//-- Carrega todos os horarios opcionais do turno
		    If LoadTnoOpc(cFilSPJ, cNewTno,__aAllTnoOpc, @aTabPadrao)
	    	   lAllTnoOpc := .T.
	    	Endif   
		Endif  
    Endif
        
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega as Marcacoes do Funcionario para Ajustar os Turnos  ³
	³ em funcao da existencia de turnos opcionais				  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	        
	If lAllTnoOpc 
		If Empty(aMarcacoes) 
			GetMarcOpc(	@aMarcacoes						,;	//01 -> Marcacoes dos Funcionarios
						dDataIni						,;	//02 -> Periodo Inicial
						dDataFim						,;	//03 -> Periodo Final
						cFil							,;	//04 -> Filial
						cMat							,;	//05 -> Matricula
						cTno							,;	//06 -> Turno
						cSeq							,;	//07 -> Sequencia de Turno
						cCc								,;	//08 -> Centro de Custo 
						If(lAcumulado, "SPG", "SP8")     ; //09 -> Obtem as marcacoes do Alias conforme o periodo considerado.
					  )         
		Endif  		  
    Endif  

	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Monta array aTabCalend com os dados da tabela				  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	While (cAliasQry)->( !Eof() .and. RF6_FILIAL+RF6_MAT == cKey .and. ;
		  					RF6_DATA >= dDataIni .and. RF6_DATA <= dDataFim )
	
		dDataApo := (cAliasQry)->(RF6_DATA)
				
		If ( dDataAnt == dDataApo )
			If ( lExceData .and. !( aExcecoes[nExc,46] <> "S" ) ) 
				(cAliasQry)->(dbSkip())
				Loop
			Else
				If ( lExceData )
					nRegAux := nMaxReg + 1
					nTipMarc:= nRegAux
					nMaxReg := nMaxReg + 2
				Else
					nRegAux := 1
					nMaxReg := 2
				EndIf
			EndIf
		Else
			nMaxReg	 := 2
			nRegAux	 := 1
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Calcula Limite de Saida do Dia ANTERIOR baseado no HorMais  ³
			³ NAO MUDAR essa Linha										  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	
			If( Len(aTabCalend) > 0)
				aTabCalend[ Len(aTabCalend), CALEND_POS_LIM_MARCACAO ] := { dDataLimS, nHorMai }
			EndIf
		
	   		/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem as informacoes o dia de apontamento					  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	
			dDataAnt := dDataApo
			nTipMarc := 1

			nHorMai := (cAliasQry)->(RF6_HRMAIS)
			nHorMen := (cAliasQry)->(RF6_HRMENO)

			cRegra	 := (cAliasQry)->(RF6_REGRA )		
			cCodRef  := (cAliasQry)->(RF6_CODREF)
			cCodJor	 := (cAliasQry)->(RF6_JORN  )
			cNonaHr	 := (cAliasQry)->(RF6_NONAHR)
			cTipoDia := (cAliasQry)->(RF6_TIPOD)
			cIdExce  := (cAliasQry)->(RF6_P2ID  )
			cTpExce  := (cAliasQry)->(RF6_TPEXCE)
			nNumMarc := (cAliasQry)->(RF6_NUMARC)
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Calcula Limite de Entrada do Dia baseado no HorMenos		  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nLimMarc	:= nHorMen
			dDataLimE 	:= (cAliasQry)->(RF7_DATAE)
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se Houve Alteracao na Tabela Padrao/Regra em Funcao das Exce³
			³ coes, Restaura os Padroes								      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( !Empty( aTabOrig ) )
				aTabTno		:= aClone( aTabOrig )
				aTabOrig	:= {}
				cNewReg		:= cRegOrig
				cRegOrig	:= ""
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se houver Sincronismo, adiciona a Data de Apontamento  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lSncMaMe )
				aAdd( aDataApo, dDataApo)
			EndIF			
			

			If ( cTurno+cSeq != (cAliasQry)->(RF6_TURNO)+(cAliasQry)->(RF6_SEQ) )
				cTurno   := (cAliasQry)->(RF6_TURNO )
				cSeq     := (cAliasQry)->(RF6_SEQ   )
			
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se houve troca de turno, e adiciona no array para  ³
				³ formar os elementos do aTurnos - permanencia do legado 	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nPos := aScan( aTurnos, { |x| x[1] == cTurno } ) 
				
				If (nPos == 0)				
					aAdd( aTurnos , { cTurno , dDataIni , cSeq , 0 , cRegra } )
				EndIf

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega tabela de horario padrao 							   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				fTabPadrao( @aTabPadrao , cFil, cTurno , lExecQryTop )
					
				If ( nPos := aScan( aSP6Cache, { |x| x[1] == cTurno } ) ) == 0
					aSpAux   := aClone(aSr6Cpo)
					aSr6Info := PosSR6( cTurno , cFil , @aSr6Cpo , 01 , .F. )
					aSr6Cpo  := aClone(aSpAux)
					aAdd( aSp6cache, {cTurno,aSr6Info} )					
	            Else
	                aSr6Info := aClone(aSP6Cache[nPos])
	            Endif
            
    		EndIf
            
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Pesquisa e Carrega a Tabela do Turno Corrente				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( ( nPos := aScan( aTabPadrao, { |x| x[2] == cTurno .and. ( x[1] == cFilSPJ .or. Empty( x[1] ) ) } ) ) > 0 )
				aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
			EndIF            
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega as Excecoes para o dia se nao estiver carregada	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If !( lExceData := RetExcId( cFil, cIdExce, dDataApo, cRegra, aAllExc, aExcecoes ) )
				If lAllTnoOpc
				   	/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
					³ em Funcao de Excecoes										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
				   ( lTnoOpcData:=GetTnoOpc( cNewTno, dData, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFilSPJ, @aMarcacoes))
				Else
					If lPnmTab01 
						If ( ValType( uRet 	:= ExecBlock("PNMTAB01",.F.,.F., { cFil, cMat , dDataApo, cTurno, aClone(aTabTno[nPos]) }) ) == "A" )
							If (lTnoSubstituto  := !Empty(uRet) )
								 /*/
							    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							    ³ Troca a tabela de horario do turno do dia pela do Ponto de Entrada           ³
							    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
								aTabTno[nPos] 	:= aClone(uRet)
							Endif	
							uRet := NIL
						EndIf
					EndIf				
			    EndIf
			Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
				³ em Funcao de Excecoes										  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nExc := aScan( aExcecoes, { |x|  x[59] == cIdExce } )
				aTabOrig  := aClone( aTabTno )
				cRegOrig  := cNewReg
			EndIf
		EndIf						

		If (cAliasQry)->(RF6_CHKTNO) == "S" .and. lAllTnoOpc
			(cAliasQry)->(dbSkip())
			Loop
		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem as Informacoes em Cache da Regra de Apontamento       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSpAux  := aClone(aSPACpo)
		aSPAInfo := PosSPA( (cAliasQry)->(RF6_REGRA) , cFil , @aSPACpo, 01 , .F. )
		aSPACpo  := aClone(aSpAux)
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Quais Intervalos Sao Pagos             			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cPagInt := aSPAInfo[1]

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Se o Dia em Questao eh um Feriado				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lTrbFeriado := .F.
		If ( lFeriado := fFeriado( cFil , (cAliasQry)->(RF6_DATA) ) )
			cP3TpExt		:= SP3->P3_TPEXT
			cP3TpExtN		:= SP3->P3_TPEXTN
			cP3Desc			:= SP3->P3_DESC
			lTrbFeriado := ( aSpaInfo[2] == "S" )
		Else
			cP3TpExt	:= ""
			cP3TpExtN	:= ""
			cP3Desc		:= ""
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verificar se o Funcionario Esta Afastado na Data			  ³
		³ atraves do R8_NUMID - Identificador unico de afastamento	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
		If ( (cAliasQry)->(RF6_R8ID) != cIdAfas )

			lAfast := fAfasta( cFil,;
							   cMat,;
							   (cAliasQry)->(RF7_DATA),;
							   @dIniAfas,;
							   @dFimAfas,;
							   @cTipAfast,;
							   aAfasta,;
							   @cIdAfas )
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se estiver Afastado Define o Dia como Nao Trabalhado        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If ( lAfast )
				cTipoDia := "N"	//Nao Trabalhado
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Aponta para Funcionario em Ferias            	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If ( cTipAfast == "F" )
				If ( lAponFer := ( aSr6Info[4] == "S" ) )
	
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se funcionario em Ferias com Direito a Apontamento       	  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					cTpExNorFer	:= aSr6Info[5]	//Normal Ferias
					cTpExNotFer	:= aSr6Info[6]	//Noturna Ferias
	
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Verifica se horas extras sao autorizadas para funcionario   ³
					³ em ferias.												  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					lHeAutoFer := If ( aSr6Info[7] == "1" .or. Empty( aSr6Info[7] ), .T. , .F. )	 // 1 ou branco - Autorizadas (Padrao) , 2- Nao Autorizadas
	
				EndIf
			Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se funcionario nao Trabalha em Feriado e dia For Feriado 	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				If (;
				 		( lFeriado );			//Dia eh Feriado
				 		.and.;
				 		!( lTrbFeriado );		//Funcionario Nao Trabalha em Feriado
				 	)
					cTipoDia := "F" //Feriado
				EndIF
			EndIf
	    EndIf
	    
	    nSeq := Val( (cAliasQry)->(RF6_SEQ) )
	    		
     	cCodPro	 := (cAliasQry)->(RF6_PROCES)
		cCodPer	 := (cAliasQry)->(RF6_PERIOD)
		cCodRot	 := (cAliasQry)->(RF6_ROTEIR) 
		cNumPag	 := (cAliasQry)->(RF6_NUMPAG)
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica se o Dia da Semana da Sequencia e equivalente ao Dia³
		³da Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  com³
		³o StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) }
		IF !( lCriaCalOk := ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
			Break
		EndIF

		If !( lExceData := !Empty( (cAliasQry)->(RF6_P2ID) ) )
		
			/*/
		   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   ³ Checa a Existencia de Turnos Opcionais				          ³
		   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
		 	If lAllTnoOpc

		 		aDiaTurnoOk := {}
				AADD( aDiaTurnoOK, {dDataApo, SPACE(1) } )
		 		
			   	/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
				³ em Funcao de Excecoes										  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				aTabOrig  := aClone( aTabTno )
				cRegOrig  := cNewReg
				aTabTno := Clone( aTabPadrao )
			    GetTnoOpc( cTurno, dDataApo, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFil, @aMarcacoes)
			 EndIf
				 
		Else
			
			If ( aExcecoes[nExc,46] <> "S" )	
			
				nMaxReg	 := 0
				nNumMarc := 0
																
				aTabTno[nPos,01] 	:= aExcecoes[nExc,05]		// 01 - 1a Entrada
				aTabTno[nPos,02] 	:= aExcecoes[nExc,06]		// 02 - 1a Saida
				aTabTno[nPos,03] 	:= aExcecoes[nExc,07]		// 03 - 2a Entrada
				aTabTno[nPos,04] 	:= aExcecoes[nExc,08]		// 04 - 2a Saida
				aTabTno[nPos,05] 	:= aExcecoes[nExc,09]		// 05 - 3a Entrada
				aTabTno[nPos,06] 	:= aExcecoes[nExc,10]		// 06 - 3a Saida
				aTabTno[nPos,07] 	:= aExcecoes[nExc,11]		// 07 - 4a Entrada
				aTabTno[nPos,08] 	:= aExcecoes[nExc,12]		// 08 - 4a Saida
				aTabTno[nPos,09] 	:= aExcecoes[nExc,16]		// 09 - Horas Trabalhadas 1a. Jornada
				aTabTno[nPos,10] 	:= aExcecoes[nExc,17]		// 10 - Horas Trabalhadas 2a. Jornada
				aTabTno[nPos,11] 	:= aExcecoes[nExc,18]		// 11 - Horas Trabalhadas 3a. Jornada
				aTabTno[nPos,12] 	:= aExcecoes[nExc,19]		// 12 - Horas Trabalhadas 4a. Jornada
				aTabTno[nPos,13] 	:= aExcecoes[nExc,26]		// 13 - Horas de Intervalo 1S
				aTabTno[nPos,14] 	:= aExcecoes[nExc,27]		// 14 - Horas de Intervalo 2S
				aTabTno[nPos,15] 	:= aExcecoes[nExc,28]		// 15 - Horas de Intervalo 3S
				aTabTno[nPos,16] 	:= ""						// 16 - Marcacao e do dia seguinte ?
				aTabTno[nPos,17] 	:= aExcecoes[nExc,20]		// 17 - Numero de Marcacoes					
				aTabTno[nPos,29] 	:= aExcecoes[nExc,34]		// 29 - Aponta Nona Hora
				aTabTno[nPos,30] 	:= aExcecoes[nExc,35]		// 30 - Limite de Horario Inicial
				aTabTno[nPos,31] 	:= aExcecoes[nExc,36]		// 31 - Limite de Horario Final
				aTabTno[nPos,32] 	:= aExcecoes[nExc,37]		// 32 - 1a. Jornada Continua
				aTabTno[nPos,33] 	:= aExcecoes[nExc,38]		// 33 - 2a. Jornada Continua
				aTabTno[nPos,34]	:= aExcecoes[nExc,39]		// 34 - 3a. Jornada Continua
				aTabTno[nPos,35]	:= aExcecoes[nExc,40]		// 35 - 4a. Jornada Continua
				aTabTno[nPos,36]	:= aExcecoes[nExc,41]		// 36 - Codigo da Refeicao
				
				For nReg := 5 To 11 Step 2
					If ( aExcecoes[nExc,23] == "S" )
						If ( !Empty(aExcecoes[nExc,nReg]) )
							nMaxReg := nMaxReg + 2
							nNumMarc++															
						EndIf
					Else
						nReg	:= 11
						nAuxReg := 1
						nMaxReg := 2
						nNumMarc:= 2
					EndIf
				Next
			Else
				nMaxReg := If ( Empty(nNumMarc), 2, nNumMarc )
		    EndIf
				
			aTabTno[nPos,18] 	:= aExcecoes[nExc,23]			// 18 - Tipo do Dia
			aTabTno[nPos,19] 	:= aTabTno[nPos,19]             // 19 - Sequencia da Marcacao
			aTabTno[nPos,20] 	:= Dow( dDataApo )     			// 20 - Numero Correspondente ao Dia da Semana
			aTabTno[nPos,21] 	:= "E"							// 21 - Flag Indicador de Excecao
			aTabTno[nPos,22] 	:= aExcecoes[nExc,21]			// 22 - Motivo da Excecao
			aTabTno[nPos,23] 	:= aExcecoes[nExc,22]			// 23 - Codigo Hora Extra Normal
			aTabTno[nPos,24] 	:= aExcecoes[nExc,24]			// 24 - Codigo Hora Extra Noturna
			aTabTno[nPos,25] 	:= If ( !Empty(aExcecoes[nExc,29]), aExcecoes[nExc,29], cCCcal )			// 25 - Centro de Custo Periodo 1 (1a.E-1a.S)
			aTabTno[nPos,26] 	:= If ( !Empty(aExcecoes[nExc,30]), aExcecoes[nExc,30], cCCcal )			// 26 - Centro de Custo Periodo 2 (2a.E-2a.S)
			aTabTno[nPos,27] 	:= If ( !Empty(aExcecoes[nExc,31]), aExcecoes[nExc,31], cCCcal )			// 27 - Centro de Custo Periodo 3 (3a.E-3a.S)
			aTabTno[nPos,28] 	:= If ( !Empty(aExcecoes[nExc,32]), aExcecoes[nExc,32], cCCcal )			// 28 - Centro de Custo Periodo 4 (4a.E-4a.S)		
			aTabTno[nPos,38] 	:= If ( !Empty(aExcecoes[nExc,47]), aExcecoes[nExc,47], cFuncCal )			// 38 - Funcoes Periodo 1 (1a.E-1a.S)
			aTabTno[nPos,39] 	:= If ( !Empty(aExcecoes[nExc,48]), aExcecoes[nExc,48], cFuncCal )			// 39 - Funcoes Periodo 2 (2a.E-2a.S)
			aTabTno[nPos,40] 	:= If ( !Empty(aExcecoes[nExc,49]), aExcecoes[nExc,49], cFuncCal )			// 40 - Funcoes Periodo 3 (3a.E-3a.S)
			aTabTno[nPos,41] 	:= If ( !Empty(aExcecoes[nExc,50]), aExcecoes[nExc,50], cFuncCal )			// 41 - Funcoes Periodo 4 (4a.E-4a.S)				
			aTabTno[nPos,58] 	:= If ( !Empty(aExcecoes[nExc,55]), aExcecoes[nExc,55], cDepto )			// 58 - Depto Periodo 1 (1a.E-1a.S)
			aTabTno[nPos,59] 	:= If ( !Empty(aExcecoes[nExc,56]), aExcecoes[nExc,56], cDepto )			// 59 - Depto Periodo 2 (2a.E-2a.S)
			aTabTno[nPos,60] 	:= If ( !Empty(aExcecoes[nExc,57]), aExcecoes[nExc,57], cDepto )			// 60 - Depto Periodo 3 (3a.E-3a.S)
			aTabTno[nPos,61] 	:= If ( !Empty(aExcecoes[nExc,58]), aExcecoes[nExc,58], cDepto )			// 61 - Depto Periodo 4 (4a.E-4a.S)
			aTabTno[nPos,62] 	:= If ( !Empty(aExcecoes[nExc,51]), aExcecoes[nExc,51], cPosto )			// 62 - Posto Periodo 1 (1a.E-1a.S)
			aTabTno[nPos,63] 	:= If ( !Empty(aExcecoes[nExc,52]), aExcecoes[nExc,52], cPosto )			// 63 - Posto Periodo 2 (2a.E-2a.S)
			aTabTno[nPos,64] 	:= If ( !Empty(aExcecoes[nExc,53]), aExcecoes[nExc,53], cPosto )			// 64 - Posto Periodo 3 (3a.E-3a.S)
			aTabTno[nPos,65] 	:= If ( !Empty(aExcecoes[nExc,54]), aExcecoes[nExc,54], cPosto )			// 65 - Posto Periodo 4 (4a.E-4a.S)								

        EndIf            
            
        If ( lExceData .or. lAllTnoOpc ) .AND. nRegAux <= nMaxReg
            
            cTipoDia	:= aTabTno[ nPos , 18 ]
            cSeq		:= aTabTno[ nPos , 19 ]
            cMotExc		:= aTabTno[ nPos , 22 ]
            cNonaHr		:= aTabTno[ nPos , 29 ]
			nHorMen		:= aTabTno[ nPos , 30 ]
			nHorMai		:= aTabTno[ nPos , 31 ]
		    cCodRef		:= aTabTno[ nPos , 36 ]
			cCodJor		:= aTabTno[ nPos , 70 ]
			
			nLimMarc	:= nHorMai
			
		Endif				
			
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Para cada um registro, carrega dois elementos no array		  ³
		³Pq para cada linha do calendario fisico existe uma entrada e |
		³uma saida, tabela RF7 										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		For nReg := nRegAux To nMaxReg
		
			nHrTrab	 := (cAliasQry)->(RF7_HRTRAB)
			nHrInte	 := (cAliasQry)->(RF7_HRINTV)			
			cCcCal 	 := (cAliasQry)->(RF7_CC)
			cFuncCal := (cAliasQry)->(RF7_CODFUN)
			cJndCont := (cAliasQry)->(RF7_JNDCO)
			cDepto	 := (cAliasQry)->(RF7_DEPTO)
			cPosto	 := (cAliasQry)->(RF7_POSTO)
			
			If AllTrim(Str(nReg)) $ "1_3_5_7"
				dData    := (cAliasQry)->(RF7_DATAE)
			Else
				dData    := (cAliasQry)->(RF7_DATAS)
			EndIf			
           
            If ( lExceData .or. lAllTnoOpc )
            
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Incrementa dData Quando Marcacao for do Dia Seguinte ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				If ( aTabTno[ nPos , nReg ] <  aTabTno[ nPos , IF( nReg == 1 , nReg , nReg-1 ) ] )
					If !( dData+1 > (cAliasQry)->(RF7_DATAS) ) 
						dData++
						nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nReg ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
						dDataLimE	:= __fNsToDh( nSerial , "D" )
						nLimMarc	:= __fNsToDh( nSerial , "H" )					
					EndIf					
				EndIf
				
				Do Case
					Case ( AllTrim(Str( nTipMarc )) $ "1" )
						cCcCal 		:= aTabTno[ nPos , 25 ] 
						cFuncCal 	:= aTabTno[ nPos , 38 ]
						cJndCont	:= aTabTno[ nPos , 32 ]
						cDepto		:= aTabTno[ nPos , 58 ]
						cPosto		:= aTabTno[ nPos , 62 ]
						IF ( nReg == 1 )
							nHora	 := aTabTno[ nPos , 01 ]
							nHrTrab  := aTabTno[ nPos , 09 ]
							nLimInfE := aTabTno[ nPos , 42 ]
							nLimSupE := aTabTno[ nPos , 43 ]
						Else
							nHora	 := aTabTno[ nPos , 02 ]
							nHrInte  := aTabTno[ nPos , 13 ]
							nLimInfS := aTabTno[ nPos , 44 ]
							nLimSupS := aTabTno[ nPos , 45 ]
						EndIF
					Case ( AllTrim(Str( nTipMarc )) $ "2" )
						cCcCal 		:= aTabTno[ nPos , 26 ]
						cFuncCal 	:= aTabTno[ nPos , 39 ]
						cJndCont	:= aTabTno[ nPos , 33 ]
						cDepto		:= aTabTno[ nPos , 59 ]
						cPosto		:= aTabTno[ nPos , 63 ]				
						IF ( nReg == 3 )
							nHora	 := aTabTno[ nPos , 03 ]
							nHrTrab  := aTabTno[ nPos , 10 ]
							nLimInfE := aTabTno[ nPos , 46 ]
							nLimSupE := aTabTno[ nPos , 47 ]
						Else
							nHora	 := aTabTno[ nPos , 04 ]
							nHrInte  := aTabTno[ nPos , 14 ]
							nLimInfS := aTabTno[ nPos , 48 ]
							nLimSupS := aTabTno[ nPos , 49 ]
						EndIF
					Case ( AllTrim(Str( nTipMarc )) $ "3" )
						cCcCal 		:= aTabTno[ nPos , 27 ]
						cFuncCal 	:= aTabTno[ nPos , 40 ]
						cJndCont	:= aTabTno[ nPos , 34 ]
						cDepto		:= aTabTno[ nPos , 60 ]
						cPosto		:= aTabTno[ nPos , 64 ]
					
						IF ( nReg == 5 )
							nHora	 := aTabTno[ nPos , 05 ]
							nHrTrab  := aTabTno[ nPos , 11 ]
							nLimInfE := aTabTno[ nPos , 50 ]
							nLimSupE := aTabTno[ nPos , 51 ]
						Else
							nHora	 := aTabTno[ nPos , 06 ]
							nHrInte  := aTabTno[ nPos , 15 ]
							nLimInfS := aTabTno[ nPos , 52 ]
							nLimSupS := aTabTno[ nPos , 53 ]
						EndIF
					Case ( AllTrim(Str( nTipMarc )) $ "4" )
						nHrTrab		:= aTabTno[ nPos , 12 ]					
						cCcCal 		:= aTabTno[ nPos , 28 ]
						cFuncCal 	:= aTabTno[ nPos , 41 ]
						cJndCont	:= aTabTno[ nPos , 35 ]
						cDepto		:= aTabTno[ nPos , 61 ]
						cPosto		:= aTabTno[ nPos , 65 ]					
						IF ( nReg == 7 )
							nHora	 := aTabTno[ nPos , 07 ]
							nHrTrab  := aTabTno[ nPos , 12 ]
							nLimInfE := aTabTno[ nPos , 54 ]
							nLimSupE := aTabTno[ nPos , 55 ]
						Else
							nHora	 := aTabTno[ nPos , 08 ]
							nLimInfS := aTabTno[ nPos , 56 ]
							nLimSupS := aTabTno[ nPos , 57 ]
						EndIF
				EndCase
				
			Else
				If AllTrim(Str(nReg)) $ "1_3_5_7"
					nHora    := (cAliasQry)->(RF7_ENTRA)
					nLimInfE := (cAliasQry)->(RF7_LIE  )
					nLimSupE := (cAliasQry)->(RF7_LSE  )
				Else
					nHora    := (cAliasQry)->(RF7_SAIDA)
					nLimInfS := (cAliasQry)->(RF7_LIS  )
					nLimSupS := (cAliasQry)->(RF7_LSS  )
				EndIf
				
				If dDataLimE == dData .and. nLimMarc > nHora
					dDataLimE -= 1
				EndIf
            EndIf
                
			aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )		
			nCal := Len(aTabCalend)
			
			aTabCalend[	nCal,	CALEND_POS_DATA		 ] := dData														// 01 - Data
			aTabCalend[	nCal,	CALEND_POS_ORDEM	 ] := (cAliasQry)->(RF6_ORDEM)									// 02 - Ordem
			aTabCalend[	nCal,	CALEND_POS_HORA		 ] := nHora														// 03 - Hora
			
			If AllTrim(Str(nReg)) $ "1_3_5_7"
				aTabCalend[	nCal, CALEND_POS_TIPO_MARC ] := AllTrim(Str(nTipMarc)+"E")								// 04 - Tipo Marc
			Else
				aTabCalend[	nCal, CALEND_POS_TIPO_MARC ] := AllTrim(Str(nTipMarc)+"S")								// 04 - Tipo Marc
				nTipMarc++
			EndIf
			
			aTabCalend[	nCal,	CALEND_POS_NUM_MARC	 ] := nNumMarc    												// 05 - No Marc.
			aTabCalend[	nCal,	CALEND_POS_TIPO_DIA	 ] := cTipoDia													// 06 - Tipo Dia						
			aTabCalend[	nCal,	CALEND_POS_HRS_TRABA ] := nHrTrab													// 07 - Horas Trabalhada no Periodo						
			aTabCalend[	nCal,	CALEND_POS_SEQ_TURNO ] := (cAliasQry)->(RF6_SEQ)									// 08 - Sequˆncia de Turno
			aTabCalend[	nCal,	CALEND_POS_HRS_INTER ] := nHrInte													// 09 - Horas de Intervalo			

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Monta excecao												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aTabCalend[	nCal,	CALEND_POS_EXCECAO			] := If( !Empty(cMotExc), "E", "" )						// 10 - Excecao ( E-Excecao, # E - nao e excecao )
			aTabCalend[	nCal,	CALEND_POS_MOT_EXECAO		] := cMotExc											// 11 - Motivo da Excecao

			aTabCalend[	nCal,	CALEND_POS_TIPO_HE_NOR		] := (cAliasQry)->(RF6_TPEXT)							// 12 - Tipo de hora extra normal
			aTabCalend[	nCal,	CALEND_POS_TIPO_HE_NOT		] := (cAliasQry)->(RF6_TPEXTN)							// 13 - Tipo de hora extra noturna
			aTabCalend[	nCal,	CALEND_POS_TURNO			] := cTurno												// 14 - Turno de Trabalho
			aTabCalend[	nCal,	CALEND_POS_CC				] := cCCcal												// 15 - Centro de Custo do Periodo
			aTabCalend[	nCal,	CALEND_POS_PG_NONA_HORA		] := cNonaHr											// 16 - Pagamento de Nona Hora
			aTabCalend[	nCal,	CALEND_POS_LIM_MARCACAO		] := { dDataLimE, nLimMarc }							// 17 - Limite de Marcacao Inicial
			aTabCalend[	nCal,	CALEND_POS_COD_REFEICAO		] := cCodRef										   	// 18 - Codigo da Refeicao
			aTabCalend[	nCal,	CALEND_POS_FERIADO			] := lFeriado											// 19 - Dia e Feriado
			aTabCalend[	nCal,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt											// 20 - Tipo de Hora Extra Feriado Normal
			aTabCalend[	nCal,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN											// 21 - Tipo de Hora Extra Feriado Noturna
			aTabCalend[	nCal,	CALEND_POS_DESC_FERIADO		] := cP3Desc											// 22 - Descricao do Feriado	
			aTabCalend[	nCal,	CALEND_POS_REGRA			] := (cAliasQry)->(RF6_REGRA) 							// 23 - Regra de Apontamento
			aTabCalend[	nCal,	CALEND_POS_AFAST			] := lAfast												// 24 - Funcionario Afastado
			aTabCalend[	nCal,	CALEND_POS_TIP_AFAST		] := cTipAfast											// 25 - Tipo de Afastamento
			aTabCalend[	nCal,	CALEND_POS_INI_AFAST		] := dIniAfas 											// 26 - Data Inicial do Afastamento
			aTabCalend[	nCal,	CALEND_POS_FIM_AFAST		] := dFimAfas											// 27 - Data Final do Afastamento	
			aTabCalend[	nCal,	CALEND_POS_INI_H_NOT		] := (cAliasQry)->(RF6_INIHNT)							// 28 - Inicio da Hora Noturna
			aTabCalend[	nCal,	CALEND_POS_FIM_H_NOT		] := (cAliasQry)->(RF6_FIMHNT)							// 29 - Final da Hora Noturna
			aTabCalend[	nCal,	CALEND_POS_MIN_H_NOT		] := (cAliasQry)->(RF6_MINHNT)							// 30 - Minutos da Hora Noturna				
			aTabCalend[	nCal,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado										// 31 - Se funcionario Trabalha em Dias Feriados
			aTabCalend[	nCal,	CALEND_POS_APON_FERIAS		] := lAponFer											// 32 - Se Aponta Quando Afastamento em Ferias
			aTabCalend[	nCal,	CALEND_POS_TP_HE_NR_FER		] := cTpExNorFer										// 33 - Tipo de hora extra normal (Ferias)
			aTabCalend[	nCal,	CALEND_POS_TP_HE_NT_FER		] := cTpExNotFer										// 34 - Tipo de hora extra noturna (Ferias)
			aTabCalend[	nCal,	CALEND_POS_PAGINT			] := cPagInt											// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
			aTabCalend[ nCal,   CALEND_POS_TIPO_ORIG_DIA    ] := (cAliasQry)->(RF6_DORIG)							// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos			
			aTabCalend[ nCal,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer											// 37 - Se H.Extras são autorizadas para funcionario em ferias					
			aTabCalend[ nCal,   CALEND_POS_CODFUNC 		    ] := cFuncCal											// 38 - Codigo de funcao
			aTabCalend[ nCal,   CALEND_POS_DEPTO  		    ] := cDepto												// 39 - Codigo de Depto. do funcionario
			aTabCalend[ nCal,   CALEND_POS_POSTO  		    ] := cPosto												// 40 - Codigo do Posto do funcionario
			aTabCalend[ nCal,   CALEND_POS_PERIODO 		    ] := cCodPer											// 41 - Periodo
			aTabCalend[ nCal,   CALEND_POS_ROTEIRO 		    ] := cCodRot											// 42 - Roterio
			aTabCalend[ nCal,   CALEND_POS_PROCESSO		    ] := cCodPro											// 44 - Num. de Pagamento
			aTabCalend[ nCal,   CALEND_POS_NUM_PAGTO	    ] := cNumPag											// 43 - Processo
			aTabCalend[ nCal,   CALEND_POS_JORN			    ] := cCodJor											// 45 - Cod. da Jornada
			aTabCalend[ nCal,   CALEND_POS_P2ID				] := cIdExce 				   							// 46 - Lote da excecao
			aTabCalend[ nCal,   CALEND_POS_R8ID				] := cIdAfas											// 47 - Identificacao afastamento
			aTabCalend[ nCal,   CALEND_POS_DATA_APO			] := dDataApo											// 48 - Data de apontamento					
			aTabCalend[ nCal,   CALEND_POS_JND_CON			] := cJndCont											// 49 - Jornada continua						
			aTabCalend[ nCal,   CALEND_POS_LIE				] := nLimInfE 											// 50 - Limite inferior da entrada
			aTabCalend[ nCal,   CALEND_POS_LSE				] := nLimSupE											// 51 - Limite superior da entrada
			aTabCalend[ nCal,   CALEND_POS_LIS				] := nLimInfS											// 52 - Limite inferior da saida
			aTabCalend[ nCal,   CALEND_POS_LSS				] := nLimSupS 											// 53 - Limite inferior da saida
			aTabCalend[ nCal, 	CALEND_POS_TPEXCE			] := cTpExce											// 54 - Tipo de Excecao "F" - Funcionario / "P" - Periodo
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Zera o limite, pois so vai inserir no primeiro registro e no ³
			³ultimo registro da ordem existente no calendario			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nLimMarc  := 0
					
			//-- Se Entrada
			If AllTrim(Str(nReg)) $ "1_3_5_7"
				dDataLimE := Ctod("//") 	
			Else//-- Se Saida
				If ( lExceData .or. lAllTnoOpc )
					nSerial		:= ( __fDhToNS( aTabCalend[ nCal , CALEND_POS_DATA ] , aTabCalend[ nCal , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31 ]) )
					dDataLimS	:= __fNsToDh( nSerial , "D" )
					nHorMai  	:= __fNsToDh( nSerial , "H" )
				Else
					If ( DataHora2Str( aTabCalend[1][1], aTabCalend[1][3] ) < DataHora2Str( aTabCalend[nCal][1], (aTabCalend[nCal][3] + SR6->R6_HORMAIS) ) ) .AND. (aTabCalend[nCal][3] + SR6->R6_HORMAIS) > nFimHnot
						dDataLimS := (cAliasQry)->(RF7_DATAS) + 1		
					Else
						dDataLimS := (cAliasQry)->(RF7_DATAS)
					EndIf
				EndIF				
			Endif
			
		Next

		cIdExce	  := ""
		cTpExce	  := ""
		cMotExc	  := ""

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Grava as alteracoes do calendario em funcao da troca de hor. ³
		³pelo turno opcional										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/		
		If lAllTnoOpc
			GravaTnoOpc( nCal, (cAliasQry)->(Recno()), (cAliasRF7)->(Recno()), If( nReg == 1, 1, 2), aTabCalend )
		EndIf
				
		(cAliasQry)->(dbSkip())
			
	EndDo
	
	If !Empty(aTabCalend)
		aTabCalend[ Len(aTabCalend), CALEND_POS_LIM_MARCACAO ] := { dDataLimS, nHorMai }
		lRet := .T.	
	EndIf
	
#ELSE
	
	nOrderRf6 := RetOrdem(cAliasRf6,"RF6_FILIAL+RF6_MAT+DTOS(RF6_DATA)+RF6_TURNO")
	nOrderRf7 := RetOrdem(cAliasRf7,"RF7_FILIAL+RF7_MAT+DTOS(RF7_DATA)+RF7_DEPTO+RF7_POSTO")
	
	cKey := cFil+cMat+Dtos(dDataIni)

	dbSelectArea(cAliasRF6)
	(cAliasRF6)->(dbSetOrder(nOrderRf6))
	
	(cAliasRF6)->(dbSeek(cFil+cMat+Dtos(dDataIni)))
	
	IF Empty( aTurnos )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Trocas de Turno/Regra do Periodo				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		DEFAULT aTurnos := {}
		lTrocaTno := fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
	Else
		lTrocaTno := .T.
	EndIF
	
	IF ( ( nPos := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) > 0 )
		cTno 	:= aTurnos[ nPos , 01 ]
		cSeq	:= aTurnos[ nPos , 03 ]
		cRegra 	:= aTurnos[ nPos , 05 ]
	Else
		If ( ( nPos := aScan( aTurnos , { |x| x[2] < dDataIni } ) ) > 0 )
			cTno 	:= aTurnos[ nPos , 01 ]
			cSeq	:= aTurnos[ nPos , 03 ]
			cRegra 	:= aTurnos[ nPos , 05 ]
		Else
			cRegra	:= SRA->RA_REGRA
		EndIf
	EndIF	

	fTabPadrao( @aTabPadrao , @cFilSPJ , cTno , lExecQryTop )
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem todos os Turnos Opcionais			                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
	lAllTnoOpc := .F.
	If __lChkTnoOpc
		If lTrocaTno                     
			For nTno:= 1 To Len(aTurnos)               
				//-- Carrega todos os horarios opcionais do turno
		    	If LoadTnoOpc(cFilSPJ, aTurnos[nTno, 1],__aAllTnoOpc, @aTabPadrao)
		    	   lAllTnoOpc := .T.
		    	Endif   
		    Next
		Else
			//-- Carrega todos os horarios opcionais do turno
		    If LoadTnoOpc(cFilSPJ, cNewTno,__aAllTnoOpc, @aTabPadrao)
	    	   lAllTnoOpc := .T.
	    	Endif   
		Endif  
    Endif
        
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega as Marcacoes do Funcionario para Ajustar os Turnos  ³
	³ em funcao da existencia de turnos opcionais				  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	        
	If lAllTnoOpc 
		If Empty(aMarcacoes) 
			GetMarcOpc(	@aMarcacoes						,;	//01 -> Marcacoes dos Funcionarios
						dDataIni - 7					,;	//02 -> Periodo Inicial
						dDataFim + 7					,;	//03 -> Periodo Final
						cFil							,;	//04 -> Filial
						cMat							,;	//05 -> Matricula
						cTno							,;	//06 -> Turno
						cSeq							,;	//07 -> Sequencia de Turno
						cCc								,;	//08 -> Centro de Custo 
						If(lAcumulado, "SPG", "SP8")     ; //09 -> Obtem as marcacoes do Alias conforme o periodo considerado.
					  )         
		Endif  		  
    Endif  	
	
	If Found()
		While (cAliasRF6)->( !Eof() .and. RF6_FILIAL+RF6_MAT == cFil+cMat .and.   ;
							RF6_DATA >= dDataIni .and. RF6_DATA <= dDataFim )
												
			cRegra   := (cAliasRF6)->(RF6_REGRA )			
			cOrdem   := (cAliasRF6)->(RF6_ORDEM )						
			dDataApo := (cAliasRF6)->(RF6_DATA  )
			cCodRef  := (cAliasRF6)->(RF6_CODREF)
			cIdExce  := (cAliasQry)->(RF6_P2ID  )
			cCodJor	 := (cAliasRF6)->(RF6_JORN  )
			cTpExt	 := (cAliasRF6)->(RF6_TPEXT )
			cTpExtN	 := (cAliasRF6)->(RF6_TPEXTN)
			cNonaHr  := (cAliasRF6)->(RF6_NONAHR)
		    nNumMarc := (cAliasRF6)->(RF6_NUMARC)			
		    nIniHnt  := (cAliasRF6)->(RF6_INIHNT)
			nFimHnt  := (cAliasRF6)->(RF6_FIMHNT)
			nMinHnt  := (cAliasRF6)->(RF6_MINHNT)
			cTipDorig:= (cAliasRF6)->(RF6_DORIG )
			cCodPro	 := (cAliasRF6)->(RF6_PROCES)
			cNumPag	 := (cAliasRF6)->(RF6_NUMPAG)
			cCodPer	 := (cAliasRF6)->(RF6_PERIOD)
			cCodRot	 := (cAliasRF6)->(RF6_ROTEIR)			
			cTipoDia := (cAliasRF6)->(RF6_TIPOD)
			cPgNhr	 := (cAliasRF6)->(RF6_NONAHR)						
			cTpExce	 := (cAliasRF6)->(RF6_TPEXCE)
				
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Guarda os limites da tabela padrao						  ³
			³ O limite superior nHorMai e utilizado no primeiro registro  ³		
			³ da Data, o nHorMin e utilizado no ultimo registro, os reg.  ³				
			³ contidos entre estes sao adicionados em branco			  ³						
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nHorMai := (cAliasRF6)->(RF6_HRMAIS)
			nHorMen := (cAliasRF6)->(RF6_HRMENO)
					
			If dDataAnt == dDataApo
				If ( lExceData .and. !( aExcecoes[nExc,46] <> "S" ) ) 
					(cAliasQry)->(dbSkip())
					Loop
				Else
					If ( lExceData )
						nRegAux := nMaxReg + 1
						nTipMarc:= nRegAux
						nMaxReg := nMaxReg + 2
					Else
						nRegAux := 1
						nMaxReg := 2
					EndIf
				EndIf				
			Else
				If( Len(aTabCalend) > 0)
					aTabCalend[ Len(aTabCalend), CALEND_POS_LIM_MARCACAO ] := { dDataLimS, nHorMai }
				EndIf
				cOrdAnt   := (cAliasRF6)->(RF6_ORDEM)
				nTipMarc  := 1
				nLimMarc  := nHorMen
				dDataLimE := (cAliasRF6)->(RF6_MAIS)
				nMaxReg	 := 2
				nRegAux	 := 1
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se Houve Alteracao na Tabela Padrao/Regra em Funcao das Exce³
				³ coes, Restaura os Padroes								      ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( !Empty( aTabOrig ) )
					aTabTno		:= aClone( aTabOrig )
					aTabOrig	:= {}
					cNewReg		:= cRegOrig
					cRegOrig	:= ""
				EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se houver Sincronismo, adiciona a Data de Apontamento  	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lSncMaMe )
					aAdd( aDataApo, dDataApo)
				EndIF				

				If ( cTurno+cSeq != (cAliasRF6)->(RF6_TURNO)+(cAliasRF6)->(RF6_SEQ) )
					cTurno   := (cAliasRF6)->(RF6_TURNO )
					cSeq     := (cAliasRF6)->(RF6_SEQ   )
				
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Verifica se houve troca de turno, e adiciona no array para  ³
					³ formar os elementos do aTurnos - permanencia do legado 	  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nPos := aScan( aTurnos, { |x| x[1] == cTurno } ) 
					
					If (nPos == 0)				
						aAdd( aTurnos , { cTurno , dDataIni , cSeq , 0 , cRegra } )
					EndIf
	
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Carrega tabela de horario padrao 							   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					fTabPadrao( @aTabPadrao , cFil, cTurno , lExecQryTop )
						
					If ( nPos := aScan( aSP6Cache, { |x| x[1] == cTurno } ) ) == 0
						aSpAux   := aClone(aSr6Cpo)
						aSr6Info := PosSR6( cTurno , cFil , @aSr6Cpo , 01 , .F. )
						aSr6Cpo  := aClone(aSpAux)
						aAdd( aSp6cache, {cTurno,aSr6Info} )					
		            Else
		                aSr6Info := aClone(aSP6Cache[nPos])
		            Endif
	            
	    		EndIf 
	            
       			/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Pesquisa e Carrega a Tabela do Turno Corrente				  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( ( nPos := aScan( aTabPadrao, { |x| x[2] == cTurno .and. ( x[1] == cFilSPJ .or. Empty( x[1] ) ) } ) ) > 0 )
					aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
				EndIF 
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega as Excecoes para o dia se nao estiver carregada	   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				If !( lExceData := RetExcId( cFil, cIdExce, dDataApo, cRegra, aAllExc, aExcecoes ) )
					If lAllTnoOpc
					   	/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
						³ em Funcao de Excecoes										  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						aTabOrig  := aClone( aTabTno )
						cRegOrig  := cNewReg
					   ( lTnoOpcData:=GetTnoOpc( cNewTno, dData, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFilSPJ, @aMarcacoes))
					Else
						If lPnmTab01 
							If ( ValType( uRet 	:= ExecBlock("PNMTAB01",.F.,.F., { cFil, cMat , dDataApo, cTurno, aClone(aTabTno[nPos]) }) ) == "A" )
								If (lTnoSubstituto  := !Empty(uRet) )
									 /*/
								    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								    ³ Troca a tabela de horario do turno do dia pela do Ponto de Entrada           ³
								    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
									aTabTno[nPos] 	:= aClone(uRet)
								Endif	
								uRet := NIL
							EndIf
						EndIf				
				    EndIf
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
					³ em Funcao de Excecoes										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nExc := aScan( aExcecoes, { |x|  x[59] == cIdExce } )
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
				EndIf
				
			EndIf						
	
			If (cAliasRF6)->(RF6_CHKTNO) == "S" .and. lAllTnoOpc
				(cAliasRF6)->( dbSkip() )
				Loop
			EndIf
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem as Informacoes em Cache da Regra de Apontamento       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aSpaInfo := PosSPA( (cAliasRF6)->(RF6_REGRA) , cFil , @aSpaInfo , 01 , .F. )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Quais Intervalos Sao Pagos             			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cPagInt := aSpaInfo[1]
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Se o Dia em Questao eh um Feriado				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lTrbFeriado := .F.
			If ( lFeriado := fFeriado( cFil , (cAliasRF6)->(RF6_DATA) ) )
				cP3TpExt		:= SP3->P3_TPEXT
				cP3TpExtN		:= SP3->P3_TPEXTN
				cP3Desc			:= SP3->P3_DESC
				lTrbFeriado := ( aSpaInfo[2] == "S" )
			Else
				cP3TpExt	:= ""
				cP3TpExtN	:= ""
				cP3Desc		:= ""
			EndIF
			
			cCodPro	 := (cAliasRF6)->(RF6_PROCES)
			cNumPag	 := (cAliasRF6)->(RF6_NUMPAG)
			cCodPer	 := (cAliasRF6)->(RF6_PERIOD)
			cCodRot	 := (cAliasRF6)->(RF6_ROTEIR)			
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verificar se o Funcionario Esta Afastado na Data			  ³
			³ atraves do R8_NUMID - Identificador unico de afastamento	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
			If ( (cAliasRF6)->(RF6_R8ID) != cIdAfas )
				lAfast := fAfasta( cFil, cMat, aTabCalend[ nCal, CALEND_POS_DATA ], @dIniAfas, @dFimAfas, @cTipAfast, aAfasta, @cIdAfas )
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se estiver Afastado Define o Dia como Nao Trabalhado        ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				If ( lAfast )
					cTipoDia := "N"	//Nao Trabalhado
				EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se Aponta para Funcionario em Ferias            	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				If ( cTipAfast == "F" )
					If ( lAponFer := ( aSr6Info[4] == "S" ) )
		
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Se funcionario em Ferias com Direito a Apontamento       	  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						cTpExNorFer	:= aSr6Info[5]	//Normal Ferias
						cTpExNotFer	:= aSr6Info[6]	//Noturna Ferias
		
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Verifica se horas extras sao autorizadas para funcionario   ³
						³ em ferias.												  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						lHeAutoFer := If ( aSr6Info[7] == "1" .or. Empty( aSr6Info[7] ), .T. , .F. )	 // 1 ou branco - Autorizadas (Padrao) , 2- Nao Autorizadas
		
					EndIf
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se funcionario nao Trabalha em Feriado e dia For Feriado 	  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					If (;
					 		( lFeriado );			//Dia eh Feriado
					 		.and.;
					 		!( lTrbFeriado );		//Funcionario Nao Trabalha em Feriado
					 	)
						cTipoDia := "F" //Feriado
					EndIF
				EndIf
		    EndIf
		    
    	    nSeq := Val( (cAliasQry)->(RF6_SEQ) )
    	    
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica se o Dia da Semana da Sequencia e equivalente ao Dia³
			³da Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  com³
			³o StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) }
			IF !( lCriaCalOk := ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
				Break
			EndIF    	    
	    		      		    
		    (cAliasRF7)->(dbSetOrder(nOrderRf7))		    
			cKeyRf7 := cFil+cMat+Dtos(dDataApo)		    
		    (cAliasRF7)->(dbSeek(cKeyRf7))
		    
		    While (cAliasRF7)->( !Eof() .and. RF7_FILIAL+RF7_MAT == cFil+cMat .and.	RF7_DATA == dDataApo )

					
					If !( lExceData := Empty( (cAliasRF6)->(RF6_P2ID) ) )
		
						/*/
					   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					   ³ Checa a Existencia de Turnos Opcionais				          ³
					   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
					 	If lAllTnoOpc
		
					 		aDiaTurnoOk := {}
							AADD( aDiaTurnoOK, {dDataApo, SPACE(1) } )
					 		
						   	/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
							³ em Funcao de Excecoes										  ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							aTabOrig  := aClone( aTabTno )
							cRegOrig  := cNewReg
							aTabTno := Clone( aTabPadrao )
						    GetTnoOpc( cTurno, dDataApo, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFil, @aMarcacoes)
						 EndIf
					Else
								
						IF ( aExcecoes[nExc,46] <> "S" )	
						
							nNumMarc := 0
																
							aTabTno[nPos,01] 	:= aExcecoes[nExc,05]		// 01 - 1a Entrada
							aTabTno[nPos,02] 	:= aExcecoes[nExc,06]		// 02 - 1a Saida
							aTabTno[nPos,03] 	:= aExcecoes[nExc,07]		// 03 - 2a Entrada
							aTabTno[nPos,04] 	:= aExcecoes[nExc,08]		// 04 - 2a Saida
							aTabTno[nPos,05] 	:= aExcecoes[nExc,09]		// 05 - 3a Entrada
							aTabTno[nPos,06] 	:= aExcecoes[nExc,10]		// 06 - 3a Saida
							aTabTno[nPos,07] 	:= aExcecoes[nExc,11]		// 07 - 4a Entrada
							aTabTno[nPos,08] 	:= aExcecoes[nExc,12]		// 08 - 4a Saida
							aTabTno[nPos,09] 	:= aExcecoes[nExc,16]		// 09 - Horas Trabalhadas 1a. Jornada
							aTabTno[nPos,10] 	:= aExcecoes[nExc,17]		// 10 - Horas Trabalhadas 2a. Jornada
							aTabTno[nPos,11] 	:= aExcecoes[nExc,18]		// 11 - Horas Trabalhadas 3a. Jornada
							aTabTno[nPos,12] 	:= aExcecoes[nExc,19]		// 12 - Horas Trabalhadas 4a. Jornada
							aTabTno[nPos,13] 	:= aExcecoes[nExc,26]		// 13 - Horas de Intervalo 1S
							aTabTno[nPos,14] 	:= aExcecoes[nExc,27]		// 14 - Horas de Intervalo 2S
							aTabTno[nPos,15] 	:= aExcecoes[nExc,28]		// 15 - Horas de Intervalo 3S
							aTabTno[nPos,16] 	:= ""						// 16 - Marcacao e do dia seguinte ?
							aTabTno[nPos,17] 	:= aExcecoes[nExc,20]		// 17 - Numero de Marcacoes					
							aTabTno[nPos,29] 	:= aExcecoes[nExc,34]		// 29 - Aponta Nona Hora
							aTabTno[nPos,30] 	:= aExcecoes[nExc,35]		// 30 - Limite de Horario Inicial
							aTabTno[nPos,31] 	:= aExcecoes[nExc,36]		// 31 - Limite de Horario Final
							aTabTno[nPos,32] 	:= aExcecoes[nExc,37]		// 32 - 1a. Jornada Continua
							aTabTno[nPos,33] 	:= aExcecoes[nExc,38]		// 33 - 2a. Jornada Continua
							aTabTno[nPos,34]	:= aExcecoes[nExc,39]		// 34 - 3a. Jornada Continua
							aTabTno[nPos,35]	:= aExcecoes[nExc,40]		// 35 - 4a. Jornada Continua
							aTabTno[nPos,36]	:= aExcecoes[nExc,41]		// 36 - Codigo da Refeicao
							
							For nReg := 5 To 11 Step 2
								If ( aExcecoes[nExc,23] == "S" )
									If ( !Empty(aExcecoes[nExc,nReg]) )
										nMaxReg := nMaxReg + 2
										nNumMarc++															
									EndIf
								Else
									nReg	:= 11
									nAuxReg := 1
									nMaxReg := 2
									nNumMarc:= 2
								EndIf
							Next
						Else
							nMaxReg := nNumMarc					
					    EndIf
				
						aTabTno[nPos,18] 	:= aExcecoes[nExc,23]			// 18 - Tipo do Dia
						aTabTno[nPos,19] 	:= aExcecoes[nExc,19]	   		// 19 - Sequencia da Marcacao
						aTabTno[nPos,20] 	:= Dow( dDataApo )     			// 20 - Numero Correspondente ao Dia da Semana
						aTabTno[nPos,21] 	:= "E"							// 21 - Flag Indicador de Excecao
						aTabTno[nPos,22] 	:= aExcecoes[nExc,21]			// 22 - Motivo da Excecao
						aTabTno[nPos,23] 	:= aExcecoes[nExc,22]			// 23 - Codigo Hora Extra Normal
						aTabTno[nPos,24] 	:= aExcecoes[nExc,24]			// 24 - Codigo Hora Extra Noturna
						aTabTno[nPos,25] 	:= aExcecoes[nExc,29]			// 25 - Centro de Custo Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,26] 	:= aExcecoes[nExc,30]			// 26 - Centro de Custo Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,27] 	:= aExcecoes[nExc,31]			// 27 - Centro de Custo Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,28] 	:= aExcecoes[nExc,32]			// 28 - Centro de Custo Periodo 4 (4a.E-4a.S)		
						aTabTno[nPos,38] 	:= aExcecoes[nExc,47]			// 38 - Funcoes Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,39] 	:= aExcecoes[nExc,48]			// 39 - Funcoes Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,40] 	:= aExcecoes[nExc,49]			// 40 - Funcoes Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,41] 	:= aExcecoes[nExc,50]			// 41 - Funcoes Periodo 4 (4a.E-4a.S)				
						aTabTno[nPos,58] 	:= aExcecoes[nExc,55]			// 58 - Depto Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,59] 	:= aExcecoes[nExc,56]			// 59 - Depto Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,60] 	:= aExcecoes[nExc,57]			// 60 - Depto Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,61] 	:= aExcecoes[nExc,58]			// 61 - Depto Periodo 4 (4a.E-4a.S)
						aTabTno[nPos,62] 	:= aExcecoes[nExc,51]			// 62 - Posto Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,63] 	:= aExcecoes[nExc,52]			// 63 - Posto Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,64] 	:= aExcecoes[nExc,53]			// 64 - Posto Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,65] 	:= aExcecoes[nExc,54]			// 65 - Posto Periodo 4 (4a.E-4a.S)								

		            EndIf
            
		            If ( lExceData .or. lAllTnoOpc )  
			            cTipoDia	:= aTabTno[ nPos , 18 ]
						cSeq		:= aTabTno[ nPos , 19 ]			            
			            cMotExc		:= aTabTno[ nPos , 22 ]
			            cNonaHr		:= aTabTno[ nPos , 29 ]
						nHorMen		:= aTabTno[ nPos , 30 ]
						nHorMai		:= aTabTno[ nPos , 31 ]
			            cCodRef		:= aTabTno[ nPos , 36 ]
						cCodJor		:= aTabTno[ nPos , 70 ]
						
						nLimMarc	:= nHorMai
					Endif		    
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Para cada um registro, carrega dois elementos no array		  ³
				³Pq para cada linha do calendario fisico existe uma entrada e |
				³uma saida, tabela RF7 										  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				For nReg := 1 To nMaxReg
				
					nHrTrab	 := (cAliasRF7)->(RF7_HRTRAB)
					nHrInte	 := (cAliasRF7)->(RF7_HRINTV)
					cCcCal 	 := (cAliasRF7)->(RF7_CC )
					cFuncCal := (cAliasRF7)->(RF7_CODFUN )
					cJndCont := (cAliasRF7)->(RF7_JNDCO )
					cDepto	 := (cAliasRF7)->(RF7_DEPTO )
					cPosto	 := (cAliasRF7)->(RF7_POSTO )
									
					If AllTrim(Str(nReg)) $ "1_3_5_7"
						nHora    := (cAliasRF7)->(RF7_ENTRA)
						nLimInfE := (cAliasRF7)->(RF7_LIE  )
						nLimSupE := (cAliasRF7)->(RF7_LSE  )			
					Else
						nHora    := (cAliasRF7)->(RF7_SAIDA)
						nLimInfS := (cAliasRF7)->(RF7_LIS  )
						nLimSupS := (cAliasRF7)->(RF7_LSS  )
					EndIf

					If AllTrim(Str(nReg)) $ "1_3_5_7"
						dData    := (cAliasQry)->(RF7_DATAE)
					Else
						dData    := (cAliasQry)->(RF7_DATAS)
					EndIf
           
            		If ( lExceData .or. lAllTnoOpc )

						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Incrementa dData Quando Marcacao for do Dia Seguinte ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						IF ( aTabTno[ nPos , nReg ] <  aTabTno[ nPos , IF( nReg == 1 , nReg , nReg-1 ) ] )
							++dData
							nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nReg ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
							dDataLimE	:= __fNsToDh( nSerial , "D" )
							nLimMarc	:= __fNsToDh( nSerial , "H" )					
						EndIF		

						Do Case
							Case ( Str( nTipMarc ) $ "1" )
								cCcCal 		:= aTabTno[ nPos , 25 ] 
								cFuncCal 	:= aTabTno[ nPos , 38 ]
								cJndCont	:= aTabTno[ nPos , 32 ]
								cDepto		:= aTabTno[ nPos , 58 ]
								cPosto		:= aTabTno[ nPos , 62 ]
								IF ( nReg == 1 )
									nHora	 := aTabTno[ nPos , 01 ]
									nHrTrab  := aTabTno[ nPos , 09 ]
									nLimInfE := aTabTno[ nPos , 42 ]
									nLimSupE := aTabTno[ nPos , 43 ]
								Else
									nHora	 := aTabTno[ nPos , 02 ]
									nHrInte  := aTabTno[ nPos , 13 ]
									nLimInfS := aTabTno[ nPos , 44 ]
									nLimSupS := aTabTno[ nPos , 45 ]
								EndIF
							Case ( Str( nTipMarc ) $ "2" )
								cCcCal 		:= aTabTno[ nPos , 26 ]
								cFuncCal 	:= aTabTno[ nPos , 39 ]
								cJndCont	:= aTabTno[ nPos , 33 ]
								cDepto		:= aTabTno[ nPos , 59 ]
								cPosto		:= aTabTno[ nPos , 63 ]
								IF ( nReg == 3 )
									nHora	 := aTabTno[ nPos , 03 ]
									nHrTrab  := aTabTno[ nPos , 10 ]
									nLimInfE := aTabTno[ nPos , 46 ]
									nLimSupE := aTabTno[ nPos , 47 ]
								Else
									nHora	 := aTabTno[ nPos , 04 ]
									nHrInte  := aTabTno[ nPos , 14 ]
									nLimInfS := aTabTno[ nPos , 48 ]
									nLimSupS := aTabTno[ nPos , 49 ]
								EndIF
							Case ( Str( nTipMarc ) $ "3" )
								cCcCal 		:= aTabTno[ nPos , 27 ]
								cFuncCal 	:= aTabTno[ nPos , 40 ]
								cJndCont	:= aTabTno[ nPos , 34 ]
								cDepto		:= aTabTno[ nPos , 60 ]
								cPosto		:= aTabTno[ nPos , 64 ]
								IF ( nReg == 5 )
									nHora	 := aTabTno[ nPos , 05 ]
									nHrTrab  := aTabTno[ nPos , 11 ]
									nLimInfE := aTabTno[ nPos , 50 ]
									nLimSupE := aTabTno[ nPos , 51 ]
								Else
									nHora	 := aTabTno[ nPos , 06 ]
									nHrInte  := aTabTno[ nPos , 15 ]
									nLimInfS := aTabTno[ nPos , 52 ]
									nLimSupS := aTabTno[ nPos , 53 ]
								EndIF
							Case ( Str( nTipMarc ) $ "4" )
								cCcCal 		:= aTabTno[ nPos , 28 ]
								cFuncCal 	:= aTabTno[ nPos , 41 ]
								cJndCont	:= aTabTno[ nPos , 35 ]
								cDepto		:= aTabTno[ nPos , 61 ]
								cPosto		:= aTabTno[ nPos , 65 ]
								IF ( nReg == 7 )
									nHora	 := aTabTno[ nPos , 07 ]
									nHrTrab  := aTabTno[ nPos , 12 ]
									nLimInfE := aTabTno[ nPos , 54 ]
									nLimSupE := aTabTno[ nPos , 55 ]
								Else
									nHora	 := aTabTno[ nPos , 08 ]
									nLimInfS := aTabTno[ nPos , 56 ]
									nLimSupS := aTabTno[ nPos , 57 ]
								EndIF
						EndCase
		            EndIf
		                
					aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )		
					nCal := Len(aTabCalend)
			
					aTabCalend[	nCal,	CALEND_POS_DATA		 ] := dData														// 01 - Data
					aTabCalend[	nCal,	CALEND_POS_ORDEM	 ] := cOrdem 													// 02 - Ordem
					aTabCalend[	nCal,	CALEND_POS_HORA		 ] := nHora														// 03 - Hora			
					
					If AllTrim(Str(nReg)) $ "1_3_5_7"
						aTabCalend[	nCal, CALEND_POS_TIPO_MARC ] := AllTrim(Str(nTipMarc)+"E")								// 04 - Tipo Marc
					Else
						aTabCalend[	nCal, CALEND_POS_TIPO_MARC ] := AllTrim(Str(nTipMarc)+"S")								// 04 - Tipo Marc
						nTipMarc++
					EndIf					
					
					aTabCalend[	nCal,	CALEND_POS_NUM_MARC	 		] := nNumMarc		    								// 05 - No Marc.
					aTabCalend[	nCal,	CALEND_POS_TIPO_DIA	 		] := cTipoDia											// 06 - Tipo Dia						
					aTabCalend[	nCal,	CALEND_POS_HRS_TRABA 		] := nHrTrab											// 07 - Horas Trabalhada no Periodo							
					aTabCalend[	nCal,	CALEND_POS_SEQ_TURNO 		] := cSeq												// 08 - Sequˆncia de Turno
					aTabCalend[	nCal,	CALEND_POS_HRS_INTER 		] := nHrInte											// 09 - Horas de Intervalo			
		
					aTabCalend[	nCal,	CALEND_POS_EXCECAO			] := If( !Empty(cMotExc), "E", "" )						// 10 - Excecao ( E-Excecao, # E - nao e excecao )
					aTabCalend[	nCal,	CALEND_POS_MOT_EXECAO		] := cMotExc											// 11 - Motivo da Excecao		
					aTabCalend[	nCal,	CALEND_POS_TIPO_HE_NOR		] := cTpExt												// 12 - Tipo de hora extra normal
					aTabCalend[	nCal,	CALEND_POS_TIPO_HE_NOT		] := cTpExtN											// 13 - Tipo de hora extra noturna
					aTabCalend[	nCal,	CALEND_POS_TURNO			] := cTurno												// 14 - Turno de Trabalho
					aTabCalend[	nCal,	CALEND_POS_CC				] := cCCcal												// 15 - Centro de Custo do Periodo
					aTabCalend[	nCal,	CALEND_POS_PG_NONA_HORA		] := cNonaHr											// 16 - Pagamento de Nona Hora
					aTabCalend[	nCal,	CALEND_POS_LIM_MARCACAO		] := { dDataLimE, nLimMarc }							// 17 - Limite de Marcacao Inicial					
					aTabCalend[	nCal,	CALEND_POS_COD_REFEICAO		] := cCodRef										   	// 18 - Codigo da Refeicao
					aTabCalend[	nCal,	CALEND_POS_FERIADO			] := lFeriado											// 19 - Dia e Feriado
					aTabCalend[	nCal,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt											// 20 - Tipo de Hora Extra Feriado Normal
					aTabCalend[	nCal,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN											// 21 - Tipo de Hora Extra Feriado Noturna
					aTabCalend[	nCal,	CALEND_POS_DESC_FERIADO		] := cP3Desc											// 22 - Descricao do Feriado	
					aTabCalend[	nCal,	CALEND_POS_REGRA			] := cRegra 					   						// 23 - Regra de Apontamento
					aTabCalend[	nCal,	CALEND_POS_AFAST			] := lAfast												// 24 - Funcionario Afastado
					aTabCalend[	nCal,	CALEND_POS_TIP_AFAST		] := cTipAfast											// 25 - Tipo de Afastamento
					aTabCalend[	nCal,	CALEND_POS_INI_AFAST		] := dIniAfas 											// 26 - Data Inicial do Afastamento
					aTabCalend[	nCal,	CALEND_POS_FIM_AFAST		] := dFimAfas											// 27 - Data Final do Afastamento	
					aTabCalend[	nCal,	CALEND_POS_INI_H_NOT		] := nIniHnt 											// 28 - Inicio da Hora Noturna
					aTabCalend[	nCal,	CALEND_POS_FIM_H_NOT		] := nFimHnt 											// 29 - Final da Hora Noturna
					aTabCalend[	nCal,	CALEND_POS_MIN_H_NOT		] := nMinHnt 											// 30 - Minutos da Hora Noturna				
					aTabCalend[	nCal,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado										// 31 - Se funcionario Trabalha em Dias Feriados
					aTabCalend[	nCal,	CALEND_POS_APON_FERIAS		] := lAponFer											// 32 - Se Aponta Quando Afastamento em Ferias
					aTabCalend[	nCal,	CALEND_POS_TP_HE_NR_FER		] := cTpExNorFer										// 33 - Tipo de hora extra normal (Ferias)
					aTabCalend[	nCal,	CALEND_POS_TP_HE_NT_FER		] := cTpExNotFer										// 34 - Tipo de hora extra noturna (Ferias)
					aTabCalend[	nCal,	CALEND_POS_PAGINT			] := cPagInt											// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
					aTabCalend[ nCal,   CALEND_POS_TIPO_ORIG_DIA    ] := cTipDorig											// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos			
					aTabCalend[ nCal,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer											// 37 - Se H.Extras são autorizadas para funcionario em ferias					
					aTabCalend[ nCal,   CALEND_POS_CODFUNC 		    ] := cFuncCal											// 38 - Codigo de funcao
					aTabCalend[ nCal,   CALEND_POS_DEPTO  		    ] := cDepto												// 39 - Codigo de Depto. do funcionario
					aTabCalend[ nCal,   CALEND_POS_POSTO  		    ] := cPosto												// 40 - Codigo do Posto do funcionario
					aTabCalend[ nCal,   CALEND_POS_PERIODO 		    ] := cCodPer											// 41 - Periodo
					aTabCalend[ nCal,   CALEND_POS_ROTEIRO 		    ] := cCodRot											// 42 - Roterio
					aTabCalend[ nCal,   CALEND_POS_PROCESSO		    ] := cCodPro											// 44 - Num. de Pagamento
					aTabCalend[ nCal,   CALEND_POS_NUM_PAGTO	    ] := cNumPag											// 43 - Processo
					aTabCalend[ nCal,   CALEND_POS_JORN			    ] := cCodJor											// 45 - Cod. da Jornada
					aTabCalend[ nCal,   CALEND_POS_P2ID				] := cIdExce 				   							// 46 - Lote da excecao
					aTabCalend[ nCal,   CALEND_POS_R8ID				] := cIdAfas											// 47 - Identificacao afastamento
					aTabCalend[ nCal,   CALEND_POS_DATA_APO			] := dDataApo											// 48 - Data de apontamento					
					aTabCalend[ nCal,   CALEND_POS_JND_CON			] := cJndCont											// 49 - Jornada continua						
					aTabCalend[ nCal,   CALEND_POS_LIE				] := nLimInfE 											// 50 - Limite inferior da entrada
					aTabCalend[ nCal,   CALEND_POS_LSE				] := nLimSupE											// 51 - Limite superior da entrada
					aTabCalend[ nCal,   CALEND_POS_LIS				] := nLimInfS											// 52 - Limite inferior da saida
					aTabCalend[ nCal,   CALEND_POS_LSS				] := nLimSupS 											// 53 - Limite inferior da saida
					aTabCalend[ nCal,   CALEND_POS_TPEXCE			] := cTpExce											// 54 - Tipo de Excecao "F" - Funcionario / "P" - Periodo
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Zera o limite, pois so vai inserir no primeiro registro e no ³
					³ultimo registro da ordem existente no calendario			  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nLimMarc  := 0
					dDataLimS := (cAliasRF7)->(RF7_DATAS)
					dDataLimE := Ctod("//")				
					
					//-- Se Entrada
					If AllTrim(Str(nReg)) $ "1_3_5_7"
						dDataLimE := Ctod("//") 	
					Else//-- Se Saida
						If ( lExceData .or. lAllTnoOpc )
							nSerial		:= ( __fDhToNS( aTabCalend[ nCal , CALEND_POS_DATA ] , aTabCalend[ nCal , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31 ]) )
							dDataLimS	:= __fNsToDh( nSerial , "D" )
							nHorMai  	:= __fNsToDh( nSerial , "H" )
						Else
							dDataLimS := (cAliasQry)->(RF7_DATAS)				
						EndIF				
					Endif

				Next

				cIdExce	  := ""
				cTpExce	  := ""
				cMotExc	  := ""
		
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Grava as alteracoes do calendario em funcao da troca de hor. ³
				³pelo turno opcional										  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/		
				If lAllTnoOpc
					GravaTnoOpc( nCal, (cAliasRF6)->(Recno()), (cAliasRF7)->(Recno()), If( nReg == 1, 1, 2), aTabCalend )
				EndIf		    						    							    					
				
				cIdExce	  := ""
				cTpExce	  := ""
				cMotExc	  := ""
		    
		    EndDo    
		    
		    (cAliasRF7)->(dbSkip())
		    (cAliasRF6)->(dbSkip())
			
		EndDo
			
		If !Empty(aTabCalend)
			aTabCalend[ Len(aTabCalend), CALEND_POS_LIM_MARCACAO ] := { dDataLimS, nHorMai }
			lRet := .T.	
		EndIf		
		
	Else
		lRet := .F.	
	EndIf
	
#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Array aTabCalend carregado 								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lRet
	nRet := 1
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Sincroniza horarios iniciais da tabela para evitar intervalos³
	³entre os limites inicial do dia corrente e final do dia  ante³
	³rior.														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lSncMaMe )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aDataApo	,;	//03 -> Array com as Datas de Apontamento do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					cMat   		,;	//09 -> Matricula do Funcionario
					cCC   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					.T.			 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
		   		   )
	EndIf
	
EndIf
              
#IFDEF TOP                           
	(cAliasQry)->(DbCloseArea())
#ENDIF         

RestArea(aArea)

Return ( nRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GravaTnoOpc	  ³ Autor ³ Igor Franzoi	  ³ Data ³26/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Grava os elementos alterados no aTabCalend pelo turno 		³
³		   ³opcional													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GravaTnoOpc( nPos, nRecnoRf6, RecnoRf7, nTip, aTabCalend )

Local cAliasRf6   := "RF6"
Local cAliasRf7	  := "RF7"

If nTip == 1

	(cAliasRf6)->(dbGoTo(nRecnoRf6))
	Reclock( "RF6", .T., .F. )
		(cAliasRf6)->( "RF6_CHKTNO" ) := "S"
	(cAliasRf6)->( MsUnlock() )
	
	(cAliasRf7)->(dbGoto(nRecnoRf7))
	RecLock( "RF7", .T., .F. )
				
				(cAliasRf7)->( "RF7_ENTRA" ) := aTabCalend[ nPos,   CALEND_POS_HORA]
				(cAliasRf7)->( "RF7_LIE" ) := aTabCalend[ nPos,   CALEND_POS_LIE ] 
				(cAliasRf7)->( "RF7_LSE" ) := aTabCalend[ nPos,   CALEND_POS_LSE ] 
				
	(cAliasRf7)->( MsUnlock() )
Else

	RF6->(dbGoTo(nRecnoRf6))
	Reclock( "RF6", .T., .F. )
		(cAliasRf6)->( "RF6_CHKTNO" ) := "S"				
	(cAliasRf6)->( MsUnlock() )
	
	RF7->(dbGoto(nRecnoRf7))
	RecLock( "RF7", .T., .F. )
				
				(cAliasRf7)->( "RF7_SAIDA" ) := aTabCalend[ nPos,   CALEND_POS_HORA]
				(cAliasRf7)->( "RF7_LIS" ) := aTabCalend[ nPos,   CALEND_POS_LIS ] 
				(cAliasRf7)->( "RF7_LSS" ) := aTabCalend[ nPos,   CALEND_POS_LSS ] 	
				
	(cAliasRf7)->( MsUnlock() )

EndIf

Return ( NIL )
                             
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CalendVirtual ³ Autor ³ Marinaldo de Jesus³ Data ³15/12/2003³
³          ³			  ³ Ver.02| Igor Franzoi	  ³ Data ³23/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cria Calendario Virtual.                                    ³
³          ³Alimenta  um Array com o Calend rio de um Per¡odo.          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CalendVirtual(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
						lTabCalen	;  //16 -> Nao zerar o array aTabCalend - Calendario Complementar						
					)

Local lCriaCalOk	:= .T.
Local lNewCalend	:= .F.
Local lChkMat		:= ( cMat <> NIL )
Local lAcumulado	:= .F.
Local aTipo
Local dDataAux                                       
Local dPerIni
Local dPerFim
Local dPerAuxIni
Local dPerAuxFim
Local dIniCalend
Local dFimCalend
Local bQualSeq
Local nPosTrcT
Local nLoop
Local nLoops
Local lError	:= ( Type("oCalendError") <> "U" )

DEFAULT lSncMaMe	:= .F.
DEFAULT lForceNew	:= .T.
DEFAULT aMarcacoes	:= {}
DEFAULT __lChkTnoOpc	:= IF( ( ( SR6->(FIELDPOS( "R6_TNOOPC" )) != 0) .and.  ( SuperGetMv("MV_TNOOPC",NIL,"N") == "S" ) ) ,.T. , .F. )   // ATENCAO ALTERAR ESSA LINHA ANTES de SUBIR
DEFAULT lPnmTab01		:= ExistBlock( "PNMTAB01" )
DEFAULT lTabCalen	:= .T.

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Garanto que dDataFim nunca sera menor que dDataIni          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( dDataFim < dDataIni )
		dDataAux := dDataIni
		dDataIni := dDataFim
		dDataFim := dDataAux	
	EndIF
   
   	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se Devera Criar Novo Calendario                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lChkMat ) .and. ( lForceNew ) )
		IF ( ( __dPerCalIni == NIL ) .or. ( __dPerCalFim == NIL ) )
			If Type("oPeriodo") == "U"
				SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
				oPeriodo:cProcesso := SRA->RA_PROCES
				oPeriodo:GetPer()
				IF !( lCriaCalOk := oPeriodo:lFound)
					If lError
						oCalendError:SendError('04',Nil, .T.)
					EndIf
					Break
				EndIF
			Endif	
			__dPerCalIni := oPeriodo:dDataIni
			__dPerCalFim := oPeriodo:dDataFim
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Garanto que __dPerCalFim nunca sera menor que __dPerCalIni  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( __dPerCalFim < __dPerCalIni )
				dDataAux 		:= __dPerCalIni
				__dPerCalIni	:= __dPerCalFim
				__dPerCalFim	:= dDataAux	
			EndIF
		EndIF	
		dPerIni := __dPerCalIni
		dPerFim := __dPerCalFim
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Forca a Criacao de um novo Calendario sempre que o   Periodo³
		³ for Diferente do Periodo Atual para que Busquemos o Turno	 e³
		³ a Sequencia Referentes a Data Inicial de Geracao do  Calenda³
		³ rio														  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lNewCalend := ( dDataIni <> dPerIni )	
	Else
		dPerIni := dDataIni
		dPerFim := dDataFim
	EndIF
   
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Para Periodos Anteriores Criar novo Calendario apenas Quando³
	³ nao Existir Troca de Turno para o Inicio do Periodo         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lChkMat ) .and. ( lForceNew ) )
		IF !( lNewCalend ) 
			IF ( dDataFim < dPerIni )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Remonta o Calendario Apenas se Nao Existir Troca de Turno pa³
				³ ra o Primeiro dia da Montagem do Calendario                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				fTrocaTno( Min( dPerIni , dDataIni ) , Max( dPerFim , dDataFim ) , @aTurnos , NIL , NIL , .F. )
				IF ( lNewCalend := ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) == 0 ) )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Para Periodos Anteriores Criar novo Calendario apenas Quando³
					³ nao Existir Troca de Turno para o Inicio do Periodo         ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF ( Len( aTurnos ) > 0 )
						dPerIni	:= aTurnos[ 01 , 02 ]
						dPerFim := ( dPerIni + ( ( dDataFim - dDataIni ) + 1 ) )
						cTno	:= aTurnos[ 01 , 01 ]
						cSeq	:= aTurnos[ 01 , 03 ]
					EndIF
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se Tiver Troca de Turno, os Turnos e Sequencias Serao  Retor³
					³ nados pelo Proprio Calendario                               ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					dPerIni := dDataIni
					dPerFim := dDataFim
					cTno	:= aTurnos[ nPosTrcT , 01 ]
					cSeq	:= aTurnos[ nPosTrcT , 03 ]
				EndIF
			EndIF	
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Remonta o Calendario Apenas se Nao Existir Troca de Turno pa³
			³ ra o Primeiro dia da Montagem do Calendario                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			fTrocaTno( Min( dPerIni , dDataIni ) , Max( dPerFim , dDataFim ) , @aTurnos , NIL , NIL , .F. )
			IF !( lNewCalend := ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) == 0 ) )
				dPerIni	:= dDataIni
				dPerFim	:= dDataFim
				cTno	:= aTurnos[ nPosTrcT , 01 ]
				cSeq	:= aTurnos[ nPosTrcT , 03 ]
			EndIF
		EndIF
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica a Data para a Montagem do 1o Calendario			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lNewCalend )
		IF ( dDataIni > dPerFim )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inicio do Periodo Solicitado Posterior ao Periodo em Aberto ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( aScan( aTurnos , { |x| x[2] > dPerFim .and. x[2] <= dDataFim } ) > 0 )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se Houver Troca de Turno, considera a Menor e a Maior   Data³
				³ para a Montagem do Calendario para que sejam Consideradas as³
				³ Trocas de Turno											  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				dIniCalend	:= Min( dPerIni , dDataIni )
				dFimCalend	:= Max( dPerFim , dDataFim )
			Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Caso Contrario o Turno e a Sequencia serao retornados   pela³
				³ fQualSeq()												  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				dIniCalend	:= dPerIni
				dFimCalend	:= dPerFim
			EndIF
		ElseIF ( dDataFim < dPerIni )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Final do Periodo Solicitado Anterior ao Periodo em Aberto   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			dIniCalend	:= dPerIni
			dFimCalend	:= dPerFim
		ElseIF ( dDataIni <> dPerIni )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Periodo Solicitado Diferente do Periodo em Aberto			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			dIniCalend	:= Min( dPerIni , dDataIni )
			dFimCalend	:= Max( dPerFim , dDataFim )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se Nao Tiver Troca de Turno no Inicio do Periodo para a Gera³
			³ cao do Primeiro Calendario, Verifica o Periodo Anterior	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( aScan( aTurnos , { |x| x[2] == dIniCalend } ) == 0 )
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Localiza o periodo o qual a data inicial compreende		  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				oPeriodo:dDataIni := dPerIni   
			
			   	/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Cria o Calendario do Periodo Anterior                       ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				dPerAuxIni := oPeriodo:dDataIni
				dPerAuxFim := oPeriodo:dDataFim 

				IF !( lCriaCalOk := PerAponta( @dPerAuxIni , @dPerAuxFim , ( dPerIni - 1 ) , .F. , cFil , .T. , NIL , .F. , .T. ) )
					Break
				EndIF
		
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega as Trocas de Turno a Partir do Inicio do Periodo  An³
				³ Terior													  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				fTrocaTno( dPerAuxIni , dFimCalend , @aTurnos , NIL , NIL , .F. )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Busca a Primeira Troca inferior ao Periodo para a Geracao do³
				³ Calendario          										  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] <= dIniCalend } ) ) > 0 )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Busca a Troca mais Proxima                                  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nLoops := ( nPosTrcT + 1 )
					While ( ( nLoops := aScan( aTurnos , { |x| x[2] <= dIniCalend } , nLoops ) ) > 0 )
						nPosTrcT := nLoops
						++nLoops
					End While
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Adiciona a Troca de Turno para o Inicio do Periodo para a Ge³
					³ racao do Calendario										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF ( nPosTrcT > 0 )
						aAdd( aTurnos , aClone( aTurnos[ nPosTrcT ] ) )
						aTurnos[ Len( aTurnos ) , 02 ] := dIniCalend
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Ordena as Trocas por Ordem de Data						  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						aSort( @aTurnos , NIL , NIL , { |x,y| ( x[2] < y[2] ) } )
					EndIF
				EndIF
			EndIF
		EndIF
	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Neste Caso o Periodo Solicitado eh Equivalente ao Periodo em³
		³ Aberto													  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		dIniCalend	:= dPerIni
		dFimCalend	:= dPerFim
	EndIF     	
    
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica Se Calendario e do Periodo Anterior			  	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    lAcumulado := ( dFimCalend < dPerIni )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria o Calendario do Periodo Atual       				  	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lCriaCalOk := CalendCria(	dIniCalend								,; //01 -> Data Inicial do Periodo
		 		  					dFimCalend								,; //02 -> Data Final do Periodo
				  					cTno									,; //03 -> Turno Para a Montagem do Calendario
				  					cSeq									,; //04 -> Sequencia Inicial para a Montagem Calendario
					  				@aTabPadrao								,; //05 -> Array Tabela de Horario Padrao
					  				@aTabCalend								,; //06 -> Array com o Calendario de Marcacoes
					  				cFil									,; //07 -> Filial para a Montagem da Tabela de Horario
					  				cMat									,; //08 -> Matricula para a Montagem da Tabela de Horario
					  				cCc										,; //09 -> Centro de Custo para a Montagem da Tabela
				  					@aTurnos								,; //10 -> Array com as Trocas de Turno
				  					@aExcePer								,; //11 -> Array com Todas as Excecoes do Periodo
				  					lExecQryTop 							,; //12 -> Se executa Query para a Montagem da Tabela Padrao
				  					( ( lSncMaMe ) .and. !( lNewCalend ) )	,; //13 -> Se executa a funcao se sincronismo do calendario
				  					lAcumulado								,; //14 -> Se o Calendario eh do periodo anterior
				  					aMarcacoes								,; //15 -> Array de Marcacoes para tratamento de Turnos Opcionais
									lTabCalen								 ; //16 -> Nao zerar o array aTabCalend - Calendario Complementar
					  			);
		 )				  			
		Break
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se nao for Criar novo Calendario, Abandona				  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lNewCalend )
		Break
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem o Turno para o Novo Calendario       			  	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cTno	:= GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"				,;	//02 -> Flag da Marcacao "1E,1S,..."
								dDataIni			,;	//03 -> Data em aTabCalend
								aTabCalend			 ;	//04 -> Calendario de Marcacoes
				   		 	)
	IF Empty( cTno )
		IF ( dDataFim < dPerIni )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Pode Ocorrer Turno em Branco para Periodo Anterior		  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
									"1E"				,;	//02 -> Flag da Marcacao "1E,1S,..."
									dIniCalend			,;	//03 -> Data em aTabCalend
									aTabCalend			 ;	//04 -> Calendario de Marcacoes
					   		 	 )
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ou Quando a Existe Jornada Continua e a Data Inicial nao cor³
			³ responte ao Inicio da Jornada								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aTipo	:= { "1E" , "1S" , "2E" , "2S" , "3E" , "3S" , "4E" , "4S" }
			nLoops	:= Len( aTipo )
			For nLoop := 2 To nLoops
				cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
										aTipo[ nLoop ]		,;	//02 -> Flag da Marcacao "1E,1S,..."
										dDataIni			,;	//03 -> Data em aTabCalend
										aTabCalend			 ;	//04 -> Calendario de Marcacoes
					 	 			  )
				IF !Empty( cTno )
					Exit
				EndIF
			Next nLoop
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se ainda assim nao achou o turno, procura a Partir do  Perio³
			³ do Final do Periodo em Aberto                               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF Empty( cTno )
				dPerIni := ( dPerFim - 1 )
				While ( Empty( cTno ) .and. ( ( ++dPerIni ) < dDataFim ) )
					For nLoop := 1 To nLoops
						cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
												aTipo[ nLoop ]		,;	//02 -> Flag da Marcacao "1E,1S,..."
												dPerIni				,;	//03 -> Data em aTabCalend
												aTabCalend			 ;	//04 -> Calendario de Marcacoes
							 	 			  )
						IF !Empty( cTno )
							Exit
						EndIF
					Next nLoop
				End While
			EndIF
		EndIF
	EndIF					   		 	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem a Sequencia para o Novo Calendario       			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cSeq	:= GetInfoPosTab(	CALEND_POS_SEQ_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"					,;	//02 -> Flag da Marcacao "1E,1S,..."
								dDataIni				,;	//03 -> Data em aTabCalend
								aTabCalend				 ;	//04 -> Calendario de Marcacoes
				   		 	)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Retorna a Sequencia do Proximo Periodo 					  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bQualSeq	:= { || IF( Empty( cSeq ) , fQualSeq( aClone( aTabCalend ) , @aTabPadrao , dDataIni , cTno ) , cSeq ) }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria o Calendario do Periodo Selecionado					  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lCriaCalOk := CalendCria(	dDataIni			,; //01 -> Data Inicial do Periodo
		 		  					dDataFim			,; //02 -> Data Final do Periodo
					  				cTno				,; //03 -> Turno Para a Montagem do Calendario
					  				Eval( bQualSeq )	,; //04 -> Sequencia Inicial para a Montagem Calendario
					  				@aTabPadrao			,; //05 -> Array Tabela de Horario Padrao
					  				@aTabCalend			,; //06 -> Array com o Calendario de Marcacoes
					  				cFil				,; //07 -> Filial para a Montagem da Tabela de Horario
				  					cMat				,; //08 -> Matricula para a Montagem da Tabela de Horario
				  					cCc					,; //09 -> Centro de Custo para a Montagem da Tabela
				  					@aTurnos			,; //10 -> Array com as Trocas de Turno
					  				@aExcePer			,; //11 -> Array com Todas as Excecoes do Periodo
					  				lExecQryTop 		,; //12 -> Se executa Query para a Montagem da Tabela Padrao
					  				lSncMaMe			,; //13 -> Se executa a funcao se sincronismo do calendario
					  				,;
					  				,;
									lTabCalen	;  //16 -> Nao zerar o array aTabCalend - Calendario Complementar
					  			);
		 )				  			
		Break
	EndIF			  			
	
End Sequence

Return( lCriaCalOk )



/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstCriaCalend	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em CriaCalend()        	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstCriaCalend()

__dPerCalIni	:= NIL
__dPerCalFim	:= NIL  
__aProcesso		:= NIL 
__cProcesso		:= NIL
__nPosProcesso	:= NIL
__lPGenerico	:= NIL
__nOrdIni       := NIL

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetExcID 	  ³ Autor ³ Igor Franzoi	  ³ Data ³26/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna os campos da excecao conforme o ID passado			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function RetExcId( cFil, cIdExce, dData, cRegra, aAllExc, aExcecoes )

Local lRet
Local nPos
Local cKey  := cFil+cIdExce

Local nRecno
Local cAlias := "SP2"
Local nOrder := RetOrdem( "SP2" , "P2_FILIAL+P2_ID" )

Local aArea := GetArea()

DEFAULT dData 	  := Ctod("//")
DEFAULT aExcecoes := {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica se a excecao ja se encontra no array				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If ( ( nPos := aScan( aAllExc, { |X| X[57] == cIdExce  } ) ) != 0 )
	fAddExce( @aExcecoes , .T. , @aAllExc , nPos , dData , cRegra , nRecno )
	lRet := .T.
Else
	dbSelectArea(cAlias)
	dbSetOrder(nOrder)
	(cAlias)->( dbSeek(cKey) )
	If Found()
		nRecno := (cAlias)->( Recno() )
		fAddExce( @aExcecoes , .F. , @aAllExc , nPos , dData , cRegra , nRecno )
		lRet := .T.
	Else
		lRet := .F.	
	EndIf
EndIf

RestArea( aArea )

Return lRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CalendCria³Autores   ³                      ³    ³          ³
³          ³          ³Versao I  ³Equipe Advanced RH    ³Data³24/11/1997³
³          ³          ³Versao II ³Marinaldo de Jesus    ³Data³18/09/2003³
³          ³          ³Versao III³Igor Franzoi			³Data³23/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Alimenta um Array com o Calend rio de um Per¡odo.           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CalendCria(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lAcumulado	,; //14 -> Se o Calendario eh do Periodo anterior 
						aMarcacoes  ,; //15 -> Array de marcacoes para tratamento de Turnos Opcionais
						lTabCalen	;  //16 -> Nao zerar o array aTabCalend - Calendario Complementar						
					)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aMarcId	 		:= { NIL , NIL }
Local aTipo				:= { "1E" , "1S" , "2E" , "2S" , "3E" , "3S" , "4E" , "4S" }
Local aDataApo			:= {}
Local cOrdem			:= ""
Local dDataApo			:= Ctod("")
Local lCriaCalOk		:= .T.
Local lForceSinc		:= .F.
Local lExistTrcTno 		:= .F.
Local lBldNewOrd		:= .F. 
Local lPerAcum			:= .F.
Local nDias				:= 0 
Local nSeq				:= 0
Local nFornY			:= Len( aTipo )
Local nOrdem			:= 0                                          

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas para Turnos Opcionais	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/     
Local aDiaTurnoOK
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/     
Local aSr6Info
Local aSr6Cpo
Local aSpaInfo
Local aExcecoes
Local aTabTno
Local aTabOrig
Local aAfasta   
Local aTransf

Local bAsc

Local cReg
Local cCcCal
Local cDepto
Local cPosto
Local cFilSP3
Local cFilSRA
Local cFilSPJ
Local cFilSR6
Local cFilSPA
Local cIdAfas
Local cIdExce
Local cTpExce
Local cTnoOpc
Local cPagInt
Local cKeyAtu
Local cNewTno
Local cNewReg
Local cCodPer	:= ""
Local cCodRot	:= ""
Local cCodPro	:= ""
Local cNumPag	:= ""
Local cCodJor
Local cRegOrig
Local cTipoDia
Local cTipAfas 
Local cFuncCal
Local cJndCont
Local cTpExNorFer
Local cTpExNotFer

Local dData
Local dIniAfas
Local dFimAfas

Local lExce
Local lExceData
Local lJndC
Local lFeriado
Local lIncrementa	:= .F.  //Incremento do dia de apontamento para jornada continua
Local lChkMat
Local lChkCc
Local lAfastper
Local lAfast
Local lAponFer
Local lTrbFeriado 
Local lHeAutoFer
Local lTrocaTno  
Local lTnoOpcData
Local lTnoSubstituto
Local lAllTnoOpc
Local lBldCalTnoSeq
Local lNewTno
Local lNewReg

Local nX
Local nY  
Local nPos
Local nPos1
Local nPos2
Local nTno
Local nFornX
Local nLenCalend
Local nPosDataApo
Local nSerial
Local nIniHnot
Local nFimHnot
Local nMinHNot	 
Local nHrTrab
Local nHrInte
Local nLimInfE 
Local nLimSupE 
Local nLimInfS
Local nLimSupS  
Local nLenRecria := 0

Local lError	:= ( Type("oCalendError") <> "U" )

DEFAULT cTno			:= IF( Type( "SRA->RA_TNOTRAB" ) != "U" , SRA->RA_TNOTRAB	,  "" )
DEFAULT cSeq			:= IF( Type( "SRA->RA_SEQTURN" ) != "U" , SRA->RA_SEQTURN	,  "" )
DEFAULT aTabPadrao		:= {}
DEFAULT cFil			:= IF( Type( "SRA->RA_FILIAL" ) != "U" , SRA->RA_FILIAL		,  "" )
DEFAULT lSncMaMe		:= .F.
DEFAULT lAcumulado		:= .F. 
DEFAULT aMarcacoes		:= {}
DEFAULT lTabCalen		:= .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem as Informacoes em Cache do Turno de Trabalho          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aSr6Cpo := {;
		"R6_INIHNOT"	,;	//01
		"R6_FIMHNOT"	,;	//02
		"R6_MINHNOT"	,;	//03
		"R6_APODFER"	,;	//04
		"R6_TPEXFER"	,;	//05
		"R6_TPEXFEN"	,;	//06
		"R6_AUTOHEF"	,;	//07
		"R6_TNOOPC"  	;	//08
}

aLogErr030 	:= If ( Type("aLogErr030") == "U" , aLogErr030 := {}, aLogErr030 )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Pesquisa das Excecoes                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSRA := cFil

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Pesquisa dos Feriados                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSP3	:= xFilial( "SP3" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Montagem do Calendario                ³
³ Case o parametro lUseSPJ = .T. utiliza filial do SPJ, senao ³
³ utiliza a tabela de horario RF2							  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If ( lUseSPJ )
	cFilSPJ := xFilial( "SPJ" , cFil )
Else
	cFilSpj := xFilial( "RF2" , cFil )
EndIf
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial do SR6                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSR6 := xFilial( "SR6" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial do SPA                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSPA	:= xFilial( "SPA" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica se Passou Centro de Custo e Matricula              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lChkMat := !( cMat == NIL )
lChkCc	:= !( cCc  == NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se passou a Matricula Carrega as Trocas de Tuno do Periodo  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lChkMat )
	IF Empty( aTurnos )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Trocas de Turno/Regra do Periodo				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		DEFAULT aTurnos := {}
		//Se for para desconsiderar o limite superior, verifica se existe troca de turno do dia posterior ao ultimo do periodo para montagem do limite superior do ultimo dia
		If lMVLimSup
			lTrocaTno := fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
		Else
			lTrocaTno := fTrocaTno( dDataIni , dDataFim+1 , @aTurnos , NIL , cSeq )
		EndIf
	Else
		lTrocaTno := .T.
	EndIF
	//Verifica se for MENOR ou igual, não existindo assume SRA
	IF ( ( nPos := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) > 0 )
		cTno 	:= aTurnos[ nPos , 01 ]
		cSeq	:= aTurnos[ nPos , 03 ]
		cReg 	:= aTurnos[ nPos , 05 ]
	Else
		aSort( @aTurnos , NIL , NIL , { |x,y| ( x[2] > y[2] ) } )
		If ( ( nPos := aScan( aTurnos , { |x| x[2] < dDataIni } ) ) > 0 )
			cTno 	:= aTurnos[ nPos , 01 ]
			cSeq	:= aTurnos[ nPos , 03 ]
			cReg 	:= aTurnos[ nPos , 05 ]
		Else
			cReg	:= SRA->RA_REGRA
		EndIf
		aSort( @aTurnos , NIL , NIL , { |x,y| ( x[2] < y[2] ) } )
	EndIF	
Else
	cReg	:= IF( Type( "SRA->RA_REGRA" ) != "U" , SRA->RA_REGRA , cReg )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Salva Turno, Sequencia e Regra Iniciais                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cNewTno	:= cTno
cNewReg	:= cReg

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica qual a sequencia correta para o Periodo enviado    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
fFindSeq( 	@cSeq			,; 
			@aTabPadrao		,; 
			@cFilSPJ		,; 
			cNewTno			,; 
			lExecQryTop		,; 
			aTurnos			,; 
			SRA->RA_ADMISSA	,; 
			dDataIni		,; 
			dDataFim		,;
			cMat	 )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Sequencia Inicial do Turno                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nSeq := Val( cSeq )

#IFDEF TOP
	IF !( lExInAs400 )
		aExcePer := {}
		IF ( lExce := ( lChkCc .and. lChkMat ) )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Todas as Excecoes do Periodo Quando o RDD for TOP   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lExce := GetExceTop( cFilSRA , cMat , cCc , aTurnos , dDataIni , dDataFim , @aExcePer )
		EndIF
	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Neste Caso o Array aExcePer foi Passado como Parametro      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lExce := ( lChkCc .and. lChkMat ) )
			lExce := !( ( ValType( aExcePer ) == "A" ) .and. Empty( aExceper ) )
		EndIF
	EndIF
#ELSE
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Neste Caso o Array aExcePer foi Passado como Parametro      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lExce := ( lChkCc .and. lChkMat ) )
		lExce := !( ( ValType( aExcePer ) == "A" ) .and. Empty( aExceper ) )
	EndIF	
#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega os Afastamentos Referente ao Periodo                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lAfastper := ( lChkMat ) )
	lAfastper := fAfastaPer( @aAfasta , dDataIni , dDataFim , cFilSRA , cMat )
EndIF	

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta a Chave Atual                                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	DEFAULT cNewReg := "__cNewReg__" 
	cKeyAtu := ( FWCODEMP("RCH") + cFilAnt + Dtos( dDataIni ) + Dtos( dDataFim ) + cNewTno + cSeq + cNewReg + AllToChar( lSncMaMe ) )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se Houve alteracao ou se o Calendario para o  Turno³
	³ esta vazio e Recria										  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
	IF ( lBldCalTnoSeq := ( !( cKeyAtu == __cKeyBldCal ) .or. Empty( __aLstTabCal ) ) )
		If lTabCalen
			aTabCalend		:= {}	
			aTabTno			:= {}
			__aLstTabCal	:= {}
			__aLstTabTno	:= {}
			__cKeyBldCal	:= cKeyAtu
		EndIf
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta o Calendario de Marcacoes padrao para o   Turno/Sequen³
		³ cia Corrente												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !( lCriaCalOk := BldCalTnoSeq(	dDataIni		,;	//01 -> Data Inicial do Periodo
											dDataFim		,;	//02 -> Data Final do Periodo
											aTipo			,;	//03 -> Tipos de Marcacoes Possiveis
											cNewTno			,;	//04 -> Turno Para a Montagem do Calendario
											cSeq			,;	//05 -> Sequencia Inicial para a Montagem Calendario
											cNewReg			,;	//06 -> Regra do Funcionario
											@aTabPadrao		,;	//07 -> Array Tabela de Horario Padrao
											@aTabCalend		,;	//08 -> Array com o Calendario de Marcacoes
											@aTabTno		,;	//09 -> Tabela do Turno Corrente
											cFil			,;	//10 -> Filial para a Montagem da Tabela de Horario
											lExecQryTop 	,;	//11 -> Se executa Query para a Montagem da Tabela Padrao
											lSncMaMe		,;	//12 -> Se executa a funcao se sincronismo do calendario 
											lTabCalen		 ;  //13 -> Nao zerar o array aTabCalend - Calendario Complementar	
										);
			)							 	
			Break
		EndIF
		__aLstTabCal	:= aClone( aTabCalend )
		__aLstTabTno	:= aClone( aTabTno )
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa o Array aTabCalend ( Calendario das Marcacoes )  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aTabCalend := aClone( __aLstTabCal )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega Informacoes Especificas do Funcionario              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lChkMat )
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Transfere informacoes necessarias para gravacao do calendario³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/   
		aTransf := {}

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carregar as Transferencias do Funcionario				       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/		    
		fLoadTransf(aTransf)
	
		fFilIdTabela( aTabCalend,, aTransf )
									 
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega a Tabela do Turno Corrente				  		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aTabTno := aClone( __aLstTabTno )    
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem todos os Turnos Opcionais			                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
		lAllTnoOpc := .F.
		If __lChkTnoOpc
			If lTrocaTno                     
				For nTno:= 1 To Len(aTurnos)               
					//-- Carrega todos os horarios opcionais do turno
			    	If LoadTnoOpc(cFilSPJ, aTurnos[nTno, 1],__aAllTnoOpc, @aTabPadrao, aSr6Cpo, aSr6Info )
			    	   lAllTnoOpc := .T.
			    	Endif   
			    Next
			Else
				//-- Carrega todos os horarios opcionais do turno
			    If LoadTnoOpc(cFilSPJ, cNewTno,__aAllTnoOpc, @aTabPadrao, aSr6Cpo, aSr6Info )
		    	   lAllTnoOpc := .T.
		    	Endif   
			Endif  
        Endif
        
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Marcacoes do Funcionario para Ajustar os Turnos  ³
		³ em funcao da existencia de turnos opcionais				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	        
		If lAllTnoOpc 
			If Empty(aMarcacoes) 
				GetMarcOpc(	@aMarcacoes						,;	//01 -> Marcacoes dos Funcionarios
							dDataIni - 7					,;	//02 -> Periodo Inicial
							dDataFim + 7					,;	//03 -> Periodo Final
							cFil							,;	//04 -> Filial
							cMat							,;	//05 -> Matricula
							cTno							,;	//06 -> Turno
							cSeq							,;	//07 -> Sequencia de Turno
							cCc								,;	//08 -> Centro de Custo 
							If(lAcumulado, "SPG", "SP8")     ; //09 -> Obtem as marcacoes do Alias conforme o periodo considerado.
						  )         
			Endif  		  
	    Endif    

	    /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Loop For/Next para a Carga das Marcacoes do Periodo         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aDiaTurnoOk:= {}
		nFornX := ( dDataFim - dDataIni )

		//Caso ja exista dias do periodo gravados no calendario, inicia ordem a partir do ultimo registro existente.
		If !( __nOrdIni == NIL )
			nOrdem := __nOrdIni
		EndIf
		
		For nX := 0 To nFornX
		
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Data a ser verificada										  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			dData := ( dDataIni + nX )
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Salva a Data de Apontamento								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
			dDataApo	:= dData
		
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ A Sequencia eh incrementada a Cada Segunda Feira			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( ( nX != 0 ) .and. ( Dow( dData ) == 2 ) )
				nSeq++
			EndIF 
			
			IF ( lIncrementa ) 
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se a Sequˆncia atual est  cadastrada na Tabela. Pes³
				³ quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   De³
				³ pois com StrZero( n , 2 ) "00"						      ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
				nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Para Jornada Continua corre todas as datas para que seja    ³
				³ verificada se alguma segunda-feira ocorre durante a jornada ³
				³ e, assim, incrementarmos a sequencia.						  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			    If nDias > 0
			      --nDias 
			      Loop
			    Endif   
			    lIncrementa := .F.
			EndIF 
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ordem da Marcacao     									  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nOrdem++
			cOrdem		:= StrZero( nOrdem , Max( __nTamP8Ordem , Len( AllTrim( Str( nOrdem ) ) ) ) )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Procura a Data de Apontamento no Calendario Generico					  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (; 
					(;
						nPosDataApo := aScan( __aLstTabCal , { |x|;
																( x[ CALEND_POS_DATA_APO ] == dDataApo ) ;
														    };
							     		  );
					) == 0 ;
				)
				Loop
			EndIF													     		  

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se houver Sincronismo, adiciona a Data de Apontamento  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lSncMaMe )
				aAdd( aDataApo, dDataApo)
			EndIF	

			//-- Prepara tabela de verificacao de turnos
			If lAllTnoOpc
				AADD(aDiaTurnoOK, {dData, SPACE(1) })
			Endif

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Pesquisa as Trocas de Turno/Sequencia/Regra Durante o  Perio³
			³ do														  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					( lTrocaTno );
					.and.;                                       
					( dDataIni != dData );
					.and.;
					( ( nPos := aScan( aTurnos , { |x| x[2] == dData } ) ) > 0 );
				)	
				lExistTrcTno	:= .T.
				cNewTno 		:= aTurnos[ nPos , 01 ]
				cSeq	 		:= aTurnos[ nPos , 03 ]
				cNewReg 		:= aTurnos[ nPos , 05 ]
				nSeq			:= Val( cSeq )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega a Tabela Para o Novo Turno de Acordo com as Trocas  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				fTabPadrao( @aTabPadrao , @cFilSPJ , cNewTno , lExecQryTop )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Pesquisa e Carrega a Tabela do Turno Corrente				  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lCriaCalOk := ( nPos := aScan( aTabPadrao, { |x| x[2] == cNewTno .and. ( x[1] == cFilSPJ .or. Empty( x[1] ) ) } ) ) > 0 )
					aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
				Else
					Break
				EndIF
			EndIF
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se a Sequˆncia atual est  cadastrada na Tabela. Pes³
			³ quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   De³
			³ pois com StrZero( n , 2 ) "00"						      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica se o Dia da Semana da Sequencia e equivalente ao Dia³
			³da Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  com³
			³o StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
						  .and. x[20] == Dow(dData);
					 }
			IF !( lCriaCalOk := ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
				If lError
					oCalendError:SendError('01',Dtoc(dData), .T.)		//Nao foi encontrado sequencia para a data XX/XX/XX
				Endif 				
				Break
			EndIF

			/*/                                                             
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se na Data Houve Excecao e Substitui os Horarios da³
			³ Tabela      												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lExceData := .F.
			IF ( lExce .and. lChkCc )

				aExcecoes := {}
				cTipoDia  := aTabTno[nPos,18]
				IF ( lExce .and.;
					 GetExcecoes( @aExcecoes , cNewTno , cCC , cFilSRA , cMat , dData , @cTipoDia , aExcePer );
				   )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
					³ em Funcao de Excecoes										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se Houver Excecoes na Data Substitui os Horarios/Regra pelos³
					³ da Excecao  												  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF (;
							lExceData := (;
											!Empty( aExcecoes ) .and. ;
											(;
												Empty( aExcecoes[ 01 , 33 ] ) .or.;
												( aExcecoes[ 01 , 33 ] == cTipoDia );
											);
										);
						)
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Nao carrega excecao caso o calendario fisico				  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						
						
						IF ( aExcecoes[01,46] <> "S" )					// Assume o Horario das Excecooes
							aTabTno[nPos,01] 	:= aExcecoes[01,05]		// 01 - 1a Entrada
							aTabTno[nPos,02] 	:= aExcecoes[01,06]		// 02 - 1a Saida
							aTabTno[nPos,03] 	:= aExcecoes[01,07]		// 03 - 2a Entrada
							aTabTno[nPos,04] 	:= aExcecoes[01,08]		// 04 - 2a Saida
							aTabTno[nPos,05] 	:= aExcecoes[01,09]		// 05 - 3a Entrada
							aTabTno[nPos,06] 	:= aExcecoes[01,10]		// 06 - 3a Saida
							aTabTno[nPos,07] 	:= aExcecoes[01,11]		// 07 - 4a Entrada
							aTabTno[nPos,08] 	:= aExcecoes[01,12]		// 08 - 4a Saida
							aTabTno[nPos,09] 	:= aExcecoes[01,16]		// 09 - Horas Trabalhadas 1a. Jornada
							aTabTno[nPos,10] 	:= aExcecoes[01,17]		// 10 - Horas Trabalhadas 2a. Jornada
							aTabTno[nPos,11] 	:= aExcecoes[01,18]		// 11 - Horas Trabalhadas 3a. Jornada
							aTabTno[nPos,12] 	:= aExcecoes[01,19]		// 12 - Horas Trabalhadas 4a. Jornada
							aTabTno[nPos,13] 	:= aExcecoes[01,26]		// 13 - Horas de Intervalo 1S
							aTabTno[nPos,14] 	:= aExcecoes[01,27]		// 14 - Horas de Intervalo 2S
							aTabTno[nPos,15] 	:= aExcecoes[01,28]		// 15 - Horas de Intervalo 3S
							aTabTno[nPos,16] 	:= ""					// 16 - Marcacao e do dia seguinte ?
							aTabTno[nPos,17] 	:= aExcecoes[01,20]		// 17 - Numero de Marcacoes
							aTabTno[nPos,29] 	:= aExcecoes[01,34]		// 29 - Aponta Nona Hora
							aTabTno[nPos,30] 	:= aExcecoes[01,35]		// 30 - Limite de Horario Inicial
							aTabTno[nPos,31] 	:= aExcecoes[01,36]		// 31 - Limite de Horario Final
							aTabTno[nPos,32] 	:= aExcecoes[01,37]		// 32 - 1a. Jornada Continua
							aTabTno[nPos,33] 	:= aExcecoes[01,38]		// 33 - 2a. Jornada Continua
							aTabTno[nPos,34]	:= aExcecoes[01,39]		// 34 - 3a. Jornada Continua
							aTabTno[nPos,35]	:= aExcecoes[01,40]		// 35 - 4a. Jornada Continua
							aTabTno[nPos,36]	:= aExcecoes[01,41]		// 36 - Codigo da Refeicao
						EndIF  
															
						aTabTno[nPos,18] 	:= aExcecoes[01,23]		// 18 - Tipo do Dia
						aTabTno[nPos,19] 	:= aTabTno[ nPos, 19 ]	// 19 - Sequencia da Marcacao
						aTabTno[nPos,20] 	:= Dow( dData )      	// 20 - Numero Correspondente ao Dia da Semana
						aTabTno[nPos,21] 	:= "E"					// 21 - Flag Indicador de Excecao
						aTabTno[nPos,22] 	:= aExcecoes[01,21]		// 22 - Motivo da Excecao
						aTabTno[nPos,23] 	:= aExcecoes[01,22]		// 23 - Codigo Hora Extra Normal
						aTabTno[nPos,24] 	:= aExcecoes[01,24]		// 24 - Codigo Hora Extra Noturna
						aTabTno[nPos,25] 	:= aExcecoes[01,29]		// 25 - Centro de Custo Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,26] 	:= aExcecoes[01,30]		// 26 - Centro de Custo Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,27] 	:= aExcecoes[01,31]		// 27 - Centro de Custo Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,28] 	:= aExcecoes[01,32]		// 28 - Centro de Custo Periodo 4 (4a.E-4a.S)						
						aTabTno[nPos,38] 	:= aExcecoes[01,47]		// 29 - Funcao Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,39] 	:= aExcecoes[01,48]		// 26 - Funcao Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,40] 	:= aExcecoes[01,49]		// 27 - Funcao Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,41] 	:= aExcecoes[01,50]		// 28 - Funcao Periodo 4 (4a.E-4a.S)					
						aTabTno[nPos,58] 	:= aExcecoes[01,55]		// 55 - Depto Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,59] 	:= aExcecoes[01,56]		// 56 - Depto Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,60] 	:= aExcecoes[01,57]		// 57 - Depto Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,61] 	:= aExcecoes[01,59]		// 58 - Depto Periodo 4 (4a.E-4a.S)
						aTabTno[nPos,62] 	:= aExcecoes[01,51]		// 51 - Posto Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,63] 	:= aExcecoes[01,52]		// 52 - Posto Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,64] 	:= aExcecoes[01,53]		// 53 - Posto Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,65] 	:= aExcecoes[01,54]		// 54 - Posto Periodo 4 (4a.E-4a.S)
						aTabTno[nPos,71] 	:= aExcecoes[01,59]		// 59 - Id de excecao
						
						cNewReg		  	 	:= aExcecoes[01,42]		// Regra de Apontamento
						nIniHnot	  	 	:= aExcecoes[01,43]		// Inicio da Hora Noturna
						nFimHnot	  	 	:= aExcecoes[01,44]		// Final da Hora Noturna
						nMinHnot	  		:= aExcecoes[01,45]		// Minutos da Hora Noturna							
							
					
						If lUseCalFisico
							/*/
						   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						   ³ Carregar apenas o ID/Tipo da excecao caso calendario fisico  ³
						   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/			
							cIdExce 	:= aExcecoes[01,59]		// 59 - Id de excecao
							cTpExce		:= aExcecoes[01,60]		// 60 - Tipo de Excecao

						EndIf
						
					EndIF
				EndIF 
			Endif
			      
		   /*/
		   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   ³ Checa a Existencia de Turnos diferentes do Padrao:	          ³
		   ³ Pode ser Turno Alternativo ou Turno Substituto               ³ 
		   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
			lTnoOpcData 	:= .F.
			lTnoSubstituto  := .F.
			If ! lExceData                                                       
				/*/
			   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			   ³ Checa a Existencia de Turnos Opcionais				          ³
			   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			 	If lAllTnoOpc
				   	/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
					³ em Funcao de Excecoes										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
				   ( lTnoOpcData:=GetTnoOpc( cNewTno, dData, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFilSPJ, @aMarcacoes))
                Else
	                /*/
				   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				   ³ Checa a Existencia de Turno Substituto	para a data           ³
				   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Ponto de Entrada para edicao do array aTabCalend             ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF lPnmTab01 
						IF ( ValType( uRet 	:= ExecBlock("PNMTAB01",.F.,.F., { cFilSRA , cMat , dData, cNewTno, aClone(aTabTno[nPos]) }) ) == "A" )	
							IF (lTnoSubstituto  := !Empty(uRet) )
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
								³ em Funcao de Excecoes										  ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								aTabOrig  		:= aClone( aTabTno )
								cRegOrig  		:= cNewReg
	
								 /*/
							    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							    ³ Troca a tabela de horario do turno do dia pela do Ponto de Entrada           ³
							    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
								aTabTno[nPos] 	:= aClone(uRet)
							Endif	
							uRet	   		:= NIL
						EndIF
					EndIF
                Endif
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verificar se o Funcionario Esta Afastado na Data			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			dIniAfas	:= Ctod("//")
			dFimAfas	:= Ctod("//")
			cTipAfas	:= __aLstTabCal[ nPosDataApo , CALEND_POS_TIP_AFAST ]
			IF ( lAfast := ( lAfastper ) )
				lAfast := fAfasta( cFilSRA , cMat , dData , @dIniAfas , @dFimAfas , @cTipAfas , aAfasta, @cIdAfas )
			EndIF			

			IF !( lBldNewOrd )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se Teve Alguma Alteracao                		  	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lBldNewOrd := (;
										( lExistTrcTno )  .or. ;	//Troca de Turno na Data
										( lExceData	   )  .or. ;	//Excecao na Data
										( lTnoOpcData  )  .or. ;	//Turno Opcional
										( lTnoSubstituto) .or. ; 	//Turno substituto
										( lAfast	   )  	   ;	//Afastamento na Data
									 );
					)
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Verifica se Deve Re-Sincronizar o Calendario     		  	  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					lForceSinc := lBldNewOrd
				
				Else
					Loop
				EndIF
			EndIF        
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega os Valores DEFAULT para o Dia            		  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lAponFer	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_APON_FERIAS	]
			cTpExNorFer	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TP_HE_NR_FER	]
			cTpExNotFer	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TP_HE_NT_FER	]
			cPagInt 	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_PAGINT		]
			lFeriado 	:= __aLstTabCal[ nPosDataApo	, 	CALEND_POS_FERIADO		]
       		lTrbFeriado	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TRAB_FERIADO	] 
       		lHeAutoFer	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_HE_AUTO_FER	] 
       		

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Define o Tipo do Dia                                    	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cTipoDia := aTabTno[ nPos , 18 ]

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Teve Alteracao no Turno              		  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF( lNewTno	:= ( cNewTno <> cTno ) )
				cTno := cNewTno
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Teve Alteracao na Regra              		  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF( lNewReg	:= ( cNewReg <> cReg ) )
				cReg := cNewReg
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se a Regra de Apontamento eh Valida                ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !( lCriaCalOk := PosSPA( cNewReg , cFilSPA , NIL , 01 , .F. ) )
				If lError
					oCalendError:SendError('03',cNewReg, .T.)  //"No se encontro la regla "
				EndIf
				Break
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem as Informacoes em Cache da Regra de Apontamento       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aSpaInfo := {;
							"PA_PAGINT"		,;	//01
							"PA_FERIADO"	 ;	//02
						}
			aSpaInfo := PosSPA( cNewReg , cFilSPA , aSpaInfo , 01 , .F. )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Quais Intervalos Sao Pagos             			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cPagInt := aSpaInfo[1]

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Se o Dia em Questao eh um Feriado				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lTrbFeriado := .F.
			IF ( lFeriado := __aLstTabCal[ nPosDataApo , CALEND_POS_FERIADO ] )
				lTrbFeriado := ( aSpaInfo[2] == "S" )
       		EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ As horas extras para funcionario em ferias sao por padrao	  ³
			³ autorizadas.												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/			
			lHeAutoFer	:= .T.
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se nao Existir Excecao na Data Redefine o Tipo do Dia   	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !( lExceData )

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se o Turno de Trabalho eh valido                   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF !( lCriaCalOk := PosSR6( cTno , cFilSPJ , NIL , 01 , .F. ) )
					If lError
						oCalendError:SendError('02',cTno, .T.)		//Nao foi encontrado Turno XXX
					Endif									
					Break
				EndIF
				
				aSr6Info := PosSR6( cNewTno , cFilSPJ , aSr6Cpo , 01 , .F. )             
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Obtem a Hora Noturna de Acordo com o Turno                  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nIniHnot := aSr6Info[1]	// Inicio da Hora Noturna
				nFimHnot := aSr6Info[2]	// Final da Hora Noturna
				nMinHnot := aSr6Info[3]	// Minutos da Hora Noturna

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se estiver Afastado Define o Dia como Nao Trabalhado        ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lAfast )
					cTipoDia := "N"	//Nao Trabalhado
				EndIF

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se Aponta para Funcionario em Ferias            	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( cTipAfas == "F" )
					IF ( lAponFer := ( aSr6Info[4] == "S" ) )
					
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Se funcionario em Ferias com Direito a Apontamento       	  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						cTpExNorFer	:= aSr6Info[5]	//Normal Ferias
						cTpExNotFer	:= aSr6Info[6]	//Noturna Ferias      
						
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Verifica se horas extras sao autorizadas para funcionario   ³
						³ em ferias.												  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						lHeAutoFer := If ( aSr6Info[7] == "1" .or. Empty( aSr6Info[7] ), .T. , .F. )	 // 1 ou branco - Autorizadas (Padrao) , 2- Nao Autorizadas
						
					EndIF
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se funcionario nao Trabalha em Feriado e dia For Feriado 	  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF (;
					 		( lFeriado );			//Dia eh Feriado	
					 		.and.;
					 		!( lTrbFeriado );		//Funcionario Nao Trabalha em Feriado
					 	)
						cTipoDia := "F" //Feriado
					EndIF
				EndIF
			
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Garante que os Minutos da Hora Nunca Sera Menor que Zero	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nMinHnot := IF( nMinHnot <= 0 , 60 , nMinHNot )	// Minutos da Hora Noturna

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Informacoes do Feriado                          	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cP3TpExt	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TP_HE_FER_NR	]
			cP3TpExtN	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TP_HE_FER_NT	]
			cP3Desc		:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_DESC_FERIADO	]

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Exclui a Data de Apontamento Existente para Inclusao de Nova³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( ( nY := nPosDataApo ) > 0 )
				nLenCalend := Len( aTabCalend )
				While (;
							( nY <= nLenCalend )  .and. ;
							( nLenCalend > 0 )	  .and.	;
							( aTabCalend[ nY , CALEND_POS_DATA_APO ] >= __aLstTabCal[ nPosDataApo , CALEND_POS_DATA_APO ] );
					   )
					aDel( aTabCalend , nY )
					aSize( aTabCalend , --nLenCalend )
				End While
			EndIF
            
           	/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Posicao da primeira recriacao								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
			nLenRecria := If ( Empty(nLenRecria), Len(aTabCalend)+1,nLenRecria )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Loop For/Next para a Carga das Marcacoes do Dia             ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
			For nY := 1 To nFornY

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Abandona Quando as Marcacoes estiverem Vazias e Nao For  Jor³
				³ nada Continua												  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF (;
						( ( nY == 3 ) .and. ( ( aTabTno[ nPos , 03 ] + aTabTno[ nPos , 04 ] ) == 0 ) .and. ( aTabTno[ nPos , 33 ] != "S" ) ) .or. ;
				   		( ( nY == 5 ) .and. ( ( aTabTno[ nPos , 05 ] + aTabTno[ nPos , 06 ] ) == 0 ) .and. ( aTabTno[ nPos , 34 ] != "S" ) ) .or. ;
				   		( ( nY == 7 ) .and. ( ( aTabTno[ nPos , 07 ] + aTabTno[ nPos , 08 ] ) == 0 ) .and. ( aTabTno[ nPos , 35 ] != "S" ) )      ;
				   	)	
					Exit
				EndIF
		
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega Informacoes Especificas para a Nova Data de Apont.  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lBldNewOrd )
			
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Incrementa dData e nDias Quando Marcacao for do Dia Seguinte³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF ( aTabTno[ nPos , nY ] <  aTabTno[ nPos , IF( nY == 1 , nY , nY-1 ) ] )
						++dData
						++nDias
					EndIF
			
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Incrementa dData e nDias Caso Jornada Continua			  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF (;
							lJndC := (;
										( ( nY == 2 ) .and. ( aTabTno[ nPos , 32 ] == "S" ) ) .or. ;
					   		  	    	( ( nY == 4 ) .and. ( aTabTno[ nPos , 33 ] == "S" ) ) .or. ;
					   			    	( ( nY == 6 ) .and. ( aTabTno[ nPos , 34 ] == "S" ) ) .or. ;
					   			    	( ( nY == 8 ) .and. ( aTabTno[ nPos , 35 ] == "S" ) )	   ;
					   			 	 );
					   	)
					   	lIncrementa	:= .T.
						++dData
						++nDias
					EndIF

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Verifica Centro de Custo, Horas Trabalhadas e Horas de  Inter³
					³Valo														  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					cCcCal	:= ""
					cFuncCal:= ""
					nHrTrab := 0
					nHrInte := 0
					Do Case
						Case ( aTipo[ nY ] $ "1E*1S" )
							cCcCal 		:= aTabTno[ nPos , 25 ] 
							cFuncCal 	:= aTabTno[ nPos , 38 ]
							cJndCont	:= aTabTno[ nPos , 32 ]
							cDepto		:= aTabTno[ nPos , 58 ]
							cPosto		:= aTabTno[ nPos , 62 ]
							cCodJor		:= aTabTno[ nPos , 70 ]
							IF ( aTipo[ nY ] == "1E" )
								nHrTrab  := aTabTno[ nPos , 09 ]
								nLimInfE := aTabTno[ nPos , 42 ]
								nLimSupE := aTabTno[ nPos , 43 ]
							Else
								nHrInte  := aTabTno[ nPos , 13 ]
								nLimInfS := aTabTno[ nPos , 44 ]
								nLimSupS := aTabTno[ nPos , 45 ]
							EndIF
						Case ( aTipo[ nY ] $ "2E*2S" )
							cCcCal 		:= aTabTno[ nPos , 26 ]
							cFuncCal 	:= aTabTno[ nPos , 39 ]
							cJndCont	:= aTabTno[ nPos , 33 ]
							cDepto		:= aTabTno[ nPos , 59 ]
							cPosto		:= aTabTno[ nPos , 63 ]
							cCodJor		:= aTabTno[ nPos , 70 ]
							IF ( aTipo[ nY ] == "2E" )
								nHrTrab  := aTabTno[ nPos , 10 ]
								nLimInfE := aTabTno[ nPos , 46 ]
								nLimSupE := aTabTno[ nPos , 47 ]
							Else
								nHrInte  := aTabTno[ nPos , 14 ]
								nLimInfS := aTabTno[ nPos , 48 ]
								nLimSupS := aTabTno[ nPos , 49 ]
							EndIF
						Case ( aTipo[ nY ] $ "3E*3S" )
							cCcCal 		:= aTabTno[ nPos , 27 ]
							cFuncCal 	:= aTabTno[ nPos , 40 ]
							cJndCont	:= aTabTno[ nPos , 34 ]
							cDepto		:= aTabTno[ nPos , 60 ]
							cPosto		:= aTabTno[ nPos , 64 ]
							cCodJor		:= aTabTno[ nPos , 70 ]
							IF ( aTipo[ nY ] == "3E" )
								nHrTrab  := aTabTno[ nPos , 11 ]
								nLimInfE := aTabTno[ nPos , 50 ]
								nLimSupE := aTabTno[ nPos , 51 ]
							Else
								nHrInte  := aTabTno[ nPos , 15 ]
								nLimInfS := aTabTno[ nPos , 52 ]
								nLimSupS := aTabTno[ nPos , 53 ]
							EndIF
						Case ( aTipo[ nY ] $ "4E*4S" )
							cCcCal 		:= aTabTno[ nPos , 28 ]
							cFuncCal 	:= aTabTno[ nPos , 41 ]
							cJndCont	:= aTabTno[ nPos , 35 ]
							cDepto		:= aTabTno[ nPos , 61 ]
							cPosto		:= aTabTno[ nPos , 65 ]
							cCodJor		:= aTabTno[ nPos , 70 ]
							IF ( aTipo[ nY ] == "4E" )
								nHrTrab  := aTabTno[ nPos , 12 ]
								nLimInfE := aTabTno[ nPos , 54 ]
								nLimSupE := aTabTno[ nPos , 55 ]
							Else
								nLimInfS := aTabTno[ nPos , 52 ]
								nLimSupS := aTabTno[ nPos , 53 ]
							EndIF
					EndCase
					
   					 
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Carrega Novo Elemento no Calendario   					  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )
					nLenCalend := Len( aTabCalend )
					aTabCalend[	nLenCalend	,	CALEND_POS_DATA				] := dData																					// 01 - Data
					aTabCalend[	nLenCalend	,	CALEND_POS_ORDEM			] := cOrdem																					// 02 - Ordem
					aTabCalend[	nLenCalend	,	CALEND_POS_HORA				] := aTabTno[ nPos , nY ]      																// 03 - Hora
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_MARC		] := aTipo[ nY ]          																	// 04 - Tipo Marc
					aTabCalend[	nLenCalend	,	CALEND_POS_NUM_MARC			] := aTabTno[ nPos , 17 ]     																// 05 - No Marc.
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_DIA			] := cTipoDia     																			// 06 - Tipo Dia
					aTabCalend[	nLenCalend	,	CALEND_POS_HRS_TRABA		] := nHrTrab																				// 07 - Horas Trabalhada no Periodo
					aTabCalend[	nLenCalend	,	CALEND_POS_SEQ_TURNO		] := aTabTno[ nPos , 19 ]   																// 08 - Sequˆncia de Turno
					aTabCalend[	nLenCalend	,	CALEND_POS_HRS_INTER		] := nHrInte																				// 09 - Horas de Intervalo
					aTabCalend[	nLenCalend	,	CALEND_POS_EXCECAO			] := aTabTno[ nPos , 21 ]																	// 10 - Excecao ( E-Excecao, # E - nao e excecao )
					aTabCalend[	nLenCalend	,	CALEND_POS_MOT_EXECAO		] := aTabTno[ nPos , 22 ]																	// 11 - Motivo da Excecao
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOR		] := aTabTno[ nPos , 23 ]																	// 12 - Tipo de hora extra normal
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOT		] := aTabTno[ nPos , 24 ]																	// 13 - Tipo de hora extra noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_TURNO			] := cNewTno																				// 14 - Turno de Trabalho
					aTabCalend[	nLenCalend	,	CALEND_POS_CC				] := cCcCal																					// 15 - Centro de Custo do Periodo 
					aTabCalend[	nLenCalend	,	CALEND_POS_PG_NONA_HORA		] := aTabTno[ nPos , 29 ]																	// 16 - Pagamento de Nona Hora
					IF ( nY == 1 )
						If !lMVLimSup .and. nLenCalend > 1
							//O limite superior do dia anterior será o limite inferior do dia atual menos um minuto
							nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
							aMarcId[1]	:= __fNsToDh( nSerial , "D" )
							aMarcId[2]	:= __fNsToDh( nSerial , "H" )
							
							If aMarcId[2] > 0
								aMarcId[2]	:= SubHoras(aMarcId[2],0.01) 
							Else
								aMarcId[2] := 23.59
								aMarcId[1] := aMarcId[1] - 1
							EndIf
							
							aTabCalend[	nLenCalend-1	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )
						EndIf					
						nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
						aMarcId[1]	:= __fNsToDh( nSerial , "D" )
						aMarcId[2]	:= __fNsToDh( nSerial , "H" )
					Else
						aMarcId[1] := Ctod("//")
						aMarcId[2] := 0
					EndIF
					aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO		] := aClone( aMarcId )																		// 17 - Limite de Marcacao Inicial
					aTabCalend[	nLenCalend	,	CALEND_POS_COD_REFEICAO		] := IF(Empty(aTabTno[nPos,36]).and.!Empty(aTabOrig),aTabOrig[nPos,36],aTabTno[nPos,36])	// 18 - Codigo da Refeicao
					aTabCalend[	nLenCalend	,	CALEND_POS_FERIADO			] := lFeriado																				// 19 - Dia e Feriado
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt																				// 20 - Tipo de Hora Extra Feriado Normal
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN																				// 21 - Tipo de Hora Extra Feriado Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_DESC_FERIADO		] := cP3Desc																				// 22 - Descricao do Feriado
					aTabCalend[	nLenCalend	,	CALEND_POS_REGRA			] := cNewReg																				// 23 - Regra de Apontamento
					aTabCalend[	nLenCalend	,	CALEND_POS_AFAST			] := lAfast																					// 24 - Funcionario Afastado
					aTabCalend[	nLenCalend	,	CALEND_POS_TIP_AFAST		] := cTipAfas																				// 25 - Tipo de Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_INI_AFAST		] := dIniAfas																				// 26 - Data Inicial do Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_FIM_AFAST		] := dFimAfas																				// 27 - Data Final do Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_INI_H_NOT		] := nIniHnot																				// 28 - Inicio da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_FIM_H_NOT		] := nFimHnot																				// 29 - Final da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_MIN_H_NOT		] := nMinHnot																				// 30 - Minutos da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado																			// 31 - Se funcionario Trabalha em Dias Feriados
					aTabCalend[	nLenCalend	,	CALEND_POS_APON_FERIAS		] := lAponFer																				// 32 - Se Aponta Quando Afastamento em Ferias
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NR_FER		] := cTpExNorFer																			// 33 - Tipo de hora extra normal (Ferias)
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NT_FER		] := cTpExNotFer																			// 34 - Tipo de hora extra noturna (Ferias)	
					aTabCalend[	nLenCalend	,	CALEND_POS_PAGINT			] := cPagInt																				// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
					aTabCalend[ nLenCalend	,   CALEND_POS_TIPO_ORIG_DIA    ] := aTabTno[nPos,18]																		// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos
					aTabCalend[ nLenCalend	,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer																				// 37 - Se H.Extras são autorizadas para funcionario em ferias				
					aTabCalend[ nLenCalend	,   CALEND_POS_CODFUNC 		    ] := cFuncCal																				// 38 - Codigo de funcao
					aTabCalend[ nLenCalend  , 	CALEND_POS_DEPTO			] := cDepto																					// 39 - Codigo de Depto. do funcionario
					aTabCalend[ nLenCalend  , 	CALEND_POS_POSTO			] := cPosto																					// 40 - Codigo do Posto do funcionario
					aTabCalend[ nLenCalend  , 	CALEND_POS_PERIODO	   		] := cCodPer  																				// 41 - Periodo
					aTabCalend[ nLenCalend  , 	CALEND_POS_ROTEIRO			] := cCodRot  																				// 42 - Roterio
					aTabCalend[ nLenCalend  , 	CALEND_POS_PROCESSO			] := cCodPro  																	   			// 43 - Processo
					aTabCalend[ nLenCalend  , 	CALEND_POS_NUM_PAGTO		] := cNumPag  																				// 44 - Num. de Pagamento
					aTabCalend[ nLenCalend  , 	CALEND_POS_JORN		   		] := cCodJor 																				// 45 - Cod. da Jornada
					aTabCalend[ nLenCalend  , 	CALEND_POS_P2ID				] := cIdExce 				   																// 46 - Lote da excecao
					aTabCalend[ nLenCalend	,   CALEND_POS_R8ID				] := cIdAfas																	   			// 47 - Identificacao afastamento
					aTabCalend[ nLenCalend	,   CALEND_POS_DATA_APO		    ] := dDataApo																				// 48 - Data de apontamento					
					aTabCalend[ nLenCalend	, 	CALEND_POS_JND_CON			] := cJndCont																				// 49 - Jornada continua						
					aTabCalend[ nLenCalend  , 	CALEND_POS_LIE				] := nLimInfE 																				// 50 - Limite inferior da entrada
					aTabCalend[ nLenCalend  , 	CALEND_POS_LSE				] := nLimSupE																				// 51 - Limite superior da entrada
					aTabCalend[ nLenCalend  , 	CALEND_POS_LIS				] := nLimInfS																				// 52 - Limite inferior da saida
					aTabCalend[ nLenCalend  ,   CALEND_POS_LSS				] := nLimSupS 
					aTabCalend[ nLenCalend  , 	CALEND_POS_TPEXCE			] := cTpExce

				EndIF

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Define a Posicao do Calendario quando nao Remontar Ordem    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
				IF !( lBldNewOrd )
					IF ( ( ++nLenCalend ) > Len( aTabCalend )  )
						Exit
					EndIF
				EndIF

			Next nY

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Quando inserir nova data de apontamento verifica o Sincronismo  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
			IF ( lBldNewOrd )
				nSerial		:= ( __fDhToNS( aTabCalend[ nLenCalend , CALEND_POS_DATA ] , aTabCalend[ nLenCalend , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31 ]) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
				
				If !lMVLimSup
					//Limite superior do ultimo dia deve ser igual o limite inferior da proxima jornada menos um
					
					If ( ( nPos := aScan( aTurnos , { |x| x[2] == dData+1 } ) ) > 0 )
						nSeq	:= Val(aTurnos[ nPos , 03 ])
					ElseIf Dow( dData+1 ) == 2
						nSeq++
					EndIf
										
					bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
							  .and. x[20] == Dow(dData+1);
							 }
							 
					If ( ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
						nSerial		:= ( __fDhToNS( dData+1 , aTabTno[ nPos , 1 ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
						aMarcId[1]	:= __fNsToDh( nSerial , "D" )
						aMarcId[2]	:= __fNsToDh( nSerial , "H" )
			
						If aMarcId[2] > 0
							aMarcId[2]	:= SubHoras(aMarcId[2],0.01) 
						Else
							aMarcId[2] := 23.59
							aMarcId[1] := aMarcId[1] - 1
						EndIf
					EndIf
				EndIf				 
								
				aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )																		// 17 - Limite de Marcacao Final
			EndIF				
			
			//Se existir excecao na data, alimenta aMarcacoes para que nao seja classificado como turno opcional
			If lExceData
				If (nPos1:= Ascan(aMarcacoes, {|x| EMPTY( x[AMARC_TNOPC] )  } ) )  >   0
	
				    //-- Corre todas as marcacoes a partir da primeira marcacao nao classificada
					For nPos2 := nPos1 To Len(aMarcacoes)
	
					   	If ( EMPTY( aMarcacoes[nPos2, AMARC_TNOPC] ) .and. (aMarcacoes[nPos2, AMARC_ORDEM] == cOrdem) )
							aMarcacoes[nPos2, AMARC_TNOPC] := aTabTno[ nPos , 19 ]
				 	   	Endif
	 	   			Next nPos2
				EndIf
			EndIf			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se Houve Alteracao na Tabela Padrao/Regra em Funcao das Exce³
			³ coes, Restaura os Padroes								      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( !Empty( aTabOrig ) )
				aTabTno		:= aClone( aTabOrig )
				aTabOrig	:= {}
				cNewReg		:= cRegOrig
				cRegOrig	:= ""
				cIdExce		:= ""
				cTpExce		:= ""
			EndIF
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se Nao eh jornada continua, os dias acrescidos no dia de    ³
			³ apontamento nao serao considerados.					      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		    If !lIncrementa
		       nDias	:= 0
			Else
			   //-- Desconsidera o ultimo incremento para considerar a ultima data incrementada
			   -- nDias
		    Endif
	
		Next nX                  
        
    	/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Renomeia chaves de identificacao Processo/Periodo			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
		If !Empty(nLenRecria)
			fFilIdTabela( aTabCalend, nLenRecria, aTransf )
		EndIf
       
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Reordena Calendario conforme a Data de Apontamento			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lForceSinc )
			aSort( aTabCalend , NIL , NIL , { |x,y|	;
														(;
															Dtos(x[ CALEND_POS_DATA_APO 	]) + ;
															x[ CALEND_POS_TIPO_MARC	]			 ;
														) < ;
														(;
															Dtos(y[ CALEND_POS_DATA_APO 	]) + ;
															y[ CALEND_POS_TIPO_MARC	]			;
														);
											 };
				  )
		EndIF
        	
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Sincroniza horarios iniciais da tabela para evitar intervalos³
	³entre os limites inicial do dia corrente e final do dia  ante³
	³rior.														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lSncMaMe ) .and. ( lForceSinc ) )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aDataApo	,;	//03 -> Array com as Datas de Apontamento do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					cMat   		,;	//09 -> Matricula do Funcionario
					cCc   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					lChkMat		,;	//12 -> Se o Calendario esta sendo Montado por Funcionario
					lTabCalen	 ;
		   		   )
	EndIF	   		   

End Sequence

Return( lCriaCalOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³BldCalTnoSeq	³Autor³Marinaldo de Jesus ³ Data ³17/09/2003³
|    	   |		     	³     ³Igor Franzoi	      ³      ³23/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Cria Calendario de Marcacoes Padrao Para o Turno/Sequencia  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function BldCalTnoSeq(	dDataIni		,;	//01 -> Data Inicial do Periodo
								dDataFim		,;	//02 -> Data Final do Periodo
								aTipo			,;	//03 -> Tipos de Marcacoes Possiveis
								cTno			,;	//04 -> Turno Para a Montagem do Calendario
								cSeq			,;	//05 -> Sequencia Inicial para a Montagem Calendario
								cReg			,;	//06 -> Regra do Funcionario
								aTabPadrao		,;	//07 -> Array Tabela de Horario Padrao
								aTabCalend		,;	//08 -> Array com o Calendario de Marcacoes
								aLstTabTno		,;	//09 -> Tabela do Turno Corrente
								cFil			,;	//10 -> Filial para a Montagem da Tabela de Horario
								lExecQryTop 	,;	//11 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe		,;	//12 -> Se executa a funcao se sincronismo do calendario
								lTabCalen		 ;  //13 -> Nao zerar o array aTabCalend - Calendario Complementar	
							)
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aMarcId	 	:= { NIL , NIL }
Local aTabTno		:= {}
Local aDataApo		:= {}
Local lCriaCalOk	:= .T.
Local lAponFer		:= .F.
Local nOrdem		:= 0
Local nFornY		:= Len( aTipo )
Local nSeq			:= Val( cSeq )
Local nDias			:= 0
Local lChkReg		:= ( !Empty( cReg ) .and. ( cReg <> "__cNewReg__" ) )
Local lHeAutoFer	:= .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aSr6Info
Local aSpaInfo

Local bAsc

Local cOrdem
Local cFilSP3
Local cFilSPJ
Local cFilSR6
Local cFilSPA
Local cPagInt
Local cP3TpExt
Local cP3TpExtN
Local cP3Desc

Local dData
Local cCcCal
Local cDepto
Local cPosto
Local cCodPer	:= ""
Local cCodRot	:= ""
Local cCodPro	:= ""
Local cNumPag	:= ""
Local cCodJor
Local cIdAfas
Local dDataApo
Local cFuncCal
Local cJndCont

Local lJndC
Local lFeriado 
Local lIncrementa	:= .F. //Incrementa dia de periodo de apontamento para jornada continua
Local lTrbFeriado

Local nIniHnot
Local nFimHnot
Local nMinHNot
Local nLimInfE
Local nLimSupE
Local nLimInfS
Local nLimSupS
Local nSerial
Local nLenTabPad
Local nLenCalend
Local nX
Local nY
Local nFornX
Local nPos
Local nHrTrab
Local nHrInte   

Local lError	:= ( Type("oCalendError") <> "U" )

aLogErr030 	:= If ( Type("aLogErr030") == "U" , aLogErr030 := {}, aLogErr030 )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Pesquisa dos Feriados                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSP3	:= xFilial( "SP3" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Montagem do Calendario                ³
³ Case o parametro lUseSPJ = .T. utiliza filial do SPJ, senao ³
³ utiliza a tabela de horario RF2			      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If( lUseSPJ, cFilSPJ := xFilial( "SPJ" , cFil ), cFilSpj := xFilial( "RF2" , cFil ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial do SR6                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSR6 := xFilial( "SR6" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial do SPA                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSPA	:= xFilial( "SPA" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega as Tabelas de Horario Padrao da Filial/Turno        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
fTabPadrao( @aTabPadrao , @cFilSPJ , cTno , lExecQryTop )
IF ( ( ( nLenTabPad := Len( aTabPadrao ) ) == 0 ) .or. ( __nFilTabTno > nLenTabPad ) )
	__nFilTabTno := 0
EndIF	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se nao Verificar a Regra carrega os Espacos correspondentes ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !( lChkReg )
	cReg := Space( GetSx3Cache( "PA_CODIGO" , "X3_TAMANHO" ) )
EndIF

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Pesquisa e Carrega a Tabela do Turno Corrente				  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( __nFilTabTno > 0 ) .and. ( __nFilTabTno <= nLenTabPad ) .and. ( ( cFilSPJ + cTno ) == ( aTabPadrao[ __nFilTabTno , 01 ] + aTabPadrao[ __nFilTabTno , 02 ] ) ) )
		aTabTno := aClone( aTabPadrao[ __nFilTabTno , 3 ] )
	Else
		IF ( lCriaCalOk := ( ( nPos := aScan( aTabPadrao , { |x| x[1] == cFilSPJ .and. x[2] == cTno } ) ) > 0 ) )
			aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
			__nFilTabTno := nPos
		Else
			AADD( aLogErr030, "04" ) //04 = Problema ao Carregar Turno da Tabela Padrão!   
			If lError
				oCalendError:SendError('02',cTno, .T.)		//Nao foi encontrado Turno XXX
			Endif
			Break
		EndIF
	EndIF	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Salva a Tabela do Turno Corrente              			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aLstTabTno := aClone( aTabTno )
	
	If !lTabCalen
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Inicializa o Array aTabCalend ( Calendario das Marcacoes )  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aTabCalend := {}
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Loop For/Next para a Carga das Marcacoes do Periodo         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If	!Empty(aTabCalend)
		nX 	   := (Len(aTabCalend)+1)
		nOrdem := aTabCalend[ Len(aTabCalend), CALEND_POS_ORDEM ]
	Else
		nX := 0	
		//Caso ja exista dias do periodo gravados no calendario, inicia ordem a partir do ultimo registro existente.
		If !( __nOrdIni == NIL )
			nOrdem := __nOrdIni
		EndIf		
	EndIf


	nFornX := ( dDataFim - dDataIni )
	For nX := nX To nFornX
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Data a ser verificada										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		dData := ( dDataIni + nX )
        
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva a Data de Apontamento								  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
		dDataApo	:= dData
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ A Sequencia eh incrementada a Cada Segunda Feira			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( nX != 0 ) .and. ( Dow( dData ) == 2 ) )
			nSeq++
		EndIF

		IF ( lIncrementa ) 
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se a Sequˆncia atual est  cadastrada na Tabela. Pes³
			³ quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   De³
			³ pois com StrZero( n , 2 ) "00"						      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Para Jornada Continua corre todas as datas para que seja    ³
			³ verificada se alguma segunda-feira ocorre durante a jornada ³
			³ e, assim, incrementarmos a sequencia.						  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		    If nDias > 0
		      --nDias 
		      Loop
		    Endif   
		    lIncrementa := .F.
		EndIF
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ordem da Marcacao     									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nOrdem++
		cOrdem := StrZero( nOrdem , Max( __nTamP8Ordem , Len( AllTrim( Str( nOrdem ) ) ) ) )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se houver Sincronismo, adiciona a Data de Apontamento  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lSncMaMe )
			aAdd( aDataApo, dDataApo)
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se a Sequˆncia atual est  cadastrada na Tabela. Pes³
		³ quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   De³
		³ pois com StrZero( n , 2 ) "00"						      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
		nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica se o Dia da Semana da Sequencia e equivalente ao Dia³
		³da Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  com³
		³o StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
					  .and. x[20] == Dow(dData);
				 }
		IF !( lCriaCalOk := ( nPos := aScan( aTabTno, bAsc ) ) > 0 )
			AADD( aLogErr030, "04" ) //04 = Problema ao Carregar Turno da Tabela Padrão!
			If lError
				oCalendError:SendError('02',cTno, .T.)		//Nao foi encontrado Turno XXX
			Endif
			Break
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se o Turno de Trabalho eh valido                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !( lCriaCalOk := PosSR6( cTno , cFilSPJ , NIL , 01 , .F. ) )
			AADD( aLogErr030, "05" ) //05 = Turno de Trabalho Inválido!   
			If lError
				oCalendError:SendError('02',cTno, .T.)		//Nao foi encontrado Turno XXX
			Endif									
			Break
		EndIF
				
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem as Informacoes em Cache do Turno de Trabalho          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSr6Info := {;
						"R6_INIHNOT"	,;	//01
						"R6_FIMHNOT"	,;	//02
						"R6_MINHNOT"	;	//03   
					}
		aSr6Info := PosSR6( cTno , cFilSPJ , aSr6Info , 01 , .F. )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem a Hora Noturna de Acordo com o Turno                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nIniHnot := aSr6Info[1]	// Inicio da Hora Noturna
		nFimHnot := aSr6Info[2]	// Final da Hora Noturna
		nMinHnot := aSr6Info[3]	// Minutos da Hora Noturna

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Garante que os Minutos da Hora Nunca Sera Menor que Zero	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nMinHnot := IF( nMinHnot <= 0 , 60 , nMinHNot )				// Minutos da Hora Noturna

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Quais Intervalos Sao Pagos             			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cPagInt := ""
		IF ( lChkReg )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se a Regra de Apontamento eh Valida                ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !( lCriaCalOk := PosSPA( cReg , cFilSPA , NIL , 01 , .F. ) )
				AADD( aLogErr030, "06" ) //06 = Regra de Apontamento Inválida!
				If lError
					oCalendError:SendError('03',cReg, .T.)		//Nao foi encontrado a Regra XXX				
				Endif
				Break
			EndIF
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem as Informacoes em Cache da Regra de Apontamento       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aSpaInfo := {;
							"PA_PAGINT"		,;	//01
							"PA_FERIADO"	 ;	//02
						}
			aSpaInfo := PosSPA( cReg , cFilSPA , aSpaInfo , 01 , .F. )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Quais Intervalos Sao Pagos             			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cPagInt := aSpaInfo[1]
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Se o Dia em Questao eh um Feriado				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lTrbFeriado := .F.
		IF ( lFeriado := fFeriado( cFilSP3 , dData ) )
			cP3TpExt		:= SP3->P3_TPEXT
			cP3TpExtN		:= SP3->P3_TPEXTN
			cP3Desc			:= SP3->P3_DESC
			IF ( lChkReg )
				lTrbFeriado := ( aSpaInfo[2] == "S" )
			EndIF
		Else
			cP3TpExt	:= ""
			cP3TpExtN	:= ""
			cP3Desc		:= ""
		EndIF		

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Define o Tipo do Dia                                    	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cTipoDia := aTabTno[ nPos , 18 ]

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se funcionario nao Trabalha em Feriado e dia For Feriado 	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( lFeriado ) .and. !( lTrbFeriado ) )
			cTipoDia := "F" //Feriado
		EndIF 

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Loop For/Next para a Carga das Marcacoes do Dia             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
		For nY := 1 To nFornY

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Abandona Quando as Marcacoes estiverem Vazias e Nao For  Jor³
			³ nada Continua												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					( ( nY == 3 ) .and. ( ( aTabTno[ nPos , 03 ] + aTabTno[ nPos , 04 ] ) == 0 ) .and. ( aTabTno[ nPos , 33 ] != "S" ) ) .or. ;
			   		( ( nY == 5 ) .and. ( ( aTabTno[ nPos , 05 ] + aTabTno[ nPos , 06 ] ) == 0 ) .and. ( aTabTno[ nPos , 34 ] != "S" ) ) .or. ;
			   		( ( nY == 7 ) .and. ( ( aTabTno[ nPos , 07 ] + aTabTno[ nPos , 08 ] ) == 0 ) .and. ( aTabTno[ nPos , 35 ] != "S" ) )      ;
			   	)	
				Exit
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Incrementa dData e nDias Quando Marcacao for do Dia Seguinte³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( aTabTno[ nPos , nY ] <  aTabTno[ nPos , IF( nY == 1 , nY , nY-1 ) ] )
				++dData
				++nDias
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Incrementa dData e nDias Caso Jornada Continua			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					lJndC := (;
								( ( nY == 2 ) .and. ( aTabTno[ nPos , 32 ] == "S" ) ) .or. ;
			   		  	    	( ( nY == 4 ) .and. ( aTabTno[ nPos , 33 ] == "S" ) ) .or. ;
			   			    	( ( nY == 6 ) .and. ( aTabTno[ nPos , 34 ] == "S" ) ) .or. ;
			   			    	( ( nY == 8 ) .and. ( aTabTno[ nPos , 35 ] == "S" ) )	   ;
			   			 	 );
			   	)
				++dData
				++nDias
				lIncrementa	:= .T.
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica Centro de Custo, Funcao, Horas Trabalhadas e Horas  ³
			³de  Intervalo												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cCcCal	:= ""
			cFuncCal:= ""
			nHrTrab := 0
			nHrInte := 0
			Do Case
				Case ( aTipo[ nY ] $ "1E*1S" )
					cCcCal 		:= aTabTno[ nPos , 25 ] 
					cFuncCal 	:= aTabTno[ nPos , 38 ]
					cJndCont	:= aTabTno[ nPos , 32 ]
					cDepto		:= aTabTno[ nPos , 58 ]
					cPosto		:= aTabTno[ nPos , 62 ]
					cCodPro		:= aTabTno[ nPos , 66 ]
					cNumPag		:= aTabTno[ nPos , 67 ]
					cCodPer		:= aTabTno[ nPos , 68 ]
					cCodRot		:= aTabTno[ nPos , 69 ]
					cCodJor		:= aTabTno[ nPos , 70 ]
					IF ( aTipo[ nY ] == "1E" )
						nHrTrab  := aTabTno[ nPos , 09 ]
						nLimInfE := aTabTno[ nPos , 42 ]
						nLimSupE := aTabTno[ nPos , 43 ]
					Else
						nHrInte  := aTabTno[ nPos , 13 ]
						nLimInfS := aTabTno[ nPos , 44 ]
						nLimSupS := aTabTno[ nPos , 45 ]
					EndIF					
				Case ( aTipo[ nY ] $ "2E*2S" )
					cCcCal 		:= aTabTno[ nPos , 26 ]
					cFuncCal 	:= aTabTno[ nPos , 39 ]
					cJndCont	:= aTabTno[ nPos , 33 ]
					cDepto		:= aTabTno[ nPos , 59 ]
					cPosto		:= aTabTno[ nPos , 63 ]
					cCodPro		:= aTabTno[ nPos , 66 ]
					cNumPag		:= aTabTno[ nPos , 67 ]
					cCodPer		:= aTabTno[ nPos , 68 ]
					cCodRot		:= aTabTno[ nPos , 69 ]
					cCodJor		:= aTabTno[ nPos , 70 ]
					IF ( aTipo[ nY ] == "2E" )
						nHrTrab  := aTabTno[ nPos , 10 ]
						nLimInfE := aTabTno[ nPos , 46 ]
						nLimSupE := aTabTno[ nPos , 47 ]
					Else
						nHrInte  := aTabTno[ nPos , 14 ]
						nLimInfS := aTabTno[ nPos , 48 ]
						nLimSupS := aTabTno[ nPos , 49 ]
					EndIF
				Case ( aTipo[ nY ] $ "3E*3S" )
					cCcCal 		:= aTabTno[ nPos , 27 ]
					cFuncCal 	:= aTabTno[ nPos , 40 ]
					cJndCont	:= aTabTno[ nPos , 34 ]
					cDepto		:= aTabTno[ nPos , 60 ]
					cPosto		:= aTabTno[ nPos , 64 ]
					cCodPro		:= aTabTno[ nPos , 66 ]
					cNumPag		:= aTabTno[ nPos , 67 ]
					cCodPer		:= aTabTno[ nPos , 68 ]
					cCodRot		:= aTabTno[ nPos , 69 ]
					cCodJor		:= aTabTno[ nPos , 70 ]
					IF ( aTipo[ nY ] == "3E" )
						nHrTrab  := aTabTno[ nPos , 11 ]
						nLimInfE := aTabTno[ nPos , 50 ]
						nLimSupE := aTabTno[ nPos , 51 ]
					Else
						nHrInte  := aTabTno[ nPos , 15 ]
						nLimInfS := aTabTno[ nPos , 52 ]
						nLimSupS := aTabTno[ nPos , 53 ]
					EndIF	
				Case ( aTipo[ nY ] $ "4E*4S" )
					cCcCal 		:= aTabTno[ nPos , 28 ]
					cFuncCal 	:= aTabTno[ nPos , 41 ]
					cJndCont	:= aTabTno[ nPos , 35 ]
					cDepto		:= aTabTno[ nPos , 61 ]
					cPosto		:= aTabTno[ nPos , 65 ]
					cCodPro		:= aTabTno[ nPos , 66 ]
					cNumPag		:= aTabTno[ nPos , 67 ]
					cCodPer		:= aTabTno[ nPos , 68 ]
					cCodRot		:= aTabTno[ nPos , 69 ]
					cCodJor		:= aTabTno[ nPos , 70 ]
					IF ( aTipo[ nY ] == "4E" )
						nHrTrab  := aTabTno[ nPos , 12 ]
						nLimInfE := aTabTno[ nPos , 54 ]
						nLimSupE := aTabTno[ nPos , 55 ]
					Else
						nLimInfS := aTabTno[ nPos , 52 ]
						nLimSupS := aTabTno[ nPos , 53 ]
					EndIF	
			EndCase			

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Novo Elemento no Calendario   					  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )
			nLenCalend := Len( aTabCalend )
			aTabCalend[	nLenCalend	,	CALEND_POS_DATA				] := dData																			// 01 - Data
			aTabCalend[	nLenCalend	,	CALEND_POS_ORDEM			] := cOrdem																			// 02 - Ordem
			aTabCalend[	nLenCalend	,	CALEND_POS_HORA				] := aTabTno[ nPos , nY ]      														// 03 - Hora
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_MARC		] := aTipo[ nY ]          															// 04 - Tipo Marc
			aTabCalend[	nLenCalend	,	CALEND_POS_NUM_MARC			] := aTabTno[ nPos , 17 ]     														// 05 - No Marc.
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_DIA			] := cTipoDia     																	// 06 - Tipo Dia
			aTabCalend[	nLenCalend	,	CALEND_POS_HRS_TRABA		] := nHrTrab									 							 		// 07 - Horas Trabalhada no Periodo
			aTabCalend[	nLenCalend	,	CALEND_POS_SEQ_TURNO		] := aTabTno[ nPos , 19 ]   														// 08 - Sequˆncia de Turno
			aTabCalend[	nLenCalend	,	CALEND_POS_HRS_INTER		] := nHrInte																		// 09 - Horas de Intervalo
			aTabCalend[	nLenCalend	,	CALEND_POS_EXCECAO			] := aTabTno[ nPos , 21 ]															// 10 - Excecao ( E-Excecao, # E - nao e excecao )
			aTabCalend[	nLenCalend	,	CALEND_POS_MOT_EXECAO		] := aTabTno[ nPos , 22 ]															// 11 - Motivo da Excecao
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOR		] := aTabTno[ nPos , 23 ]															// 12 - Tipo de hora extra normal
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOT		] := aTabTno[ nPos , 24 ]															// 13 - Tipo de hora extra noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_TURNO			] := cTno																			// 14 - Turno de Trabalho
			aTabCalend[	nLenCalend	,	CALEND_POS_CC				] := cCcCal										 							 		// 15 - Centro de Custo do Periodo 
			aTabCalend[	nLenCalend	,	CALEND_POS_PG_NONA_HORA		] := aTabTno[ nPos , 29 ]															// 16 - Pagamento de Nona Hora
			IF ( nY == 1 )
				If !lMVLimSup .and. nLenCalend > 1
					//O limite superior do dia anterior será o limite inferior do dia atual menos um minuto
					nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
					aMarcId[1]	:= __fNsToDh( nSerial , "D" )
					aMarcId[2]	:= __fNsToDh( nSerial , "H" )
					
					If aMarcId[2] > 0
						aMarcId[2]	:= SubHoras(aMarcId[2],0.01) 
					Else
						aMarcId[2] := 23.59
						aMarcId[1] := aMarcId[1] - 1
					EndIf
					
					aTabCalend[	nLenCalend-1	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )
				EndIf
				nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
			Else
				aMarcId[1] := Ctod("//")
				aMarcId[2] := 0
			EndIF
			aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO		] := aClone( aMarcId )																// 17 - Limite de Marcacao Inicial
			aTabCalend[	nLenCalend	,	CALEND_POS_COD_REFEICAO		] := aTabTno[ nPos , 36 ]															// 18 - Codigo da Refeicao
			aTabCalend[	nLenCalend	,	CALEND_POS_FERIADO			] := lFeriado																		// 19 - Dia e Feriado
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt																		// 20 - Tipo de Hora Extra Feriado Normal
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN																		// 21 - Tipo de Hora Extra Feriado Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_DESC_FERIADO		] := cP3Desc																		// 22 - Descricao do Feriado
			aTabCalend[	nLenCalend	,	CALEND_POS_REGRA			] := cReg																			// 23 - Regra de Apontamento
			aTabCalend[	nLenCalend	,	CALEND_POS_AFAST			] := .F.																			// 24 - Funcionario Afastado
			aTabCalend[	nLenCalend	,	CALEND_POS_TIP_AFAST		] := ""																				// 25 - Tipo de Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_INI_AFAST		] := Ctod("//")																		// 26 - Data Inicial do Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_FIM_AFAST		] := Ctod("//")																		// 27 - Data Final do Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_INI_H_NOT		] := nIniHnot																		// 28 - Inicio da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_FIM_H_NOT		] := nFimHnot																		// 29 - Final da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_MIN_H_NOT		] := nMinHnot																		// 30 - Minutos da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado																	// 31 - Se funcionario Trabalha em Dias Feriados
			aTabCalend[	nLenCalend	,	CALEND_POS_APON_FERIAS		] := lAponFer																		// 32 - Se Aponta Quando Afastamento em Ferias
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NR_FER		] := ""																				// 33 - Tipo de hora extra normal (Ferias)
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NT_FER		] := ""																				// 34 - Tipo de hora extra noturna (Ferias)	
			aTabCalend[	nLenCalend	,	CALEND_POS_PAGINT			] := cPagInt																		// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
			aTabCalend[ nLenCalend	,   CALEND_POS_TIPO_ORIG_DIA    ] := aTabTno[nPos,18]																// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos
			aTabCalend[ nLenCalend	,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer																		// 37 - Se H.Extras são autorizadas para funcionario em ferias				
			aTabCalend[ nLenCalend	,   CALEND_POS_CODFUNC 		    ] := cFuncCal																		// 38 - Cod. de Funcao			
			aTabCalend[ nLenCalend  , 	CALEND_POS_DEPTO			] := cDepto																			// 39 - Codigo de Depto. do funcionario
			aTabCalend[ nLenCalend  , 	CALEND_POS_POSTO			] := cPosto																			// 40 - Codigo do Posto do funcionario
			aTabCalend[ nLenCalend  , 	CALEND_POS_PERIODO	   		] := cCodPer  																		// 41 - Periodo
			aTabCalend[ nLenCalend  , 	CALEND_POS_ROTEIRO			] := cCodRot  																		// 42 - Roterio
			aTabCalend[ nLenCalend  , 	CALEND_POS_PROCESSO			] := cCodPro  																		// 43 - Processo
			aTabCalend[ nLenCalend  , 	CALEND_POS_NUM_PAGTO		] := cNumPag  																		// 44 - Num. de Pagamento
			aTabCalend[ nLenCalend  , 	CALEND_POS_JORN		   		] := cCodJor 																		// 45 - Cod. da Jornada
			aTabCalend[ nLenCalend  , 	CALEND_POS_P2ID				] := "" 				   															// 46 - Lote da excecao
			aTabCalend[ nLenCalend	,   CALEND_POS_R8ID				] := cIdAfas																		// 47 - Identificacao afastamento
			aTabCalend[ nLenCalend	,   CALEND_POS_DATA_APO		    ] := dDataApo  																		// 48 - Data de apontamento					
			aTabCalend[ nLenCalend	, 	CALEND_POS_JND_CON			] := cJndCont																		// 49 - Jornada continua						
			aTabCalend[ nLenCalend  , 	CALEND_POS_LIE				] := nLimInfE 																		// 50 - Limite inferior da entrada
			aTabCalend[ nLenCalend  , 	CALEND_POS_LSE				] := nLimSupE																		// 51 - Limite superior da entrada
			aTabCalend[ nLenCalend  , 	CALEND_POS_LIS				] := nLimInfS																		// 52 - Limite inferior da saida
			aTabCalend[ nLenCalend  ,   CALEND_POS_LSS				] := nLimSupS 																		// 53 - Limite superior da saida			
			aTabCalend[ nLenCalend  , 	CALEND_POS_TPEXCE			] := ""
			
		Next nY

		nSerial		:= ( __fDhToNS( aTabCalend[ nLenCalend , CALEND_POS_DATA ] , aTabCalend[ nLenCalend , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31] ) )
		aMarcId[1]	:= __fNsToDh( nSerial , "D" )
		aMarcId[2]	:= __fNsToDh( nSerial , "H" )

		aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )																		// 17 - Limite de Marcacao Final

		If !lMVLimSup .and. nX == nFornX
			//Limite superior do ultimo dia deve ser igual o limite inferior da proxima jornada menos um
			If Dow( dData+1 ) == 2
				nSeq++
			EndIf
			
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica se o Dia da Semana da Sequencia e equivalente ao Dia³
			³da Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  com³
			³o StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
						  .and. x[20] == Dow(dData+1);
					 }
			If ( ( nPos := aScan( aTabTno, bAsc ) ) > 0 )
				nSerial		:= ( __fDhToNS( dData+1 , aTabTno[ nPos , 1 ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
			
				If aMarcId[2] > 0
					aMarcId[2]	:= SubHoras(aMarcId[2],0.01) 
				Else
					aMarcId[2] := 23.59
					aMarcId[1] := aMarcId[1] - 1
				EndIf				 
			
				aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )
			EndIf
		EndIf				

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se Nao eh jornada continua, os dias acrescidos no dia de    ³
		³ apontamento nao serao considerados.					      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	    If !lIncrementa
	       nDias	:= 0
		Else
		   //-- Desconsidera o ultimo incremento para considerar a ultima data incrementada
		   -- nDias
	    Endif

	Next nX                  

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Sincroniza horarios iniciais da tabela para evitar intervalos³
	³entre os limites inicial do dia corrente e final do dia  ante³
	³rior.														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lSncMaMe )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aDataApo	,;	//03 -> Array com as Datas de Apontamento do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					NIL   		,;	//09 -> Matricula do Funcionario
					NIL   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					.F.			 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
		   		   )
	EndIF	   		   

End Sequence

Return( lCriaCalOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstCalendCria	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em CalendCria()        	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstCalendCria()

__aLstTabCal	:= {}
__aLstTabTno	:= {}
__cKeyBldCal	:= "__cKeyBldCal"
__nFilTabTno	:= 0  
__aAllTnoOpc	:= {} 

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetTabCal		³Autor³Marinaldo de Jesus ³ Data ³18/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Array contendo __aLstTabCal e __aLstTabTno			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTabCal()

Local aTabsCal := Array( 03 )

aTabsCal[ 01 ] := aClone( __aLstTabCal )
aTabsCal[ 02 ] := aClone( __aLstTabTno )
aTabsCal[ 03 ] := __cKeyBldCal

Return( aClone( aTabsCal ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³SetTabCal		³Autor³Marinaldo de Jesus ³ Data ³18/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Restaura  __aLstTabCal e __aLstTabTno que foram salvos  pela³
³          ³GetTabCal()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetTabCal( aTabsCal )

__aLstTabCal	:= aClone( aTabsCal[ 01 ] )
__aLstTabTno	:= aClone( aTabsCal[ 02 ] )
__cKeyBldCal	:= aTabsCal[ 03 ]

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³CalSncMaMe  ³Autor³ Marinaldo de Jesus    ³ Data ³28/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Sincroniza o HorMais e HorMenos do Calendario de Marcacoes  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>	                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>	                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function CalSncMaMe(	aTabCalend	,;	//01 -> Calendario de Marcacoes
							aTabPadrao	,;	//02 -> Tabela de Horario Padrao
							aDataApo	,;	//03 -> Array com as Datas de Apontamento do Calendario
							dPerIni		,;	//04 -> Inicio do Periodo de Apontamento
							dPerFim		,; 	//05 -> Final do Periodo de Apontamento
							cTno		,;	//06 -> Turno de Trabalho
							cSeq		,;	//07 -> Sequencia de Turno
							cFil     	,;	//08 -> Filial do Funcionario
							cMat   		,;	//09 -> Matricula do Funcionario
							cCc   		,;	//10 -> Centro de Custo do Funcionario
							lMarcOrder	,;	//11 -> Marcacoes Sendo carregadas pela Ordem
							lCalendFunc	 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
				   		   )

Local aMarcId		:= {}
Local bHrsAtu		:= { |x| NIL }
Local bHrsAnt		:= { |x| NIL }
Local dDataAtu		:= ""
Local dDataAnt		:= ""
Local nPosCalAtu	:= 0
Local nPosCalAnt	:= 0
Local nPosCalUlt	:= 0
Local nLoop			:= 0
Local nLoops		:= Len( aDataApo )
Local nSerial		:= 0
Local nHrsAtu		:= 0
Local nHrsAnt		:= 0
Local nDifHrs		:= 0
Local nHorMeno		:= 0
Local nHorMais		:= 0
Local nFator		:= 0

IF ( nLoops >= 2.00 )
	bHrsAtu		:= { |x| IF(;
								( x[ CALEND_POS_DATA_APO ] == dDataAtu ) ,;
								nHrsAtu := SomaHoras( nHrsAtu , x[ CALEND_POS_HRS_TRABA ] ),;
								NIL;
							);
					}
	bHrsAnt		:= { |x| IF(;
								( x[ CALEND_POS_DATA_APO ] == dDataAnt ) ,;
								nHrsAnt := SomaHoras( nHrsAnt , x[ CALEND_POS_HRS_TRABA ] ),;
								NIL;
							);
					}
	For nLoop := 1 To nLoops
		dDataAtu	:= aDataApo[ nLoop ]
		nPosCalAtu	:= aScan( aTabCalend , { |x|;
													( x[ CALEND_POS_DATA_APO ] == dDataAtu ) .and.;
													( x[ CALEND_POS_TIPO_MARC ] == "1E" );
											},;
							  ++nPosCalAtu;
							)
		IF ( nLoop == 1 )
			IF ( nPosCalAtu > 0 )
				nSerial := RetSerIni(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
										@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
										dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
										dPerFim					,; 	//04 -> Final do Periodo de Apontamento
										cTno					,;	//05 -> Turno de Trabalho
										cSeq					,;	//06 -> Sequencia de Turno
										cFil     				,;	//07 -> Filial do Funcionario
										cMat   					,;	//08 -> Matricula do Funcionario
										cCc   					,;	//09 -> Centro de Custo do Funcionario
										lMarcOrder				,;	//10 -> Marcacoes Sendo carregadas pela Ordem
										lCalendFunc	 			 ;	//11 -> Se o Calendario esta sendo Montado por Funcionario
					   				 )
		  		aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
				aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
			EndIF	
		ElseIF ( nLoop == nLoops )
			IF (;
					(;
						nPosCalUlt := aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_DATA_APO ] == dDataAtu ) .and.;
																	!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																	( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
														 	  },;
												++nPosCalAtu;
									 		);
					) > 0;
				)	
				dDataAnt	:= aDataApo[ nLoop-1]
		   		nPosCalAnt	:= aScan( aTabCalend , { |x| ( x[ CALEND_POS_DATA_APO ] == dDataAnt ) .and.;
													 !Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
													 ( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
											   },;
								  ++nPosCalAnt;
								 )
				nHrsAnt		:= 0
				aEval( aTabCalend , bHrsAnt )
				IF ( nHrsAnt > 0 )
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) + ;
								   __fDhToNS( NIL , 0.01  );
								)         
				
					If ( __fDhToNS( aTabCalend[ nPosCalAtu, CALEND_POS_LIM_MARCACAO , 01 ] + aTabCalend[ nPosCalAtu, CALEND_POS_LIM_MARCACAO, 02 ], "D" ) < nSerial )
						nPosCalAnt := aScan(;
													aTabCalend , { |x|;
																		( x[ CALEND_POS_DATA_APO ] == dDataAtu ) .and.;
																		!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																		( x[ CALEND_POS_TIPO_MARC ] == "1E" );
															 	  },;
													++nPosCalAnt;
										 		)
						aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
						aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
					EndIf
				Endif		
				nSerial := RetSerFim(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
										@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
										dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
										dPerFim					,; 	//04 -> Final do Periodo de Apontamento
										cTno					,;	//05 -> Turno de Trabalho
										cSeq					,;	//06 -> Sequencia de Turno
										cFil     				,;	//07 -> Filial do Funcionario
										cMat   					,;	//08 -> Matricula do Funcionario
										cCc   					,;	//09 -> Centro de Custo do Funcionario
										lMarcOrder				,;	//10 -> Marcacoes Sendo carregadas pela Ordem
										lCalendFunc	 			 ;	//11 -> Se o Calendario esta sendo Montado por Funcionario
					   				 )
		  		aTabCalend[	nPosCalUlt , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
				aTabCalend[	nPosCalUlt , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
			EndIF
		Else
			dDataAnt	:= aDataApo[ nLoop - 1 ]
			nPosCalAnt	:= aScan( aTabCalend , { |x| ( x[ CALEND_POS_DATA_APO ] == dDataAnt ) .and.;
													 !Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
													 ( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
											   },;
								  ++nPosCalAnt;
								 )
			IF ( ( nPosCalAtu > 0 ) .and. ( nPosCalAnt > 0 ) )
				nHrsAtu		:= 0
				nHrsAnt		:= 0
				aEval( aTabCalend , bHrsAtu )
				aEval( aTabCalend , bHrsAnt )
				IF ( nHrsAnt > 0 )
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) + ;
								   __fDhToNS( NIL , 0.01  );
								)
					If ( __fDhToNS( aTabCalend[ nPosCalAtu, CALEND_POS_LIM_MARCACAO , 01 ] + aTabCalend[ nPosCalAtu, CALEND_POS_LIM_MARCACAO, 02 ], "D" ) < nSerial )
						aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
						aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
					EndIf
				ElseIF ( ( nHrsAnt == 0 ) .and. ( nHrsAtu == 0 ) )
					nHorMais	:= DataHora2Val(;
												aTabCalend[ nPosCalAnt , CALEND_POS_DATA ],;
												aTabCalend[ nPosCalAnt , CALEND_POS_HORA ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ],;
												"H";
											)
					nHorMeno	:= DataHora2Val(;
												aTabCalend[ nPosCalAtu , CALEND_POS_DATA ],;
												aTabCalend[ nPosCalAtu , CALEND_POS_HORA ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ],;
												"H";
											)
					nDifHrs := DataHora2Val(;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ] ;
											)
					nFator	:= ( nHorMais / ( nHorMais + nHorMeno ) )
					nDifHrs *= nFator
					nDifHrs := __NoRound( nDifHrs , 0 )
					nDifHrs := __Min2Hrs( nDifHrs )
					aMarcId := RetFimTab(	aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ]	,;	//01 -> Data da Primeira Marcacao
											aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	,;	//02 -> Hora da Primeira Marcacao
											nDifHrs									 				 ;	//03 -> Total de Horas a Trabalhar
										)										
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] := aMarcId[1]
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ] := aMarcId[2]
					aMarcId := RetFimTab(	aMarcId[1]	,;	//01 -> Data da Primeira Marcacao
											aMarcId[2]	,;	//02 -> Hora da Primeira Marcacao
											0.01		 ;	//03 -> Total de Horas a Trabalhar
										)										
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ] := aMarcId[1]
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ] := aMarcId[2]
				Else
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) - ;
								   __fDhToNS( NIL , 0.01  );
								)
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] := __fNsToDh( nSerial , "D" )
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ] := __fNsToDh( nSerial , "H" )
				EndIF
			EndIF
		EndIF
	Next nLoop
EndIF

Return( NIL )


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³TabMarc   ³ Autor ³ Marinaldo de Jesus    ³ Data ³12/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna numero de Elementos Permitidos para o Calendario    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>	                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>	                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function TabMarc( cAlias , aMarcs )

Local cCampo  	:= ""
Local cCampoE 	:= ""
Local cCampoS 	:= ""
Local cPrefixo	:= ""
Local nX      	:= 0
Local nCtaMarc	:= 0
Local nCampos 	:= 0

DEFAULT cAlias			:= Alias()
DEFAULT __aLstTbMarc	:= {}

cAlias	:= Upper( AllTrim( cAlias ) )
aMarcs	:= {}

IF ( ( nX := aScan( __aLstTbMarc , { |x| x[1] == cAlias } ) ) > 0 )

	aMarcs		:= aClone( __aLstTbMarc[ nX , 02 ] )
	nCtaMarc	:= __aLstTbMarc[ nX , 03 ]

Else

	cPrefixo := PrefixoCpo( cAlias )

	cCampoE := ( cPrefixo + "_ENTRA" )
	cCampoS := ( cPrefixo + "_SAIDA" )

	nCampos := ( cAlias )->( fCount() )
	For nX := 1 To nCampos
		cCampo := ( cAlias )->( FieldName( nX ) )
		IF ( SubStr( cCampo , 1 , 8 ) == cCampoE ) .or. ( SubStr( cCampo , 1 , 8 ) == cCampoS )
			aAdd( aMarcs , SubStr( cCampo , 9 , 1 ) + SubStr( cCampo , 4 , 1 ) )
		EndIF
	Next nX

	aSort( @aMarcs )
	aAdd( __aLstTbMarc , { cAlias , aClone( aMarcs ) , ( nCtaMarc := Len( aMarcs ) ) } )

EndIF

Return( nCtaMarc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ GravaSPC ³ Autor ³ Equipe Advanced RH    ³ Data ³10/04/1996³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Grava o resultado no SPC.                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ GravaSPC()                                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GravaSPC(	aResult		,;	//01 -> Array com os Resultados a serem Gravados
					cFil		,;	//02 -> Filial do Funcionario
					cMat		,;	//03 -> Matricula do Funcionario
					cEveMesA	,;	//04 -> Eventos do Mes Anterior que nao poderao ser apagados
					dPerIni		,;	//05 -> Periodo Inicial
					dPerFim		,;	//06 -> Periodo Final
					aAbonosPer	 ;	//07 -> Array com Todos os Abonos no Periodo
				)

Local aSPC			:= {}
Local cFilMat		:= ( cFil + cMat )
Local cAlias		:= "SPC"
Local cAliasQuery	:= cAlias
Local cSvFilAnt		:= cFilAnt
Local nOrder		:= RetOrdem( "SPC" , "PC_FILIAL+PC_MAT+PC_PD+DTOS(PC_DATA)+PC_TPMARCA+PC_CC+PC_DEPTO+PC_POSTO+PC_CODFUNC" )
Local nSvOrder		:= SPC->( IndexOrd() )

Local aAbonos
Local aInfAbonos
Local aPreAbonos
Local aNewAbonos
Local cCodAbono
Local cMsgErr
Local nPos
Local nX
Local nFornX
Local nLenSPC
Local nHrsAbono
Local nHrsPreAbono


#IFDEF TOP

	Local aTamQuantC		:= {}
	Local aTamAbonos		:= {}
	Local cIniData	 		:= ""
	Local cFimData			:= ""
	Local cQuery	 		:= ""
	Local cSvAlias			:= Alias()
	Local cTableName		:= ""
	Local cCpoRecno			:= ""
	Local lQueryOpened		:= .F.

	Static aSpcFields
	Static cQrySpcFields
	Static nSpcFields

	IF !( lExInAs400 )
	
		DEFAULT aSpcFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpcFields := Len( aSpcFields )

		IF ( cQrySpcFields == NIL )
			cQrySpcFields := ""
			For nX := 1 To nSpcFields
				cQrySpcFields += aSpcFields[ nX , 01 ] + ", "
			Next nX
	    EndIF

	EndIF	    

#ENDIF

DEFAULT cEveMesA		:= ""
DEFAULT lRF0ChkTable	:= fVerTabRF0()  	//Verifica a Existencia da Tabela de Pre-Abonos e se a mesm possui registro
DEFAULT __cLimpaMotAbo	:= Space( TamSx3("PC_ABONO")[1] )	//Variavel auxiliar para preencher em branco o campo Motivo do Abono

cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )

bAsc   := { |x|	x[1] == aResult[ nX , ARESULT_DATA		];
				.and.;
				x[2] == aResult[ nX , ARESULT_EVENTO	];
				.and.;
				x[5] == aResult[ nX , ARESULT_CC		];
				.and.;
				x[6] == aResult[ nX , ARESULT_TPMARCA	];
				.and.;
				x[10] == aResult[ nX , ARESULT_FUNCAO	];		
				.and.;
				x[11] == aResult[ nX , ARESULT_DEPTO 	];	
   				.and.;
				x[12] == aResult[ nX , ARESULT_POSTO 	];	
				.and.;
				x[13] == aResult[ nX , ARESULT_PROCESSO];	
				.and.;
				x[14] == aResult[ nX , ARESULT_PERIODO	];	
				.and.;
				x[15] == aResult[ nX , ARESULT_ROTEIRO	];																				
				.and.;
				x[16] == aResult[ nX , ARESULT_NUM_PAGTO	];	  
		  } 

IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIF


#IFNDEF TOP

	IF SPC->( dbSeek( cFilMat  , .F. ) )

#ELSE

	IF ( lExInAs400 )

		SPC->( dbSeek( cFilMat  , .F. ) )

	Else

		aTamQuantC	:= TamSx3("PC_QUANTC")
		aTamAbonos	:= TamSx3("PC_QTABONO")
		cTableName	:= InitSqlName( cAlias )
		cCpoRecno	:= IF( lExInAs400 , "RRN("+cTableName+")", "R_E_C_N_O_" )
		cIniData	:= Dtos( dPerIni )
		cFimData	:= Dtos( dPerFim )
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
		cQuery := "SELECT "
		cQuery += cQrySpcFields
		cQuery += "R_E_C_N_O_ RECNO"
		cQuery += " FROM "
		cQuery += cTableName
		cQuery += " WHERE "
		cQuery += "PC_FILIAL='"+cFil+"'"
		cQuery += " AND "
		cQuery += "PC_MAT='"+cMat+"'"
		cQuery += " AND "
		cQuery += "( "
		cQuery += 		"PC_DATA>='"+cIniData+"' AND "
		cQuery += 		"PC_DATA<='"+cFimData+"'"
		cQuery += " )"
		cQuery += " AND "
		cQuery += "D_E_L_E_T_=' ' "
		cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
		cQuery := ChangeQuery( cQuery )
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nSpcFields
				IF !( aSpcFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQuery,aSpcFields[nX,01],aSpcFields[nX,02],aSpcFields[nX,03],aSpcFields[nX,04])
				EndIF
			Next nX
			cQuery := ""
		Else
			cAliasQuery	:= cAlias
			( cAliasQuery )->( dbSeek( cFilMat  , .F. ) )
		EndIF
	
    EndIF

#ENDIF

		While ( cAliasQuery )->( !Eof() .and. ( PC_FILIAL + PC_MAT ) == cFilMat )
			IF ( cAliasQuery )->( ( PC_DATA >= dPerIni ) .and. ( PC_DATA <= dPerFim ) )
				aAdd( aSPC , Array( 16 ) )
				nLenSPC := Len( aSPC )
				aSPC[ nLenSPC , 01 ] := ( cAliasQuery )->( PC_DATA		)
				aSPC[ nLenSPC , 02 ] := ( cAliasQuery )->( PC_PD		)
				aSPC[ nLenSPC , 03 ] := ( cAliasQuery )->( PC_QUANTC	)
				aSPC[ nLenSPC , 04 ] := ( cAliasQuery )->( PC_QUANTI	)
				aSPC[ nLenSPC , 05 ] := ( cAliasQuery )->( PC_CC		)
				aSPC[ nLenSPC , 06 ] := ( cAliasQuery )->( PC_TPMARCA	)
				#IFNDEF TOP
					aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( Recno() )
				#ELSE
					IF !( lQueryOpened )
						aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( Recno() )
					Else
						aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( RECNO )
					EndIF
				#ENDIF
				aSPC[ nLenSPC , 08 ] := ( cAliasQuery )->( PC_ABONO		)
				aSPC[ nLenSPC , 09 ] := ( cAliasQuery )->( PC_QTABONO 	)
				aSPC[ nLenSPC , 10 ] := ( cAliasQuery )->( PC_CODFUNC	)				
				aSPC[ nLenSPC , 11 ] := ( cAliasQuery )->( PC_DEPTO  	)				
				aSPC[ nLenSPC , 12 ] := ( cAliasQuery )->( PC_POSTO  	)				
				aSPC[ nLenSPC , 13 ] := ( cAliasQuery )->( PC_PROCES	)				
				aSPC[ nLenSPC , 14 ] := ( cAliasQuery )->( PC_PERIODO	)				
				aSPC[ nLenSPC , 15 ] := ( cAliasQuery )->( PC_ROTEIR	)				
				aSPC[ nLenSPC , 16 ] := ( cAliasQuery )->( PC_NUMPAG	)				

			EndIF
			( cAliasQuery )->( dbSkip() )
		End While

#IFNDEF TOP

	EndIF

#ELSE

	IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
		( cAliasQuery )->( dbCloseArea() )
		dbSelectArea( cSvAlias )
	EndIF	

#ENDIF	

nLenSPC := Len( aSPC )

nFornX := Len( aResult )
For nX := 1 To nFornX

	IF ( ( aResult[ nX , ARESULT_DATA ] >= dPerIni ) .and. ( aResult[ nX , ARESULT_DATA ] <= dPerFim ) )

		nHrsAbono	:= fAbonos( aResult[ nX , ARESULT_DATA 		] , aResult[ nX , ARESULT_EVENTO ] , NIL , @aAbonos , aResult[ nX , ARESULT_TPMARCA ] , ;
								aResult[ nX , ARESULT_CC 		] , aAbonosPer, aResult[ nX , ARESULT_FUNCAO	] ,;
								aResult[ nX , ARESULT_DEPTO 	] , aResult[ nX , ARESULT_POSTO 	] ,;								
								aResult[ nX , ARESULT_PROCESSO	] , aResult[ nX , ARESULT_PERIODO 	] ,;								
								aResult[ nX , ARESULT_ROTEIRO	] , aResult[ nX , ARESULT_NUM_PAGTO	] ;																
								)
		fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] == "P" } , { |x| x[ AABONOS_FLAG ] <> "P" } , @aInfAbonos )
		cCodAbono	:= IF( !Empty( aInfAbonos ) , aInfAbonos[ 01 , AABONOS_CODIGO ] , __cLimpaMotAbo )
        aNewAbonos	:= {}

	    IF ( ( lRF0ChkTable ) .and. Empty( aInfAbonos ) )

			aNewAbonos	:= aResult[ nX , ARESULT_RESULT_APO ]
			nHrsPreAbono := fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] <> "P"} , { |x| x[ AABONOS_FLAG ] == "P"} , @aPreAbonos )
		    
		    nHrsAbono	:= SubHoras( nHrsAbono , nHrsPreAbono )
		    nHrsAbono	:= SomaHoras( nHrsAbono ,  aResult[ nX , ARESULT_NUM_ABO_HRS]) //01 -> Array com as Horas Abonadas para o Evento do Dia (Evento + Tipo Marc + C.Custo)
			
			cCodAbono	:= IF( !Empty( aInfAbonos ) , aInfAbonos[ 01 , AABONOS_CODIGO ] , IF( !Empty( aNewAbonos ) , aNewAbonos[ 01 , AABONOS_CODIGO ] , __cLimpaMotAbo ) )

        EndIF
		
       	cCodAbono	:= IF( !Empty( cCodAbono ) , cCodAbono , __cLimpaMotAbo )
		IF ( ( nPos := aScan( aSPC , bAsc ) ) > 0 )
			IF ( aSPC[ nPos , 7 ] == 0 ) //Eof()
				Loop //Existem Apontamentos Duplicados.... Isso nao Pode Ocorrer....
			EndIF
			IF (;
					( aSPC[ nPos , 3 ] <> aResult[ nX , ARESULT_HORAS ] );
					.or.;
					( aSPC[ nPos , 8 ] <> cCodAbono );
					.or.;
					( aSPC[ nPos , 9 ] <> nHrsAbono );
				)	
				( cAlias )->( dbGoTo( aSPC[ nPos , 7 ] ) )
				#IFNDEF TOP
					IF RecLock( cAlias , .F. , .F. )
						( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS		]
						( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC			]
						( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
						( cAlias )->( PC_QTABONO	)	:= nHrsAbono
						( cAlias )->( PC_ABONO		)	:= cCodAbono
						( cAlias )->( PC_CODFUNC	)	:= aResult[ nX , ARESULT_FUNCAO		] 
						( cAlias )->( PC_DEPTO		)	:= aResult[ nX , ARESULT_DEPTO		]	
						( cAlias )->( PC_POSTO		)	:= aResult[ nX , ARESULT_POSTO		]				
						( cAlias )->( PC_PROCES		)	:= aResult[ nX , ARESULT_PROCESSO	]										
						( cAlias )->( PC_PERIODO	)	:= aResult[ nX , ARESULT_PERIODO	]				
						( cAlias )->( PC_ROTEIR		)	:= aResult[ nX , ARESULT_ROTEIRO	]	
						( cAlias )->( PC_NUMPAG		)	:= aResult[ nX , ARESULT_NUM_PAGTO	]							
						( cAlias )->( MsUnLock() )
					EndIF	
				#ELSE
					IF ( lExInAs400 )
						IF RecLock( cAlias , .F. , .F. )
							( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS 		]
							( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC 		]
							( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
							( cAlias )->( PC_QTABONO	)	:= nHrsAbono
							( cAlias )->( PC_ABONO		)	:= cCodAbono  
							( cAlias )->( PC_CODFUNC	)	:= aResult[ nX , ARESULT_FUNCAO		]	  
							( cAlias )->( PC_DEPTO		)	:= aResult[ nX , ARESULT_DEPTO		]	
							( cAlias )->( PC_POSTO		)	:= aResult[ nX , ARESULT_POSTO		]				
							( cAlias )->( PC_PROCES		)	:= aResult[ nX , ARESULT_PROCESSO	]										
							( cAlias )->( PC_PERIODO	)	:= aResult[ nX , ARESULT_PERIODO	]				
							( cAlias )->( PC_ROTEIR		)	:= aResult[ nX , ARESULT_ROTEIRO	]	
							( cAlias )->( PC_NUMPAG		)	:= aResult[ nX , ARESULT_NUM_PAGTO	]														
							( cAlias )->( MsUnLock() )
						EndIF
					Else
						cQuery := "UPDATE "
						IF ( lExInAs400 )
							cQuery += _cDataBase+"/"+cTableName
						Else
							cQuery += cTableName
						EndIF	
						cQuery += " SET "
						cQuery += "PC_QUANTC="		+ Str( aResult[ nX , ARESULT_HORAS ] , aTamQuantC[1] , aTamQuantC[2] )
						cQuery += ", "
						cQuery += "PC_CC='"			+ aResult[ nX , ARESULT_CC ] + "'"
						cQuery += ", "
						cQuery += "PC_TPMARCA='"	+ aResult[ nX , ARESULT_TPMARCA ] + "'"
						cQuery += ", "
						cQuery += "PC_QTABONO="		+ Str( nHrsAbono , aTamAbonos[1] , aTamAbonos[2] )
						cQuery += ", "
						cQuery += "PC_CODFUNC='"	+ aResult[ nX , ARESULT_FUNCAO ] + "'"						
						cQuery += ", " 
						cQuery += "PC_DEPTO='"		+ aResult[ nX , ARESULT_DEPTO ] + "'"						
						cQuery += ", "
						cQuery += "PC_POSTO='"		+ aResult[ nX , ARESULT_POSTO ] + "'"						
						cQuery += ", "
						cQuery += "PC_PROCES='"		+ aResult[ nX , ARESULT_PROCESSO] + "'"						
						cQuery += ", "
						cQuery += "PC_PERIODO='"	+ aResult[ nX , ARESULT_PERIODO ] + "'"						
						cQuery += ", "
						cQuery += "PC_ROTEIR ='"	+ aResult[ nX , ARESULT_ROTEIRO ] + "'"						
						cQuery += ", "
						cQuery += "PC_NUMPAG='"		+ aResult[ nX , ARESULT_NUM_PAGTO] + "'"						
						cQuery += ", "																																				
						cQuery += "PC_ABONO='"		+ cCodAbono + "'"
						cQuery += " WHERE " 
						cQuery += cCpoRecno + "=" + Str( aSPC[ nPos , 7 ] , 10 , 0 )
						TcSqlExec( cQuery )
						cQuery := ""
					EndIF
				#ENDIF
			EndIF
			aSPC[ nPos , 7 ] := 0
		Else
			IF RecLock( cAlias , .T. , .F. )
				( cAlias )->( PC_FILIAL		)	:= cFil
				( cAlias )->( PC_MAT		)	:= cMat
				( cAlias )->( PC_DATA		)	:= aResult[ nX , ARESULT_DATA		]
				( cAlias )->( PC_PD			)	:= aResult[ nX , ARESULT_EVENTO 	]
				( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS  	]
				( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC			]
				( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
				( cAlias )->( PC_QTABONO	)	:= nHrsAbono
				( cAlias )->( PC_ABONO		)	:= cCodAbono                        
				( cAlias )->( PC_CODFUNC	)	:= aResult[ nX , ARESULT_FUNCAO		]				
				( cAlias )->( PC_DEPTO		)	:= aResult[ nX , ARESULT_DEPTO		]	
				( cAlias )->( PC_POSTO		)	:= aResult[ nX , ARESULT_POSTO		]				
				( cAlias )->( PC_PROCES		)	:= aResult[ nX , ARESULT_PROCESSO	]										
				( cAlias )->( PC_PERIODO	)	:= aResult[ nX , ARESULT_PERIODO	]				
				( cAlias )->( PC_ROTEIR		)	:= aResult[ nX , ARESULT_ROTEIRO	]	
				( cAlias )->( PC_NUMPAG		)	:= aResult[ nX , ARESULT_NUM_PAGTO	]				
				( cAlias )->( MsUnLock() )
			EndIF
		EndIF

		DelAbo( aPreAbonos )

		IF !Empty( aNewAbonos )

			GravaAbo( 	cFil								,;	//01 -> Filial do Funcionario
						cMat								,;	//02 -> Matricula do Funcionario
						aNewAbonos				    		,;	//03 -> Horarios do Apontamento Abonado
						aResult[ nX , ARESULT_DATA		]	,;	//04 -> Data da Geracao
						aResult[ nX , ARESULT_EVENTO	]	,;	//05 -> Codigo do Evento
						aResult[ nX , ARESULT_CC		]	,;	//06 -> Centro de Custo a ser Gravado
						aResult[ nX , ARESULT_TPMARCA	]	,;	//07 -> Tipo de Marcacao   
						aResult[ nX , ARESULT_FUNCAO	]	,;	//08 -> Funcao a ser Gravado
						aResult[ nX , ARESULT_DEPTO		]	,;	//09 -> Depto a ser Gravado						
						aResult[ nX , ARESULT_POSTO 	]	,;	//10 -> Posto a ser Gravado
						aResult[ nX , ARESULT_PROCESSO	]	,;	//11 -> Processo a ser Gravado										
						aResult[ nX , ARESULT_PERIODO	]	,;	//12 -> Periodo a ser Gravado
						aResult[ nX , ARESULT_ROTEIRO	]	,;	//13 -> Roteiro a ser Gravado											
						aResult[ nX , ARESULT_NUM_PAGTO	]	;	//14 -> Numero de Pagamamento (Semana)a ser Gravado
					) 
		EndIF
		
	EndIF

Next nX

For nX := 1 To nLenSPC
	IF (;
			( aSPC[ nX , 7 ] > 0 );
			.and.;
			( aSPC[ nX , 4 ] == 0 );
			.and.;
			!( aSPC[ nX , 02 ] $ cEveMesA );
		 )
		( cAlias )->( dbGoTo( aSPC[ nX , 7 ] ) )
		IF RecLock( cAlias , .F. , .F. )
			IF !( cAlias )->( FkDelete( @cMsgErr ) )
				( cAlias )->( RollBackDelTran( cMsgErr ) )
			EndIF
			( cAlias )->( MsUnLock() )
		EndIF
		fAbonos( ;
					aSPC[ nX , 01 ] ,;
					aSPC[ nX , 2 ] 	,;
					NIL 			,;
					@aAbonos 		,;
					aSPC[ nX , 6 ] 	,;
					aSPC[ nX , 5 ] 	,;
					aAbonosPer		,;
					aSPC[ nX , 10 ] ,;    
					aSPC[ nX , 11 ] ,;
					aSPC[ nX , 12 ] ,;
					aSPC[ nX , 13 ] ,;
					aSPC[ nX , 14 ] ,;
					aSPC[ nX , 15 ] ,;
					aSPC[ nX , 16 ] ;
				)
		fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] <> "P" } , { |x| x[ AABONOS_FLAG ] == "P" } , @aPreAbonos )
		DelAbo( aPreAbonos )
	EndIF
Next nX

IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nSvOrder ) )
EndIF

cFilAnt	:= cSvFilAnt

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GravaAbo  ³ Autor ³ Mauricio MR           ³ Data ³10/05/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Grava o Abonos no SPK.		                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gravacao dos Pre-Abonos no SPK                              ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GravaAbo(	cFil						,;	//01 -> Filial do Funcionario
							cMat						,;	//02 -> Matricula do Funcionario
							aHorarios				    ,;	//03 -> Horarios do Apontamento Abonado
							dDtGer						,;	//04 -> Data da Geracao
							cEvento						,;	//05 -> Codigo do Evento
							cCusto   					,;	//06 -> Centro de Custo a ser Gravado
							cTpMarc						,;	//07 -> Tipo de Marcacao  
							cFuncao						,;   //08 -> Funcao
							cDepto						,;   //09 -> Depto 
							cPosto 						,;   //10 -> Posto  
							cProcesso					,;   //11 -> Processo					
							cPeriodo					,;   //12 -> Periodo
							cRoteiro					,;   //13 -> Roteiro
							cNumPagto					;   //14 -> NumPagto
						 ) 

Local lPkTpMarca	:= ( Type( "SPK->PK_TPMARCA" ) == "C" )

Local nLoop
Local nLoops

nLoops := Len( aHorarios )
For nLoop := 1 To nLoops
	
	IF SPK->( RecLock( "SPK" , .T. , .F. ) )
		SPK->PK_FILIAL	:= cFil
		SPK->PK_MAT		:= cMat
		SPK->PK_CODABO	:= aHorarios[ nLoop , AABONOS_CODIGO ] 
		SPK->PK_CODEVE	:= cEvento
	    SPK->PK_DATA	:= dDtGer
		SPK->PK_CC		:= cCusto
		SPK->PK_HRSABO	:= aHorarios[ nLoop , AABONOS_HORAS_ABO	] 
		SPK->PK_HORINI	:= aHorarios[ nLoop , AABONOS_HORAS_INI	]
		SPK->PK_HORFIM	:= aHorarios[ nLoop , AABONOS_HORAS_FIM	] 
		IF ( lPkTpMarca )
			SPK->PK_TPMARCA	:= cTpMarc
		EndIF
		SPK->PK_FLAG		:= "P"
		SPK->PK_CODFUNC		:= cFuncao
		SPK->PK_DEPTO   	:= cDepto
		SPK->PK_POSTO  		:= cPosto		
		SPK->PK_PROCES  	:= cProcesso
		SPK->PK_PERIODO 	:= cPeriodo
		SPK->PK_ROTEIR		:= cRoteiro 
		SPK->PK_NUMPAG		:= cNumPagto
	SPK->( MsUnLock() )
	EndIF        

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Altera Flag da Faixa de Pre-Abono							  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/	
	RF0->( dbgoto( aHorarios[ nLoop , ELEMENTOS_AABONOS + 1 ] ) )
	
	If	RF0->RF0_ABONA <> 'S'
		IF RecLock( 'RF0' , .F. , .F. )
		   RF0->RF0_ABONA := 'S' 
		   RF0->( MsUnLock() )	
        Endif
	Endif 

Next nLoop

aHorarios := {}

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ DelAbo   ³ Autor ³ Mauricio MR           ³ Data ³13/05/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Deleta Abonos no SPK.		                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ Vide Parametros                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function DelAbo( aPreAbonos ) //01 -> Array de Abonos Pre-Abonados

Local cMsgErr
Local nLoop
Local nLoops

DEFAULT aPreAbonos := {}

nLoops := Len( aPreAbonos )
For nLoop := 1 To nLoops
	SPK->( dbGoto( aPreAbonos[ nLoop , AABONOS_RECNO ] ) )
	IF ( SPK->( Recno() ) == aPreAbonos[ nLoop , AABONOS_RECNO ] )
		IF RecLock( "SPK" , .F. , .F. )
			IF !SPK->( FkDelete( @cMsgErr ) )
				SPK->( RollBackDelTran( cMsgErr ) )
			EndIF
			SPK->( MsUnLock() )
		EndIF
	EndIF	
Next nLoop

aPreAbonos := {}

Return( NIL )




/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fFiltAbo		³Autor³Mauricio MR		  ³ Data ³12/05/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtra Abonos											    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                  	                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fFiltAbo( aAbonos , bSkip , bCondRet , aRetorno )

Local nHrsAbo	:= 0

Local nLoop
Local nLoops

DEFAULT aAbonos		:= {}
DEFAULT bSkip 		:= { || .F. }
DEFAULT bCondRet 	:= { || .T. }

aRetorno := {}

nLoops := Len( aAbonos )
For nLoop := 1 To nLoops
    IF Eval( bSkip , aAbonos[ nLoop ] )
       Loop
    EndIF
	IF Eval( bCondRet , aAbonos[ nLoop ] )
	   aAdd( aRetorno , aAbonos[ nLoop ] )
	EndIF
	nHrsAbo := SomaHoras( nHrsAbo , aAbonos[ nLoop , AABONOS_HORAS_ABO	] )
Next nLoop

Return( nHrsAbo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PerAponta ³ Autor ³ Equipe Advanced RH    ³ Data ³14/04/1997³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna a data inicio e fim para apontamento das marcacoes. ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³          ³Obs.:Quando a Data Inicial e Maior que a Data Final a fun‡„o³
³          ³ir  considerar que o apontamento ‚ feito de um mes para   ou³
³          ³tro, e quando a Data Final for maior que a Data Inicial,   a³
³          ³fun‡„o ir  considerar que o apontamento ‚ feito no mˆs.     ³
³          ³Caso a dData nao for passado assume a dDataBase do Sistema. ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PerAponta(		dPerIni			,;	//Data Inicial passada como referencia
						dPerFim 		,;	//Data Final   passada como referencia
						dData			,;	//Data Base
						lShowHelp		,;	//Mostrar o Help
						cFil			,;	//Filial para GetMv
						lNewPer			,;	//Se eh para gerar um novo periodo
						lPerCompleto	,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
						lIncDate		,;	//Se Quando lNewPer Incrementa Data, caso contrario Decrementa
						lUseParamPer	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
				 )

Local cSvFilAnt			:= cFilAnt
Local lPerNotOk			:= .F.

Local cDiaIni
Local cDiaFim
Local cMesIni
Local cMesFim
Local cAnoIni
Local cAnoFim
Local cPerAponta
Local nDiaIni
Local nDiaFim

DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT dData			:= dDataBase
DEFAULT lShowHelp		:= .T.
DEFAULT cFil			:= cSvFilAnt
DEFAULT lNewPer			:= .F.
DEFAULT lIncDate		:= .T.
DEFAULT lUseParamPer	:= .F.

lPerCompleto		:= .F.

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica o Modo de Acesso do Cadastro de Periodos de Apontamen³
	³to															   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lPerNotOk := CheckModSPO() )
		Break
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se o Conteudo do  MV_PAPONTA esta OK  			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lPerNotOk := !PapontaOk( @cPerAponta , @nDiaIni , @nDiaFim , cFil ) )
		Break
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Para Possibilitar que o periodo seja definido pelo    usuario³
	³ Este devera ser preenchido com a String de Data da   Seguinte³
	³ te forma AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD. Onde AAAA cor³
	³ responde ao ano com 4 digitos, MM ao mes com 2 digitos e   DD³
	³ corresponde ao dia com 2 Digitos. A barra (/) separadora   se³
	³ servira apenas para facilitar a leitura do periodo pelo  usua³
	³ rio. Essa forma de Preenchimento do Parametro ira   facilitar³
	³ as Empresas que reduzem ou aumentam o periodo em  determinado³
	³ mes. Obs.: Essa forma de preenchimento devera ser   utilizada³
	³ apenas para os meses em que o periodo for diferente do padrao³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lPerCompleto := PerCompleto( @cPerAponta ) )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Quando Nao Considerar as Datas Passadas Redefine-as   conferme³
		³conteudo de MV_PAPONTA										   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !( lUseParamPer )
			dPerIni := Stod( Left(	cPerAponta , 08 ) )
			dPerFim := Stod( Right(	cPerAponta , 08 ) )
		EndIF	

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Quando for um novo Periodo Incrementa ou Decrementa		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lNewPer )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Apura o Novo periodo baseado no numero de dias do periodo ante³
			³rior														   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lIncDate )
				PonIncDate( @dPerIni , @dPerFim )
			Else
				PonDecDate( @dPerIni , @dPerFim )
			EndIF	
		EndIF

		Break

	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³A Principio, Inicio ‚ no mes corrente.						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( nDiaIni > nDiaFim )

		cMesIni := Month2Str( dData )
		cAnoIni := Year2Str( dData )
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Acrescenta um dia ao Periodo Inicial se Inicio do Periodo for ³
		³>= 29 e Mes Fev.											   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
				(;
					( Month( dPerIni ) == 2 );
					.or.;
					( ( Month( dPerIni ) - 1 )  == 2 );
				);
				.and.;
				( nDiaIni >= 29 );
			)	
			IF ( Day( dPerIni ) != nDiaIni )
				dPerIni++
			EndIF
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se Inicio for Apos Data-Base, Retrocede 1 mes.				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( dPerIni > dData )
			cMesIni := Month2Str( IF( Month( dData ) - 1 == 0 , 12 , Month( dData ) -1 ) )
			cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dData) - 1 , Year( dData ) ) )
			cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³A Principio, Data Final ‚ 1 mes apos a data Inicial.		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cMesFim := Month2Str( IF( Month( dPerIni ) + 1 == 13 , 1 , Month( dPerIni ) + 1 ) )
		cAnoFim := Year2Str( IF( cMesFim == "01" , Year( dPerIni ) + 1 , Year( dPerIni ) ) )
		cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³A Data Final ‚ no mesmo mes da Data Inicio.				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( dPerFim - dPerIni ) > 50 )
			cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerFim := Ctod( cDiaFim + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Acrescenta um dia ao Periodo Inicial quando o dia deste    for³
		³igual ao do Periodo Final									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
				(;
					( Day( dPerIni ) == Day( dPerFim ) );
					.or.;
					( Day( dPerIni ) < Day( dPerFim ) );
		    	);
		    	.and.;
		    	( AnoMes( dPerIni ) != AnoMes( dPerFim ) );
		   ) 
			dPerIni++
		EndIF

		Break

	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³A Principio, Final ‚ no mes corrente.						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cMesFim := Month2Str( dData )
	cAnoFim := Year2Str( dData )
	cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
	dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se Final for Antes da Data-Base, Avan‡a 1 mes.				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( dPerFim < dData )
		cMesFim := Month2Str( IF( Month( dData ) + 1 == 13 , 1 , Month( dData ) +1 ) )
		cAnoFim := Year2Str( IF( cMesFim == "01" , Year( dData ) + 1 , Year( dData ) ) )
		cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim +"/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³A Principio, Data Inicial ‚ 1 mes anterior a data Final.	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cMesIni := Month2Str( IF( Month( dPerFim ) - 1 == 0 , 12 , Month( dPerFim ) -1 ) )
	cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dPerFim) - 1 , Year( dPerFim ) ) )
	cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
	dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³A Data Inicial ‚ no mesmo mes da Data Final.				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( dPerFim - dPerIni ) > 50 ) 
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
	EndIF

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se ocorreu alguma Inconsistencia Verifica se Deve Mostrar   o³
³ Help														   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lPerNotOk )
	IF ( lShowHelp ) .AND. !IsInCallStack("GPEA240")
		Help("" , 1 , "PERNCAD" )
	EndIF	
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura cFilAnt											   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilAnt := cSvFilAnt
	
Return( !( lPerNotOk ) )

 
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerAtu		³Autor³Marinaldo de Jesus ³ Data ³25/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Disponibilizar Dialogo para Alteracao do Periodo 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>     								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Pona080Calend												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerAtu( dDataIni , dDataFim , oDataIni , oDataFim )

GetPonMesDat( @dDataIni , @dDataFim  , xFilial("SRA") )
IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerPrev		³Autor³Marinaldo de Jesus ³ Data ³25/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Disponibilizar Dialogo para Alteracao do Periodo 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>     								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Pona080Calend												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerPrev(	dDataIni	,;
						dDataFim	,;
						oDataIni	,;
						oDataFim	,;
						lShowHelp	,;
						lGetNewPer	,;
						lIncDate	,;
						lUseParamPer ;
					)

Local dData := ( dDataIni - 1 )

Local nFimPer
Local nDay

DEFAULT lShowHelp		:= .T.
DEFAULT lGetNewPer		:= .T.
DEFAULT lIncDate		:= .F.
DEFAULT lUseParamPer	:= .T.

IF PapontaOk( NIL , NIL , @nFimPer )
	IF ( nFimPer <> NIL )
		nDay := Day( dData )
		IF ( nDay > nFimPer )
			While ( Day( dData ) <> nFimPer )
				--dData	
			End While
		EndIF	
	EndIF
EndIF

PerAponta(	@dDataIni 		,;	//Data Inicial passada como referencia
			@dDataFim 		,;	//Data Final   passada como referencia
			dData			,;	//Data Base
			lShowHelp		,;	//Mostrar o Help
			xFilial("SRA")	,;	//Filial para GetMv
			lGetNewPer		,;	//Se eh para gerar um novo periodo
			NIL				,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
			lIncDate		,;  //Se Quando lNewPer Incrementa Data, caso contrario Decrementa
			lUseParamPer  	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
		  )

IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerNext		³Autor³Marinaldo de Jesus ³ Data ³25/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Disponibilizar Dialogo para Alteracao do Periodo 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>     								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Pona080Calend												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerNext(	dDataIni 	,;
						dDataFim 	,;
						oDataIni 	,;
						oDataFim 	,;
						lShowHelp	,;
						lGetNewPer	,;
						lIncDate	,;
						lUseParamPer ;
					)

Local dData := ( dDataFim + 1 )

Local nIniPer
Local nDay

DEFAULT lShowHelp		:= .T.
DEFAULT lGetNewPer		:= .T.
DEFAULT lIncDate		:= .T.
DEFAULT lUseParamPer    := .T.

IF PapontaOk( NIL , @nIniPer )
	IF ( nIniPer <> NIL )
		nDay := Day( dData )
		IF ( nDay < nIniPer )
			While ( Day( dData ) <> nIniPer )
				++dData	
			End While
		EndIF	
	EndIF
EndIF

PerAponta(	@dDataIni 		,;	//Data Inicial passada como referencia
			@dDataFim 		,;	//Data Final   passada como referencia
			dData			,;	//Data Base
			lShowHelp		,;	//Mostrar o Help
			xFilial("SRA")	,;	//Filial para GetMv
			lGetNewPer		,;	//Se eh para gerar um novo periodo 
			NIL				,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
			lIncDate		,;  //Se Quando lNewPer Incrementa Data, caso contrario Decrementa
			lUseParamPer 	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
		  )

IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerSPO		³Autor³Marinaldo de Jesus ³ Data ³29/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna consulta SXB ao RPO                      			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>     								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Pona080Calend												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerSPO( dDataIni , dDataFim , oDataIni , oDataFim )

IF ( PerApoConPad() )
	dDataIni := SPO->PO_DATAINI
	dDataFim := SPO->PO_DATAFIM
	IF ( ValType( oDataIni ) == "O" )
		oDataIni:Refresh()
	EndIF	
	IF ( ValType( oDataFim ) == "O" )
		oDataFim:Refresh()
	EndIF	
EndIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetPaponta ³ Autor ³ Marinaldo de Jesus   ³ Data ³30/06/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem o Conteudo do parametro MV_PAPONTA                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPaponta( cFil )

Local cSvFilAnt		:= cFilAnt

Local cPerAponta

DEFAULT cFil		:= cFilAnt

cFilAnt		:= IF( !Empty( cFil ) , cFil , cFilAnt )
cPerAponta	:= AllTrim( StrTran( GetMv( "MV_PAPONTA" , NIL , "" ) , " " , "" ) )
cFilAnt		:= cSvFilAnt

Return( cPerAponta )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PapontaOk  ³ Autor ³ Marinaldo de Jesus   ³ Data ³30/06/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se o parametro MV_PAPONTA este com o Conteudo OK   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PapontaOk( cPerAponta , nIniPer , nFimPer , cFil )

Local lPapontaOk := .T.

DEFAULT cPerAponta := GetPaponta( cFil )

Begin Sequence

	IF !( lPapontaOk := !Empty( cPerAponta ) )
		Break
	EndIF
	
	IF PerCompleto( @cPerAponta )
		Break
	EndIF

	nIniPer	:= Val( Left( cPerAponta , 2 ) )
	IF !( lPapontaOk := ( nIniPer > 0 ) )
		Break
	EndIF

	nFimPer := Val( Right( cPerAponta , 2 ) )
	IF !( lPapontaOk := ( nFimPer > 0 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nIniPer <= 31 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nFimPer <= 31 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nIniPer <> nFimPer ) )
		Break
	EndIF

End Sequence

Return( lPapontaOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PerCompleto³ Autor ³ Marinaldo de Jesus   ³ Data ³30/06/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se o parametro MV_PAPONTA este Preenchido com o con³
³          ³teudo equivalente a "AAAAMMDD/AAAAMMDD"                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PerCompleto( cPerAponta , cFil )
DEFAULT cPerAponta := GetPaponta( cFil )
Return( ( ( Len( cPerAponta ) == 17 ) .or. ( Len( cPerAponta ) == 16 ) ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetPonMes  ³ Autor ³ Marinaldo de Jesus   ³ Data ³01/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem o Conteudo do parametro MV_PONMES                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPonMes( cFil )

Local cSvFilAnt		:= cFilAnt

Local cPonMes

DEFAULT cFil		:= cFilAnt

cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )
cPonMes	:= AllTrim( StrTran( GetMv( "MV_PONMES" , NIL , "" ) , " " , "" ) )
cFilAnt	:= cSvFilAnt

Return( cPonMes )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³DescAbono ³ Autor ³ Equipe Advanced RH    ³ Data ³11/03/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a existencia do codigo de abono e retorna a Desc. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function DescAbono( cCodigo , cTipoRet , cCampo , cFil , nSize )

Local uRet			:= ""

Local nPoscCampo
Local nPosQtdAbo
Local nPosQtdCal
Local cCpoQtdAbo
Local cCpoQtdCal

DEFAULT cTipoRet	:= ""
DEFAULT cCodigo 	:= ""
DEFAULT cCampo		:= ""
DEFAULT nSize		:= GetSx3Cache( "P6_DESC" , "X3_TAMANHO" )

cTipoRet	:= Upper( AllTrim( cTipoRet ) )
cCampo		:= Upper( AllTrim( cCampo ) )
cFil		:= xFilial( "SP6" , cFil )
cCodigo		:= IF( Empty( cCodigo ) .and. cTipoRet == "L" , &(ReadVar()) , cCodigo )

IF SP6->( MsSeek( cFil + cCodigo ) )
	uRet 		:= IF( ( cTipoRet == "L" ) , .T. , Padr( SP6->P6_DESC , nSize ) )
	cCpoQtdAbo	:= IF( cCampo == "PC_DESCABO" , "PC_QTABONO" ,"PH_QTABONO" )
	cCpoQtdCal	:= IF( cCampo == "PC_DESCABO" , "PC_QUANTC"  ,"PH_QUANTC"  )
	IF IsInGetDados( { cCampo , cCpoQtdAbo , cCpoQtdCal } )
	    IF ( ( nPoscCampo := GdFieldPos( cCampo ) ) > 0 )
			aCols[n,nPoscCampo] := SP6->P6_DESC
    	EndIF
		IF ( ( cTipoRet == "L" ) .and. ( cCampo $ "PC_DESCABO*PH_DESCABO" ) )
			nPosQtdAbo := GdFieldPos( cCpoQtdAbo )
			nPosQtdCal := GdFieldPos( cCpoQtdCal )
			IF nPosQtdAbo > 0 .and. nPosQtdCal > 0
				IF aCols[n,nPosQtdAbo] == 0
					aCols[n,nPosQtdAbo] := aCols[n,nPosQtdCal] // Calculado
				EndIF
			EndIF
		EndIF
	EndIF
Else
	uRet := IF( ( cTipoRet == "L" ) , .F. , Space( nSize ) )
EndIF

Return( uRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fCargaId³Autor³Mauro     1a. Versao  	   ³ Data ³18/12/1996³
³          ³        ³Autor³Marinaldo 2a. Versao  	   ³ Data ³04/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Carregar Array com os Identificadores e Verbas               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fCargaId( aCodigos , cFil , lStop )

Local lRet			:= .T.
Local lShowHelp		:= .T.

Local cFilSX5
Local cFilSP9
Local nOrderSP9
Local nSvSp9Ord
Local nPosEmpFil
Local nLenaCod

aCodigos			:= {}

DEFAULT cFil		:= xFilial( "SP9" , IF( Type( "SRA->RA_FILIAL" ) == "C" , SRA->RA_FILIAL , NIL ) )
DEFAULT lStop		:= .T.

Begin Sequence

	DEFAULT aCargaIdCache	:= {}
	
	cFilSP9	:= xFilial( "SP9" , cFil )
	IF ( ( nPosEmpFil := aScan( aCargaIdCache , { |x| ( x[1] == FWCODEMP("SP9") ) .and. ( x[2] == cFilSp9 ) } ) ) > 0 )
		Break
	EndIF

	cFilSX5	:= xFilial( "SX5" , cFil )
	IF !( lRet := SX5->( MsSeek( cFilSX5 + "20" , .F. ) ) )
		IF ( lStop )
			lShowHelp := .F.
			Help( "" , 1 , "EVENTNCAD" )
		EndIF
		Break
	EndIF

	nOrderSP9	:= RetOrdem( "SP9" , "P9_FILIAL+P9_IDPON+P9_CODIGO" )
	nSvSp9Ord	:= SP9->( IndexOrd() )
	IF !( nOrderSP9 == nSvSp9Ord )
		SP9->( dbSetOrder( nOrderSP9 ) )
	EndIF
	SP9->( dbSeek( cFilSP9 , .F. ) )
	While SP9->( !Eof() .and. ( P9_FILIAL == cFilSP9 ) )
		IF SP9->( !Empty( P9_IDPON ) .or. !Empty( P9_CODFOL ) )
			aAdd( aCodigos , Array( 04 ) )
			nLenaCod := Len( aCodigos )
			aCodigos[nLenaCod,01] := SP9->P9_CODIGO
			aCodigos[nLenaCod,02] := SP9->P9_IDPON
			aCodigos[nLenaCod,03] := SP9->P9_DESCDSR
			aCodigos[nLenaCod,04] := SP9->P9_CODFOL
		EndIF
		SP9->(dbSkip())
	End While
	SP9->( dbSetOrder( nSvSp9Ord ) )
	aAdd( aCargaIdCache , { FWCODEMP("SP9") , cFilSP9 , aClone( aCodigos ) } )
	nPosEmpFil	:= Len( aCargaIdCache )
	aCodigos	:= {}

End Sequence

IF !Empty( nPosEmpFil )
	aCodigos := aClone( aCargaIdCache[ nPosEmpFil , 3 ] )
EndIF

IF !( lRet := !Empty( aCodigos ) )
	IF ( ( lStop ) .and. ( lShowHelp ) )
		Help( " ",1,"EVENTNCAD" )
	EndIF	
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstfCargaId   ³ Autor ³Marinaldo de Jesus     ³ Data ³04/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializa as Statics em fCargaId()                       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³																³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL																³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstfCargaId()

aCargaIdCache := {}

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GetEveIdPon   ³Autor³ Marinaldo de Jesus  ³ Data ³15/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Array com Identificadores de Ponto x Eventos de acor³
³          ³do com o SX5                                				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetEveIdPon( aCodigos , cFil , aLogFile, lChkEve )

Local aEveIds		:= {}
Local aArea			:= GetArea()
Local aAreaSX5		:= SX5->( GetArea() )
Local aLastLog		:= {}
Local cTabId		:= "20"
Local cChaveId		:= ""
Local cIdPon		:= "" 
Local nEveId 		:= 0
Local nPosId		:= 0
Local nEvesSX5		:= 0
Local nTotIdPonto	:= 0

DEFAULT aCodigos	:= {}
DEFAULT cFil		:= cFilSX5
DEFAULT aLogfile	:= {}  
DEFAULT lChkEve		:= .F.

IF Empty( aCodigos )
	aCodigos := {}
	fCargaId( @aCodigos , cFil , .F. )
EndIF

aLastLog := aClone( aLogFile )

cFil 		:= xFilial( "SX5" , cFil )
cChaveId	:= ( cFil + cTabId )

IF SX5->( dbSeek( cChaveId , .F. ) )  
	
	While SX5->( !Eof() .and. X5_FILIAL + X5_TABELA == cChaveId )
		aAdd( aEveIds , Array( 3 ) )
		cIdPon						:= Upper( AllTrim( SX5->X5_CHAVE ) )
		aEveIds[ ++nEveId , 01 ]	:= cIdPon
		IF ( nPosId := aScan( aCodigos , { |x| Upper( AllTrim( x[2] ) ) == cIdPon } ) ) == 0
			aEveIds[ nEveId , 02 ]	:= ""
		Else
			aEveIds[ nEveId , 02 ]	:= aCodigos[ nPosId , 01 ]
		EndIF
		aEveIds[ nEveId , 03 ]		:= SX5->( x5Descri() )   
		IF lChkEve
			IF Empty( aEveIds[ nEveId , 02 ] ) 
				aAdd( aLogFile , ( STR0117 + aEveIds[ nEveId , 01 ] + " - " + aEveIds[ nEveId , 03 ] ) ) //'Nao Foi Encontrado Evento para o Id. de Ponto: '
			EndIF
		EndIF
		SX5->( dbSkip() )
	End While
EndIF               

nTotIdPonto:= 43
	
nEvesSX5 := Len( aEveIds )
IF ( !( ArrayCompare( aLastLog , aLogFile ) ) .or. ( nEvesSX5 < nTotIdPonto ) .or. ( nEvesSX5 > nTotIdPonto ) )
	aAdd( aLogFile , "" )
	aAdd( aLogFile , STR0118 )									//'- O Apontamento nao foi Efetuado porque Foram Encontradas Inconsitencias nos Eventos. ' 
	IF ( ( nEvesSX5 < nTotIdPonto ) .or. ( nEvesSX5 > nTotIdPonto ) )
		IF ( nEvesSX5 < nTotIdPonto )
			aAdd( aLogFile , STR0180 )							//'- Estao faltado codigos de Identificadores de Ponto na Tabela 20 do Configurador. '
 	 	ElseIF ( nEvesSX5 > nTotIdPonto )
			aAdd( aLogFile , STR0183 )							//'- Existem Identificadores do Ponto Duplicados na Tabela 20 do Condigurador.'
		EndIF
 	 	aAdd( aLogFile , STR0181 + StrZero( nTotIdPonto , 2 ) )			//'- Numero de Identificadores requeridos: '
 	 	aAdd( aLogFile , STR0182 + StrZero( nEvesSX5 , 2 ) )	//'- Numero de Identificadores Existentes: '
	Else
		IF lChkEve
			aAdd( aLogFile , STR0119 )								//'- Esta Faltando Vincular os Identificadores de Ponto Acima a Eventos. '
		EndIF
	EndIF
EndIF

( RestArea( aAreaSX5 ) , RestArea( aArea ) )

Return( aClone( aEveIds ) )  

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³ObtemEveNoDele³Autor³ Marinaldo de Jesus  ³ Data ³15/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem Eventos que nao Podem ser Deletados pela GravaSPC()   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ObtemEveNoDele( aCodigos )

Local cEvesNoDele	:= ""
Local nPos			:= 0

DEFAULT aCodigos := {}

//-- Evento de Faltas/Antrasos Meses Anteriores Autorizado
IF ( nPos := aScan( aCodigos , { |x| x[2] == "022A" } ) ) > 0
	cEvesNoDele += aCodigos[ nPos , 01 ]
EndIF

//-- Evento de Faltas/Antrasos Meses Anteriores Nao Autorizado
IF ( nPos := aScan( aCodigos , { |x| x[2] == "021N" } ) )  > 0
	cEvesNoDele += ( "/" + aCodigos[ nPos , 01 ] )
EndIF

//-- Evento de DSR Ultima Semana Periodo Anterior
IF ( nPos := aScan( aCodigos , { |x| x[2] == "036N" } ) ) > 0
	cEvesNoDele += ( "/" + aCodigos[ nPos , 01 ] )
EndIF

Return( cEvesNoDele )    


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ObtemIdPon   ³Autor ³Mauricio MR          ³ Data ³25/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a Existencia do Id.Ponto e Evento correspondente   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ObtemIdPon( aEvesIds, cId, lOnlyId )
Local lRet	:= .F.
Local nPos	:= 0   

DEFAULT lOnlyId:= .F.

If lOnlyId
	lRet:= !Empty( (nPos:= Ascan(aEvesIds,{|aId| SUBSTR(aId[1],1,4) == cId  } ) ))
Else
	lRet:= !Empty( (nPos:= Ascan(aEvesIds,{|aId| SUBSTR(aId[1],1,4) == cId .AND. !Empty(aId[2]) } ) ))
Endif
Return lRet
                
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fTotaliza ³ Autor ³ Mauro                 ³ Data ³ 10/12/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Totalizar as Verbas do SPC                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fTotaliza( aTotaliza , cFil , cMat , bAcessaSPC )

Local cFilMat		:= ""
Local dDataIni		:= Ctod("//")
Local dDataFim		:= dDataIni

DEFAULT cFil 		:= SRA->RA_FILIAL
DEFAULT cMat 		:= SRA->RA_MAT
DEFAULT aTotaliza	:= {}
DEFAULT bAcessaSPC	:= { || .T. }

IF PerAponta( @dDataIni , @dDataFim , NIL , NIL , cFil )

	cFilMat	:= ( cFil + cMat )
	IF SPC->( dbSeek( cFilMat , .F.  ) )
	
		While SPC->( !Eof() .and. cFilMat == PC_FILIAL + PC_MAT )
	
			IF SPC->( PC_DATA < dDataIni .or. PC_DATA > dDataFim )
				SPC->( dbSkip() )
				Loop
			EndIF
	
			IF !Eval( bAcessaSPC )
				SPC->( dbSkip() )
				Loop
			EndIF
	
			IF SPC->( ( nPos := aScan( aTotaliza , { |x| x[1] = IF( !Empty( PC_PDI ) , PC_PDI , PC_PD ) } ) ) > 0 )
				aTotaliza[nPos,2] := SomaHoras( aTotaliza[nPos,2] , SPC->( IF( PC_QUANTI > 0 , 0 , SubHoras( PC_QUANTC , PC_QTABONO ) ) ) )
				aTotaliza[nPos,3] := SomaHoras( aTotaliza[nPos,3] , SPC->PC_QUANTI  )
				aTotaliza[nPos,4] := SomaHoras( aTotaliza[nPos,4] , SPC->PC_QTABONO )
			Else
				SPC->( aAdd( aTotaliza , { IF( !Empty( PC_PDI ) , PC_PDI , PC_PD ) , IF( PC_QUANTI > 0 , 0 , SubHoras( PC_QUANTC , PC_QTABONO ) ) , PC_QUANTI , PC_QTABONO } ) )
			EndIF
			
			SPC->( dbSkip() )

		End While
	
	EndIF

EndIF
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fTabTurno ³ Autor ³ Equipe Advanced RH    ³ Data ³18/11/1997³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Preenche um Array com a Tabela de Hor rios dos Turnos      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ fTabTurno( aTabTno , cFil )                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³ aTabTno = Array a ser alimentado com as Tabelas            ³
³          ³ cFil    = Filial para Pesquisa                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ lRet                                                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Gen‚rico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTabTurno( aTabTno , cFil , lExecQryTop , bCond )

Local lRet		:= .T.
Local nSR6Rec	:= SR6->( Recno() )

DEFAULT aTabTno	:= {}

IF ( lRet := xRetModo("SR6","SPJ") )
	IF cFil == NIL
		SR6->( dbGoTop() )
	Else
		cFil := xFilial( "SR6" , cFil )
		SR6->( MsSeek( cFil , .T. ) )
	EndIF
	While SR6->( !Eof() .and. IF( cFil == NIL , .T. , cFil <= R6_FILIAL  ) )
		fTabPadrao( @aTabTno , SR6->R6_FILIAL , SR6->R6_TURNO , lExecQryTop , bCond )
		SR6->( dbSkip() )
	End While
	IF !( lRet := !Empty( aTabTno ) )
		Help(' ',1,'TPADNCAD')
	EndIF
EndIF

IF ( SR6->( Recno() ) != nSR6Rec )
	SR6->( dbGoto( nSR6Rec ) )
EndIF

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fTrocaTno ³ Autor ³Equipe Advanced RH     ³ Data ³03/09/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Adiciona os Turnos pelos quais o funcionario passou durante ³±±
±±³          ³o periodo.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fTrocaTno(dPerIni,dPerFim,aTurnos,aSPF)		              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³dPerIni = Periodo Inicial a ser pesquizado                  ³±±
±±³          ³dPerFim = Periodo Final a ser pesquizado                    ³±±
±±³          ³aTurnos = Array a ser alimentado com as trocas de turno     ³±±
±±³          ³aSPF    = Array com as Trocas de Turno do SPF               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fTrocaTno( dPerIni , dPerFim , aTurnos , aSPF , cSeq , lAddTrcIniPer )

Local aTnoAnt		:= {}
Local aTnoProx		:= {}
Local cFil			:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cFilMat		:= ( cFil + cMat )
Local cRegra		:= SRA->RA_REGRA
Local cTurno		:= SRA->RA_TNOTRAB
Local cSeqTurn		:= SRA->RA_SEQTURN
Local cAlias		:= "SPF"
Local cAliasQuery	:= cAlias
Local dData     	:= Ctod("//")
Local lTrocaTno		:= .F.
Local lVazio		:= .T.
Local nX        	:= 0
Local nFornX		:= 0
Local nY        	:= 0
Local nFornY		:= 0

#IFDEF TOP

	Local cIniData	 		:= ""
	Local cFimData			:= ""
	Local cQuery	 		:= ""
	Local cPrefixo			:= ( PrefixoCpo( cAlias ) + "_" )
	Local cSvAlias			:= Alias()
	Local lQueryOpened		:= .F.

	Static aSpfFields
	Static cQrySpfFields
	Static nSpfFields

	IF !( lExInAs400 )

		DEFAULT aSpfFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpfFields := Len( aSpfFields )
	
		IF ( cQrySpfFields == NIL )
			cQrySpfFields := ""
			For nX := 1 To nSpfFields
				cQrySpfFields += aSpfFields[ nX , 01 ] + ", "
			Next nX
		EndIF

	EndIF
	
#ENDIF

DEFAULT dPerIni 		:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT aTurnos			:= {}
DEFAULT aSPF			:= {}
DEFAULT lAddTrcIniPer	:= .T.

IF Empty( dPerIni ) .or. Empty( dPerFim )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIF
aTurnos := {}


IF  ExistBlock( "PONAPO11" )     
	aSPF:=ExecBlock( "PONAPO11" , .F. , .F. , { dPerIni , dPerFim, cSeq } ) 
EndIF

IF Empty( aSPF ) 

	#IFDEF TOP

		IF ( lExInAs400 )
			( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
		Else
			cIniData	:= Dtos( dPerIni )
			cFimData	:= Dtos( dPerFim )
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQrySpfFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName( cAlias )
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA>='"+cIniData+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA<='"+cFimData+"'"
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery( cQuery )
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nSpfFields
					IF !( aSpfFields[ nX , 02 ] == "C" )
						TcSetField(cAliasQuery,aSpfFields[nX,01],aSpfFields[nX,02],aSpfFields[nX,03],aSpfFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
				( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
			EndIF	
		EndIF
	#ELSE
		IF ( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	#ENDIF
			While ( cAliasQuery )->( !Eof() .and. cFilMat == PF_FILIAL + PF_MAT )
				#IFNDEF TOP
					IF ( cAliasQuery )->( PF_DATA < dPerIni .or. PF_DATA > dPerFim )
						If ( cAliasQuery )->( PF_DATA < dPerIni )
							//Ao final sobrara apenas a primeira troca anterior a data inicial
							aTnoAnt := {}
							( cAliasQuery )->( aAdd(	aTnoAnt , {	PF_TURNODE									,;	//01 - Turno De
																	PF_TURNOPA									,;	//02 - Turno Para
																	PF_DATA										,;	//03 - Data
																	PF_SEQUEDE									,;	//04 - Sequencia De
																	PF_SEQUEPA									,;	//05 - Sequencia Para
																	IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																	IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
								      		   					};
							    					);
								  			 )
						EndIf
						If ( cAliasQuery )->( PF_DATA > dPerFim )
							( cAliasQuery )->( aAdd(	aTnoProx, {	PF_TURNODE									,;	//01 - Turno De
																	PF_TURNOPA									,;	//02 - Turno Para
																	PF_DATA										,;	//03 - Data
																	PF_SEQUEDE									,;	//04 - Sequencia De
																	PF_SEQUEPA									,;	//05 - Sequencia Para
																	IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																	IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
								      		   					};
							    					);
								  			 )
							//Adicionara somente a primeira troca apos a data final do periodo
							Exit
						EndIf
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
				#ELSE
					IF !( lQueryOpened )
						IF ( cAliasQuery )->( PF_DATA < dPerIni .or. PF_DATA > dPerFim )
							If ( cAliasQuery )->( PF_DATA < dPerIni )
								//Ao final sobrara apenas a primeira troca anterior a data inicial
								aTnoAnt := {}							
								( cAliasQuery )->( aAdd(	aTnoAnt , {	PF_TURNODE									,;	//01 - Turno De
																		PF_TURNOPA									,;	//02 - Turno Para
																		PF_DATA										,;	//03 - Data
																		PF_SEQUEDE									,;	//04 - Sequencia De
																		PF_SEQUEPA									,;	//05 - Sequencia Para
																		IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																		IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
									      		   					};
								    					);
									  			 )
							EndIf
							If ( cAliasQuery )->( PF_DATA > dPerFim )
								( cAliasQuery )->( aAdd(	aTnoProx, {	PF_TURNODE									,;	//01 - Turno De
																		PF_TURNOPA									,;	//02 - Turno Para
																		PF_DATA										,;	//03 - Data
																		PF_SEQUEDE									,;	//04 - Sequencia De
																		PF_SEQUEPA									,;	//05 - Sequencia Para
																		IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																		IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
									      		   					};
								    					);
									  			 )
								//Adicionara somente a primeira troca apos a data final do periodo
								Exit
							EndIf
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF
				#ENDIF
				( cAliasQuery )->( aAdd(	aSPF , {	PF_TURNODE									,;	//01 - Turno De
														PF_TURNOPA									,;	//02 - Turno Para
														PF_DATA										,;	//03 - Data
														PF_SEQUEDE									,;	//04 - Sequencia De
														PF_SEQUEPA									,;	//05 - Sequencia Para
														IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
														IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
					      		   					};
				    					);
					  			 )
				lVazio := .F.
				( cAliasQuery )->( dbSkip() )
			End While
	#IFNDEF TOP
		EndIF
	#ELSE
		IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
			( cAliasQuery )->( dbCloseArea() )
			dbSelectArea( cSvAlias )
		EndIF	
	#ENDIF	
EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	| Caso nao encontre nenhuma troca de turno para o periodo, 	   |
	| procura uma troca na primeira data maior que dPerFim.        |
	| Se encontrar monta aTurnos com os dados desta troca, caso    |
	| contrario ira assumir dados da SRA - Leandro 14/05/08        |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lVazio
	#IFDEF TOP
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQrySpfFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName( cAlias )
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' '"
			cQuery += " AND ( "
			cQuery += cPrefixo + "DATA>'"+cFimData+"'"
			cQuery += " OR "
			cQuery += cPrefixo + "DATA<'"+cIniData+"' ) "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery( cQuery )
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nSpfFields
					IF !( aSpfFields[ nX , 02 ] == "C" )
						TcSetField(cAliasQuery,aSpfFields[nX,01],aSpfFields[nX,02],aSpfFields[nX,03],aSpfFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
				( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
			EndIF
	#ELSE
		IF ( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	#ENDIF
           	/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Grava as trocas menores e maiores que o periodo informado				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			While ( cAliasQuery )->( !Eof() .and. cFilMat == PF_FILIAL + PF_MAT )
						If ( cAliasQuery )->( PF_DATA < dPerIni )
							//Ao final sobrara apenas a primeira troca anterior a data inicial
							aTnoAnt := {}
							( cAliasQuery )->( aAdd(	aTnoAnt , {	PF_TURNODE									,;	//01 - Turno De
																	PF_TURNOPA									,;	//02 - Turno Para
																	PF_DATA										,;	//03 - Data
																	PF_SEQUEDE									,;	//04 - Sequencia De
																	PF_SEQUEPA									,;	//05 - Sequencia Para
																	IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																	IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
								      		   					};
							    					);
								  			 )
						EndIf
						If ( cAliasQuery )->( PF_DATA > dPerFim )
							( cAliasQuery )->( aAdd(	aTnoProx, {	PF_TURNODE									,;	//01 - Turno De
																	PF_TURNOPA									,;	//02 - Turno Para
																	PF_DATA										,;	//03 - Data
																	PF_SEQUEDE									,;	//04 - Sequencia De
																	PF_SEQUEPA									,;	//05 - Sequencia Para
																	IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																	IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
								      		   					};
							    					);
								  			 )
							//Adicionara somente a primeira troca apos a data final do periodo
							Exit
						EndIf
						( cAliasQuery )->( dbSkip() )
			End While
	#IFNDEF TOP
		EndIF
	#ELSE
		IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
			( cAliasQuery )->( dbCloseArea() )
			dbSelectArea( cSvAlias )
		EndIF	
	#ENDIF
    
	//Adiciona o ultimo turno anterior ao periodo selecionado
	If !Empty(aTnoAnt)
		aAdd( aSPF , aTnoAnt[1] )
		lVazio := .F.
	EndIf
	//Adiciona o primeiro turno posterior ao periodo selecionado
	If !Empty(aTnoProx)
		aAdd( aSPF , aTnoProx[1] )
		lVazio := .F.
	EndIf
EndIf
IF ( Len(aSPF) > 0 )
	aSort( @aSPF , NIL , NIL , { |x,y| ( x[3] < y[3] ) } )
	nFornX := ( dPerFim - dPerIni )
	For nX := 0 To nFornX
		dData := dPerIni + nX
		nFornY := Len(aSPF)
		For nY := 1 To nFornY
			IF aSPF[nY,3] >= dData .And. nY < Len(aSPF) .And. dData <= aSPF[nY+1,3] .Or. ;
				aSPF[nY,3] >= dData .And. nY == Len(aSPF) .Or. ;
				( nX == 0 .And. nFornY == 1 .And. lVazio ) //Caso nao exista troca para o periodo informado, gravara a troca anterior/posterior encontrada
				//-- Inclui o 1o. "TURNO DE" como 1o. do periodo
				//-- qdo nao houver troca no primeiro dia do periodo
				IF Len(aTurnos)==0 .And. aSPF[nY,3] # dPerIni .and. lAddTrcIniPer
					//Se a Data da troca de turno for maior que a data inicial do periodo, grava as informacoes DE
					If aSPF[nY,3] > dPerIni
						aAdd(aTurnos, {	aSPF[nY, 1],;								//01 - Turno De
										dPerIni,;									//02 - Data
										IF(Empty(aSPF[nY,4]),cSeqTurn,aSPF[nY,4]),;	//03 - Sequencia De
										0,;											//04 - Numero Serial
										IF(Empty(aSPF[nY,6]),cRegra,aSPF[nY,6]),;	//05 - Regra De
										.T.;										//06 - Troca Turno
								      };
							 )
					//Se a Data da troca de turno for menor que a data inicial do periodo, grava as informacoes PARA
					Else
						aAdd(aTurnos, {	aSPF[nY, 2],;								//01 - Turno Para
										dPerIni,;									//02 - Data
										IF(Empty(aSPF[nY,5]),cSeqTurn,aSPF[nY,5]),;	//03 - Sequencia Para
										0,;											//04 - Numero Serial
										IF(Empty(aSPF[nY,7]),cRegra,aSPF[nY,7]),;	//05 - Regra Para
										.T.;										//06 - Troca Turno
								      };
							 )
					EndIf
				EndIF
				//-- Inclui os "TURNO PARA" do periodo
				IF aScan(aTurnos, {|x| x[1] == aSPf[nY,2] .And. x[2] == aSPF[nY,3]}) == 0
					aAdd(aTurnos, {	aSPF[nY, 2],;								//01 - Turno Para
									aSPF[nY, 3],;								//02 - Data
									IF(Empty(aSPF[nY,5]),cSeqTurn,aSPF[nY,5]),;	//03 - Sequencia Para
									0,;											//04 - Numero Serial
									IF(Empty(aSPF[nY,7]),cRegra,aSPF[nY,7]),;	//05 - Regra Para
									.T.,;										//06 - Troca Turno
								  };
						 )
				EndIF
				Exit
			EndIF
		Next nY
	Next nX
EndIF

IF !( lTrocaTno := !Empty( aTurnos ) )
	DEFAULT cSeq := cSeqTurn
	IF ( lAddTrcIniPer )
		If ( Len(aSPF) > 0 )
			aAdd( aTurnos , { aSPF[ Len(aSPF), 02 ] , aSPF[ Len(aSPF), 03 ] , aSPF[ Len(aSPF), 05 ] , 0 , aSPF[ Len(aSPF), 07 ], .F. } )			
		Else
			aAdd( aTurnos , { cTurno , dPerIni , cSeq , 0 , cRegra, .F. } )
		EndIf
	EndIF	
EndIF

Return( lTrocaTno )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fDepuraSP2³ Autor ³ Fernando Joly Siquini ³ Data ³ 27.08.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Filtra SP2 deixando somente excecoes do Per¡odo            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fDepuraSP2(cArqInd, dPerIni, dPerFim)                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cArqInd = Nome do Arquivo de Indice (passar com "@")       ³±±
±±³          ³ dPerIni = Inicio do Periodo de Depura‡„o                   ³±±
±±³          ³ dPerFim = Final do Periodo de Depura‡„o                    ³±±
±±³          ³ lShowDialog = Mostrar Dialogo na IndRegua                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fDepuraSP2( cArqInd , dPerIni , dPerFim , lShowDialog )

Local cChave		:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
Local cPerIni		:= ""
Local cPerFim		:= ""
Local cQuery		:= ""

DEFAULT cArqInd		:= ""
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT lShowDialog := .T.

IF !Empty( cArqInd )
	RetIndex( "SP2" )
	SP2->( dbSetOrder( RetOrdem( "SP2" , cChave ) ) )
	fErase( cArqInd + OrdBagExt() )
	cArqInd := ""
EndIF

cPerIni	:= Dtos( dPerIni )
cPerFim := Dtos( dPerFim )

cArqInd	:= CriaTrab("",.F.)
cQuery  += '(((DtoS(P2_DATAATE)>="'+cPerIni+'".AND.DtoS(P2_DATAATE)<="'+cPerFim+'").OR.'
cQuery  += '(DtoS(P2_DATAATE)>="'+cPerFim+'".AND.DtoS(P2_DATA)<="'+cPerIni+'")).OR.'
cQuery  += '(DtoS(P2_DATA)>="'+cPerIni+'".AND.DtoS(P2_DATA)<="'+cPerFim+'"))'

IndRegua( "SP2" , cArqInd , cChave ,, cQuery , STR0056 , lShowDialog ) // 'Depurando Excecoes...'

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ fTabSP4  ³ Autor ³ Aldo Marini Junior    ³ Data ³ 15/10/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Carrega tabela de Eventos do Tipo de Hora Extra            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fTabSP4(aCodAut)

Local nLenCodAut := 0

//-- Preenche o Array aCodAut com as Horas Extras
SP4->( dbGoTop() )
While SP4->( !Eof() )
	IF (;
			SP4->(;
					aScan(aCodAut, {|x| x[1] == P4_FILIAL .and. ;
									  	x[2] == P4_TURNO  .and. ;
									  	x[3] == P4_CODAUT		;
									};
					  	) == 0;
				  );
		)		  	  	
		aAdd( aCodAut , Array( 04 ) )
		nLenCodAut := Len( aCodAut )
		aCodAut[nLenCodAut,01] := SP4->P4_FILIAL
		aCodAut[nLenCodAut,02] := SP4->P4_TURNO
		aCodAut[nLenCodAut,03] := SP4->P4_CODAUT
		aCodAut[nLenCodAut,04] := "A"
	EndIF
	IF (;
			SP4->(;
					aScan(aCodAut, {|x| x[1] == P4_FILIAL .and. ;
								  		x[2] == P4_TURNO  .and. ;
								  		x[3] == P4_CODNAUT		;
								  	};
						  ) == 0;
				);
		)										  
		aAdd( aCodAut , Array( 04 ) )
		nLenCodAut := Len( aCodAut )
		aCodAut[nLenCodAut,01] := SP4->P4_FILIAL
		aCodAut[nLenCodAut,02] := SP4->P4_TURNO
		aCodAut[nLenCodAut,03] := SP4->P4_CODNAUT
		aCodAut[nLenCodAut,04] := "N"
	EndIF
	SP4->( dbSkip() )
End While

aCodAut := aSort( @aCodAut , NIL , NIL , { |x,y| x[2]+x[3] > y[2]+y[3] } )

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fBscEven  ³ Autor ³ Aldo Marini Junior    ³ Data ³ 28.12.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna % ou Efetua validacao do Evento                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fBscEven(cEvento,nTipo,nTpEvento)                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cEvento  = Codigo do Evento a ser pesquisado               ³±±
±±³          ³ nTipo    = 1-Percentual Evento 2-Validacao do Evento       ³±±
±±³          ³ nTpEvento= 1-Autorizado 2-Nao Autorizado 3-Ambos           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fBscEven( cEvento , nTipo , nTpEvento )

Local nPerc		:= 100
Local cCodFol	:= ""
Local lRet		:= .T.

IF nTipo == 1
	IF ( nPerc := PosSP9(cEvento,SRA->RA_FILIAL,"P9_BHPERC") ) <= 0
		nPerc := 100
	EndIF
Else
	cCodFol := PosSP9(cEvento,SRA->RA_FILIAL,"P9_CODFOL")
	IF ( Empty(cCodFol) .and. nTpEvento == 1 ) .or. ( !Empty(cCodFol) .and. nTpEvento == 2 )
		lRet := .F.
	EndIF
EndIF

Return( IF( nTipo == 1 , nPerc ,  lRet ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fValidMarc	³ Autor ³Equipe Advanced RH    ³ Data ³11/07/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar a multipla escolha do tipo de marcacao 1E/1S ..		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fValidMarc( l1Elem , cTipo )								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                     		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T.                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fValidMarc( l1Elem , cTipo )

Local cAlias := ""
Local cPref_ := ""
Local cConte := ""
Local aMarc		:= {}
Local aStruct	:= {} 
Local bSort		:= { || NIL }
Local cMarc		:= ""
Local cTitulo	:= ""
Local cMvParDef	:= ""
Local cMvPar	:= &( Alltrim( ReadVar() ) )
Local nX		:= 0
Local nCampos	:= 0
Local nTamCon	:= 0
Local nTamTip	:= 0
Local nPosTip	:= 0

Private uMvRet	:= Alltrim( ReadVar() )

If ( Type("lUseSpj") == "U" )
	lUseSPJ := ( SuperGetMv("MV_USESPJ",NIL,"0")  == "1" )
EndIf

If lUseSpj
   cAlias := "SPJ"
   cPref_ := "PJ"
   nTamCon:= 8
   nTamTip:= 9
   nPosTip:= 4
Else
   cAlias := "RF3"
   cPref_ := "RF3"
   nTamCon:= 9
   nTamTip:= 10
   nPosTip:= 5
EndIf

aStruct := (cAlias)->(dbStruct())
nCampos := Len(aStruct)
cConte  := cPref_+"_ENTRA_"+cPref_+"_SAIDA"

l1Elem			:= IF( l1Elem == NIL .and. ValType( l1Elem ) != "L" , .F. , .T. )

bSort := { |x,y| ( SubStr( x[1] , nTamTip , 1 ) + SubStr( x[1] , nPosTip , 1 ) );
				 <;
				 ( SubStr( y[1] , nTamTip , 1 ) + SubStr( y[1] , nPosTip , 1 ) );
		 }

CursorWait()

	aSort( @aStruct , NIL , NIL , bSort )
	
	IF ( cTipo != "I" )
		For nX := 1 To nCampos
			cCampo := Upper( AllTrim( aStruct[ nX , 01 ] ) )
			If Subs(cCampo,1,nTamCon) $ cConte
				cMarc := SubStr( cCampo , nTamTip , 1 ) + SubStr( cCampo , nPosTip , 1 )
				cMvParDef += ( cMarc + "-" )
				aAdd( aMarc , cMarc += ( "-" + GetDescMarc( cMarc  ) ) )
			EndIF
		Next nX
	Else
		aAdd( aMarc , "I1-" + GetDescMarc( "I1" ) )
		aAdd( aMarc , "I2-" + GetDescMarc( "I2" ) )
		aAdd( aMarc , "I3-" + GetDescMarc( "I3" ) )
		cMvParDef := "I1-I2-I3-"
	EndIF

CursorArrow()
	
IF ( cMvPar != NIL )
	IF f_Opcoes(@cMvPar,cTitulo,aMarc,cMvParDef,12,49,l1Elem,3)
		&(uMvRet) := cMvPar
	EndIF	
EndIF	

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fTolerancia³ Autor ³Equipe Advanced RH    ³ Data ³22/03/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Extrai a tolerancia da regra de apontamento.               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ fTolerancia(cString, nMarc)								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cString - String contendo as tolerancias separadas por '-' ³
³          ³ nMarc   - Numero sequencial da marcacao referente a tol. 	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTolerancia( cString , nMarc )

Local nTolera := 0				//-- Retorno da tolerancia
Local nY      := 0				//-- Contador da quantidade de tolerancias
Local nPos    := 1				//-- Posicao para extracao de cString
Local nLenStr := Len(cString)	//-- Tamanho da String

While ( nPos <= nLenStr )
	nY++
	IF ( nY > nMarc )
		Exit
	ElseIF ( nY == nMarc )
		nTolera := __Min2Hrs( Val( Subs( cString , nPos , 2 ) ) )
		Exit
	EndIF
	nPos += 3
End While

Return( nTolera )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao	   ³fAbonos   ³Autor³Equipe Advanced RH Ver. I³ Data ³04/04/2001³
³          ³          ³     ³Marinaldo de Jesus Ver.II³ Data ³27/04/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Verifica a existencia de abonos.                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fAbonos(	dData		,;	//01 - Data do Abono
					cPD			,;	//02 - Evento do Abono
					nHora		,;	//03 - Hora Inicial do Abono
					aAbonos		,;	//04 - Array onde serao carregados os Abonos
					cTpMarca	,;	//05 - Tipo de Marcacao
					cCC			,;	//06 - Centro de Custo
					aAbonosPer	,;	//07 - Array com Todos os Abonos do Periodo
					cFuncao		,;	//08 - Funcao
					cDepto		,;	//09 - Depto 
					cPosto		,;	//10 - Posto  
					cProcesso	,;	//11 - Processo
					cPeriodo	,;	//12 - Periodo
					cRoteiro	,;	//13 - Roteiro
					cNumPagto	;	//14 - NumPagto								
				)

Local lPassTpMarca		:= !( cTpMarca == NIL )
Local lPassCC			:= !( cCC == NIL )
Local lPassFuncao		:= !( cFuncao == NIL )
Local lPassDepto 		:= !( cDepto == NIL )
Local lPassPosto 		:= !( cPosto == NIL )
Local lPassProcesso		:= !( cProcesso == NIL )
Local lPassPeriodo		:= !( cPeriodo == NIL )
Local lPassRoteiro		:= !( cRoteiro == NIL )
Local lPassNumPagto		:= !( cNumpagto == NIL )

Local nHrsAbo			:= 0

Local aTamSx3
Local bEval
Local bFiltro
Local cFilSPK
Local cCond_01
Local cCond_02
Local cbCond
Local lAbonosPer
Local nLenAbo
Local nSvOrder
Local nOrder

DEFAULT cTpMarca		:= Space( GetSx3Cache( "PK_TPMARCA" , "X3_TAMANHO" ) )

IF ( Type( "lMemoria" ) <> "L" )
	Private lMemoria := .F.
EndIF

aAbonos	 := {}

IF !( lMemoria )

	lAbonosPer := ( ValType( aAbonosPer ) == "A" )

	IF !( lAbonosPer )

		aTamSx3		:= TamSx3( "PK_HORINI" )
		bEval		:= { |e1 , e2 | e1 == &(e2) }
		cFilSPK		:= SRA->RA_FILIAL
		nSvOrder	:= SPK->( IndexOrd() )
		nOrder		:= RetOrdem( "SPK" , "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODEVE+STR(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")+PK_TPMARCA+PK_CC+PK_DEPTO+PK_POSTO+PK_CODFUNC" )

		IF ( lPassTpMarca )
		   cbCond	:=	"SPK->PK_TPMARCA $ cTpMarca"
		EndIF
		IF ( lPassCC )
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_CC==cCC"
		EndIF
		IF ( lPassFuncao)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_CODFUNC==cFuncao"
		EndIF 
		IF ( lPassDepto)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_DEPTO==cDepto"
		EndIF
		IF ( lPassPosto)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_POSTO==cPosto"
		EndIF
		IF ( lPassProcesso)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_PROCES==cProcesso"
		EndIF
		IF ( lPassPeriodo)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_PERIODO==cPeriodo"
		EndIF				
		IF ( lPassRoteiro)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_ROTEIR==cRoteiro"
		EndIF
		IF ( lPassNumpagto)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_NUMPAG==cNumPagto"
		EndIF	
		IF Empty( cbCond )
		   cbCond	:=	".T."
		EndIF
		bFiltro  := &( "{ ||" + cbCond + " }" )
		IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
			cCond_01	:= ( cFilSPK +  SRA->RA_MAT + Dtos( dData ) + cPD )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)+PK_CODEVE"
		ElseIF ( nHora == NIL .and. cPD == NIL )
			cCond_01	:= ( cFilSPK + SRA->RA_MAT + Dtos( dData ) )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)"
		Else
			cCond_01	:= ( cFilSPK + SRA->RA_MAT + Dtos(dData) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)+PK_CODEVE+Str(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")"
		EndIF

		IF !( nSvOrder == nOrder )
			SPK->( dbSetOrder( nOrder ) )
		EndIF

		IF SPK->( MsSeek( cCond_01 ) )
			While SPK->( !Eof() .and. Eval( bEval , cCond_01 , cCond_02 ) )
		        IF Eval( bFiltro )
					aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
					nLenAbo := Len( aAbonos )
					aAbonos[ nLenAbo , AABONOS_CODIGO 		] := SPK->PK_CODABO
					aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := SPK->PK_HRSABO
					aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := SPK->PK_HORINI
					aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := SPK->PK_HORFIM
					aAbonos[ nLenAbo , AABONOS_DATA			] := SPK->PK_DATA
					aAbonos[ nLenAbo , AABONOS_CC			] := SPK->PK_CC
					aAbonos[ nLenAbo , AABONOS_TPMARCA		] := SPK->PK_TPMARCA
					aAbonos[ nLenAbo , AABONOS_CODEVE		] := SPK->PK_CODEVE
					aAbonos[ nLenAbo , AABONOS_RECNO		] := SPK->( Recno() )
					aAbonos[ nLenAbo , AABONOS_FLAG			] := SPK->PK_FLAG
		 			aAbonos[ nLenAbo , AABONOS_FUNCAO		] := SPK->PK_CODFUNC
					aAbonos[ nLenAbo , AABONOS_DEPTO		] := SPK->PK_DEPTO   	 			
					aAbonos[ nLenAbo , AABONOS_POSTO 		] := SPK->PK_POSTO   
					aAbonos[ nLenAbo , AABONOS_PROCESSO     ] := SPK->PK_PROCES   	
					aAbonos[ nLenAbo , AABONOS_PERIODO		] := SPK->PK_PERIODO 
		   			aAbonos[ nLenAbo , AABONOS_ROTEIRO		] := SPK->PK_ROTEIR  		
					aAbonos[ nLenAbo , AABONOS_NUM_PAGTO		] := SPK->PK_NUMPAG 
				   	
				   	nHrsAbo := SomaHoras( nHrsAbo , SPK->PK_HRSABO )
				   	
				EndIF
				SPK->( dbSkip() )
			End While
		EndIF
		
		IF !( nSvOrder == nOrder )
			SPK->( dbSetOrder( nSvOrder ) )
		EndIF

	Else

		nHrsAbo := GetAbonosPer( dData , cPD , nHora , @aAbonos , cTpMarca , cCC , aAbonosPer , lPassTpMarca , lPassCC, cFuncao, ;
							     cDepto, cPosto,cProcesso,cPeriodo,cRoteiro,cNumPagto,lPassFuncao,lPassDepto, lPassPosto, lPassProcesso, lPassPeriodo, lPassRoteiro, lPassNumpagto;
							   )
			
	EndIF
	
Else

	nHrsAbo := fAbonosMem( dData , cPD , nHora , @aAbonos , cTpMarca , cCC , lPassTpMarca , lPassCC, cFuncao,;
					       cDepto, cPosto, cProcesso, cPeriodo, cRoteiro, cNumPagto, lPassFuncao, lPassDepto, lPassPosto, lPassProcesso, lPassPeriodo, lPassRoteiro, lPassNumpagto;
					     )

EndIF

Return( nHrsAbo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao	   ³GetAbonosPer³Autor ³Marinaldo de Jesus    ³ Data ³20/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Carrega aAbonos a Partir do Conteudo de aAbonosPer			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³fAbonos()													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GetAbonosPer(	dData			,;	//Data do Abono
								cPD				,;	//Evento do Abono
								nHora			,;	//Hora Inicial do Abono
								aAbonos			,;	//Array onde serao carregados os Abonos
								cTpMarca		,;	//Tipo de Marcacao
								cCC				,;	//Centro de Custo
								aAbonosPer		,;	//Array com Todos os Abonos do Periodo
								lPassTpMarca	,;	//Se passou o Tipo da Marcacao em fAbonos
								lPassCC			,;	//Se passou o Centro de Custo em fAbonos  
								cFuncao			,;  //Codigo da Funcao
							    cDepto			,;  //Codigo do Depto
 							    cPosto			,;  //Codigo do Posto
 							    cProcesso		,;  //Codigo do Processo
 							    cPeriodo		,;  //Codigo do Periodo
 							    cRoteiro		,;  //Codigo do Roteiro
 							    cNumPagto		,;  //Codigo do NumPagto
 								lPassFuncao     ,;  //Se passou funcao   
 							    lPassDepto		,;  //Se passou Depto
 							    lPassPosto		,;  //Se passou Posto
 							    lPassProcesso	,;  //Se passou Processo
 							    lPassPeriodo	,;  //Se passou Periodo
 							    lPassRoteiro	,;  //Se passou Roteiro   
 							    lPassNumpagto	 ;  //Se passou NumPagto   
							)
                
Local aTamSx3	:= TamSx3( "PK_HORINI" )
Local nHrsAbo	:= 0

Local bEval
Local bFiltro
Local bCond_01
Local bCond_02
Local cbCond
Local nLenAbo
Local nAbonosPer
Local nPosAbono

aAbonos	 := {}

IF ( lPassTpMarca )
   cbCond	:=	"aAbonosPer[ nPosAbono ," + AllTrim( Str( AABONOS_TPMARCA ) ) + "] $ cTpMarca"
EndIF
IF ( lPassCC )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_CC ) + "] == cCC"
EndIF
IF ( lPassFuncao )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_FUNCAO ) + "] == cFuncao"
EndIF 
IF ( lPassDepto )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_DEPTO ) + "] == cDepto"
EndIF
IF ( lPassPosto )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_POSTO ) + "] == cPosto"
EndIF
If ( lPassProcesso )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_PROCESSO ) + "] == cProcesso"
EndIF	
If ( lPassPeriodo )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_PERIODO ) + "] == cPeriodo"
EndIF
If ( lPassRoteiro )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_ROTEIRO ) + "] == cRoteiro"
EndIF
If ( lPassNumPagto )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_NUM_PAGTO ) + "] == cNumPagto"
EndIF

IF Empty( cbCond )
   cbCond	:= ".T."
EndIF
bFiltro		:= &( "{ || " + cbCond + " } " )
IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
	bCond_01	:= { || Dtos( dData ) + cPD }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) + aAbonosPer[ nPosAbono , AABONOS_CODEVE ] }
ElseIF ( ( nHora == NIL ) .and. ( cPD == NIL ) )
	bCond_01	:= { || Dtos( dData ) }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) }
Else
	bCond_01	:= { || Dtos( dData ) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) + aAbonosPer[ nPosAbono , AABONOS_CODEVE ] + Str( aAbonosPer[ nPosAbono , AABONOS_HORAS_INI ] , aTamSx3[1] , aTamSx3[2] ) }
EndIF

nAbonosPer	:= Len( aAbonosPer )
IF ( ( nPosAbono := aScan( aAbonosPer , { |x| x[ AABONOS_DATA ] == dData } ) ) > 0 )
	bEval := { | b1 , b2 | Eval( b1 ) == Eval( b2 ) }
	For nPosAbono := nPosAbono To nAbonosPer
		IF ( !Eval( bEval , bCond_01 , bCond_02 ) .or. !Eval( bFiltro ) )
			Loop
		EndIF   
		IF !Empty(aAbonosPer[ nPosAbono , AABONOS_CODIGO 	])
			aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
			nLenAbo := Len( aAbonos )
			aAbonos[ nLenAbo , AABONOS_CODIGO 		] := aAbonosPer[ nPosAbono , AABONOS_CODIGO 	]
			aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_ABO	]
			aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_INI	]
			aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_FIM	]
			aAbonos[ nLenAbo , AABONOS_DATA			] := aAbonosPer[ nPosAbono , AABONOS_DATA		]
			aAbonos[ nLenAbo , AABONOS_CC			] := aAbonosPer[ nPosAbono , AABONOS_CC			]
			aAbonos[ nLenAbo , AABONOS_TPMARCA		] := aAbonosPer[ nPosAbono , AABONOS_TPMARCA	]
			aAbonos[ nLenAbo , AABONOS_CODEVE		] := aAbonosPer[ nPosAbono , AABONOS_CODEVE		]
			aAbonos[ nLenAbo , AABONOS_RECNO		] := aAbonosPer[ nPosAbono , AABONOS_RECNO		]
			aAbonos[ nLenAbo , AABONOS_FLAG			] := aAbonosPer[ nPosAbono , AABONOS_FLAG		]
			aAbonos[ nLenAbo , AABONOS_FUNCAO		] := aAbonosPer[ nPosAbono , AABONOS_FUNCAO		]		
			aAbonos[ nLenAbo , AABONOS_DEPTO		] := aAbonosPer[ nPosAbono , AABONOS_DEPTO		]		
			aAbonos[ nLenAbo , AABONOS_POSTO		] := aAbonosPer[ nPosAbono , AABONOS_POSTO		]								
			aAbonos[ nLenAbo , AABONOS_PROCESSO		] := aAbonosPer[ nPosAbono , AABONOS_PROCESSO	]	
			aAbonos[ nLenAbo , AABONOS_PERIODO		] := aAbonosPer[ nPosAbono , AABONOS_PERIODO	]	
			aAbonos[ nLenAbo , AABONOS_ROTEIRO		] := aAbonosPer[ nPosAbono , AABONOS_ROTEIRO	]	
			aAbonos[ nLenAbo , AABONOS_NUM_PAGTO		] := aAbonosPer[ nPosAbono , AABONOS_NUM_PAGTO	]													
			nHrsAbo := SomaHoras( nHrsAbo , aAbonosPer[ nPosAbono , AABONOS_HORAS_ABO	] )
		Endif
	Next nPosAbono
EndIF

Return( nHrsAbo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao	   ³fAbonosMem³Autor³Mauricio MR        Ver. I³ Data ³04/04/2001³
³          ³          ³     ³Marinaldo de Jesus Ver.II³ Data ³27/04/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Verifica a existencia de abonos (Trabalha com a Memoria)	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³fAbonos()													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fAbonosMem(	dData			,;	//Data do Abono
							cPD				,;	//Evento do Abono
							nHora			,;	//Hora Inicial do Abono
							aAbonos			,;	//Array onde serao carregados os Abonos
							cTpMarca		,;	//Tipo de Marcacao
							cCC				,;	//Centro de Custo
							lPassTpMarca	,;	//Se passou o Tipo da Marcacao em fAbonos
							lPassCC			,;	//Se passou o Centro de Custo em fAbonos   
							cFuncao         ,;  //Codigo da Funcao
						  	cDepto			,;  //Codigo do Depto
						    cPosto			,;  //Codigo do Posto
						    cProcesso		,;  //Codigo do Processo
						    cPeriodo		,;  //Codigo do Periodo
						    cRoteiro		,;  //Codigo do Roteiro
						    cNumPagto		,;  //Codigo do NumPagto
							lPassFuncao     ,;  //Se passou a Funcao
						    lPassDepto		,;  //Se passou Depto
						    lPassPosto		,;  //Se passou Posto
						    lPassProcesso	,;  //Se passou Processo
						    lPassPeriodo	,;  //Se passou Periodo
						    lPassRoteiro	,;  //Se passou Roteiro   
						    lPassNumpagto	 ;  //Se passou NumPagto   
						   )								

Local nHrsAbo	:= 0

Local aAboCols
Local aTamSx3
Local bFiltro
Local cCond_01
Local cCond_02
Local cbCond
Local nLenAbo
Local nX
Local nLenX
Local nPkCodAbo
Local nPkHorIni
Local nPkHorFim
Local nPkHrsAbo
Local nPkCodEve
Local nPkTpMarca
Local nPkCc
Local nPkFlag
Local nPkFuncao
Local nPkDepto
Local nPkPosto
Local nPkProcesso
Local nPkPeriodo
Local nPkRoteiro
Local nPkNumPagto

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se Existir a Variavel bAboCols ( e for um bloco )   utilizada³
³ para a Montagem do aAboCols, Executa						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( Type( "bAboCols" ) == "B" )

	aTamSx3		:= TamSx3( "PK_HORINI" )
	nPkData		:= GdFieldPos( "PK_DATA"    , aAboHeader )
	nPkCodAbo	:= GdFieldPos( "PK_CODABO" 	, aAboHeader )
	nPkHorIni	:= GdFieldPos( "PK_HORINI" 	, aAboHeader )
	nPkHorFim	:= GdFieldPos( "PK_HORFIM" 	, aAboHeader )
	nPkHrsAbo	:= GdFieldPos( "PK_HRSABO" 	, aAboHeader )
	nPkCodEve	:= GdFieldPos( "PK_CODEVE" 	, aAboHeader ) 
	nPkTpMarca	:= GdFieldPos( "PK_TPMARCA"	, aAboHeader )            
	nPkCc 		:= GdFieldPos( "PK_CC"		, aAboHeader ) 
	nPkFlag		:= GdFieldPos( "PK_FLAG"	, aAboHeader ) 
	nPkFuncao	:= GdFieldPos( "PK_CODFUNC"	, aAboHeader ) 
	nPkDepto	:= GdFieldPos( "PK_DEPTO"	, aAboHeader ) 
	nPkPosto	:= GdFieldPos( "PK_POSTO"	, aAboHeader ) 
	nPkProcesso	:= GdFieldPos( "PK_PROCES"	, aAboHeader ) 
	nPkPeriodo	:= GdFieldPos( "PK_PERIODO"	, aAboHeader ) 
	nPkRoteiro	:= GdFieldPos( "PK_ROTEIR"	, aAboHeader ) 
	nPkNumPagto := GdFieldPos( "PK_NUMPAG"	, aAboHeader ) 					

	aAboCols	:= Eval( bAboCols )

	IF ( lPassTpMarca )
	   cbCond := 'aAboCols[nX, nPkTpMarca]$cTpMarca'
	EndIF
	IF ( lPassCC )
	   cbCond := IF( !Empty(cbCond) , cbCond + ' .and. ','') + 'aAboCols[nX, nPkCc]==cCC'
	EndIF
	IF ( lPassFuncao )
	   cbCond := IF( !Empty(cbCond) , cbCond + ' .and. ','') + 'aAboCols[nX, nPkFuncao]==cFuncao'
	EndIF	
	IF ( lPassDepto )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkDepto ] == cDepto'
	EndIF
	IF ( lPassPosto )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkPosto] == cPosto'
	EndIF
	IF ( lPassProcesso )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkProcesso] == cProcesso'
	EndIF
	IF ( lPassPeriodo )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkPeriodo] == cPeriodo'
	EndIF
	IF ( lPassRoteiro )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkRoteiro] == cRoteiro'
	EndIF
	IF ( lPassNumPagto )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkNumPagto] == cNumPagto'
	EndIF
	IF Empty(cbCond)
	   cbCond := '.T.'
	EndIF

	bFiltro  := &("{||"+cbCond+" }") 
	
	IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
		cCond_01	:= ( Dtos( dData ) + cPD )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem , nPkData ] ) + aAboCols[ nElem , nPkCodEve ] }
	ElseIF ( ( nHora == NIL ) .and. ( cPD == NIL ) )
		cCond_01	:= ( Dtos( dData ) )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem , nPkData ] ) }
	Else
		cCond_01	:= ( Dtos(dData) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem, nPkData ] ) + aAboCols[ nElem , nPkCodEve ] + Str( aAboCols[ nElem , nPkHorIni ] , aTamSx3[1] , aTamSx3[2] ) }
	EndIF
	               
	nLenX := Len( aAboCols )
	For nX := 1 To nLenX
		IF ( cCond_01 == Eval( cCond_02 , nX ) )
			IF Eval( bFiltro )
				IF !Empty(aAboCols[nX, nPkCodAbo]) .AND. !aAboCols[ nX, Len( aAboCols[nX] ) ]
					aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
					nLenAbo := Len( aAbonos )
					aAbonos[ nLenAbo , AABONOS_CODIGO 		] := aAboCols[ nX , nPkCodAbo 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := aAboCols[ nX , nPkHrsAbo 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := aAboCols[ nX , nPkHorIni 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := aAboCols[ nX , nPkHorFim 	]
					aAbonos[ nLenAbo , AABONOS_DATA			] := aAboCols[ nX , nPkData 	]
					aAbonos[ nLenAbo , AABONOS_CC			] := aAboCols[ nX , nPkCc	 	]
					aAbonos[ nLenAbo , AABONOS_TPMARCA		] := aAboCols[ nX , nPkTpMarca	]
					aAbonos[ nLenAbo , AABONOS_CODEVE		] := aAboCols[ nX , nPkCodEve	]
					aAbonos[ nLenAbo , AABONOS_RECNO		] := nX
					aAbonos[ nLenAbo , AABONOS_FLAG			] := aAboCols[ nX , nPkFlag		]   
					aAbonos[ nLenAbo , AABONOS_FUNCAO		] := aAboCols[ nX , nPkFuncao	]   					
					aAbonos[ nLenAbo , AABONOS_DEPTO		] := aAboCols[ nX , nPkDepto	]   					
					aAbonos[ nLenAbo , AABONOS_POSTO		] := aAboCols[ nX , nPkPosto	]   												
					aAbonos[ nLenAbo , AABONOS_PROCESSO		] := aAboCols[ nX , nPkProcesso	]   												
					aAbonos[ nLenAbo , AABONOS_PERIODO		] := aAboCols[ nX , nPkPeriodo	]   												
					aAbonos[ nLenAbo , AABONOS_ROTEIRO		] := aAboCols[ nX , nPkRoteiro	]   												
					aAbonos[ nLenAbo , AABONOS_NUM_PAGTO	] := aAboCols[ nX , nPkNumpagto	]   																																
				EndIF
				IF !Empty( aAboCols[ nX , nPkCodAbo ] ) .and. !aAboCols[ nX, Len( aAboCols[nX] ) ]
					nHrsAbo := SomaHoras( nHrsAbo , aAboCols[ nX , nPkHrsAbo ] )
				EndIF
			EndIF
		EndIF
	Next nX

EndIF
	
Return( nHrsAbo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao	   ³fAbonosPer ³ Autor ³Marinaldo de Jesus    ³ Data ³20/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Carrega no Array aAbonos    Todos os Abonos do Periodo		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fAbonosPer( aAbonos , dPerIni , dPerFim , cFil , cMat )

Local aTamSx3		:= TamSx3( "PK_HORINI" )
Local cAlias		:= "SPK"
Local cAliasQuery	:= cAlias
Local nOrder		:= RetOrdem( "SPK" , "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODEVE+STR(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")+PK_CC+PK_DEPTO+PK_POSTO+PK_CODFUNC" )
Local nOrdSPK		:= ( cAlias )->( IndexOrd() )

Local cFilMat
Local lExistAbo
Local nLenAbo

#IFDEF TOP

	Local cOldAlias			:= Alias()
	Local cPrefixo			:= ( PrefixoCpo( cAlias ) + "_" )
	Local cIniData	 		:= ""
	Local cFimData			:= ""
	Local cQuery	 		:= ""
	Local lQueryOpened		:= .F.
	Local nX				:= 0

	Static aSpkFields
	Static cQrySpkFields
	Static nSpkFields

	IF !( lExInAs400 )
	
		DEFAULT aSpkFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpkFields := Len( aSpkFields )

		IF ( cQrySpkFields == NIL )
			cQrySpkFields := ""	
			For nX := 1 To nSpkFields
				cQrySpkFields += aSpkFields[ nX , 01 ] + ", "
			Next nX
		EndIF
	
	EndIF		

#ENDIF

aAbonos := {}
DEFAULT dPerIni := Ctod("//")
DEFAULT dPerFim := Ctod("//")
DEFAULT cFil	:= SRA->RA_FILIAL
DEFAULT cMat	:= SRA->RA_MAT

IF !( nOrdSPK == nOrder )
	( cAliasQuery )->( dbSetOrder( nOrder ) )
EndIF

cFilMat := ( cFil + cMat )

#IFDEF TOP

	IF !( lExInAs400 )
		
		cIniData	:= Dtos( dPerIni )
		cFimData	:= Dtos( dPerFim )
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
		cQuery := "SELECT "
		cQuery += cQrySpkFields
		cQuery += "R_E_C_N_O_ RECNO "
		cQuery += " FROM "
		cQuery += InitSqlName( cAlias )
		cQuery += " WHERE "
		cQuery += cPrefixo + "FILIAL='"+cFil+"'"
		cQuery += " AND "
		cQuery += cPrefixo + "MAT='"+cMat+"'"
		cQuery += " AND "
		cQuery += cPrefixo + "DATA>='"+cIniData+"'"
		cQuery += " AND "
		cQuery += cPrefixo + "DATA<='"+cFimData+"'"
		cQuery += " AND "
		cQuery += "D_E_L_E_T_=' ' "
		cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
		cQuery := ChangeQuery( cQuery )
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nSpkFields
				IF !( aSpkFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQuery,aSpkFields[nX,01],aSpkFields[nX,02],aSpkFields[nX,03],aSpkFields[nX,04])
				EndIF
			Next nX
		Else
			cAliasQuery := cAlias
		EndIF	

	EndIF
				
#ENDIF

#IFNDEF TOP
	( cAliasQuery )->( MsSeek( cFilMat + Dtos( dPerIni ) , .T. ) )
#ELSE
	IF !( lQueryOpened )
		( cAliasQuery )->( MsSeek( cFilMat + Dtos( dPerIni ) , .T. ) )
	EndIF
#ENDIF

While ( cAliasQuery )->( !Eof() .and. ( ( PK_FILIAL + PK_MAT ) == cFilMat ) )
	#IFNDEF TOP
		IF ( cAliasQuery )->( ( PK_DATA < dPerIni ) .or. ( PK_DATA > dPerFim ) )
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	#ELSE
		IF !( lQueryOpened )
			IF ( cAliasQuery )->( ( PK_DATA < dPerIni ) .or. ( PK_DATA > dPerFim ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF
	    EndIF
	#ENDIF
	aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
	nLenAbo := Len( aAbonos )
	aAbonos[ nLenAbo , AABONOS_CODIGO 		] := ( cAliasQuery )->( PK_CODABO	)
	aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := ( cAliasQuery )->( PK_HRSABO	)
	aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := ( cAliasQuery )->( PK_HORINI	)
	aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := ( cAliasQuery )->( PK_HORFIM	)
	aAbonos[ nLenAbo , AABONOS_DATA			] := ( cAliasQuery )->( PK_DATA		)
	aAbonos[ nLenAbo , AABONOS_CC			] := ( cAliasQuery )->( PK_CC		)
	aAbonos[ nLenAbo , AABONOS_TPMARCA		] := ( cAliasQuery )->( PK_TPMARCA	)
	aAbonos[ nLenAbo , AABONOS_CODEVE		] := ( cAliasQuery )->( PK_CODEVE	)
	#IFNDEF TOP	
		aAbonos[ nLenAbo , AABONOS_RECNO	] := ( cAliasQuery )->( Recno() )
	#ELSE
		IF !( lQueryOpened )
			aAbonos[ nLenAbo , AABONOS_RECNO	] := ( cAliasQuery )->( Recno() )
		Else
			aAbonos[ nLenAbo , AABONOS_RECNO	] := ( cAliasQuery )->( RECNO 	)
		EndIF
	#EndIF
	aAbonos[ nLenAbo , AABONOS_FLAG			] := ( cAliasQuery )->( PK_FLAG			)
	aAbonos[ nLenAbo , AABONOS_FUNCAO		] := AllTrim(( cAliasQuery )->( PK_CODFUNC		))
	aAbonos[ nLenAbo , AABONOS_DEPTO		] := ( cAliasQuery )->( PK_DEPTO		)
	aAbonos[ nLenAbo , AABONOS_POSTO		] := ( cAliasQuery )->( PK_POSTO		)
	aAbonos[ nLenAbo , AABONOS_PROCESSO		] := AllTrim(( cAliasQuery )->( PK_PROCES		))
	aAbonos[ nLenAbo , AABONOS_PERIODO		] := ( cAliasQuery )->( PK_PERIODO		)
	aAbonos[ nLenAbo , AABONOS_ROTEIRO		] := ( cAliasQuery )->( PK_ROTEIR		)
	aAbonos[ nLenAbo , AABONOS_NUM_PAGTO	] := ( cAliasQuery )->( PK_NUMPAG		)				
	( cAliasQuery )->(  dbSkip() )
End While

#IFDEF TOP
	IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cOldAlias )
   	EndIF
#ENDIF

lExistAbo := ( Len( aAbonos ) > 0 )

IF !( nOrdSPK == nOrder )
	SPK->( dbSetOrder( nOrdSPK ) )
EndIF

Return( lExistAbo )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ RetSeq   ³ Autor ³ Alexsandro Pereira    ³ Data ³ 25/08/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna a sequencia inicial do turno de um periodo qualquer³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ RetSeq(cSeqAtual,cTurno,dPerIni,dPerFim,dData,aTabPadrao)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cSeqAtual  - Sequencia do periodo atual                    ³±±
±±³          ³ cTurno     - Turno de trabalho atual                       ³±±
±±³          ³ dPerIni    - Data inicio do periodo a se calcular sequencia³±±
±±³          ³ dPerFim    - Data fim do periodo a se calcular sequencia   ³±±
±±³          ³ dData      - Data referente ao periodo para calculo sequenc³±±
±±³          ³ aTabPadrao - Tabela de horario padrao                      ³±±
±±³          ³ cSeqAnt    - Sequencia anterior calculada (retornado p/fun)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function RetSeq(cSeqAtual,cTurno,dPerIni,dPerFim,dData,aTabPadrao,cSeqAnt,cFil)

//-- Calcula a sequencia inicial do periodo retroativo
//-- funcao chamada quando nao houver troca de turno.
Local dPerAntIni := Ctod('  /  /  ')	//-- Data inicial do periodo anterior
Local dPerAntFim := Ctod('  /  /  ')	//-- Data final do periodo anterior
Local dDataSeg   := Ctod('  /  /  ')	//-- Data da ultima segunda-feira
Local nSemanas   := 0					//-- Numero de semanas
Local nQtdSeq    := 0					//-- Quantidade de sequencias da tabela de horario padrao
Local nPosTab    := 0					//-- Posicao do turno na tabela de horario padrao
Local cFilSPF    := SRA->RA_FILIAL		//-- Codigo da filial do arquivo SPF

DEFAULT cFil := cFilAnt

//-- Quando a sequencia nao for informada, assume-se "01"
cSeqAtual := If(cSeqAtual==Nil .Or. Val(cSeqAtual)=0,'01',cSeqAtual)

//-- Obtem o total de sequencias da tabela
If (nPosTab := aScan(aTabPadrao, { |x| x[1] == fFilFunc('SPJ') .And. x[2] == cTurno })) > 0
	nQtdSeq := Val(aTabPadrao[nPosTab,3,Len(aTabPadrao[nPosTab,3]),16])
	//nQtdSeq := Val(aTabPadrao[nPosTab,3,Len(aTabPadrao[nPosTab,3]),19])
Endif

//-- Carrega o periodo de apontamento.
If !PerAponta(@dPerAntIni,@dPerAntFim,dData,NIL,cFil)
	Return .F.
Endif

//-- verifica as trocas de turno a partir do periodo escolhido ate a data atual
If SPF->(dbSeek(cFilSPF+SRA->RA_MAT+DTos(dPerIni),.T.))
	If SPF->PF_FILIAL+SPF->PF_MAT == cFilSPF+SRA->RA_MAT .And. SPF->PF_DATA <= dPerAntIni-1
		//-- Carrega o periodo de apontamento.
		cSeqAtual := SPF->PF_SEQUEDE
		cTurno    := SPF->PF_TURNODE
		//-- Carrega o periodo de apontamento.
		If !PerAponta(@dPerAntIni,@dPerAntFim,SPF->PF_DATA,NIL,cFil)
			Return .F.
		Endif
	Endif
Endif

//-- Se a data fim do antepenultimo periodo nao for na segunda-feira
If Dow(dPerAntIni-1) # 2
	//-- Obtem a data da segunda-feira do antepenultimo periodo.
	dDataSeg := (dPerAntIni-1) - (Dow(dPerAntIni-1) - 2)
	Else
	dDataSeg := dPerAntIni-1
Endif

//-- Calcula o numero de semanas decorridas desde a data inicial do periodo a obter a sequencia.
nSemanas  := If((nSemanas:=(dDataSeg-dPerIni)/7) > Int(nSemanas),Int(nSemanas := nSemanas + 1),nSemanas)
cSeqAnt   := Val(cSeqAtual)-nSemanas
cSeqAnt   := If(cSeqAnt<=1,nQtdSeq + cSeqAnt ,cSeqAnt)
cSeqAnt   := StrZero(ABS(cSeqAnt),2)

Return (cSeqAnt<>cSeqAtual)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ fGeraExtra³ Autor ³ Mauro Sergio          ³ Data ³ 07/11/96 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Gerar a Verba de Horas Extras                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Geracao de Horas Extras                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGeraExtra(	aTabExtra	,;	//01 -> Array contendo os Tipos de Horas Extras
						cTpExtra	,;	//02 -> Tipo de Hora Extra a ser Gerado
						nThoras		,;	//03 -> Numero de Horas Extras Autorizadas	
						nTNhoras	,;	//04 -> Numero de Horas Extras Nao Autorizadas	
						aResult		,;	//05 -> Array com os Resultados do Apontamento do Dia
						aTotais		,;	//06 -> Array com os Totais Apontados por Evento do Dia 
						dData		,;	//07 -> Data da Gravacao
						cRotina		,;	//08 -> Rotina Chamadora da Funcao
						cPeriodo	,;	//09 -> Periodo de Apuracao 
						lSoma		,;	//10 -> Soma ao Valor Existente
						cCusto		,;	//11 -> Centro de Custo Para Gravacao
						cTpMarc		,;	//12 -> Tipo de Marcacao
						lMvAcmHExt	,;	//13 -> Considerar Todas as Horas Extras do Dia Para o Escalonamento
						lSubstitui	,;	//14 -> Se Substitui as Horas Existentes
						cFuncao		,;  //15 -> Funcao para gravacao
						cDepto		,;  //16 -> Depto para gravacao
						cPosto		,;  //17 -> Posto para gravacao  
						cProcesso   ,;  //18 -> Processo para Gravacao								
						cRoteiro	,;  //19 -> Roteiro para Gravacao
						cPeriodo	,;  //20 -> Periodo para Gravacao								
						cNumPagto	;   //21 -> NumPagto para Gravacao												
					)

Local aExTipo

Local bEvalSomaA
Local bEvalSomaN

Local cEvento

Local lRotFec

Local nResto
Local nHoras
Local nPos
Local nX
Local nFornX
Local nN

DEFAULT nThoras		:= 0
DEFAULT nTNhoras	:= 0

IF (;
		( nThoras > 0 );
		.or.;
		( nTNhoras > 0 );
	)

	aExTipo := {}
	nResto  := 0

	DEFAULT lSoma			:= .F.
	DEFAULT cCusto			:= Space( GetSx3Cache( "PC_CC" 			, "X3_TAMANHO" ) )
	DEFAULT cTpMarc 		:= Space( GetSx3Cache( "PC_TPMARCA"		, "X3_TAMANHO" ) )
	DEFAULT cFuncao 		:= Space( GetSx3Cache( "PC_CODFUNC"		, "X3_TAMANHO" ) )
	DEFAULT cDepto 			:= Space( GetSx3Cache( "PC_DEPTO"		, "X3_TAMANHO" ) )
	DEFAULT cPosto 			:= Space( GetSx3Cache( "PC_POSTO"		, "X3_TAMANHO" ) )
	DEFAULT cProcesso 		:= Space( GetSx3Cache( "PC_PROCES"		, "X3_TAMANHO" ) )
	DEFAULT cPeriodo 		:= Space( GetSx3Cache( "PC_PERIODO"		, "X3_TAMANHO" ) )
	DEFAULT cRoteiro 		:= Space( GetSx3Cache( "PC_ROTEIR"		, "X3_TAMANHO" ) )
	DEFAULT cNumPagto 		:= Space( GetSx3Cache( "PC_NUMPAG"		, "X3_TAMANHO" ) )	
	DEFAULT lMvAcmHExt		:= .F.
	
	//-- 'APO' para Apontamento e 'FEC' para Fechamento
	cRotina  := IF( Empty( cRotina )  , "APO" , Upper( cRotina  ) )
	cPeriodo := IF( Empty( cPeriodo ) , "D"   , Upper( cPeriodo ) )

	lRotFec  := ( cRotina == "FEC" )

	Begin Sequence
	
		IF ( lMvAcmHExt )
			ToScheduleOverTime(	aTabExtra	,;	//Array contendo os Tipos de Horas Extras
								cTpExtra	,;	//Tipo de Hora Extra a ser Gerado
								nThoras		,;	//Numero de Horas Extras Autorizadas
								nTNhoras	,;	//Numero de Horas Extras Nao Autorizadas
								aResult		,;	//Array com os Resultados do Apontamento do Dia
								aTotais		,;	//Array com os Totais Apontados por Evento do Dia
								dData		,;	//Data da Gravacao
								cRotina		,;	//Rotina Chamadora da Funcao
								cPeriodo	,;	//Periodo de Apuracao
								lSoma		,;	//Soma ao Valor Existente
								cCusto		,;	//Centro de Custo Para Gravacao
								cTpMarc		,;	//Tipo de Marcacao
								lSubstitui	,;	//Se Substitui as Horas Existentes 
								cFuncao		,;  //Funcao para Gravacao
								cDepto		,;  //Depto para Gravacao
								cPosto		,;  //Posto para Gravacao
								cProcesso	,;  //Processo para Gravacao																								
								cPeriodo	,;  //Periodo para Gravacao
								cRoteiro	,;  //Processo para Gravacao								
								cNumPagto	;   //NumPagto para Gravacao
							)
			Break
	    EndIF
		
		//--Gerar Array do Tipo Desejado
		aExTipo := GetExTipo( aTabExtra , @cTpExtra )

		IF ( lSoma )
			IF !( lRotFec )
				bEvalSomaA	:= { |x| IF(;
											(;
												( x[ ARESULT_DATA ] == dData );
												.and.;
												( x[ ARESULT_EVENTO ] == aExTipo[ nX , 4 ] );
												.and.;
												( x[ ARESULT_CC ] == cCusto );
												.and.;
												( x[ ARESULT_TPMARCA ] == cTpMarc );  
												.and.;
												( x[ ARESULT_FUNCAO	] == cFuncao);		
												.and.;
												( x[ ARESULT_DEPTO	] == cDepto );		
												.and.;
												( x[ ARESULT_POSTO	] == cPosto );																										
												.and.;
												( x[ ARESULT_PROCESSO	] == cProcesso);	
												.and.;
												( x[ ARESULT_PERIODO	] == cPeriodo);	
												.and.;
												( x[ ARESULT_ROTEIRO	] == cRoteiro);	
												.and.;
												( x[ ARESULT_NUM_PAGTO	] == cNumPagto);																																																			
											),;
											(;
												nThoras := SomaHoras( nThoras , x[ ARESULT_HORAS ] ),;
												x[ ARESULT_HORAS ] := 0;
											),;
											NIL;
										);
								}
				bEvalSomaN	:= { |x| IF(;
											(;
												( x[ ARESULT_DATA ] == dData );
												.and.;
												( x[ ARESULT_EVENTO ] == aExTipo[ nX , 5 ] );
												.and.;
												( x[ ARESULT_CC ] == cCusto );
												.and.;
												( x[ ARESULT_TPMARCA ] == cTpMarc );
												.and.;
												( x[ ARESULT_FUNCAO	] == cFuncao);
	  									  		.and.;
												( x[ ARESULT_DEPTO	] == cDepto );		
												.and.;
												( x[ ARESULT_POSTO	] == cPosto );																										
												.and.;
												( x[ ARESULT_PROCESSO	] == cProcesso);	
												.and.;
												( x[ ARESULT_PERIODO	] == cPeriodo);	
												.and.;
												( x[ ARESULT_ROTEIRO	] == cRoteiro);	
												.and.;
												( x[ ARESULT_NUM_PAGTO	] == cNumPagto);																												
											),;
											(;
												nTNhoras := SomaHoras( nTNhoras , x[ ARESULT_HORAS ] ),;
												x[ ARESULT_HORAS ] := 0;
											),;
											NIL;
										);
								}
			Else
				bEvalSomaA	:= { |x| IF(;
											(;
												( x[ ATOTAIS_DATA ] == dData );
												.and.;
												( x[ ATOTAIS_EVENTO_PONTO ] == aExTipo[ nX , 4 ] );
												.and.;
												( x[ ATOTAIS_CENTRO_DE_CUSTO ] == cCusto );
												.and.;
												( x[ ARESULT_FUNCAO	] == cFuncao);
								  				.and.;
												( x[ ARESULT_DEPTO	] == cDepto );		
												.and.;
												( x[ ARESULT_POSTO	] == cPosto );																										
												.and.;
												( x[ ARESULT_PROCESSO	] == cProcesso);	
												.and.;
												( x[ ARESULT_PERIODO	] == cPeriodo);	
												.and.;
												( x[ ARESULT_ROTEIRO	] == cRoteiro);	
												.and.;
												( x[ ARESULT_NUM_PAGTO	] == cNumPagto);																
											),;
											(;
												nThoras := SomaHoras( nThoras , x[ ATOTAIS_HORAS ] ),;
												x[ ATOTAIS_HORAS ] := 0;
											),;
											NIL;
										);
								}
				bEvalSomaN	:= { |x| IF(;
											(;
												( x[ ATOTAIS_DATA ] == dData );
												.and.;
												( x[ ATOTAIS_EVENTO_PONTO ] == aExTipo[ nX , 5 ] );
												.and.;
												( x[ ATOTAIS_CENTRO_DE_CUSTO ] == cCusto ); 
												.and.;
												( x[ ARESULT_FUNCAO	] == cFuncao); 
												.and.;
												( x[ ARESULT_PROCESSO	] == cProcesso);	
												.and.;
												( x[ ARESULT_PERIODO	] == cPeriodo);	
												.and.;
												( x[ ARESULT_ROTEIRO	] == cRoteiro);	
												.and.;
												( x[ ARESULT_NUM_PAGTO	] == cNumPagto);																												
											),;
											(;
												nTNhoras := SomaHoras( nTNhoras , x[ ATOTAIS_HORAS ] ),;
												x[ ATOTAIS_HORAS ] := 0;
											),;
											NIL;
										);
								}
			EndIF
			//--Soma Horas Quando Existir mais de uma Geracao para o mesmo dia
			nFornX	:= Len( aExTipo )
			For nX := 1 To nFornX
				IF !Empty( nThoras )
					IF ( lRotFec )
						aEval( aTotais , bEvalSomaA )
					Else
						aEval( aResult , bEvalSomaA )
					EndIF	
				EndIF
				IF !Empty( nTNhoras )
					IF ( lRotFec )
						aEval( aTotais , bEvalSomaN )
					Else
						aEval( aResult , bEvalSomaN )
					EndIF	
				EndIF
			Next nX
		EndIF

		//-- 1o. para Autorizado e 2o. para Nao Autorizada
		For nN := 1 To 2
			nResto := IF( nN == 1 , nThoras , nTNhoras )
			//-- Aplicar a Tabela de Horas Extras		
			While ( nResto > 0 )
				//--Procura a faixa de horas
				IF ( ( nPos := aScan( aExTipo , { |x| nResto >= x[2] .And. nResto <= x[3] } ) ) > 0 )
					cEvento := aExTipo[ nPos , IF( nN == 1 , 4 , 5 ) ]
					nHoras  := SubHoras( nResto , SubHoras( aExTipo[ nPos , 2 ] , 0.01 ) )
					//--Gerar no Array de Resultado e Totais
					IF !( lRotFec )
						fGeraRes(	@aResult	,; //01 -> Array com os Resultados
									dData		,; //02 -> Data da Gravacao	
									nHoras		,; //03 -> Valor a Ser Gravado	
									cEvento		,; //04 -> Codigo onde Gravar
									cCusto		,; //05 -> Centro de Custo Onde Gravar
									cTpMarc		,; //06 -> Tipo da Marcacao
									lSoma		,; //07 -> Se soma a valor ja Existente
									cPeriodo	,; //08 -> Periodo para a Tolerancia
									0			,; //09 -> Tolerancia
									"H"			,; //10 -> Tipo de Arredondamento a Ser considerado
									lSubstitui	,; //11 -> Substitui a(s) Hora(s) Existente(s) em aResult
									cFuncao		,; //12 -> Funcao
									cDepto		,; //13 -> Depto para gravacao     
									cPosto		,; //14 -> Posto para gravacao									
									cProcesso	,; //15 -> Processo para Gravacao
									cRoteiro	,; //16 -> Roteiro para Gravacao								
									cPeriodo	,; //17 -> Periodo para Gravacao
									cNumPagto	;  //18 -> NumPagto para Gravacao								
								 )
					Else
						IF ( lSubstitui == NIL )
							lSubstitui := !( lSoma )
						EndIF
						fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
									dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
									nHoras			,;	//03 -> Horas para Soma ou Geracao
									0   			,;	//04 -> Valor para Soma ou Geracao
									cEvento			,;	//05 -> Evento do Ponto para Pesquisa
									cCusto			,;	//06 -> Centro de Custo para Comparacao
									SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9									
									NIL				,;	//08 -> Verba da Folha
									lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais
									cFuncao			,;	//10 -> funcao para Comparacao   
									cDepto			,;  //11 -> Depto para gravacao
									cPosto			,;  //12 -> Posto para gravacao
									cProcesso		,;  //13 -> Processo para Gravacao
									cRoteiro		,;  //14 -> Roteiro para Gravacao								
									cPeriodo		,;  //15 -> Periodo para Gravacao
									cNumPagto		;   //16 -> NumPagto para Gravacao								
								)
					EndIF
					nResto  := SubHoras( nResto , SubHoras( nResto , SubHoras( aExTipo[ nPos , 2 ] , 0.01 ) ) )
				Else
					Exit
				EndIF
			End While
		
		Next nN

	End Sequence
	
EndIF
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ToScheduleOverTime³Autor ³Marinaldo de Jesus ³Data³11/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gerar Horas Extras Escalonads                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Geracao de Horas Extras                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ToScheduleOverTime(	aTabExtra	,;	//01 -> Array contendo os Tipos de Horas Extras
								cTpExtra	,;	//02 -> Tipo de Hora Extra a ser Gerado
								nThoras		,;	//03 -> Numero de Horas Extras Autorizadas
								nTNhoras	,;	//04 -> Numero de Horas Extras Nao Autorizadas
								aResult		,;	//05 -> Array com os Resultados do Apontamento do Dia
								aTotais		,;	//06 -> Array com os Totais Apontados por Evento do Dia
								dData		,;	//07 -> Data da Gravacao
								cRotina		,;	//08 -> Rotina Chamadora da Funcao
								cPeriodo	,;	//09 -> Periodo de Apuracao
								lSoma		,;	//10 -> Soma ao Valor Existente
								cCusto		,;	//11 -> Centro de Custo Para Gravacao
								cTpMarc		,;	//12 -> Tipo de Marcacao
								lSubstitui	,;	//13 -> Se Substitui as Horas Existentes 
								cFuncao		,;  //14 -> Funcao para Gravacao
								cDepto		,;  //15 -> Depto para Gravacao
								cPosto		,;  //16 -> Posto para Gravacao
								cProcesso	,;  //17 -> Processo para Gravacao																								
								cPeriodo	,;  //18 -> Periodo para Gravacao
								cRoteiro	,;  //19 -> Processo para Gravacao								
								cNumPagto	;   //20 -> NumPagto para Gravacao
							)

Local aExTipo		:= {}
Local lAutoriza		:= .F.
Local lRotFec		:= ( cRotina == "FEC" )

Local cEvento
Local cHeKeyAtu
Local cTipoDia

Local nResto
Local nHoras
Local nPos
Local nPosPlus1
Local nPos1
Local nN
Local nLenExt
Local nLenGer
Local nPosTpDia

DEFAULT nThoras			:= 0
DEFAULT nTNhoras		:= 0
DEFAULT __aHeLastGera__	:= {}
DEFAULT __cHeLastKey__	:= "__cHeLastKey__"

//--Gerar Array do Tipo Desejado
aExTipo 	:= GetExTipo( aTabExtra , @cTpExtra )
nLenExt 	:= Len( aExTipo )
cTipoDia	:= GetDiaToEx( cTpExtra )

cHeKeyAtu	:= ( FWCODEMP("SPC") + cFilAnt + SRA->RA_MAT + Dtos( dData ) )
IF !( cHeKeyAtu == __cHeLastKey__ )
	__aHeLastGera__	:= {}
	__cHeLastKey__	:= cHeKeyAtu
	aAdd( __aHeLastGera__ , { cTipoDia , nThoras , nTNhoras , {} } )
	nPosTpDia := Len( __aHeLastGera__ )
Else
	IF ( ( nPosTpDia := aScan( __aHeLastGera__ , { |x| x[1] == cTipoDia } ) ) == 0 )
		aAdd( __aHeLastGera__ , { cTipoDia , 0 , 0 , {} } )
		nPosTpDia := Len( __aHeLastGera__ )
	EndIF
	__aHeLastGera__[ nPosTpDia , 02 ] := SomaHoras( __aHeLastGera__[ nPosTpDia , 02 ] , nThoras	 )
	__aHeLastGera__[ nPosTpDia , 03 ] := SomaHoras( __aHeLastGera__[ nPosTpDia , 03 ] , nTNhoras )
EndIF

//-- 1o. para Autorizado e 2o. para Nao Autorizada
For nN := 1 To 2
	lAutoriza := ( nN == 1 )
	nResto := IF( ( lAutoriza ) , __aHeLastGera__[ nPosTpDia , 02 ] , __aHeLastGera__[ nPosTpDia , 03 ] )
	nPos := 0
	While ( nResto > 0 ) .and. ( ++nPos <= nLenExt )
		//-- Aplicar a Tabela de Horas Extras
		nPosPlus1	:= Min( nPos + 1 , nLenExt )
		nHoras  	:= Min( nResto , SubHoras( aExTipo[ Min( nPosPlus1 , nLenExt ) , 02 ] , aExTipo[ nPos , 02 ] ) )
		nHoras 		:= IF( nHoras == 0 , nResto , nHoras )
		nResto		:= SubHoras( nResto , nHoras )
		cEvento 	:= aExTipo[ nPos , IF( ( lAutoriza ) , 04 , 05 ) ]
		nPos1 		:= 0
		nLenGer 	:= Len( __aHeLastGera__[ nPosTpDia , 04 ] )
		//-- Subtrai da quantidade de Horas remanescentes o total de horas ja enviadas para 
		//-- o aResult
		While ( ++nPos1 <= nLenGer )
			IF ( ;
					__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 01 ] == nPos;
					.and.;
					__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 04 ] == lAutoriza;
					.and.;
					(;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 03 ] <> cEvento;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 05 ] <> cTpMarc;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 06 ] <> cCusto;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 07 ] <> cFuncao;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 08 ] <> cProcesso;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 09 ] <> cPeriodo;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 10 ] <> cRoteiro;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 11 ] <> cNumpagto;																								
					);
				)
				nHoras  := SubHoras( nHoras , __aHeLastGera__[ nPosTpDia , 04 , nPos1 , 02 ] )
			EndIF
		End While  
		//-- Substitui o total de horas da faixa para o evento pelo total de horas calculadas
		IF ( nPos1 := aScan( __aHeLastGera__[ nPosTpDia , 04 ]	, { |x|	x[1] == nPos;
																		.and.;
																		x[3] == cEvento;
																		.and.;
																		x[4] == lAutoriza;
																		.and.;
																		x[5] == cTpMarc;
																		.and.;
																		x[6] == cCusto;
																		.and.;
																		x[7] == cFuncao;
																		.and.;
																		x[8] == cProcesso;
																		.and.;
																		x[9] == cPeriodo;
																		.and.;
																		x[10] == cRoteiro;
																		.and.;
																		x[11] == cNumPagto;																																																																								
												  	   			  };
							);
			 ) > 0
			__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 02 ] := nHoras
		Else
			aAdd( __aHeLastGera__[ nPosTpDia , 04 ] , { nPos , nHoras , cEvento , lAutoriza , cTpMarc , cCusto, cFuncao, cProcesso, cPeriodo, cRoteiro, cNumPagto } )
		EndIF
		//--Gerar no Array de Resultado e Totais
		IF !Empty( nHoras )
			IF !( lRotFec )
				DEFAULT lSubstitui		:= .T.
				fGeraRes(	@aResult			,; //01 -> Array com os Resultados
							dData				,; //02 -> Data da Gravacao	
							nHoras				,; //03 -> Valor a Ser Gravado	
							cEvento				,; //04 -> Codigo onde Gravar
							cCusto				,; //05 -> Centro de Custo Onde Gravar
							cTpMarc				,; //06 -> Tipo da Marcacao
							lSoma				,; //07 -> Se soma a valor ja Existente
							cPeriodo			,; //08 -> Periodo para a Tolerancia
							0   				,; //09 -> Tolerancia
							"H" 				,; //10 -> Tipo de Arredondamento a ser Considerado
							lSubstitui			,; //11 -> Substitui a(s) Hora(s) Existente(s) em aResult
							cFuncao	 			,; //12 -> Funcao
							cDepto				,; //13 -> Depto para gravacao
							cPosto				,; //14 -> Posto para gravacao
							cProcesso			,; //15 -> Processo para Gravacao
							cRoteiro			,; //16 -> Roteiro para Gravacao								
							cPeriodo			,; //17 -> Periodo para Gravacao
							cNumPagto	 		;  //18 -> NumPagto para Gravacao								
						 )
			Else
				IF ( lSubstitui == NIL )
					lSubstitui := !( lSoma )
				EndIF
				fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
							dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							nHoras			,;	//03 -> Horas para Soma ou Geracao
							0   			,;	//04 -> Valor para Soma ou Geracao
							cEvento			,;	//05 -> Evento do Ponto para Pesquisa
							cCusto			,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9
							NIL				,;	//08 -> Verba da Folha
							lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais
							cFuncao			,;	//10 -> funcao para Comparacao   
							cDepto			,;  //11 -> Depto para gravacao
							cPosto			,;  //12 -> Posto para gravacao
							cPeriodo		,;  //13 -> Periodo para Gravacao
							cRoteiro		,;  //14 -> Processo para Gravacao								
							cNumPagto		;   //15 -> NumPagto para Gravacao
						)
			EndIF
		EndIF
	End While	
Next nN

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstToScheduleOverTime³Aut³Marinaldo de Jesus³Data³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em ToScheduleOverTime() ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstToScheduleOverTime()

__aHeLastGera__ := NIL
__cHeLastKey__	:= "__cHeLastKey__"

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetExTipo		  ³Autor ³Marinaldo de Jesus ³Data³28/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Array com o Tipo de Hora Extra a ser utilizado       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Geracao de Horas Extras                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetExTipo( aTabExtra , cTpExtra )

Local aExTipo	:= {}
Local bEval		:= { |x| IF( x[1] == cTpExtra , aAdd( aExTipo , x ) , NIL ) }

aEval( aTabExtra , bEval )

//-- Quando nao Encotrar o Tipo de Hora Extra Exato, Procura o Tipo Correspondente
//-- 5=1;6=2;7=3;8=4	//HE Noturnas/Normais	
//-- B=A;D=C;F=E;H=G	//HE Intervalos Noturnas/Normais
IF Empty( aExTipo )
	Do Case
		Case ( cTpExtra $ "H_G" )			//Tipos de Intervalo Feriado
			IF ( cTpExtra == "H" )			//Hora Extra Intervalo Noturna Feriado
				cTpExtra	:= "8"			//Hora Extra Feriado Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "G"    	//Hora Extra Intervalo Diurna Feriado
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra	:= "4"		//Hora Extra Feriado Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "G" )		//Hora Extra Intervalo Diurna Feriado
				cTpExtra	:= "4"			//Hora Extra Feriado Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "F_E" )			//Tipos de Intervalo Compensado
			IF ( cTpExtra == "F" )			//Hora Extra Intervalo Noturna Compensado
				cTpExtra	:= "7"			//Hora Extra Compensado Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "E"	    //Hora Extra Intervalo Diurna Compensado
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra	:= "3"		//Hora Extra Compensado Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "E" )		//Hora Extra Intervalo Diurna Compensado
				cTpExtra := "3"				//Hora Extra Compensado Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "D_C" )			//Tipos de Intervalo DSR
			IF ( cTpExtra == "D" )			//Hora Extra Intervalo Noturna DSR
				cTpExtra	:= "6"			//Hora Extra DSR Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra := "C"			//Hora Extra Intervalo Diurna DSR
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra := "2"			//Hora Extra DSR Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "C" )		//Hora Extra Intervalo Diurna DSR
				cTpExtra := "2"				//Hora Extra DSR Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "B_A" )			//Tipos de Intervalo Normal
			IF ( cTpExtra == "B" )			//Hora Extra Intervalo Noturna Normal
				cTpExtra	:= "5"			//Hora Extra Noturna Normal
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "A"		//Hora Extra Intervalo Normal
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra := "1"			//Hora Extra Normal
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "A" )		//Hora Extra Intervalo Normal
				cTpExtra := "1"				//Hora Extra Normal
				aEval( aTabExtra , bEval )
			EndIF	
		OtherWise							//Tipos de Horas Extras
			cTpExtra := IF( Val( cTpExtra ) > 4 , StrZero( Val( cTpExtra ) - 4 , 1 ) , cTpExtra )
			aEval( aTabExtra , bEval )
	EndCase
EndIF

Return( aExTipo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetTpExInt		  ³Autor ³Marinaldo de Jesus ³Data³10/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Tipo de Hora Extra de Intervalo Conforme Tipo do Dia ³
³          ³ou Tipo de Hora Extra										 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTpExInt( cTpDiaExt , lNoturna )

Local cTpExtInt		:= "A"

DEFAULT cTpDiaExt	:= "S"
DEFAULT lNoturna	:= .F.

Do Case
	Case ( cTpDiaExt $ "F_8_4" ) ; ( cTpExtInt := IF( lNoturna , "H" , "G" ) )	//Feriado
	Case ( cTpDiaExt $ "C_7_3" ) ; ( cTpExtInt := IF( lNoturna , "F" , "E" ) )	//Compensado
	Case ( cTpDiaExt $ "D_6_2" ) ; ( cTpExtInt := IF( lNoturna , "D" , "C" ) )	//DSR
	Case ( cTpDiaExt $ "S_5_1" ) ; ( cTpExtInt := IF( lNoturna , "B" , "A" ) )	//Normal
End Case

Return( cTpExtInt )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetDiaToEx		  ³Autor ³Marinaldo de Jesus ³Data³22/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Tipo do Dia de Acordo com o Tipo de Horas Extras     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetDiaToEx( cTpExtra )

Local cTipoDia	:= ""

DEFAULT cTpExtra := "S"

Do Case
	Case ( cTpExtra $ "F_8_4" ) ; ( cTipoDia := "F" )	//Feriado
	Case ( cTpExtra $ "C_7_3" ) ; ( cTipoDia := "C" )	//Compensado
	Case ( cTpExtra $ "D_6_2" ) ; ( cTipoDia := "D" )	//DSR
	Case ( cTpExtra $ "S_5_1" ) ; ( cTipoDia := "S" )	//Normal
End Case

Return( cTipoDia )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGeraRes     ³Autor ³Equipe Advanced RH   ³ Data ³01/04/1997³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gerar no Array a Result os Resultados do Apontamento        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
Function fGeraRes(	aResult		,; //01 -> Array com os Resultados do Dia
					dDtGer		,; //02 -> Data da Geracao
					nHoras		,; //03 -> Numero de Horas Resultantes
					cEvento		,; //04 -> Codigo do Evento
					cCusto		,; //05 -> Centro de Custo a ser Gravado
					cTpMarc		,; //06 -> Tipo de Marcacao
					lSoma		,; //07 -> True para Acumular as Horas
					cPeriodo	,; //08 -> Periodo de Apuracao
					nTole		,; //09 -> Tolerancia
					cArred		,; //10 -> Tipo de Arredondamento a Ser Utilizado
					lSubstitui	,; //11 -> Substitui a(s) Hora(s) Existente(s)
					cFuncao		,; //12 -> Funcao  
  					cDepto		,; //13 -> Depto para gravacao
					cPosto		,; //14 -> Posto para gravacao
					cProcesso	,; //15 -> Periodo para Gravacao
					cRoteiro	,; //16 -> Processo para Gravacao
					cPerApo		,; //17 -> Periodo para Gravacao
					cNumPagto	 ; //18 -> NumPagto para Gravacao								
				  )

Local bAsc
Local nRes

DEFAULT cEvento 	:= ""
DEFAULT nHoras		:= 0
DEFAULT cPeriodo	:= ""
DEFAULT nTole		:= 0

IF !Empty( cEvento ) .and. ( nHoras > 0 ) .and. IF( cPeriodo == "D" , IF( ( nTole > 0 ) , ( nHoras > nTole ) , .T. ) , .T. )
 
	DEFAULT aResult 	:= {}
	DEFAULT dDtGer  	:= dDataBase
	DEFAULT cCusto  	:= Space( GetSx3Cache( "PC_CC"		, "X3_TAMANHO" ) )
	DEFAULT cTpMarc		:= Space( GetSx3Cache( "PC_TPMARCA"	, "X3_TAMANHO" ) )
	DEFAULT lSoma   	:= .F.
	DEFAULT cArred		:= ""
	DEFAULT lSubstitui	:= .F.
	DEFAULT cFuncao  	:= Space( GetSx3Cache( "PC_CODFUNC"	, "X3_TAMANHO" ) )
	DEFAULT cDepto   	:= Space( GetSx3Cache( "PC_DEPTO"	, "X3_TAMANHO" ) )
	DEFAULT cPosto   	:= Space( GetSx3Cache( "PC_POSTO"	, "X3_TAMANHO" ) )
	DEFAULT cProcesso	:= Space( GetSx3Cache( "PC_PROCES"  , "X3_TAMANHO" ) )
	DEFAULT cPerApo 	:= Space( GetSx3Cache( "PC_PERIODO"	, "X3_TAMANHO" ) )
	DEFAULT cRoteiro 	:= Space( GetSx3Cache( "PC_ROTEIR"	, "X3_TAMANHO" ) )
	DEFAULT cNumPagto 	:= Space( GetSx3Cache( "PC_NUMPAG"  , "X3_TAMANHO" ) )

	
	bAsc	:= { |x| 	x[ARESULT_DATA] 	== dDtGer 		.and. ;
						x[ARESULT_EVENTO] 	== cEvento 		.and. ;
						x[ARESULT_CC] 		== cCusto 		.and. ;
						x[ARESULT_TPMARCA] 	== cTpMarc 		.and. ;
						x[ARESULT_FUNCAO] 	== cFuncao  	.and. ;
						x[ARESULT_DEPTO] 	== cDepto   	.and. ;						
						x[ARESULT_POSTO] 	== cPosto   	.and. ;
						x[ARESULT_PROCESSO]	== cProcesso	.and. ;
						x[ARESULT_PERIODO] 	== cPerApo  	.and. ;
						x[ARESULT_ROTEIRO] 	== cRoteiro  	.and. ;																								
						x[ARESULT_NUM_PAGTO] == cNumPagto   		  ;																														
				}

	nRes	:= 0

	lSoma := IF( lSoma .and. lSubstitui , !( lSubstitui ) , lSoma )
	IF ( ( lSoma .or. lSubstitui ) .and. ( nRes := aScan( aResult , bAsc  ) ) > 0 )
		IF ( lSoma )
			aResult[ nRes , ARESULT_HORAS ] := SomaHoras( aResult[ nRes , ARESULT_HORAS ] , nHoras )
		ElseIF ( lSubstitui )
			aResult[ nRes , ARESULT_HORAS ] := nHoras
		EndIF
	Else
		aAdd( aResult , Array( ELEMENTOS_ARESULT ) )
		nRes := Len( aResult )
		aResult[ nRes , ARESULT_DATA 		] := dDtGer			//01 - Data da Geracao
		aResult[ nRes , ARESULT_EVENTO		] := cEvento		//02 - Codigo do Evento
		aResult[ nRes , ARESULT_HORAS		] := nHoras			//03 - Horas
		aResult[ nRes , ARESULT_CC			] := cCusto			//04 - Centro de Custo
		aResult[ nRes , ARESULT_TPMARCA		] := cTpMarc		//05 - Tipo da Marcacao
		aResult[ nRes , ARESULT_ARRED		] := cArred			//06 - Tipo de Arredondamento a Ser Utilizado
		aResult[ nRes , ARESULT_DTOS_DATA	] := Dtos( dDtGer )	//07 - String de Data
		aResult[ nRes , ARESULT_NUM_ABO_HRS	] := 0				//08 - Qtde Horas Abonadas do Evento
		aResult[ nRes , ARESULT_RESULT_APO	] := {}				//09 - Array de Horarios Abonados para o Evento
		aResult[ nRes , ARESULT_FUNCAO	    ] := cFuncao		//10 - Funcao
		aResult[ nRes , ARESULT_DEPTO	    ] := cDepto			//15 - Depto 
		aResult[ nRes , ARESULT_POSTO	    ] := cPosto			//16 - Posto 
		aResult[ nRes , ARESULT_PROCESSO    ] := cProcesso		//11 - Processo
		aResult[ nRes , ARESULT_PERIODO	    ] := cPerApo 		//12 - Periodo
		aResult[ nRes , ARESULT_ROTEIRO	    ] := cRoteiro		//13 - Roteiro 	
		aResult[ nRes , ARESULT_NUM_PAGTO   ] := cNumPagto		//14 - NumPagto			
	EndIF

EndIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³AjustaResult ³Autor ³Marinaldo de Jesus   ³ Data ³18/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Ajustar as Horas em aResult os Resultados do Apontamento    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function AjustaResult( aResult )

Local aResAux
Local nRes
Local nResults

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Acertando as Horas                                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF ( ( nResults := Len( aResult ) ) > 0 )
	For nRes := 1 To nResults
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Nao Mexer no Calculo abaixo. Ele eh utilizado para   efetuar³
		³ a correta conversao das horas que ateh este ponto estao  com³
		³ mais de 2 casas decimais ( Necessario para que o calculo das³
		³ Horas de Adicional Noturno Fiquem Ok )                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aResult[ nRes , ARESULT_HORAS ] := __TimeSum( __TimeSum( aResult[ nRes , ARESULT_HORAS ] , 0 ) , 0 )
	Next nRes
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Remonta o aResult Eliminaldo Apontamentos Zerados           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF ( aScan( aResult , { |x| x[ ARESULT_HORAS ] == 0 } ) > 0 )
		aResAux := aClone( aResult )
		aResult	:= {}
		For nRes := 1 To nResults
			IF !Empty( aResAux[ nRes , ARESULT_HORAS ] )
				aAdd( aResult , aClone( aResAux[ nRes ] ) )
			EndIF
		Next nRes
	EndIF
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGeraTot     ³Autor ³Marinaldo de Jesus   ³ Data ³24/09/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gerar no Array aTotais os Totais Apontado					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGeraTot(	aTotais 	,;	//01 -> Array com os Totais do Ponto
					dData		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
					nHoras		,;	//03 -> Horas para Soma ou Geracao
					nValor		,;	//04 -> Valor para Soma ou Geracao
					cEvento		,;	//05 -> Evento do Ponto para Pesquisa
					cCusto		,;	//06 -> Centro de Custo para Comparacao
					cFil		,;	//07 -> Filial para Pesquisa no SP9
					cVerba		,;	//08 -> Verba da Folha
					lSubstitui	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
					cFuncao		,;	//10 -> funcao para Comparacao   
					cDepto		,;	//11 -> Depto  para Comparacao   
					cPosto 		,;	//12 -> Posto  para Comparacao   
					cProcesso	,;	//13 -> Processo para Comparacao  
					cRoteiro	,;	//14 -> Roteiro para Comparacao   					 
					cPeriodo	,;	//15 -> Periodo para Comparacao   
					cNumPagto	 ;	//16 -> NumPagto para Comparacao   
				  )

Local bAsc		:= { || .F. }
Local nPos		:= 0

DEFAULT aTotais		:= {}
DEFAULT dData		:= Ctod("//")
DEFAULT nHoras		:= 0
DEFAULT nValor		:= 0
DEFAULT cEvento		:= Space( GetSx3Cache( "PB_PD"	, "X3_TAMANHO" ) )
DEFAULT cCusto		:= Space( GetSx3Cache( "PB_CC"	, "X3_TAMANHO" ) )
DEFAULT cFil		:= fFilFunc( "SP9" )
DEFAULT cVerba		:= PosSP9( cEvento , cFil , "P9_CODFOL" , 1 )
DEFAULT lSubstitui	:= .F.
DEFAULT cFuncao		:= Space( GetSx3Cache( "PB_CODFUNC"	, "X3_TAMANHO" ) )
DEFAULT cDepto   	:= Space( GetSx3Cache( "PC_DEPTO"	, "X3_TAMANHO" ) )
DEFAULT cPosto   	:= Space( GetSx3Cache( "PC_POSTO"	, "X3_TAMANHO" ) )
DEFAULT cProcesso	:= Space( GetSx3Cache( "PC_PROCES"  , "X3_TAMANHO" ) )
DEFAULT cPeriodo 	:= Space( GetSx3Cache( "PC_PERIODO"	, "X3_TAMANHO" ) )
DEFAULT cRoteiro 	:= Space( GetSx3Cache( "PC_ROTEIR"	, "X3_TAMANHO" ) )
DEFAULT cNumPagto 	:= Space( GetSx3Cache( "PC_NUMPAG"  , "X3_TAMANHO" ) )

bAsc := { |x|	(;
					( x[ATOTAIS_EVENTO_PONTO 		] 	== cEvento 		);
					.and.;
					( x[ATOTAIS_DATA				]	== dData 		);
					.and.;
					( x[ATOTAIS_CENTRO_DE_CUSTO 	]	== cCusto		);
					.and.;
					( x[ATOTAIS_FUNCAO				]	== cFuncao 		);
					.and.;
					( x[ATOTAIS_DEPTO				] 	== cDepto 		);		
					.and.;
					( x[ATOTAIS_POSTO				] 	== cPosto		);																										
					.and.;
					( x[ATOTAIS_PROCESSO			] 	== cProcesso	);	
					.and.;
					( x[ATOTAIS_PERIODO				] 	== cPeriodo		);	
					.and.;
					( x[ATOTAIS_ROTEIRO	   			] 	== cRoteiro		);	
					.and.;
					( x[ATOTAIS_NUM_PAGTO  			] 	== cNumPagto	);
				);
		}

IF ( ( nPos := aScan( aTotais , bAsc ) ) > 0 )
	IF ( lSubstitui )
		aTotais[ nPos , ATOTAIS_HORAS ] := nHoras
		aTotais[ nPos , ATOTAIS_VALOR ] := nValor
	Else
	    //aTotais[ nPos , ATOTAIS_HORAS ] := SomaHoras( aTotais[ nPos , ATOTAIS_HORAS] , nHoras )
	    aTotais[ nPos , ATOTAIS_HORAS ] := aTotais[ nPos , ATOTAIS_HORAS] + nHoras
		aTotais[ nPos , ATOTAIS_VALOR ] += nValor
	EndIF
Else
	aAdd( aTotais , Array( ELEMENTOS_DO_ATOTAIS ) )
	nPos := Len( aTotais )
	aTotais[ nPos , ATOTAIS_DATA			] := dData				//01 - Data do Evento
	aTotais[ nPos , ATOTAIS_EVENTO_PONTO	] := cEvento			//02 - Codigo do Evento
	aTotais[ nPos , ATOTAIS_HORAS			] := nHoras				//03 - Quantidade do Evento
	aTotais[ nPos , ATOTAIS_CODIGO_FOLHA	] := cVerba				//04 - Codigo para a Folha
	aTotais[ nPos , ATOTAIS_CENTRO_DE_CUSTO	] := cCusto				//05 - Centro de Custo do Evento
	aTotais[ nPos , ATOTAIS_VALOR			] := nValor				//06 - Valor do Evento
	aTotais[ nPos , ATOTAIS_DTOS_DATA		] := Dtos( dData )		//07 - String de Data
	aTotais[ nPos , ATOTAIS_FUNCAO			] := cFuncao			//08 - Funcao do Evento
	aTotais[ nPos , ATOTAIS_DEPTO 			] := cDepto 			//09 - Depto  do Evento
	aTotais[ nPos , ATOTAIS_POSTO 			] := cPosto 			//10 - Posto  do Evento
	aTotais[ nPos , ATOTAIS_PROCESSO 		] := cProcesso			//11 - Processo do Evento
	aTotais[ nPos , ATOTAIS_PERIODO	 		] := cPeriodo 			//12 - Periodo do Evento
	aTotais[ nPos , ATOTAIS_ROTEIRO			] := cRoteiro 			//13 - Roteiro do Evento	
	aTotais[ nPos , ATOTAIS_NUM_PAGTO		] := cNumPagto			//14 - NumPagto do Evento
			
EndIF

Return( nPos )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fDiasFolga³ Autor ³Equipe Advanced RH     ³ Data ³11/02/1999³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Altera aTabCalend de Forma a Transformar o Dia em DSR       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fDiasFolga(aMarcacoes,aTabCalend,dPerIni,dPerFim...)		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fDiasFolga(	aMarcacoes		,;	//01 -> Array padrao contendo as marcacoes           
						aTabCalend		,;	//02 -> Array padrao contendo o calendario do func.  
						dPerIni			,;	//03 -> Inicio do Periodo de Apontamento             
						dPerFim			,;	//04 -> Final do Periodo de Apontamento              
						cCodDsrAutPa	,;	//05 -> Codigo do DSR Ult. Semana do Periodo Anterior
						lAcumulado		,;	//06 -> Se a Pesquisa deve ser Feita nos Acumulados  
						lGrava			 ;	//07 -> Nao Gravar o Evento
					)

Local aFaltas		:= {}
Local aDomingo		:= {}
Local dDataApo		:= ""
Local cGeraDSR		:= "N"
Local cUltDataApo	:= ""
Local cUltDtaDom	:= ""
Local cAliasPesq	:= "SPC"
Local cFilSRA		:= NIL 
Local cMatSRA		:= NIL 
Local cPrefixo		:= ""
Local cTipAfas		:= ""
Local cMsgErr		:= ""
Local dData			:= Ctod("//")
Local dUltDiaTab	:= dData
Local dIniAfas		:= dData
Local dFimAfas		:= dData
Local lCodDSRAutPa	:= .F.
Local lGerDSRAutPa	:= .F.
Local lRet			:= .F.
Local lLock			:= .F.
Local nDias			:= 0
Local nCount		:= 0
Local nX			:= 0
Local nPos			:= 0
Local nPos2			:= 0
Local nProxD		:= 0
Local nCt			:= 0	
Local nFornCt		:= 0
Local nLenTab		:= 0
Local nRecDSRAutPa	:= 0

DEFAULT aMarcacoes	:= {}
DEFAULT aTabCalend	:= {}
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT cCodDsrAutPa:= ""
DEFAULT lAcumulado	:= .F.
DEFAULT lGrava		:= .T.
DEFAULT cFilSRA		:= SRA->RA_FILIAL
DEFAULT cMatSRA		:= SRA->RA_MAT

IF lAcumulado
	cAliasPesq	:= "SPH"
EndIF

cAliasPesq		:= Upper( AllTrim( cAliasPesq ) )
cPrefixo		:= ( PrefixoCpo( cAliasPesq ) + "_" )
nLenTab			:= Len(aTabCalend)
nDias			:= ( ( dPerFim - dPerIni ) + 1 )
dData			:= dPerIni
lCodDSRAutPa	:= !( cCodDsrAutPa == "@" .or. Empty(cCodDsrAutPa) )
cUltDataApo		:= aTabCalend[nLenTab,CALEND_POS_DATA_APO]


dUltDiaTab	:= aTabCalend[ Len(aTabCalend) , CALEND_POS_DATA ]

aEval( aTabCalend , {;
						 |x,y|;
						 		 IF( x[CALEND_POS_TIPO_MARC]=="1E" .and. Dow(x[CALEND_POS_DATA]) == 1 ,;
						 		 	 cUltOrdDom := aTabCalend[y,CALEND_POS_ORDEM] ,;
						 		 	 NIL;
						 		 	);
					 };
	  )

For nCount := 1 To nDias

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Guarda a Data de Apontamento da Tabela					  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF (nPos := aScan(aTabCalend, {|x| x[CALEND_POS_DATA_APO] == dData})) > 0
		dData := aTabCalend[nPos,CALEND_POS_DATA]
	Else
		dData++
		Loop
	EndIF
    
	dDataApo	:= dData
	
	IF Dow(dUltDiaTab) != 1
		IF lCodDSRAutPa
			IF ( cAliasPesq )->( MsSeek( cFilSRA + cMatSRA + cCodDsrAutPa + Dtos(dPerFim+1) ) )
				nRecDSRAutPa := ( cAliasPesq )->( Recno() )
			EndIF
		EndIF
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica as Trocas de Turno								  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( fBscTnoFolga(cFilSRA,aTabCalend[nPos,CALEND_POS_TURNO]) # "S" )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se a semana iniciou-se com um turno com DSR automatico,iden ³
		³ tifica-se a parte da semana com DSR automatico ate a data	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF	 cGeraDSR == "S"   
		    //-- Calcula a segunda-feira que antecedeu a data atual
		    aAdd( aDomingo,{ dData , If( Dow(dData) == 1, (dData-6), dData -( Dow(dData) - 2 )  ) } )
		EndIF
		cGeraDSR := "N"
		dData++
		Loop
	EndIF

	cGeraDSR := "S"

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem o Inicio e Fim de Cada Semana para Verifica se a Falta³
	³ Esta ou Nao Dentro da Mesma								  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( Dow(dData) == 1 )
		aAdd(aDomingo,{dData,dData-6})
	ElseIF ( dData == dPerFim )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica qual o Proximo Domingo							  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		While ( Dow( dData ) != 1 )
			++dData
		End While
		aAdd(aDomingo,{dData,dData-6})
		dData := dPerFim
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Marca‡„o anterior a Admiss„o.                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF SRA->(;
				( RA_SITFOLH == Space( GetSx3Cache( "RA_SITFOLH" , "X3_TAMANHO" ) ) );
				.and.;
				( dData < fDtaAdmis() );
			)
		dData++
		Loop
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Marca‡„o posterior a Demiss„o ou Transferencia              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF SRA->( RA_SITFOLH $ "DúT" .and. !Empty(RA_DEMISSA) .and. dData > RA_DEMISSA )
		dData ++
		Loop
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Marca‡„o dentro de intervalo de Afastamento.                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cTipAfas	:=	aTabCalend[ nPos , CALEND_POS_TIP_AFAST ]
	dIniAfas	:=	aTabCalend[ nPos , CALEND_POS_INI_AFAST ]
	dFimAfas	:=	aTabCalend[ nPos , CALEND_POS_FIM_AFAST ]
	IF aTabCalend[ nPos , CALEND_POS_AFAST ] .and. ;
		( dData >= dIniAfas .And. dData <= IF( Empty( dFimAfas ) , dData , dFimAfas ) )
		IF ( ( SR6->R6_APODFER == "S" ) .And. ( cTipAfas == "F" ) )
			dData := dData
		Else
			dData ++
			Loop
		EndIF
	EndIF

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica quais os dias sao faltas, caso este dia nao tenha  ³
	| lancamento e o mesmo seja um feriado, ele nao e considerado |
	| uma falta.												  |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	*/
	If !aTabCalend[ nPos, CALEND_POS_FERIADO]
		IF ( nPos := aScan( aMarcacoes, { |x| x[AMARC_DATAAPO] == dDataApo } ) ) == 0 
				aAdd(aFaltas, dData )
		EndIF
	EndIf	
	
Next nCount

nFornCt := Len(aDomingo)
For nCt := 1 To nFornCt

	dData := aDomingo[nCt,1]

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica a Qual Semana a Falta Pertence                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( nPos := aScan( aFaltas, {|x| x <= aDomingo[nCt,1] .and. x >= aDomingo[nCt,2] } ) ) > 0
		dData := aFaltas[nPos]
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se for a Primeira Semana Verifica se Ja Teve DSR na   Ultima³
	³ Semana do Periodo de Apontamento Anterior e Nao Gera o   DSR³
	³ Automatico para a Semana.									  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( nCt == 1 ) .and. ( lCodDSRAutPa ) )
		IF ( cAliasPesq )->( MsSeek( cFilSRA + cMatSRa + cCodDsrAutPa + Dtos(dPerIni) ) )
			Loop
		EndIF
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se ja houver excecao para a data em questao nao altera o  Ho³
	³ rario														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( nPos2 := aScan(aTabCalend, { |x| x[CALEND_POS_DATA_APO] == dData } ) ) > 0 .and.;
	   ( fBscTnoFolga(cFilSRA,aTabCalend[nPos2,CALEND_POS_TURNO]) == "S" )
		nX		:= nPos2
		lRet	:= .T.
		While ( ( nX <= nLenTab ) .and. aTabCalend[nPos2,CALEND_POS_DATA_APO] == aTabCalend[nX,CALEND_POS_DATA_APO] )
			IF aTabCalend[nX,CALEND_POS_EXCECAO] # "E"
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Atualiza a folga diretamente em aTabCalend				  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( ( nX - nPos2 ) < 2 )
					aTabCalend[ nX , CALEND_POS_HORA        ] := 0											//Hora
					aTabCalend[ nX , CALEND_POS_TIPO_DIA    ] := "D"										//Tipo do Dia
					aTabCalend[ nX , CALEND_POS_HRS_INTER   ] := 0											//Intervalo
					aTabCalend[ nX , CALEND_POS_MOT_EXECAO  ] := STR0101									//*/** DSR Automatico ***
					aTabCalend[ nX , CALEND_POS_TIPO_HE_NOR ] := SR6->(IF(Empty(R6_TPEXT),"2",R6_TPEXT))	//Tipo de Horas Extras Normais
					aTabCalend[ nX , CALEND_POS_TIPO_HE_NOT ] := SR6->(IF(Empty(R6_TPEXTN),"6",R6_TPEXTN))	//Tipo de Horas Extras Noturnas
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Elimina os Elementos que Nao serao Utilizados em aTabCalend ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					aDel(aTabCalend,nX)
					aSize(aTabCalend,--nLenTab)
					--nX
				EndIF	
			EndIF
			nX++
		End While
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando For a Ultima Semana e o Dia Nao For um Domingo e   Ti³
		³ver Sido Gerado um DSR Grava o Evento de DSR Automatico   Mes³
		³Anterior Para o Proximo Mes								  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( Dow(dUltDiaTab) != 1 ) .and. !( lAcumulado ) .and. ( lGrava ) )
			IF ( ( lCodDSRAutPa ) .and. ( aTabCalend[ nPos2 , CALEND_POS_DATA_APO ] >= cUltDtaDom ) .and. ( aTabCalend[ nPos2 , CALEND_POS_DATA_APO ] <= cUltDataApo ) )
				lGerDSRAutPa := .T.
				IF(  Dow( aTabCalend[ nPos2 , CALEND_POS_DATA ] ) == 1 )
					IF ( ( nProxD := aScan( aTabCalend , { |x| x[CALEND_POS_DATA] == ( aTabCalend[ nPos2 , CALEND_POS_DATA ] + 1 ) .and. x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0 )
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Nao Gera quando for o Domingo da Penultima Semana		      ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						lGerDSRAutPa := !( Dow( aTabCalend[ nProxD , CALEND_POS_DATA ] ) == 2 ) 
					EndIF
				EndIF	
				IF ( lGerDSRAutPa )
					IF !Empty( nRecDSRAutPa )
						( cAliasPesq )->( dbGoto( nRecDSRAutPa ) )
						lLock := ( cAliasPesq )->( RecLock( cAliasPesq , .F. , .F. ) )
					Else
						lLock := RecLock( cAliasPesq , .T. , .F. )
					EndIF
					IF ( lLock )
						( cAliasPesq )->( &(cPrefixo+"FILIAL")	)	:= cFilSRA
						( cAliasPesq )->( &(cPrefixo+"MAT")		)	:= cMatSRA
						( cAliasPesq )->( &(cPrefixo+"DATA")	)	:= ( dPerFim + 1 )
						( cAliasPesq )->( &(cPrefixo+"PD")		)	:= cCodDsrAutPa
						( cAliasPesq )->( &(cPrefixo+"CC")		)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_CC 		]
						( cAliasPesq )->( &(cPrefixo+"CODFUNC")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_CODFUNC  ]
						( cAliasPesq )->( &(cPrefixo+"DEPTO")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_DEPTO	]
						( cAliasPesq )->( &(cPrefixo+"POSTO")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_POSTO 	]
						( cAliasPesq )->( &(cPrefixo+"PROCES")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_PROCESSO ]
						( cAliasPesq )->( &(cPrefixo+"PERIODO")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_PERIODO  ]
						( cAliasPesq )->( &(cPrefixo+"ROTEIR")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_ROTEIRO 	]
						( cAliasPesq )->( &(cPrefixo+"NUMPAG")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_NUM_PAGTO]
						( cAliasPesq )->( &(cPrefixo+"QUANTC")	)	:= 0.01
						( cAliasPesq )->( MsUnLock() )
					EndIF
				EndIF
			EndIF
		EndIF
	EndIF
Next

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Quando nao Houver DSR Automatico a Ser Gerado e Ja Existir  o³
³Evento, Exclui.											  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( !( lAcumulado ) .and. ( lGrava ) )
	IF ( !( lGerDSRAutPa ) .and. !Empty( nRecDSRAutPa ) )
		( cAliasPesq )->( dbGoto( nRecDSRAutPa ) )
		IF ( cAliasPesq )->( RecLock( cAliasPesq , .F. , .F. ) )
			IF !( cAliasPesq )->( FkDelete( @cMsgErr ) )
				( cAliasPesq )->( RollBackDelTran( cMsgErr ) )
			EndIF
			( cAliasPesq )->( MsUnLock() )
		EndIF	
	EndIF
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fBscTnoFolga ³Autor³ Equipe Advanced RH   ³ Data ³10/02/1999³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Retorna (S/N) parametro do Turno - 1a.Falta da Semana=Folga³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fBscTnoFolga( cFil , cTno )                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ fDiasFolga()	                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fBscTnoFolga( cFil , cTno )
Return( PosSR6( cTno , cFil , "R6_ASFOLGA" , 01 ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PosSP9	  ³ Autor ³ Marinaldo de Jesus	  ³ Data ³17/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cCompKey	= Chave Complementar para Pesquisa			  	³
³          ³cFil    	= Filial do Evento que deseja 	 			  	³
³          ³cCampo  	= Campo  do Evento que Deseja Pesquisar 		³
³          ³nOrdem  	= Ordem  da Pesquisa                    		³
³          ³lMsGoto 	= Se Deve Reposicionar Recno            		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PosSP9( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SP9" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PosSPA	  ³ Autor ³ Marinaldo de Jesus	  ³ Data ³17/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Posiciona no Evento Desejado no SPA							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PosSPA( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SPA" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PosSR6	  ³ Autor ³ Marinaldo de Jesus	  ³ Data ³17/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Posiciona no Turno Desejado no SR6							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PosSR6( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SR6" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PosSP6	  ³ Autor ³ Marinaldo de Jesus	  ³ Data ³17/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Posiciona no Abono Desejado no SP6						    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PosSP6( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SP6" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fQualSeq    ³ Autor ³Marinaldo de Jesus    ³ Data ³26/10/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o numero da Seq do Turno de Acordo com a Data Inicial³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fQualSeq( aTabCalend , aTabPadrao , dPerIni , cTurno )		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTabCalend -> Calendario do Periodo Atual          		     ³
³          ³aTabPadrao -> Calendario Padrao                    		     ³
³          ³dPerIni    -> Data do Periodo Inicial para achar a Seq.		 ³
³          ³cTurno     -> Turno Atual do Funcionario           		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cSeq - Sequencia Inicial da Tabela de Horario Padrao		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fQualSeq( aTabCalend , aTabPadrao , dPerIni , cTurno )

Local aSeq		:= {}
Local cSeq		:= ""
Local cFil		:= xFilial( "SPJ" , SRA->RA_FILIAL )
Local dQualSeg  := dPerIni
Local dSegAtu   := Ctod('//')
Local dSvSegAt  := Ctod('//')
Local nPosTab	:= 0
Local nSegund   := 0
Local nSvPosT	:= 0
Local nX		:= 0
Local nFornX	:= 0

cTurno := IF( cTurno == NIL , SRA->RA_TNOTRAB , cTurno )

nPosTab := aScan( aTabCalend , { |x| x[CALEND_POS_TIPO_MARC] == "1E" } )

IF ( nPosTab > 0 )
	dSegAtu := aTabCalend[ nPosTab , CALEND_POS_DATA 		]
	cSeq	:= aTabCalend[ nPosTab , CALEND_POS_SEQ_TURNO	]
	cTurno	:= aTabCalend[ nPosTab , CALEND_POS_TURNO		]
Else
	cSeq	:= SRA->RA_SEQTURN
	dSegAtu := dPerIni
EndIF

IF ( ( nPosTab := aScan( aTabPadrao , { |x| x[1] == cFil .and. x[ 2 ] == cTurno } ) ) > 0 )
	nFornX := Len( aTabPadrao[ nPosTab , 3 ] )
	For nX := 1 To nFornX
		IF ( aScan( aSeq , { |x| x[ 1 ] == aTabPadrao[ nPosTab , 3 , nX , 19 ] } ) == 0 )
			aAdd( aSeq , { aTabPadrao[ nPosTab , 3 , nX , 19 ] , '' } )
		EndIF
	Next nX
EndIF

IF ( Dow( dQualSeg ) != 2 )
	While ( Dow( --dQualSeg ) != 2 )
	End While
EndIF

IF ( Dow( dSegAtu ) != 2 )
	While ( Dow( --dSegAtu ) != 2 )
	End While
EndIF

IF ( !Empty( aSeq ) .and. ( Len( aSeq ) > 1 ) )
	IF ( ( nPosTab := aScan( aSeq, { |x| x[ 1 ] == cSeq } ) ) > 0 )
       	aSeq[ nPosTab , 2 ] := dSegAtu
		nSvPosT	 := nPosTab
        dSvSegAt := dSegAtu
		While ( ++nPosTab <= Len( aSeq ) )
			aSeq[ nPosTab , 2 ] := ( dSegAtu := ( dSegAtu + 7 ) )
		End While
		nPosTab := nSvPosT
        dSegAtu := dSvSegAt
		While ( --nPosTab >= 1 )
        	aSeq[ nPosTab , 2 ] := ( dSegAtu := ( dSegAtu - 7 ) )
		End While
		dSegAtu := dSvSegAt
		IF ( ( nTotSeq := Len( aSeq ) ) > 1 )
			nPosTab := nSvPosT
            IF ( dSegAtu > dQualSeg )
	            nSegund := ( dSegAtu - dQualSeg ) / 7
       			While ( --nSegund >= 0 )
					IF ( nPosTab == 1 )
						nPosTab := nTotSeq
					Else
						--nPosTab
					EndIF
				End While
			Else
                nSegund := ( dQualSeg - dSegAtu ) / 7
                While ( --nSegund >= 0 )
					IF ( nPosTab == nTotSeq )
						nPosTab := 1
					Else
						++nPosTab
					EndIF
				End While
			EndIF
            cSeq := aSeq[ nPosTab , 1 ]
        Else
			cSeq := aSeq[ 1 , 1 ]
		EndIF
	EndIF
EndIF

Return( cSeq )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fHrsTrabGat ³ Autor ³Marinaldo de Jesus    ³ Data ³24/10/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Calcula Total de Horas da Tabela de Horario Padrao		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fHrsTrabGat()												 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cTipo  -> "H"oras, "I"ntervalo, "T"otal de Horas			 ³
³          ³cAlias -> "SPJ" Tabela de Horario Padrao ou "SP2" Excecoes	 ³
³          ³cObj   -> "GD" GetDatos, "MB" mBrowse ou "DB" Arquivo		 ³
³          ³cInt   -> Quando cTipo = "I", qual Intervalo "1", "2" ou "3" ³
³          ³          Quando cTipo = "H", qual Periodo "1","2","3" ou "4"³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nHoras									                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gatilho                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function 		fHrsTrabGat( cTipo , cAlias , cObj , cInt, lSR6 )

Local nHoras		:= 0
Local cVar			:= IF( cObj == "DB" , "" , Upper( AllTrim( ReadVar() ) ) )
Local cPrefixo		:= ""
Local dE1			:= dDataBase
Local dS1			:= Ctod('//')
Local dE2			:= Ctod('//')
Local dS2			:= Ctod('//')
Local dE3			:= Ctod('//')
Local dS3			:= Ctod('//')
Local dE4			:= Ctod('//')
Local dS4			:= Ctod('//')
Local lHnotTab		:= .F.
Local lHnotTbI		:= .F.
Local lNoExecGat	:= ( Type( "lHrsTrbGat" ) == "L" .and. !( lHrsTrbGat ) )

Local nIniHnot		:= 0
Local nFimHnot		:= 23.59
Local nMinHnot		:= 60  
Local nObj             
Local nAlias         
Local aCpos			:=Array(3)
Local bGet			:=Array(3)  

DEFAULT lSR6		:= .F. //Para forcar o uso dos campos do turno ao calcular as horas de jornadas associadas a ele.
			
#DEFINE ENTRA1_  	01
#DEFINE SAIDA1_  	02
#DEFINE ENTRA2_  	03
#DEFINE SAIDA2_  	04
#DEFINE ENTRA3_  	05
#DEFINE SAIDA3_  	06
#DEFINE ENTRA4_  	07
#DEFINE SAIDA4_  	08			
#DEFINE INTERV1_	09
#DEFINE INTERV2_ 	10
#DEFINE INTERV3_ 	11  
#DEFINE HRSINT1_    12
#DEFINE HRSINT2_    13
#DEFINE HRSINT3_    14
#DEFINE HRSTRAB_ 	15
#DEFINE HRSTRA2_ 	16
#DEFINE HRSTRA3_ 	17
#DEFINE HRSTRA4_ 	18
#DEFINE JND1CON_ 	19
#DEFINE JND2CON_ 	20
#DEFINE JND3CON_ 	21
#DEFINE JND4CON_ 	22 
#DEFINE HNTTAB_  	23
#DEFINE HNTTBI_  	24
#DEFINE INIHNT_  	25
#DEFINE FIMHNT_  	26
#DEFINE MINHNT_  	27



#DEFINE PONSPJ_		01   
#DEFINE PONSP2_		02
#DEFINE PONOUT_		03 

#DEFINE PONGD_		01   
#DEFINE PONMB_		02
#DEFINE PONDB_		03 

aCpos[PONOUT_]:= {;
					"ENTRA1"	,; //01 - 1E
					"SAIDA1"    ,; //02 - 1S
					"ENTRA2"	,; //03 - 2E
					"SAIDA2"    ,; //04 - 2S
					"ENTRA3"	,; //05 - 3E
					"SAIDA3"    ,; //06 - 3S
					"ENTRA4"	,; //07 - 4E
					"SAIDA4"    ,; //08 - 4S
					"INTER1"	,; //09 - 1a.S.Interv
					"INTER2"	,; //10 - 2a.S.Interv.
					"INTER3"	,; //11 - 3a.S.Interv.
					"HRINT1"	,; //12 - Hrs 1o.Int.
					"HRINT2"	,; //13 - Hrs 2o.Int.
					"HRINT3"	,; //14 - Hrs 3o.Int.
					"HRTRAB"	,; //15 - Hrs.Trb.1a.J
					"HRTRA2"	,; //16 - Hrs.Trb.2a.J
					"HRTRA3"	,; //17 - Hrs.Trb.3a.J
					"HRTRA4"	,; //18 - Hrs.Trb.4a.J
					"JND1CO" 	,; //19 - 1a.Jor.Cont.
					"JND2CO" 	,; //20 - 2a.Jor.Cont.
					"JND3CO" 	,; //21 - 3a.Jor.Cont.
					"JND4CO" 	,; //22 - 4a.Jor.Cont.
					"HNTTAB"    ,; //23 - 
					"HNTTBI"    ,; //24 -
					"INIHNT"    ,; //25 -
					"FIMHNT"    ,; //26 -
					"MINHNT"    ;  //27 -
                  }

aCpos[PONSPJ_]:= {;
					"ENTRA1"    ,; //01 - 1a Entrada
					"SAIDA1"    ,; //02 - 1a Saida
					"ENTRA2"	,; //03 - 2a Entrada
					"SAIDA2"    ,; //04 - 2a Saida
					"ENTRA3"	,; //05 - 3a Entrada
					"SAIDA3"    ,; //06 - 3a Saida
					"ENTRA4"	,; //07 - 4a Entrada
					"SAIDA4"    ,; //08 - 4a Saida
					"INTERV1"	,; //09 - 1a Saida Int
					"INTERV2"	,; //10 - 2a Saida Int          
					"INTERV3"	,; //11 - 3a Saida Int            
					"HRSINT1"  	,; //12 - Horas 1o.Int          
					"HRSINT2"  	,; //13 - Horas 2o.Int          
					"HRSINT3"  	,; //14 - Horas 3o.Int          
					"HRSTRAB"  	,; //15 - Hrs.Trb.1a.J          
					"HRSTRA2"  	,; //16 - Hrs.Trb.2a.J          
					"HRSTRA3"  	,; //17 - Hrs.Trb.3a.J          
					"HRSTRA4"  	,; //18 - Hrs.Trb.4a.J          
					"JND1CON"  	,; //19 - 1a.Jor.Cont.          
					"JND2CON"  	,; //20 - 2a.Jor.Cont.          
					"JND3CON"  	,; //21 - 3a.Jor.Cont.          
					"JND4CON"  	,; //22 - 4a.Jor.Cont. 
					"HNOTTAB"  	,; //23 - Horas Total
					"HNOTTBI"  	,; //24 - 
					"INIHNOT"  	,; //25 - 
					"FIMHNOT"  	,; //26 - 
					"MINHNOT"	;  //27 - 
					}

aCpos[PONSP2_]:={;
					"ENTRA1"	,; //01 - 1a Entrada
					"SAIDA1"    ,; //02 - 1a Saida
					"ENTRA2"	,; //03 - 2a Entrada
					"SAIDA2"    ,; //04 - 2a Saida
					"ENTRA3"	,; //05 - 3a Entrada
					"SAIDA3"    ,; //06 - 3a Saida
					"ENTRA4"	,; //07 - 4a Entrada
					"SAIDA4"    ,; //08 - 4a Saida
					"INTERV1"  	,; //09 - 1a.S.Interv
					"INTERV2"  	,; //10 - 2a.S.Interv.
					"INTERV3"  	,; //11 - 3a.S.Interv.
					"HRINTV1"  	,; //12 - Hrs 1o.Int.
					"HRINTV2"  	,; //13 - Hrs 2o.Int.
					"HRINTV3"  	,; //14 - Hrs 3o.Int.
					"HRSTRAB"  	,; //15 - Hrs.Trb.1a.J
					"HRSTRA2"  	,; //16 - Hrs.Trb.2a.J
					"HRSTRA3"  	,; //17 - Hrs.Trb.3a.J
					"HRSTRA4"  	,; //18 - Hrs.Trb.4a.J
					"JND1CON"  	,; //19 - 1a.Jor.Cont. 
					"JND2CON"  	,; //20 - 2a.Jor.Cont.
					"JND3CON"  	,; //21 - 3a.Jor.Cont.
					"JND4CON"  	,; //22 - 4a.Jor.Cont. 
					"HNOTTAB"  	,; //23 - Horas Total
					"HNOTTBI"  	,; //24 - Horario
					"INIHNOT"  	,; //25 - 
					"FIMHNOT"  	,; //26 - 
					"MINHNOT"	;  //27 - 
					}   

bGet[PONGD_]:={|x| 	 GdFieldGet( cPrefixo+ x ) }
bGet[PONMB_]:={|x| 	 GetMemVar( cPrefixo+ x ) }	
bGet[PONDB_]:={|x| 	 (cAlias)->( &( cPrefixo+ x )) }

cTipo		:= IF(cTipo == NIL .or. ValType(cTipo) != "C", "H"  ,IF(!(Upper(AllTrim(cTipo ))$"I_H_T"),"H",Upper(AllTrim(cTipo))))
cAlias		:= IF(cAlias == NIL .or. ValType(cTipo)!= "C", "SPJ" , Upper( AllTrim( cAlias ) ) )
cObj		:= IF(cObj == NIL .or. ValType(cTipo) != "C", "GD" ,IF(!(Upper(AllTrim(cObj ))$"GD_MB_DB"),"GD",Upper(AllTrim(cObj))))
cObj		:= IF(cAlias == "SP2" .and. Type("lGatForceGd") == "L" .and. cObj != "DB" , IF( lGatForceGd , "GD" , cObj ) , cObj )
cInt		:= IF(cInt == NIL .or. ValType(cInt) != "C", ""  ,IF(!(Upper(AllTrim(cInt ))$"1_2_3_4"),"",AllTrim(cInt)))
cPrefixo	:= ( PrefixoCpo( cAlias ) + "_" )

Begin Sequence

	IF ( lNoExecGat )
		Break
	EndIF
    
    nObj	:= If(cObj == "GD", 1, If (cObj == "MB",2,3))
    nAlias  := If(cAlias == "SPJ",1, If(cAlias == "SP2",2,3))

	IF ( cAlias == "SPJ" )
		lHnotTab	:= ( SR6->R6_HNOTTAB == "S" )
		lHnotTbI	:= ( SR6->R6_HNOTTBI == "S" )
		nIniHnot	:= SR6->R6_INIHNOT
		nFimHnot	:= SR6->R6_FIMHNOT
		nMinHnot	:= SR6->R6_MINHNOT  
		
	ElseIF ( cAlias == "RF3" )  
	    IF lSR6                         
			lHnotTab	:= ( SR6->R6_HNOTTAB == "S" )
			lHnotTbI	:= ( SR6->R6_HNOTTBI == "S" )
			nIniHnot	:= SR6->R6_INIHNOT
			nFimHnot	:= SR6->R6_FIMHNOT
			nMinHnot	:= SR6->R6_MINHNOT  	                           
	    Else
			lHnotTab	:= (GETMV('MV_HNOTTAB'	,,'S') == "S" )
			lHnotTbI	:= (GETMV('MV_HNOTTBI'	,,'S') == "S" )
			nIniHnot	:= 	GETMV('MV_INIHNOT')	
			nFimHnot	:= 	GETMV('MV_FIMHNOT')
			nMinHnot	:= 	GETMV('MV_MINHNOT')
		Endif			
	Else
		lHnotTab	:= ( Eval( bGet[nObj] , aCpos[nAlias,HNTTAB_]) == "S" )
		lHnotTbI	:= ( Eval( bGet[nObj] , aCpos[nAlias,HNTTBI_]) == "S" )
		nIniHnot	:=   Eval( bGet[nObj] , aCpos[nAlias,INIHNT_])
		nFimHnot	:=   Eval( bGet[nObj] , aCpos[nAlias,FIMHNT_])
		nMinHnot	:=   Eval( bGet[nObj] , aCpos[nAlias,MINHNT_])
	EndIF
	    
	dS1		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA1_ ]) ) , dE1 , dE1 + 1 )
	dS1		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA1_ ]) ) .and. ( Eval( bGet[nObj] , aCpos[nAlias, JND1CON_ ]) == "S" ), dS1 + 1 , dS1 )
	dE2		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ]) ) , dS1 , dS1 + 1 )
	dS2		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ]) ) , dE2 , dE2 + 1 )
	dS2		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ]) ) .and. ( Eval( bGet[nObj] , aCpos[nAlias, JND2CON_ ]) == "S" ), dS2 + 1 , dS2 )
	dE3		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ]) ) , dS2 , dS2 + 1 )
	dS3		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ]) ) , dE3 , dE3 + 1 )
	dS3		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ]) ) .and. ( Eval( bGet[nObj] , aCpos[nAlias, JND3CON_ ]) == "S" ), dS3 + 1 , dS3 )
	dE4		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ]) ) , dS3 , dS3 + 1 )
	dS4		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA4_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ]) ) , dE4 , dE4 + 1 )
	dS4		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA4_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ]) ) .and. ( Eval( bGet[nObj] , aCpos[nAlias, JND4CON_ ]) == "S" ), dS4 + 1 , dS4 )

	//-- Calcula as Horas entre Jornadas
	IF cTipo == "H"
			IF cInt == "1"
				nHoras := fCalHoras( dE1 , Eval( bGet[nObj] , aCpos[nAlias, ENTRA1_ ]) , dS1 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ]) , NIL , NIL , lHnotTab , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "2"
				nHoras := fCalHoras( dE2 , Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ]) , dS2 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ]) , NIL , NIL , lHnotTab , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "3"
				nHoras := fCalHoras( dE3 , Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ]) , dS3 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ]) , NIL , NIL , lHnotTab , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "4"
				nHoras := fCalHoras( dE4 , Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ]) , dS4 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA4_ ]) , NIL , NIL , lHnotTab , dE4 , NIL , nIniHnot , nFimHnot , nMinHnot )
			EndIF	

	//-- Calcula as Horas de Intervalos
	ElseIF cTipo == "I"
		IF cInt == "1" .or. cVar $ aCpos[nAlias,INTERV1_]
			IF  Eval( bGet[nObj] , aCpos[nAlias,INTERV1_]) == "S"
				nHoras := fCalHoras( dS1 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ]) , dE2 ,  Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ]) , NIL , NIL , lHnotTbI , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
			EndIF
		
		ElseIF cInt == "2" .or. cVar $  aCpos[nAlias,INTERV2_]
				IF Eval( bGet[nObj] , aCpos[nAlias,INTERV2_]) == "S"
					nHoras := fCalHoras( dS2 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ]), dE3 ,  Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ]) , 0 , 0 , lHnotTbI , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
		
		ElseIF cInt == "3" .or. cVar $ aCpos[nAlias,INTERV3_]
				IF Eval( bGet[nObj] , aCpos[nAlias,INTERV3_]) == "S"
					nHoras := fCalHoras( dS3 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ]) , dE4 ,  Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ])  , NIL , NIL , lHnotTbI , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF	
		EndIF
    
	//-- Calcula o Total de Horas
	ElseIF cTipo == "T"
	 		nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSINT1_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSINT2_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSINT3_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSTRAB_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSTRA2_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSTRA3_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSTRA4_]) )
	EndIF

End Sequence
	
Return(__TimeSum(__TimeSum( nHoras, 0 ), 0) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³__Excecoes ³Autor ³ Equipe Advanced RH    ³ Data ³19/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega a Tabela de Exce‡”es                	            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³__Excecoes(aArray,cTurno,cCC,cMat,dData,nRecno,aExcePer)	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³< Vide Parametros Formais >							        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Obs.:     ³Matida a Funcao Apenas Para Compatibilidade com os Programas³
³          ³Especificos que ja Estao Sendo Utilizados nos Cliente.  Reco³
³          ³mendado o uso da GetExcecoes()								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function __Excecoes(aArray,cTurno,cCC,cMat,dData,nRecno,aExcePer)

Local cFil 		:= SRA->RA_MAT
Local lExcecao	:= .F.

DEFAULT aArray		:= {}
DEFAULT cTurno		:= SRA->RA_TNOTRAB
DEFAULT cCC			:= SRA->RA_CC
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT dData		:= dDataBase
DEFAULT nRecno		:= 0
DEFAULT aExceper	:= {}	

lExcecao := GetExcecoes(	@aArray		,; // 01 - Array a ser Carregado com as Exce‡oes
							cTno		,; // 02 - Turno de Trabalho do Funcion rio
							cCC			,; // 03 - Centro de Custo do Funcion rio
							cFil		,; // 04 - Filial do Funcionario
							cMat		,; // 05 - Matricula do Funcion rio
							dData		,; // 06 - Data a ser pesquisada
							""			,; // 07 - Tipo do Dia Para a Excecao
							aExcePer	,; // 08 - Array com Todas as Exce‡oes do Periodo
							NIL			,; // 09 - Periodo Inicial Para Carga de aExcePer
							NIL			,; // 10 - Periodo Final   Para Carga de aExcePer
							.F.			,; // 11 - True para Carregar Todas as Excecoes do Periodo
							.F.			 ; // 12 - Mostrar Dialogo na IndRegua
						)

Return( lExcecao )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetExcecoes³Autor ³ Marinaldo de Jesus    ³ Data ³19/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega a Tabela de Exce‡”es                	            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetExcecoes()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³< Vide Parametros Formais >							        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Obs.:     ³Quando a procura For Feita em Arquivo (SP2) ira posicionar o³
³          ³Recno Correspondente `a Excecao.                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetExcecoes(	aArray		,; // 01 - Array a ser Carregado com as Exce‡oes
						cTno		,; // 02 - Turno de Trabalho do Funcion rio
						cCC			,; // 03 - Centro de Custo do Funcion rio
						cFil		,; // 04 - Filial do Funcionario
						cMat		,; // 05 - Matricula do Funcion rio
						dData		,; // 06 - Data a ser pesquisada
						cTipoDia 	,; // 07 - Tipo do Dia Para a Excecao             					
						aExcePer	,; // 08 - Array com Todas as Exce‡oes do Periodo
						dPerIni		,; // 09 - Periodo Inicial Para Carga de aExcePer
						dPerFim		,; // 10 - Periodo Final   Para Carga de aExcePer 
						lPeriodo	,; // 11 - True para Carregar Todas as Excecoes do Periodo
						lShowDialog ,; // 12 - Mostrar Dialogo na IndRegua
						lForceGoto	 ; // 13 - Se, quando pesquisa em array, forca o posicionamento no SP2	
					 )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aExceTip		:= {}
Local cRegra		:= SRA->RA_REGRA
Local cSpcTipoDia	:= Space( GetSx3Cache( "P2_TIPODIA" , "X3_TAMANHO" ) ) 
Local lExcecao		:= .F.
Local lArray		:= .F.
Local nFornY		:= RetCondExce()

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aString
Local baScan
Local bCond
Local bLoop
Local bExce
Local cArqInd
Local nFornX
Local nX
Local nY
Local nPos
Local nRecno

Static	cIndKeyExc
Static	nOrderExce

DEFAULT aArray		:= {}
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT cCC			:= SRA->RA_CC
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT dData		:= dDataBase       
DEFAULT cTipoDia	:= cSpcTipoDia
DEFAULT aExcePer	:= {}
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT lPeriodo	:= .F.
DEFAULT lShowDialog := .F.
DEFAULT lForceGoto	:= .F.

Begin Sequence
	
	IF ( ( ValType( aExcePer ) == "A" ) .and. ( lArray := ( Len(aExcePer) > 0 ) ) )  //Pesquizando em Array

		baScan := { |x| x[2] + Dtos( x[3] ) + Dtos( x[4] ) == aExcePer[ nX , 35 ] + Dtos( aExceper[ nX , 02 ] ) + Dtos( aExceper[ nX , 03 ] ) }
		
		bCond := { |x| ( x[1] + x[6] + x[5] + x[4] + Dtos( x[2] ) ) == aString[1]  .or. ;
					   ( x[1] + x[6] + x[5] + x[4]                ) == aString[2]     	;
				 }

		bExce := { |e| dData >= aExcePer[e,2] .and. dData <= IF(!Empty(aExcePer[e,3]),aExcePer[e,3],aExcePer[e,2]) }

	   	bLoop := { |e,f| IF( f == "L" , aExcePer[e,1] + aExcePer[e,6] + aExcePer[e,5] + aExcePer[e,4] != aString[2] ,;
						   			    aExcePer[e,1] + aExcePer[e,6] + aExcePer[e,5] + aExcePer[e,4] == aString[2]  ;
							)																						 ;
	   			 }
		
		For nY := 1 To nFornY
			
			aString  := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
			
			IF ( ( nPos := aScan( aExcePer, bCond ) ) > 0 )
				nFornX  := ( nFornX := Len( aExcePer ) )
				For nX := nPos To nFornX
					IF ( nX > nFornX )
						Exit
					EndIF	
					IF Eval( bLoop , nX , "L" ) 
						IF Eval( bLoop , nFornX , "F" ) .and. Eval( bExce , nFornX )
							lExcecao := .T.
							IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
								aAdd( aExceTip , {   			   			 ;
													nFornX		   			,;	//01 -> Indice da Excecao em aExcePer
													aExcePer[ nFornX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
													aExceper[ nFornX , 02 ]	,;	//03 -> Data Inicial da Excecao
													aExceper[ nFornX , 03 ] ,;	//04 -> Data Final da Excecao
													aExceper[ nFornX , 01 ] ,;	//05 -> Filial
													aExceper[ nFornX , 06 ] ,;	//06 -> Matricula do Funcionario
													aExceper[ nFornX , 05 ] ,;	//07 -> Centro de Custo
													aExceper[ nFornX , 04 ]	,;	//08 -> Turno 
													aExcePer[ nFornX , 27 ]  ;	//09 -> Recno
												  };
									 )
								--nFornX	 
							EndIF
						Else
							--nFornX
						EndIF
						Loop
					EndIF
					IF Eval( bExce , nX )
						lExcecao := .T.
						IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
							aAdd( aExceTip , {   					 ;
												nX					,;	//01 -> Indice da Excecao em aExcePer
												aExcePer[ nX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
												aExceper[ nX , 02 ]	,;	//03 -> Data Inicial da Excecao
												aExceper[ nX , 03 ] ,;	//04 -> Data Final da Excecao
												aExceper[ nX , 01 ] ,;	//05 -> Filial
												aExceper[ nX , 06 ] ,;	//06 -> Matricula do Funcionario
												aExceper[ nX , 05 ] ,;	//07 -> Centro de Custo
												aExceper[ nX , 04 ]	,;	//08 -> Turno 
												aExcePer[ nX , 27 ]  ;	//09 -> Recno
											   };
								 )
						EndIF
					EndIF
					IF Eval( bLoop , nFornX , "F" )  .and. Eval( bExce , nFornX )
						lExcecao := .T.
						IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
							aAdd( aExceTip , {   			   			 ;
												nFornX		   			,;	//01 -> Indice da Excecao em aExcePer
												aExcePer[ nFornX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
												aExceper[ nFornX , 02 ]	,;	//03 -> Data Inicial da Excecao
												aExceper[ nFornX , 03 ] ,;	//04 -> Data Final da Excecao
												aExceper[ nFornX , 01 ] ,;	//05 -> Filial
												aExceper[ nFornX , 06 ] ,;	//06 -> Matricula do Funcionario
												aExceper[ nFornX , 05 ] ,;	//07 -> Centro de Custo
												aExceper[ nFornX , 04 ]	,;	//08 -> Turno 
												aExcePer[ nFornX , 27 ]  ;	//09 -> Recno
											   };
								 )
							--nFornX	 
						EndIF
					Else
						--nFornX
					EndIF
				Next nX
			EndIF
	    
	    Next nY

	ElseIF !( lPeriodo ) //Pesquizando em Arquivo

		DEFAULT cIndKeyExc	:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
		DEFAULT nOrderExce	:= RetOrdem( "SP2" , cIndKeyExc )

		IF SP2->( IndexOrd() <> nOrderExce )
			IF !fContemStr( cIndKeyExc , SP2->( IndexKey() ) )
				SP2->( dbSetOrder( nOrderExce ) )
			EndIF
		EndIF

		baScan := { |x| x[2] + Dtos( x[3] ) + Dtos( x[4] ) == P2_TIPODIA + Dtos( P2_DATA ) + Dtos( P2_DATAATE ) }
		bExce  := { || dData >= P2_DATA .and. dData <= IF(!Empty(P2_DATAATE),P2_DATAATE,P2_DATA) }
		bLoop  := { || P2_FILIAL + P2_MAT + P2_CC + P2_TURNO == aString[1]  .or.	;
					   P2_FILIAL + P2_MAT + P2_CC + P2_TURNO == aString[2]  		;
				   }

		For nY := 1 To nFornY

			aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )

			IF SP2->(dbSeek( aString[1] , .F.) .or. dbSeek( aString[2] , .F.) ) 
				While SP2->( !Eof() .and. Eval( bLoop ) )
					IF ( lExcecao := SP2->( Eval( bExce ) ) ) 
						While SP2->( !Eof() .and. Eval( bLoop ) )
							IF SP2->( Eval( bExce ) )
								IF Empty( aExceTip ) .or. SP2->( aScan( aExceTip , baScan ) ) == 0
									++nX
									SP2->( aAdd( aExceTip , {				 ;
																nX			,;	//01 -> Indice da Excecao em aExcePer
																P2_TIPODIA	,;	//02 -> Tipo do Dia para a Excecao
																P2_DATA		,;	//03 -> Data Inicial da Excecao
																P2_DATAATE	,;	//04 -> Data Final da Excecao
																P2_FILIAL   ,;	//05 -> Filial
																P2_MAT      ,;	//06 -> Matricula do Funcionario
																P2_CC		,;	//07 -> Centro de Custo
																P2_TURNO    ,;	//08 -> Turno
																Recno()		 ;	//09 -> Recno
															 };
												);
										  )
								EndIF
								SP2->( dbSkip() )
							Else
								Break
							EndIF
						End While
					Else
						SP2->( dbSkip() )
					EndIF
				End While
			EndIF
	
		Next nY
		
	EndIF

End Sequence

lExcecao := .F.
IF !( lPeriodo )

	nPos := 0
	IF !Empty( aExceTip )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Procura Excecao sem o Tipo do Dia                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	   	baScan	:= { |e| (;
	   						(;
	   							e[5] +			;	//Filial
	   							e[6] +			;	//Matricula
	   							e[7] +			;	//Centro de Custo
	   							e[8] + 			;	//Turno
	   							e[2]			;	//Tipo do Dia
	   						);	
	   						==					;
							(;
								aString[2] +	;
								cSpcTipoDia		;
							);	
	   					 );
		   			 }
	
		For nY := 1 To nFornY
	
			aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
			IF ( ( nPos := aScan( aExceTip , baScan ) ) > 0 )
	        	Exit
	        EndIF
	
		Next nY
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Procura Excecao Expecifica para o Tipo do Dia                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( nPos == 0 ) )
	    
		   	baScan	:= { |e| (;
		   						(;
		   							e[5] +			;	//Filial
		   							e[6] +			;	//Matricula
		   							e[7] +			;	//Centro de Custo
		   							e[8] +			;	//Turno
		   							e[2]			;	//Tipo do Dia
		   						);	
		   						==					;
		   						(;
		   							aString[2] +	;
		   							cTipoDia		;
		   						);	
		   					 );
			   			 }
		
			For nY := 1 To nFornY
		
				aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
				IF ( ( nPos := aScan( aExceTip , baScan ) ) > 0 )
		        	Exit
		        EndIF
		
			Next nY
	
		EndIF
		
	EndIF

	IF ( lExcecao := ( nPos > 0 ) )
	
		cTipoDia	:= aExceTip[ nPos , 02 ]
		nRecno      := aExceTip[ nPos , 09 ]
	
		IF !( lArray )
			IF ( SP2->( Recno() ) != nRecno )
				SP2->( dbGoto( nRecno ) )
			EndIF
		Else
			IF ( lForceGoto )
				IF ( SP2->( Recno() ) != nRecno )
					SP2->( dbGoto( nRecno ) )
				EndIF
			EndIF
			nPos := aExceTip[ nPos , 01 ]
		EndIF
	
		SP2->( fAddExce( @aArray , lArray , aExceper , nPos , dData , cRegra , nRecno ) )

	EndIF
	
ElseIF ( lPeriodo )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Neste Ponto a Chamada devera ser Feita Pela Processa()       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	SP2->( ProcRegua( RecCount() ) , dbGoTop() )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Depura o Arquivo de Excecoes Carregando as Excecoes do Periodo³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	fDepuraSP2( @cArqInd , dPerIni , dPerFim , lShowDialog )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega as Excecoes do Periodo                             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aExcePer := {}
	While SP2->( !Eof() )
		IncProc(OemToAnsi(STR0060))	// 'Carregando as Exce‡”es do Per¡odo...'
		SP2->( fAddExce( @aExcePer , NIL , NIL , NIL , NIL , cRegra , Recno() ) )
		SP2->( dbSkip() )
	End While

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura Indices do SP2 e Apaga Indice Temporario          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !Empty( cArqInd )
		RetIndex("SP2")
		SP2->( dbSetOrder( nOrderExce ) )
		fErase( cArqInd + OrdBagExt() )
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega o Retorno da Funcao                                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lExcecao := ( Len( aExcePer ) > 0 )

EndIF

Return( lExcecao )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetCondExce	  ³ Autor ³Marinaldo de Jesus    ³ Data ³19/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Array com Chaves para a Pesquisa das Excecoes          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RetCondExce( cFil , cMat , cTno , cCC , dData , nInd )		   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                         					   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³xRet ->	Qdo PCount() = 0 , Numero de Condicoes Existentes, caso³
³          ³       	Contrario, Array de 2 Posicoes contendo as Chaves  para³
³          ³       	a Pesquisa das Excecoes.                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GetExcecoes()												   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function RetCondExce( cFil , cMat , cTno , cCC , dData , nInd )

Local cSpcP2Mat	:= Space( GetSx3Cache( "P2_MAT    " , "X3_TAMANHO" ) ) 
Local cSpcP2Cc	:= Space( GetSx3Cache( "P2_CC     " , "X3_TAMANHO" ) ) 
Local cSpcP2Tno	:= Space( GetSx3Cache( "P2_TURNO  " , "X3_TAMANHO" ) ) 
Local xRet		:= NIL

IF Empty( PCount() )
	xRet := 8.00
Else
	xRet := Array( 02 )
	IF nInd == 1		//Pesquisando Mat + CC + Turno
		xRet[1]		:=  ( cFil + cMat + cCC + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cCC + cTno )
	ElseIF nInd == 2	//Pesquisando Mat + CC + şşşşş
		xRet[1]		:=	( cFil + cMat + cCC + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cCC + cSpcP2Tno )
	ElseIF nInd == 3	//Pesquisando Mat + şş + Turno
		xRet[1]		:=	( cFil + cMat + cSpcP2Cc + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cSpcP2Cc + cTno )
	ElseIF nInd == 4	//Pesquisando Mat + şş + şşşşş
		xRet[1]		:=	( cFil + cMat + cSpcP2Cc + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cSpcP2Cc + cSpcP2Tno )
	ElseIF nInd == 5	//Pesquisando şşş + CC + Turno
		xRet[1]		:=  ( cFil + cSpcP2Mat + cCC + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cSpcP2Mat + cCC + cTno )
	ElseIF nInd == 6	//Pesquisando şşş + şş + Turno
		xRet[1]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cTno + Dtos( dData ) )
	    xRet[2]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cTno )
	ElseIF nInd == 7	//Pesquisando şşş + CC + şşşşş
		xRet[1]		:=  ( cFil + cSpcP2Mat + cCC + cSpcP2Tno + Dtos( dData ) ) 
	    xRet[2]		:=  ( cFil + cSpcP2Mat + cCC + cSpcP2Tno )
	ElseIF nInd == 8	//Pesquisando şşş + şş + şşşşş
		xRet[1]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cSpcP2Tno )
	EndIF
EndIF
	
Return( xRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetExceTop ³Autor ³ Marinaldo de Jesus    ³ Data ³07/06/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega a Tabela de Exce‡”es                	            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetExcecoes()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³< Vide Parametros Formais >							        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico RDD TOPCONNECT                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetExceTop( cFil		,; //01 -> Filial
					 cMat 		,; //02 -> Matricula
					 cCc		,; //03 -> Centro de Custo
					 aTurnos	,; //04 -> Array com os Turnos do Funcionario
					 dPerIni	,; //05 -> Periodo Inicial
					 dPerFim	,; //06 -> Periodo Final
					 aArray  	 ; //07 -> Array a ser carregado com as Excecoes
					)

Local cSvAlias	:= Alias()
Local lRet		:= .F.

#IFDEF TOP

	Local baScan		:= { || NIL }
	Local cPerIni		:= Dtos( dPerIni )
	Local cPerFim		:= Dtos( dPerFim )
	Local cRegra		:= SRA->RA_REGRA
	Local cSpaceMat		:= Space( GetSx3Cache( "RA_MAT    " , "X3_TAMANHO" ) )
	Local cSpaceCus 	:= Space( GetSx3Cache( "RA_CC     " , "X3_TAMANHO" ) )
	Local cSpaceTur 	:= Space( GetSx3Cache( "RA_TNOTRAB" , "X3_TAMANHO" ) )
	Local cQuery		:= ""
	Local cTno			:= ""
	Local cAliasQuery	:= "__QSP2QRY"
	Local cInitSqlName	:= InitSqlName("SP2")
	Local lQueryOpened	:= .F.
	Local nLenTurno		:= 0
	Local nX			:= 0
	Local nY			:= 0
	Local nSvOrder		:= SP2->( IndexOrd() )
	
	Static aStruSP2
	Static cIndKeyExc
	Static cQrySp2Fields
	Static nOrderExce
	Static nFieldsSP2
	
	DEFAULT cIndKeyExc	:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
	DEFAULT nOrderExce	:= RetOrdem( "SP2" , cIndKeyExc )

	IF ( aStruSP2	== NIL )
		aStruSP2	:= SP2->( dbStruct() )
		nFieldsSP2	:= Len( aStruSP2 )
	EndIF	

 	IF ( cQrySp2Fields == NIL )
		cQrySp2Fields := ""
		For nX := 1 To nFieldsSP2
			cQrySp2Fields += aStruSP2[ nX , 01 ] + ", "
		Next nX
    EndIF

	aArray := {}
	
	IF ( nOrderExce == nSvOrder )
		SP2->( dbSetOrder( nOrderExce ) )
	EndIF    

	baScan	:= { |x| x[ 01 ] == ( cAliasQuery )->( P2_FILIAL	)	.and. ; //Filial
			  		 x[ 02 ] == ( cAliasQuery )->( P2_DATA		)	.and. ; //Data De
					 x[ 03 ] == ( cAliasQuery )->( P2_DATAATE	)	.and. ; //Data Ate
					 x[ 04 ] == ( cAliasQuery )->( P2_TURNO		)	.and. ; //Turno
					 x[ 05 ] == ( cAliasQuery )->( P2_CC		)	.and. ; //Centro de Custo
					 x[ 06 ] == ( cAliasQuery )->( P2_MAT		)	.and. ; //Matricula
					 x[ 35 ] == ( cAliasQuery )->( P2_TIPODIA	)		  ; //Tipo do Dia Para Excecao
	            }
	
	nLenTurno := Len( aTurnos )
	For nY := 1 To nLenTurno

		cTno	:= aTurnos[ nY , 01 ]
		cQuery	:= "SELECT "
		cQuery  += cQrySp2Fields
		cQuery	+= "R_E_C_N_O_ RECNO"
		cQuery	+= " FROM "
		cQuery	+= cInitSqlName
		cQuery	+= " WHERE "
		cQuery	+= "("
		cQuery	+=	"("
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+=		")"
		cQuery	+=		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+=		")"
		cQuery	+=		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+=		")"
		cQuery	+=		" AND "
		cQuery	+= 		"("
		cQuery	+= 			"("
		cQuery	+= 			 	"P2_DATAATE BETWEEN '"+cPerIni+"' AND '"+cPerFim+"'" 
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_DATA BETWEEN '"+cPerIni+"' AND '"+cPerFim+"'"
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_DATAATE >='"+cPerFim+"' AND P2_DATA<='"+cPerIni+"'"
		cQuery	+= 			")"
		cQuery	+= 		")"
		cQuery	+=	")"
		cQuery	+=	" AND D_E_L_E_T_=' '"
		cQuery	+= ")"
		cQuery	+= " ORDER BY "+SqlOrder( SP2->( IndexKey() ) )
		cQuery	:= ChangeQuery( cQuery )
		
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )

			For nX := 1 To nFieldsSP2
				IF ( aStruSP2[nX,02] <> "C" )
					TcSetField(cAliasQuery,aStruSP2[nX,01],aStruSP2[nX,02],aStruSP2[nX,03],aStruSP2[nX,04])
				EndIF
			Next nX
	
			While ( cAliasQuery )->( !Eof() )
	
				IF aScan( aArray , baScan ) == 0
					( cAliasQuery )->( fAddExce( @aArray , NIL , NIL , NIL , NIL , cRegra , RECNO ) )
				EndIF
				
				( cAliasQuery )->( dbSkip() )
			
			End While
			
			( cAliasQuery )->( dbCloseArea() )

		EndIF
			
	Next nY	

	IF ( nOrderExce == nSvOrder )
		SP2->( dbSetOrder( nSvOrder ) )
	EndIF

	lRet := !( Empty( aArray ) )

#ENDIF

IF ( Select( cSvAlias ) > 0 )
	dbSelectArea( cSvAlias )
EndIF
	
Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fAddExce      ³ Autor ³Marinaldo de Jesus    ³ Data ³18/07/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carregar o Array de Excecoes com Informacoes do SP2            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³SP2>->( fAddExce( @aArray ) )                          		   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                         					   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aArray   -> Array que contera as Excecoes do SP2               ³
³          ³lArray   -> Quando True Carrega Excecao de aExcePer            ³
³          ³aExcePer -> Array com as Excecoes por Periodo                  ³
³          ³nPos     -> Posicao da Excecao em aExcePer                     ³
³          ³dData    -> Data da Excecao                                    ³
³          ³cRegra   -> Regra de Apontamento do Cadastro de Funcionarios   ³
³          ³nRecno   -> Recno Correspondente a Excecao                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GetExcecoes() e GetExceTop()								   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fAddExce( aArray , lArray , aExceper , nPos , dData , cRegra , nRecno )

Local nLenArray := 0
Local cHerdHor	:= "N"

IF !( lArray )
	cRegra		:=	IF( Empty( P2_REGRA ) , cRegra , P2_REGRA )
	cHerdHor	:=	IF( ( P2_HERDHOR == "S" ) , "S", "N" )
EndIF

IF ( dData == NIL ) //Carrega as Excecoes Por Periodo

	aAdd(aArray, Array( 62 ) )
	nLenArray := Len( aArray )
	aArray[nLenArray,01] := P2_FILIAL	//01 - Filial
	aArray[nLenArray,02] := P2_DATA		//02 - Data da Excecao
	aArray[nLenArray,03] := P2_DATAATE	//03 - Data Final da Excecao
	aArray[nLenArray,04] := P2_TURNO	//04 - Turno para a Excecao
	aArray[nLenArray,05] := P2_CC		//05 - Centro de Custo para a Excecao
	aArray[nLenArray,06] := P2_MAT		//06 - Matricula para a Excecao
	aArray[nLenArray,07] := P2_ENTRA1	//07 - 1a. Entrada
	aArray[nLenArray,08] := P2_SAIDA1	//08 - 1a. Saida
	aArray[nLenArray,09] := P2_ENTRA2	//09 - 2a. Entrada
	aArray[nLenArray,10] := P2_SAIDA2	//10 - 2a. Saida
	aArray[nLenArray,11] := P2_ENTRA3	//11 - 3a. Entrada
	aArray[nLenArray,12] := P2_SAIDA3	//12 - 3a. Saida
	aArray[nLenArray,13] := P2_ENTRA4	//13 - 4a. Entrada
	aArray[nLenArray,14] := P2_SAIDA4	//14 - 4a. Saida
	aArray[nLenArray,15] := P2_INTERV1	//15 - Primeira Saida Intervalo
	aArray[nLenArray,16] := P2_INTERV2	//16 - Segunda Saida Intervalo
	aArray[nLenArray,17] := P2_INTERV3	//17 - Terceira Saida Intervalo
	aArray[nLenArray,18] := P2_HRSTRAB	//18 - Horas Trabalhadas 1a. Jornada
	aArray[nLenArray,19] := P2_HRSTRA2	//19 - Horas Trabalhadas 2a. Jornada
	aArray[nLenArray,20] := P2_HRSTRA3	//20 - Horas Trabalhadas 3a. Jornada
	aArray[nLenArray,21] := P2_HRSTRA4	//21 - Horas Trabalhadas 4a. Jornada
	aArray[nLenArray,22] := 0			//22 - Numero de Marcacoes da Tabela (Nao usado)
	aArray[nLenArray,23] := P2_MOTIVO	//23 - Motivo da Excecao
	aArray[nLenArray,24] := P2_CODHEXT	//24 - Codigo da Hora Extra Normal
	aArray[nLenArray,25] := P2_TRABA	//25 - Dia Trabalhado
	aArray[nLenArray,26] := P2_CODHNOT	//26 - Codigo da Hora Extra Noturna
	aArray[nLenArray,27] := nRecno		//27 - Registro da Excecao
	aArray[nLenArray,28] := P2_HRINTV1	//28 - Horas do Primeiro Intervalo
	aArray[nLenArray,29] := P2_HRINTV2	//29 - Horas do Segundo Intervalo
	aArray[nLenArray,30] := P2_HRINTV3	//30 - Horas do Terceiro Intervalo
	aArray[nLenArray,31] := P2_CCPER01	//31 - Centro de Custo da 1a. Jornada
	aArray[nLenArray,32] := P2_CCPER02	//32 - Centro de Custo da 2a. Jornada
	aArray[nLenArray,33] := P2_CCPER03	//33 - Centro de Custo da 3a. Jornada
	aArray[nLenArray,34] := P2_CCPER04	//34 - Centro de Custo da 4a. Jornada
	aArray[nLenArray,35] := P2_TIPODIA	//35 - Tipo do Dia para a Excecao
	aArray[nLenArray,36] := P2_NONAHOR	//36 - Aponta Nona Hora
	aArray[nLenArray,37] := P2_HORMENO	//37 - Limite de Horario Inicial
	aArray[nLenArray,38] := P2_HORMAIS	//38 - Limite de Horario Final
	aArray[nLenArray,39] := P2_JND1CON	//39 - 1a. Jornada Continua
	aArray[nLenArray,40] := P2_JND2CON	//40 - 2a. Jornada Continua
	aArray[nLenArray,41] := P2_JND3CON	//41 - 2a. Jornada Continua
	aArray[nLenArray,42] := P2_JND4CON	//42 - 2a. Jornada Continua
	aArray[nLenArray,43] := P2_CODREF	//43 - Codigo da Refeicao
	aArray[nLenArray,44] := cRegra		//44 - Regra de Apontamento
	aArray[nLenArray,45] := P2_INIHNOT	//45 - Inicio da Hora Noturna
	aArray[nLenArray,46] := P2_FIMHNOT	//46 - Final da Hora Noturna
	aArray[nLenArray,47] := P2_MINHNOT	//47 - Minutos da Hora Noturna 
	aArray[nLenArray,48] := cHerdHor	//48 - Herda Hora (Mantem o Horario do Calendario)
	aArray[nLenArray,49] := P2_CODFUN1	//49 - Funcao 1a. Jornada
	aArray[nLenArray,50] := P2_CODFUN2	//50 - Funcao 2a. Jornada
	aArray[nLenArray,51] := P2_CODFUN3	//51 - Funcao 3a. Jornada
	aArray[nLenArray,52] := P2_CODFUN4	//52 - Funcao 4a. Jornada  
  	aArray[nLenArray,53] := P2_POSTO1	//53 - Posto 1a. Jornada
	aArray[nLenArray,54] := P2_POSTO2	//54 - Posto 2a. Jornada
	aArray[nLenArray,55] := P2_POSTO3	//55 - Posto 3a. Jornada
	aArray[nLenArray,56] := P2_POSTO4	//56 - Posto 4a. Jornada
	aArray[nLenArray,57] := P2_DEPTO1	//57 - Depto 1a. Jornada
	aArray[nLenArray,58] := P2_DEPTO2	//58 - Depto 2a. Jornada
	aArray[nLenArray,59] := P2_DEPTO3	//59 - Depto 3a. Jornada
	aArray[nLenArray,60] := P2_DEPTO4	//60 - Depto 4a. Jornada    
	aArray[nLenArray,61] := P2_ID		//61 - Id da excecao
	aArray[nLenArray,62] := P2_TPEXCE	//62 - Tipo de Excecao 'F' = Funcionario / 'P' = Periodo
	
Else //Carrega as Excecoes na Data
	aAdd( aArray , Array( 60 ) )
	nLenArray := Len( aArray )
	aArray[nLenArray,01] := dData					//01 - Data
	IF ( lArray )
	
		aArray[nLenArray,02] := aExcePer[nPos,04]	//02 - Turno
		aArray[nLenArray,03] := aExcePer[nPos,05]	//03 - CC
		aArray[nLenArray,04] := aExcePer[nPos,06]	//04 - Mat
		aArray[nLenArray,05] := aExcePer[nPos,07]	//05 - Entra1
		aArray[nLenArray,06] := aExcePer[nPos,08]	//06 - Saida1
		aArray[nLenArray,07] := aExcePer[nPos,09]	//07 - Entra2
		aArray[nLenArray,08] := aExcePer[nPos,10]	//08 - Saida2
		aArray[nLenArray,09] := aExcePer[nPos,11]	//09 - Entra3
		aArray[nLenArray,10] := aExcePer[nPos,12]	//10 - Saida3
		aArray[nLenArray,11] := aExcePer[nPos,13]	//11 - Entra4
		aArray[nLenArray,12] := aExcePer[nPos,14]	//12 - Saida4
		aArray[nLenArray,13] := aExcePer[nPos,15]	//13 - Intervalo1
		aArray[nLenArray,14] := aExcePer[nPos,16]	//14 - Intervalo2
		aArray[nLenArray,15] := aExcePer[nPos,17]	//15 - Intervalo3
		aArray[nLenArray,16] := aExcePer[nPos,18]	//16 - Horas Trabalhadas 1a. Jornada
		aArray[nLenArray,17] := aExcePer[nPos,19]	//17 - Horas Trabalhadas 2a. Jornada
		aArray[nLenArray,18] := aExcePer[nPos,20]	//18 - Horas Trabalhadas 3a. Jornada
		aArray[nLenArray,19] := aExcePer[nPos,21]	//19 - Horas Trabalhadas 4a. Jornada
		aArray[nLenArray,20] := aExcePer[nPos,22]	//20 - TabMarc("SP2") Numero de Marcacoes da Tabela
		aArray[nLenArray,21] := aExcePer[nPos,23]	//21 - Motivo
		aArray[nLenArray,22] := aExcePer[nPos,24]	//22 - HExt
		aArray[nLenArray,23] := aExcePer[nPos,25]	//23 - Traba
		aArray[nLenArray,24] := aExcePer[nPos,26]	//24 - HENot
		aArray[nLenArray,25] := aExcePer[nPos,27]	//25 - Recno
		aArray[nLenArray,26] := aExcePer[nPos,28]	//26 - Horas do 1o. Intervalo	
		aArray[nLenArray,27] := aExcePer[nPos,29]	//27 - Horas do 2o. Intervalo
		aArray[nLenArray,28] := aExcePer[nPos,30]	//28 - Horas do 3o. Intervalo
		aArray[nLenArray,29] := aExcePer[nPos,31]	//29 - Centro de Custo Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,30] := aExcePer[nPos,32]	//30 - Centro de Custo Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,31] := aExcePer[nPos,33]	//31 - Centro de Custo Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,32] := aExcePer[nPos,34]	//32 - Centro de Custo Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,33] := aExcePer[nPos,35]	//33 - Tipo do Dia para a Excecao
		aArray[nLenArray,34] := aExcePer[nPos,36]	//34 - Aponta Nona Hora
		aArray[nLenArray,35] := aExcePer[nPos,37]	//35 - Limite de Horario Inicial
		aArray[nLenArray,36] := aExcePer[nPos,38]	//36 - Limite de Horario Inicial
		aArray[nLenArray,37] := aExcePer[nPos,39]	//37 - 1a. Jornada Continua
		aArray[nLenArray,38] := aExcePer[nPos,40]	//38 - 2a. Jornada Continua
		aArray[nLenArray,39] := aExcePer[nPos,41]	//39 - 2a. Jornada Continua
		aArray[nLenArray,40] := aExcePer[nPos,42]	//40 - 2a. Jornada Continua
		aArray[nLenArray,41] := aExcePer[nPos,43]	//41 - Codigo da Refeicao
		aArray[nLenArray,42] := aExcePer[nPos,44]	//42 - Regra de Apontamento
		aArray[nLenArray,43] := aExcePer[nPos,45]	//43 - Inicio da Hora Noturna
		aArray[nLenArray,44] := aExcePer[nPos,46]	//44 - Final da Hora Noturna
		aArray[nLenArray,45] := aExcePer[nPos,47]	//45 - Minutos da Hora Noturna  
		aArray[nLenArray,46] := aExcePer[nPos,48]	//46 - Herda Hora (Mantem o Horario do Calendario) 
		aArray[nLenArray,47] := aExcePer[nPos,49]	//47 - Funcoes Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,48] := aExcePer[nPos,50]	//48 - Funcoes Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,49] := aExcePer[nPos,51]	//49 - Funcoes Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,50] := aExcePer[nPos,52]	//50 - Funcoes Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,51] := aExcePer[nPos,53]	//51 - Posto Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,52] := aExcePer[nPos,54]	//52 - Posto Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,53] := aExcePer[nPos,55]	//53 - Posto Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,54] := aExcePer[nPos,56]	//54 - Posto Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,55] := aExcePer[nPos,57]	//55 - Depto Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,56] := aExcePer[nPos,58]	//56 - Depto Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,57] := aExcePer[nPos,59]	//57 - Depto Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,58] := aExcePer[nPos,60]	//58 - Depto Periodo 4 (4a.E-4a.S)		
		aArray[nLenArray,59] := aExcePer[nPos,61]	//59 - Id de excecao
		aArray[nLenArray,60] := aExcePer[nPos,62]	//60 - Tipo de Excecao 'F' = Funcionario / 'P' = Periodo
				
	Else
	
		aArray[nLenArray,02] :=	P2_TURNO			//02 - Turno
		aArray[nLenArray,03] := P2_CC				//03 - CC
		aArray[nLenArray,04] := P2_MAT				//04 - Mat
		aArray[nLenArray,05] := P2_ENTRA1			//05 - Entra1
		aArray[nLenArray,06] := P2_SAIDA1			//06 - Saida1
		aArray[nLenArray,07] := P2_ENTRA2			//07 - Entra2
		aArray[nLenArray,08] := P2_SAIDA2			//08 - Saida2
		aArray[nLenArray,09] := P2_ENTRA3			//09 - Entra3
		aArray[nLenArray,10] := P2_SAIDA3			//10 - Saida3
		aArray[nLenArray,11] := P2_ENTRA4			//11 - Entra4
		aArray[nLenArray,12] := P2_SAIDA4			//12 - Saida4
		aArray[nLenArray,13] := P2_INTERV1			//13 - Intervalo1
		aArray[nLenArray,14] := P2_INTERV2			//14 - Intervalo2
		aArray[nLenArray,15] := P2_INTERV3			//15 - Intervalo3
		aArray[nLenArray,16] := P2_HRSTRAB			//16 - Horas Trabalhadas 1a. Jornada
		aArray[nLenArray,17] := P2_HRSTRA2			//17 - Horas Trabalhadas 2a. Jornada
		aArray[nLenArray,18] := P2_HRSTRA3			//18 - Horas Trabalhadas 3a. Jornada
		aArray[nLenArray,19] := P2_HRSTRA4			//19 - Horas Trabalhadas 4a. Jornada
		aArray[nLenArray,20] := 0					//20 - TabMarc("SP2") Numero de Marcacoes da Tabela
		aArray[nLenArray,21] := P2_MOTIVO			//21 - Motivo
		aArray[nLenArray,22] := P2_CODHEXT			//22 - HExt
		aArray[nLenArray,23] := P2_TRABA			//23 - Traba
		aArray[nLenArray,24] := P2_CODHNOT			//24 - HENot
		aArray[nLenArray,25] := nRecno				//25 - Recno
		aArray[nLenArray,26] := P2_HRINTV1			//26 - Horas do 1o. Intervalo	
		aArray[nLenArray,27] := P2_HRINTV2			//27 - Horas do 2o. Intervalo
		aArray[nLenArray,28] := P2_HRINTV3			//28 - Horas do 3o. Intervalo
		aArray[nLenArray,29] := P2_CCPER01			//29 - Centro de Custo Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,30] := P2_CCPER02			//30 - Centro de Custo Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,31] := P2_CCPER03			//31 - Centro de Custo Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,32] := P2_CCPER04			//32 - Centro de Custo Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,33] := P2_TIPODIA			//33 - Tipo do Dia para a Excecao
		aArray[nLenArray,34] := P2_NONAHOR			//34 - Aponta Nona Hora
		aArray[nLenArray,35] := P2_HORMENO			//35 - Limite de Horario Inicial
		aArray[nLenArray,36] := P2_HORMAIS			//36 - Limite de Horario Inicial
		aArray[nLenArray,37] := P2_JND1CON			//37 - 1a. Jornada Continua
		aArray[nLenArray,38] := P2_JND2CON			//38 - 2a. Jornada Continua
		aArray[nLenArray,39] := P2_JND3CON			//39 - 2a. Jornada Continua
		aArray[nLenArray,40] := P2_JND4CON			//40 - 2a. Jornada Continua
		aArray[nLenArray,41] := P2_CODREF			//41 - Codigo da Refeicao
		aArray[nLenArray,42] := cRegra				//42 - Regra de Apontamento
		aArray[nLenArray,43] := P2_INIHNOT			//43 - Inicio da Hora Noturna
		aArray[nLenArray,44] := P2_FIMHNOT			//44 - Final da Hora Noturna
		aArray[nLenArray,45] := P2_MINHNOT			//45 - Minutos da Hora Noturna
		aArray[nLenArray,46] := cHerdHor			//46 - Herda Hora (Mantem o Horario do Calendario)
	    aArray[nLenArray,47] := P2_CODFUN1			//47 - Funcao Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,48] := P2_CODFUN2			//48 - Funcao Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,49] := P2_CODFUN3			//49 - Funcao Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,50] := P2_CODFUN4			//50 - Funcao Periodo 4 (4a.E-4a.S)	 
	    aArray[nLenArray,51] := P2_POSTO1			//51 - Posto Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,52] := P2_POSTO2			//52 - Posto Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,53] := P2_POSTO3			//53 - Posto Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,54] := P2_POSTO4			//54 - Posto Periodo 4 (4a.E-4a.S)	
	    aArray[nLenArray,55] := P2_DEPTO1			//55 - Depto Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,56] := P2_DEPTO2			//56 - Depto Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,57] := P2_DEPTO3			//57 - Depto Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,58] := P2_DEPTO4			//58 - Depto Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,59] := P2_ID				//59 - Id de excecao		
		aArray[nLenArray,60] := P2_TPEXCE			//60 - Tipo de Excecao 'F' = Funcionario / 'P' = Periodo

	EndIF
EndIF
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PutHrsTab  ³Autor ³ Marinaldo de Jesus    ³ Data ³27/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Atualiza as Horas da Tabela de Horario/Excecoes		        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PutHrsTab( cAlias , lProcess )								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³cAlias   -> Alias da Tabela a Ser Atualizada                ³
³          ³            "SP2" -> Excecoes                               ³
³          ³            "SPJ" -> Tabela de Horario Padrao               ³
³          ³lProcess -> False Executa via Processa()                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutHrsTab( cAlias , lProcess )
Local aArea			:= GetArea()
Local bEval			:= { |e| &(e) }
Local cCond			:= ""
Local cPerg			:= ""
Local cPref			:= ""
Local cSeek			:= ""
Local nHoras		:= 0

Private lAbortPrint := .F.

DEFAULT cAlias	 := IF (lUseSPJ,"SPJ","RF3")
DEFAULT lProcess := .F.

cAlias	:= Upper( AllTrim( cAlias ) )
cPerg	:= IF( cAlias <> "SP2" , "PNCAPJ" , "PNCAP2" )
cPref	:= ( PrefixoCpo( cAlias ) + "_" )

If cAlias == "SPJ"
	cCond := "PJ_FILIAL+PJ_TURNO"
ElseIf ( cAlias == "RF3" .or. cAlias == "RF2" )
	cAlias	 := "RF2"
	cCond    := "RF2_FILIAL+RF2_TURNO"
Else
	cCond := "P2_FILIAL+DTOS(P2_DATA)"
EndIf	

IF !( lProcess )
	IF Pergunte( cPerg , .T. )
		Processa( { || PutHrsTab( cAlias , .T. ) } , IF( cAlias <> "SP2" , STR0061 , STR0062 ) ,, .T. )
		Return( NIL )
	EndIF
Else
	Pergunte( cPerg , .F. )
	dbSelectArea( cAlias )
	( cAlias )->( ProcRegua( RecCount() ) , dbGotop() , dbSetOrder( RetOrdem( cAlias , cCond ) ) )
	IF !Empty( xFilial( cAlias ) )
		cSeek := ( mv_par01 + IF( cAlias <> "SP2"  , mv_par03 , Dtos( mv_par03 ) ) )
	Else
		cSeek := ( Space(FWGETTAMFILIAL) + IF( cAlias <> "SP2"  , mv_par03 , Dtos( mv_par03 ) ) )
	EndIF
	( cAlias )->( dbSeek( cSeek , .T. ) )
	While ( cAlias )->( !Eof() .and. Eval( bEval , cCond ) <= mv_par02 + IF(cAlias <> "SP2" , mv_par04 , Dtos( mv_par04 ) ) )
	    IncProc( STR0063 )
	    IF ( lAbortPrint )
	    	Exit
	    EndIF	

		If cAlias == "RF2"
			fHorasRF2(cAlias)
		Else
	    	If RecLock( cAlias , .F. , .F. )
				nHoras := 0
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT1 , P2_HRINTV1 ) )	:= fHrsTrabGat( "I" , cAlias , "DB" , "1" ) ) ), 0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT2 , P2_HRINTV2 ) ) := fHrsTrabGat( "I" , cAlias , "DB" , "2" ) ) ), 0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT3 , P2_HRINTV3 ) ) := fHrsTrabGat( "I" , cAlias , "DB" , "3" ) ) ), 0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRAB") ) := fHrsTrabGat( "H" , cAlias , "DB" , "1" ) ) ) ,0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA2") ) := fHrsTrabGat( "H" , cAlias , "DB" , "2" ) ) ) ,0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA3") ) := fHrsTrabGat( "H" , cAlias , "DB" , "3" ) ) ) ,0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA4") ) := fHrsTrabGat( "H" , cAlias , "DB" , "4" ) ) ) ,0 )
				( cAlias )->( IF( cAlias == "SPJ" , PJ_HRTOTAL , P2_TOTHORA ) ) := nHoras
						
			Endif
		
			( cAlias )->( MsUnLock() )
		EndIF	
		( cAlias )->( dbSkip() ) 
	End While
	RestArea(aArea)
EndIf
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fHorasRF2  ³Autor ³ Leandro Drummond	  ³ Data ³03/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Atualiza as Horas da Tabela de Horario/Excecoes				|
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fHorasRF2( cAlias )											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³cAlias   -> Alias da Tabela a Ser Atualizada                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fHorasRF2(cAlias)

Local aArea			:= GetArea()
Local cCondRF3		:= "RF3_FILIAL+RF3_JORN"
Local cCondRF4		:= "RF4_FILIAL+RF4_HOR"
Local cAliasRF3		:= "RF3"
Local cAliasRF4		:= "RF4"
Local cSeekRF3		:= ""
Local cSeekRF4		:= ""
Local nHoras		:= 0

dbSelectArea( cAliasRF4 )
dbGotop()
dbSetOrder( RetOrdem( cAliasRF4 , cCondRF4 ) )
cSeekRF4 := (cAlias)->( RF2_FILIAL + RF2_HOR )
( cAliasRF4 )->( dbSeek( cSeekRF4 ) )
While ( cAliasRF4 )->( !Eof() .and. RF4_FILIAL + RF4_HOR == cSeekRF4 )
	IF ( lAbortPrint )
    	Exit
    EndIF
    dbSelectArea( cAliasRF3 )
	dbGotop()
	dbSetOrder( RetOrdem( cAliasRF3 , cCondRF3 ) )			    
    cSeekRF3 := (cAliasRF4)->( RF4_FILIAL + RF4_JORN )
    ( cAliasRF3 )->( dbSeek( cSeekRF3 ) )
	While ( cAliasRF3 )->( !Eof() .and. RF3_FILIAL + RF3_JORN == cSeekRF3 )
    	IF ( lAbortPrint )
      		Exit
    	EndIF			    
	    IF RecLock( cAliasRF3 , .F. , .F. )
			nHoras := 0
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRINT1	:= fHrsTrabGat( "I" , cAliasRF3 , "DB" , "1" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRINT2	:= fHrsTrabGat( "I" , cAliasRF3 , "DB" , "2" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRINT3 := fHrsTrabGat( "I" , cAliasRF3 , "DB" , "3" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRTRAB := fHrsTrabGat( "H" , cAliasRF3 , "DB" , "1" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRTRA2 := fHrsTrabGat( "H" , cAliasRF3 , "DB" , "2" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRTRA3	:= fHrsTrabGat( "H" , cAliasRF3 , "DB" , "3" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRTRA4 := fHrsTrabGat( "H" , cAliasRF3 , "DB" , "4" ) ) ) ,0 )
			( cAliasRF3 )->RF3_HRSTOT:= nHoras
			( cAliasRF3 )->( MsUnLock() )
		EndIf
		( cAliasRF3 )->( dbSkip() )
	End While
    ( cAliasRF4 )->( dbSkip() )
End While

RestArea(aArea)

Return Nil
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CheckPonMes   ³ Autor ³Marinaldo de Jesus    ³ Data ³14/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida o Parametro de Fechamento do Ponto em Relacao ao Periodo³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide parametros Formais>									   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros Formais>									   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet -> Se a Competencia e' Valida                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generica                                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CheckPonMes(	dPerIni			,;	//Periodo Inicial de Apontamento
						dPerFim 		,;	//Periodo Final   de Apontamento
						lPut			,;	//Se True Grava Novo Periodo no Parametro do SX6
						lContinua		,;	//Se True Mesmo que o Periodo Nao For Valido ira contornar True.
						lShowHelp		,;	//Se False Nao Mostra o Help. DEFAULT True
						cFil			,;	//Filial para PerAponta()
						lNewPer			,;	//Se eh para gerar novo periodo (Para PerAponta())
						lPerCompleto	 ;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
					 )

Local cHelp			:= ""
Local cPerg			:= "PONMES"
Local dIniFec		:= Ctod("//")
Local dFimFec		:= Ctod("//")
Local lRet			:= .T.
Local lExistPonMes	:= .T.
Local lModPer		:= .T.
Local uSaveMvPar	:= IF( Type("mv_par01") != "U" , mv_par01 , NIL )

DEFAULT	dPerIni		:= Ctod("//")
DEFAULT	dPerFim 	:= Ctod("//")
DEFAULT lPut		:= .F.
DEFAULT lContinua	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT cFil		:= cFilAnt
DEFAULT lNewPer		:= .F.

IF ( lRet := CheckModSPO() )
	IF ( lRet := ( GetPonMesDat( @dIniFec , @dFimFec , cFil ) .and. !lPut ) )
		IF ( lRet := PerAponta( @dPerIni , @dPerFim , NIL , lShowHelp , cFil , NIL , @lPerCompleto ) )
			lRet := ( ( dIniFec == dPerIni ) .and. ( dFimFec <= dPerFim ) )
			IF ( !lRet .and. !lContinua .and. lShowHelp )
				cHelp += ( STR0064 + Dtoc( dIniFec ) + Chr(13) )					//'Data Inicial: '
				cHelp += ( STR0065 + Dtoc( dFimFec ) )								//'Data Final  : '
				Help( " " , 1 , "PERIIVALID" , , cHelp , 4 , 0 )
			ElseIF ( lContinua .and. !lRet )
				cHelp += STR0066													//'O Periodo de Apontamento: '
				cHelp += Dtoc( dIniFec )
				cHelp += STR0067													//' a '
				cHelp += Dtoc( dFimFec )                                        	
				cHelp += STR0068													//'ainda n„o foi Fechado. Deseja Continuar?'
				IF ( lShowHelp )
					lRet := MsgNoYes( OemToAnsi( cHelp ) , OemToAnsi( STR0069 ) )	//"Aten‡„o"
				Else
					lRet := .T.
				EndIF
			EndIF
		EndIF
	Else
		IF !( lPut )
			IF ( lShowHelp )
				SetMVValue(cPerg,"MV_PAR01",cTod("//"))
                If Pergunte( cPerg , .T.)
                    Pergunte( cPerg , .F.) // Acerto para atualizar o MV_PAR01
                Else
                    MV_PAR01    := cTod("//")
                EndIf
			EndIF
		EndIF
		IF ( lRet := PerAponta( @dPerIni , @dPerFim , IF( lPut , ( ++dPerFim ) , IF( Empty( mv_par01 ) .or. !( ValType( mv_par01 ) == "D" ) , dDataBase , mv_par01 ) ) , lShowHelp , cFil , lNewPer , @lPerCompleto ) )
			IF ( lPut .or. ( !lPut .and. !Empty( mv_par01 ) ) )
				IF !( lExistPonMes := PutMvFil( "MV_PONMES" , ( Dtos( dPerIni ) + "/" + Dtos( dPerFim ) ) , cFil ) )
					cHelp := OemToAnsi( STR0115 )										//'N„o Existe o Parametro MV_PONMES Para a Filial : '
					cHelp += CRLF
					cHelp += OemToAnsi( STR0116 )										//'Deseja Inclui-lo?'
					IF ( lShowHelp )
						IF MsgNoYes( OemToAnsi( cHelp ) , OemToAnsi( STR0069 ) )		//"Aten‡„o"
							IF ( lExistPonMes := CheckModSPO() )
								IF ( lExistPonMes := PutMvFil( "MV_PONMES" , ( Dtos( dPerIni ) + "/" + Dtos( dPerFim ) ) , cFil ) )
									lPut := .T.
								EndIF
							EndIF	
						EndIF
					EndIF
				Else
					lPut := .T.
				EndIF
		    EndIF
		    IF ( !( lPut ) .and. lExistPonMes )
			    IF ( lShowHelp )
			    	lRet := CheckPonMes( @dPerIni , @dPerFim , .F. , lContinua , lShowHelp , cFil , lNewPer )
	    		EndIF
	    	ElseIF !( lExistPonMes )
	    		IF ( lShowHelp )
	    			Help( " " , 1 , "NOMVPONMES" , , ( STR0114 + cFil ) , 4 , 0 ) //"Filial: "
	    		EndIF	
	    	EndIF                
	    Else
			IF ( lModPer )
				IF ( lShowHelp )
					lModPer := PonModPer( lModPer , cFil )
					lRet	:= CheckPonMes( @dPerIni , @dPerFim , .F. , .F. , .F. , cFil , .F. )
				EndIF
			EndIF
	    EndIF
	EndIF
EndIF
	
IF !Empty( uSaveMvPar )
	mv_par01 := uSaveMvPar
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ValidArqPon   ³ Autor ³Marinaldo de Jesus    ³ Data ³14/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida o Relacionamentos dos Arquivos do Ponto Eletronico      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ValidArqPon( lShowHelp )                           			   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                         					   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet -> Se todos os Arquivos Estao com o Relacionamento Correto³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generica                                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ValidArqPon( lShowHelp )
Return( PonRelationFile( lShowHelp ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonRelationFile³ Autor ³Marinaldo de Jesus   ³ Data ³14/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida o Relacionamentos dos Arquivos do Ponto Eletronico      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PonRelationFile( void )                            			   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                         					   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet -> Se todos os Arquivos Estao com o Relacionamento Correto³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generica                                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonRelationFile( lShowHelp )

Local cMsg			:= ""
Local lRetModo		:= .T.

Static lPonChkRel
Static cLastEmpChk

DEFAULT lShowHelp	:= .T.

DEFAULT lRF0ChkTable	:= fVerTabRF0()  	//Verifica a Existencia da Tabela de Pre-Abonos e se a mesm possui registro

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Coloca o Ponteiro do Mouse em Estado de Espera               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lShowHelp )
	CursorWait()
EndIF	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Consiste o Modo de Acesso dos Arquivos                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Begin Sequence
	DEFAULT lPonChkRel 	:= .T.
	DEFAULT cLastEmpChk	:= FWCODEMP("SRA")
	IF ( cLastEmpChk <> FWCODEMP("SRA") )
		lPonChkRel := .T.
	EndIF
	IF !( lPonChkRel )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP2",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP5",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP8",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPB",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPC",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPF",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPG",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPH",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPI",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPK",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPL",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPN",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPS",lShowHelp) )
		Break
	EndIF	
	IF !( lRetModo := xRetModo("SRA","SPT",lShowHelp) )
		Break
	EndIF	
	
	//-- Se Existir a tabela de Pre-abonos, checa modo de acesso compativel
	IF lRF0ChkTable
		IF !( lRetModo := xRetModo("SRA","RF0",lShowHelp) )
			Break
		EndIF	
	Endif

	IF !( lRetModo := xRetModo("SR6","SPJ",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SR6","RF8",lShowHelp) )
 		Break
 	EndIF
	IF !Empty( xFilial( "SP9" ) )
		IF !( lRetModo := xRetModo("SP9","SP4",lShowHelp) )
			Break
		EndIF
	EndIF	
	IF !( lRetModo := xRetModo("SP1","SPM",lShowHelp) )
		Break
	EndIF  
	
	IF ( GetMv( "MV_SP0SPEM" , NIL , "S" ) == "S" )
		IF !( lRetModo := xRetModo("SPE","SP0",lShowHelp) )
			Break
		EndIF
	EndIF
	IF !( lRetModo := xRetModo("SPU","SPV",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SPU","SPX",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SPY","SPZ",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("RF8","RF4",lShowHelp) )
		Break
	EndIF	
	IF !( lRetModo := xRetModo("RF4","RF3",lShowHelp) )
		Break
	EndIF		
	IF !( lRetModo := xRetModo("RF9","RF5",lShowHelp) )
		Break
	EndIF		
	IF !( lRetModo := xRetModo("RF6","RF7",lShowHelp) )
		Break
	EndIF		
	IF !( lRetModo := xRetModo("SR6","RF2",lShowHelp) )
		Break
	EndIF				                 
	IF !( lRetModo := ( __nTamP8Ordem == __nTamPGOrdem  ) )
		cMsg := STR0157	//'O Tamanho do Campo P8_ORDEM e diferente do Tamanho do Campo PG_ORDEM'
		cMsg += CRLF
		cMsg += STR0158 //'Contacte o Administrador do Sistema para compatibilizar os campos'
		Break
	EndIF
	lPonChkRel := .F.
End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Ponteiro do Mouse                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lShowHelp )
	CursorArrow()
EndIF	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se estiver Tudo Ok nao verifica Novamente					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( ( lPonChkRel := !( lRetModo ) ) .and. !Empty( cMsg ) )
	IF ( lShowHelp )
		MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0158 ) )	//  'Aten‡„o!'
	EndIF
EndIF

Return( lRetModo )

/*/Apenas para Compatibilizacao com Versoes Anterior*/
Function Classifica( aMarcacoes , aTabCalend  )       
Return( PutOrdMarc( aMarcacoes , aTabCalend ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PutOrdMarc  ³ Autor ³Marinaldo de Jesus    ³ Data ³23/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega as Ordens no Array a Marcacoes de Acordo com o  Calen³
³          ³dario de Marcacoes.                                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PutOrdMarc( @aMarcacoes , aTabCalend )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aMarcacoes -> Array com as Marcacoes do Periodo    		     ³
³          ³aTabCalend -> Calendario de Marcacoes do Periodo   		     ³
³          ³lNotFlag   -> Exclui os Flags de Marcacao forcando o Reaponta³
³          ³              mento.										 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutOrdMarc( aMarcacoes , aTabCalend , lNotFlag, lAjustMarc, dPerIni, dPerFim, cFil, cMat )

Local aJaProc		:= {} 
Local aMarNextPer   := {}
Local aTabClone		:= {}
Local aDataApo		:= {}
Local cSpaceOrd		:= Space( __nTamP8Ordem )

Local bSemOrdem
Local bNoFlag
Local cOrd 
Local dDataApo 
Local dDataAnt  := Ctod("")
Local dUltData
Local cOrdAnt	:= ""  
Local cTurnoAnt	:= ""
Local cMarc
Local cTno
Local cSpacePer
Local cPerAponta  
Local cPerAnt
Local dDataOrd	:=Ctod(Space(8))
Local nTab
Local nVezTab
Local nMar 
Local nMar1 
Local nPrimMarc
Local nMarcSemOrdem	:= 0  
Local nOrd			:= 0
Local nVezMar
Local nVezMar1
Local nSvTab
Local nQtde
Local nHours      
Local nHoursTot	:= 0      
Local nPosDt
Local nTamPer

DEFAULT lNotFlag		:= .F.   
DEFAULT lAjustMarc   	:= .F.
DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT cFil			:= SRA->RA_FILIAL
DEFAULT cMat			:= SRA->RA_MAT

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem o Tamanho do campo P8_PAPONTA						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nTamPer := GetSx3Cache( "P8_PAPONTA" , "X3_TAMANHO" )
DEFAULT nTamPer := 16
cSpacePer := Space( nTamPer )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Limpa o Flag de Marcacoes Nao Ordenadas 					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
bSemOrdem := 	{ 	|x| ;
						IF(;
								( x[AMARC_ORDEM] == "__NaoOrdenada__" ),;			//Se Marcacao nao Ordenada
									(;
										( x[AMARC_ORDEM] 		:= cSpaceOrd ),;	//Preenche a Ordem com Brancos
										( x[AMARC_APONTA]		:= "N" ),;			//Desflega Apontamento
										( x[AMARC_PERAPONTA]	:= cSpacePer ),;	//Limpa Periodo de Apontamento
										( x[AMARC_DATAAPO]	    := Ctod("") ),;		//Limpa Data de Apontamento										
									),;
								x[AMARC_PERAPONTA] := cPerAponta;					//Carrega Periodo de Apontamento
						  );
		  		} 
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Desflega  Marcacoes Apontados conforme lNotFlag			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/		  
bNoFlag :=	 { 	|x|   IF( lNotFlag , ( x[AMARC_APONTA] := "N" ) , NIL );		//Desflega Apontamento conforme lNotFlag
		 	 }

Begin Sequence

	IF ( Empty( aMarcacoes ) .or. Empty( aTabCalend ) )
		Break
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Obtem o Numero de Elementos do Calendario de Marcacoes        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nVezTab := Len( aTabCalend )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Obtem o Periodo de Apontamento Conforme Calenario de Marcacoes³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
	cUltOrdem		:= aTabCalend[ nVezTab	, CALEND_POS_ORDEM	] 
	dUltData		:= aTabCalend[ nVezTab	, CALEND_POS_DATA_APO	] 
	cPerAponta		+= Dtos( dUltData )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem o HorMais e HorMenos                                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	For nTab := 1 To nVezTab
		IF ( Empty( cOrd ) .or. ( cOrd != aTabCalend[ nTab , CALEND_POS_ORDEM ] ) )
			cOrd := aTabCalend[ nTab , CALEND_POS_ORDEM ]
		EndIF
		IF ( Empty( cTno ) .or. ( cTno != aTabCalend[ nTab , CALEND_POS_TURNO ] ) )
			cTno := aTabCalend[ nTab , CALEND_POS_TURNO ]
		EndIF	
		IF ( Empty( dDataApo) .or. ( dDataApo != aTabCalend[ nTab , CALEND_POS_DATA_APO ] ) )
			dDataApo := aTabCalend[ nTab , CALEND_POS_DATA_APO ]
		EndIF		
		IF !Empty( aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 1 ] )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se a Data de Apontamento for Diferente da Data Lida Anteriormente   ³
			³ recalcula as Horas Trabalhadas para a Data de Apontamento		      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If (dDataAnt <> dDataApo)
			  dDataAnt	:= dDataApo
			  nHours := 0 
			  aEval( aTabCalend , { |x| IF( x[CALEND_POS_DATA_APO] == dDataApo , nHours := SomaHoras( nHours , x[CALEND_POS_HRS_TRABA] ) , NIL ) }, nTab )
			Endif
			cMarc := DataHora2Str( aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 1 ] , aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 2 ] )
			aAdd( aDataApo ,  {	cOrd									,;	//01 - Ordem da Marcacao
						    	cTno									,; 	//02 - Turno da Marcacao
							    IF( Empty( nHours ) , "" , cMarc )		,; 	//03 - String para Comparacao correspondente ao HorMeno/HorMais para Dias Com Horas na Tabela
								aTabCalend[ nTab , CALEND_POS_DATA ] 	,; 	//04 - Data de Referencia da Ordem
								cMarc									,;	//05 - String para Comparacao correspondente ao HorMeno/HorMais para Marcacoes Nao Ordenadas
								dDataApo								;	//06 - Data de Apontamento da Marcacao
						      };
				 )
		EndIF	
		nHoursTot := SomaHoras( nHoursTot , aTabCalend[nTab, CALEND_POS_HRS_TRABA] ) 
	Next nTab
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Corre Todas as Marcacoes 									   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nVezMar := Len( aMarcacoes )
	nVezTab := Len( aDataApo )
	nSvTab	:= 1

	For nMar := 1 To nVezMar  
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Limpa Todas as Ordens de Marcacoes nao Infomadas/Modificadas ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	    IF !aMarcacoes[nMar, AMARC_L_ORIGEM] 
	         aMarcacoes[nMar, AMARC_ORDEM] := cSpaceOrd 
	    Endif
    	/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ordena as Marcacoes com Horario no Calendario de Marcacoes   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/   	
		IF !Empty( nHoursTot )
			IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
				cMarc	:= DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
			EndIF	
			For nTab := nSvTab To nVezTab Step 2
				IF ( ( cMarc >= aDataApo[ nTab , 3 ] ) .and. ( cMarc <= aDataApo[ nTab + 1 , 3 ] ) )
					IF !( aMarcacoes[ nMar , AMARC_L_ORIGEM ] )
						aMarcacoes[ nMar , AMARC_ORDEM ]:= aDataApo[ nTab , 1 ]
					EndIF
					aMarcacoes[ nMar , AMARC_TURNO ] 	:= aDataApo[ nTab , 2 ]
					aMarcacoes[ nMar , AMARC_DATAAPO ] 	:= aDataApo[ nTab , 6 ]					
					aMarcacoes[ nMar , AMARC_DTHR2STR ]	:= cMarc
					nSvTab := nTab
					Exit
				EndIF	
			Next nTab
		Endif
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem a Primeira Marcacao sem Ordem						   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/   	
		If Empty( nMarcSemOrdem ) 
		   If Empty( aMarcacoes[nMar, AMARC_ORDEM] )
		      nMarcSemOrdem:= nMar
		   Endif
		Endif
   		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Refaz Status da Marcacao para Reapontar ou Nao			   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		Eval(bNoFlag, aMarcacoes[nMar])
		
	Next nMar

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Ordena as Marcacoes sem Horario no Calendario de Marcacoes   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( !Empty(nMarcSemOrdem) )
	    nMar	:= nMarcSemOrdem
		For nMar := nMarcSemOrdem To nVezMar
			cOrd 		:= ""
			cTno 		:= "" 
			dDataApo	:= Ctod("")
			IF ( ( nMar := aScan( aMarcacoes , { |x| Empty( x[AMARC_ORDEM] ) } ) ) == 0 )
				Exit
			EndIF
			IF ( aScan( aJaProc , { |x| x == nMar } ) == 0 )
				aAdd( aJaProc , nMar )
			Else
				Exit
			EndIF	
			For nSvTab := nMar To nVezMar
				IF ( Empty( cOrd ) .and. ( ( nTab := aScan( aDataApo , { |x| Empty( x[3] ) .and. x[6] == aMarcacoes[ nMar , AMARC_DATAAPO ] } ) ) > 0 ) )
					IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
						cMarc := DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
					EndIF	
					cOrd  	:= aDataApo[ nTab , 01 ]
					cTno  	:= aDataApo[ nTab , 02 ] 
					dDataApo:= aDataApo[ nTab , 06 ] 
					aDataApo[ nTab , 03 ] := aDataApo[ nTab + 1 , 03 ] := cMarc
				EndIF
				IF Empty( cOrd )
					cOrd := "__NaoOrdenada__"	//Ordem Nao Encontrada
					IF ( ( nPosDt := aScan( aMarcacoes , { |x| x[ AMARC_DATA ] == aMarcacoes[ nSvTab , AMARC_DATA ] .and. !Empty( x[AMARC_ORDEM] ) } ) ) > 0 )
						IF (;
								(;
									nQtde := 0 ,;
									aEval( aMarcacoes, { |x| IF( x[AMARC_DATAAPO] == aMarcacoes[ nPosDt , AMARC_DATAAPO ] , nQtde++ , NIL ) } ),;
									( nQtde % 2 > 0 );
								 );
							 )
							cOrd 	:= aMarcacoes[ nPosDt , AMARC_ORDEM ]
							cTno 	:= aMarcacoes[ nPosDt , AMARC_TURNO ]
							dDataApo:= aMarcacoes[ nPosDt , AMARC_DATAAPO ]
						EndIF
					EndIF
				EndIF
				IF (;
						Empty( aMarcacoes[ nSvTab , AMARC_ORDEM ] ) .and.;
						(;
						 	( aMarcacoes[ nSvTab , AMARC_DATA ] == aMarcacoes[ nMar , AMARC_DATA ] ) .or.;
							(;
								nQtde := 0 ,;
								aEval( aMarcacoes, { |x| IF( x[AMARC_DATAAPO] == dDataApo , nQtde++ , NIL ) } ),;
								( nQtde % 2 > 0 );
							);
						  );
					 )
					aMarcacoes[ nSvTab , AMARC_ORDEM ] 	:= cOrd
					aMarcacoes[ nSvTab , AMARC_TURNO ] 	:= cTno
					aMarcacoes[ nSvTab , AMARC_DATAAPO] := dDataApo
				Else
					Exit
				EndIF    
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Refaz Status da Marcacao para Reapontar ou Nao			   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				Eval(bNoFlag, aMarcacoes[nMar] )
			Next nSvTab
		Next nMar
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Encaixa as Marcacoes Perdidas                                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( nMar := aScan( aMarcacoes , { |x| ( x[AMARC_ORDEM] == "__NaoOrdenada__" ) } ) ) > 0 )
			For nMar := nMar To nVezMar
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Despreza Marcacoes ja Ordenadas                              ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF !( aMarcacoes[ nMar , AMARC_ORDEM ] == "__NaoOrdenada__" )
					Loop
				EndIF
				IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
					cMarc := DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
				EndIF
				For nTab := 1 To nVezTab Step 2
					IF ( cMarc >= aDataApo[ nTab , 5 ] ) .and. ( cMarc <= aDataApo[ nTab + 1 , 5 ] )
						IF !( aMarcacoes[ nMar , AMARC_L_ORIGEM ] )
							aMarcacoes[ nMar , AMARC_ORDEM ]:= aDataApo[ nTab , 1 ]
						EndIF
						aMarcacoes[ nMar , AMARC_TURNO ] 	:= aDataApo[ nTab , 2 ]  
						aMarcacoes[ nMar , AMARC_DATAAPO ] 	:= aDataApo[ nTab , 6 ]  						
						aMarcacoes[ nMar , AMARC_DTHR2STR ]	:= cMarc
						Exit
					EndIF
				Next nTab             
 
			Next nMar
		EndIF
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Tratamento  de modo a ajustar as marcacoes de saida de jorna ³
	³ da que devido a horas extras recairam na ordem seguinte.     ³
	³ (Inicialmente para tratamento de extras em jornada continua) ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lAjustMarc
	 	/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Reordena Calendario conforme a Data de Apontamento			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSort( @aMarcacoes , NIL , NIL , { |x,y|	(Dtos(x[AMARC_DATAAPO]) + x[AMARC_DTHR2STR] );
									 				<;
									     			(Dtos(y[AMARC_DATAAPO]) + y[AMARC_DTHR2STR] );
							     		  };
	 		  )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Corre Todas as Marcacoes 									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nNumMar	:= 0
		cOrdAnt	:= "!!" 
		For nMar := 1 To nVezMar
		  	
		  	cOrd	:= aMarcacoes[ nMar , AMARC_ORDEM ] 
		  	dDataApo:= aMarcacoes[ nMar , AMARC_DATAAPO ] 
		  	//-- Se a data da primeira marcacao da Data de Apontamento for maior ou igual a data final do periodo não considera a 
		  	//-- marcacao pois provavelmente nao foram lidas todas as marcacoes do dia.
		  	If nNumMar == 0 
		  	   	dDataOrd:= aMarcacoes[nMar, AMARC_DATAAPO]
		  	   	If dDataOrd	> dPerFim
		  	   		Loop
		  	   	Endif  
		  	   	
		  	Endif
		  	
			//- Se a Data de Apontamento mudou  ou se for a Ultima Marcacao
			If ( dDataApo <> dDataAnt ) .or. ( nMar == nVezMar  .and. dDataOrd == dUltData)
			   //-- Verifica se houve marcacoes em quantidade impar  para o dia 
			   If (nNumMar % 2) > 0 .or. (  nMar == nVezMar )
			       
			       //-- Obtem as informacoes da Data de Apontamento anterior a quebra de Data de Apontamento
		           If ( nMar == nVezMar )
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Cria array com as marca‡”es do Proximo Periodo 		  	  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			            aMarNextPer	:= {}  
			            aTabClone	:= {}
						GetMarcacoes(	@aMarNextPer				,;	//01 -> Marcacoes dos Funcionarios
										@aTabClone					,;	//02 -> Calendario de Marcacoes
										NIL							,;  //03 -> Tabela Padrao
										NIL							,;  //04 -> Turnos de Trabalho  
										dPerFim+1					,;  //05 -> Periodo Inicial
										dPerFim+7					,;  //06 -> Periodo Final
										cFil						,;  //07 -> Filial
										cMat						,;  //08 -> Matricula 
										NIL							,;	//09 -> Turno
										NIL							,;	//10 -> Sequencia de Turno
										NIL							,;	//11 -> Centro de Custo
										NIL							,;	//12 -> Alias para Carga das Marcacoes
										NIL							,;	//13 -> Se carrega Recno em aMarcacoes
										NIL							,;	//14 -> Se considera Apenas Ordenadas
										NIL							,;  //15 -> Verifica as Folgas Automaticas
										NIL							,;  //16 -> Se Grava Evento de Folga Mes Anterior
										NIL							,;	//17 -> Se Carrega as Marcacoes Automaticas
										NIL							,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Deletados
										NIL							,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
										.F.							,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
										.F.							 ;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
								 	)  

						 /*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Ordena as marca‡”es                                         ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						PutOrdMarc( @aMarNextPer , aTabClone , .T. )   
				  
					    //-- Inicializa contador de quantidade de marcacoes para a ordem
				        nNumMar:= 0 
				        dDataAnt:=dDataApo  
				        nVezMar1:= Len(aMarNextPer)
					      
			            //-- Obtem as marcacoes para a primeira Data de Apontamento do periodo seguinte
			            dDataApo := Ctod("//")
			            For nMar1 := 1 To nVezMar1        
			                //-- Conta a quantidade de marcacoes para a proxima Data de Apontamento
			                If ( aMarNextPer[ nMar1 , AMARC_RECNO ] <> aMarcacoes[nMar,AMARC_RECNO])

							    If Empty(dDataApo) ///dDataApo == "!!"
			                    	dDataApo	:= aMarNextPer[ nMar1 , AMARC_DATAAPO ] 
			                    	nPrimMarc  	:= nMar1 
			                    Endif
			                    
			                	If aMarNextPer[nMar1, AMARC_DATAAPO] == dDataApo  
			                   		nNumMar++
			                	Else
			                		Exit
				                Endif
							Endif
			            Next nMar1   
			            
			            //-- Se a quantidade de marcacoes da Data de Apontamento seguinte for impar
			            //-- Ajusta a primeira marcacao da Data de Apontamento para a Data de Apontamento anterior
			            If (nNumMar % 2) > 0  
			                AADD(aMarcacoes, aClone( aMarNextPer[nPrimMarc] ) )
			                //Aeval(aMarNextPer, {|x|  AADD( aMarcacoes[ Len( aMarcacoes ) ], aClone( a ) ) } )
						    //-- Seta aMar
	                        nMar := Len(aMarcacoes)
					    Else
					    	Exit
					    Endif                  

		           Else
					    //-- Inicializa contador de quantidade de marcacoes para a Data de Apontamento
				        nNumMar:= 0  
			            For nMar1 := nMar To nVezMar        
			                //-- Conta a quantidade de marcacoes para a proxima Data de Apontamento
			                If aMarcacoes[nMar1, AMARC_DATAAPO] == dDataApo
			                   nNumMar++
			                Else
			                	  Exit
			                Endif
			            Next nMar1    
                   Endif 
                   
   			       
   			       //-- Se a quantidade de marcacoes da Data de Apontamento seguinte for impar
		           //-- Ajusta a primeira marcacao da Data de Apontamento para a ordem anterior
		           If ( (nNumMar % 2) > 0 .and. !(nNumMar == 1) )
				  	   aMarcacoes[ nMar , AMARC_ORDEM 		] := cOrdAnt
				  	   aMarcacoes[ nMar , AMARC_TURNO 		] := cTurnoAnt
					   aMarcacoes[ nMar , AMARC_DATAAPO 	] := dDataAnt				  	     
				  	   aMarcacoes[ nMar , AMARC_PERAPONTA 	] := cPerAnt
				  	   	/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Refaz Status da Marcacao para Reapontar ou Nao			   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						Eval(bNoFlag, aMarcacoes[nMar])
					    nNumMar		:= 0    			       
					    cOrdAnt		:= "!!"
						Loop
				   Endif 
			   Endif    
		       dDataAnt		:= aMarcacoes[ nMar , AMARC_DATAAPO		]  
		       cOrdAnt		:= aMarcacoes[ nMar , AMARC_ORDEM 		]   
		       cTurnoAnt	:= aMarcacoes[ nMar , AMARC_TURNO 		]   
		       cPerAnt		:= aMarcacoes[ nMar , AMARC_PERAPONTA 	]   
		        
			   nNumMar		:= 0    			       
			Endif
			
			nNumMar++
		Next nMar

    Endif
    

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Refaz Status da Marcacao em funcao de estar ou nao ordenada  ³
	³ e atualiza o periodo de apontamento						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aEval( @aMarcacoes , bSemOrdem )                               

    
End Sequence
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fTipoExtra  ³ Autor ³Marinaldo de Jesus    ³ Data ³31/03/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida os Tipos de Horas Extras                              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fTipoExtra( cTipo , @cDescr )              			 		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cTipo     -> Tipo das Horas Extras                     		 ³
³          ³cDescr 	  -> Descriacao das Horas Extras               		 ³
³          ³lShowHelp -> Mostrar o Help                            		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTipoExtra( cTipo , cDescr , lShowHelp )

Local aTipos 		:= Array( 16 , 2 )
Local lRet	 		:= .T.
Local nPos	 		:= 0

DEFAULT cTipo		:= ""
DEFAULT cDescr		:= ""
DEFAULT lShowHelp	:= .T.

aTipos[ 01 , 01 ] :=  "1" ; aTipos[ 01 , 02 ] := STR0070 //'Normal'
aTipos[ 02 , 01 ] :=  "2" ; aTipos[ 02 , 02 ] := STR0071 //'D.S.R.'
aTipos[ 03 , 01 ] :=  "3" ; aTipos[ 03 , 02 ] := STR0072 //'Compensado'
aTipos[ 04 , 01 ] :=  "4" ; aTipos[ 04 , 02 ] := STR0073 //'Feriado'
aTipos[ 05 , 01 ] :=  "5" ; aTipos[ 05 , 02 ] := STR0074 //'Normal Noturna'
aTipos[ 06 , 01 ] :=  "6" ; aTipos[ 06 , 02 ] := STR0075 //'D.S.R. Noturna'
aTipos[ 07 , 01 ] :=  "7" ; aTipos[ 07 , 02 ] := STR0076 //'Compensada Noturna'
aTipos[ 08 , 01 ] :=  "8" ; aTipos[ 08 , 02 ] := STR0077 //'Feriado Noturna'
aTipos[ 09 , 01 ] :=  "A" ; aTipos[ 09 , 02 ] := STR0078 //'Intervalo'
aTipos[ 10 , 01 ] :=  "B" ; aTipos[ 10 , 02 ] := STR0079 //'Intervalo Noturna'
aTipos[ 11 , 01 ] :=  "C" ; aTipos[ 11 , 02 ] := STR0195 //'Intervalo DSR'
aTipos[ 12 , 01 ] :=  "D" ; aTipos[ 12 , 02 ] := STR0196 //'Intervalo Noturna DSR'
aTipos[ 13 , 01 ] :=  "E" ; aTipos[ 13 , 02 ] := STR0197 //'Intervalo Compensado'
aTipos[ 14 , 01 ] :=  "F" ; aTipos[ 14 , 02 ] := STR0198 //'Intervalo Noturna Compensado'
aTipos[ 15 , 01 ] :=  "G" ; aTipos[ 15 , 02 ] := STR0199 //'Intervalo Feriado'
aTipos[ 16 , 01 ] :=  "H" ; aTipos[ 16 , 02 ] := STR0200 //'Intervalo Noturna Feriado'

IF ( lRet := ( ( nPos := aScan( aTipos , { |x| x[1] == cTipo } ) ) > 0 ) )
	cDescr := aTipos[ nPos , 2 ]
ElseIF lShowHelp
	Help(" ",1,"CTIPOHE")
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetTabArred	³ Autor ³Marinaldo de Jesus    ³ Data ³12/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega as Tabelas de Arredondamentos do SPD                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetTabArred( cFil , cTno , cTip )							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cFil -> Filial Para a Pesquisa no SP5              		     ³
³          ³cTno -> Turno  Para a Pesquisa no SP5              		     ³
³          ³cTip -> Tipo do Arredondamento a Ser Carregado     		     ³
³          ³        "A" -> Atrasos                             		     ³
³          ³        "D" -> DSR                                 		     ³
³          ³        "F" -> Faltas                              		     ³
³          ³        "H" -> Horas Extras                        		     ³
³          ³        "N" -> Horas Noturnas                      		     ³
³          ³        "S" -> Saidas Antecipadas                  		     ³
³          ³        "9" -> Nona Hora                           		     ³
³          ³lFullTable -> .T. -> Carrega toda a tabela de Arredondamento ³
³          ³               para a Filial informada  	       		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aCloneTabArr <=> Array Contendo as Tabelas de Arredondamentos³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTabArred( cFil , cTno , cTip, lFullTable )

Local bAscan		:= { || .T. }
Local cKey			:= ""
Local cKeyPesq		:= ""
Local cLenTno		:= ""
Local cTipo			:= ""
Local cAlias		:= "SPD"
Local cAliasQuery	:= cAlias
Local cChave		:= ""
Local lTnoOrFil		:= .T.
Local lAtu			:= .T.    
Local lQueryOpened	:= .F.
Local nArreds		:= 0
Local nTabs			:= 0
Local nPos			:= 0
Local nOrder		:= RetOrdem( "SPD" , "PD_FILIAL+PD_TIPO+PD_TURNO" )
Local nSvOrder		:= SPD->( IndexOrd() ) 

#IFDEF TOP
	Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
	Local cQuery		:= ""
	Local cSvQuery		:= ""
	Local cSvAlias		:= Alias()
	Local nX			:= 0

	Static aSpdFields
	Static cQrySpdFields
	Static nSpdFields
#ENDIF

DEFAULT cTip		:= "ADFHNS9"
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT lFullTable	:= .F.  

#IFDEF TOP

	IF !( lExInAs400 )

		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

		DEFAULT aSpdFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpdFields := Len( aSpdFields )
	
		IF ( cQrySpdFields == NIL )
			cQrySpdFields := ""
			For nX := 1 To nSpdFields
				cQrySpdFields += aSpdFields[ nX , 01 ] + ", "
			Next nX
		EndIF
		
	EndIF

#ENDIF
                               
cLenTno		:= Space( GetSx3Cache( "PD_TURNO  " , "X3_TAMANHO" ) ) 
cTip		:= StrTran( cTip , " " , "" )
cTipo		:= cTip
cFil		:= xFilial( cAlias , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta Bloco para Pesquisa dos Tipos de Arredondamento.       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
baScan		:= { |x| If(  !lFullTable,;
										 ( ( x[1] == cFil ) .or. Empty( x[1] ) )   	;
									  	  .and.								 	   		;
									     ( ( x[2] == cTno ) .or. Empty( x[2] ) )   	;
									     .and.								 	   		;
									     ( x[3] == cTipo ) 						   		,;
								     	 ( ( x[1] == cFil ) .or. Empty( x[1] ) )   	;
						) ;		     	 
		   		}



DEFAULT	__aTabArr	:= {}
DEFAULT	__aTabFilArr:= {}


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se foi Selecionado apenas um Determinado Tipo                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !lFullTable 
	IF ( nTabs := Len( cTipo ) ) == 1
		IF !Empty( __aTabArr )
			lAtu := ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 .or. ( nPos > 0 .and. Empty( __aTabArr[nPos , 2] ) ) )
		EndIF
	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Caso contrario Considera Todos os Tipos Validos              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cTip := "ADFHNS9"
	EndIF
Else           
    /*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Forca Carregar Todas as Tabelas de Arredondamento da Filial  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !Empty( __aTabArr )
			lAtu 	:= ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0  )  
	Endif		
	nTabs	:= 1 
	cTip 	:= "ADFHNS9" 
	cTno	:=  cLenTno  
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se a Tabela de Arredondamento Estiver Vazia ou se for forcada³
³ uma Atualizacao											   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( Empty( __aTabArr ) .or. ( lAtu ) )
	
	IF !Empty( nTabs )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Seta a Ordem para Pesquisa                                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !( nSvOrder == nOrder )
			SPD->( dbSetOrder( nOrder ) )
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica os Tipos de Arredondamento                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		For nArreds := 1 To nTabs
		    
		

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica se o Tipo em Questao ja foi Carregado e se possui con³
			³teudo														   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
			IF !lFullTable 
				cTipo := SubStr( cTip , nArreds , 1 )
				lAtu:= ( ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 )  .or. ( nPos > 0 .and. Empty( __aTabArr[nPos , 2] ) ) )
			Else	                                 
				cTipo := SPACE(1)
				lAtu:= ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 )
			Endif
			
			If 	lAtu
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Se For TOP						                               ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				#IFDEF TOP
					IF !( lExInAs400 )
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Monta Query para pesquisa do Turno Especifico                 ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						cQuery		:= "SELECT "
						cQuery		+= cQrySpdFields
						cQuery		:= SubStr( cQuery , 1 , Len( cQuery ) - 2 )
						cQuery		+= " FROM "
						cQuery		+= InitSqlName( cAlias )
						cQuery		+= " WHERE "
						cQuery		+= cPrefixo+"FILIAL='"+cFil+"'"
						cQuery		+= " AND " 
						If !lFullTable
							cQuery		+= cPrefixo+"TIPO='"+cTipo+"'"
							cQuery		+= " AND "
							cQuery		+= cPrefixo+"TURNO='"+cTno+"'"
							cQuery		+= " AND "
						Endif	
						cQuery		+= "D_E_L_E_T_=' ' "
						cQuery		+= "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
						cSvQuery	:= cQuery
						cQuery		:= ChangeQuery( cQuery )
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Verifica se conseguiu Montar a Query                          ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
							For nX := 1 To nSpdFields
								IF !( aSpdFields[ nX , 02 ] == "C" )
									TcSetField(cAliasQuery,aSpdFields[nX,01],aSpdFields[nX,02],aSpdFields[nX,03],aSpdFields[nX,04])
								EndIF
							Next nX
							
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Se nao achou o Turno Especifico	                           ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							lTnoOrFil := ( cAliasQuery )->( !Eof() )  
							
							IF !( lTnoOrFil )
								( cAliasQuery )->( dbCloseArea() )	
								IF !lFullTable
									/*/
									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									³Monta Query para pesquisa do Turno Generico ( Em Branco )     ³
									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
									cQuery := StrTran( cSvQuery , ( "TURNO='"+cTno+"'" ) , ( "TURNO='"+cLenTno+"'" ) )
									cQuery := ChangeQuery( cQuery )
									/*/
									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									³Verifica se conseguiu Montar a Query para o Turno Generico    ³
									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
									IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
										For nX := 1 To nSpdFields
											IF !( aSpdFields[ nX , 02 ] == "C" )
												TcSetField(cAliasQuery,aSpdFields[nX,01],aSpdFields[nX,02],aSpdFields[nX,03],aSpdFields[nX,04])
											EndIF
										Next nX
										/*/
										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										³Se nao Existia o Tipo para o Turno Generico (Em Branco)       ³
										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
										IF ( nPos == 0 )
											/*/
											ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											³Pesquisa o Turno Generico ( Em Branco )                       ³
											ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
											IF ( cAliasQuery )->( Eof() )
												/*/
												ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
												³Se nao Encontrou o Turno Generico, carrega Tabela Vazia       ³
												ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
												aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
												( cAliasQuery )->( dbCloseArea() )
												Loop
											EndIF
										EndIF
									Else
										/*/
										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										³Caso contrario Pesquisa Direto no Arquivo                     ³
										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
										cAliasQuery := cAlias
									EndIF
								Else
									/*/
									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									³Se nao Existia o Tipo para o Turno Generico (Em Branco)       ³
									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
									IF ( nPos == 0 )
										/*/
										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										³Se nao Encontrou a Filial, carrega Tabela Vazia       		   ³
										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
										aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
										Loop                                                                       
									Endif	
								Endif	
							Endif	
						Else
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Caso contrario Pesquisa Direto no Arquivo                     ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							cAliasQuery := cAlias
						EndIF
					EndIF
				#ENDIF

				IF !( lQueryOpened )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Procura pelo Turno Especifico	 		                       ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
					IF !lFullTable
						cKeyPesq 	:=  cFil + cTipo + cTno 
					Else                                       
						cKeyPesq 	:=  cFil 
					Endif
					
					lTnoOrFil := ( cAliasQuery )->( dbSeek( cKeyPesq ) ) 

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se nao Existe o Turno Especifico procura pelo Generico        ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
					IF !( lTnoOrFil )
						IF !lFullTable
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Se nao Existia o Tipo para o Turno Generico (Em Branco)       ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							IF ( nPos == 0 )
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Pesquisa o Turno Generico ( Em Branco )                       ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								IF ( cAliasQuery )->( !dbSeek( cFil + cTipo + cLenTno ) )
									/*/
									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									³Se nao Encontrou o Turno Generico, carrega Tabela Vazia       ³
									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
									aAdd( __aTabArr , ( cAliasQuery )->( { cFil , PD_TURNO , PD_TIPO , {} } ) )
									Loop
								EndIF
							Endif	
						Else
							If ( nPos == 0 )
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Se nao Encontrou a Filial, carrega Tabela Vazia       		   ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
								Loop
							Endif	
						EndIF
					Endif	
                EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se Encontrou o Turno e Este ainda nao Esta Carregado         ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( ( lTnoOrFil ) .or. ( nPos == 0 ) )
				
					If !lFullTable
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Carrega as Informacoes para o Turno						   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						aAdd( __aTabArr , { cFil , IF( lTnoOrFil , cTno , cLenTno ) , cTipo , {} } )
						nPos := Len( __aTabArr )
	
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Carrega os Itens para o Turno      						   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						cKey := ( cFil + cTipo + IF( lTnoOrFil , cTno , cLenTno ) )
						While ( cAliasQuery )->( !Eof() .and. PD_FILIAL+PD_TIPO+PD_TURNO == cKey )
						    ( cAliasQuery )->( aAdd( __aTabArr[ nPos , 4 ] , { PD_DE , PD_ATE , PD_HORAS } ) )
							( cAliasQuery )->( dbSkip() )
						End While
                    Else 
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Carrega todos Itens para Filial      						   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
						cKey:= ""
						While ( cAliasQuery )->( !Eof() .and. ( PD_FILIAL == cFil ) )
							If ( cKey <> ( cAliasQuery )->( cFil + PD_TIPO + PD_TURNO )  )
							     cKey := ( cAliasQuery )->( cFil + PD_TIPO + PD_TURNO )  
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Carrega as Informacoes para a Filial + Tipo + Turno		   ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								aAdd( __aTabArr , ( cAliasQuery )->( { cFil , PD_TURNO , PD_TIPO , {} } ) )
								nPos := Len( __aTabArr )								
							Endif	                    
					    	( cAliasQuery )->( aAdd( __aTabArr[ nPos , 4 ] , { PD_DE , PD_ATE , PD_HORAS } ) )
							( cAliasQuery )->( dbSkip() )
						End While
                    Endif
				EndIF

				#IFDEF TOP
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se Montou a Query, Fecha-a                                    ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
						( cAliasQuery )->( dbCloseArea() )
					EndIF
				#ENDIF
				
			EndIF
	
		Next nArreds

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Restaura a Ordem de Entrada         					   	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !( nSvOrder == nOrder )
			SPD->( dbSetOrder( nSvOrder ) )
		EndIF

	Else

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Neste Caso nao Foi passado Nenhum Tipo de Arredondamento 	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aAdd( __aTabArr , { "" , "" , "" , {} } )

	EndIF
	
EndIF

#IFDEF TOP
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Garante o Fechamento da Query no retorno da funcao           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( Select( cAliasQuery ) > 0 )
		( cAliasQuery )->( dbCloseArea() )
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Restaura dados de Entrada                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( Select( cSvAlias ) > 0 )
		dbSelectArea( cSvAlias )
	EndIF
#EndIF
	
Return( aClone( __aTabArr ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstGetTabArred	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em GetTabArred()       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstGetTabArred() 
__aTabArr 		:= 	NIL 
__aTabFilArr	:=  NIL
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetTabArred	³ Autor ³Marinaldo de Jesus    ³ Data ³10/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Tabela de Arredondamento Especifica baseada no  Array³
³          ³Carregado Atraves de GetTabArred()							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RetTabArred( aArreds , cFil , cTno , cTip )					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aArreds -> Array com todos as Tabelas de Arredondamentos	 ³
³          ³cFil 	-> Filial para Procura								 ³
³          ³cTno	-> Turno  Para a Pesquisa no SP5              		 ³
³          ³cTipo	-> Tipo do Arredondamento a Ser Carregado     		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aArred  -> Tabela com Arredondamento Especifico				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RetTabArred( aArreds , cFil , cTno , cTipo )

Local aArred := {}
Local bAscan := { || .T. }
Local nPosAr := 0

baScan	:= { |x| ( ( x[1] == cFil ) .or. Empty( x[1] ) ) ;
			  	 .and.								 	 ;
			      ( x[2] == cTno )						 ;
			     .and.								 	 ;
			     ( x[3] == cTipo )						 ;
			}

IF ( ( nPosAr := aScan( aArreds , bAscan ) ) == 0 )
	baScan	:= { |x| ( ( x[1] == cFil ) .or. Empty( x[1] ) ) ;
				  	 .and.								 	 ;
				     Empty( x[2] )							 ;
				     .and.								 	 ;
			    	 ( x[3] == cTipo )						 ;
				}
	nPosAr := aScan( aArreds , bAscan )
EndIF

IF ( nPosAr > 0 )
	aArred := aClone( aArreds[ nPosAr , 4 ] )
EndIF

Return( aClone( aArred ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fArredHoras	³ Autor ³Marinaldo de Jesus    ³ Data ³12/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Efetua o Arredondamento de Horas de Acordo com o Array       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nHrs   -> Horas Arredondadas                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fArredHoras(	nHrs		,;	//01 -> Horas a Serem Arredondadas
						aArrs		,;	//02 -> Array com os Arredondamentos
						cTip		,;	//03 ->	Tipo de Horas a Arredondar:"A"trasos ; "D"SR ; "F"altas ; "H"oras Extras ; "N"Horas Noturnas ; "S"aidas Antecipadas
						cFil		,;	//04 -> Filial Para a Pesquisa no SP5
						cTno		,;	//05 -> Turno  Para a Pesquisa no SP5
						lArrdIntegr	 ;	//06 -> Se Arredonda as Horas Integralmente	
					 )
                                                          
Local nArrVal		:= 0
Local nArre			:= 0
Local nLenArre		:= 0

DEFAULT nHrs		:= 0
DEFAULT aArrs		:= {}
DEFAULT cTip		:= ""
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT lArrdIntegr	:= .F.

IF ( !Empty( cTip ) .and. Empty( aArrs ) )
	aArrs := ( GetTabArred( cTip , cFil , cTno  )[ 1 , 3 ] )
EndIF

nLenArre := Len( aArrs )
For nArre := 1 To nLenArre
	nArrVal := IF( !( lArrdIntegr ) , SubHoras( nHrs , __NoRound( nHrs , 0 ) ) , nHrs )
	IF (;
			( __NoRound( nArrVal , 2 ) >= __NoRound( aArrs[ nArre , 1 ] , 2 ) );
			.and.;
  	   		( __NoRound( nArrVal , 2 ) <= __NoRound( aArrs[ nArre , 2 ] , 2 ) );
  	   	)	
		IF !( lArrdIntegr )
			nHrs := SomaHoras( __NoRound( nHrs , 0 ) , aArrs[ nArre , 3 ] )
		Else
			nHrs := aArrs[ nArre , 3 ]
		EndIF
		Exit
	EndIF
Next nArre

Return( nHrs )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetTabExtra	³ Autor ³Marinaldo de Jesus    ³ Data ³16/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega Array com os Tipos de Horas Extras                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet      -> True se Conseguir Carregar os Tipos de H.E.     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTabExtra(	aTabExtra		,;	//01 -> Array a ser Carregado com os Tipos de H.E.
						cFil			,;	//02 -> Filial para Pesquisa no SP4
						cTno			,;	//03 -> Turno para Pesquisa no SP4
						lTodas			,;	//04 -> Atualizar as Tabelas de Horas Extras
						lShowHelp		,;	//05 -> Mostrar o Help
						lEscalonar		,;	//06 -> Se trata o escalonamento
						nErrorNumber	,;	//07 -> Numero de retorno de erro. 1 - Tabela de HE nao encontrada 2 - Tabela de HE nao configurada corretamente
						cHelp			 ;	//08 -> Mensagem Complementar ao Help ( Retorno por Referencia )
					 )

Local aEscala		:= {}
Local baScan		:= { || .T. }
Local cAlias		:= "SP4"
Local cAliasQuery	:= cAlias
Local lRet			:= .F.
Local lModFil		:= .F. 
Local lQueryOpened	:= .F.
Local nPos			:= 0
Local nOrder		:= RetOrdem( "SP4" , "P4_FILIAL+P4_TURNO+P4_TIPO" )
Local nSvOrder		:= SP4->( IndexOrd() ) 

#IFDEF TOP
	Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
	Local cQuery		:= ""
	Local cSvQuery		:= ""
	Local cSvTno		:= ""	
	Local cSvAlias		:= Alias()
	Local nX			:= 0

	Static aSp4Fields
	Static cQrySp4Fields
	Static nSp4Fields
#ENDIF

DEFAULT cFil			:= SRA->RA_FILIAL
DEFAULT cTno			:= SRA->RA_TNOTRAB
DEFAULT nErrorNumber	:= 0   
DEFAULT lTodas			:= .F.
DEFAULT lShowHelp		:= .F.
DEFAULT __aTabEx		:= {}

#IFDEF TOP

	IF !( lExInAs400 )
	
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

		DEFAULT aSp4Fields := ( cAlias )->( dbStruct() )
		DEFAULT nSp4Fields := Len( aSp4Fields )

		IF ( cQrySp4Fields == NIL )
			cQrySp4Fields := ""
			For nX := 1 To nSp4Fields
				cQrySp4Fields += aSp4Fields[ nX , 01 ] + ", "
			Next nX
		EndIF
		
	EndIF		

#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se o parametro de escalonamento foi passado				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !( lEscalonar == NIL )
   __lEscalonamento	:= lEscalonar
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se eh a primeira vez ou ocorreu quebra de filial E NAO    foi³
	³para escalonar Obtem o parametro de escalonamento			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lModFil := ( ( cFilStatic == NIL )  .or. ( cFilStatic != cFil    ) ) )
		__lEscalonamento	:=	NIL
		cFilStatic			:= 	cFil
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Considerar Todas as Horas Extras do Dia Para o Escalonamento ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    	DEFAULTFIL __lEscalonamento := ( SuperGetMv("MV_ACMHEXT",,"N",cFil) == "S" )      	
	EndIF
EndIF

aTabExtra	:= {}
baScan		:= { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
					  .and.									;
					 ( x[2] == cTno .or. Empty( x[2] ) )    ;
			   }

cFil := xFilial( cAlias , cFil )

IF ( Empty( __aTabEx ) .or. ( !lTodas .and. ( nPos := aScan( __aTabEx , baScan ) ) == 0 .or. ( nPos > 0 .and. Empty( __aTabEx[ nPos , 2 ] ) ) ) )


	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nOrder ) )
	EndIF

	#IFDEF TOP
		IF !( lExInAs400 )
			cQuery := "SELECT "
			cQuery += cQrySp4Fields
			cQuery := SubStr( cQuery , 1 , Len( cQuery ) - 2 )
			cQuery += " FROM "
			cQuery += InitSqlName( cAlias )
			cQuery += " WHERE "
			cQuery += cPrefixo+"FILIAL='"+cFil+"'"
			cQuery += " AND "
			IF !( lTodas )
				cQuery += cPrefixo+"TURNO='"+cTno+"'"
				cQuery += " AND "
				cSvTno := cTno
			EndIF
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cSvQuery	:= cQuery
			cQuery		:= ChangeQuery( cQuery )
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nSp4Fields
					IF !( aSp4Fields[ nX , 02 ] == "C" )
						TcSetField(cAliasQuery,aSp4Fields[nX,01],aSp4Fields[nX,02],aSp4Fields[nX,03],aSp4Fields[nX,04])
					EndIF
				Next nX
				IF !( lRet := ( cAliasQuery )->( !Eof() ) )
					IF !( lTodas )
						( cAliasQuery )->( dbCloseArea() )
						cTno	:= Space( GetSx3Cache( "P4_TURNO  " , "X3_TAMANHO" ) )
						cQuery	:= StrTran( cSvQuery , ( "TURNO='"+cSvTno+"'" ) , ( "TURNO='"+cTno+"'" ) )
						cQuery	:= ChangeQuery( cQuery )
						IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
							For nX := 1 To nSp4Fields
								IF !( aSp4Fields[ nX , 02 ] == "C" )
									TcSetField(cAliasQuery,aSp4Fields[nX,01],aSp4Fields[nX,02],aSp4Fields[nX,03],aSp4Fields[nX,04])
								EndIF
							Next nX 
							IF ( nPos == 0 )
								IF !( lRet := ( cAliasQuery )->( !Eof() ) )
									( cAliasQuery )->( dbCloseArea() )
								EndIF
							EndIF
						EndIF
					EndIF
				EndIF
	        EndIF
		EndIF	        
	#ENDIF
	
	IF !( lQueryOpened )
	
		cAliasQuery := cAlias
		IF ( lTodas )
			lRet := ( cAliasQuery )->( dbSeek( cFil , .F. ) )
		Else
			IF !( lRet := ( cAliasQuery )->( dbSeek( cFil + cTno ) ) )
				IF ( nPos == 0 )
					lRet := ( cAliasQuery )->( dbSeek( cFil + ( cTno := Space( GetSx3Cache( "P4_TURNO  " , "X3_TAMANHO" ) ) ) ) )
				EndIF
			EndIF
		EndIF
	
	EndIF

	IF ( ( lRet ) .and. ( Select( cAliasQuery ) > 0 ) )
		aAdd( __aTabEx , { cFil , IF( lTodas , "TODAS" , cTno ) , {} } )
		While ( cAliasQuery )->( !Eof() .and. cFil == P4_FILIAL .and. IF( lTodas , lTodas , cTno == P4_TURNO ) )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Adiciona a Informacao da Tabela de Hora Extras em Array  auxi³
			³liar para verificar consistencia da mesma para uso do  escalo³
			³namento de horas											  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			( cAliasQuery )->( aAdd( aEscala , { P4_TIPO , P4_DE , P4_ATE ,P4_CODAUT , P4_CODNAUT }  ) )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Carrega a Tabela de Horas Extras							  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			( cAliasQuery )->( aAdd( __aTabEx[ Len( __aTabEx ) , 3 ] , { P4_TIPO , P4_DE , P4_ATE ,P4_CODAUT , P4_CODNAUT } ) )
			( cAliasQuery )->( dbSkip() )
		End While

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se foi solicitada a interrupcao do processamento ao   ocorrer³
		³alguma inconsistencia, procedemos com a verificacao da  incon³
		³sistencia para efeito de escalonamento					      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lShowHelp .and. __lEscalonamento )
			IF !( lRet := fVerEscala( aEscala ) )
        		cHelp			:= STR0155	//-- "Tabela de Horas Extras Nao Configurada para Escalonamento"
        		nErrorNumber	:= 2.00		//-- Retorno de erro para a funcao chamadora
	   		EndIF
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se Estiver Ok Monta a Tabela de Horas Extras				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lRet )
			IF !( lTodas ) 
				baScan := { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
						  		.and.								;
						 		( x[2] == cTno )					;
				   		  }
				IF ( ( nPos := aScan( __aTabEx , baScan ) ) == 0 )
					baScan := { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
							  		.and.								;
							 		Empty( x[2] )						;
					   		  }
					nPos := aScan( __aTabEx , baScan )
					
				EndIF		
			EndIF
		EndIF
	EndIF

	#IFDEF TOP
		IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
			( cAliasQuery )->( dbCloseArea() )
		EndIF	
	#EndIF

	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nSvOrder ) )
	EndIF

EndIF

IF ( lTodas .and. ( lRet := !Empty( __aTabEx ) ) )
	aEval( __aTabEx , { |x,y| IF( __aTabEx[y,1] == cFil , aAdd( aTabExtra , aClone( __aTabEx[y,3] ) ) , NIL ) } )
ElseIF ( lRet := ( nPos > 0 ) )
	aTabExtra := aClone( __aTabEx[ nPos , 3 ] )
EndIF

IF ( ( lShowHelp ) .and. !( lRet ) )
    IF !Empty( cHelp )
		HELP(" ",1,"TABHENCAD", , OemToAnsi( cHelp ) , 5 , 0 ) 
	Else
		HELP(" ",1,"TABHENCAD" )
	EndIF
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Fornece o numero de erro ao executar a funcao  ( considerando³
³que nao ocorreu algum ainda) se nao foi encontrada a   tabela³
³de He para a chave de pesquisa (filial e/ou turno).		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF Empty(nErrorNumber)
   nErrorNumber := IF( !( lRet ) , 1 , 0 )
EndIF

#IFDEF TOP
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Garante o Fechamento da Query no retorno da funcao           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( Select( cAliasQuery ) > 0 )
		( cAliasQuery )->( dbCloseArea() )
	EndIF	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Restaura dados de Entrada                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( Select( cSvAlias ) > 0 )
		dbSelectArea( cSvAlias )
	EndIF
#EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstGetTabExtra	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em GetTabExtra()		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstGetTabExtra()

__aTabEx			:= NIL
__lEscalonamento	:= NIL	
cFilStatic			:= NIL

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fTpoExtra   ³ Autor ³Marinaldo de Jesus   ³ Data ³28/09/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Tipo de Horas Extras de Acordo com o Dia          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Tipo de Hora Extra                                    	    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Apontamento                                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTpoExtra(	dData		,;	//Data para pesquisa do Tipo de Hora Extra
					aTabClone	,;	//Copia do Array com o Calendario de Marcacoes
					nPosCalend	 ;	//Indice em aTabCalend
				  )

Local aSvTabsCal
Local cTpExtra
Local nPos

DEFAULT dData		:= Ctod("//")
DEFAULT aTabClone	:= {}
DEFAULT nPosCalend	:= 0

Begin Sequence

	IF !Empty( aTabClone ) .and. IF( Empty( nPosCalend ) , ( nPos := aScan( aTabClone, { |x| x[ CALEND_POS_DATA ] == dData .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } ) ) > 0 ,( nPos:= nPosCalend, .T. ) )
		nPosCalend := nPos
	Else
		aTabClone	:= {}
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSvTabsCal	:= GetTabCal()
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Cria o Calendario para a Data                   			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( SRA->( CriaCalend(	dData		,;	//01 -> Data Inicial do Periodo
								dData		,;	//02 -> Data Final do Periodo
								RA_TNOTRAB	,;	//03 -> Turno Para a Montagem do Calendario
								RA_SEQTURN	,;	//04 -> Sequencia Inicial para a Montagem Calendario
								aTabPadrao	,;	//05 -> Array Tabela de Horario Padrao
								@aTabClone	,;	//06 -> Array com o Calendario de Marcacoes
								RA_FILIAL	,;	//07 -> Filial para a Montagem da Tabela de Horario
								RA_MAT		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								RA_CC		,;	//09 -> Centro de Custo para a Montagem da Tabela
								NIL    		,;	//10 -> Array com as Trocas de Turno
								NIL     	,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL         ,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL      	 ;	//14 -> Se Forca a Criacao de Novo Calendario
							 );
					);
			)
			IF ( ( nPos := aScan( aTabClone, { |x| x[ CALEND_POS_DATA ] == dData .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } ) ) > 0 )
				nPosCalend := nPos
			EndIF
		EndIF
	EndIF
	
	IF ( nPosCalend > 0 )
		IF ( aTabClone[ nPosCalend , CALEND_POS_APON_FERIAS ] )
			cTpExtra := aTabClone[nPosCalend,CALEND_POS_TP_HE_NT_FER]+"-"+aTabClone[nPosCalend,CALEND_POS_TP_HE_NR_FER]
		Else
			IF ( aTabClone[ nPosCalend , CALEND_POS_FERIADO ] )				//Dia Corresponde a Feriado
				IF ( aTabClone[ nPosCalend , CALEND_POS_EXCECAO ] == "E" )	//Dia Corresponde a Excecao em Feriado
					cTpExtra := aTabClone[nPosCalend,CALEND_POS_TIPO_HE_NOT]+"-"+aTabClone[nPosCalend,CALEND_POS_TIPO_HE_NOR]
				Else
					IF !( aTabClone[ nPosCalend , CALEND_POS_TRAB_FERIADO ] )	//Se nao Trabalha em Feriado
						cTpExtra	:= IF(Empty(aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NT ]),"8",aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NT ])
						cTpExtra	+= "-"
						cTpExtra	+= IF(Empty(aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NR ]),"4",aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NR ])
					Else                        //Trabalha em Feriado
						cTpExtra := aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOT ] + "-" + aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOR ]
					EndIF
				EndIF
			Else
				cTpExtra := aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOT ]+"-"+aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOR ]
			EndIF
		EndIF
	EndIF

End Sequence
	
cTpExtra := IF( Empty( cTpExtra ) , "5-1" , cTpExtra ) //DEFAULT

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Conteudo do Calendario por Turno        		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( aSvTabsCal <> NIL )
	SetTabCal( aSvTabsCal )
EndIF

Return( cTpExtra )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fVerEscala	³ Autor ³Mauricio MR           ³ Data ³12/11/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Consiste a Tabela de HE para uso com Escalonamento de Horas  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fVerEscala( aTabHE )									     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTabHE   -> Array de um Turno/Filial a Ser Consistido.		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet     -> True se OK ou .F. se houver inconsistencia       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Funcao GetTabExtra()                                         ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fVerEscala(aTabHE)  

Local aCompara	:= {'1-5','2-6','3-7','4-8','A-B','C-D','E-F','G-H'}  
Local aDiurno	:= {}
Local aNoturno	:= {}
Local cTipo		:= ''
Local cTipoPar	:= ''
Local lRet		:= .T.
Local nLenaTab  := Len(aTabHE)     
Local cTipoAnt	:= ''
Local nDiurno	:= 0
Local nNoturno	:= 0
Local nPos		:= 0
Local nFaixas	:= 0

//-- Percorre todos os tipos de HE
For nFaixas := 1 To nLenaTab
       
    //-- Para cada Tipo lido procura o seu Tipo "Noturno" correspondente     
    cTipo:=aTabHE[nFaixas, 1] 
    
    //-- Despreza Faixas de Tipos ja lidos e Despreza noturnos
    If  (cTipoAnt == cTipo) .OR. (cTipo >'4' .AND. !(cTipo $'ACEG'))
       Loop
    Endif
  
    //-- Se nao encontrou o correspondente Noturno
    If Empty( nPos:= Ascan( aCompara, {|cPar| cTipo == Substr(cPar,1,1) } ) )
       //-- Obtem o proximo
       Loop
    Endif      

    //-- Extrai o noturno correspondente
    cTipoPar:=Substr(aCompara[nPos],-1,1)
    
    //-- Iguala variavel auxiliar que mantera o ultimo tipo lido para evitar processamento desnecessario
    cTipoAnt:=cTipo

    //-- Monta array com as faixas do tipo diurno     
    aDiurno:={}
    nDiurno:=0  
    aEval(aTabHE,{|aTipo| If( aTipo[1] == cTipo, (nDiurno++, aAdd( aDiurno, aTipo )) , Nil ) })
     
    //-- Monta array com as faixas do tipo noturno correspondente
    aNoturno:= {}  
    nNoturno:= 0
    aEval(aTabHE,{|aTipo| If( aTipo[1] == cTipoPar,(nNoturno++, aAdd( aNoturno, aTipo )) , Nil ) })
    
    //-- Verificar se qtde de faixas de valores diurnas e noturnas diferem entre si
    If nDiurno <> nNoturno
       lRet:=.F.
       Exit
    Endif   
                                 
    //-- Percorre Cada uma das faixas do Noturno correspondente
    nPos:=nDiurno
    Do While nPos >0                                          
       //-- Verifica Se existem diferenca entre os Limites Inicial e final em cada faixas correspondente
       If aDiurno[nPos,2] <> aNoturno[nPos,2] .OR. aDiurno[nPos,3] <> aNoturno[nPos,3]
          lRet:=.F.
          Exit
       Endif   
       nPos--
    End While
    
    //-- Se houve diferenca de faixas abandona rotina
    IF ! lRet
       Exit
    Endif
Next nFaixas

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fFeriado() ³ Autor ³ Marinaldo de Jesus   ³ Data ³01/06/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Verifica se a Data passada eh ou nao um Feriado            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ fFeriado( cFil, dDate, cDesc, cTipo, cTipCod )			    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ SIGAPON                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ lRet <=> True se Data Feriado, False se n„o                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cFil  = Variavel com a Filial do Funcionario.              ³
³          ³ dDate = Data a Ser Verificada no SP3                       ³
³          ³ cDesc = Descricao do Feriado                               ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
Function fFeriado( cFil, dDate, cDesc, cTipo, cTipCod )

Local aArea		:= GetArea()
Local aSP3Area	:= SP3->( GetArea() )
Local cMesDia	:= ""
Local cAno		:= ""
Local lFeriado	:= .F.
Local cMyChave	:= ""
Local nPosFer	:= 0
Local nOrderDt	:= 0
Local nOrderMd	:= 0
Local nMyRecno	:= 0
Local lMyCnt	:= .T.

Local cAlias	:= "SP3"
Local cQuery	:= ""
Local cGcGrpE	:= FwCompany()
Local cGcUneg	:= FwUnitBusiness()
Local cGcFil	:= FwFilial()

DEFAULT __aFeriadoStatic	:= {}
DEFAULT cFil				:= xFilial( "SP3" )
DEFAULT dDate				:= dDataBase
DEFAULT cDesc				:= ""
DEFAULT cTipo				:= ""
DEFAULT cTipCod				:= ""

lGestaoCorp := Iif( FWSizeFilial() > 2, .T., .F.)	//-Indica se esta configurado como Gestao Corporativa na P11
lNewFields  := Iif( SP3->( Type("P3_GCGRPE")#"U" .And. Type("P3_GCUNEG")#"U" .And. Type("P3_GCFIL")#"U" ), .T., .F.)	//-Indica se foram criados os campos novos do SP3

dbSelectArea("SQB")
dbSetOrder(4)	//-QB_FILIAL+QB_CC+QB_DEPTO
dbSelectArea("SP3")

If lGestaoCorp .And. lNewFields
	
	cMyChave	:= (fAjusTam(cGcGrpE,SP3->P3_GCGRPE) + fAjusTam(cGcUneg,SP3->P3_GCUNEG)+ fAjusTam(cGcFil,SP3->P3_GCFIL)) + DtoS(dDate) + cTipo + cTipCod
	nOrderDt	:= RetOrdem( "SP3" , "P3_GCGRPE+P3_GCUNEG+P3_GCFIL+DTOS(P3_DATA)+P3_TIPO+P3_TIPCOD" )
	nPosFer		:= aScan( __aFeriadoStatic , { |x| x[01]+DtoS(x[02])+x[06]+x[07] == cMyChave } )
	
	dbSetOrder( nOrderDt )
	
	cAlias := "QSP3"
	cQuery := "SELECT DISTINCT RA_FILIAL,RA_MAT,RA_CC,RA_DEPTO,QB_CESTAB,P3.* "
	cQuery += "FROM "+RetSqlName("SRA")+" RA "
	
	cQuery += "INNER JOIN "+RetSqlName("SQB")+" QB ON "
	If TcSrvType() == "AS/400"
		cQuery += "QB.@DELETED@ = ' ' "
	Else
		cQuery += "QB.D_E_L_E_T_ = ' ' "
	Endif 
	cQuery += "AND QB_DEPTO=RA_DEPTO "
	
	cQuery += "INNER JOIN "+RetSqlName("SP3")+" P3 ON "
	If TcSrvType() == "AS/400"
		cQuery += "P3.@DELETED@ = ' ' "
	Else
		cQuery += "P3.D_E_L_E_T_ = ' ' "
	Endif 
	cQuery += "AND P3_DATA='"+DTOS(dDate)+"' "
	cQuery += "AND ( (P3_GCGRPE='"+fAjusTam(cGcGrpE,SP3->P3_GCGRPE)+"' OR P3_GCGRPE='"+fAjusTam(" ",SP3->P3_GCGRPE)+"') "
	cQuery += "  AND (P3_GCUNEG='"+fAjusTam(cGcUneg,SP3->P3_GCUNEG)+"' OR P3_GCUNEG='"+fAjusTam(" ",SP3->P3_GCUNEG)+"') "
	cQuery += "  AND (P3_GCFIL='"+fAjusTam(cGcFil,SP3->P3_GCFIL)+"' OR P3_GCFIL='"+fAjusTam(" ",SP3->P3_GCFIL)+"') "
	cQuery += "    ) WHERE "
	If TcSrvType() == "AS/400"
		cQuery += "RA.@DELETED@ = ' ' "
	Else
		cQuery += "RA.D_E_L_E_T_ = ' ' "
	Endif 
	cQuery += "AND RA_FILIAL='"+SRA->RA_FILIAL+"' AND RA_MAT='"+SRA->RA_MAT+"' "
	cQuery += "ORDER BY P3_GCGRPE,P3_GCUNEG,P3_GCFIL,P3_DATA,P3_TIPO,P3_TIPCOD "
	cQuery := ChangeQuery(cQuery)
	If Select(cAlias) > 0
		(cAlias)->(dbCloseArea())
	Endif
	
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)
	//Count To nTReg	//# Conta os registros retornados
	aEval( (cAlias)->(dbStruct()), {|x| Iif(x[2] != "C",TcSetField(cAlias,x[1],x[2],x[3],x[4]),Nil)} )	//# Corrige a forma das Datas e Numeros
	(cAlias)->(dbGotop())
	
Else
	cMyChave	:= cFil + DtoS(dDate)
	nOrderDt	:= RetOrdem( "SP3" , "P3_FILIAL+DTOS(P3_DATA)" )
	nPosFer		:= aScan( __aFeriadoStatic , { |x| x[01]+DtoS(x[02]) == cMyChave } )
	
EndIf
nOrderMd	:= RetOrdem( "SP3" , "P3_FILIAL+P3_MESDIA+P3_FIXO" )

If nPosFer == 0
	
	If lGestaoCorp .And. lNewFields	//-Tratamaneto Novo
		
		If Eof()
			lMyCnt := .F.
		Else
			//-QB_FILIAL+QB_CC+QB_DEPTO
			SQB->(xFilial("SQB")+SRA->RA_CC,.F.)
		EndIf
		
		While !Eof()
			
			cMyChv :=	fAjusTam(cGcGrpE,SP3->P3_GCGRPE) + ;
						fAjusTam(cGcUneg,SP3->P3_GCUNEG) + ;
						fAjusTam(cGcFil,SP3->P3_GCFIL)
				
			If P3_TIPO == "1" .And. Alltrim(P3_TIPCOD) == Alltrim(SRA->RA_CC)
				cDesc	:= SP3->P3_DESC
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
				lFeriado := .T.
				nMyRecno := QSP3->R_E_C_N_O_
				Exit
				
			ElseIf P3_TIPO == "2" .And. Alltrim(P3_TIPCOD) == Alltrim(SRA->RA_DEPTO)
				cDesc	:= SP3->P3_DESC
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
				lFeriado := .T.
				nMyRecno := QSP3->R_E_C_N_O_
				Exit
				
			ElseIf P3_TIPO == "3" .And. Alltrim(P3_TIPCOD) == Alltrim(SQB->QB_CESTAB)
				cDesc	:= SP3->P3_DESC
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
				lFeriado := .T.
				nMyRecno := QSP3->R_E_C_N_O_
				Exit
				
			ElseIf P3_GCGRPE + P3_GCUNEG + P3_GCFIL == cMyChv
				cDesc	:= SP3->P3_DESC
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
				lFeriado := .T.
				nMyRecno := QSP3->R_E_C_N_O_
				Exit
				
			EndIf
				
			dbSkip()
		EndDo
		
	Else	//-Tratamaneto Antigo
		
		SP3->( dbSetOrder( nOrderDt ) )
		IF ( lFeriado := SP3->( MsSeek(cFil+DtoS(dDate),.F.) ) )
			nMyRecno := SP3->( Recno() )
			cDesc := SP3->P3_DESC
			SP3->( dbSetOrder( aSP3Area[ 02 ] ) )
/*
		Else
			SP3->( dbSetOrder( nOrderMd ) )
			cMesDia := MesDia( dDate )
			cAno	:= SubStr( AllTrim( Dtos( dDate ) ) , 1 , 4  )
			
			IF ( lFeriado := SP3->( MsSeek( ( cFil + cMesDia + "S" ) , .F. ) ) )
				cDesc := SP3->P3_DESC
				dDate := Stod( ( cAno + cMesDia ) )
				
				If cPaisLoc $ "PTG" .And. lNewFields
					cTipo   := SP3->P3_TIPO
					cTipCod := SP3->P3_TIPCOD
				EndIf
					
				nMyRecno := SP3->( Recno() )
			EndIF
*/
		EndIF
	EndIF

	If !lFeriado
	
		SP3->( dbSetOrder( nOrderMd ) )
		cMesDia := MesDia( dDate )
		cAno	:= SubStr( AllTrim( Dtos( dDate ) ) , 1 , 4  )
		
		IF ( lFeriado := SP3->( MsSeek( ( cFil + cMesDia + "S" ) , .F. ) ) )
			cDesc := SP3->P3_DESC
			dDate := Stod( ( cAno + cMesDia ) )
			
			If cPaisLoc $ "PTG" .And. lNewFields
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
			EndIf
			
			nMyRecno := SP3->( Recno() )
		Else
			lMyCnt := .F.
		EndIF
	EndIF

	If lMyCnt
		aAdd( __aFeriadoStatic, {	cFil,;									//-01
									dDate,;									//-02
									cDesc,;									//-03
									Iif( lFeriado, nMyRecno, 0 ),;			//-04
									lFeriado,;								//-05
									cTipo,;									//-06
									cTipCod ;								//-07
								} )
	EndIf
Else
	IF ( lFeriado := __aFeriadoStatic[ nPosFer , 05 ] )
		SP3->( MsGoto( __aFeriadoStatic[ nPosFer , 04 ] ) )
		cDesc := __aFeriadoStatic[ nPosFer , 03 ]
	EndIF
EndIF

If !lFeriado
	RestArea(aSP3Area)
EndIf

If !ArrayCompare( aArea , aSP3Area )
	RestArea(aArea)
EndIf

Return( lFeriado )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fAjusTam		³Autor³Ademar Fernandes   ³ Data ³11/02/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Ajusta o tamanho do campo retornando-o de acordo com o tama-³
³          ³nho do campo do segundo parametro desta funcao.             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³uConteudo - conteudo a ser redimencionado                   ³
³          ³cNomeCpo  - Alias+Campo usado como padrao de tamanho        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fAjusTam(uConteudo,cNomeCpo)
//cGcFil,SP3->P3_GCFIL
Local cRet := uConteudo + Space( Len(cNomeCpo)-Len(uConteudo) )
Return(cRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstfFeriado		³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em fFeriado()        	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstfFeriado()
Return( ( __aFeriadoStatic := NIL ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fDescTno  ³ Autor ³ Marinaldo de Jesus    ³ Data ³07/06/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Retorna uma descri‡„o do Turno de Trabalho Solicitado      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fDescTno(cFil,cTno)                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cFil - Filial para Pesquisa                                 ³
³          ³cTno - Turno para Pesquisa                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fDescTno( cFil , cTno, nTam )

Local cString := Space(50)

DEFAULT nTam	:= 50
cString := Left( fDesc( "SR6" , cTno , "R6_DESC" , nTam , cFil , NIL , .F. ) , nTam )

Return( cString )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetDescMarc ³ Autor ³Marinaldo de Jesus    ³ Data ³12/06/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a Descricao dos Tipos de Marcacoes                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetDescMarc( cMarca )			              			 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cMarca  -> Tipo de Marcacao                          		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cDesc                                                	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetDescMarc( cMarca )

Local aMarca := Array( 11 , 2 )
Local cDescr := ""
Local nPos	 := 0

DEFAULT cMarca	:= ""

cMarca := StrTran( Upper( Alltrim( cMarca  ) ) , " " , "" )

aMarca[ 01 , 01 ] :=  "1E" ; aMarca[ 01 , 02 ] := STR0080 //'1a. Entrada'
aMarca[ 02 , 01 ] :=  "1S" ; aMarca[ 02 , 02 ] := STR0081 //'1a. Saida  '
aMarca[ 03 , 01 ] :=  "2E" ; aMarca[ 03 , 02 ] := STR0082 //'2a. Entrada'
aMarca[ 04 , 01 ] :=  "2S" ; aMarca[ 04 , 02 ] := STR0083 //'2a. Saida  '
aMarca[ 05 , 01 ] :=  "3E" ; aMarca[ 05 , 02 ] := STR0084 //'3a. Entrada'
aMarca[ 06 , 01 ] :=  "3S" ; aMarca[ 06 , 02 ] := STR0085 //'3a. Saida  '
aMarca[ 07 , 01 ] :=  "4E" ; aMarca[ 07 , 02 ] := STR0086 //'4a. Entrada'
aMarca[ 08 , 01 ] :=  "4S" ; aMarca[ 08 , 02 ] := STR0087 //'4a. Saida  '
aMarca[ 09 , 01 ] :=  "I1" ; aMarca[ 09 , 02 ] := STR0088 //'1o. Intervalo '
aMarca[ 10 , 01 ] :=  "I2" ; aMarca[ 10 , 02 ] := STR0089 //'2o. Intervalo '
aMarca[ 11 , 01 ] :=  "I3" ; aMarca[ 11 , 02 ] := STR0090 //'3o. Intervalo '

IF ( ( nPos := aScan( aMarca , { |x| x[1] == cMarca } ) ) > 0 )
	cDescr := aMarca[ nPos , 2 ]
EndIF

Return( cDescr )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Chk_IdPon ³ Autor ³Marinaldo de Jesus     ³ Data ³10/07/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Consiste os Identificadores de Ponto                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Chk_IdPon( Codigo )                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ codigo = codigos da folha                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ SP9                                                        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Chk_IdPon()

Local aArea		:= GetArea()
Local aAreaSP9	:= {}
Local cSpaceIdP := Space( GetSx3Cache( "P9_IDPON  " , "X3_TAMANHO" ) ) 
Local cId		:= GetMemVar( "P9_IDPON" )
Local lRet		:= .F.
Local nOrder	:= RetOrdem( "SP9" , "P9_FILIAL+P9_IDPON+P9_CODIGO" )

aAreaSP9 := SP9->( GetArea() )
IF !( aAreaSP9[2] == nOrder )
	SP9->( dbSetOrder( nOrder ) )
EndIF	

IF lRet := SP9->( dbSeek( xFilial("SP9") + cId ) .and. IF( Altera , Recno() # aAreaSP9[3] , .T. ) .and. cId # cSpaceIdP )
	Help(" ",1,"XREPCODFOL")
EndIF

RestArea( aAreaSP9 )
RestArea( aArea	   )

Return( !lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetLastApo  ³ Autor ³Marinaldo de Jesus    ³ Data ³27/07/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar array com os Resultados dos Apontamentos            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetLastApo( [ dPerIni ],[ dPerFim ],[ cAlias ],[ aCpos ] )	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³dPerIni 	-> Periodo Inicial de Apontamento            	 ³
³          ³dPerFim 	-> Periodo Final   de Apontamento            	 ³
³          ³cAlias  	-> Alias Para Pesquisa ("SPC" ou "SPH")      	 ³
³          ³aCpos   	-> Campos Para a Montagem da Query           	 ³
³          ³lInformado	-> Se considera os Dados Informados    	 		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aResult                                              	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetLastApo( dPerIni , dPerFim , cAlias , aCpos , lInformado )

Local aAreaSPC		:= {}
Local aResult		:= {}
Local bSort			:= { || NIL }
Local cFil	    	:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cFilMat		:= ( cFil + cMat )
Local cAliasQuery	:= ""
Local cPrefixo		:= ""
Local cSvAlias		:= Alias()
Local cCpoPD		:= "PD"
Local cCpoQtd		:= "QUANTC"
Local cOrdem		:= ""
Local lSPC			:= .F.
Local lSort			:= .F.
Local lQueryOpened	:= .F.
Local nOrdem		:= 1

#IFDEF TOP
	
	Local aStru			:= {}
	Local cIniData		:= ""
	Local cFimData		:= ""
	Local cQuery		:= ""
	Local cQryStru		:= ""
	Local nCpos			:= 0
	Local nX			:= 0
    
	Static aSPCStruct
	Static aSPHStruct
	Static cQrySPCStruct
	Static cQrySPHStruct

	DEFAULT aCpos	:= {}

#ENDIF

DEFAULT dPerIni 	:= Ctod("//")
DEFAULT dPerFim 	:= Ctod("//")
DEFAULT cAlias		:= "SPC"
DEFAULT lInformado	:= .F.

cAlias		:= Upper( AllTrim( cAlias ) )
cPrefixo 	:= ( PrefixoCpo( cAlias ) + "_" )
lSPC		:= ( cAlias == "SPC" )
cAliasQuery	:= cAlias
aAreaSPC	:= ( cAlias )->( GetArea() )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Define a Ordem para Pesquisa								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cOrdem	:= ( cPrefixo+'FILIAL+' )
cOrdem	+= ( cPrefixo+'MAT+' )
cOrdem	+= ( 'Dtos('+cPrefixo+'DATA'+')+' )
cOrdem	+= ( cPrefixo+'PD+' )
cOrdem	+= ( cPrefixo+'TPMARCA+' )
cOrdem	+= ( cPrefixo+'CC' )
cOrdem	+= ( cPrefixo+'DEPTO' )
cOrdem	+= ( cPrefixo+'POSTO' )
cOrdem	+= ( cPrefixo+'CODFUNC' )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica a Existencia de Indice Fil+Mat+Data... e utiliza-o.  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nOrdem	:= RetOrdem( cAlias , cOrdem )

IF ( nOrdem > 1 )
	( cAlias )->( dbSetOrder( nOrdem ) )
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Na Ausencia do Indice forca a ordenacao					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lSort	:= .T.  
	bSort	:= { |x,y|	(;
							x[ARESULT_DTOS_DATA]	+ ;
							x[ARESULT_EVENTO] 		+ ;
							x[ARESULT_TPMARCA] 		+ ;
							x[ARESULT_CC] 			+ ;
							x[ARESULT_FUNCAO] 		+ ;
							x[ARESULT_DEPTO] 		+ ;
							x[ARESULT_POSTO] 		  ;														
						);
							 < 					  	  ;
						(;
							y[ARESULT_DTOS_DATA]	+ ;
							y[ARESULT_EVENTO] 		+ ;
							y[ARESULT_TPMARCA] 		+ ;
							y[ARESULT_CC] 		 	+ ;
							y[ARESULT_FUNCAO] 		+ ;
							y[ARESULT_DEPTO] 		+ ;
							y[ARESULT_POSTO] 		  ;														
						);
				};

EndIF

IF Empty( dPerIni ) .or. Empty( dPerFim )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIF

#IFDEF TOP

	IF !( lExInAs400 )
	
		DEFAULT aSPCStruct := SPC->( dbStruct() )
		DEFAULT aSPHStruct := SPH->( dbStruct() )
	
		cIniData := Dtos( dPerIni )
		cFimData := Dtos( dPerFim )
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Seta apenas os Campos do SPC/SPH que serao Utilizados       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aAdd( aCpos , cPrefixo + "FILIAL"  )
		aAdd( aCpos , cPrefixo + "MAT" 	   )
		aAdd( aCpos , cPrefixo + "PD"	   )
		aAdd( aCpos , cPrefixo + "DATA"	   )
		aAdd( aCpos , cPrefixo + "QUANTC"  )
		aAdd( aCpos , cPrefixo + "CC"	   )
		aAdd( aCpos , cPrefixo + "TPMARCA" )
		aAdd( aCpos , cPrefixo + "CODFUNC" )
		aAdd( aCpos , cPrefixo + "POSTO"   )
		aAdd( aCpos , cPrefixo + "DEPTO"   )
		aAdd( aCpos , cPrefixo + "PROCES"  )
		aAdd( aCpos , cPrefixo + "ROTEIR"  )
		aAdd( aCpos , cPrefixo + "PERIODO" )
		aAdd( aCpos , cPrefixo + "NUMPAG"  )								
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando forcar a carga dos dados Informados				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lInformado )
			aAdd( aCpos , cPrefixo + "PDI"	   )
			aAdd( aCpos , cPrefixo + "QUANTI"  )
		EndIF
		
		nCpos := IF( lSPC , Len( aSPCStruct ) , Len( aSPHStruct ) )
		For nX := 1 To nCpos
			IF aScan( aCpos , { |x| x == AllTrim( IF( lSPC , aSPCStruct[ nX , 1 ] , aSPHStruct[ nX , 1 ] ) ) } ) > 0
				aAdd( aStru , aClone( IF( lSPC , aSPCStruct[ nX ] , aSPHStruct[ nX ] ) ) )
				IF ( ( lSPC ) .and. !( cQrySPCStruct == NIL ) ) 
					IF !( aSPCStruct[ nX , 1 ] $ cQrySPCStruct )
						cQrySPCStruct := NIL
					EndIF
				ElseIF !( cQrySPHStruct == NIL )
					IF !( aSPHStruct[ nX , 1 ] $ cQrySPHStruct )
						cQrySPHStruct := NIL
					EndIF
				EndIF
			EndIF
		Next nX
	
		aCpos	:= NIL
		nCpos	:= Len( aStru )
	
		IF ( lSPC )
			IF ( cQrySPCStruct == NIL )
				cQrySPCStruct := ""
				For nX := 1 To nCpos
					cQrySPCStruct += aStru[ nX , 1 ] + ", "
				Next nX
			EndIF
			cQryStru := cQrySPCStruct
		Else
			IF ( cQrySPHStruct == NIL )
				cQrySPHStruct := ""
				For nX := 1 To nCpos
					cQrySPHStruct += aStru[ nX , 1 ] + ", "
				Next nX
			EndIF
			cQryStru := cQrySPHStruct
		EndIF
		
		cQuery	:= "SELECT "
		cQuery	+= cQryStru
		cQuery	:= SubStr( cQuery , 1 , Len( cQuery ) - 2 )
		cQuery	+= " FROM "
		cQuery	+= InitSqlName( cAlias )
		cQuery	+= " WHERE "
		cQuery	+= cPrefixo + "FILIAL='"+cFil+"'"
		cQuery	+= " AND "
		cQuery	+= cPrefixo + "MAT='"+cMat+"'"
		cQuery	+= " AND "
		cQuery	+= cPrefixo + "DATA>='"+cIniData+"'"
		cQuery	+= " AND "
		cQuery	+= cPrefixo + "DATA<='"+cFimData+"'"
		cQuery	+= " AND "
		cQuery	+= "D_E_L_E_T_=' ' "
		cQuery	+= "ORDER BY " + SqlOrder( ( cAlias )->( IndexKey() ) )
		cQuery	:= ChangeQuery(cQuery)
		cAliasQuery += "QRY"
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nCpos
				IF ( aStru[nX,2] <> "C" )
					TcSetField(cAliasQuery,aStru[nX,1],aStru[nX,2],aStru[nX,3],aStru[nX,4])
				EndIF
			Next nX
		EndIF

	EndIF
	
#ENDIF

IF !( lQueryOpened )
	cAliasQuery := cAlias
	( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
EndIF	

While ( cAliasQuery )->( !Eof() .and. ( ( &(cPrefixo+"FILIAL") + &(cPrefixo+"MAT") ) == cFilMat ) )
		
	#IFNDEF TOP
		IF ( cAliasQuery )->( &(cPrefixo+"DATA") < dPerIni .or. &(cPrefixo+"DATA") > dPerFim )
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	#ELSE
		IF !( lQueryOpened )
			IF ( cAliasQuery )->( &(cPrefixo+"DATA") < dPerIni .or. &(cPrefixo+"DATA") > dPerFim )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF
		EndIF
	#ENDIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Quando forcar a carga dos dados Informados				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lInformado )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Altera o Nome do Campo correspondente ao Evento a ser conside³
		³ rado														   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !Empty( ( cAliasQuery )->( &(cPrefixo+"PDI") ) )
			cCpoPD := "PDI"
		Else
			cCpoPD := "PD"
		EndIF
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Altera o Nome do Campo correspondente a Quantidade a ser  con³
		³ siderada													   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !Empty( ( cAliasQuery )->( &(cPrefixo+"QUANTI") ) )
			cCpoQtd := "QUANTI"
		Else
			cCpoQtd := "QUANTC"
		EndIF	
	EndIF
			
	( cAliasQuery )->( fGeraRes(	@aResult				,; //01 -> Array com os Resultados do Dia
			   						&(cPrefixo+"DATA")		,; //02 -> Data da Geracao
									&(cPrefixo+cCpoQtd)		,; //03 -> Numero de Horas Resultantes
									&(cPrefixo+cCpoPD)		,; //04 -> Codigo do Evento
									&(cPrefixo+"CC")		,; //05 -> Centro de Custo a ser Gravado
									&(cPrefixo+"TPMARCA")	,; //06 -> Tipo de Marcacao
									.F.						,; //07 -> True para Acumular as Horas
									NIL						,; //08 -> Periodo de Apuracao
									NIL						,; //09 -> Tolerancia
									NIL						,; //10 -> Tipo de Arredondamento a Ser Utilizado
									.T.			 			,; //11 -> Substitui a(s) Hora(s) Existente(s) ( Garanto Apenas 1 DSR por Data )
									&(cPrefixo+"CODFUNC")	,; //12 -> Funcao a ser Gravada	
									&(cPrefixo+"DEPTO"	)	,; //13 -> Depto para gravacao     
									&(cPrefixo+"POSTO"	)	,; //14 -> Posto para gravacao									
									&(cPrefixo+"PROCES")	,; //15 -> Processo para Gravacao
									&(cPrefixo+"ROTEIR")	,; //16 -> Roteiro para Gravacao								
									&(cPrefixo+"PERIODO")	,; //17 -> Periodo para Gravacao
									&(cPrefixo+"NUMPAG")	;  //18 -> NumPagto para Gravacao								
							    );
				  	 )

	( cAliasQuery )->( dbSkip() )

End While

IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
	( cAliasQuery )->( dbCloseArea() )
	dbSelectArea( cAlias )				//Restaura Arquivo Original
EndIF	

( cAlias )->( dbSetOrder( aAreaSPC[ 02 ] ) )

dbSelectArea( cSvAlias )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Ordena aResult para Acumulados pois nao Existe o Indice 02   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lSort )
	aSort( @aResult , NIL , NIL , bSort ) 
EndIF
		
Return( aResult )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fEventos   ³ Autor ³ Marinaldo de Jesus   ³ Data ³23/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ListBox com a Selecao dos Eventos do Ponto                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fEventos( cCampo , l1Elem )			    					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T. por ser Utilizado em Validacao                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cCampo 	- Campo Chave                                   ³
³          ³ l1Elem 	- Se deve Mostrar Apenas 1 Elemento             ³
³          ³ cPreSelect	- Eventos que ja foram Selecionados             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fEventos( cCampo , l1Elem , cPreSelect )

Local aPreSelect	:= {}
Local aEventos		:= {}
Local cTitulo		:= ""
Local cFilSP9		:= xFilial( "SP9" )
Local cFilSRV		:= xFilial( "SRV" )
Local cMvPar		:= &( Alltrim( ReadVar() ) )
Local cMvParDef		:= ""
Local cMvRetor		:= ""
Local cMvParam		:= ""
Local cReplicate	:= ""
Local nFor			:= 0
Local nLenFor		:= Len( AllTrim( cMvPar ) )
Local nTamCpo		:= 0

DEFAULT l1Elem 			:= .F.
DEFAULT cCampo 			:= "P9_CODIGO"
DEFAULT cPreSelect		:= ""

cCampo		:= Upper( AllTrim( cCampo ) )
nTamCpo		:= GetSx3Cache( cCampo , "X3_TAMANHO" )
cReplicate  := Replicate( "*" , nTamCpo )

CursorWait()

	IF !( l1Elem )
		nLenFor := Len( AllTrim( cMvPar ) )
		For nFor := 1 To nLenFor
			cMvParam += SubStr( cMvPar , nFor , nTamCpo )
			cMvParam += cReplicate
		Next nFor
	EndIF
	cMvPar := cMvParam
	
	IF ( Empty( __aEvefEve__ ) )
		SP9->( dbSetOrder( RetOrdem( "SP9" , "P9_FILIAL+" + cCampo ) ) )
		__aEvefEve__	:= BldafEventos( cFilSP9 , cCampo , cFilSRV )
	EndIF	
	
	nLenFor := Len( cPreSelect )
	For nFor := 1 To Len( cPreSelect ) Step nTamCpo
		aAdd( aPreSelect , SubStr( cPreSelect , nFor , nTamCpo ) )
	Next nFor
	
	nLenFor := Len( __aEvefEve__ )
	For nFor := 1 To nLenFor
		IF ( aScan( aPreSelect , SubStr( __aEvefEve__[ nFor ] , 1 , nTamCpo ) ) == 0 )
			cMvParDef += SubStr( __aEvefEve__[ nFor ] , 1 , nTamCpo )
			aAdd( aEventos , __aEvefEve__[ nFor ] )
		EndIF
	Next nFor

CursorArrow()
	
IF f_Opcoes( @cMvPar , cTitulo , aEventos , cMvParDef , 12 , 49 , l1Elem , nTamCpo , 10 )

	CursorWait()

		nLenFor := Len( cMvPar )
		For nFor := 1 To nLenFor Step nTamCpo
			IF ( SubStr( cMvpar , nFor , nTamCpo ) # cReplicate )
				cMvRetor += SubStr( cMvPar , nFor , nTamCpo )
			EndIF
		Next nFor

		&( Alltrim( ReadVar() ) ) := AllTrim( cMvRetor )

	CursorArrow()

EndIF
	
Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³BldafEventos  ³ Autor ³Marinaldo de Jesus     ³ Data ³12/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carregar os Eventos do SP9 conforme Filial                    	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cFilSP9 - Filial do SP9											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aEventos - Array com a String de Codigo + Descricao do Evento   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function BldafEventos( cFilSP9 , cCampo , cFilSRV )

Local aArea		:= GetArea()
Local aQuery	:= {}
Local aEventos	:= {}
Local bAscan	:= { |x| ( x == cCpoDes ) } 
Local bSkip		:= { || .F. }
Local cCntCpo	:= ""
Local cCpoDes	:= ""
Local nOrdSrv	:= 0

Begin Sequence

	IF ( SP9->( FieldPos( cCampo ) ) == 0 )
		Break
	EndIF

	IF ( cCampo == "P9_CODFOL" )
		nOrdSrv := RetOrdem( "SRV" , "RV_FILIAL+RV_COD" )
		bSkip	:= { || (;
							cCpoDes := (;
											( cCntCpo := &( cCampo ) )	+ ;
											" - "						+ ;
											PosSRV( cCntCpo , cFilSRV , "RV_DESC" , nOrdSrv , .F. );
									    );
						),;
						IF( aScan( aEventos , bAscan ) == 0 .and. !Empty( cCntCpo ),;
							aAdd( aEventos , cCpoDes ),;
							NIL;
						  ),;
						 (;
						 	cCntCpo	:= "" ,;
						 	.F.;
						 );
				  }
	Else
		bSkip	:= { || (;
							cCpoDes := (;
											( cCntCpo := &( cCampo ) )	+ ;
											" - "						+ ;
											P9_DESC						  ;
										);
						 ),;
						 IF( aScan( aEventos , bAscan ) == 0 .and. !Empty( cCntCpo ),;
						 	 aAdd( aEventos , cCpoDes ),;
						 	 NIL;
						 	),;
						 (;
						 	cCntCpo	:= "" ,;
						 	.F.;
						 );	
					}
	EndIF

	#IFDEF TOP
		aQuery		:= Array( 03 )
		aQuery[01]	:= "P9_FILIAL='"+cFilSP9+"'"
		aQuery[02]	:= " AND "
		aQuery[03]	:= "D_E_L_E_T_=' ' "
	#ENDIF

	SP9->( GdBuildCols(	NIL				,;	//01 -> Array com os Campos do Cabecalho da GetDados
						NIL				,;	//02 -> Numero de Campos em Uso
						NIL				,;	//03 -> [@]Array com os Campos Virtuais
						NIL				,;	//04 -> [@]Array com os Campos Visuais
						NIL				,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						{				 ;
							"P9_FILIAL"	,;
							cCampo		,;
							"P9_DESC"	 ;
						}				,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						NIL				,;	//07 -> [@]Array unidimensional contendo os Recnos
						"SP9"			,;	//08 -> Alias do Arquivo Pai
						cFilSP9			,;	//09 -> Chave para o Posicionamento no Alias Filho
						NIL				,;	//10 -> Bloco para condicao de Loop While
						bSkip			,;	//11 -> Bloco para Skip no Loop While
						.F.				,;	//12 -> Se Havera o Elemento de Delecao no aCols 
						.F.				,;	//13 -> Se Sera considerado o Inicializador Padrao
						.F.				,;	//14 -> Opcional, Carregar Todos os Campos
						.F.				,;	//15 -> Opcional, Nao Carregar os Campos Virtuais
						aQuery			,;	//16 -> Opcional, Utilizacao de Query para Selecao de Dados
						.F.				,;	//17 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						.T.				,;	//18 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						.F.				,;	//19 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						.T.				,;	//20 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						.F.				,;	//21 -> Verifica se Deve Checar se o campo eh usado
						.F.				,;	//22 -> Verifica se Deve Checar o nivel do usuario
						.F.				 ;	//23 -> Verifica se Deve Carregar o Elemento Vazio no aCols
					   );
		  )

End Sequence

RestArea( aArea )

Return( aClone( aEventos ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstfEventos   ³ Autor ³Marinaldo de Jesus     ³ Data ³11/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializa as Statics em RstfEventos()                       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³																³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL																³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstfEventos()
Return( ( __aEvefEve__ := {} ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetMarcacoes³Autor ³ Marinaldo de Jesus   ³ Data ³25/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array aMarcacoes com as Marcacoes do Periodo       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetMarcacoes(@aMarcacoes,[@]aTabCalend...)					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGetMarcOk                         							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetMarcacoes(	aMarcacoes			,;	//01 -> Marcacoes dos Funcionarios
						aTabCalend			,;	//02 -> Calendario de Marcacoes
						aTabPadrao			,;	//03 -> Tabela Padrao
						aTurnos				,;	//04 -> Turnos de Trabalho
						dPerIni 			,;	//05 -> Periodo Inicial
						dPerFim				,;	//06 -> Periodo Final
						cFil				,;	//07 -> Filial
						cMat				,;	//08 -> Matricula
						cTno				,;	//09 -> Turno
						cSeq				,;	//10 -> Sequencia de Turno
						cCc					,;	//11 -> Centro de Custo
						cAlias				,;	//12 -> Alias para Carga das Marcacoes
						lRecno				,;	//13 -> Se carrega Recno em aMarcacoes
						lOrdem				,;	//14 -> Se considera Apenas Ordenadas
						lDiasFolga			,;  //15 -> Verifica as Folgas Automaticas
						lGrvFolgPa  		,;  //16 -> Se Grava Evento de Folga Mes Anterior
						lGetMarcAuto		,;	//17 -> Se Carrega as Marcacoes Automaticas
						aRecsMarcAut	    ,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Desprezadas
						bCondMarcAut		,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
						lChkPerAponta		,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
						lSncMaMe			,;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
						lDataApo			,;	//22 -> Se Considera a data de apontamento 
						lDataIni			;	//23 -> Se Deve verificar se a data de apontamento da marcacao eh maior ou igual a data inicial do periodo (somente se Considera a data de apontamento) 						
					  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local cSvAlias			:= Alias()
Local lGetMarcOk 		:= .T.
Local lQueryOpened		:= .F.

Local cFilter	  		:= ""
Local cAliasQuery 		:= cAlias
Local nOrderSP8  

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/      
Local aAreaDtMin 		:= GetArea()
Local cFilMat
Local cFilSPJ	:=xFilial("SPJ")
Local cPrefixo
Local cCod036N
Local cPriOrdem
Local cUltOrdem	
Local cAtuOrdem    
Local cAtuDataApo
Local cPerAponta
Local cAntOrdem
Local cPrxOrdem
Local cDtHrAntOrd
Local cDtHrPrxOrd
Local cDtHrLimIni
Local cDtHrLimFim
Local cDtHrAtu
Local cSetOrdem
Local lNotOrdena    
Local nLenMarc
Local nSerMarc
Local nSerIni
Local nSerFim
Local nSvIndexOrd
Local nPosUltOrdem
Local nLenTabCal
Local nPosPrxOrd
Local nPosAntOrd
Local nSetOrder

Local cIniData
Local cFimData   


#IFDEF TOP

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Variaveis de Inicializacao Obrigatoria					  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	Local aGetMarcFields	:= {}

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	Local cQryMarcFields
	Local cQuery
	Local nGetMarcFields
	Local nX

	Static aGetSP8Fields
	Static cQrySP8Fields
	Static cQrySPGFields
	Static nGetSP8Fields
	Static aGetSPGFields
	Static nGetSPGFields

#ENDIF

DEFAULT cFil				:= SRA->RA_FILIAL
DEFAULT cMat				:= SRA->RA_MAT
DEFAULT cTno				:= SRA->RA_TNOTRAB
DEFAULT cSeq				:= SRA->RA_SEQTURN
DEFAULT dPerIni				:= Ctod("//")
DEFAULT dPerFim				:= Ctod("//")
DEFAULT aTabPadrao			:= {}
DEFAULT aTabCalend			:= {}
DEFAULT aTurnos				:= {}
DEFAULT cAlias				:= "SP8"
DEFAULT lDataApo			:= .T.
//DEFAULT lDataIni			:= .T.
DEFAULT lRecno				:= .T.
DEFAULT lOrdem				:= .F.
DEFAULT lDiasFolga			:= .F.
DEFAULT lGrvFolgPa			:= .F.
DEFAULT lGetMarcAuto		:= .T.
DEFAULT bCondMarcAut		:= { || .T. }
DEFAULT lChkPerAponta		:= .T.
DEFAULT lSncMaMe			:= .T.        

aRecsMarcAut				:= {}

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³A Data de Apontamento sobrepoe a Ordem            			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    lDataApo	:= IF( lOrdem, .T., IF(Valtype(lDataApo) <> "U",lDataApo, .F.))
    lOrdem:= IF(lDataApo, .F., lOrdem)       
   
   	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Somente verifica a Data de Apontamento da marcacao se considera a Data de Apontamento         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    lDataIni	:= If(lDataApo, IF(Valtype(lDataIni) <> "U",lDataIni, .F.),.F.)
    
    /* Caso esteja carregabdo marcacoes da tabela SP8, a data inicial devera  ser a menor data existente nas marcacoes */

    If cAlias == "SP8"
    	If !lDataIni
			#IFDEF TOP
	
				cAliasQuery := GetNextAlias()
						
				cFilter := " P8_FILIAL = '"+cFil+"'"
				cFilter += " AND P8_MAT = '"+cMat+"'"
	
				If !lExInAs400
					cFilter    += " AND D_E_L_E_T_ = ' ' "
				Else
					cFilter    += " AND @DELETED@ = ' ' "
				EndIf
				
				cFilter := "%"+cFilter+"%"
			
				If lDataApo
					BeginSql alias cAliasQuery
						column MINDTA as Date
						%NoParser%
						SELECT 
							MIN(cAliasQuery.P8_DATAAPO) MINDTA
						FROM 
							%Table:SP8% cAliasQuery
						WHERE 
							%Exp:cFilter%
					EndSql
				Else
					BeginSql alias cAliasQuery
						column MINDTA as Date
						%NoParser%
						SELECT 
							MIN(cAliasQuery.P8_DATA) MINDTA
						FROM 
							%Table:SP8% cAliasQuery
						WHERE 
							%Exp:cFilter%
					EndSql
				EndIf
								
				If !Empty((cAliasQuery)->(MINDTA)) .and. (cAliasQuery)->(MINDTA) < dPerIni
					dPerIni := (cAliasQuery)->(MINDTA)
				EndIf
				
				(cAliasQuery)->(dbCloseArea())
				
			#ELSE
			
				cFilter := cFil
				cFilter += cMat
				
				If lDataApo
					nOrderSP8 := (cAlias)->(dbSetOrder(RetOrder("P8_FILIAL+P8_MAT+DTOS(P8_DATAAPO)+DTOS(P8_DATA)+P8_HORA")))
				Else
					nOrderSP8 := (cAlias)->(dbSetOrder(RetOrder("P8_FILIAL+P8_MAT+DTOS(P8_DATA)+P8_HORA")))
				EndIf
			
				dbSelectArea(cAlias)
				dbSetOrder(nOrderSP8)
				
				(cAlias)->(dbSeek( cFilter, .F. ))
				
				If Found()
					If lDataApo 
						If (cAliasQuery)->(P8_DATAAPO) < dPerIni
							dPerIni := (cAliasQuery)->(P8_DATAAPO)
						EndIf
					Else
						If (cAliasQuery)->(P8_DATA) < dPerIni
							dPerIni := (cAliasQuery)->(P8_DATA)
						EndIf
					EndIf
				EndIf
			#ENDIF
			
			RestArea( aAreaDtMin )
			If Type("oPeriodo") <> "U"
				oPeriodo:dDataIni := dPerIni
			EndIf
		EndIf
	EndIf    		
    
Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega o Calendario do Periodo Caso Esteja Vazio            ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			If Type("oPeriodo") == "U"
				SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
			EndIf
			oPeriodo:cProcesso := SRA->RA_PROCES
			oPeriodo:GetPer()
			IF !( lGetMarcOk :=oPeriodo:lFound)
				Break
			EndIF
			
			dPerFim := oPeriodo:dDataFim
		EndIF 
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Inicio do Periodo e a menor data entre as marcacoes e o Periodo³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/		
	    dPerIni := Min(oPeriodo:dDataIni,dPerIni)
	    
		IF !( lGetMarcOk := CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Periodo
			  			   			   	dPerFim		,;	//02 -> Data Final do Periodo
								   		cTno		,;	//03 -> Turno Para a Montagem do Calendario
								   		cSeq		,;	//04 -> Sequencia Inicial para a Montagem Calendario
								   		@aTabPadrao	,;	//05 -> Array Tabela de Horario Padrao
								   		@aTabCalend	,;	//06 -> Array com o Calendario de Marcacoes
								   		cFil     	,;	//07 -> Filial para a Montagem da Tabela de Horario
								   		cMat   		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								   		cCc   		,;	//09 -> Centro de Custo para a Montagem da Tabela
								   		@aTurnos	,;	//10 -> Array com as Trocas de Turno
										NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
										NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
										lSncMaMe	,;	//13 -> Se executa a funcao se sincronismo do calendario
										NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
							  		  );
			)
			Break
		EndIF
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )

		nLenTabCal		:= Len( aTabCalend )
		If !lDataApo
			cPriOrdem		:= aTabCalend[ 01 , CALEND_POS_ORDEM	]
			dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA		]
			cUltOrdem		:= aTabCalend[ nLenTabCal , CALEND_POS_ORDEM ]
			nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
			IF ( nPosUltOrdem > 0 )
				dPerFim := aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ]
			Else
				If Type("oPeriodo") == "U"
					SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
				EndIf
				oPeriodo:cProcesso := SRA->RA_PROCES
				oPeriodo:GetPer()
				IF !( lGetMarcOk :=oPeriodo:lFound)
					Break
				EndIF
	
				dPerIni := oPeriodo:dDataIni
				dPerFim := oPeriodo:dDataFim
	
			EndIF
		Else
			dPerIni := aTabCalend[ 01 				, CALEND_POS_DATA_APO ]
			dPerFim := aTabCalend[ nLenTabCal 		, CALEND_POS_DATA_APO ]
		Endif	
	EndIF	
	
	cAlias			:= Upper( AllTrim( cAlias ) )
	cAliasQuery 	:= cAlias
	cPrefixo		:= ( PrefixoCpo( cAliasQuery ) + "_" )
	aMarcacoes  	:= {}
	nLenTabCal		:= Len( aTabCalend )
	cPriOrdem		:= aTabCalend[ 01			, CALEND_POS_ORDEM	]
	cUltOrdem		:= aTabCalend[ nLenTabCal	, CALEND_POS_ORDEM	]
	IF ( lChkPerAponta )
		cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
		If !lDataApo
			nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
			cPerAponta		+= Dtos( aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ] )
		Else                                                                       
			cPerAponta		+= Dtos( aTabCalend[ nLenTabCal , CALEND_POS_DATA_APO ] )
		Endif	
	EndIF
	
	
	cDtHrLimIni		:= DataHora2Str(;
										aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ],;
										aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ];
									)
	cDtHrLimFim		:= DataHora2Str(;
										aTabCalend[ nLenTabCal , CALEND_POS_LIM_MARCACAO , 01 ],;
										aTabCalend[ nLenTabCal , CALEND_POS_LIM_MARCACAO , 02 ];
									)
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica os Seriais Apenas Quando Marcacoes nao ordenadas	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    IF !( lOrdem )  .AND. !(lDataApo)
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Define Numero Serial para o Inicio do Periodo        		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nSerIni	:= RetSerIni(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
								@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
								dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
								dPerFim					,; 	//04 -> Final do Periodo de Apontamento
								cTno					,;	//05 -> Turno de Trabalho
								cSeq					,;	//06 -> Sequencia de Turno
								cFil     				,;	//07 -> Filial do Funcionario
								cMat   					,;	//08 -> Matricula do Funcionario
								cCc   					,;	//09 -> Centro de Custo do Funcionario
								lOrdem	.or. 	lDataApo ;	//10 -> Marcacoes Sendo carregadas pela Ordem
					   		)
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Define Numero Serial para o Final do Periodo        		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nSerFim	:= RetSerFim(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
								@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
								dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
								dPerFim					,; 	//04 -> Final do Periodo de Apontamento
								cTno					,;	//05 -> Turno de Trabalho
								cSeq					,;	//06 -> Sequencia de Turno
								cFil     				,;	//07 -> Filial do Funcionario
								cMat   					,;	//08 -> Matricula do Funcionario
								cCc   		 			,;	//09 -> Centro de Custo do Funcionario
								lOrdem .or. lDataApo	 ;	//10 -> Marcacoes Sendo carregadas pela Ordem
					         )
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seleciona o Arquivo de Marca‡”es e Seta a Ordem corresponden³
	³ te:														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nSvIndexOrd := ( cAlias )->( IndexOrd() )
	cSetOrdem	:= ""
	IF ( lOrdem )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Ordem <=> _FILIAL+_MAT+_ORDEM+_DTOS(_DATA)+STR(_HORA,5,2)	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += cPrefixo+"ORDEM+"
		cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	ElseIF (lDataApo)                                             
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Data  <=> 	P8_FILIAL+P8_MAT+ DTOS(P8_DATAAPO) +DTOS(P8_DATA)+STR(P8_HORA,5,2)   	  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += "DTOS("+cPrefixo+"DATAAPO)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	Else                                                                                                                    
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Data  <=> _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	EndIF
	nSetOrder	:= RetOrdem( cAlias , cSetOrdem )
	IF !( nSvIndexOrd == nSetOrder )
		( cAlias )->( dbSetOrder( nSetOrder ) )
	EndIF
                        
 	//-- Se Nao for carregar as marcacoe  pela data de apontamento aumenta a amplitude do periodo
	IF !(lDataApo)
		cIniData	:= Dtos( aTabCalend[ 01			, CALEND_POS_DATA ] - 7 )
		cFimData	:= Dtos( aTabCalend[ nLenTabCal , CALEND_POS_DATA ] + 7 )
	Else
	     //-- Se for carregar as marcacoe pela data de apontamento Nao aumenta a amplitude do periodo                                                                                                           
		cIniData	:= Dtos( aTabCalend[ 01			, CALEND_POS_DATA_APO ] - 7 )
		cFimData	:= Dtos( aTabCalend[ nLenTabCal , CALEND_POS_DATA_APO ] + 7 )
	Endif	    
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria array com as marca‡”es do Periodo para o funcion rio.  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	#IFDEF TOP

		IF !( lExInAs400 )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Monta Query para Carga das Marcacoes                         ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( cAlias == "SP8" )
				IF ( aGetSP8Fields == NIL )
					aGetSP8Fields	:= (cAlias)->( dbStruct() )
					nGetSP8Fields	:= Len( aGetSP8Fields )
					cQrySP8Fields	:= ""
					For nX := 1 To nGetSP8Fields
		        		cQrySP8Fields += aGetSP8Fields[ nX , 01 ] + ", "
					Next nX
				EndIF
				aGetMarcFields	:= aClone( aGetSP8Fields )
				cQryMarcFields	:= cQrySP8Fields
				nGetMarcFields	:= nGetSP8Fields
			ElseIF ( cAlias == "SPG" )
				IF ( aGetSPGFields == NIL )
					aGetSPGFields	:= (cAlias)->( dbStruct() )
					nGetSPGFields	:= Len( aGetSPGFields )
					cQrySPGFields	:= ""
					For nX := 1 To nGetSPGFields
		        		cQrySPGFields += aGetSPGFields[ nX , 01 ] + ", "
					Next nX
				EndIF	
				aGetMarcFields	:= aClone( aGetSPGFields )
				cQryMarcFields	:= cQrySPGFields
				nGetMarcFields	:= nGetSPGFields
			EndIF 
					
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQryMarcFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName(cAlias)
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"  
			
			// Verifica a Data Inicial se nao considera a data de apontamento ou 
			// se a considera e foi solicitada a verificacao da data inicial
			IF !(lDataApo) .or. (lDataApo .and. lDataIni)
				cQuery += " AND "
				cQuery += cPrefixo + "DATA>='"+cIniData+"'"
			Endif
			
			cQuery += " AND "
			cQuery += cPrefixo + "DATA<='"+cFimData+"'"
			IF ( lChkPerAponta )
				cQuery += " AND "
				cQuery += " ( "
				cQuery +=		cPrefixo + "PAPONTA='"+cPerAponta+"'"
				cQuery += 		" OR "
				cQuery +=		cPrefixo + "PAPONTA='"+Space(Len(cPerAponta))+"'"
				cQuery += " ) "
			EndIF
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery(cQuery)
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nGetMarcFields
					IF ( aGetMarcFields[ nX , 02 ] <> "C" )
						TcSetField(cAliasQuery,aGetMarcFields[nX,01],aGetMarcFields[nX,02],aGetMarcFields[nX,03],aGetMarcFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
			EndIF	

		EndIF
			
	#ENDIF

	cFilMat := ( cFil + cMat )

	IF !( lQueryOpened )
		cAliasQuery := cAlias
		( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	EndIF		


        
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem as Marcacoes validas para o Periodo                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	While ( cAliasQuery )->( !Eof() .and. ( &( cPrefixo+"FILIAL+"+cPrefixo+"MAT" ) == cFilMat ) )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verificando a Ordem das Marcacoes                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lOrdem )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ignora Marcacoes nao Ordenadas                               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF Empty( cAtuOrdem := ( cAliasQuery )->( &( cPrefixo+"ORDEM" ) ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem String de Data Hora da Marcacao Referente a Ordem Atual³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cDtHrAtu 	:= ( cAliasQuery )->( DataHora2Str( &( cPrefixo+"DATA" ) , &( cPrefixo+"HORA" ) ) )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ignora Marcacoes Fora dos Limites Considerando a Ordem 	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/     
			//-- Verifica a ordem se nao for checar o periodo de apontamento ou
			//-- se for para checar, mas o periodo de apontamento estah vazio (ou seja verifico a ordem pois a 
			//-- checagem do periodo nao consiguirah verificar se a marcacao se encontra entre os limites do periodo)
			IF !( lChkPerAponta ) .OR. ( lChkPerAponta .and. Empty( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) ) )
				IF (;
						(;
							( cAtuOrdem >= cPriOrdem   ) .and. ( cDtHrAtu < cDtHrLimIni );	//Marcacao de Periodo Posterior
						 ) .or. ;
						 (;
							( cAtuOrdem <= cUltOrdem   ) .and. ( cDtHrAtu > cDtHrLimFim );	//Marcacao de Periodo Anterior
						 );
					)		
					( cAliasQuery )->( dbSkip() )
					Loop
				EndIF
			
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Se for a Primeira Ordem, compara Horarios em Relacao ao Limite³
				³Final da Proxima Ordem									   	   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( cAtuOrdem == cPriOrdem )
					IF Empty( nPosPrxOrd )
						cPrxOrdem	:= StrZero( ( Val( cAtuOrdem ) + 1 ) , __nTamP8Ordem )
						nPosPrxOrd	:= aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cPrxOrdem ) .and.;
																	!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																	( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
														 	  };
									 		)
	                   	IF ( nPosPrxOrd > 0 )
							cDtHrPrxOrd := DataHora2Str(;
															aTabCalend[ nPosPrxOrd , CALEND_POS_LIM_MARCACAO , 01 ],;
															aTabCalend[ nPosPrxOrd , CALEND_POS_LIM_MARCACAO , 02 ];
														)
	    				EndIF
					EndIF
					IF ( nPosPrxOrd > 0 )
						IF ( cDtHrAtu > cDtHrPrxOrd )
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Se for a Ultima Ordem, compara Horarios em Relacao ao   Limite³
				³Inicial da Ordem Anterior       							   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( cAtuOrdem == cUltOrdem )
					IF Empty( nPosAntOrd )
						cAntOrdem	:= StrZero( ( Val( cAtuOrdem ) - 1 ) , __nTamP8Ordem )
						nPosAntOrd	:= aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cAntOrdem ).and.; 
																	( x[ CALEND_POS_TIPO_MARC ] == "1E" );
														 	  };
									 		)
						IF ( nPosAntOrd > 0 )
							cDtHrAntOrd := DataHora2Str(;
															aTabCalend[ nPosAntOrd , CALEND_POS_LIM_MARCACAO , 01 ],;
															aTabCalend[ nPosAntOrd , CALEND_POS_LIM_MARCACAO , 02 ];
														)
						EndIF
					EndIF
					IF ( nPosAntOrd > 0 )
						IF ( cDtHrAtu <= cDtHrAntOrd )
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
			Endif	    
			   
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verificando a Data de Apontamento das Marcacoes              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/			
		ElseIF (lDataApo)
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ignora Marcacoes Sem Data de Apontamento                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF Empty(  cAtuDataApo := Dtos(( cAliasQuery )->( &( cPrefixo+"DATAAPO" ) )) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
		
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ignora Marcacoes Fora dos Limites Considerando a Data de Apontamento ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/     
		       IF lDataIni
					IF (	( cAtuDataApo < cIniData  ) .or. ( cAtuDataApo > cFimData ) )	//Marcacao fora do Periodo de Apontamento
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
			   Else        
			   		IF (	( cAtuDataApo > cFimData ) )	//Marcacao fora do Periodo de Apontamento
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
			   Endif
			   
			
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ignora Marcacoes Fora dos Limites Considerando o Serial      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					( cAliasQuery )->(;
										(;
											nSerMarc := __fDHtoNS( &( cPrefixo+"DATA" ),&( cPrefixo+"HORA" ) );
										);
									  ) < nSerIni;
					.or.;
					( nSerMarc > nSerFim );
				 )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Ignora Marcacoes Fora dos Limites Considerando o Serial      ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					( cAliasQuery )->( dbSkip() )
					Loop
			EndIF
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ignora Marcacoes Fora do Periodo de Apontamento              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lChkPerAponta )
			IF ( !Empty( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) ) .and. ( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) <> cPerAponta ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Deve Carregar as Marcacoes Automaticas           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( !( lGetMarcAuto ) .and. ( cAliasQuery )->( &( cPrefixo+"FLAG" ) == "A" .and. Eval( bCondMarcAut ) ) )
			#IFNDEF TOP
				aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
			#ELSE
				IF !( lQueryOpened )
					aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
				Else
					aAdd( aRecsMarcAut , ( cAliasQuery )->( RECNO ) )
				EndIF
			#ENDIF
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Marcacoes do Funcionario                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aAdd( aMarcacoes , Array( ELEMENTOS_AMARC ) )
		nLenMarc := Len( aMarcacoes )
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATA   ] := &(cPrefixo+"DATA")	)					//01 - Data
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_HORA   ] := &(cPrefixo+"HORA")	)					//02 - Hora
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] := &(cPrefixo+"ORDEM")	)					//03 - Ordem
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FLAG   ] := &(cPrefixo+"FLAG")	)					//04 - Flag
		IF ( lRecno )
			#IFNDEF TOP
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno()  		)					//05 - Recno 
			#ELSE
				IF !( lQueryOpened )
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno() 	)					//05 - Recno 
				Else                                                                                	
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := RECNO		)					//05 - Recno 
				EndIF
			#ENDIF
		Else
			aMarcacoes[ nLenMarc , AMARC_RECNO ] := 0														//05 - Recno
		EndIF
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TURNO		] := &(cPrefixo+"TURNO")	)			//06 - Turno
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FUNCAO		] := &(cPrefixo+"FUNCAO")	)			//07 - Funcao 
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_GIRO		] := &(cPrefixo+"GIRO") 	)			//08 - Giro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CC			] := &(cPrefixo+"CC")		)			//09 - Centro de Custo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_APONTA		] := &(cPrefixo+"APONTA")	)			//10 - Flag de Apontamento
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_RELOGIO		] := &(cPrefixo+"RELOGIO")	)			//11 - Relogio
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOMARC	] := &(cPrefixo+"TPMARCA")	)			//12 - Tipo da Marcacao
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PROCESSO	] := &(cPrefixo+"PROCES")	)			//18 - Processo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ROTEIRO		] := &(cPrefixo+"ROTEIR")	)			//19 - Roteiro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERIODO		] := &(cPrefixo+"PERIODO")	)			//20 - Periodo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_NUM_PAGTO	] := &(cPrefixo+"NUMPAG")	)			//21 - NumPag
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DEPTO		] := &(cPrefixo+"DEPTO")	)			//22 - Depto
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_POSTO		] := &(cPrefixo+"POSTO")	)			//23 - Posto
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CODFUNC		] := &(cPrefixo+"CODFUNC")	)			//24 - Cod. Func.                
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATAAPO		] := &(cPrefixo+"DATAAPO")	)			//25 - Data de Apontamento.   
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se a Marcacao sera ordenada                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lNotOrdena := (;
							( aMarcacoes[ nLenMarc , AMARC_FLAG ] $ "M,I" ) .and.;
							!Empty( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] );
					   )		
		aMarcacoes[ nLenMarc , AMARC_L_ORIGEM ] := lNotOrdena												//13 - Logico Origem 
		aMarcacoes[ nLenMarc , AMARC_DTHR2STR ] := DataHora2Str(;                                           
																	aMarcacoes[ nLenMarc , AMARC_DATA ] ,;
																	aMarcacoes[ nLenMarc , AMARC_HORA ]  ;
																)                                           //14 - String de Data/Hora para aSort
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERAPONTA	] := &(cPrefixo+"PAPONTA")	)		//15 - Periodo de Apontamento
		( cAliasQuery )->( dbSkip() )
	End While

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Fecha a Query e Seta a Area do Arquivo Original              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cAlias )
    EndIF	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura a Ordem de Entrada                                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( nSvIndexOrd == IF( lOrdem , 1 , 2 ) )
		( cAlias )->( dbSetOrder( nSvIndexOrd ) )
	EndIF	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica as Folgas Automaticas apenas Quando Marcacoes ja  ti³
	³ verem Sido Ordenadas										   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lDiasFolga ) .and. ( lOrdem ) )
		cCod036N := PosSP9("036N",cFil,"P9_CODIGO",2)
		fDiasFolga(aClone(aMarcacoes),@aTabCalend,dPerIni,dPerFim,cCod036N,( cAlias == "SPG" ) , lGrvFolgPa )
	EndIF
	
End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura a Area de Entrada                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !Empty( cSvAlias ) 
	dbSelectArea( cSvAlias )
EndIF

Return( lGetMarcOk )  


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetMarcOPC  ³Autor ³ Mauricio MR		  ³ Data ³12/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array aMarcacoes com as Marcacoes do Periodo       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetMarcOpc(@aMarcacoes,...)									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGetMarcOk                         							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetMarcOpc(	aMarcacoes			,;	//01 -> Marcacoes dos Funcionarios
						dPerIni 			,;	//02 -> Periodo Inicial
						dPerFim				,;	//03 -> Periodo Final
						cFil				,;	//04 -> Filial
						cMat				,;	//05 -> Matricula
						cTno				,;	//06 -> Turno
						cSeq				,;	//07 -> Sequencia de Turno
						cCc					,;	//08 -> Centro de Custo
						cAlias				,;	//09 -> Alias para Carga das Marcacoes
						lRecno				,;	//10 -> Se carrega Recno em aMarcacoes
						lGetMarcAuto		,;	//11 -> Se Carrega as Marcacoes Automaticas
						aRecsMarcAut	    ,;	//12 -> Registros de Marcacoes Automaticas que deverao ser Desprezadas
						bCondMarcAut		;	//13 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
					  )

   
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Local cSvAlias			:= Alias()
Local lGetMarcOk 		:= .T.
Local lQueryOpened		:= .F.


/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/      

Local cFilMat
Local cAliasQuery  
Local cPrefixo
Local cDtHrLimIni
Local cDtHrLimFim
Local cDtHrAtu
Local cSetOrdem
Local lNotOrdena    
Local nI
Local nLenMarc
Local nSerMarc
Local nSerIni
Local nSerFim
Local nSvIndexOrd
Local nSetOrder

#IFDEF TOP

	/*/

	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Variaveis de Inicializacao Obrigatoria					  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	Local aGetMarcFields	:= {}

	/*/

	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	Local cQryMarcFields
	Local cIniData
	Local cFimData
	Local cQuery
	Local nGetMarcFields
	Local nX

	Static aGetSP8Fields
	Static cQrySP8Fields
	Static cQrySPGFields
	Static nGetSP8Fields
	Static aGetSPGFields
	Static nGetSPGFields

#ENDIF

DEFAULT cFil				:= SRA->RA_FILIAL
DEFAULT cMat				:= SRA->RA_MAT
DEFAULT cTno				:= SRA->RA_TNOTRAB
DEFAULT cSeq				:= SRA->RA_SEQTURN
DEFAULT dPerIni				:= Ctod("//")
DEFAULT dPerFim				:= Ctod("//")
DEFAULT cAlias				:= "SP8"
DEFAULT lRecno				:= .T.
DEFAULT lGetMarcAuto		:= .T.
DEFAULT bCondMarcAut		:= { || .T. }

aRecsMarcAut				:= {}

nSerIni := __fDHtoNS( dPerIni-7,00.00 )
nSerFim := __fDHtoNS( dPerFim+7,23.59 )
	
Begin Sequence

	
	cAlias			:= Upper( AllTrim( cAlias ) )
	cAliasQuery 	:= cAlias
	cPrefixo		:= ( PrefixoCpo( cAliasQuery ) + "_" )
	aMarcacoes  	:= {}


	/*/

	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seleciona o Arquivo de Marca‡”es e Seta a Ordem corresponden³
	³ te:														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	nSvIndexOrd := ( cAlias )->( IndexOrd() )
	cSetOrdem	:= ""
	/*/

	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Data  <=> _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	cSetOrdem += cPrefixo+"FILIAL+"
	cSetOrdem += cPrefixo+"MAT+"
	cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
	cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 

	nSetOrder	:= RetOrdem( cAlias , cSetOrdem )
	IF !( nSvIndexOrd == nSetOrder )
		( cAlias )->( dbSetOrder( nSetOrder ) )
	EndIF

	/*/

	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria array com as marca‡”es do Periodo para o funcion rio.  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	#IFDEF TOP

		IF !( lExInAs400 )

			/*/
		
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Monta Query para Carga das Marcacoes                         ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		
			IF ( cAlias == "SP8" )
				IF ( aGetSP8Fields == NIL )
					aGetSP8Fields	:= (cAlias)->( dbStruct() )
					nGetSP8Fields	:= Len( aGetSP8Fields )
					cQrySP8Fields	:= ""
					For nX := 1 To nGetSP8Fields
		        		cQrySP8Fields += aGetSP8Fields[ nX , 01 ] + ", "
					Next nX
				EndIF
				aGetMarcFields	:= aClone( aGetSP8Fields )
				cQryMarcFields	:= cQrySP8Fields
				nGetMarcFields	:= nGetSP8Fields
			ElseIF ( cAlias == "SPG" )
				IF ( aGetSPGFields == NIL )
					aGetSPGFields	:= (cAlias)->( dbStruct() )
					nGetSPGFields	:= Len( aGetSPGFields )
					cQrySPGFields	:= ""
					For nX := 1 To nGetSPGFields
		        		cQrySPGFields += aGetSPGFields[ nX , 01 ] + ", "
					Next nX
				EndIF	
				aGetMarcFields	:= aClone( aGetSPGFields )
				cQryMarcFields	:= cQrySPGFields
				nGetMarcFields	:= nGetSPGFields
			EndIF
			cIniData	:= Dtos( dPerIni-7 )
			cFimData	:= Dtos( dPerFim+7 )
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQryMarcFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName(cAlias)
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA>='"+cIniData+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA<='"+cFimData+"'"
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery(cQuery)
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nGetMarcFields
					IF ( aGetMarcFields[ nX , 02 ] <> "C" )
						TcSetField(cAliasQuery,aGetMarcFields[nX,01],aGetMarcFields[nX,02],aGetMarcFields[nX,03],aGetMarcFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
			EndIF	

		EndIF
			
	#ENDIF

	cFilMat := ( cFil + cMat )

	IF !( lQueryOpened )
		cAliasQuery := cAlias
		( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	EndIF		

        
	/*/       

	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem as Marcacoes validas para o Periodo                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	While ( cAliasQuery )->( !Eof() .and. ( &( cPrefixo+"FILIAL+"+cPrefixo+"MAT" ) == cFilMat ) )


		/*/
	
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ignora Marcacoes Fora dos Limites Considerando o Serial      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		IF (;
				( cAliasQuery )->(;
									(;
										nSerMarc := __fDHtoNS( &( cPrefixo+"DATA" ),&( cPrefixo+"HORA" ) );
									);
								  ) < nSerIni;
				.or.;
				( nSerMarc > nSerFim );
			 )
			/*/
		
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ignora Marcacoes Fora dos Limites Considerando o Serial      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	

		/*/   
	
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Deve Carregar as Marcacoes Automaticas           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		IF ( !( lGetMarcAuto ) .and. ( cAliasQuery )->( &( cPrefixo+"FLAG" ) == "A" .and. Eval( bCondMarcAut ) ) )
			#IFNDEF TOP
				aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
			#ELSE
				IF !( lQueryOpened )
					aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
				Else
					aAdd( aRecsMarcAut , ( cAliasQuery )->( RECNO ) )
				EndIF
			#ENDIF
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF

		/*/
	
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Marcacoes do Funcionario                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		aAdd( aMarcacoes , Array( ELEMENTOS_AMARC ) )
		nLenMarc := Len( aMarcacoes )
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATA   ] := &(cPrefixo+"DATA")	)					//01 - Data
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_HORA   ] := &(cPrefixo+"HORA")	)					//02 - Hora
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] := &(cPrefixo+"ORDEM")	)					//03 - Ordem
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FLAG   ] := &(cPrefixo+"FLAG")	)					//04 - Flag
		IF ( lRecno )
			#IFNDEF TOP
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno()  		)					//05 - Recno 
			#ELSE
				IF !( lQueryOpened )
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno() 	)					//05 - Recno 
				Else                                                                                	
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := RECNO		)					//05 - Recno 
				EndIF
			#ENDIF
		Else
			aMarcacoes[ nLenMarc , AMARC_RECNO ] := 0														//05 - Recno
		EndIF
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TURNO		] := &(cPrefixo+"TURNO")	)			//06 - Turno
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FUNCAO		] := &(cPrefixo+"FUNCAO")	)			//07 - Funcao 
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_GIRO		] := &(cPrefixo+"GIRO") 	)			//08 - Giro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CC			] := &(cPrefixo+"CC")		)			//09 - Centro de Custo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_APONTA		] := &(cPrefixo+"APONTA")	)			//10 - Flag de Apontamento
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_RELOGIO		] := &(cPrefixo+"RELOGIO")	)			//11 - Relogio
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOMARC	] := &(cPrefixo+"TPMARCA")	)			//12 - Tipo da Marcacao
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PROCESSO	] := &(cPrefixo+"PROCES")	)			//18 - Processo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ROTEIRO		] := &(cPrefixo+"ROTEIR")	)			//19 - Roteiro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERIODO		] := &(cPrefixo+"PERIODO")	)			//20 - Periodo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_NUM_PAGTO	] := &(cPrefixo+"NUMPAG")	)			//21 - NumPag
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DEPTO		] := &(cPrefixo+"DEPTO")	)			//22 - Depto
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_POSTO		] := &(cPrefixo+"POSTO")	)			//23 - Posto
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CODFUNC		] := &(cPrefixo+"CODFUNC")	)			//24 - Cod. Func.
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATAAPO		] := &(cPrefixo+"DATAAPO")	)			//25 - Data de Apontamento .   


		/*/
	
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se a Marcacao sera ordenada                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		lNotOrdena := (;
							( aMarcacoes[ nLenMarc , AMARC_FLAG ] $ "M,I" ) .and.;
							!Empty( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] );
					   )		
		aMarcacoes[ nLenMarc , AMARC_L_ORIGEM ] := lNotOrdena												//13 - Logico Origem 
		aMarcacoes[ nLenMarc , AMARC_DTHR2STR ] := DataHora2Str(;                                           
																	aMarcacoes[ nLenMarc , AMARC_DATA ] ,;
																	aMarcacoes[ nLenMarc , AMARC_HORA ]  ;
																)                                           //14 - String de Data/Hora para aSort
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERAPONTA	    ] := &(cPrefixo+"PAPONTA")	)		//15 - Periodo de Apontamento
		aMarcacoes[ nLenMarc , AMARC_SEQ	] := SPACE(2)											//16 - Sequencia da Tabela de Horario Padrao (turno opcional) ja identificado
		aMarcacoes[ nLenMarc , AMARC_DIA	] := SPACE(2)											//17 - Dia da semana da Tabela de Horario Padrao (turno opcional) ja identificado
		( cAliasQuery )->( dbSkip() )
	End While

	/*/   

	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Fecha a Query e Seta a Area do Arquivo Original              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
   
    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cAlias )
    EndIF	

	/*/

	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura a Ordem de Entrada                                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	IF !( nSvIndexOrd ==  2  )
		( cAlias )->( dbSetOrder( nSvIndexOrd ) )
	EndIF	

End Sequence

/*/   

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura a Area de Entrada                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

IF !Empty( cSvAlias ) 
	dbSelectArea( cSvAlias )
EndIF
	
Return( lGetMarcOk )  


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetTnoOpc   ³Autor ³ Mauricio MR		  ³ Data ³12/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array com Horario para substituicao do pre-esta-   ³
³          ³belecido em funcao da marcacao realiazada.                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetTnoOpc(cTurno,...)									    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet	                         							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTnoOpc( cTurno,  dData, aDiaTurnoOK, aTabPadrao, aTabTno, cFilSPJ, aMarcacoes)
                
Local aHorOpc
Local aSerial
Local aTemp
Local aTnoSeqDia
Local cOrdem
Local cSeq         
Local nDia  
Local lRet	:= .F.  
Local nHorOpc		 
Local nPos1
Local nPos2
Local nPosTnoOpc		
Local nPosTnoEscolhido 
Local nHora
Local nSerIniTno
Local nSerFimTno 
Local uHora        
Local nSerIni
Local nSerFim
Local nSerMeiaJorn

Begin Sequence 
    nHora	:= aTabTno[01]                                                                   
    cSeq	:= aTabTno[19]
    nDia	:= aTabTno[20]
    
   	//-- Obtem Todos os Horarios para Filial + Turno + Dia
	If (nPosTnoOpc:=Ascan(__aAllTnoOpc,{|x| ( x[1] + x[2] ) == (cFilSPJ + cTurno ) }) ) >  0
    	aHorOpc:=aClone(__aAllTnoOpc[nPosTnoOpc, 3, nDia])
    	AADD(aHorOpc, aTabTno)
		aSort( @aHorOpc , NIL , NIL , { |x,y| ( x[1] < y[1] ) } )    	 
	Else    
	   Break
	Endif
	
	//-- Verifica se existe horario para o turno opcional
    If Empty(aHorOpc)                     
       Break
    Endif   
                                               
	//Obtem os limites maximos possiveis para o dia  
	aSerial		:= fLimitTnoOpc(dData, aHorOpc[ 1 ] )
	nSerIniTno 	:= aSerial[1]                     
	aSerial		:= fLimitTnoOpc(dData, aHorOpc[ Len(aHorOpc) ] )
	nSerFimTno 	:= aSerial[2]
	
	//-- Procura pela primeira marcacao ainda nao verificada
	If (nPos1:= Ascan(aMarcacoes, {|x| EMPTY( x[AMARC_SEQ] )  } ) )  ==   0
	   Break
	Endif   
	nSerIni:=nSerFim:=0
    
    //-- Corre todas as marcacoes a partir da primeira marcacao nao classificada
	For nPos2:= nPos1 To Len(aMarcacoes)

	   	If (! EMPTY( aMarcacoes[nPos2, AMARC_TNOPC] ) )
 	   		Loop
 	   	Endif
 	   	
	    uHora	:= aMarcacoes[nPos2, AMARC_HORA]
	    uHora	:= If( ValType( uHora ) = "C", Val(uHora), uHora )
	    nSerMarc:= __fDHtoNS(aMarcacoes[nPos2, AMARC_DATA], uHora )

	    //-- Verifica se Marcacao esta fora dos limites maximos do turno
	    If nSerMarc < nSerIniTno
	       	Loop

	    ElseIf 	nSerMarc > nSerFimTno
        	Exit
	    Endif
	    
	    //-- Verifica se Marcacao esta entre os limites do turno ja verificado  (se ja foi identificado)
	    If !Empty(nSerIni)
	        If (nSerMarc < nSerIni)
	            Loop
	        ElseIf nSerMarc > nSerFim  .and. aMarcacoes[nPos2, AMARC_ORDEM] <> aMarcacoes[nPos1, AMARC_ORDEM]
	            Exit
	        Else
           		aMarcacoes[nPos2, AMARC_TURNO]	:= cTurno
		        aMarcacoes[nPos2, AMARC_SEQ] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
		   		aMarcacoes[nPos2, AMARC_DIA] 	:= aHorOpc[ nPosTnoEscolhido, 20 ]
		   		aMarcacoes[nPos2, AMARC_TNOPC] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
		        Loop
	        Endif
	    Endif
	    
   	    //-- Verifica a qual das entradas possiveis para o turno a marcacao mais se aproxima
    	aTemp := {} 
    	For nHorOpc  := 1 To Len(aHorOpc)   
	    	aAdd( aTemp , { nHorOpc , DataHora2Val( 	aMarcacoes[nPos2, AMARC_DATA]	,;
													 	uHora							,;
													 	dData							,;
													 	aHorOpc[ nHorOpc , 01 ]	    	,;
													 	"H"							 	;
												  );
							};											  
			 	)
		Next nHorOpc
		
		aSort( aTemp , NIL , NIL , { |x,y| x[2] < y[2] } )		
                            
        //--Gera o Limite do Turno Selecionado para o Dia
		nPosTnoEscolhido 	:= aTemp[1,1]
		aSerial				:= fLimitTnoOpc(dData, aHorOpc[ nPosTnoEscolhido], .T. )
	    nSerIni				:= aSerial[1]
	    nSerFim				:= aSerial[2]  
        nSerMeiaJorn		:= aSerial[3]  
        
   		//-- Verifica se a Marcacao esta fora dos limites do turno (Entre o HorMenos e a MeiaJornada)
	    If ( nSerMarc < nSerIni .or.  nSerMarc > nSerMeiaJorn )
	       Loop                                                                     
	    Endif   
   		
   		aMarcacoes[nPos2, AMARC_TURNO]	:= cTurno 	    
        aMarcacoes[nPos2, AMARC_SEQ] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
   		aMarcacoes[nPos2, AMARC_DIA] 	:= aHorOpc[ nPosTnoEscolhido, 20 ]
   		
        aDiaTurnoOK[ Len(aDiaTurnoOK), 2 ]  	:= {cTurno, aHorOpc[ nPosTnoEscolhido, 19 ], aHorOpc[ nPosTnoEscolhido, 20 ] }
	    
	    aTabTno[01] 	:=aHorOpc[ nPosTnoEscolhido][01]		// 01 - 1a Entrada
		aTabTno[02] 	:=aHorOpc[ nPosTnoEscolhido][02]		// 02 - 1a Saida
		aTabTno[03] 	:=aHorOpc[ nPosTnoEscolhido][03]		// 03 - 2a Entrada
		aTabTno[04] 	:=aHorOpc[ nPosTnoEscolhido][04]		// 04 - 2a Saida
		aTabTno[05] 	:=aHorOpc[ nPosTnoEscolhido][05]		// 05 - 3a Entrada
		aTabTno[06] 	:=aHorOpc[ nPosTnoEscolhido][06]		// 06 - 3a Saida
		aTabTno[07] 	:=aHorOpc[ nPosTnoEscolhido][07]		// 07 - 4a Entrada
		aTabTno[08] 	:=aHorOpc[ nPosTnoEscolhido][08]		// 08 - 4a Saida
		aTabTno[09] 	:=aHorOpc[ nPosTnoEscolhido][09]		// 09 - Horas Trabalhadas 1a. Jornada
		aTabTno[10] 	:=aHorOpc[ nPosTnoEscolhido][10]		// 10 - Horas Trabalhadas 2a. Jornada
		aTabTno[11] 	:=aHorOpc[ nPosTnoEscolhido][11]		// 11 - Horas Trabalhadas 3a. Jornada
		aTabTno[12] 	:=aHorOpc[ nPosTnoEscolhido][12]		// 12 - Horas Trabalhadas 4a. Jornada
		aTabTno[13] 	:=aHorOpc[ nPosTnoEscolhido][13]		// 13 - Horas de Intervalo 1S
		aTabTno[14] 	:=aHorOpc[ nPosTnoEscolhido][14]		// 14 - Horas de Intervalo 2S
		aTabTno[15] 	:=aHorOpc[ nPosTnoEscolhido][15]		// 15 - Horas de Intervalo 3S
		aTabTno[16] 	:= ""									// 16 - Marcacao e do dia seguinte ?
		aTabTno[17] 	:=aHorOpc[ nPosTnoEscolhido][17]		// 17 - Numero de Marcacoes
		aTabTno[29] 	:=aHorOpc[ nPosTnoEscolhido][29]		// 29 - Aponta Nona Hora
		aTabTno[30] 	:=aHorOpc[ nPosTnoEscolhido][30]		// 30 - Limite de Horario Inicial
		aTabTno[31] 	:=aHorOpc[ nPosTnoEscolhido][31]		// 31 - Limite de Horario Final
		aTabTno[32] 	:=aHorOpc[ nPosTnoEscolhido][32]		// 32 - 1a. Jornada Continua
		aTabTno[33] 	:=aHorOpc[ nPosTnoEscolhido][33]		// 33 - 2a. Jornada Continua
		aTabTno[34]		:=aHorOpc[ nPosTnoEscolhido][34]		// 34 - 3a. Jornada Continua
		aTabTno[35]		:=aHorOpc[ nPosTnoEscolhido][35]		// 35 - 4a. Jornada Continua
		aTabTno[36]		:=aHorOpc[ nPosTnoEscolhido][36]		// 36 - Codigo da Refeicao
	  
	    lRet	:= .T.
	Next nPos2
End

Return (lRet)   

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fLimitTnoOpc³Autor ³ Mauricio MR		  ³ Data ³12/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array com os limites do dia para a identificacao   ³
³          ³de horario para Turnos Opcionais do funcionario.            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fLimitTnoOpc(dDataTno, aTabTno)							    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Array  com os limites {nSerialIni, nSerialFim}	 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fLimitTnoOpc(dDataTno, aTabTno, lMeiaJorn)

Local dData		:=	dDataTno
Local dDataI		
Local dDataF			
Local nY
Local nFornY    := 8 // 1E, 1S...4E,4S.
Local nSerialIni
Local nSerialFim    
Local nSeriaMeiaJorn
Local nHoraI			
Local nHoraF			
Local nDifHrs 		

Local aMeiaJorn		
Local aRetorno		
   
DEFAULT lMeiaJorn	:= .F.

    /*/
    
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Loop For/Next para a Carga das Marcacoes do Dia             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
	
	For nY := 1 To nFornY

		/*/
		
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Abandona Quando as Marcacoes estiverem Vazias e Nao For  Jor³
		³ nada Continua												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		IF (;
				( ( nY == 3 ) .and. ( ( aTabTno[ 03 ] + aTabTno[  04 ] ) == 0 ) .and. ( aTabTno[ 33 ] != "S" ) ) .or. ;
		   		( ( nY == 5 ) .and. ( ( aTabTno[ 05 ] + aTabTno[  06 ] ) == 0 ) .and. ( aTabTno[ 34 ] != "S" ) ) .or. ;
		   		( ( nY == 7 ) .and. ( ( aTabTno[ 07 ] + aTabTno[  08 ] ) == 0 ) .and. ( aTabTno[ 35 ] != "S" ) )      ;
		   	)	
			Exit
		EndIF

		/*/
	
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Incrementa dData e nDias Quando Marcacao for do Dia Seguinte³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		IF ( aTabTno[ nY ] <  aTabTno[ IF( nY == 1 , nY , nY-1 ) ] )
			++dData
		EndIF

		/*/
		
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Incrementa dData e nDias Caso Jornada Continua			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		IF (;
				 (;
							( ( nY == 2 ) .and. ( aTabTno[ 32 ] == "S" ) ) .or. ;
		   		  	    	( ( nY == 4 ) .and. ( aTabTno[ 33 ] == "S" ) ) .or. ;
		   			    	( ( nY == 6 ) .and. ( aTabTno[ 34 ] == "S" ) ) .or. ;
		   			    	( ( nY == 8 ) .and. ( aTabTno[ 35 ] == "S" ) )	   ;
		   		 );
		   	)
			++dData
		EndIF

		IF ( nY == 1 )
			nSerialIni		:= ( __fDhToNS( dData , aTabTno[ nY ] ) - __fDhToNS( NIL , aTabTno[ 30 ] ) )
			If lMeiaJorn
				dDataI		:= dData
				nHoraI		:= aTabTno[ nY ]
			Endif	
		EndIF
	Next nY
	nSerialFim		:= ( __fDhToNS( dData , aTabTno[ Min(nY-1, nFornY) ] ) + __fDhToNS( NIL ,aTabTno[ 31 ] ) )

	If lMeiaJorn
		dDataF			:= dData
		nHoraF			:= aTabTno[ Min(nY-1, nFornY) ]	
		
		nDifHrs 		:= DataHora2Val(dDataI,	nHoraI,	dDataF, nHoraF)
		nDifHrs 		:= __NoRound( nDifHrs/2 , 0 )
		nDifHrs 		:= __Min2Hrs( nDifHrs )
	
		aMeiaJorn		:= RetFimTab(dDataI, nHoraI, nDifHrs )										
		nSeriaMeiaJorn	:= __fDhToNS( aMeiaJorn[1] , aMeiaJorn[2] )
	    aRetorno		:= {nSerialIni, nSerialFim, nSeriaMeiaJorn }
    Else
	    aRetorno		:= {nSerialIni, nSerialFim, Nil } 
    Endif
    
Return( aRetorno )


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³LoadTnoOpc  ³Autor ³ Mauricio MR		  ³ Data ³12/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array com os horarios dos turnos opcionais de um   ³
³          ³turno.												        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³LoadTnoOpc(cFilSPJ, ...)								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet											 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/       
 
Static Function LoadTnoOpc(cFilSPJ, cTurno,__aAllTnoOpc, aTabPadrao) 
Local aSeq			:= {}
Local aSR6Info		:= {"R6_TNOOPC"} //01 -> Turno Opcional
Local cTnoOpc		:= ""
Local lRet			:= .F.
Local nPosAllTnoOpc
Local nPosSeq
Local nPosTabPad


Begin Sequence
	//-- Verifica se Turno ainda nao foi carregado
	If (nPosAllTnoOpc	:= Ascan(__aAllTnoOpc, {|x| x[1] == cFilSPJ .And. x[2] == cTurno } ) ) ==  0
	    //-- Verifica se trata de um turno opcional
	    aSr6Info:= PosSR6( cTurno , cFilSPJ , aSr6Info , 01 , .F. )
	    cTnoOpc:= aSr6Info[1]
	    If !Empty( cTnoOpc )
		    If (nPosTabPad	:= aScan(aTabPadrao, { |x| x[1] == cFilSPJ .And. x[2] == cTnoOpc })) == 0  
		   	   	/*/   
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega a Tabela Para o turno ainda nao carregado           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				fTabPadrao( @aTabPadrao , cFilSPJ , cTnoOpc, .T. ) 
			    If (nPosTabPad:= aScan(aTabPadrao, { |x| x[1] == cFilSPJ .And. x[2] == cTnoOpc })) == 0
			       Break
			    Endif
			Endif
		
			//-- Monta Tabela de Horarios Opcionais para o turno lido
			AADD(__aAllTnoOpc, {cFilSPJ, cTurno, Array(7,1) } )  
			nPosAllTnoOpc	:= Len(__aAllTnoOpc)
 		    Aeval(__aAllTnoOpc[ nPosAllTnoOpc,3 ], { |x| x:= {} } )
		   	aSeq		:= aClone( aTabPadrao[ nPosTabPad, 3 ] )
		   	For nPosSeq := 1 To Len(aSeq)  
		   	  	AADD(__aAllTnoOpc[nPosAllTnoOpc, 3, aSeq[nPosSeq, 20] ],  aClone( aSeq[nPosSeq] )  )	   		
		   	Next  
		    lRet:= .T.		   	
		Endif   	
	Else                        
	    lRet:= .T.		   	
	Endif       
End

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PutMarcacoes³Autor ³ Marinaldo de Jesus   ³ Data ³03/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gravar o Array aMarcacoes                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

Function PutMarcacoes(	aMarcacoes	,;	//01 -> Array contendo as Marcacoes do Funcionario
						cFil		,;	//02 -> Filial do Funcionario
						cMat		,;	//03 -> Matricula do Funcionario
						cAlias		,;	//04 -> Arquivo para Gravacao ( "SP8" ou "SPG" )
						lNewRec		,;	//05 -> Se Forca a Inclusao de Novo Registro
						lSubsDtHr	,;	//06 -> Se Forca a Substituicao da Data/Hora
						nPosIni		,;	//07 -> Posicao Inicial para o aMarcacoes
						lSubsAll	 ;	//08 -> Se Forca a Substituicao de Tudo
					 )

Local cSvFilAnt := cFilAnt

Local aArea
Local cChave
Local cPrefixo
Local cSetOrdem
Local lGoto
Local lAddNew
Local lLock
Local nCount
Local nLenMarc
Local nOrder

#IFDEF TOP
	Local aCposChar
	Local aTamHora
	Local cTableName
	Local cCpoRecno
	Local cQryUpdate	
	Local nCpoChar
	Local nCposChar
#ENDIF

DEFAULT aMarcacoes	:= {}
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT cAlias		:= "SP8"
DEFAULT lNewRec		:= .F.
DEFAULT lSubsDtHr	:= .F.
DEFAULT nPosIni		:= 1
DEFAULT lSubsAll	:= .F.

cAlias	    := Upper( AllTrim( cAlias ) )
cPrefixo	:= ( PrefixoCpo( cAlias ) + "_" )
cFilAnt		:= IF( !Empty( cFil ) , cFil , cFilAnt )

#IFDEF TOP

	IF !( lExInAs400 )

		aTamHora	:= TamSx3( cPrefixo+"HORA" )
		cTableName	:= InitSqlName( cAlias )
		cCpoRecno	:= IF( lExInAs400 , "RRN("+cTableName+")", "R_E_C_N_O_" )
		cQryUpdate	:= ""

	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Garanto que Filial e Matricula nao Terao Strings Nulas de  for³
	³ma a Evitar erro no UpDate quando Base em TOP                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cFil	:= Padr( cFil	, GetSx3Cache( cPrefixo+"FILIAL"	, "X3_TAMANHO" ) )
	cMat	:= Padr( cMat	, GetSx3Cache( cPrefixo+"MAT"		, "X3_TAMANHO" ) )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Obtenho o Tamanho dos Campos Char para garantir que no  Update³
	³nao Ocorra erro de NULLL quando Base em TOP                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aCposChar := {}
	aAdd( aCposChar , { AMARC_FLAG		, GetSx3Cache( cPrefixo+"FLAG"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_FUNCAO	, GetSx3Cache( cPrefixo+"FUNCAO"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_GIRO		, GetSx3Cache( cPrefixo+"GIRO"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_CC		, GetSx3Cache( cPrefixo+"CC" 		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_RELOGIO	, GetSx3Cache( cPrefixo+"RELOGIO"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_ORDEM		, GetSx3Cache( cPrefixo+"ORDEM" 	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_TURNO		, GetSx3Cache( cPrefixo+"TURNO" 	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_APONTA	, GetSx3Cache( cPrefixo+"APONTA"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_TIPOMARC	, GetSx3Cache( cPrefixo+"TPMARCA"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_PROCESSO	, GetSx3Cache( cPrefixo+"PROCES"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_ROTEIRO	, GetSx3Cache( cPrefixo+"ROTEIR"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_PERIODO	, GetSx3Cache( cPrefixo+"PERIODO"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_NUM_PAGTO	, GetSx3Cache( cPrefixo+"NUMPAG"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_DEPTO		, GetSx3Cache( cPrefixo+"DEPTO"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_POSTO		, GetSx3Cache( cPrefixo+"POSTO"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_CODFUNC	, GetSx3Cache( cPrefixo+"CODFUNC"	, "X3_TAMANHO" ) } )	     
	
	nCposChar := Len( aCposChar )

#ENDIF

aArea 		:= ( cAlias )->( GetArea() )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Seleciona o Arquivo de Marca‡”es e Seta a Ordem corresponden³
³te: _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cSetOrdem	:= cPrefixo+"FILIAL+"
cSetOrdem	+= cPrefixo+"MAT+"
cSetOrdem	+= "DTOS("+cPrefixo+"DATA)+"
cSetOrdem	+= "STR("+cPrefixo+"HORA,5,2)" 

nOrder		:= RetOrdem( cAlias , cSetOrdem )	

IF !( aArea[2] == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIF	

nLenMarc := Len( aMarcacoes )
For nCount := nPosIni To nLenMarc
	#IFDEF TOP
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Garanto que os Campos Char nao Terao Strings Nulas de forma  a³
		³ma a Evitar erro no UpDate quando Base em TOP                 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		For nCpoChar := 1 To nCposChar
			aMarcacoes[ nCount , aCposChar[ nCpoChar , 1 ] ] := Padr( aMarcacoes[ nCount , aCposChar[ nCpoChar , 1 ] ] , aCposChar[ nCpoChar , 2 ] )
		Next nCpoChar
	#ENDIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se nao estiver forcando a Inclusao de um Novo Registro		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lNewRec )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Posiciona no Registro a ser Alteradao e seta a Inclusao   como³
		³False (.F.)												   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lGoto := ( ValType( aMarcacoes[ nCount , AMARC_RECNO ] ) == "N" .and. !Empty( aMarcacoes[ nCount , AMARC_RECNO ] ) ) )
			#IFNDEF TOP
				( cAlias )->( dbGoto( aMarcacoes[ nCount , AMARC_RECNO ] ) )
			#ELSE
				IF ( lExInAs400 )
					( cAlias )->( dbGoto( aMarcacoes[ nCount , AMARC_RECNO ] ) )
				EndIF
			#ENDIF
			lAddNew	:= .F.
		Else
			cChave	:= ( cFil + cMat + Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + Str( aMarcacoes[ nCount , AMARC_HORA ] , 5 , 2 ) )
			lAddNew := !( ( cAlias )->( dbSeek( cChave , .F. ) ) )
		EndIF
	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Forca a Inclusao de um novo Registro						   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lAddNew := .T.
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Trava o Registro conforme lAddNew   						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	#IFNDEF TOP
		lLock := ( cAlias )->( RecLock( cAlias , lAddNew , .F. ) )
	#ELSE
		IF (;
				( lAddNew );
				.or.;
				( lExInAs400 );
			)
			lLock := ( cAlias )->( RecLock( cAlias , lAddNew , .F. ) )
		Else
			lLock := .T.
		EndIF
	#ENDIF	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se nao Consegui o Lock Tenta o Proximo						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lLock )
		Loop
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Grava as Informacoes                						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF (;
			( lAddNew );
			.or.;
			( lSubsAll  );
		)
		#IFNDEF TOP
			( cAlias )->( &( cPrefixo+"FILIAL"  ) )	:= cFil
			( cAlias )->( &( cPrefixo+"MAT"	    ) )	:= cMat
			( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
			( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
			( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao
			( cAlias )->( &( cPrefixo+"FUNCAO"  ) )	:= aMarcacoes[ nCount , AMARC_FUNCAO	]	//07 - Funcao do Relogio
			( cAlias )->( &( cPrefixo+"GIRO"    ) )	:= aMarcacoes[ nCount , AMARC_GIRO    	]	//08 - Giro do Relogio
			( cAlias )->( &( cPrefixo+"CC"      ) )	:= aMarcacoes[ nCount , AMARC_CC      	]	//09 - Centro de Custo da Marcacao
			( cAlias )->( &( cPrefixo+"RELOGIO" ) )	:= aMarcacoes[ nCount , AMARC_RELOGIO 	]	//11 - Relogio da Marcacao
			( cAlias )->( &( cPrefixo+"PROCES"	) )	:= aMarcacoes[ nCount , AMARC_PROCESSO	] 	//18 - Processo
			( cAlias )->( &( cPrefixo+"ROTEIR"  ) )	:= aMarcacoes[ nCount , AMARC_ROTEIRO	] 	//19 - Roteiro
			( cAlias )->( &( cPrefixo+"PERIODO" ) )	:= aMarcacoes[ nCount , AMARC_PERIODO	] 	//20 - Periodo
			( cAlias )->( &( cPrefixo+"NUMPAG"  ) )	:= aMarcacoes[ nCount , AMARC_NUM_PAGTO	] 	//21 - NumPag
			( cAlias )->( &( cPrefixo+"DEPTO"   ) )	:= aMarcacoes[ nCount , AMARC_DEPTO		] 	//22 - Depto
			( cAlias )->( &( cPrefixo+"POSTO"   ) )	:= aMarcacoes[ nCount , AMARC_POSTO		] 	//23 - Posto
			( cAlias )->( &( cPrefixo+"CODFUNC" ) )	:= aMarcacoes[ nCount , AMARC_CODFUNC	] 	//24 - Cod. Func.
			( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	] 	//25 - Data de Apontamento
						
		#ELSE
			IF (;
					( lAddNew );
					.or.;
					( lExInAs400 );
				)
				( cAlias )->( &( cPrefixo+"FILIAL"  ) )	:= cFil
				( cAlias )->( &( cPrefixo+"MAT"	    ) )	:= cMat
				( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
				( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
				( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao
				( cAlias )->( &( cPrefixo+"FUNCAO"  ) )	:= aMarcacoes[ nCount , AMARC_FUNCAO	]	//07 - Funcao do Relogio
				( cAlias )->( &( cPrefixo+"GIRO"    ) )	:= aMarcacoes[ nCount , AMARC_GIRO    	]	//08 - Giro do Relogio
				( cAlias )->( &( cPrefixo+"CC"      ) )	:= aMarcacoes[ nCount , AMARC_CC      	]	//09 - Centro de Custo da Marcacao
				( cAlias )->( &( cPrefixo+"RELOGIO" ) )	:= aMarcacoes[ nCount , AMARC_RELOGIO 	]	//11 - Relogio da Marcacao
				( cAlias )->( &( cPrefixo+"PROCES"	) )	:= aMarcacoes[ nCount , AMARC_PROCESSO  ] 	//18 - Processo
				( cAlias )->( &( cPrefixo+"ROTEIR"  ) )	:= aMarcacoes[ nCount , AMARC_ROTEIRO	] 	//19 - Roteiro
				( cAlias )->( &( cPrefixo+"PERIODO" ) )	:= aMarcacoes[ nCount , AMARC_PERIODO	] 	//20 - Periodo
				( cAlias )->( &( cPrefixo+"NUMPAG"  ) )	:= aMarcacoes[ nCount , AMARC_NUM_PAGTO	] 	//21 - NumPag
				( cAlias )->( &( cPrefixo+"DEPTO"   ) )	:= aMarcacoes[ nCount , AMARC_DEPTO		] 	//22 - Depto
				( cAlias )->( &( cPrefixo+"POSTO"   ) )	:= aMarcacoes[ nCount , AMARC_POSTO		] 	//23 - Posto
				( cAlias )->( &( cPrefixo+"CODFUNC" ) )	:= aMarcacoes[ nCount , AMARC_CODFUNC	] 	//24 - Cod. Func. 
				( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	] 	//25 - Data de Apontamento
			
							
			Else
				cQryUpdate := "UPDATE "
				IF ( lExInAs400 )
					cQryUpdate += _cDataBase+"/"+cTableName
				Else
					cQryUpdate += cTableName
				EndIF	
				cQryUpdate += " SET "
				cQryUpdate += cPrefixo +"FILIAL='"	+ cFil + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"MAT='"		+ cMat + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"DATA='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"HORA="		+ Str(  aMarcacoes[ nCount , AMARC_HORA ] , aTamHora[1] , aTamHora[2] )
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"FLAG='"	+ aMarcacoes[ nCount , AMARC_FLAG    	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"FUNCAO='"	+ aMarcacoes[ nCount , AMARC_FUNCAO		] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"GIRO='"	+ aMarcacoes[ nCount , AMARC_GIRO   	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"CC='"		+ aMarcacoes[ nCount , AMARC_CC      	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"RELOGIO='"	+ aMarcacoes[ nCount , AMARC_RELOGIO	] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"PROCES"		+ aMarcacoes[ nCount , AMARC_PROCESSO	] + "'"	
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"ROTEIR"     + aMarcacoes[ nCount , AMARC_ROTEIRO	] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"PERIODO"    + aMarcacoes[ nCount , AMARC_PERIODO	] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"NUMPAG"     + aMarcacoes[ nCount , AMARC_NUM_PAGTO	] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"DEPTO"      + aMarcacoes[ nCount , AMARC_DEPTO		] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"POSTO"      + aMarcacoes[ nCount , AMARC_POSTO		] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"CODFUNC"    + aMarcacoes[ nCount , AMARC_CODFUNC	] + "'"            
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"DATAAPO"    + aMarcacoes[ nCount , AMARC_DATAAPO	] + "'"
				
		
			EndIF
		#ENDIF
	ElseIF ( lSubsDtHr )
		#IFNDEF TOP
			( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
			( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
		#ELSE
			IF ( lExInAs400 )
				( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
				( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
			Else
				cQryUpdate := "UPDATE "
				IF ( lExInAs400 )
					cQryUpdate += _cDataBase+"/"+cTableName
				Else
					cQryUpdate += cTableName
				EndIF	
				cQryUpdate += " SET "
				cQryUpdate += cPrefixo +"DATA='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"HORA="		+ Str(  aMarcacoes[ nCount , AMARC_HORA ] , aTamHora[1] , aTamHora[2] )
			EndIF
		#ENDIF
	EndIF
	#IFNDEF TOP
		( cAlias )->( &( cPrefixo+"ORDEM"   ) )	:= aMarcacoes[ nCount , AMARC_ORDEM   	]	//03 - Ordem da Marcacao
		( cAlias )->( &( cPrefixo+"TURNO"   ) )	:= aMarcacoes[ nCount , AMARC_TURNO		]	//06 - Turno da Marcacao
		( cAlias )->( &( cPrefixo+"APONTA"  ) )	:= aMarcacoes[ nCount , AMARC_APONTA  	]	//10 - Flag de Marcacao Apontada
		( cAlias )->( &( cPrefixo+"TPMARCA" ) )	:= aMarcacoes[ nCount , AMARC_TIPOMARC	]	//12 - Tipo da Marcacao
		( cAlias )->( &( cPrefixo+"PAPONTA" ) )	:= aMarcacoes[ nCount , AMARC_PERAPONTA	]	//15 - String de Data com o Periodo de Apontamento
		( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao 
		( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	] 	//25 - Data de Apontamento			
		
	#ELSE
		IF (;
				( lAddNew );
				.or.;
				( lExInAs400 );
			)
			( cAlias )->( &( cPrefixo+"ORDEM"   ) )	:= aMarcacoes[ nCount , AMARC_ORDEM   	]	//03 - Ordem da Marcacao
			( cAlias )->( &( cPrefixo+"TURNO"   ) )	:= aMarcacoes[ nCount , AMARC_TURNO		]	//06 - Turno da Marcacao
			( cAlias )->( &( cPrefixo+"APONTA"  ) )	:= aMarcacoes[ nCount , AMARC_APONTA  	]	//10 - Flag de Marcacao Apontada
			( cAlias )->( &( cPrefixo+"TPMARCA" ) )	:= aMarcacoes[ nCount , AMARC_TIPOMARC	]	//12 - Tipo da Marcacao
			( cAlias )->( &( cPrefixo+"PAPONTA" ) )	:= aMarcacoes[ nCount , AMARC_PERAPONTA	]	//15 - String de Data com o Periodo de Apontamento
			( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao  
			( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	] 	//25 - Data de Apontamento
							
		Else
			IF Empty( cQryUpdate )
				cQryUpdate := "UPDATE "
				IF ( lExInAs400 )
					cQryUpdate += _cDataBase+"/"+cTableName
				Else
					cQryUpdate += cTableName
				EndIF
				cQryUpdate += " SET "
			Else
				cQryUpdate += ", "
			EndIF
			cQryUpdate += cPrefixo +"ORDEM = '"	+ aMarcacoes[ nCount , AMARC_ORDEM   	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"TURNO= '"	+ aMarcacoes[ nCount , AMARC_TURNO		] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"APONTA = '"	+ aMarcacoes[ nCount , AMARC_APONTA  	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"TPMARCA = '"	+ aMarcacoes[ nCount , AMARC_TIPOMARC	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"PAPONTA = '"	+ aMarcacoes[ nCount , AMARC_PERAPONTA	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"FLAG = '"	+ aMarcacoes[ nCount , AMARC_FLAG    	] + "'"     
			cQryUpdate += ", "				
			cQryUpdate += cPrefixo+"DATAAPO = '"    + Dtos(aMarcacoes[ nCount , AMARC_DATAAPO	]) + "'"
			
		EndIF
	#ENDIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Destrava o Registro                 						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	#IFNDEF TOP
		( cAlias )->( MsUnlock() )
	#ELSE
		IF (;
				( lAddNew );
				.or.;
				( lExInAs400 );
			)
			( cAlias )->( MsUnlock() )
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Substitui os valores                						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !Empty( cQryUpdate )
				cQryUpdate += " WHERE " 
				cQryUpdate += cCpoRecno + "=" + Str( aMarcacoes[ nCount , AMARC_RECNO ] , 10 , 0 )
				TcSqlExec( cQryUpdate )
				cQryUpdate := ""
			EndIF
		EndIF
	#ENDIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Grava o Recno no aMarcacoes         						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF (;
			( lAddNew );
			.or.;
			Empty( aMarcacoes[ nCount , AMARC_RECNO ] );
		)
		aMarcacoes[ nCount , AMARC_RECNO ] := ( cAlias )->( Recno() )						//05 - Recno
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³lAddNew eh Setada como .F.          						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lAddNew := .F.
Next nCount
( cAlias )->( dbSetOrder( aArea[ 02 ] ) )

cFilAnt := cSvFilAnt

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerAponta³ Autor ³ Marinaldo de Jesus  ³ Data ³27/09/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ListBox com a Selecao dos Periodos de Apontamento           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetPerAponta( nNumPerAnt , cFil , cMat , lReturn , uMvPar )	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Se Validacao .T. c.c. Array com os Periodos de Apontamento  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³nNumPerAnt	- Numero de Periodos a Serem Listados			³
³          ³cFil		- Filial do Funcionario							³
³          ³cMat		- Matricula do Funcionario						³
³          ³lReturn		- Retorno Logico Quando Validacao				³
³          ³uMvPar	    - Opcional.Variavel Receptora do Valor da Opcao ³  
³          ³              Escolhida.                                    ³  
³          ³aPerSPO     - Periodos do SPO                       		³  
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerAponta( nNumPerAnt , cFil , cMat , lReturn , lSelectOne , uMvPar , aPerSPO )

Local aAreaSRA		:= {}
Local aPeriodos		:= {}
Local aShowPer		:= {}
Local bAscPer		:= { |x| x[1] == dPerIni .and. x[2] == dPerFim }
Local cMvParDef		:= ""
Local dAdmissa		:= Ctod("//")
Local dPerIni		:= Ctod("//")
Local dPerFim		:= Ctod("//")
Local lItera		:= .T.
Local lFunc			:= .T.
Local lMvPar		:= !( uMvPar == NIL )
Local lPerCompleto	:= .F.
Local nPer			:= 0
Local nPerSPO		:= 0
Local nItera		:= 0

DEFAULT nNumPerAnt	:= 12
DEFAULT lReturn		:= .T.
DEFAULT lSelectOne	:= .T.
DEFAULT aPerSPO		:= {}

uMvPar	:= IF( lReturn , IF( !lMvPar , &( Alltrim( ReadVar() ) ) , uMvPar ) , "" )

IF ( lReturn )
	CursorWait()
EndIF	

IF ( lFunc := ( cFil != NIL .and. cMat != NIL ) )
	aAreaSRA := SRA->( GetArea() )
	IF !( SRA->( RA_FILIAL+RA_MAT == cFil+cMat ) )
		SRA->( dbSetOrder( RetOrdem("SRA") ) )
		SRA->( dbSeek( cFil + cMat ) )
	EndIF
	dAdmissa := fDtaAdmis()
	SRA->( dbSetOrder( aAreaSRA[ 02 ] ) )
EndIF		

IF ( lMvPar )
	aAdd( aPeriodos, { Stod( SubStr( uMvPar , 1 , 8 ) ) , Stod( SubStr( uMvPar , 9 , 8 ) ) } )
EndIF

IF !GetPonMesDat( @dPerIni , @dPerFim , cFil )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ,  .F. , @lPerCompleto )
EndIF

IF ( aScan( aPeriodos , bAscPer ) == 0 )
	aAdd( aPeriodos, { dPerIni , dPerFim } )
EndIF

IF ( ( nPerSPO := Len( aPerSPO ) ) > 0 )
	aSort( aPerSPO , NIL , NIL , { |x,y| Dtos(x[1])+Dtos(x[2]) > Dtos(y[1])+Dtos(y[2]) } )
EndIF
	
While ( lItera )

	++nItera
    
	IF ( lItera := ( --nNumPerAnt > 0 ) )
		IF ( nPerSPO == 0 )
			IF !( lItera := !( IF( lFunc , --dPerIni < dAdmissa , ( --dPerIni , .F. ) ) ) )
				Exit
			EndIF
			IF ( !( lPerCompleto ) .and. ( nItera == 1 ) )
				PerAponta( dPerIni , dPerFim , dPerIni , NIL , cFil , .F. , @lPerCompleto )
			EndIF
			IF ( lPerCompleto )
				PonIncDate( @dPerIni , @dPerFim )
			Else
				PerAponta( @dPerIni , @dPerFim , dPerIni , NIL , cFil , .T. , NIL )
			EndIF
		Else
			IF !( lItera := ( ++nPer <= nPerSPO ) )
				Exit
			EndIF	
			dPerIni := aPerSPO[ nPer , 01 ]
			dPerFim := aPerSPO[ nPer , 02 ]
			IF !( lItera := !( IF( lFunc , dPerIni < dAdmissa , .F. ) ) )
				Exit
			EndIF
		EndIF
		IF ( aScan( aPeriodos , bAscPer ) == 0 )
			aAdd( aPeriodos, { dPerIni , dPerFim } )
		EndIF
	EndIF

End While

IF !Empty( aPeriodos )
	aSort( aPeriodos , NIL , NIL , { |x,y| Dtos(x[1])+Dtos(x[2]) < Dtos(y[1])+Dtos(y[2]) } )
	aEval( aPeriodos , { |x| aAdd( aShowPer , Dtoc(x[1])+ STR0067 + Dtoc(x[2]) ) , ( cMvParDef += Dtos(x[1])+Dtos(x[2]) ) } )
EndIF

IF ( lReturn )
	CursorArrow()
	IF f_Opcoes( @uMvPar , STR0100 , aShowPer , cMvParDef , 12 , 49 , lSelectOne , 16 , ( 16 * nNumPerAnt ) ) //Periodos de Apontamento
		IF ( !Empty( uMvPar := StrTran( uMvPar , "*" , "" ) ) .and. !( lMvPar ) )
			&( ReadVar() ) := uMvPar
		EndIF
	EndIF	
EndIF

Return( IF( lReturn , lReturn , aPeriodos ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetSerIni   ³Autor ³ Marinaldo de Jesus   ³ Data ³26/06/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Numero Serial p/ o Inicio do Periodo de Apontamento ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>                   				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nSerIni                            							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RetSerIni(	aTabCalend	,;	//01 -> Copia do Calendario de Marcacoes
					aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					dPerIni		,;	//03 -> Inicio do Periodo de Apontamento
					dPerFim		,; 	//04 -> Final do Periodo de Apontamento
					cTno		,;	//05 -> Turno de Trabalho
					cSeq		,;	//06 -> Sequencia de Turno
					cFil     	,;	//07 -> Filial do Funcionario
					cMat   		,;	//08 -> Matricula do Funcionario
					cCc   		,;	//09 -> Centro de Custo do Funcionario
					lMarcOrder	,;	//10 -> Marcacoes Sendo carregadas pela Ordem
					lCalendFunc  ;	//11 -> Se o Calendario Esta Sendo Montado por funcionario
				   )

Local nHoursDay	:= 0
Local nHoursTab := 0

Local aSvTabsCal
Local dPriDataApo
Local nSerIni
Local nDays
Local nLenCalend

DEFAULT aTabCalend		:= {}
DEFAULT aTabPadrao		:= {}
DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT lCalendFunc		:= .T.
IF ( lCalendFunc )
	DEFAULT cFil		:= SRA->RA_FILIAL
	DEFAULT cMat		:= SRA->RA_MAT
	DEFAULT cTno		:= SRA->RA_TNOTRAB
	DEFAULT cSeq		:= SRA->RA_SEQTURN
	DEFAULT cCc			:= SRA->RA_CC
EndIF	
DEFAULT lMarcOrder	:= .F.

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se o Calendario foi passado como parametro		  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		    //-- Para periodo de funcionario considera o cadastro de periodos (RCH)
			IF ( lCalendFunc )
				If Type("oPeriodo") == "U"
					SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
				EndIf
				oPeriodo:cProcesso := SRA->RA_PROCES
				oPeriodo:GetPer()
				IF !( lGetMarcOk :=oPeriodo:lFound)
					Break
				EndIF
	
				dPerIni := oPeriodo:dDataIni
				dPerFim := oPeriodo:dDataFim
	
            Else
                //-- Para periodo de turno considera o cadastro de periodos (SPO)
				IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
					Break
				EndIF
			EndIF				
		EndIF
        
        
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSvTabsCal := GetTabCal()
		IF !(;
				CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Calendario
						   	dPerFim		,;	//02 -> Data Final do Calendario
					   		cTno		,;	//03 -> Turno de Trabalho
					   		cSeq		,;	//04 -> Sequencia de Turno
					   		@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
					   		@aTabCalend	,;	//06 -> Calendario de Marcacoes
					   		cFil     	,;	//07 -> Filial do Funcionario
					   		cMat   		,;	//08 -> Matricula do Funcionario
					   		cCc   		,;	//09 -> Centro de Custo do Funcionario
							NIL			,;	//10 -> Array com as Trocas de Turno
							NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
							NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
							NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  	  );
			)					  	  
			Break
		EndIF					  	  
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA ]
		dPerFim 		:= aTabCalend[  Len( aTabCalend ) , CALEND_POS_DATA_APO ]
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Define o Numero Serial correspondente ao primeiro dia do Peri³
	³odo de Apontamento											  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nSerIni := __fDHtoNS(aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ], aTabCalend[ 01, CALEND_POS_LIM_MARCACAO , 02 ] )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Quando Primeiro Dia da Tabela Tiver o Horario Zerado Decremen³
	³ta um Dia													  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	dPriDataApo := aTabCalend[ 01 , CALEND_POS_DATA_APO ]
	aEval( aTabCalend ,{ |x|;
					 	 	 IF( x[CALEND_POS_DATA_APO] == dPriDataApo ,;
					 	 	 		 nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ),;
					 	 	 		 nHoursTab := SomaHoras( nHoursTab , x[CALEND_POS_HRS_TRABA] );
					 	 	 	);
					  };
		  )
	IF ( Empty( nHoursDay ) .and. !Empty( nHoursTab := SomaHoras( nHoursDay , nHoursTab ) ) )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Monta Novo Periodo de Apontamento                   	  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nDays	:= ( ( dPerFim - dPerIni ) + 1 )
		dPerFim	:= ( aTabCalend[ 01 , CALEND_POS_DATA ] - 1 )
		dPerIni := ( dPerFim - nDays )
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF Empty( aSvTabsCal )
			aSvTabsCal := GetTabCal()
		EndIF
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Cria Calendario com o Ultimo dia do Periodo Anterior         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF CriaCalend(	dPerFim		,;	//01 -> Data Inicial do Calendario
		   		   		dPerFim		,;	//02 -> Data Final do Calendario
						cTno		,;	//03 -> Turno de Trabalho
						cSeq		,;	//04 -> Sequencia de Turno
						@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						@aTabCalend	,;	//06 -> Calendario de Marcacoes
						cFil     	,;	//07 -> Filial do Funcionario
						cMat   		,;	//08 -> Matricula do Funcionario
						cCc   		,;	//09 -> Centro de Custo do Funcionario
						NIL			,;	//10 -> Array com as Trocas de Turno
						NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
						NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
						.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
						NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Procura o Proximo Dia com Horario na Tabela         	  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
				IF ( ( --dPerFim ) < dPerIni )
					Exit
				EndIF
				aTabCalend := {}
				IF !CriaCalend(	dPerFim		,;	//01 -> Data Inicial do Calendario
		   		    			dPerFim		,;	//02 -> Data Final do Calendario
					  			cTno		,;	//03 -> Turno de Trabalho
								cSeq		,;	//04 -> Sequencia de Turno
								@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
								@aTabCalend	,;	//06 -> Calendario de Marcacoes
								cFil     	,;	//07 -> Filial do Funcionario
								cMat   		,;	//08 -> Matricula do Funcionario
								cCc   		,;	//09 -> Centro de Custo do Funcionario
								NIL			,;	//10 -> Array com as Trocas de Turno
								NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  		)
					Exit
				EndIF					  		
			End While
			IF Empty( nHoursDay )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Se nao Achou Horas na Tabela Decrementa o Primeiro Serial	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				--nSerIni
			Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Caso Contrario Considera como Primeira Marcacao a ultima  Mar³
				³cacao do Dia Anterior(Respeitando o HorMais) somado de um  mi³
				³nuto.  													  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nLenCalend	:= Len( aTabCalend )
				nSerIni 	:= __fDHtoNS( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 01 ] , SomaHoras( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
			EndIF
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se nao Achou Horas na Tabela Decrementa o Primeiro Serial	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			--nSerIni
		EndIF	
	ElseIF Empty( nHoursTab )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Neste Caso a Tabela nao Tem Horario e o Serial deve ser Decre³
		³mentado													  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		--nSerIni
	EndIF

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Conteudo do Calendario por Turno        		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se Deve Decrementar o Serial Obtido				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Return( IF( lMarcOrder ,  --nSerIni , nSerIni ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetSerFim   ³Autor ³ Marinaldo de Jesus   ³ Data ³11/10/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Numero Serial para o Fim do Periodo de Apontamento  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>                   				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nSerFim                            							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RetSerFim(	aTabCalend	,;	//01 -> Copia do Calendario de Marcacoes
					aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					dPerIni		,;	//03 -> Inicio do Periodo de Apontamento
					dPerFim		,; 	//04 -> Final do Periodo de Apontamento
					cTno		,;	//05 -> Turno de Trabalho
					cSeq		,;	//06 -> Sequencia de Turno
					cFil     	,;	//07 -> Filial do Funcionario
					cMat   		,;	//08 -> Matricula do Funcionario
					cCc   		,;	//09 -> Centro de Custo do Funcionario
					lMarcOrder	,;	//10 -> Marcacoes Sendo carregadas pela Ordem
					lCalendFunc  ;	//11 -> Se o Calendario Esta Sendo Montado por funcionario
				   )

Local nHoursDay	:= 0
Local nHoursTab := 0

Local aSvTabsCal
Local dUltDataApo
Local nSerFim
Local nDays

DEFAULT aTabCalend	:= {}
DEFAULT aTabPadrao	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT lCalendFunc	:= .T.
IF ( lCalendFunc )
	DEFAULT cMat		:= SRA->RA_MAT
	DEFAULT cTno		:= SRA->RA_TNOTRAB
	DEFAULT cSeq		:= SRA->RA_SEQTURN
	DEFAULT cCc			:= SRA->RA_CC
EndIF
DEFAULT lMarcOrder	:= .F.

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se o Calendario foi passado como parametro		  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Empty( aTabCalend )
	 		//-- Para periodo de funcionario considera o cadastro de periodos (RCH)
			IF ( lCalendFunc )
				If Type("oPeriodo") == "U"
					SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
				EndIf
				oPeriodo:cProcesso := SRA->RA_PROCES
				oPeriodo:GetPer()
				IF !( lGetMarcOk :=oPeriodo:lFound)
					Break
				EndIF
	
				dPerIni := oPeriodo:dDataIni
				dPerFim := oPeriodo:dDataFim
	
            Else
                //-- Para periodo de turno considera o cadastro de periodos (SPO)
				IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
					Break
				EndIF
			EndIF
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSvTabsCal := GetTabCal()
		IF !(;
				CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Calendario
						   	dPerFim		,;	//02 -> Data Final do Calendario
				   			cTno		,;	//03 -> Turno de Trabalho
					   		cSeq		,;	//04 -> Sequencia de Turno
					   		@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
					   		@aTabCalend	,;	//06 -> Calendario de Marcacoes
					   		cFil     	,;	//07 -> Filial do Funcionario
					   		cMat   		,;	//08 -> Matricula do Funcionario
				   			cCc   		,;	//09 -> Centro de Custo do Funcionario
							NIL			,;	//10 -> Array com as Trocas de Turno
							NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
							NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
							NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  	  );
			)
			Break					  	  
		EndIF
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA ]
		dPerFim			:= aTabCalend[ Len( aTabCalend ) , CALEND_POS_DATA_APO ]
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Define o Numero Serial correspondente ao ultimo dia do  Perio³
	³do de Apontamento											  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nSerFim := __fDHtoNS(aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,1] , aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,2] )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Quando ultimo Dia da Tabela Tiver o Horario Zerado Soma  Mais³
	³um Dia														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	dUltDataApo := aTabCalend[Len(aTabCalend),CALEND_POS_DATA_APO]
	aEval( aTabCalend ,{ |x|;
					 	 	 IF( x[CALEND_POS_DATA_APO] == dUltDataApo ,;
					 	 	 		 nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ),;
					 	 	 		 nHoursTab := SomaHoras( nHoursTab , x[CALEND_POS_HRS_TRABA] );
					 	 	 	);
					  };
		  )
	IF ( Empty( nHoursDay ) .and. !Empty( nHoursTab := SomaHoras( nHoursDay , nHoursTab ) ) )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Monta Novo Periodo de Apontamento                   	  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nDays	:= ( ( dPerFim - dPerIni ) + 1 )
		dPerIni := ( aTabCalend[ Len(aTabCalend) , CALEND_POS_DATA ]  + 1 )
		dPerFim := ( dPerIni + nDays )
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF Empty( aSvTabsCal )
			aSvTabsCal := GetTabCal()
		EndIF	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Cria Calendario com o Primeiro dia do Proximo Periodo de Apon³
		³tamento													  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF CriaCalend(	dPerIni		,;	//01 -> Data Inicial do Calendario
		   		   		dPerIni		,;	//02 -> Data Final do Calendario
						cTno		,;	//03 -> Turno de Trabalho
						cSeq		,;	//04 -> Sequencia de Turno
						@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						@aTabCalend	,;	//06 -> Calendario de Marcacoes
						cFil     	,;	//07 -> Filial do Funcionario
						cMat   		,;	//08 -> Matricula do Funcionario
						cCc   		,;	//09 -> Centro de Custo do Funcionario
						NIL			,;	//10 -> Array com as Trocas de Turno
						NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
						NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
						.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
						NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Procura o Proximo Dia com Horario na Tabela         	  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
				IF ( ( ++dPerIni ) > dPerFim )
					Exit
				EndIF
				aTabCalend := {}
				IF !CriaCalend(	dPerIni		,;	//01 -> Data Inicial do Calendario
		   		    			dPerIni		,;	//02 -> Data Final do Calendario
					  			cTno		,;	//03 -> Turno de Trabalho
								cSeq		,;	//04 -> Sequencia de Turno
								@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
								@aTabCalend	,;	//06 -> Calendario de Marcacoes
								cFil     	,;	//07 -> Filial do Funcionario
								cMat   		,;	//08 -> Matricula do Funcionario
								cCc   		,;	//09 -> Centro de Custo do Funcionario
								NIL			,;	//10 -> Array com as Trocas de Turno
								NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  		)
					Exit
				EndIF					  		
			End While
			IF Empty( nHoursDay )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Se nao Achou Horas na Tabela Incremente o Ultimo Serial	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				++nSerFim
			Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Caso Contrario Considera como Ultima Marcacao a Primeira  Mar³
				³cacao do Proximo Dia (Respeitando o HorMenos) subtraido de um³
				³minuto.													  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nSerFim := __fDHtoNS( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ] , SubHoras( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
			EndIF
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se nao Achou Horas na Tabela Incremente o Ultimo Serial	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			++nSerFim
		EndIF	
	ElseIF Empty( nHoursTab )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Neste Caso a Tabela nao Tem Horario e o Serial deve ser incre³
		³mentado													  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		++nSerFim
	EndIF

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Conteudo do Calendario por Turno        		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF
	
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se Deve Incrementar o Serial Obtido				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Return( IF( lMarcOrder , ++nSerFim , nSerFim ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PutMarcAuto  ³Autor³ Marinaldo de Jesus   ³ Data ³13/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gerar Marcacoes Automaticas no Array aMarcacoes             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<vide parametros formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lAuto														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<vide parametros formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutMarcAuto(	aTabCalend	,;
						aMarcacoes	,;
						dPerIni		,;
						dPerFim		,;
						cFil		,;
						lChkTables	,;
						lSobrepoe	,;
						aMarcNoGer   ;
					)
                    	
Local aCloneMarc	:= aClone( aMarcacoes )
Local aMAuto		:= {}
Local cCusto		:= SRA->RA_CC 
Local lSpaIsMemVar	:= .F.
Local lSr6IsMemVar	:= .F.

Local aTDia
Local aMDia
Local aTab_Marc
Local aFields  
Local aMarcGer  
Local aMarcDia		:= {}

Local cOrdem 
Local dDataApo
Local cMarcAut  
Local cNewMarcAut
Local cMarc 
Local cUltmarc
Local cTipMarcDia
Local cMarcsObriga
Local cMarcsEfe
Local cFilRegra
Local cFilTurno
Local cTpMarc
Local cPerAponta
Local cAutoSai
Local cUltOrdem 
Local dUltDataApo

Local dDtMarc 

Local lAuto
Local lInterv
Local lAleat
Local lAutomSM
Local lTrabFer
Local lMarcsObriga
Local lAutoSai
Local lCompletaMar

Local nY
Local nFornY
Local nTab
Local nLenTab
Local nMarc
Local nLenMarc
Local nOrdem
Local nDataApo
Local nForOrdem
Local nForDataApo
Local nField
Local nMarcsGer
Local nMarcsEfe
Local nLenMAuto
Local nMarcAut
Local nPosUltOrd 
Local nPosUltDataApo
Local nInterv
Local nHrTrab
Local nAleato
Local nPos
Local nMinuto
Local nSvRecno
 
DEFAULT aTabCalend	:= {}
DEFAULT aMarcacoes	:= {}   
DEFAULT aMarcNoGer	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= cFilAnt 
DEFAULT lChkTables	:= .T.
DEFAULT lSobrepoe	:= .F.
DEFAULT lPnMcAut01	:= ExistBlock( "PNMCAUT01" )

IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
	If Type("oPeriodo") == "U"
		SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
	EndIf
	oPeriodo:cProcesso := SRA->RA_PROCES
	oPeriodo:GetPer()
	dPerIni := oPeriodo:dDataIni
	dPerFim := oPeriodo:dDataFim
EndIF

DEFAULT	_aSpaHeader		:= GdMontaHeader( @_nSpaHeader , NIL , NIL , "SPA" , NIL , .T. , .T. , .F. , .F. , .F. , .F. , .F. , .F. )
DEFAULT	_aSr6Header		:= GdMontaHeader( @_nSr6Header , NIL , NIL , "SR6" , NIL , .T. , .T. , .F. , .F. , .F. , .F. , .F. , .F. )

DEFAULT	_cSpaLastReg	:= "_cSpaLastReg"
DEFAULT _cSr6LastTno	:= "_cSr6LastTno"

DEFAULT _cSpceFuncao	:= Space( GetSx3Cache( "P8_FUNCAO " , "X3_TAMANHO" ) )
DEFAULT _cSpceGiro		:= Space( GetSx3Cache( "P8_GIRO   " , "X3_TAMANHO" ) )
DEFAULT _cSpceRelogi	:= Space( GetSx3Cache( "P8_RELOGIO" , "X3_TAMANHO" ) )

dUltDataApo	:= aTabCalend[ Len( aTabcalend ) , CALEND_POS_DATA_APO ]
nForDataApo	:= (dPerFim-dPerIni)
nLenTab		:= Len( aTabCalend )
nLenMarc	:= Len( aMarcacoes )
cFilRegra	:= xFilial( "SPA" , cFil )
cFilTurno	:= xFilial( "SR6" , cFil )
cPerAponta	:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
cPerAponta	+= Dtos(dUltDataApo)
dDataApo	:= dPerIni
IF !( lChkTables )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega Informacoes da Regra de Apontamento          	      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cMarcAut := StrTran( GetMemVar( "PA_MARCAUT" ) , "*" , "" )
	cMarcAut += IF( SubStr(cMarcAut,-1) != "-" .and. !Empty(cMarcAut) , "-" , "" )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega Informacoes da Regra de Apontamento          	      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lAleat	  		:= ( GetMemVar( "PA_ALEATOR" ) == "S" )
	lAutomSM    	:= ( GetMemVar( "PA_AUTOMSM" ) == "S" )
	lCompletaMar	:= ( GetMemVar( "PA_COMPMAR" ) == "S" )
	nMinuto			:= Abs( GetMemVar( "PA_MINALEA" ) )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se Devera Gerar Marcacoes em Dias Nao Trabalhados  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lAutoSai := !Empty( cAutoSai := AllTrim( StrTran( GetMemVar( "R6_AUTOSAI" ) , "*" , "" ) ) )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Garante que as marcacoes de um dia nao interfiram no proximo³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aMarcNoGer	:= {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Processa para Todas as Ordens da Tabela de Horario		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
For nDataApo := 0 To nForDataApo //leandro nfordataapo não tem valor

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa as Variaveis									  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    cTipMarcDia		:= ""
    cMarcsObriga	:= ""
    lMarcsObriga	:= .F.
	 
	dDataApo	    :=  dPerIni + nDataApo
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Procura a Data de Apontamento em aTabCalend.                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
	IF ( nTab := aScan( aTabCalend, { |x| x[CALEND_POS_DATA_APO] == dDataApo } ) ) > 0
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Esta Dentro do Periodo de Apontamento           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( aTabCalend[ nTab , CALEND_POS_DATA_APO ] < dPerIni .or. aTabCalend[ nTab , CALEND_POS_DATA_APO ] > dPerFim )
			Loop
		EndIF

		aMarcGer	:= {}

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Posiciona na Regra do Calendario							  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !PosSPA( aTabCalend[ nTab , CALEND_POS_REGRA ] , cFilRegra , NIL , 1 , .F. )
			Loop
		EndIF

	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Seta os Campos da Regra									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
				( lChkTables );
				.and.;
				(;
					( _cSpaLastReg <> ( cFilRegra + aTabCalend[ nTab , CALEND_POS_REGRA ] ) );
					.or.;
					!( lSpaIsMemVar );
				);
			)

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Armazena Filial e Regra Anterior                     	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			_cSpaLastReg := ( cFilRegra + aTabCalend[ nTab , CALEND_POS_REGRA ] )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem as informacoes em Cache do SPA                        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aFields	:= {}
			For nField := 1 To _nSpaHeader
				aAdd( aFields , _aSpaHeader[ nField , __AHEADER_FIELD__ ] )
			Next nField
			aFields := PosSPA( aTabCalend[ nTab , CALEND_POS_REGRA ] , cFilRegra , aFields , 1 , .F. )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega e Alimenta as Variaveis de Memoria para o SPA	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nField := 1 To _nSpaHeader
				SetMemVar( _aSpaHeader[ nField , __AHEADER_FIELD__ ] , aFields[ nField ] , .T. )
			Next nField

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se as Variaveis de Memoria foram Carregadas 	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lSpaIsMemVar := IsMemVar( "PA_MARCAUT" )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Informacoes da Regra de Apontamento          	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cMarcAut := StrTran( GetMemVar( "PA_MARCAUT" ) , "*" , "" )
			cMarcAut += IF( SubStr(cMarcAut,-1) != "-" .and. !Empty(cMarcAut) ,"-" , "" )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Informacoes da Regra de Apontamento          	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lAleat	  		:= ( GetMemVar( "PA_ALEATOR" ) == "S" )
			lAutomSM    	:= ( GetMemVar( "PA_AUTOMSM" ) == "S" )
			lCompletaMar	:= ( GetMemVar( "PA_COMPMAR" ) == "S" )
			nMinuto			:= Abs( GetMemVar( "PA_MINALEA" ) )
			
			DEFAULT lCompletaMar	:= .F.

		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se nao Tiver Marcacoes a Gerar Vai Para o Proximo Dia	      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF Empty( nMarcAut := Len( cMarcAut ) )
			Loop
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Funcionario Trabalha em Dias Feriado     	      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lTrabFer	:= (;
							aTabCalend[	nTab , CALEND_POS_FERIADO		];
							.and.;
							aTabCalend[	nTab , CALEND_POS_TRAB_FERIADO	];
						)	

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Posiciona no Turno do Calendario							  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !PosSR6( aTabCalend[ nTab , CALEND_POS_TURNO ] , cFilTurno , NIL , 1 , .F. )
			Loop
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Seta os Campos do Turno									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
				( lChkTables );
				.and.;
				(;
					( _cSr6LastTno <> ( cFilTurno + aTabCalend[ nTab , CALEND_POS_TURNO ] ) );
					.or.;
					!( lSr6IsMemVar );
				);	
			)	

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Armazena Filial e Turno Anterior                     	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			_cSr6LastTno := ( cFilTurno + aTabCalend[ nTab , CALEND_POS_TURNO ] )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem as informacoes em Cache do SR6                        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aFields	:= {}
			For nField := 1 To _nSr6Header
				aAdd( aFields , _aSr6Header[ nField , __AHEADER_FIELD__ ] )
			Next nSpaHeader
			aFields := PosSR6( aTabCalend[ nTab , CALEND_POS_TURNO ] , cFilTurno , aFields , 1 , .F. )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega e Alimenta as Variaveis de Memoria para o SR6	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nField := 1 To _nSr6Header
				SetMemVar( _aSr6Header[ nField , __AHEADER_FIELD__ ] , aFields[ nField ] , .T. )
			Next nField

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se as Variaveis de Memoria foram Carregadas 	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lSr6IsMemVar := IsMemVar( "R6_AUTOSAI" )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Devera Gerar Marcacoes em Dias Nao Trabalhados  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lAutoSai := !Empty( cAutoSai := AllTrim( StrTran( GetMemVar( "R6_AUTOSAI" ) , "*" , "" ) ) )

		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica os Tipos de Marcacoes para o Dia                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		For nMarc := nTab To nLenTab
			IF ( aTabCalend[ nMarc , CALEND_POS_DATA_APO ] == dDataApo )
				cUltmarc	:=  ( aTabCalend[ nMarc , CALEND_POS_TIPO_MARC ] + "-" ) 
				cTipMarcDia += cUltmarc
			Else
				Exit
			EndIF	
		Next nMarc  
		
    	/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Limita as Marcacoes automaticas a maior marcacao da Tabela   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
		cNewMarcAut	:= "" 
		IF !empty(cUltmarc)        	
	       	For nMarc := 1 To Len(cMarcAut) Step 3
			
	       		cMarc:= SubStr( cMarcAut , nMarc , 3 )
	       		If cMarc <= cUltmarc
		       		cNewMarcAut+= cMarc
		       	Endif
	
	       	Next nX
        Else 
	        cNewMarcAut:= cMarcAut
        Endif          
        
    	/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica novamente a existencia de marcacoes a gerar	      ³
		³ Se nao Tiver Marcacoes a Gerar Vai Para o Proximo Dia	      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF Empty( nMarcAut := Len( cNewMarcAut ) )
			Loop
		EndIF    
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Quais Marcacoes sao Obrigatorias                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
       	cMarcsObriga	:= cTipMarcDia
       	nMarcsGer	 	:= 0
       	For nMarc := 1 To nMarcAut Step 3
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Apura o Numero de Marcacoes a Gerar						  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nMarcsGer++
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se Todas as Marcacoes Obrigatorias Foram Efetuadas sai do For³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
       		IF Empty( cMarcsObriga := StrTran( cMarcsObriga , SubStr( cNewMarcAut , nMarc , 3 ) , "" ) )
       			Exit
       		EndIF
       	Next nX

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Reinicializa as Variaveis Tabela e Marcacoes                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aTDia := {}
		aMDia := {}


		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ N„o gera Marca‡oes Autom ticas em Feriados e Dias Nao Traba ³
		³ lhados                                                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
					aTabCalend[ nTab , CALEND_POS_FERIADO ];
					.and.;
					!( lTrabFer );
					.and.;
					!( lAutosai );
			)		
			Loop
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ N„o gera Marca‡oes Autom ticas Para Funcionarios Afastados  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( aTabCalend[ nTab , CALEND_POS_AFAST ] )
			IF (;
					(;
						( aTabCalend[nTab,CALEND_POS_DATA] >= aTabCalend[ nTab , CALEND_POS_INI_AFAST ] );
						.and.;
						( aTabCalend[nTab,CALEND_POS_DATA] <= aTabCalend[ nTab , CALEND_POS_FIM_AFAST ] );
					);	
					.or.;
					(;
						( aTabCalend[nTab,CALEND_POS_DATA] >= aTabCalend[ nTab , CALEND_POS_INI_AFAST ] );
						.and.;
						Empty( aTabCalend[ nTab , CALEND_POS_FIM_AFAST ] );
					);
				)	
				Loop
			EndIF
		EndIF

		While (;
					( nTab <= nLenTab );
					.and.;
					( dDataApo == aTabCalend[ nTab , CALEND_POS_DATA_APO ] );
			  )
			aAdd( aTDia,;
							{;
								aTabCalend[ nTab , CALEND_POS_DATA		]	,;	//01 - Data
						   		aTabcalend[ nTab , CALEND_POS_HORA		]	,;	//02 - Hora
						   		aTabCalend[ nTab , CALEND_POS_TIPO_MARC	]	,;	//03 - Tipo Marcacao
						   		aTabCalend[ nTab , CALEND_POS_TIPO_DIA	]	,;	//04 - Tipo do Dia
						   		aTabCalend[ nTab , CALEND_POS_HRS_INTER	]	,;	//05 - Horas de Intervalo
						   		aTabCalend[ nTab , CALEND_POS_TURNO		]	,;	//06 - Turno de Trabalho
						   		aTabCalend[ nTab , CALEND_POS_CC		]	,;	//07 - Centro de Cuto
						   		aTabCalend[ nTab , CALEND_POS_FERIADO	]	,;	//08 - Dia Corresponde a Feriado
						   		aTabCalend[ nTab , CALEND_POS_HRS_TRABA	]	,;	//09 - Horas Trabalhadas 
								aTabCalend[ nTab , CALEND_POS_CODFUNC	]	,;	//10 - Codigo da Funcao do funcionario
								aTabCalend[ nTab , CALEND_POS_DEPTO	]		,;	//11 - Codigo de Depto. do funcionario
								aTabCalend[ nTab , CALEND_POS_POSTO	]		,;	//12 - Codigo do Posto do funcionario
								aTabCalend[ nTab , CALEND_POS_PERIODO	]	,;	//13 - Periodo
								aTabCalend[ nTab , CALEND_POS_ROTEIRO	]	,;	//14 - Roterio 
								aTabCalend[ nTab , CALEND_POS_PROCESSO	]	,;	//15 - Processo
								aTabCalend[ nTab , CALEND_POS_NUM_PAGTO	]	,;	//16 - Num. de Pagamento 
								aTabCalend[ nTab , CALEND_POS_DATA_APO	]	,;	//17 - Data de Apontamento
								aTabCalend[ nTab , CALEND_POS_ORDEM  	]	 ;	//18 - Ordem
							};
				 )
			nTab++
		End While
		nTab := 0
		aEval( aTDia , { |x| nTab := SomaHoras( nTab , x[9] ) } )
	
	Else

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Nao Encontrou a Ordem no Calendario                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		Loop

	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Procura a Ordem em aMarcacoes.                              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( nMarc := aScan( aMarcacoes, { |x| x[AMARC_DATAAPO] == dDataApo } ) ) > 0 )
		While (;
					( nMarc <= nLenMarc );
					.and.;
					( dDataApo == aMarcacoes[ nMarc , AMARC_DATAAPO ] );
			   )
			aAdd( aMDia , { aMarcacoes[ nMarc , 1 ] , aMarcacoes[ nMarc , 2 ], nMarc, aMarcacoes[ nMarc ,AMARC_FLAG] } )
			nMarc++
		End While
		nMarc := 0
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ So Gerar Marcacoes nos Dias em Que Existirem Marcacoes ou se³
	³ Tiver Horas Trabalhadas no Calendario de Marcacoes          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF (;
			( nTab == 0 );
			.or.;
			(;
				Empty( aMDia );
				.and.;
				!( lAutomSM );  
			 );
		)
		Loop
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ S¢ gera Marca‡oes Autom ticas se o tipo do dia for "S"im.   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( aTDia[1,4] == "S" )
	    IF ( lAutoSai ) 
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ S¢ gera Marca‡oes Autom ticas se o tipo do dia for "C"-Compensado ³
			³ ou "D" - Descanso ou Dia marcacao for Feriado					    ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !(;
					( aTDia[1,4] $ cAutoSai ))
/*					.or.;
					( aTDia[1,8] );
				 )  */
				Loop
			EndIF
		Else
			Loop
		EndIF			
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica Qual Horario da Tabela Esta Sem Marcacao           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aTab_Marc := StuffMarcTab( aTDia , aMDia )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inverte Marcacao de Entrada de Intervalo com Marcacao de  En³
	³ trada Quando Marcacao de Intervalo for Menor que Marcacao da³
	³ tabela													  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	AjustMarc( aTDia , NIL , aTab_Marc , NIL , cNewMarcAut , .T. , aClone( aMDia ) , lAutoSai )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Insere a marcacao lida e nao incluida no aTab_Marc qdo. se  ³
	³ tratar da ultima saida (situacao nao contemplada na aproxim.³
	³ de horarios de StuffMarcTab).								  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nTab_Marc := Len( aTab_Marc )
	
	For nMarc := 1 To Len( aMDia )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se a marcacao ja foi incluida em aTabMarc.         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( aScan( aTab_Marc, { |x| If( !Empty( x[ 2 ] ), x[ 2, 1 ] == aMDia[ nMarc , 1 ] .And. x[ 2 , 2 ] == aMDia[ nMarc , 2 ], .F. ) } ) == 0 )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Nao encontrou ultima saida e a marcacao nao lida e nao      ³
			³ incluida eh maior que a ultima saida prevista no calendario,³
			³ entao assume como sendo a ultima saida.                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF Empty( aTab_Marc[ nTab_Marc , 2 ] ) .And. DataHora2Str( aMDia[ nMarc , 1 ] , aMDia[ nMarc , 2 ] ) > aTab_Marc[ nTab_Marc , 4 ]
				aTab_Marc[ nTab_Marc , 2 ] := { aMDia[ nMarc , 1 ], aMDia[ nMarc , 2 ] }
				aTab_Marc[ nTab_Marc , 3 ] := nMarc
				aTab_Marc[ nTab_Marc , 4 ] := DataHora2Str( aTab_Marc[ nTab_Marc , 1 , 1 ] , aTab_Marc[ nTab_Marc , 1 , 2 ] )
				aTab_Marc[ nTab_Marc , 5 ] := aMDia[ nMarc , 3 ]
			EndIF
		EndIF
	Next nMarc

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Ponto de Entrada para Remanejamento dos Horarios de         ³
	³ Tabela X Marcacoes realizadas.						      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lPnMcAut01                                                     
		If ( ValType( uRet := ExecBlock("PNMCAUT01" , .F. , .F. , {aTab_Marc, aTDia, aMdia,  cNewMarcAut  } ) ) == "A" )
		   aTab_Marc:= aClone(uRet)
		Endif
	Endif
	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Totaliza o Numero de Marcacoes ja Efetuadas                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nMarcsEfe := 0
	cMarcsEfe := ""
	MarcEfetuadas(aTab_Marc, lSobrepoe,  cTipMarcDia,  cMarcsObriga, @nMarcsEfe, @cMarcsEfe) 
	        
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se as Marcacoes Obrigatorias foram efetuadas       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    IF !( lMarcsObriga := ( Empty( cMarcsObriga ) .and. Empty( cMarcsEfe ) ) )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ So verifica as Marcacoes Obrigatorias se nao for   Completar³
		³ as Marcacoes que Faltam 									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    	IF !( lCompletaMar )
    		For nMarc := 1 To Len( cMarcsObriga ) Step 3
       			IF !( lMarcsObriga := ( SubStr( cMarcsObriga , nMarc , 3 ) $ cMarcsEfe ) )
       				Exit
				EndIF
       		Next nX
       	EndIF	
    ElseIF (;
    			( lCompletaMar );
    			.and.;
    			( lAutomSM );
    		 )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Deixar a Carga de Todas as Marcacoes, quando estas nao  exis³
		³ tirem, para lAutomSM     									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    	lCompletaMar := .F.
    EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gera as Marcacoes Automaticas                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF (;
			(;
				( lMarcsObriga );
				.or.;
				( lCompletaMar );
			);
			.and.;
			( ( nFornY := Len( aTab_Marc ) ) > 0 );
		 )            
		 
		 If !( lSobrepoe )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Recalcula as marcacoes a serem geradas subtraindo as marca-  ³
			³coes efetuadas.											  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nMarc := 1 To Len(cMarcsEfe) Step 3
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Diminue as marcacoes geradas a cada marcacao ja efetuada     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	       		IF SubStr( cMarcsEfe , nMarc , 3 )$ cNewMarcAut
					nMarcsGer--
	       		EndIF
	       	Next nX
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se todas as marcacoes a gerar ja foram efetuadas vai para a ³
			³ proxima ordem.											  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/		       	
			If Empty(nMarcsGer)
			   Loop
			Endif
		Endif
		
		//-- Inicializa todas as marcacoes do dia (Antigas e Geradas)
		aMarcDia	:= aclone(aMDia)
			
		For nY := 1 To nFornY

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ So Gera Quando Nao Existir Marcacoes ou se Sobrescreve      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					!Empty( aTab_Marc[ nY , 02 ] );
					.and.;
					!( lSobrepoe );
				) 
				 //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                 //-- geracao de marcacoes impares. 
                 If !Empty(aMarcDia)
                    If !Empty(aTab_Marc[nY, 03])
		                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
		            Endif
		         Endif        
				Loop
			EndIF

			IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
			   									x[2] == aTab_Marc[ nY , 01 , 02 ]		;
									    };
						      );
				) > 0 
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Verifica se Devera Gerar a Marcacao Automatica para o Tipo de³
				³Marcacao em questao. Se o Tipo Nao Estiver Selecionado e a Di³
				³ferenca de Horas Entre o Tipo Selecionado e um Tipo  Imediata³
				³mente Anterior ou Posterior Que Tenha Sido Selecionado    for³
				³igual, tambem Gera a Marcacao Automatica. Pois Neste caso nao³
				³da Para Identificar a Quem Pertence a Marcacao Efetuada.     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF (;
						(;
							AjustMarc( aTDia , nPos , aTab_Marc , nY , cNewMarcAut );
							.or.;
							( aTDia[nPos,3] $ cNewMarcAut );
						 );
						.and.;
				   		( Len( aTDia ) - nMarcsGer >= nMarcsEfe );
				   	)	
                Else
                    //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                    //-- geracao de marcacoes impares.
                    If !Empty(aMarcDia)
	                    If !Empty(aTab_Marc[nY, 03])
			                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
			            Endif
			        Endif   
                	Loop
                EndIF
			Else
					 //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                    //-- geracao de marcacoes impares.
                    If !Empty(aMarcDia)
	                    If !Empty(aTab_Marc[nY, 03])
			                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
			            Endif
			        Endif  
				Loop
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Retorna as Horas Maximas Para a Geracao Aleatoria. Os Minutos³
			³Aleatorios nao  podem Exceder `a metada da Jornada.		  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lAleat ) //Marcacao Aleatoria
				IF ( nTab := aScan( aTabCalend, { |x| x[CALEND_POS_TIPO_MARC] == aTDia[nPos,3] .and. x[CALEND_POS_DATA] == aTDia[nPos,1] } ) ) > 0
					IF ( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] > 0 .or. SubStr(aTDia[nPos,3],-1) == "E" )
						IF ( lInterv := ( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] > 0 ) )
						    nInterv := Min( ( __Hrs2Min( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] ) / 2 ) , nMinuto )
						ElseIF ( lInterv := ( aTabCalend[ Max( 1 , nTab - 1 ) , CALEND_POS_HRS_INTER ] > 0 ) )
							nInterv := Min( ( __Hrs2Min( aTabCalend[ Max( 1 , nTab - 1  ) , CALEND_POS_HRS_INTER ] ) / 2 ) , nMinuto )
						EndIF
					EndIF
					IF ( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] > 0 .or. SubStr(aTDia[nPos,3],-1) == "S" )
						IF ( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] > 0 )
						    nHrTrab := Min( ( __Hrs2Min( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] ) / 2 ) , nMinuto )
						ElseIF ( aTabCalend[ Max( 1 , nTab - 1 ) , CALEND_POS_HRS_TRABA ] > 0 )
							nHrTrab := Min( ( __Hrs2Min( aTabCalend[ nTab - 1 , CALEND_POS_HRS_TRABA ] ) / 2 ) , nMinuto )
						EndIF
					EndIF	
				EndIF
				dDtMarc	:= aTDia[nPos,1]
				nMarc	:= aTDia[nPos,2]
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Gera minutos aleatorios									  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( SubStr(aTDia[nPos,3],-1) == "E" ) //-- Marcacoes de entrada
					IF lInterv
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"E")						
					Else
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nHrTrab,@nAleato,"E")
					EndIF	
				Else //-- Marcacoes de saida
					IF lInterv
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"S")
					Else
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nHrTrab,@nAleato,"S")
					EndIF	
				EndIF
      			lInterv := .F.
      		Else
      			dDtMarc	:= aTDia[nPos,1]
      			nMarc	:= aTDia[nPos,2]
      		EndIF	
            
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem o Tipo de Marcacao a Ser Gerada						  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cTpMarc := aTDia[nPos,3]

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega as Marcacoes Automaticas							  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aAdd( aMarcGer , Array( ELEMENTOS_AMARC + 1 ) )
			nLenMAuto := Len( aMarcGer )
			aMarcGer[ nLenMAuto , AMARC_DATA		] := dDtMarc											// 01 - Data
			aMarcGer[ nLenMAuto , AMARC_HORA		] := nMarc												// 02 - Hora
			aMarcGer[ nLenMAuto , AMARC_ORDEM		] := aTDia[nPos,18]											// 03 - Ordem
			aMarcGer[ nLenMAuto , AMARC_FLAG		] := "A"												// 04 - Flag
			aMarcGer[ nLenMAuto , AMARC_RECNO		] := 0													// 05 - Recno
			aMarcGer[ nLenMAuto , AMARC_TURNO		] := aTDia[nPos,6]										// 06 - Turno
			aMarcGer[ nLenMAuto , AMARC_FUNCAO		] := _cSpceFuncao              							// 07 - Funcao
			aMarcGer[ nLenMAuto , AMARC_GIRO		] := _cSpceGiro               							// 08 - Giro
			aMarcGer[ nLenMAuto , AMARC_CC			] := IF(!Empty(aTDia[nPos,7]),aTDia[nPos,7],cCusto )	// 09 - Centro Custo
			aMarcGer[ nLenMAuto , AMARC_APONTA		] := "N"												// 10 - Flag de Apontamento
			aMarcGer[ nLenMAuto , AMARC_RELOGIO		] := _cSpceRelogi               						// 11 - Relogio
			aMarcGer[ nLenMAuto , AMARC_TIPOMARC	] := cTpMarc											// 12 - Tipo da Marcacao
			aMarcGer[ nLenMAuto , AMARC_L_ORIGEM	] := .F.												// 13 - Logico
			aMarcGer[ nLenMAuto , AMARC_DTHR2STR	] := DataHora2Str(;                                          
																	aMarcGer[ nLenMAuto , AMARC_DATA ] ,;
																	aMarcGer[ nLenMAuto , AMARC_HORA ]  ;
																  )                                    	//14 - String de Data/Hora para aSort
			aMarcGer[ nLenMAuto , AMARC_PERAPONTA	] := cPerAponta											//15 - String de Data com o Periodo de Apontamento	

			aMarcGer[ nLenMAuto , AMARC_PROCESSO] 	  := aTDia[nPos,15]   	//15 - Processo
			aMarcGer[ nLenMAuto , AMARC_ROTEIRO] 	  := aTDia[nPos,14]		//14 - Roterio 
			aMarcGer[ nLenMAuto , AMARC_PERIODO] 	  := aTDia[nPos,13]		//13 - Periodo
			aMarcGer[ nLenMAuto , AMARC_NUM_PAGTO] 	  := aTDia[nPos,16]		//16 - Num. de Pagamento 
			aMarcGer[ nLenMAuto , AMARC_DEPTO] 		  := aTDia[nPos,11]		//11 - Codigo de Depto. do funcionario
			aMarcGer[ nLenMAuto , AMARC_POSTO] 		  := aTDia[nPos,12]		//12 - Codigo do Posto do funcionari
			aMarcGer[ nLenMAuto , AMARC_CODFUNC]	  := aTDia[nPos,10]	  	//10 - Codigo da Funcao do funcionario
			aMarcGer[ nLenMAuto , AMARC_DATAAPO] 	  := aTDia[nPos,17]		//17 - Data de Apontamento		

			aMarcGer[ nLenMAuto , ELEMENTOS_AMARC  + 1 ] := If( !EMPTY( aTab_Marc[ nY, 02 ] ), aTab_Marc[ nY , 05 ], 0 ) //16 - Ponteiro para a marcacao a ser subsituida (se possuir hora correspondente) ou incluida (o trabalhador nao realizou a marcacao)

			//-- Marcacoes do dia (Antigas e Geradas)
			 If !EMPTY( aTab_Marc[ nY, 02 ] ) 
			 	If !Empty(aMarcDia)
				    If !Empty(aTab_Marc[nY, 03]) 
					    aMarcDia[ aTab_Marc[ nY , 03 ],1 ]:= dDtMarc
					    aMarcDia[ aTab_Marc[ nY , 03 ],2 ]:= nMarc
					    aMarcDia[ aTab_Marc[ nY , 03 ],4 ]:= "A"
				    Endif
				Endif    
			 Else
			    aAdd(aMarcDia, { dDtMarc, nMarc,0, "A"	}  )
			 Endif
			    
		Next nY
        
        //-- Verifica se serao geradas marcacoes em quantidade impar
        If ( Len(aMarcDia) % 2 ) > 0                                         
       		aSort( @aMarcDia , NIL , NIL , { |x,y| ( Dtoc(x[1]) + StrZero( x[2] , 5 , 2 ) ) <  ( Dtoc(y[1]) + StrZero( y[2] , 5 , 2 ) ) } )
            AADD(aMarcNoGer, {dDataApo, aClone( aMarcDia ), "IMPAR" } )
        Else                                        
            //-- Adiciona cada uma das marcações geradas para a ordem lida
            Aeval(aMarcGer, {|x| AADD(aMAuto, aClone(x) ) } )
        Endif
        
	EndIF

Next nDataApo

/*/                  
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ As Marca‡oes Autom ticas s„o Transferidas para o aMarcacoes.³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( ( nLenMarc := Len( aMAuto ) ) > 0 )

	For nMarc := 1 To nLenMarc
        If Empty( aMAuto[ nMarc , ELEMENTOS_AMARC  + 1 ] ) 
		    nPos := aScan(	aMarcacoes, { |x|;
		    									x[ AMARC_DATAAPO 	] == aMAuto[ nMarc , AMARC_DATAAPO  	];
		    									.and.;
												x[ AMARC_TIPOMARC 	] == aMAuto[ nMarc , AMARC_TIPOMARC 	];
								  		};
					 	  )
        Else 
        	nPos :=  aMAuto[ nMarc , ELEMENTOS_AMARC  + 1 ] 
        Endif
		IF ( nPos > 0 )

			IF !( lSobrepoe )
		    	Loop
		    EndIF

			nSvRecno := aMarcacoes[ nPos , AMARC_RECNO ]
			aMarcacoes[ nPos ]				:= aClone( aMAuto[ nMarc ] ) 
			aMarcacoes[ nPos , AMARC_RECNO]	:= nSvRecno

		Else

			aAdd( aMarcacoes , aClone( aMAuto[ nMarc ] ) )

		EndIF

	Next nMarc

EndIF

/*/	
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ O Array aMarcacoes ‚ indexado por Ordem + Data + Hora.      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lAuto := !ArrayCompare( aMarcacoes , aCloneMarc ) )
	aSort( @aMarcacoes , NIL , NIL , { |x,y|	(DtoS(x[AMARC_DATAAPO])+x[AMARC_DTHR2STR]);
								 				<;
								     			(DtoS(y[AMARC_DATAAPO])+y[AMARC_DTHR2STR]);
						     		  };
		  )
EndIF

Return( lAuto )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³MarcEfetuadas ³ Autor ³Mauricio MR			  ³ Data ³17/06/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Calcula o numero de marcacoes efetuadas	                       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³																³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL																³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function MarcEfetuadas(aTab_Marc, lSobrepoe,  cTipMarcDia,  cMarcsObriga, nMarcsEfe, cMarcsEfe)
Local cTipMarc	:= ""
Local nX		:= 0     
Local nFor 		:= Len(aTab_Marc)

For nX:=1 to nFor
    //-- Se Existir marcacao 
	If !Empty( aTab_Marc[ nX, 2 ] ) 
		If !lSobrepoe
		    //-- Acumula todas as marcacoes efetuadas
		    nMarcsEfe++
		    cMarcsEfe+= SubStr(cTipMarcDia, Getfxy( 3, nX ), 3 ) 	
		Else                                               
		    //-- Acumula como efetuadas apenas as marcacoes que devem existir (as nao selecionadas para gerar)
		    cTipMarc := SubStr(cTipMarcDia, Getfxy( 3, nX ), 3 )
		    If cTipMarc  $ cMarcsObriga
				cMarcsEfe+= cTipMarc
			    nMarcsEfe++
			Endif 
		Endif		 	
	Endif 
Next nX 		 
REturn ( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstMarcAuto	  ³ Autor ³Marinaldo de Jesus     ³ Data ³05/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializa as Statics em PutMarcAuto()                       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³																³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL																³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstMarcAuto()

_aSpaHeader		:= NIL
_aSr6Header		:= NIL

_cSr6LastTno	:= NIL
_cSpaLastReg	:= NIL
_cSpceFuncao	:= NIL
_cSpceGiro		:= NIL
_cSpceRelogi	:= NIL

lPa_CompMar		:= NIL

_nSpaHeader		:= NIL
_nSr6Header		:= NIL

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³StuffMarcTab ³Autor³ Marinaldo de Jesus   ³ Data ³13/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Unir Array de Marcacoes x Tabela para verificar a Marcacao  ³
³          ³que falta.													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³StuffMarcTab( aTab , aMarc )     						    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PutMarcAuto()                                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Array com os Respectivos pares Marcacoes x Tabela           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aTab  = Array com os Horarios da Tabela                    ³
³          ³ aMarc = Array com as Marcacoes do Funcionario              ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function StuffMarcTab( aTab , aMarc )

Local aUnion		:= {}
Local aTemp			:= {}
Local aTemp1		:= {}
Local cDtHr1		:= ""
Local cDtHr2		:= ""
Local nHora1		:= 0
Local nHora2		:= 0
Local nTab   		:= 0
Local nForTab		:= Len( aTab )
Local nMarc	 		:= 0
Local nForMarc		:= Len( aMarc )

For nTab  := 1 To nForTab
	aTemp := {}
	For nMarc := 1 To nForMarc
		aAdd( aTemp , { nMarc , DataHora2Val(	aTab[  nTab , 01  ]		,;
											 	aTab[  nTab , 02  ]		,;
											 	aMarc[ nMarc , 01 ]		,;
											 	aMarc[ nMarc , 02 ]		,;
											 	"H"						 ;
											  ),;
											 	aMarc[ nMarc , 03 ]     ;
						};											  
			 )
	Next nMarc
	aSort( @aTemp , NIL , NIL , { |x,y| x[2] < y[2] } )
	IF !Empty( aTemp )
		aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }							 ,;
						 { aMarc[ aTemp[ 01 , 01 ] , 01 ] , aMarc[ aTemp[ 01 , 01 ] , 02 ] } ,;
						 aTemp[ 01 , 01 ],;
						 DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
						 aTemp[01,03];
					    };
	     	)
	Else
		aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }	 ,;
						 {}											 ,;
						 0,;
						 DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
						 0;
					    };
	     	)
	EndIF	
Next nTab

IF !Empty( aUnion )
	aSort( @aUnion , NIL , NIL , { |x,y| x[4] < y[4] } )
EndIF

IF !Empty( aMarc )

	aTemp := {}
	
	nForTab := Len( aUnion )
	For nTab := 1 To nForTab
		For nMarc := 1 To nForTab
			IF ( ( aUnion[ nTab , 3 ] == aUnion[ nMarc , 3 ] ) .and. !ArrayCompare( aUnion[ nTab ] , aUnion[ nMarc ] ) )
				IF ( aScan( aTemp , { |x| x[4] == aUnion[ nTab , 4 ] } ) == 0 )
					aAdd( aTemp , aClone( aUnion[ nTab ] ) )
					aTemp[ Len( aTemp ) , 03 ] := nTab
				EndIF	
			EndIF   
		Next nMarc
	Next nTab
	
	IF !Empty( aTemp )
	
		aSort( @aTemp , NIL , NIL , { |x,y| x[4] < y[4] } )
	
		nForTab := Len( aTemp )
		For nTab := 1 To nForTab
			cDtHr1 := DataHora2Str( aTemp[ nTab , 02 , 01 ] , aTemp[ nTab , 02 , 02 ] )
			nHora1 := DataHora2Val( aTemp[ nTab , 01 , 01 ] ,;
									aTemp[ nTab , 01 , 02 ] ,;
									aTemp[ nTab , 02 , 01 ] ,;
									aTemp[ nTab , 02 , 02 ] ,;
									"H";
								   )
			IF ( aScan( aTemp1 , { |x| x[1] == cDtHr1 .and. x[2] == aTemp[ nTab , 03 ] .and. x[3] == nHora1 } ) == 0 )
				aAdd( aTemp1 , { cDtHr1 , aTemp[ nTab , 03 ] , nHora1, aTemp[ nTab, 04 ] } )
			EndIF
			For nMarc := nTab + 1 To nForTab
				IF ( cDtHr2 := DataHora2Str( aTemp[ nMarc , 02 , 01 ] , aTemp[ nMarc , 02 , 02 ] ) ) == cDtHr1
					nHora2 := DataHora2Val( aTemp[ nMarc , 01 , 01 ] ,;
											aTemp[ nMarc , 01 , 02 ] ,;
											aTemp[ nMarc , 02 , 01 ] ,;
											aTemp[ nMarc , 02 , 02 ] ,;
											"H";
										   )
					IF ( aScan( aTemp1 , { |x| x[1] == cDtHr2 .and. x[2] == aTemp[ nMarc , 03 ] .and. x[3] == nHora2 } ) == 0 )
						aAdd( aTemp1 , { cDtHr2 , aTemp[ nMarc , 03 ] , nHora2, aTemp[ nMarc, 04 ] } )
					EndIF
					nTab := nMarc
				Else
					Exit
				EndIF
			Next nMarc
		Next nTab
		
		aSort( @aTemp1 , NIL , NIL , { |x,y| x[1] + StrZero( x[3] , 5 , 2 ) < y[1] + StrZero( y[3] , 5 , 2 ) } )
		
		nForTab := Len( aTemp1 )
		For nTab := 1 To nForTab
			For nMarc := nTab + 1 To nForTab
				IF aTemp1[ nMarc , 1 ] == aTemp1[ nTab , 1 ]
					aUnion[ aTemp1[ nMarc , 2 ] , 02 ] := {}
					nTab := nMarc
				Else
					Exit
				EndIF	
			Next nMarc	
		Next nTab
	
	EndIF

EndIF

Return( aUnion )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AjustMarc()  ³Autor³ Marinaldo de Jesus   ³ Data ³14/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³AjustMarc()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³AjustMarc(aTDia,nPos,<@>aTab_Marc,nY,cMarcAut,lInverte)		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PutMarcAuto()                                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³True se a Diferenca for Igual                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aTDia    	= Array com as Marcacoes da Tabela de Horario	³
³          ³ nPos     	= Indice de aTDia								³
³          ³ aTab_Marc	= Array com Horarios da Tabela x Marcacoes 		³
³          ³ nY       	= Indice para aTab_Marc                    		³
³          ³ cMarcaut	= Marcacoes a Serem Geradas						³
³          ³ lInverte	= Inverter Marcacao de Entrada de Intervalo  com³
³          ³              Entrada do Expediente							³
³          ³ aMDia      = Array com as Reais Marcacoes do Dia			³
³          ³ lAutoSai   = Se Gera Marcacoes de Intervalo Para Dias N.T. ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function AjustMarc( aTDia , nPos , aTab_Marc , nY , cMarcAut , lInverte , aMDia , lAutoSai )

Local cTipMarc		:= ""
Local dDtTab		:= Ctod("//")
Local dDtMar		:= Ctod("//")
Local lRet			:= .F.
Local nHrTab		:= 0
Local nHrMar		:= 0
Local nLenDia		:= Len( aTDia )
Local nLenTma		:= Len( aTab_Marc )
Local nHora1		:= 0
Local nHora2		:= 0.01
Local nMarcs		:= 0
Local nMarc			:= 0
Local nLenMarcs		:= 0

DEFAULT nPos		:= 0
DEFAULT nY			:= 0
DEFAULT lInverte	:= .F.
DEFAULT aMDia		:= {}

lInverte := IF( lInverte , ( Len( cMarcAut ) == 6 .and. SubStr( cMarcAut , 2 , 1 ) == "S" .and. SubStr( cMarcAut , 5 , 1 ) == "E" ) , lInverte )

IF ( nLenDia > 0 )

	IF !( lInverte ) .and. Len( cMarcAut ) == 3.00 .and. !Empty( nPos ) .and. !( aTDia[ nPos , 3 ] $ cMarcAut )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica se Devera Gerar a Marcacao Automatica para o Tipo de³
		³Marcacao em questao. Se o Tipo Nao Estiver Selecionado e a Di³
		³ferenca de Horas Entre o Tipo Selecionado e um Tipo  Imediata³
		³mente Anterior ou Posterior Que Tenha Sido Selecionado    for³
		³igual, tambem Gera a Marcacao Automatica. Pois Neste caso nao³
		³da Para Identificar a Quem Pertence a Marcacao Efetuada.     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( "E" $ aTDia[ nPos , 3 ] )
			cTipMarc := StrZero( Val( SubStr( aTDia[ nPos , 3 ] , 1 , 1 ) ) - 1 , 1 ) + SubStr( aTDia[ nPos , 3 ] , -1 )
		ElseIF ( "S" $ aTDia[ nPos , 3 ] )
			cTipMarc := StrZero( Val( SubStr( aTDia[ nPos , 3 ] , 1 , 1 ) ) + 1 , 1 ) + SubStr( aTDia[ nPos , 3 ] , -1 )
		EndIF
	
		IF ( SubStr( cTipMarc , 1 , 1 ) + SubStr( cMarcAut , 2 , 1 ) ) $ cMarcAut
	
			IF ( "E" $ aTDia[ nPos , 3 ] )
	
				IF !Empty( aTab_Marc[ Max( 1 , nY - 1 ) , 2 ] ) .and. !Empty( aTDia[ Max( 1 , nPos - 1 ) ] )
				
					dDtMar := aTab_Marc[ Max( 1 , nY - 1 ) , 2 , 1 ]
					nHrMar := aTab_Marc[ Max( 1 , nY - 1 ) , 2 , 2 ]
		
					dDtTab := aTDia[ nPos , 1 ]
					nHrTab := aTDia[ nPos , 2 ]
					nHora1 := DataHora2Val( dDtTab , nHrTab , dDtMar , nHrMar , "H" )
		
					dDtTab := aTDia[ Max( 1 , nPos - 1 ) , 1 ]
					nHrTab := aTDia[ Max( 1 , nPos - 1 ) , 2 ]
					nHora2 := DataHora2Val( dDtTab , nHrTab , dDtMar , nHrMar , "H" )
				
				EndIF
	
			ElseIF ( "S" $ aTDia[ nPos , 3 ] )
	
				IF !Empty( aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 ] ) .and. !Empty( aTDia[ Min( nLenDia , nPos + 1 ) ] )
	
					dDtMar := aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 , 1 ]
					nHrMar := aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 , 2 ]
		
					dDtTab := aTDia[ nPos , 1 ]
					nHrTab := aTDia[ nPos , 2 ]
					nHora1 := DataHora2Str( dDtTab , nHrTab , dDtMar , nHrMar )
		
					dDtTab := aTDia[ Min( nLenDia , nPos + 1 ) , 1 ]
					nHrTab := aTDia[ Min( nLenDia , nPos + 1 ) , 2 ]
					nHora2 := DataHora2Str( dDtTab , nHrTab , dDtMar , nHrMar )
	
				EndIF	
		
			EndIF
	
			lRet := ( nHora1 == nHora2 )
	
		EndIF
	
	ElseIF ( lInverte )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Apenas Quando Existirem Marcacoes Efetivas 				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( nLenMarcs := Len( aMDia ) ) > 0 
		
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ajusta a Saida  ( Quando nao for a ultima )				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nY := 1 To nLenTma
	
				IF ( Empty( aTab_Marc[ nY , 02 ] ) .or. ( nY == nLenTma )  )
					Loop
				EndIF
				
				IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
					   								x[2] == aTab_Marc[ nY , 01 , 02 ]		;
										    };
								   );
					) > 0 .and. aTDia[nPos,3] $ cMarcAut .and. SubStr( aTDia[nPos,3] , -1 ) == "S"
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se Marcacao de Encaixe for menor que marcacao da Tabela Zera³
					³ a Marcacao de Encaixe										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF Empty( aTab_Marc[ nY - 1 , 02 ] ) .and. ;
					   DataHora2Str(aTab_Marc[nY,02,01],aTab_Marc[nY,02,02]) < DataHora2Str(aTab_Marc[nY,01,01],aTab_Marc[nY,01,02])
						aTab_Marc[ nY - 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
						aTab_Marc[ nY , 02 ]		:= {}
						Exit
					Else
						Loop
					EndIF
	        	
	        	EndIF
			
			Next nY

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ajusta a Saida  ( Quando for a Ultima e Numero de  Marcacoes³
			³ da Tabela for igual a 2 )									  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
            IF ( ( nLenTma == 2 ) .and. ( nLenMarcs == nLenTma ) )
            	IF ( Empty( aTab_Marc[ nLenTma , 02 ] ) .and. !Empty( aTab_Marc[ nLenTma - 1 , 02 ] ) )
            		aTab_Marc[ nLenTma , 02 ]		:= aClone( aTab_Marc[ nLenTma - 1 , 02 ] )
            		aTab_Marc[ nLenTma , 02 , 01 ]	:= aMDia[ nLenMarcs , 01 ]
            		aTab_Marc[ nLenTma , 02 , 02 ]	:= aMDia[ nLenMarcs , 02 ]
            	EndIF
            EndIF
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ajusta a Entrada ( Quando nao for a Primeira ) 			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nY := 1 To nLenTma
	
				IF ( Empty( aTab_Marc[ nY , 02 ] ) .or. ( nY == 1 )  )
					Loop
				EndIF
				
				IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
					   								x[2] == aTab_Marc[ nY , 01 , 02 ]		;
										    };
								   );
					) > 0 .and. aTDia[nPos,3] $ cMarcAut .and. SubStr( aTDia[nPos,3] , -1 ) == "E"
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se Marcacao de Encaixe for maior que marcacao da Tabela Zera³
					³ a Marcacao de Encaixe										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF DataHora2Str(aTab_Marc[nY,02,01],aTab_Marc[nY,02,02]) > DataHora2Str(aTab_Marc[nY,01,01],aTab_Marc[nY,01,02])
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Apenas Quando for formar Pares de Marcacoes ou Quando o Dia ³
						³ Nao For Trabalhado e Gerar Marcacoes para Dias Nao Trabalha ³
						³ dos ( lAutoSai ) ou Ainda Quando a Marcacao de Entrada  for ³
						³ a Ultima Marcacao do Dia.									  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			    		IF ( nMarc := aScan( aMDia , { |x| x[1] == aTab_Marc[nY,02,01] .and. x[2] == aTab_Marc[nY,02,02] } ) ) > 0
					        IF ( ( nMarcs := ( nLenMarcs - ( nMarc + 1 ) ) % 2 ) > 0 .or. ( nMarc == nLenMarcs ) )
								IF ( nMarc == nLenMarcs )
									IF ( nY + 1 ) <= Len( aTab_Marc )
										aTab_Marc[ nY + 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
										aTab_Marc[ nY , 02 ]		:= {}
									EndIF
								Else
									aTab_Marc[ nY , 02 ] := {}
								EndIF
							ElseIF ( lAutoSai .and. ( aTDia[ nPos , 04 ] != "S" ) )
								IF ( nY + 1 ) <= Len( aTab_Marc )
									aTab_Marc[ nY + 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
									aTab_Marc[ nY , 02 ]		:= {}
								EndIF
							EndIF	
						EndIF	
						Exit
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Neste Caso a Marcacao foi Encaixada como Entrada de Intervalo³
					³Simula a Saida no Expediente para Poder Gerar a Saida do   In³
					³tervalo													  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					ElseIF ( nY + 1 ) <= Len( aTab_Marc ) .and. Empty( aTab_Marc[ nY + 1 , 02 ] )
						aTab_Marc[ nY + 1 , 02 ] := aClone( aTab_Marc[ nY , 02 ] )
						Exit
					Else
						Loop
					EndIF
	        	
	        	EndIF
			
			Next nY
		
		EndIF
	
	EndIF
	
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonDestroyStatic³Autor³Marinaldo de Jesus ³ Data ³26/11/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializar as Variaveis Staticas do SIGAPON    			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PonDestroyStatic( <aDestroy> )								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aDestroy -> Pilha com as Funcoes que terao Statics Reinicia³
³          ³ 			 lizadas       									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonDestroyStatic( aDestroy )

Begin Sequence

	DEFAULT aDestroy := {}
	IF ( Empty( aDestroy ) .or. ( ValType( aDestroy ) != "A" ) )
		aDestroy := Array( 21 )
		aDestroy[01] := "RstAponta()"
		aDestroy[02] := "RstfFeriado()"
		aDestroy[03] := "RstGetTabExtra()"
		aDestroy[04] := "RstGetTabArred()"
		aDestroy[05] := "SuperGetMv()"
		aDestroy[06] := "RstToScheduleOverTime()"
		aDestroy[07] := "RstTimeRemaining()"
		aDestroy[08] := "RstPosAlias()"
		aDestroy[09] := "ResetSqlName()"
		aDestroy[10] := "RstCalendCria()"
		aDestroy[11] := "RstCriaCalend()"
		aDestroy[12] := "RstTabPadrao()"
		aDestroy[13] := "RstEnchoVlds()"
		aDestroy[14] := "RstfEventos()"
		aDestroy[15] := "RstCheckSx9()"
		aDestroy[16] := "RstfCargaId()"
		aDestroy[17] := "RstMarcAuto()"
		aDestroy[18] := "RstExistField()"
		aDestroy[19] := "RstFilExistField()"
		aDestroy[20] := "RstGetCache()"
		aDestroy[21] := "RstGetAdsLckRec()"
		aEval( aDestroy , { |x| IF( !Empty(x) .and. FindFunction(x) , &(x) , NIL ) } )
	ElseIF ( ValType( aDestroy ) == "A" )
		aEval( aDestroy , { |x| IF( !Empty(x) .and. FindFunction(x) , IF( SubStr( ( x := StrTran( x ," ","") ) , -2 )!="()",&(x+"()"),&(x)) , NIL ) } )
	EndIF

    //-- Descarta Variavel para uso em Query
	__cLimpaMotAbo := NIL    
	
End Sequence
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPonMesDat    ³Autor³Marinaldo de Jesus ³ Data ³10/12/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a Data Inicial e Final do Parametro MV_PONMES		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetPonMes( @dPerIni , @dPerFim , cFil )						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³dPerIni  -> Data Inicial do Periodo de Apontamento em Aberto³
³          ³dPerFim  -> Data Final   do Periodo de Apontamento em Aberto³
³          ³cFil     -> Filial para GetMv()								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPonMesDat( dPerIni , dPerFim , cFil )
         
Local cPonMes		:= ""
Local cPerAponta	:= ""
Local cSvFilAnt		:= cFilAnt
Local lRet			:= .T.

DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= cSvFilAnt

aLogErr030 	:= If ( Type("aLogErr030") == "U" , aLogErr030 := {}, aLogErr030 )

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )

Begin Sequence

	IF !( lRet := CheckModSPO() )
		AADD( aLogErr030, "01" ) //01 = Problema no modo de acesso do cadastro de períodos (SPO).
		Break
	EndIF
	
	IF Empty( cPonMes := GetPonMes( cFil ) )
		cPerAponta := GetPaponta( cFil )
		IF ( PerCompleto( cPerAponta ) )
	    	cPonMes := cPerAponta
    		PutMvFil( "MV_PONMES" , cPonMes , cFilAnt )
	    EndIF
	EndIF

	IF !( lRet := !Empty( dPerIni := Stod( Left( cPonMes , 08 ) ) ) )
		AADD( aLogErr030, "02" ) //02 = Período incorreto!
		Break
	EndIF
	
	IF !( lRet := !Empty( dPerFim := Stod( Right( cPonMes , 08 ) ) ) )
		AADD( aLogErr030, "02" ) //02 = Período ncorreto!
		Break
    EndIF

	IF !( lRet := MaxP8PGOrdVld( dPerIni , dPerFim ) )
		AADD( aLogErr030, "03" ) //03 = Número de ordens superior ao permitido.
		Break
	EndIF

End Sequence

cFilAnt := cSvFilAnt

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ValidPonData    ³Autor³Marinaldo de Jesus ³ Data ³10/12/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida as Datas Digitadas nos Lancamentos do SIGAPON		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais 									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ValidPonData(	dData		,;	//01 -> Data a Ser Validada
						cTipValid	,;	//02 -> Tipo da Validacao "G" - GetDados (Periodo) ; "P" - Validar o MV_PONMES
						dPerIni		,;	//03 -> Periodo Inicial
						dPerFim		,;	//04 -> Periodo Final
						lAcumulado	,;	//05 -> Se Informacao de Arquivo Acumulado
						lShowHelp	,;  //06 -> Mostrar ou Nao o Help
						cFil		 ;	//07 -> Filial para PerAponta
					  )

Local cHelp	:= ""
Local lRet	:= .T.

DEFAULT dData		:= Ctod("//")
DEFAULT cTipValid	:= "G"
DEFAULT dPerIni 	:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lAcumulado	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT cFil		:= cFilAnt

cTipValid := Upper( AllTrim( cTipValid ) )

Begin Sequence

	IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		IF !( lRet := PerAponta( @dPerIni , @dPerFim , NIL , lShowHelp , cFil ) )
			Break
		EndIF
	EndIF

	IF ( cTipValid == "G" )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Nao Podem Haver Lancamentos Fora do Periodo em Aberto		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( dData < dPerIni ) .or. ( dData > dPerFim ) )
			lRet := .F.
			cHelp += ( OemToAnsi( STR0108 ) + Space(50) + Chr(13) )								//'A Data Informada e Invalida.'
			cHelp += OemToAnsi( STR0106 )														//'Per¡odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
			cHelp += Space(50) + Chr(13)
			cHelp += Space(50) + Chr(13)
		EndIF
		Break
	EndIF

	IF ( cTipValid == "P" )
		IF ( lAcumulado )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Nao Podem Haver Lancamentos para Periodos Posteriores ao Peri³
			³ odo de Apontamento em Aberto.						   		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lRet := !( dData >= dPerIni )
			cHelp += ( OemToAnsi( STR0105 ) + Space(50) + Chr(13) )								//'N„o Podem Haver Lan‡amentos Acumulados'
			cHelp += ( OemToAnsi( STR0107 ) + Space(50) + Chr(13) )								//'Para Este Per¡odo: '
			cHelp += OemToAnsi( STR0106 )														//'Per¡odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
			cHelp += Space(50) + Chr(13)
			cHelp += Space(50) + Chr(13)
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Nao Podem Haver Lancamentos para Periodo Anteriores ao  Perio³
			³ do de Apontamento em Aberto.							   	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lRet := !( dData < dPerIni )
			cHelp += ( OemToAnsi( STR0102 ) + Space(50) + Chr(13) )								//'N„o Podem Haver Lan‡amentos para Per¡odo'
			cHelp += ( OemToAnsi( STR0103 ) + Space(50) + Chr(13) )								//'Posterior ao Periodo em Aberto: '
			cHelp += OemToAnsi( STR0106 )														//'Per¡odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
		EndIF	
		Break
	EndIF
	
End Sequence
	
IF ( !( lRet ) .and. ( lShowHelp ) )
	IF !Empty( cHelp )
		Help( " " , 1 , "NOVALIDPER" , , cHelp , 1 , 0 )
	EndIF	
EndIF

Return( lRet )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DescPdPon ³ Autor ³ Equipe Advanced RH    ³ Data ³23/02/1995³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna a Descricao do Codigo de Provento / Desconto       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function DescPdPon( cEvento , cFil , nBytes )

Local cRet		:= ""
Local nSvOrder	:= SP9->( IndexOrd() )
Local nOrder	:= RetOrdem( "SP9" , "P9_FILIAL+P9_CODIGO" )

DEFAULT nBytes := 20

IF ( nBytes > 20 )
	nBytes := 20
EndIF

cFil := xFilial( "SP9" , cFil )

IF !( nOrder == nSvOrder )
	SP9->( dbSetOrder( nOrder ) )
EndIF
	
IF SP9->( MsSeek( cFil + cEvento ) )
	cRet := Left( SP9->P9_DESC + Space( nBytes ) , nBytes )
Else
	cRet := Left( STR0001 + Space( nBytes ) , nBytes ) // '** Nao Cadastrado **'
EndIF

SP9->( dbSetOrder( nSvOrder ) )

Return( cRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ShowTipoDia ³ Autor ³Marinaldo de Jesus    ³ Data ³19/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar a multipla escolha de tipo de Dia              		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ShowTipoDia( cTipo , l1Elem )								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                     		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T.                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ShowTipoDia( cTipoDia , l1Elem , lDisplay )

Local aTpDia		:= {}
Local aOpc			:= {}
Local cTitulo		:= ""
Local cMvParDef		:= ""
Local cMvPar		:= ""
Local nTpDia		:= 0
Local nTpDias		:= 0
Local nPosTpDia		:= 0
Local uRet			:= NIL

DEFAULT cTipoDia	:= "CDFNS"
DEFAULT l1Elem		:= .F.
DEFAULT lDisplay	:= .T.

aAdd( aTpDia , { "C" , STR0109	} )	//"Compensado"
aAdd( aTpDia , { "D" , STR0110	} )	//"DSR"
aAdd( aTpDia , { "F" , STR0111	} )	//"Feriado"
aAdd( aTpDia , { "N" , STR0112	} )	//"Nao Trabalhado"
aAdd( aTpDia , { "S" , STR0113 	} )	//"Trabalhado"

IF ( lDisplay )  

	CursorWait()

	    cMvPar				:= &( Alltrim( ReadVar() ) )
		cTipoDia			:= Upper( AllTrim( cTipoDia ) )
		l1Elem				:= IF( ValType( l1Elem ) != "L" , .F. , l1Elem )
		MvRet				:= Alltrim( ReadVar() )

		nTpDias := Len( cTipoDia )
		For nTpDia := 1 To nTpDias
			IF ( nPosTpDia := aScan( aTpDia , { |x| x[1] == SubStr( cTipoDia , nTpDia , 1 ) } ) ) > 0
				cMvParDef += aTpDia[ nPosTpDia , 01 ]
				aAdd( aOpc , aTpDia[ nPosTpDia , 01 ] += ( "-" + aTpDia[ nPosTpDia , 02 ] ) )
			EndIF
		Next nX

	CursorArrow()

	IF ( uRet := ( cMvPar != NIL ) )
		IF f_Opcoes(@cMvPar,cTitulo,aOpc,cMvParDef,12,49,l1Elem,1)
			&(MvRet) := cMvPar
		EndIF	
	EndIF

Else

	IF ( nPosTpDia := aScan( aTpDia , { |x| x[1] == cTipoDia } ) ) > 0
		uRet := aTpDia[ nPosTpDia , 02 ]
	EndIF

EndIF
	
Return( uRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ValidPerSPO ³ Autor ³Marinaldo de Jesus    ³ Data ³29/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar as Datas no Cadastro de Periodos de Apontamento		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ValidPerSPO(	cFil		,;	//Filial de Referencia Para Pesquisa no SPO
						dPerIni 	,;	//Periodo Inicial para Valiadacao
						dPerFim		,;	//Periodo Final Para Validacao
						lNotInclui	,;	//Quando Inclui nao Estiver Definido, qual sera o seu valor
						lShowHelp	,;	//Se deve Mostrar Help
						aPeriodos	,;	//Periodos que foram carregados
						lValidPer	 ;	//Se deve validar os Periodos
					)

Local aAreaSPO		:= SPO->( GetArea() )
Local cAlias		:= "SPO"
Local lRet			:= .T.
Local nPosDataIni	:= ( cAlias )->( FieldPos( "PO_DATAINI" ) )
Local nPosDataFim	:= ( cAlias )->( FieldPos( "PO_DATAFIM" ) )

Local dPoDataIni
Local dPoDataFim
Local dFirstDate
Local dLastDate
Local nRecno

DEFAULT dPerIni		:= IF( IsMemVar("PO_DATAINI") , GetMemVar( "PO_DATAINI" ) , Ctod("//") )
DEFAULT dPerFim		:= IF( IsMemVar("PO_DATAFIM") , GetMemVar( "PO_DATAFIM" ) , Ctod("//") )
DEFAULT lNotInclui	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT lValidPer	:= .T.

aPeriodos := {}

Begin Sequence

	IF !( lRet := MaxP8PGOrdVld( dPerIni , dPerFim , lShowHelp ) )
		Break
	EndIF

	IF !( lRet := ( nPosDataIni > 0 ) )
		Break
	EndIF

	IF !( lRet := ( nPosDataFim > 0 ) )
		Break
	EndIF

	Inclui	:= IF( ( Type( "Inclui" ) == "U" ) , lNotInclui , Inclui )
	cFil	:= xFilial( cAlias , cFil )

	SPO->( dbSetOrder( RetOrdem( "SPO" , "PO_FILIAL+DTOS(PO_DATAINI)" ) ) )
	IF ( cAlias )->( dbSeek( cFil , .F. ) )
		While ( cAlias )->( !Eof() .and. PO_FILIAL == cFil )
			IF IF( Inclui , Inclui , !( nRecno := ( cAlias )->( Recno() ) == aAreaSPO[ 3 ] ) )
				dPoDataIni	:= ( cAlias )->( FieldGet( nPosDataIni ) )
				IF Empty( dFirstDate )
					dFirstDate	:= dPoDataIni
				EndIF
				dPoDataFim	:= ( cAlias )->( FieldGet( nPosDataFim ) )
				dLastDate	:= dPoDataFim
				IF ( lValidPer )
					IF ConflictDate( dPerIni , dPerFim , dPoDataIni , dPoDataFim )
						lRet := .F.
						Break
					EndIF
				EndIF
				aAdd( aPeriodos , { dPoDataIni , dPoDataFim , nRecno } )
			EndIF
			( cAlias )->( dbSkip() )
		End While
	EndIF

	IF ( lValidPer )

		IF ( !Empty( dFirstDate ) .and. !Empty( dLastDate ) )
			IF ConflictDate( dPerIni , dPerFim , dFirstDate , dLastDate )
				lRet := .F.
				Break
			EndIF
		EndIF	

	EndIF

End Sequence

IF ( ( lShowHelp ) .and. !( lRet ) )
	Help(" ",1,"PONA290PER")
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PutPerSPO	  ³Autor³ Marinaldo de Jesus  ³ Data ³09/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gravar Periodo de Apontamento na Tabela de Periodos de  Apon³
³          ³Tamento														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutPerSPO( cFil , dPerIni , dPerFim , cFlag , cRespon )

Local aArea		:= GetArea()
Local cAlias	:= "SPO"
Local lRet		:= .F.

DEFAULT cFil	:= ""
DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")
DEFAULT cFlag	:= "0"
DEFAULT cRespon	:= "S"

IF !( cFlag $ "01" )
	cFlag := "0"
EndIF

IF !( cRespon $ "US" )
	cRespon := "U"
EndIF

IF ( lRet := ValidPerSPO( @cFil , dPerIni , dPerFim , .T. , .F. ) )
	IF ( lRet := ( cAlias )->( RecLock( cAlias , .T. , .F. ) ) )
		( cAlias )->( FieldPut( FieldPos( "PO_FILIAL"  ) , cFil		) )
		( cAlias )->( FieldPut( FieldPos( "PO_DATAINI" ) , dPerIni	) )
		( cAlias )->( FieldPut( FieldPos( "PO_DATAFIM" ) , dPerFim	) )
		( cAlias )->( FieldPut( FieldPos( "PO_FLAGFEC" ) , cFlag   	) )
		( cAlias )->( FieldPut( FieldPos( "PO_RESPONS" ) , cRespon 	) )
		( cAlias )->( MsUnLock() )
	EndIF
EndIF

RestArea( aArea )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³RetPerSPO	  ³Autor³ Marinaldo de Jesus  ³ Data ³29/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retornar Periodos de Apontamento do SPO                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RetPerSPO( cFil )

Local aArea		:= GetArea()
Local aAreaSPO	:= SPO->( GetArea() )
Local aPerSPO	:= {}

cFil := xFilial( "SPO" , cFil )

While SPO->( !Eof() .and. cFil == PO_FILIAL )
	SPO->( aAdd( aPerSPO , { PO_DATAINI , PO_DATAFIM } ) , dbSkip() )
End While

( RestArea( aAreaSPO ) , RestArea( aArea ) )

Return( aPerSPO )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³CheckModSPO   ³Autor³ Marinaldo de Jesus  ³ Data ³09/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica o Modo de Acesso do SPO e,se nao for compartilhado,³
³          ³Duplica os Parametros MV_PONMES e MV_PAPONTA				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CheckModSPO()

Local aArea		:= GetArea()
Local aAreaSMO	:= SM0->( GetArea() )
Local lRet		:= .T.

Begin Sequence

	IF ( lRet := Empty( xFilial( "SPO" ) ) )
		Break
	EndIF
	
	IF ( lRet := SM0->( dbSeek( cEmpant , .F. ) ) )
		While SM0->( !Eof() .and. M0_CODIGO == cEmpAnt )
			IF ( lRet := DuplicaMv( FWGETCODFILIAL , "MV_PONMES" ) )
				IF !( lRet := DuplicaMv( FWGETCODFILIAL , "MV_PAPONTA" ) )
					Break
				EndIF
			Else
				Break
			EndIF
			SM0->( dbSkip() )
		End While
	EndIF

End Sequence

IF !( lRet )
	Help( "" , 1 , "NOEXISTMVS" )
EndIF

( RestArea(  aAreaSMO ) , RestArea(  aArea ) )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PerApoConPad  ³Autor³ Marinaldo de Jesus  ³ Data ³12/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Monta Consulta Padrao para o Periodo de Apontamento  baseada³
³          ³no SPO                                      				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<void>                                                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PerApoConPad()
Return( ConPad1( NIL , NIL , NIL , "SPO" , NIL , NIL , .F. ) ) 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PutPerMvPar	  ³Autor³ Marinaldo de Jesus  ³ Data ³26/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Carregar o Periodo de Apontamento nas Variaveis dos   Parame³
³          ³tros                                        				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutPerMvPar( cParGroup , cParDt1 , cParDt2 )

Local aArea			:= GetArea()
Local aAreaSX1		:= SX1->( GetArea() )
Local lRet			:= .T.
Local lConPad		:= .T.

DEFAULT cParGroup	:= ""
DEFAULT cParDt1		:= ""
DEFAULT cParDt2 	:= ""

IF ( lConPad := PerApoConPad() )
	IF SX1->( dbSeek( cParGroup + cParDt1 , .F. ) )
		IF ( Type( SX1->X1_VAR01 ) == "D" )
			&( SX1->X1_VAR01 ) := SPO->PO_DATAINI
		EndIF
	EndIF
	IF SX1->( dbSeek( cParGroup + cParDt2 , .F. ) )
		IF ( Type( SX1->X1_VAR01 ) == "D" )
			&( SX1->X1_VAR01 ) := SPO->PO_DATAFIM
		EndIF
	EndIF
EndIF

( RestArea( aAreaSX1 ) , RestArea( aArea ) )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonRetOpcBox  ³Autor³ Marinaldo de Jesus  ³ Data ³10/09/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retornar as Opcoes para o X3_BOX                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³#PonRetOpcBox( nOpcBox )									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³SX3->X3_BOX   												³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonRetOpcBox( nOpcBox )

Local cOpcBox	:= ""

DEFAULT nOpcBox	:= 0

IF ( nOpcBox == 01 )
	cOpcBox += ( "S=" + STR0113 + ";"	)	//"Trabalhado"
	cOpcBox += ( "C=" + STR0109	+ ";"	)	//"Compensado"
	cOpcBox	+= ( "D=" + STR0110 + ";"	)	//"D.S.R"
	cOpcBox += ( "N=" + STR0112	     	)	//"Nao Trabalhado"
ElseIF ( nOpcBox == 02 )
	cOpcBox += ( "S=" + STR0113 + ";"	)	//"Trabalhado"
	cOpcBox += ( "C=" + STR0109	+ ";"	)	//"Compensado"
	cOpcBox	+= ( "D=" + STR0110 + ";"	)	//"D.S.R"
	cOpcBox += ( "N=" + STR0112	+ ";"	)	//"Nao Trabalhado"
	cOpcBox += ( "F=" + STR0111	   		)	//"Feriado"	
ElseIF ( nOpcBox == 03 )
	cOpcBox += ( "1=" + STR0120 + ";"	)	//"Normal"
	cOpcBox += ( "2=" + STR0110	+ ";"	)	//"D.S.R"
	cOpcBox	+= ( "3=" + STR0109 + ";"	)	//"Compensada"
	cOpcBox += ( "4=" + STR0111	+ ";"	)	//"Feriado"
	cOpcBox += ( "5=" + STR0121	+ ";"	)	//"Noturna Normal"
	cOpcBox += ( "6=" + STR0122	+ ";"	)	//"Noturna D.S.R"
	cOpcBox += ( "7=" + STR0123	+ ";"	)	//"Noturna Compensada"
	cOpcBox += ( "8=" + STR0124	     	)	//"Noturna Feriado"
ElseIF ( nOpcBox == 04 )
	cOpcBox += ( "1=" + STR0120 + ";"	)	//"Normal"
	cOpcBox += ( "2=" + STR0110	+ ";"	)	//"D.S.R"
	cOpcBox	+= ( "3=" + STR0109 + ";"	)	//"Compensada"
	cOpcBox += ( "4=" + STR0111	+ ";"	)	//"Feriado"
	cOpcBox += ( "5=" + STR0121	+ ";"	)	//"Noturna Normal"
	cOpcBox += ( "6=" + STR0122	+ ";"	)	//"Noturna D.S.R"
	cOpcBox += ( "7=" + STR0123	+ ";"	)	//"Noturna Compensada"
	cOpcBox += ( "8=" + STR0124	+ ";"  	)	//"Noturna Feriado"
	cOpcBox += ( "A=" + STR0078	+ ";"	)	//"Intervalo Normal"
	cOpcBox += ( "B=" + STR0079	+ ";"   )	//"Intervalo Noturna"
	cOpcBox += ( "C=" + STR0195	+ ";"   )	//"Intervalo DSR"
	cOpcBox += ( "D=" + STR0196	+ ";"   )	//"Intervalo Noturna DSR"
	cOpcBox += ( "E=" + STR0197	+ ";"   )	//"Intervalo Compensado"
	cOpcBox += ( "F=" + STR0198	+ ";"   )	//"Intervalo Noturna Compensado"
	cOpcBox += ( "G=" + STR0199	+ ";"   )	//"Intervalo Feriado"
	cOpcBox += ( "H=" + STR0200         )	//"Intervalo Noturna Feriado"
ElseIF ( nOpcBox == 05 )
	cOpcBox += ( "S=" + STR0125 + ";"	)	//'Sim'
	cOpcBox += ( "N=" + STR0126      	)	//'Nao'
ElseIF ( nOpcBox == 06 )
	cOpcBox += ( "1E=" + STR0080 + ";"	)	//'1a. Entrada'
	cOpcBox += ( "1S=" + STR0081 + ";"	)	//'1a. Saida  '
	cOpcBox += ( "2E=" + STR0082 + ";"	)	//'2a. Entrada'
	cOpcBox += ( "2S=" + STR0083 + ";"	)	//'2a. Saida  '
	cOpcBox += ( "3E=" + STR0084 + ";"	)	//'3a. Entrada'
	cOpcBox += ( "3S=" + STR0085 + ";"	)	//'3a. Saida  '
	cOpcBox += ( "4E=" + STR0086 + ";"	)	//'4a. Entrada'
	cOpcBox += ( "4S=" + STR0087      	)	//'4a. Saida  '
ElseIF ( nOpcBox == 07 )
	 cOpcBox += ( "1I=" + STR0088 + ";"	)	//'1o. Intervalo '
	 cOpcBox += ( "2I=" + STR0089 + ";"	)	//'2o. Intervalo '
	 cOpcBox += ( "3I=" + STR0090       )	//'3o. Intervalo '
ElseIF ( nOpcBox == 08 )
	 cOpcBox += ( "S=" + STR0125 + ";"	)	//'Sim'
	 cOpcBox += ( "N=" + STR0126 + ";" 	)	//'Nao'
	 cOpcBox += ( "D=" + STR0110 + ";"	)	//"D.S.R"
	 cOpcBox += ( "C=" + STR0109      	)	//"Compensado"
ElseIF ( nOpcBox == 09 )
	 cOpcBox += ( "T=" + STR0127 + ";"	)	//"Total"
	 cOpcBox += ( "P=" + STR0128      	)	//"Parcial"
ElseIF ( nOpcBox == 10 )
	 cOpcBox += ( "1=" + STR0129 + ";"	)	//"Provento"
	 cOpcBox += ( "2=" + STR0130 + ";"	)	//"Desconto"
	 cOpcBox += ( "3=" + STR0131      	)	//"Base"
ElseIF ( nOpcBox == 11 )
	 cOpcBox += ( "S=" + STR0132 + ";"	)	//"Semanal"
	 cOpcBox += ( "Q=" + STR0133 + ";"	)	//"Quinzenal"
	 cOpcBox += ( "M=" + STR0134      	)	//"Mensal"
ElseIF ( nOpcBox == 12 )
	 cOpcBox += ( "D=" + STR0135 + ";"	)	//"Diario"	 
	 cOpcBox += ( "S=" + STR0132 + ";"	)	//"Semanal"
	 cOpcBox += ( "Q=" + STR0133 + ";"	)	//"Quinzenal"
	 cOpcBox += ( "M=" + STR0134      	)	//"Mensal"
ElseIF ( nOpcBox == 13 )
	 cOpcBox += ( "A=" + STR0136 + ";"	)	//"Anterior"	 
	 cOpcBox += ( "P=" + STR0137 + ";"	)	//"Posteior"
	 cOpcBox += ( "T=" + STR0138		)	//"Todos"
ElseIF ( nOpcBox == 14 )
	 cOpcBox += ( "H=" + STR0139 + ";"	)	//"Horas"	 
	 cOpcBox += ( "V=" + STR0140 + ";"	)	//"Valor"
	 cOpcBox += ( "D=" + STR0141		)	//"Dias"
ElseIF ( nOpcBox == 15 )
	 cOpcBox += ( "A=" + STR0142 + ";"	)	//"Atrasos"	 
	 cOpcBox += ( "S=" + STR0143 + ";"	)	//"Saidas Antecipadas"
	 cOpcBox += ( "H=" + STR0144 + ";"	)	//"Horas Extras"
	 cOpcBox += ( "D=" + STR0145 + ";"	)	//"Descanso Semanal Remunerado"
	 cOpcBox += ( "F=" + STR0146 + ";"	)	//"Faltas"
	 cOpcBox += ( "N=" + STR0147 + ";"	)	//"Adicional Noturno"
	 cOpcBox += ( "9=" + STR0148      	)	//"Nona Hora"
ElseIF ( nOpcBox == 16 )
	 cOpcBox += ( "0=" + STR0149 + ";"	)	//"Fechado"
	 cOpcBox += ( "1=" + STR0150      	)	//"Aberto"
ElseIF ( nOpcBox == 17 )
	 cOpcBox += ( "S=" + STR0151 + ";"	)	//"Sistema"
	 cOpcBox += ( "U=" + STR0152     	)	//"Usuario"
ElseIF ( nOpcBox == 18 )
	 cOpcBox += ( "1=" + STR0129 + ";"	)	//"Provento"
	 cOpcBox += ( "2=" + STR0130 + ";"	)	//"Desconto"
	 cOpcBox += ( "3=" + STR0216 + ";"	)	//"Base ( Provento )"
	 cOpcBox += ( "4=" + STR0217        )	//"Base ( Desconto )"
ElseIf ( nOpcBox == 19 )
	 cOpcBox += ( "2=" + STR0016 + ";"	)	//"lunes"
	 cOpcBox += ( "3=" + STR0017 + ";"	)	//"martes"
	 cOpcBox += ( "4=" + STR0018 + ";"	)	//"miercoles"
	 cOpcBox += ( "5=" + STR0019 + ";"	)	//"jueves"	 
	 cOpcBox += ( "6=" + STR0020 + ";"	)	//"viernes" 
 	 cOpcBox += ( "7=" + STR0021 + ";"	)	//"sabado"	 
	 cOpcBox += ( "1=" + STR0015 + ";"	)	//"domingo"	  
EndIF

Return( cOpcBox )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³MaxP8PGOrdVld	³Autor³Marinaldo de Jesus ³ Data ³24/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Numero de Ordens possiveis para o SP8 e SPG confor³
³          ³me Periodo de Apontamento									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function MaxP8PGOrdVld( dPerIni , dPerFim , lShowHelp , nOrdens )
         
Local cMsg			:= ""
Local lOrdensOk		:= .F.
Local nDias			:= 0

DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lShowHelp	:= .T.

nDias 	:= ( ( dPerFim - dPerIni ) + 1 )
nOrdens	:= Val( Replicate( "9" , __nTamP8Ordem ) )
Begin Sequence
	IF !( lOrdensOk := ( nDias <= nOrdens ) )
		cMsg := STR0160 //"O numero de dias do periodo ultrapassou o numero de ordens permitidas para o SP8"
		Break
	EndIF
	nOrdens	:= Val( Replicate( "9" , __nTamPGOrdem ) )
	IF !( lOrdensOk := ( nDias <= nOrdens ) )
		cMsg := STR0161 //"O numero de dias do periodo ultrapassou o numero de ordens permitidas para o SPG"
		Break
	EndIF
End Sequence	

IF ( lShowHelp )
	IF ( !( lOrdensOk ) .and. !Empty( cMsg ) )
		cMsg += CRLF
		cMsg += STR0162 + AllTrim( Str( nDias ) )	//'Numero de dias do Periodo:'
	 	cMsg += CRLF
	 	cMsg += STR0163 + AllTrim( Str( nOrdens ) )	//'Numero Maximo de Ordens:
		MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0159 ) ) //"Aten‡„o!"
	EndIF
EndIF

Return( lOrdensOk  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PonIncDate		³Autor³Marinaldo de Jesus ³ Data ³28/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Incrementa Periodo de Acordo com os dias do Periodo Anterior³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonIncDate( dPerIni , dPerFim  )

Local dDateAux
Local nDias

DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")

IF ( dPerFim < dPerIni )
	dDateAux	:= dPerIni
	dPerIni		:= dPerFim
	dPerFim		:= dDateAux
EndIF

nDias		:= ( dPerFim - dPerIni )
dPerIni 	:= ( dPerFim + 1  )
dPerFim 	:= ( dPerIni + nDias )

Return( nDias )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PonDecDate		³Autor³Marinaldo de Jesus ³ Data ³22/01/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Decrementa Periodo de Acordo com os dias do Periodo Anterior³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonDecDate( dPerIni , dPerFim  )

Local dDateAux
Local nDias

DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")

IF ( dPerFim < dPerIni )
	dDateAux	:= dPerIni
	dPerIni		:= dPerFim
	dPerFim		:= dDateAux
EndIF

nDias		:= ( dPerFim - dPerIni )
dPerFim 	:= ( dPerIni - 1 )
dPerIni 	:= ( dPerFim - nDias )

Return( nDias )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PonDelRecnos	³Autor³Marinaldo de Jesus ³ Data ³12/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Deletar Registros conforme Alias e Array aRecnos            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonDelRecnos(	cAlias			,;	//01 -> Alias
						aRecnos 		,;	//02 -> Array com os Recnos
						bCondDele		,;	//03 -> Bloco com a Condicao para Delecao
						uParbCondDele	,;	//04 -> Parametro para o Bloco 
						aMsMmCpos		,;	//05 -> Array com os campos Memo para Delecao
						cAliasMsMm		 ;	//06 -> Alias para a MsMm
					)
Return(DelRecnos(@cAlias,@aRecnos,@bCondDele,@uParbCondDele,@aMsMmCpos,@cAliasMsMm))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonModPer	³ Autor ³Marinaldo de Jesus    ³ Data ³06/09/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Possibilitar a Alteracao do parametro MV_PERAPONTA e a  conse³
³          ³sequente atualizacao do MV_PONMES							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonModPer( lModPer , cFil )

DEFAULT lModPer := .T.

IF ( lModPer )
	lModPer := PonActModPer( cFil )
EndIF

Return( MbrChgLoop( .F. ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonActModPer³ Autor ³Marinaldo de Jesus    ³ Data ³06/09/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Possibilitar a Alteracao do parametro MV_PERAPONTA e a  conse³
³          ³sequente atualizacao do MV_PONMES							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function PonActModPer( cFil )

Local aSvKeys		:= GetKeys()
Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local cAntDiaIniFim	:= Space( 05 )
Local cAtuDiaIniFim	:= Space( 05 )
Local cNewPerPutMv	:= ""
Local cSvFilAnt		:= cFilAnt
Local cMsgPaponta	:= ""
Local dAntIniPer	:= Ctod("//")
Local dAntFimPer	:= Ctod("//")
Local dAtuIniPer	:= Ctod("//")
Local dAtuFimPer	:= Ctod("//")
Local dIniPonMes	:= Ctod("//")
Local dFimPonMes	:= Ctod("//")
Local lModPerOk		:= .F.
Local lModPonMes	:= .F.
Local lPapontaPer	:= .F.
Local lVisualizar	:= .F.
Local nOpcModPer	:= 0
Local oDlg 			:= NIL
Local oFont			:= NIL
Local oGroup1		:= NIL
Local oGroup2		:= NIL
Local oGroup3		:= NIL
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Declaração de arrays para dimensionar tela		             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

DEFAULT cFil		:= cSvFilAnt

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )
       
IF ( Type( "Inclui" ) == "L" )
	Inclui := .F.
EndIF

IF !( Type( "cCadastro" ) == "C" )
	Private cCadastro := ""
EndIF

IF !( ( nOpcModPer := PonOpcModPer() ) == 0 )

	cAntDiaIniFim := GetPaponta( cFil )

	GetPonMesDat( @dIniPonMes , @dFimPonMes , cFilAnt )

	lModPonMes	:= ( nOpcModPer == 2 )
	lVisualizar	:= ( nOpcModPer == 3 )

	IF ( lPapontaPer := PerCompleto( cAntDiaIniFim ) )
		dAntIniPer		:= Stod( Left(	cAntDiaIniFim , 08 ) )
		dAntFimPer		:= Stod( Right( cAntDiaIniFim , 08 ) )
		cAntDiaIniFim	:= Space( 05 )
	Else
		cAntDiaIniFim	:= Left( cAntDiaIniFim, 02 ) + '/' + Right( cAntDiaIniFim , 02 )
	EndIF
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aAdvSize			:= MsAdvSize()
	aAdvSize[5]			:=	420 //horizontal
	aAdvSize[3]			:=	210 // LARGURA
	aAdvSize[4]			:=	90  // ALTURA
	aAdvSize[6]			:=  230 //Vertical
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )
	
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro + " - " + STR0167 ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL	//"Modificar Periodo de Apontamento"
	
		@ aObjSize[1][1],aObjSize[1][2] GROUP oGroup1 TO aObjSize[1][3],aObjSize[1][4] LABEL OemToAnsi(STR0168) OF oDlg PIXEL		//""Periodo Anterior do Parametro MV_PAPONTA"
		oGroup1:oFont:=oFont

		IF !( lPapontaPer )
			@ aObjSize[1][1]+10,aObjSize[1][2]+10 SAY OemToAnsi( STR0164 )	SIZE	50,10 OF oDlg PIXEL FONT oFont	//"Dia Inicial/Final"
			@ aObjSize[1][1]+10,aObjSize[1][2]+55 MSGET cAntDiaIniFim		SIZE	50,10 OF oDlg PIXEL FONT oFont WHEN ( .F. ) PICTURE "99/99" 
	    Else
			@ aObjSize[1][1]+10,aObjSize[1][2]+10 SAY OemToAnsi( STR0165 )	SIZE	50,10 OF oDlg PIXEL FONT oFont	//"Anterior"
			@ aObjSize[1][1]+10,aObjSize[1][2]+55 MSGET dAntIniPer			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN ( .F. )  HASBUTTON
			@ aObjSize[1][1]+10,aObjSize[1][2]+120 MSGET dAntFimPer			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN ( .F. ) HASBUTTON
	    EndIF
	    
		IF !( lVisualizar )

			@ aObjSize[2][1],aObjSize[2][2] GROUP oGroup2 TO aObjSize[2][3],aObjSize[2][4] LABEL OemToAnsi(STR0169) OF oDlg PIXEL			//"Novo Periodo para o Parametro MV_PAPONTA"
			oGroup2:oFont:=oFont
		
			IF !( lModPonMes )
				@ aObjSize[2][1]+10,aObjSize[2][2]+10 	SAY OemToAnsi( STR0164 )	SIZE	50,10 OF oDlg PIXEL FONT oFont	//"Dia Inicial/Final"
				@ aObjSize[2][1]+10,aObjSize[2][2]+55 	MSGET cAtuDiaIniFim			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( IF( !( lModPonMes ) , IF( lVisualizar , !( lVisualizar ) , !( lModPonMes ) ) , .F. ) ) PICTURE "99/99"
			Else
				@ aObjSize[2][1]+10,aObjSize[2][2]+10  SAY OemToAnsi( STR0165 )	SIZE	50,10 OF oDlg PIXEL FONT oFont	//"Periodo"
				@ aObjSize[2][1]+10,aObjSize[2][2]+55  MSGET dAtuIniPer		   		SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( IF( lModPonMes , IF( lVisualizar , !( lVisualizar ) , lModPonMes ) , .F. ) )	 HASBUTTON
				@ aObjSize[2][1]+10,aObjSize[2][2]+120 MSGET dAtuFimPer				SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( IF( lModPonMes , IF( lVisualizar , !( lVisualizar ) , lModPonMes ) , .F. ) )	 HASBUTTON
			EndIF
        
		ELSE
			aObjSize[3] := aClone(aObjSize[2])
		EndIF
	
		@ aObjSize[3][1],aObjSize[3][2] GROUP oGroup3 TO aObjSize[3][3],aObjSize[3][4] LABEL OemToAnsi(STR0178) OF oDlg PIXEL			//"Periodo Atual do parametro MV_PONMES"
		oGroup3:oFont:=oFont

		@ aObjSize[3][1]+10,aObjSize[3][2]+10  MSGET dIniPonMes	SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( .F. )	 HASBUTTON
		@ aObjSize[3][1]+10,aObjSize[3][2]+75 MSGET dFimPonMes	SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( .F. )	 HASBUTTON
			
		IF ( lVisualizar )
			bSet15	:= { || oDlg:End() }
		Else
			bSet15	:= { || IF( lModPerOk := PonOkModPer( StrTran( cAtuDiaIniFim , "/" , "" ) , dAtuIniPer , dAtuFimPer , lModPonMes ) , oDlg:End() , lModPerOk ) }
		EndIF
		bSet24		:= { || oDlg:End() }
	
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24  ) CENTERED  
	
	IF ( ( lModPerOk ) .and. !( lVisualizar ) )
	    IF ( lModPonMes )
			cNewPerPutMv := ( Dtos( dAtuIniPer ) + "/" + Dtos( dAtuFimPer ) )
			PutMvFil( "MV_PAPONTA"	, cNewPerPutMv  , cFilAnt )
			PutMvFil( "MV_PONMES"	, cNewPerPutMv  , cFilAnt )
	    Else
	    	cNewPerPutMv := cAtuDiaIniFim
	    	PutMvFil( "MV_PAPONTA"	, cNewPerPutMv  , cFilAnt )
	    	PutMvFil( "MV_PONMES"	, "" , cFilAnt )
			lModPerOk := CheckPonMes( @dAtuIniPer , @dAtuFimPer , .F. , .F. , .T. , cFilAnt , .F. , NIL )
	    	IF ( lModPerOk )
	    		cMsgPaponta := MsgPaponta( cNewPerPutMv , dAtuIniPer , dAtuFimPer , cFilAnt )
	    	EndIF
	    EndIF
		//"Caso as Marca‡”es j  tenham sido apontadas, ser  necess rio for‡ar o Reapontamento para ajust -las ao novo periodo."
		IF Empty( cMsgPaponta )
			cMsgPaponta := ( Dtoc( dAtuIniPer ) + " - " + Dtoc( dAtuFimPer ) + CRLF + CRLF + STR0177 )
		Else
			cMsgPaponta := ( Dtoc( dAtuIniPer ) + " - " + Dtoc( dAtuFimPer ) + CRLF + CRLF + STR0177 + CRLF + CRLF + cMsgPaponta )
		EndIF
		MsgInfo( OemToAnsi( cMsgPaponta ) , OemToAnsi( STR0176 ) )	//"Novo Periodo do Ponto em Aberto"
	EndIF
	
	IF ( Type( "Inclui" ) == "L" )
		Inclui := .F.
	EndIF

EndIF

RestKeys( aSvKeys , .T. )

cFilAnt := cSvFilAnt

Return( lModPerOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonOpcModPer 	³Autor³Marinaldo de Jesus ³ Data ³04/03/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Dialogo com as Opcoes para Modificacao do Periodo 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PonOpcModPer()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Numero da Opcao da Mudanca do Periodo:1 -> Dia Inicial/Final³
³          ³                                      2 -> Periodo          ³
³          ³                                      3 -> Visualizar		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³PonModPer()											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function PonOpcModPer()

Local aSvKeys		:= GetKeys()
Local bSet15		:= { || lOpcOk := .T. , RestKeys( aSvKeys , .T. ) ,  oDlg:End() }
Local bSet24		:= { || RestKeys( aSvKeys , .T. ) , oDlg:End() }
Local nOpcModPer	:= 1
Local lOpcOk		:= .F.
Local oRadio		:= NIL
Local oDlg			:= NIL
Local oGroup		:= NIL
Local oFont			:= NIL
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Declaração de arrays para dimensionar tela		             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdvSize			:= MsAdvSize()
aAdvSize[5]			:=	420 //horizontal
aAdvSize[3]			:=	212 // LARGURA
aAdvSize[4]			:=	62  // ALTURA
aAdvSize[6]			:=  150 //Vertical
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T.  } )
aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi( STR0167 ) OF GetWndDefault() PIXEL	//"Modificar Periodo de Apontamento"

	@ aObjSize[1][1],aObjSize[1][2]	GROUP oGroup TO aObjSize[1][3],aObjSize[1][4] LABEL OemToAnsi(STR0166) OF oDlg PIXEL	//"Escolha a Op‡„o para a Modifica‡„o do Parametro:"
	oGroup:oFont:=oFont
	
	@ aObjSize[1][1]+10,aObjSize[1][2]+10	RADIO oRadio VAR nOpcModPer ITEMS;
					 	OemToAnsi(STR0164)	,;			//"Dia Inicial/Final"
						OemToAnsi(STR0165)	,;			//"Periodo"
						OemToAnsi(STR0179)	 ;			//'Apenas Visualizar'
						SIZE 115,010 OF oDlg PIXEL
	
	oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.	

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 ) CENTERED 
RestKeys( aSvKeys , .T. )

IF !( lOpcOk )
	nOpcModPer := 0
EndIF

Return( nOpcModPer )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonOkModPer  	³Autor³Marinaldo de Jesus ³ Data ³04/03/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Novo Periodo de Apontamento             			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PonOkModPer()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³PonModPer()											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function PonOkModPer( cPeriodo , dPerIni , dPerFim , lPeriodo )

Local cMsg			:= ""
Local lOK			:= .F.

Begin Sequence

	IF ( lPeriodo )
		IF !( lOk := ( !Empty( dPerIni ) .and. !Empty( dPerFim ) ) )
			cMsg := STR0173	// "Data Inicial ou Data Final em Branco"
			Break
		EndIF
		IF !( lOk := ( dPerFim >= dPerIni ) )
			cMsg := STR0172 //"Data Inicial maior que Data Final"
			Break
		EndIF
		IF !( lOk := MaxP8PGOrdVld( dPerIni , dPerFim ) )
			cMsg := ""
			Break
		EndIF
		IF !( lOk := ValidPerSPO( cFilAnt , dPerIni , dPerFim , .T. , .F. ) )
			cMsg := STR0171	//"Periodo Ja Cadastrado no SPO ( Cadastro de Periodos )"
			Break
		EndIF
	Else
		IF !( lOk := ( !Empty( cPeriodo ) ) )
			cMsg := STR0170	//"O Periodo nao pode ficar em Branco"
			Break
		EndIF
	EndIF

End Sequence

IF ( !( lOk ) .and. !Empty( cMsg ) )
	MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0174 + " - " + STR0175  ) ) //"Aten‡„o!"###"Existem Inconsistencias a serem verificadas."
EndIF

Return( lOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³MsgPaponta  	³Autor³Marinaldo de Jesus ³ Data ³01/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se Existe Alguma Inconsistencia no preenchimento do³
³          ³MV_PAPONTA e Emite Mensagem correspondente				    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<vide parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³PonModPer()											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function MsgPaponta( cPerAponta , dAtuIniPer , dAtuFimPer , cFil )

Local cMsgPaponta	:= ""
Local lMaisDias		:= .F.

Local cMsgIniPer
Local cMsgFimPer
Local cMesAux
Local cAnoAux
Local dDataAux
Local nDiaAux
Local nMesAux
Local nAnoAux
Local nUltDiaMes
Local nDiaIni
Local nDiaFim
Local nIniDif
Local nFimDif

Begin Sequence

	IF PerCompleto( @cPerAponta , cFil )
		Break
	EndIF

	IF !PapontaOk( cPerAponta , NIL , NIL , cFil )
		Help( "" , 1 , "PERNCAD" )
		Break
	EndIF

	nDiaIni := Day( dAtuIniPer )
	nDiaFim := Day( dAtuFimPer )

	IF ( AnoMes( dAtuIniPer ) == AnoMes( dAtuFimPer ) )

 		IF ( nDiaIni > 1 )
			nIniDif := ( nDiaIni - 1 )
			IF ( nIniDif > 0 )
				cMsgIniPer	:= Day2Str( nIniDif )
				cMsgIniPer	+= " "
				cMsgIniPer	+= STR0210	//"dia(s), no Inicio do período,"
			EndIF
		EndIF

 		nUltDiaMes := f_UltDia( Ctod( "01/" + Month2Str( dAtuFimPer ) + "/" + Year2Str( dAtuFimPer ) , "DDMMYYYY" ) )
 		IF ( nDiaFim < nUltDiaMes )
			nFimDif := ( nUltDiaMes - nDiaFim )
			IF ( nFimDif > 0 )
				IF !Empty( cMsgIniPer )
					cMsgIniPer += " "
					cMsgIniPer += STR0211 //"e"
					cMsgIniPer += " "
				EndIF
				cMsgFimPer := Day2Str( nFimDif )
				cMsgFimPer += " "
				cMsgFimPer += STR0212	//"dia(s), no Final do período,"
			EndIF
		EndIF

 		Break

 	EndIF

	IF ( nDiaIni > nDiaFim )

		nFimDif := ( ( nDiaIni - nDiaFim ) - 1 )
		IF ( nFimDif > 0 )
			cMsgFimPer := Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do período,"
		EndIF
		
		Break

	EndIF

	IF ( nDiaIni < nDiaFim )

		nUltDiaMes	:= f_UltDia( Ctod( "01/" + Month2Str( dAtuIniPer ) + "/" + Year2Str( dAtuIniPer ) , "DDMMYYYY" ) )
		nIniDif		:= ( ( nUltDiaMes - nDiaIni ) + 1 )
		nFimDif		:= nDiaFim
		IF ( lMaisDias := ( ( nIniDif + nFimDif ) > nUltDiaMes ) )
			nFimDif := ( ( nIniDif + nFimDif ) - nUltDiaMes )
			cMsgFimPer := STR0214 //"mais"
			cMsgFimPer += " "
			cMsgFimPer += Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do período,"
			Break
		EndIF

		nDiaAux		:= ( nDiaIni - 1 )
		nMesAux		:= ( Month( dAtuFimPer ) + 1 )
		nAnoAux		:= Year( dAtuFimPer )
		IF ( nMesAux > 12 )
			nMesAux := 1
			++nAnoAux
		EndIF
		cMesAux		:= Month2Str( nMesAux )
		cAnoAux		:= Year2Str( nAnoAux )
		dDataAux	:= Ctod( Day2Str( nDiaAux ) + "/" + cMesAux + "/" + cAnoAux , "DDMMYYYY" )
		While Empty( dDataAux )
			dDataAux := Ctod( Day2Str( --nDiaAux ) + "/" + cMesAux + "/" + cAnoAux , "DDMMYYYY" )
		End While
		nUltDiaMes	:= f_UltDia( Ctod( "01/" + Month2Str( dAtuFimPer ) + "/" + Year2Str( dAtuFimPer ) , "DDMMYYYY" ) )
		nFimDif		:= ( nUltDiaMes - nDiaFim )
		nFimDif		+= Day( dDataAux )
		IF ( nFimDif > 0 )
			cMsgFimPer := Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do período,"
		EndIF
		
		Break

	EndIF

End Sequence

IF !Empty( cMsgIniPer ) .or. !Empty( cMsgFimPer )
	cMsgPaponta := STR0209	//"A Configuração Atual do MV_PAPONTA fará com que"
	cMsgPaponta += " "
	IF !Empty( cMsgIniPer )
		cMsgPaponta += cMsgIniPer
	EndIF	
	IF !Empty( cMsgFimPer )
		cMsgPaponta += cMsgFimPer
	EndIF	
	cMsgPaponta += " "
	IF !( lMaisDias )
		cMsgPaponta += STR0213	//"seja(m) desconsiderado(s) pelo sistema."
	Else
		cMsgPaponta += STR0215	//"seja(m) considerados(s) pelo sistema."
	EndIF	
	cMsgPaponta := ( STR0208 + CRLF + CRLF + cMsgPaponta ) //"Atenção!!!!"
EndIF	

Return( cMsgPaponta )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³InitP8PgOrdSize³Autor³Marinaldo de Jesus   ³ Data ³03/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializa as Statics __nTamP8PgOrdSize e __nTamP8PgOrdSize  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function InitP8PgOrdSize(nOpc)

Local nTam

DEFAULT nOpc := 1

IF ( Select("SX3") > 0 )
	IF ( nOpc == 1 )
		nTam := GetSx3Cache( "P8_ORDEM" , "X3_TAMANHO" )
	Else
		nTam := GetSx3Cache( "PG_ORDEM" , "X3_TAMANHO" )
	EndIF
EndIF
DEFAULT nTam := 2

Return( nTam )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonLockRegs		³Autor³Marinaldo de Jesus ³ Data ³11/06/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Tentativa de Lock em Varios Registros             			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lLocked                  									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico   											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonLockRegs(	cAlias			,;	//01 -> Alias onde os Registros devera haver Lock dos Registros
						aRegsLock		,;	//02 -> Array com os Recnos para Lock
						aKeysCode		,;	//03 -> Array com as Chaves para MayIUseCode
						nTentaLocks		,;	//04 -> Numero de Tentativas de Lock
						nSecondsWait	,;	//05 -> Segundos a aguardar para nova tentativa
						lMayIUseCode	,;	//06 -> Se ira utilizar MayIUseCode
						nMaxLocks		 ;	//07 -> Numero maximo de Locks
					)
Return(LockRegsCode(@cAlias,@aRegsLock,@aKeysCode,@nTentaLocks,@nSecondsWait,@lMayIUseCode,@nMaxLocks))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonFreeLocks    ³Autor³Marinaldo de Jesus ³ Data ³11/06/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Chamada da FreeLocks                                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                        									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico   											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonFreeLocks( cAlias , nReg , lFreeUseCode , cUseCode )
Return( FreeLocks( cAlias , nReg , lFreeUseCode , cUseCode ) )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fDemissao       ³Autor³Mauricio MR        ³ Data ³27/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a Situacao de Demissao do Funcionario              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                        									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³SIGAPON   											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fDemissao(cSituacao, cRescRais)
Local cRet    
If cRescRais$'30/31'
	cRet:= 'T'
Else 
	cRet:= cSituacao
Endif   
Return( cRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fVerTabRF0   ³Autor ³Mauricio MR          ³ Data ³05/10/05  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a Existencia da tabela de Pre-abonos e se a mesma  ³
³          ³possui registros.                                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
function  fVerTabRF0()
Local lRet		:= .F.
Local lVazio	:= .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica a Existencia da Tabela RF0 e se a mesma  ³
³possui conteudo. Somente nessas condicoes sera	   ³
³verficada a existencia de pre-abonos.			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lRet:= Sx2ChkTable( "RF0",, @lVazio) 	

lRet:= ( lRet .AND. !lVazio)

Return ( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Metodo    ³LoadCalError  ³ Autor ³ Mauricio MR       ³ Data ³05/02/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega tabelas de erros para a rotina do calendario        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³LoadCalError()				 								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Em cada rotina em que se deseja manter controle de erros    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
Function LoadCalError()  

Local aMsg  := {}

aAdd(aMsg, { "01", STR0007 } ) //"No se encontro la secuencia para la fecha "
aAdd(aMsg, { "02", STR0008 } ) //"No se encontro el turno "   
aAdd(aMsg, { "03", STR0009 } ) //"No se encontro la regla "
aAdd(aMsg, { "04", STR0219 } ) //"Periodo nao encontrado "
aAdd(aMsg, { "05", STR0220 } ) //"Nao e possivel gerar calendario por demanda, verificar parametro MV_CALDEM "
aAdd(aMsg, { "06", STR0221 } ) //"Nao foi possivel gravar calendario "
aAdd(aMsg, { "07", STR0223 } ) //"Não foi possível gerar o calendário para o período de: "
aAdd(aMsg, { "08", STR0224 } ) //"Somente é possível gerar calendário para períodos consecutivos."

Return(aClone(aMsg))
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fPnVldProc³ Autor ³ Igor Franzoi		    ³ Data ³17/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validacao do processo digitado nos perguntes utilizados nos ³±±
±±|			 |nos relatorios											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fPnVldProc												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico   												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fPnVldProc( cTip )

Local lRet := .F.

If ( cTip == "A" )
	lRet := ( ExistCpo("RCJ") .and. NaoVazio() )
Else
    lRet := ExistCpo("RCJ")
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fPnVldPer ³ Autor ³ Igor Franzoi		    ³ Data ³17/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validacao do processo digitado nos perguntes utilizados nos ³±±
±±|			 |nos relatorios											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fPnVldPer												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico   												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fPnVldPer( cTip )

Local cOldAlias := Alias()
Local cFilRCH	:= xFilial("RCH")
Local cMsg

Local lRet 		:= .T.

If ( cTip == 'A' )

	Begin Sequence
	
		IF !( lRet := NaoVazio() )
			Break
		EndIF
	
		DbSelectArea( "RCH" )
		RCH->( dbsetOrder( Retorder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+DTOS(RCH_DTFECH)" ) ) )
		RCH->( dbSeek( cFilRCH + MV_PAR01 + MV_PAR02 + SPACE(6) , .F. ) )
	
		If RCH->( Eof() )
			lRet := .F.
			cMsg := STR0218	// "Periodo nao Cadastrado!"
			MsgInfo( cMsg )
		EndIf
	
	End Sequence
	
EndIf

DbSelectArea(cOldAlias)

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fPnVldRot ³ Autor ³ Igor Franzoi		    ³ Data ³17/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validacao do processo digitado nos perguntes utilizados nos ³±±
±±|			 |nos relatorios											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fPnVldRot												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico   												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fPnVldRot( cTip )

Local lRet := .F.

If ( cTip == "A" )
	lRet := ( ExistCpo("SRY") .and. NaoVazio() )
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fPnVldNPag³ Autor ³ Igor Franzoi		    ³ Data ³17/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validacao do processo digitado nos perguntes utilizados nos ³±±
±±|			 |nos relatorios											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fPnVldNPag												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico   												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fPnVldNPag( cTip )

Local lRet := .F.

If ( cTip == "A" )
	lRet := NaoVazio()
EndIf

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ PonX1Valid ³ Autor ³ Leandro Drumond       ³ Data ³23/04/08³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Valida os campos periodo e numero de	pagamento da pergunte.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cChave 	- Chave de pesquisa (RCH)  						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Pergunte GPR040 - campos Processo (MV_PAR01), 			  ³±±
±±³    		 ³                   Roteiro (MV_PAR02), Periodo (MV_PAR03) e ³±±
±±³    		 ³                   Numero de Pagamento (MV_PAR04).          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß */
Function PonX1Valid(cChave)

Local cReadVar	:= Upper( AllTrim( ReadVar() ) )
Local cRoteiro 
Local lTipoAut
Local lRet 		:= .T.                   
Local nPerNumPg
Local nFilProces
Local nTamRoteiro

If Substr(cReadVar, 1, 3) == "M->"
	cReadVar := Substr(cReadVar,4)
EndIf

If cReadVar == "MV_PAR01"
	lRet 	  := ExistCpo("RCJ", cChave)
	cProcesso := cChave
ElseIf !(cReadVar == "MV_PAR04" .AND. mv_par04 == "99")
	If Substr(cChave, 6, 3) <> "EXT"
		DbSelectArea( "RCH" )
		DbSetOrder( 4 ) // RCH_FILIAL + RCH_PROCESSO + RCH_ROTEIRO + RCH_PERIODO + RCH_NUMPAG
		cChave := xFilial( "RCH" ) + cChave
		DbSeek( cChave, .F. ) 
		If Eof()
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Tratamento de Autonomos - Permite Nro. Pagto nao cadastrado  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			nFilProces 	:= GetSx3Cache( "RCH_FILIAL", "X3_TAMANHO" ) + GetSx3Cache( "RCH_PROCES", "X3_TAMANHO" )
			nTamRoteiro	:= GetSx3Cache( "RCH_ROTEIR", "X3_TAMANHO" )
			cRoteiro 	:= Substr(cChave, nFilProces+1, nTamRoteiro)
			nPerNumPg 	:= nFilProces + Len( cRoteiro ) + 1
			lTipoAut 	:= ( fGetTipoRot( cRoteiro ) == "9" )
			DbSelectArea("RCH")
			If lTipoAut
				DbSeek( Substr( cChave, 1, nFilProces ) + cRoteiro + Substr( cChave, nPerNumPg ) , .F. )
			EndIf
			If Eof()

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Pesquisar Periodo sem roteiro de calculo.                    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				cRoteiro := Space( nTamRoteiro )
				cChave := Substr( cChave, 1, nFilProces ) + cRoteiro + Substr( cChave, nPerNumPg )
				DbSeek( cChave, .F. )
				If Eof()
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Tratamento de Autonomos - Permite Nro. Pagto nao cadastrado  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If lTipoAut
						cChave := Substr( cChave, 1, nFilProces ) + cRoteiro
						DbSeek( cChave, .F. )
						If Eof()
							lTipoAut := .F.
						EndIf
					EndIf
					If !lTipoAut
						Help( " ", 1, "REGNOIS" )
						lRet 	 := .F.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

Return ( lRet )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PnRCHFiltro³Autor³Leandro Drumond            ³Data³08/05/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtro da Consulta Padrao RCH06								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)	 			                  	   	 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PnRCHFiltro(cCond)

Local cFiltro	:= "(RCH->RCH_FILIAL == '" + xFilial("RCH") + "')"
Local lPn090	:= IsInCallStack("PONM090")

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Criar as variaveis DEFAULT 								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
DEFAULT cCond := If( lPn090,"1","3")

If Type( "cProcesso" ) == "U"
	cProcesso := ""
EndIf

If Type( "cPeriodo" ) == "U"
	cPeriodo := ""
EndIf

If Type( "cRoteiro" ) == "U" .or. Empty(AllTrim(cRoteiro))
	cRoteiro := "PON"
EndIf

DEFAULT cRoteiro := "PON"

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Documentacao das Variaveis 								   ³
³															   ³
³cCond == 1 -> Periodos Abertos 							   ³
³      == 2 -> Periodos Fechados							   ³
³      == 3 -> Ambos	         							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If cCond == "1" .OR. cCond == "2" // Periodo aberto ou fechado
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	If cCond == "2" // Periodo fechado
		cFiltro := "!"
	EndIf
	cFiltro	+= "EMPTY(RCH->RCH_DTFECH)" 
EndIf
	
If !Empty(cPeriodo) .and. !lPn090
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	cFiltro += " (RCH->RCH_PER == '" + cPeriodo + "')"
EndIf

If !Empty(cProcesso)
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	cFiltro	+= " (RCH->RCH_PROCES == '" + cProcesso + "')" 
EndIf

If !Empty(cRoteiro)
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	cFiltro	+= " (RCH->RCH_ROTEIR == '" + cRoteiro + "'"
	cFiltro += ")"
EndIf

cFiltro := "@#" + cFiltro + "@#"

Return ( cFiltro )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fSetPerData ³ Autor ³ Leandro Drumond     ³ Data ³ 09/05/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta dialogo para selecao de periodo ou Data, no caso de  ³±±
±±³			 ³ data abrira outra tela para definir data inicial e final   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Manutencoes                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fSetPerData(nOpcRadio, cTitJan, cTitBox, cTitRad1, cTitRad2)

Local nOpcAux
Local oRadio
Local oDlg
Local oDlg2
Local oGroup
Local oFont
Local oDtIni
Local oDtFim
Local dDataIni := CtoD("//")
Local dDataFim := CtoD("//")
Local bSet15A
Local bSet24A
Local bSet15B
Local bSet24B
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Declaração de arrays para dimensionar tela		         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aGDCoord		:= {}

DEFAULT cTitBox  := STR0222 //"Visualizar por"
DEFAULT cTitRad1 := STR0165 //"Periodo"
DEFAULT cTitRad2 := STR0164 //"Dia Inicial/Final"

nOpcAux   := nOpcRadio
nOpcRadio := 0

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdvSize		:= MsAdvSize( ,.T.,30)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
aAdd( aObjCoords , { 000 , 060 , .T. , .F.  } )
aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7],0 TO aAdvSize[6]*0.8,aAdvSize[5] TITLE OemToAnsi(cTitJan) PIXEL

@ aObjSize[1][1],aObjSize[1][2] GROUP oGroup TO aObjSize[1][3],aObjSize[1][4] LABEL OemToAnsi(cTitBox) OF oDlg PIXEL
oGroup:oFont:=oFont

@ aObjSize[1][1]+10,aObjSize[1][2]+10 RADIO oRadio VAR nOpcAux ITEMS 	OemToAnsi(cTitRad1), OemToAnsi(cTitRad2);
          SIZE 115,010 OF oDlg PIXEL

bSet15A := {|| nOpcRadio := nOpcAux, oDlg:End()}
bSet24A := {|| nOpcRadio := 0,       oDlg:End()}
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15A, bSet24A, Nil, Nil) CENTERED

If ( nOpcRadio == 2 )
	nOpcRadio := 0    
     
	aObjCoords 			:= {}
	aInfoAdvSize		:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )

	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg2 FROM  aAdvSize[7],0 TO aAdvSize[6]*0.8,aAdvSize[5] TITLE OemToAnsi(cTitJan) PIXEL
	
	@ aObjSize[1][1],aObjSize[1][2] GROUP oGroup TO aObjSize[1][3],aObjSize[1][4] LABEL OemToAnsi(STR0064) OF oDlg2 PIXEL  //Data Inicial
	
	@ aObjSize[1][1]+10,aObjSize[1][2]+10 MSGET oDtIni Var dDataIni SIZE 050,10 OF oDlg2 PIXEL VALID !Empty( dDataIni )

	@ aObjSize[2][1],aObjSize[2][2] GROUP oGroup TO aObjSize[2][3],aObjSize[2][4] LABEL OemToAnsi(STR0065) OF oDlg2 PIXEL  //Data Final

	@ aObjSize[2][1]+10,aObjSize[2][2]+10 MSGET oDtFim Var dDataFim SIZE 050,10 OF oDlg2 PIXEL VALID ( !Empty( dDataFim ) .and. ( dDataIni <= dDataFim ) )
	
	bSet15B := {|| nOpcRadio := 2, oDlg2:End() }
	bSet24B := {|| nOpcRadio := 0, oDlg2:End() }
	
	ACTIVATE MSDIALOG oDlg2 ON INIT EnchoiceBar(oDlg2, bSet15B, bSet24B, Nil, Nil) CENTERED
	
	oPeriodo:dDataIni := dDataIni
	oPeriodo:dDataFim := dDataFim

EndIf

Return( nOpcRadio )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fDtaAdmis   ³ Autor ³ Leandro Drumond     ³ Data ³ 10/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Instancia data de admissao ou readmissao do funcionario    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fDtaAdmis()

Local dDataAdmis := CtoD('')

If cPaisLoc == "MEX"
	If !Empty(SRA->RA_FECREI)
		dDataAdmis := SRA->RA_FECREI
	Else
		dDataAdmis := SRA->RA_ADMISSA
	EndIf
Else
	dDataAdmis := SRA->RA_ADMISSA
EndIf

Return ( dDataAdmis )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fFilIdTabela³ Autor ³ Igor Franzoi	    ³ Data ³ 25/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Static Function fFilIdTabela( aTabCalend, nPosIni, aTransf )
Local aArea		:= GetArea()
Local aSX3Area	

Local cFilRCH	:= xFilial('RCH') 
Local nPos		:= 0
Local nCont 	:= 0
Local cFilProc	:=	''
Local cProcesso	:=	''
Local cPeriodo 	:=	''
Local cRoteiro 	:=	''
Local cNumPagto	:=	''
Local dPerIni	:=	''
Local dPerFim	:=	''

Local dData		:= aTabCalend[ 1,CALEND_POS_DATA_APO ] 
Local dDataAnt	:= Ctod('')

Local aElmTransf:= {}	

Local lTransf	:= .F.

Local cCC 		:= SRA->RA_CC	 	  
Local cCodFunc  := SRA->RA_CODFUNC   
Local cDepto	:= SRA->RA_DEPTO     
Local cPosto	:= SRA->RA_POSTO

If Type("oPeriodo") == "U"
	SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
EndIf

cFilProc	:= oPeriodo:cFilRCH
cProcesso	:= oPeriodo:cProcesso	//Processo
cPeriodo 	:= oPeriodo:cPeriodo  	//Periodo
cRoteiro 	:= oPeriodo:cRoteiro	//Roteiro
cNumPagto	:= oPeriodo:cNumPagto	//Numero de Pagamento
dPerIni		:= oPeriodo:dDataIni  	//Data Inicio do Periodo Atual
dPerFim		:= oPeriodo:dDataFim  	//Data Fim do Periodo Atual  

If cSX3ProcTit == Nil 
	aSX3Area	:= SX3->(GetArea() )
	SX3->( dbSetOrder( 02 ) )
	SX3->( dbSeek('RCH_PROCES') )
	cSX3ProcTit     := Alltrim(SX3->(X3TITULO()))
	RestArea(aSX3Area)
Endif
		
DEFAULT nPosIni := 1  


For nCont := nPosIni To Len(aTabCalend)  
	
	dData		:= aTabCalend[ nCont , CALEND_POS_DATA_APO ] 		  
	
	//-- Carrega transferencias referentes ao Processo 
	aElmTransf := fBuscaProc( aTransf, dData, /*cProcesso*/, /*cDescProc*/, /*uData*/, /*lNoRept*/ , /*lOrigem*/  )
        
	//-- Se não encontrou transferencia        
	//-- Busca  no disco as informacoes do processo atual se o funcionario nao apresentou transferencia na data
	IF Empty(aElmTransf)
	   cProcesso	:= oPeriodo:cProcesso 
	Else
	   cProcesso	:= aElmTransf[2]  	   
	Endif
	
	If ( ( nPos := aScan( oPeriodo:aPeriodos, { |x| ( x[1]== cFilRCH ) 	.and. ;
													 ( x[2] == cProcesso ) 	.and. ;
													 ( ( dData >= x[6] ) 		.and. ( dData <= x[7] ) );
											    } ;
				   	     ) ;
		   ) = 0 ;
		) 
		   
		
	
		fFileRCH( 	dData					,;
				  	cProcesso				,; //-- Processo na Data
				  	@nPos 					;
					)                                  
	
		//-- Se nao encontrou o processo  valido na data de apontamento lida avisa ao usuario
		If Empty(nPos)
			oCalendError:SendError('07',OemToAnsi(STR0064) +  " " +Dtoc(dData) + CRLF +;
									cSX3ProcTit + ": " + cProcesso, .T.)  //"Não foi possível gerar o calendário para o período de: "
			Loop
		EndIf
    Endif
    
	//-- Carrega informacoes do Processo
	cProcesso:= oPeriodo:aPeriodos[ nPos, 02 ]	//Processo
	cPeriodo := oPeriodo:aPeriodos[ nPos, 03 ]  //Periodo
	cRoteiro := oPeriodo:aPeriodos[ nPos, 04 ]  //Roteiro		
	cNumPagto:= oPeriodo:aPeriodos[ nPos, 05 ]  //Numero de Pagamento
     
	dPerIni  := oPeriodo:aPeriodos[ nPos, 06 ]  //Data Inicio do Periodo Atual
	dPerFim  := oPeriodo:aPeriodos[ nPos, 07 ]  //Data Fim do Periodo Atual

	If dData <> dDataAnt
		fBuscaDia( aTransf, dData, @cDepto, @cPosto, @cCC, @cCodFunc)
		dDataAnt:= dData
	Endif
	
	//-- Alimenta o calendario com as informacoes do processo na data de apontamento
	aTabCalend[ nCont, CALEND_POS_PERIODO  	] := cPeriodo	//Periodo
	aTabCalend[ nCont, CALEND_POS_ROTEIRO  	] := cRoteiro	//Roteiro
	aTabCalend[ nCont, CALEND_POS_PROCESSO 	] := cProcesso	//Processo
	aTabCalend[ nCont, CALEND_POS_NUM_PAGTO	] := cNumPagto	//Numero de Pagamento 
    

	aTabCalend[ nCont, CALEND_POS_DEPTO		] := If(	Empty(aTabCalend[ nCont, CALEND_POS_DEPTO		]),;
														cDepto		,;
														aTabCalend[ nCont, CALEND_POS_DEPTO				] ;
													)	//Depto
	aTabCalend[ nCont, CALEND_POS_CC		] := If(	Empty(aTabCalend[ nCont, CALEND_POS_CC			]),;
														cCC			,;
														aTabCalend[ nCont, CALEND_POS_CC				];
													)	//Centro de Custo
	aTabCalend[ nCont, CALEND_POS_CODFUNC	] := If(	Empty(aTabCalend[ nCont, CALEND_POS_CODFUNC		]),;
														cCodFunc	,;
														aTabCalend[ nCont, CALEND_POS_CODFUNC			];
													)	//Codigo da Funcao
	aTabCalend[ nCont, CALEND_POS_POSTO		] := If(	Empty(aTabCalend[ nCont, CALEND_POS_POSTO		]),;
														cPosto		,;
														aTabCalend[ nCont, CALEND_POS_POSTO				];
													)	//Posto

Next

Return (NIl)  

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fFileRCH	 	³Autor³  				  ³ Data ³08/05/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Carregar no array de periodos (no objeto oPeriodo), conforme³
|		   |Data e Processo												|
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fFileRCH( dData, cProcesso, nPos )

Local aArea		:= GetArea()


Local cAliasQry := ""

#IFDEF TOP
	Local cWhere	:= "" 
#ELSE	
	Local cAlias	:= "RCH"
#ENDIF
	
DEFAULT nPos	:= 0

#IFDEF TOP

	cAliasQry := GetNextAlias()
		
	cWhere += "%"
	cWhere += " RCH_PROCES = '"+cProcesso+"' AND "
	cWhere += " RCH_ROTEIR = 'PON' AND "
	cWhere += " RCH_DTINI <= '"+Dtos(dData)+"' AND "
	cWhere += " RCH_DTFIM >= '"+Dtos(dData)+"' AND "
	cWhere += "%"
	
	BeginSql Alias cAliasQry
		column RCH_DTINI as Date, RCH_DTFIM as Date, RCH_DTFECH as Date
	   	%NoParser%
	   	SELECT 
				RCH_FILIAL,
				RCH_PROCES,	
				RCH_PER,		
				RCH_ROTEIR,	
				RCH_NUMPAG,	
				RCH_DTINI,	
				RCH_DTFIM,	
				RCH_DTFECH,	
				RCH_ANO,		
				RCH_MES	 	
		FROM
			%Table:RCH% RCH
		WHERE
			%Exp:cWhere%
			RCH.%NotDel%
		ORDER BY 
			%Order:RCH%
	EndSql
	
	
	If !( (cAliasQry)->(Eof()) )
		oPeriodo:aADDPer(	{{	(cAliasQry)->RCH_FILIAL	,;		//01
								(cAliasQry)->RCH_PROCES	,;      //02
								(cAliasQry)->RCH_PER 	,;		//03
								(cAliasQry)->RCH_ROTEIR	,;		//04
								(cAliasQry)->RCH_NUMPAG	,;		//05
								(cAliasQry)->RCH_DTINI	,;		//06
								(cAliasQry)->RCH_DTFIM	,;		//07
								(cAliasQry)->RCH_DTFECH	,;		//08
								(cAliasQry)->RCH_ANO	,;		//09
								(cAliasQry)->RCH_MES	;		//10
							}},;
							@nPos;
						 )
	EndIf
	
	(cAliasQry)->(dbCloseArea())

#ELSE

	

	DbSelectArea( cAlias )
	(cAlias)->(RetOrder("RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_DTFECH+RCH_PER+RCH_NUMPAG"))
	(cAlias)->(DbSeek( xFilial("RCH")+cProcesso+"PON" ))

	While (cAlias)->( !Eof() .and. xFilial("RCH")+cProcesso+"PON" == RCH_FILIAL+RCH_PROCES+RCH_ROTEIR )

		If (cAlias)->(RCH_DTINI <= dData .and. RCH_DTFIM >= dData)

				oPeriodo:aADDPer(	{{	(cAliasQry)->(RCH_FILIAL)	,;		//01
										(cAliasQry)->(RCH_PROCES)	,;      //02
										(cAliasQry)->(RCH_PER)		,;		//03
										(cAliasQry)->(RCH_ROTEIR)	,;		//04
										(cAliasQry)->(RCH_NUMPAG)	,;		//05
										(cAliasQry)->(RCH_DTINI)	,;		//06
										(cAliasQry)->(RCH_DTFIM)	,;		//07
										(cAliasQry)->(RCH_DTFECH)	,;		//08
										(cAliasQry)->(RCH_ANO)		,;		//09
										(cAliasQry)->(RCH_MES)	 	;		//10
									}},;
									@nPos;
								 ) 
				EXIT
		EndIf
		
		(cAlias)->(dbSkip())
		
	EndDo

#ENDIF
	
RestArea(aArea)
	
Return (Nil)
	
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fLoadTransf	 	³Autor³Mauricio MR		  ³ Data ³26/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Carrega as transferencias do Funcionario 				    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fLoadTransf(aTransf)

Local nX		:= 0
Local aRet		:= {}
Local cFilMat	:= SRA->(RA_FILIAL + RA_MAT )
Local aAux		:= {}
          
//-- Variaveis para obter as transferencias do funcionario
Local lOrigem := .T.			//Executar a Pesquisa pela Tambem pela Origem
Local lNoRept := .F.			//Nao Armazena Itens Iguais

//-- Carrega todas as transferencias
fTransfAll( aAux , , lNoRept , lOrigem )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Filtrar as Transferencias do Funcionario				       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/	
If !Empty(aAux)
	For nX := 1 to Len(aAux)  
	    //-- Se Transf DE e Transf PARA for diferente ( FWCODEMP("SRA") + cFilAnt + cMat ) desconsidera
	    If ( ( FWCODEMP("SRA") + cFilMat ) <> (aAux[ nX , 04 ] + aAux[ nX , 10 ] + aAux[ nX , 11 ] )) .AND.;
	       ( ( FWCODEMP("SRA") + cFilMat ) <> (aAux[ nX , 01 ] + aAux[ nX , 08 ] + aAux[ nX , 09 ] ) ) 
	       Loop
        Endif
		
		//Posicao anterior a Transferencia 
		//{ dDataTrf-1, cProcesso, cDepto, cPosto, cCC, cEmpresa, cFilial, cMat, nRecno  } )			
		aAdd( aRet, { aAux[ nX, 07 ]-1, aAux[ nX , 14 ], aAux[ nX , 16 ], aAux[ nX , 18 ], aAux[ nX , 03 ], aAux[ nX , 02 ], aAux[ nX , 08 ], aAux[ nX , 09 ], aAux[ nX , 13 ]  } )			

		//Posicao na data da Transferencia 	
		//{ dDataTrf, cProcesso, cDepto, cPosto, cCC, cEmpresa, cFilial, cMat, nRecno  } )					
		aAdd( aRet, { aAux[ nX, 07 ], aAux[ nX , 15 ], aAux[ nX , 17 ], aAux[ nX , 19 ], aAux[ nX , 06 ], aAux[ nX , 04 ], aAux[ nX , 10 ], aAux[ nX , 11 ], aAux[ nX , 13 ]  } )						
	Next  
Endif                  
           
//-- Transfere as transferencias filtradas para o parametro de entrada
aTransf := aClone(aRet)

Return (Nil) 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fBuscaProc	 	³Autor³Igor Franzoi		  ³ Data ³26/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Localiza o Processo do Funcionario se ocorreu Transferencia ³
|		   |na data														|
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fBuscaProc( aTransf, dData)

Local nX		:= 0
Local aRet		:= {}
For nX := 1 to Len(aTransf)  

		If aTransf[ nX, 01 ] <= dData
			//{ dData, cProcesso, cDepto, cPosto, cCC, cEmpresa, cFilial, cMat, nRecno  } 			
			aRet :=  { dData, aTransf[ nX , 02 ], aTransf[ nX , 03 ], aTransf[ nX , 04 ], aTransf[ nX , 05 ], aTransf[ nX , 06 ], aTransf[ nX , 07 ], aTransf[ nX , 08 ], aTransf[ nX , 09 ]  } 			
		Endif	
Next  

Return (aRet) 



/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fBuscaDia	 	³Autor³Mauricio MR		  ³ Data ³28/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Localiza o Depto, Posto e Centro de Custo numa Data			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fBuscaDia( aTransf, dData, cDepto, cPosto, cCC, cCodFunc)

Local nX	:= 0
Local lCpo	:= .F.


For nX := 1 to Len(aTransf)  
    
	If ( aTransf[ nX, 01 ] >= dData ) 
		cDepto		:= aTransf[ nX , 03 ]	// Dept
		cPosto		:= aTransf[ nX , 04 ]	// Posto
		cCC			:= aTransf[ nX , 05 ]	// CC
        Exit
	EndIf   
Next  

fBuscaFunc(dData, @cCodFunc, , , lCpo)
Return ( NIL )

	
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fVerPGenerico 	³Autor³Mauricio MR		  ³ Data ³28/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Localiza informacoes do Periodo conforme o Processo			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fVerPGenerico(cProcesso)	 								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/           
Static Function fVerPGenerico(cProcesso)
Local aRCHArea 	
Local aArea			:= GetArea()
Local lGenerico		:= .F.
Local lUsaPGenerico	:= .F.
Local laProcVazio	:= ( __aProcesso	== NIL )
Local lRet			:= .F.
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Para o Modulo SIGAPON todos os funcionarios devem estar num  ³
³ Processo com Periodo										   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/		                      
If  ( Alltrim( Upper( cModulo ) ) <> "PON" )
	//Verifica se Processo jah foi verificado (se igual ao ultimo)
	If ( __cProcesso <> cProcesso )
	   __cProcesso := cProcesso              
	   
	   //-- Se nao for a primeira vez
	   IF !laProcVazio
	   		If ( __nPosProcesso:= Ascan( __aProcesso, { |x| x[1] == cProcesso } )  > 0 )
	   			lRet	:= __aProcesso[__nPosProcesso, 2]
	   		Endif	
	   Endif	
	
	   //-- Se o processo nao foi verificado, procura em disco
	   If  ( laProcVazio .or.  Empty( __nPosProcesso ) )
	    	aRCHArea 	:= RCH->(GetArea())
		    __aProcesso	:= {} 
		   
		    //-- Procura as informacoes do processo no disco
		    RCH->(DbSetOrder( RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG" )))        
	        lGenerico		:= !( RCH->( Dbseek( xFilial("RCH") + cProcesso  + "PON" ) ) )
	        
	       //-- Adiciona o Processo verificado
	       AADD( __aProcesso, {cProcesso, lGenerico } ) 
	       __nPosProcesso:=	Len( __aProcesso )
	       
	       RCH->(RestArea(aRCHArea))
	   Endif                              
	
	Endif
	lRet	:= __aProcesso[__nPosProcesso, 2]
Endif   

RestArea(aArea)
Return (lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fRecCalAfa  ³ Autor ³ Leandro Drumond     ³ Data ³ 27/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Recria o Calendario Fisico levando em consideracao o ultimo³±±
±±³			 | afastamento incluido.									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA240                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fRecCalAfa  ³ Autor ³ Leandro Drumond     ³ Data ³ 27/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Recria o Calendario Fisico levando em consideracao o ultimo³±±
±±³			 | afastamento incluido.									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA240                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fRecCalAfa(oGrid,aSR8ID,nOpcx)
/*
aSR8ID[x,1] := Referencia o numero da linha no ASR8Cols
aSR8ID[x,2] := NUMID
aSR8ID[x,3] := Indica se campo foi deletado
*/
Local cMat		  := SRA->RA_MAT
Local cFil		  := SRA->RA_FILIAL
Local cNumId	  := ''
Local dDtaIni     := CtoD('')
Local dDtaFim     := CtoD('')
Local dIniCal     := CtoD('')
Local dFimCal     := CtoD('')
Local dMinIniCal  := CtoD('')
Local dMaxFimCal  := CtoD('')
Local nLenID	  := Len(aSR8ID)
Local nX          := 0
Local oPerFch	  := RHPERIODO():New()

If lUseCalFisico

	//Monta ultimo periodo fechado do funcionario
	oPerFch:cProcesso 	:= SRA->(RA_PRCFCH)
	oPerFch:cPeriodo	:= SRA->(RA_PERFCH)
	oPerFch:cRoteiro	:= SRA->(RA_ROTFCH)
	oPerFch:cNumPagto	:= SRA->(RA_NUPFCH)
	
	oPerFch:GetPer("!EMPTY(RCH_DTFECH)")
	
	//Obtem a data inicial e final do calendario
	fDatMaxCal( cFil, cMat, @dFimCal, @dIniCal )
	
	dMinIniCal := If( dIniCal > oPerFch:dDataFim , dIniCal , (oPerFch:dDataFim + 1) )
	
	dMaxFimCal := dFimCal
	
	//Apaga todos os afastamento do periodo se datas forem maiores que data final do ultimo periodo fechado
	If dMaxFimCal > oPerFch:dDataFim
		fUpdCal( cFil							 ,; //Filial do funcionario
				 cMat				 			 ,; //Matricula
				 ""		 			   			 ,; //Processo para o qual o funcionario sera transf.
				 ""		 			   			 ,; //Centro de Custo
				 ""		 			   			 ,; //Roteiro
				 ""		 			   			 ,; //Periodo
				 ""		 			   			 ,; //Num. de Pagamento
				 ""		 			   			 ,; //Departamento
				 ""		 			   			 ,; //Posto
				 ""		 			   			 ,; //Cod. da Funcao
				 Dtos(dMinIniCal)				 ,; //Data inicio do calendario ja existente
				 Dtos(dMaxFimCal)				 ,; //Data fim do calendario existente
				 .T.	 			   			 ,; //Efetua Update no RF6 com os campos/dados passados
				 .F.	 		 	   			 ,; //Efetua Update no RF7 com os campos/dados passados
				 {"","S"}				 		 ,; //Dados para update, na mesma ordem dos campos RF6
				 {}		 			   			 ,; //Dados para update, na mesma ordem dos campos RF7
				 {"R8ID","TIPOD"}	   	 		 ,; //Campos utilizados para Update RF6
				 {} 	  	 					  ) //Campos utilizados para Update RF7
	EndIf
	
	//Se nao for exclusao reconstroi os afastamentos do calendario
	If nOpcx != 5
		For nX := 1 to nLenID
			oGrid:GoLine(aSR8ID[nX,1])
			//Se data final estiver vazia, utiliza ultima data do calendario
			If Empty(oGrid:GetValue("R8_DATAFIM"))
				dDtaFim := dFimCal
			Else
				dDtaFim := If(oGrid:GetValue("R8_DATAFIM") <= dFimCal , oGrid:GetValue("R8_DATAFIM") , dFimCal)
			EndIf
	        //Data Inicial devera ser maior que data final do ultimo periodo fechado
			dDtaIni := If(oGrid:GetValue("R8_DATAINI") > oPerFch:dDataFim , oGrid:GetValue("R8_DATAINI") , (oPerFch:dDataFim + 1))
	
	        //Se deletado
			If aSR8ID[nX,3]
				cNumId  := ''
			Else
				cNumId := aSR8ID[nX,2]
			EndIf
	        
	        //Somente executa update se datas forem maiores que data final do ultimo periodo fechado
			If dDtaFim > oPerFch:dDataFim
				fUpdCal( cFil							 ,; //Filial do funcionario
						 cMat				 			 ,; //Matricula
						 ""		 			   			 ,; //Processo para o qual o funcionario sera transf.
						 ""		 			   			 ,; //Centro de Custo
						 ""		 			   			 ,; //Roteiro
						 ""		 			   			 ,; //Periodo
						 ""		 			   			 ,; //Num. de Pagamento
						 ""		 			   			 ,; //Departamento
						 ""		 			   			 ,; //Posto
						 ""		 			   			 ,; //Cod. da Funcao
						 Dtos(dDtaIni)					 ,; //Data inicio do calendario ja existente
						 Dtos(dDtaFim)					 ,; //Data fim do calendario existente
						 .T.	 			   			 ,; //Efetua Update no RF6 com os campos/dados passados
						 .F.	 		 	   			 ,; //Efetua Update no RF7 com os campos/dados passados
						 {cNumId,"N"}				 	 ,; //Dados para update, na mesma ordem dos campos RF6
						 {}		 			   			 ,; //Dados para update, na mesma ordem dos campos RF7
						 {"R8ID","TIPOD"}	   	 		 ,; //Campos utilizados para Update RF6
						 {} 	  	 					  ) //Campos utilizados para Update RF7
			EndIf
			
		Next nX
	
	EndIf
	
EndIf

Return(Nil)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fFindSeq 		³Autor³Igor Franzoi	  	  ³ Data ³07/10/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Procura a Sequencia inicial correta para o calendario		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fFindSeq()				 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fFindSeq( 	cSeq		,;
							aTabPadrao	,; 
							cFilSPJ		,; 
							cNewTno		,;
							lExecQryTop	,; 
							aTurnos		,; 
							dDataAdm	,; 
							dDataIni	,; 
							dDataFim	,;
							cMat	)


Local nCont		:= 0
Local nPosTno	:= 0
Local nPosTab	:= 0
Local nLstSeq	:= 0

Local dIniPer	:= Ctod("//")	//Variavel auxiliar para calculo da sequencia a partir da Data de Admissao
Local dFimPer	:= Ctod("//")	//Variavel auxiliar para calculo da sequencia, primeiro dia do Periodo Solicitado

Local aSeq		:= {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Procura a Sequencia do Turno do Primeiro dia do Periodo	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If !Empty( aTurnos )
	nPosTno := aScan( aTurnos, { |x| x[2] >= dDataIni .and. x[2] <= dDataIni } )
EndIf

If ( nPosTno > 0 )
		
    If !( aTurnos[ nPosTno, 06 ] )
    
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega tabela de horario padrao                     		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		fTabPadrao( @aTabPadrao , @cFilSPJ , cNewTno , lExecQryTop )
			
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega todas as sequencias da tabela no array aSeq		  |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If ( ( nPosTab := aScan( aTabPadrao , { |x| x[1] == cFilSPJ .and. x[2] == cNewTno } ) ) > 0 )
			For nCont := 1 To Len(aTabPadrao[ nPosTab , 03 ])
				If ( aScan( aSeq , { |x| x == aTabPadrao[ nPosTab , 03 , nCont , 19 ] } ) == 0 )
					aAdd( aSeq , aTabPadrao[ nPosTab , 03 , nCont , 19 ] )
					nLstSeq	:= Val(aTabPadrao[ nPosTab , 03 , nCont , 19 ])
				EndIf
			Next
		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega a data da Primeira Segunda-Feira, da Data Admissao  |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    	dIniPer := fFindDay( dDataAdm )
    	dFimPer := fFindDay( dDataIni )
    	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Localiza a Sequencia correta para a Data Inicio do Periodo  |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If ( nLstSeq > 0 )
	    	cSeq := fContSeq( dIniPer, dFimPer, aSeq, nLstSeq )
    	EndIf
		
	EndIf

Else

	If !( ValType(cMat) == "U" )
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega tabela de horario padrao                     		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		fTabPadrao( @aTabPadrao , @cFilSPJ , cNewTno , lExecQryTop )
			
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega todas as sequencias da tabela no array aSeq		  |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If ( ( nPosTab := aScan( aTabPadrao , { |x| x[1] == cFilSPJ .and. x[2] == cNewTno } ) ) > 0 )
			For nCont := 1 To Len(aTabPadrao[ nPosTab , 03 ])
				If ( aScan( aSeq , { |x| x == aTabPadrao[ nPosTab , 03 , nCont , 19 ] } ) == 0 )
					aAdd( aSeq , aTabPadrao[ nPosTab , 03 , nCont , 19 ] )
					nLstSeq	:= Val(aTabPadrao[ nPosTab , 03 , nCont , 19 ])
				EndIf
			Next
		EndIf	
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega a data da Primeira Segunda-Feira, da Data Admissao  |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		dIniPer := fFindDay( aTurnos[ Len(aTurnos), 02 ] )
		dFimPer := fFindDay( dDataIni )	
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Localiza a Sequencia correta para a Data Inicio do Periodo  |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If ( nLstSeq > 0 )
	    	cSeq := fContSeq( dIniPer, dFimPer, aSeq, nLstSeq, Val(cSeq) )
	   	EndIf	
   	
   	EndIf

EndIf
										
Return ( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fFindDay 		³Autor³Igor Franzoi	  	  ³ Data ³07/10/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Localiza primeira Segunda-Feira da Data Solicitada			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fFindDay				 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fFindDay( dData )

While (Dow(dData) != 2)
	dData--
EndDo

Return ( dData )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fFindDay 		³Autor³Igor Franzoi	  	  ³ Data ³07/10/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Localiza primeira Segunda-Feira da Data Solicitada			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fFindDay				 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fContSeq( dIniPer, dFimPer, aSeq, nLstSeq, nSeqIni )

Local cSeq		:= ""

Local nWeek		:= 1

DEFAULT nSeqIni := 0

//Se houver mais de uma Sequencia cadastrada, conta as sequencias do periodo senao retorna a primeira sequencia
If ( nLstSeq > 1 )

	If ( nSeqIni > 0 )
		nWeek := nSeqIni
	EndIf

	While ( dIniPer < dFimPer )
		dIniPer := (dIniPer + 7)		
		If ( nWeek < nLstSeq )
			nWeek++
		Else
			nWeek := 1
		EndIf
	EndDo
	
	nLstSeq := nWeek
	
EndIf

cSeq := aSeq[ nLstSeq ]

Return ( cSeq )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonStruct() 	³Autor³Mauricio MR		  ³ Data ³11/07/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a integridade das estruturas das bases SIGAPON		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PonStruct()				 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/           
Function PonStruct(lWorkFlow, aLogFile, bCond )   

Local cAviso	:=  STR0159 // "Atençäo!"
Local cMsg		:=  STR0225 // "Para Acessar esta rotina, execute o programa RHUPDR12."

Local lRet		:= .T.

DEFAULT		lWorkFlow	:= .F.

//-- Executa a condicao de verificacao de integridade da base
IF !Eval(bCond)
   lRet := .F.
   
   //-- Exibe mensagem na tela se nao WokFlow
   If !lWorkFlow
      	//"Atençäo!" ## "Para Acessar esta rotina, execute o programa RHUPDR12."
		 Aviso( OEMTOANSI(cAviso),oemtoansi(cMsg),{"OK"}) 
   Endif
   
   //-- Adiciona ao Log se WorkFlow
   IF aLogFile <> Nil
      AADD( aLogFile, cMsg )
   Endif
  
Endif   

Return (lRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³VerSP5Struct() 	³Autor³Mauricio MR		  ³ Data ³11/07/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a estrutura da base SP5							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³VerSP5Struct()				 								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/           
Function  VerSP5Struct()

Local aArea		:= GetArea()
Local aSX3Area  := SX3->(GetArea())
Local lRet		:= .F.

SX3->(DbSetOrder(2))

If SX3->( dbSeek("P5_DATAAPO"))
	lRet := ( Upper(AllTrim(SX3->X3_TIPO)) == 'D' )
EndIf

If lRet
	If SX3->( dbSeek("P5_POSTO"))
		lRet := ( SX3->X3_TAMANHO == 9 )
	EndIf
EndIf

RestArea(aSX3Area)
RestArea(aArea)

Return (lRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³VerSPLStruct() 	³Autor³Leandro Drumond    ³ Data ³18/08/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a estrutura da base SPL							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³VerSPLStruct()				 								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
Function  VerSPLStruct()

Local aArea		:= GetArea()
Local aSX3Area  := SX3->(GetArea())
Local lRet		:= .T.
Local cUsado    := ""

SX3->(DbSetOrder(2))

If SX3->( dbSeek("PL_D4"))
	cUsado := SX3->X3_USADO

	If SX3->( dbSeek("PL_D5"))
		If !( SX3->X3_USADO == cUsado ) .or. !( SX3->X3_BROWSE == "S" )
	      	//"Atençäo!" ## "Para Acessar esta rotina, execute o programa RHUPDR12."
			 Aviso( OEMTOANSI(STR0159),oemtoansi(STR0225),{"OK"}) 
			lRet := .F.			
		EndIf
	EndIf

EndIf

RestArea(aSX3Area)
RestArea(aArea)

Return (lRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³VerRFAStruct() 	³Autor³Mauricio MR		  ³ Data ³11/07/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a estrutura da base RFA							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³VerRFAStruct()				 								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/           
Function  VerRFAStruct()

Local lRet		:= .F.

lRet	:= 	!Empty(RetOrder('RFA', 'RFA_FILIAL+RFA_CRACHA+DTOS(RFA_DATA)+STR(RFA_HORA,5,2)',.T.))  .and. ;
			!Empty(RetOrder('RFA', 'RFA_ORIG+RFA_CRACHA+DTOS(RFA_DATA)+STR(RFA_HORA,5,2)',.T.)) 


Return (lRet)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ AjustSX3		³Autor³  Luiz Almeida     ³ Data ³09/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONA230                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³aRotina														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function VerSPIStruct()

Local aArea		:= GetArea()
Local aSX3Area  := SX3->(GetArea())
Local lRet		:= .F.

SX3->(DbSetOrder(2))

If SX3->( dbSeek("PI_NUMPAG")) .and. SX3->( dbSeek("PI_ROTEIR") )
	lRet := .T.
EndIf

If lRet
	If SX3->( dbSeek("PI_PROCES") )
		If ( AllTrim(SX3->X3_VALID) != 'PIProcesVld()' )
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aSX3Area)
RestArea(aArea)

Return (lRet)

/*                                	
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ PONLoadExec	³Autor³  Igor Franzoi     ³ Data ³29/06/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Funcao executada a cada rotina (menu) chamado pelo PON		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PONLoadExec													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function PONLoadExec()

If FindFunction("SPFLoadExec()")
	SPFLoadExec()
EndIf

Return (Nil)
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Port1510     ³Autor ³Leandro Drumond      ³ Data ³02/10/09  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se Portaria 1510/2009 esta em vigor.               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Port1510()
Local lRet := .F.

If DPORT1510 == "25/11/09" .and. cPaisLoc == "BRA"
	lRet := .T.
EndIf

Return lRet
