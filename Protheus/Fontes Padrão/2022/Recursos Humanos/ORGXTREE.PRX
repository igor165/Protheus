#INCLUDE "PROTHEUS.CH"
#INCLUDE "DBTREE.CH"
#INCLUDE "APDXTREE.CH"
#INCLUDE "APDTREEN.CH"

Static aMainTree
Static aLstMainTree
Static aTreeNodes
Static aCutTreeNodes
Static aCopyTreeNodes
Static nPosMainGrp
Static nLstMainGrp
Static nSeedTree
Static cLastSeq
Static lTreeUseSeq       

/*/
зддддддддддбддддддддддбдддддбдддддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁORGXTREE  ЁAutorЁMarinaldo de Jesus       Ё Data Ё16/07/2003Ё
цддддддддддеддддддддддадддддадддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁBiblioteca de Funcoes para Uso de Tree Estruturado          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢	
ЁUso       ЁGenerico                                                    Ё
цддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё            ATUALIZACOES SOFRIDAS DESDE A CONSTRU─AO INICIAL           Ё
цддддддддддддбддддддддддбддддддбдддддддддддддддддддддддддддддддддддддддд╢
ЁProgramador ЁData      ЁBOPS  ЁMotivo da Alteracao                     Ё
цддддддддддддеддддддддддеддддддедддддддддддддддддддддддддддддддддддддддд╢
ЁCecilia Car.Ё07/08/2014ЁTQEQKPЁIncluido o fonte da 11 para a 12 e efe- Ё
Ё            Ё          Ё      Ёtuada a limpeza.                        Ё
юддддддддддддаддддддддддаддддддадддддддддддддддддддддддддддддддддддддддды/*/

/*/
зддддддддддбддддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁInORGXTREEExecЁAutor ЁMarinaldo de Jesus   Ё Data Ё24/08/2004Ё
цддддддддддеддддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁExecutar Funcoes Dentro de ORGXTREE                          Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁInORGXTREEExec( cExecIn , aFormParam )						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁuRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function InOrgXTreeExec( cExecIn , aFormParam )
	Local uRet
	
	DEFAULT cExecIn		:= ""
	DEFAULT aFormParam	:= {}
	
	IF !Empty( cExecIn )
		cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
		uRet	:= __ExecMacro( cExecIn )
	EndIF	
Return( uRet )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgBldTreeЁ Autor ЁMarinaldo de Jesus     Ё Data Ё18/06/2002Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMontar Tree Estruturado                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerica 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OrgBldTree( 	aDbTreeInfo		,; //01
						cTreeTitle		,; //02
						bTreeOk			,; //03
						bTreeChange		,; //04
						bTreeInit		,; //05
						lGrava			,; //06
						aObjSize		,; //07
						nWidthTree		,; //08
						oDlg		 	,; //09
						lMenuPopUp		,; //10
						aMenuDisable	,; //11
						aMenuPopUp		,; //12
						bTreeRClicked	,; //13
						aFormalAdvSize	,; //14
						oTreeRef		,;  //15
						aNodesRef		;
				 )  
	Local aSvKeys				:= GetKeys()
	Local aAreaAnt				:= GetArea()
	Local aAdvSize				:= IF( !Empty( aFormalAdvSize ) , aFormalAdvSize , MsAdvSize( .T. ) )
	Local aObjects				:= {}
	Local bMenuVldExc			:= { || .T. }
	Local bMenuVldCut			:= { || .T. }
	Local bTreeGetDet			:= { || .T. }
	Local bRes1Field			:= { || "PMSTASK1" }
	Local bRes2Field			:= { || "PMSTASK2" }
	Local bDialogInit			:= { || .T. }
	Local lTudoOk				:= .F.
	Local lNewDialog			:= !( ValType( oDlg ) == "O" )
	Local oTreeDlg				:= oDlg
	Local aInfo
	Local adbTree
	Local bFilField
	Local bCodField
	Local bTreeField
	Local bItemField
	Local bDescField
	Local bAddNewItem
	
	Local cAliasFather
	Local cFilFather
	Local cKeyFather
	Local cFldDescFather
	Local cFldRes1Father
	Local cFldRes2Father
	Local cdbTreeAlias
	Local cFilField
	Local cCodField
	Local cItemField
	Local cTreeField
	Local cDescField
	Local cSetFilConPad
	Local cRes1Field
	Local cRes2Field
	Local cLastItemNum     
	Local cdbTreeF3
	
	Local nTreeOrder
	Local nItemOrder
	Local nRegFather
	
	Local oMenu
	Private oTree
	
	
	OrgTreeCacheClear()
	
	aCutTreeNodes	:= {}
	aCopyTreeNodes  := {}
	
	DEFAULT aObjects			:= { { 100, 100, .T., .T. } }
	DEFAULT oDlg				:= NIL
	DEFAULT lMenuPopUp			:= .T.
	DEFAULT aMenuDisable		:= {}
	DEFAULT aMenuPopUp			:= {;
										{;
											OemToAnsi("Remover PermissЦo"),;
											{ || CursorWait(), OrgTreeRevoke(@oTree), CursorArrow() },;
											.T.,;
											NIL,;
											PERMISSION[REVOKE];
										},;	
										{;
											OemToAnsi("Conceder PermissЦo..."),;
											NIL,;
											.T.,;
											{;
												{;
													OemToAnsi("Somente neste departamento"),;
													{ || CursorWait(), OrgTreeGrant(@oTree, .F.), CursorArrow() },;
													.T.,;
													NIL,;
													PERMISSION[GRANT];
												},;	
												{;
													OemToAnsi("A partir deste ponto da arquitetura"),;
													{ || CursorWait(), OrgTreeGrant(@oTree, .T.), CursorArrow() },;
													.T.,;
													NIL,;
													PERMISSION[MASTER_GRANT];
												};												
											},;	
											PERMISSION[GRANT];
										},;	
										{;
											OemToAnsi("Negar PermissЦo"),;
											NIL,;
											.T.,;
											{;
												{;
													OemToAnsi("Somente neste departamento"),;
													{ || CursorWait(), OrgTreeDeny(@oTree, .F.), CursorArrow() },;
													.T.,;
													NIL,;
													PERMISSION[DENY];
												},;	
												{;
													OemToAnsi("A partir deste ponto da arquitetura"),;
													{ || CursorWait(), OrgTreeDeny(@oTree, .T.), CursorArrow() },;
													.T.,;
													NIL,;
													PERMISSION[MASTER_DENY];
												};
											},;
											PERMISSION[DENY];
										};					
									}
			
								
	DEFAULT bTreeRClicked	:= { |o,x,y| OrgTreeMenu(o ,oMenu, x, y, aMenuPopUp) } // PosiГЦo x,y em relaГЦo a Dialog
	DEFAULT lGrava			:= .T.
	
	cAliasFather			:= aDbTreeInfo[ 01 , 01 ]	//01 , 01 -> Alias Mestre do Tree
	nRegFather				:= aDbTreeInfo[ 01 , 02 ]	//01 , 02 -> Recno para o Posicionamento do Tree
	cFilFather				:= aDbTreeInfo[ 01 , 03 ]	//01 , 03 -> Filial para a Montagem do Tree
	cKeyFather				:= aDbTreeInfo[ 01 , 04 ]	//01 , 04 -> Chave para a Montagem do Tree
	cFldDescFather			:= aDbTreeInfo[ 01 , 05 ]	//01 , 05 -> Descricao do Tree

	IF ( Len( aDbTreeInfo[ 01 ] ) >= 06 )
		cFldRes1Father		:= aDbTreeInfo[ 01 , 06 ]	//01 , 06 -> Campo que Contem o Resource1
	EndIF           
	
	IF ( Len( aDbTreeInfo[ 01 ] ) >= 07 )
		cFldRes2Father		:= aDbTreeInfo[ 01 , 07 ]	//01 , 07 -> Campo que Contem o Resource2
	EndIF
	
	cdbTreeAlias			:= aDbTreeInfo[ 02 , 01 ]	//02 , 01 -> Alias Filho do Tree
	cItemField				:= aDbTreeInfo[ 02 , 02 ]	//02 , 02 -> Item
	nItemOrder				:= aDbTreeInfo[ 02 , 03 ]	//02 , 03 -> Ordem do Item
	cTreeField				:= aDbTreeInfo[ 02 , 04 ]	//02 , 04 -> Tree (Grupo Superior)
	nTreeOrder				:= aDbTreeInfo[ 02 , 05 ]	//02 , 05 -> Ordem do Tree
	cDescField				:= aDbTreeInfo[ 02 , 06 ]	//02 , 06 -> Descricao do Item   
	
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 07 )
		IF ( ValType( aDbTreeInfo[ 02 , 07 ]  ) == "B" )
			bMenuVldExc		:= aDbTreeInfo[ 02 , 07 ]	//02 , 07 -> Bloco para o DelOk
		EndIF
	EndIF          
	
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 08 )
		cSetFilConPad		:= aDbTreeInfo[ 02 , 08 ]	//02 , 08 -> Funcao Para Setar o Filtro
	EndIF            
	
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 09 )
		IF ( ValType( aDbTreeInfo[ 02 , 09 ]  ) == "B" )
			bMenuVldCut		:= aDbTreeInfo[ 02 , 09 ]	//02 , 09 -> Bloco para Validar o Cut
		EndIF
	EndIF          
	
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 10 )
		IF ( ValType( aDbTreeInfo[ 02 , 10 ]  ) == "B" )
			bTreeGetDet		:= aDbTreeInfo[ 02 , 10 ]	//02 , 10 -> Bloco para Get das Informacoes
		EndIF
	EndIF          
	
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 11 )
		cRes1Field		:= aDbTreeInfo[ 02 , 11 ]		//02 , 11 -> Campo para Get do Resource1
	EndIF		       
	
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 12 )
		cRes2Field		:= aDbTreeInfo[ 02 , 12 ]		//02 , 12 -> Campo para Get do Resource2
	EndIF  
			
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 13 )
		cFilField := aDbTreeInfo[ 02 , 13 ]				//02 , 13 -> Campo de Filial
	EndIF   
	
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 14 )
		cCodField := aDbTreeInfo[ 02 , 14 ]				//02 , 14 -> Campo de Codigo
	EndIF   
	
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 15 )
		bAddNewItem := aDbTreeInfo[ 02 , 15 ]			//02 , 15 -> Bloco para Adicao de Novo Item
	EndIF	
	
	DEFAULT bAddNewItem := { || MsgInfo( OemToAnsi( STR0042 ) /*"OpГЦo nЦo disponМvel"*/ , OemToAnsi( STR0007 )/*"AtenГДo!"*/ ) }
	
	IF ( Len( aDbTreeInfo[ 02 ] ) >= 16 )
		cdbTreeF3 := aDbTreeInfo[ 02 , 16 ]				//02 , 16 -> Alias para consulta Padrao
	EndIF	
	
	IF ( cFilField <> NIL )
		bFilField	:= FieldWBlock( cFilField	, Select( cdbTreeAlias ) )
	EndIF	
	
	IF ( cCodField <> NIL )
		bCodField	:= FieldWBlock( cCodField	, Select( cdbTreeAlias ) )
	EndIF	
	
	bItemField	:= FieldWBlock( cItemField	, Select( cdbTreeAlias ) )
	bTreeField	:= FieldWBlock( cTreeField	, Select( cdbTreeAlias ) )
	bDescField	:= FieldWBlock( cDescField	, Select( cdbTreeAlias ) )

	IF ( cRes1Field <> NIL )
		If ValType(cRes1Field) == "B"
			bRes1Field	:= cRes1Field
		Else
			bRes1Field	:= FieldWBlock( cRes1Field , Select( cdbTreeAlias ) )
		EndIf
	EndIF
	
	IF ( cRes2Field <> NIL )
		If ValType(cRes2Field) == "B"
			bRes2Field	:= cRes2Field
		Else	
			bRes2Field := FieldWBlock( cRes2Field , Select( cdbTreeAlias ) )
		EndIF			
	EndIF	
	
	aObjects			:= { { 100 , 100 , .T. , .T. } }
	aInfo				:= { aAdvSize[1], aAdvSize[2], aAdvSize[3], aAdvSize[4], 3, 3 } 
	DEFAULT aObjSize	:= MsObjSize( aInfo , aObjects , NIL , .T. )
	DEFAULT nWidthTree	:= 98
	
	If aNodesRef != NIL
		adbTree := aTreeNodes:= aClone(aNodesRef)
		aLstMainTree:= {{cAliasFather, cFilFather, cKeyFather, AClone(aNodesRef)}}
		nLstMainGrp:=1
	Else
		CursorWait()
		
		adbTree := OrgGetNodes(	cAliasFather				,;
								cFilFather					,;
								@cKeyFather					,;
								cFldDescFather				,;
								nRegFather					,;
								cFldRes1Father				,;
								cFldRes2Father				,;
								cdbTreeAlias		 		,;
								bItemField					,;
								bDescField					,;
								nTreeOrder					,;
								bTreeField					,;
								nItemOrder	 				,;
								bTreeGetDet		 			,;
								bRes1Field					,;
								bRes2Field					,;
								@cLastItemNum				 ;
				 			)
		CursorArrow()
	EndIf
		
	IF Empty( cLastItemNum )
		cLastItemNum := Replicate( "0" , GetSx3Cache( cItemField , "X3_TAMANHO" ) )
	EndIF
	
	IF ( lNewDialog )
		DEFINE MSDIALOG oTreeDlg FROM aAdvSize[7],00 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi( cTreeTitle ) OF GetWndDefault() PIXEL
	EndIF
	                   

	oTree := OrgDbTree( adbTree , oTreeDlg , bTreeInit , bTreeRClicked , bTreeChange , aObjSize , nWidthTree, 	oTreeRef)
	
	
	IF ( lMenuPopUp )
		oMenu := OrgBldMnuTree( aMenuPopUp , aMenuDisable )
	EndIF
	
	IF ( lNewDialog )
		bDialogInit := { || OrgTreeBar( oTreeDlg , @lTudoOk , NIL,  NIL , NIL , NIL , bTreeOk ) }
		IF ( ValType( oTreeDlg ) == "O" )
			oTreeDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.
			ACTIVATE MSDIALOG oTreeDlg ON INIT Eval( bDialogInit ) CENTERED
		EndIF
	EndIF

	IF ( lGrava )	
		IF ( lTudoOk )
			cKeyFather := aDbTreeInfo[ 01 , 04 ]
			MsAguarde(;
							{ || lGrava := OrgTreeGrv(;
															aTreeNodes,;
															aLstMainTree[ nLstMainGrp , 4 ],;
															cdbTreeAlias,;
															bFilField,;
															bCodField,;
															bItemField,;
															bTreeField,;
															bDescField,;
															cFilFather,;
															cKeyFather,;
															nItemOrder;
													  );
							 },;
							 NIL,;
							 OemToAnsi( STR0006 );	//'Gravando Estrutura...'
					 )
			IF ( lGrava )
				aMainTree[ nLstMainGrp		, 4 ]	:= aClone( aTreeNodes )
				aLstMainTree[ nLstMainGrp	, 4 ]	:= aClone( aTreeNodes )
			EndIF
		Else
			IF !( ArrayCompare( aTreeNodes , aLstMainTree[ nLstMainGrp , 4 ] ) )
				aMainTree[ nLstMainGrp , 4 ] := aClone( aLstMainTree[ nLstMainGrp , 4 ] )
			EndIF
		EndIF			
	EndIF
	
	RestKeys( aSvKeys , .T. )
	RestArea( aAreaAnt )	
Return oTree

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeCacheClearЁAutorЁMarinaldo de JesusЁ Data Ё17/08/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁBarrasa do Tree ( Equivalente a EnchoiceBar )               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OrgTreeCacheClear()
	aMainTree		:= NIL
	aLstMainTree	:= NIL
	aTreeNodes		:= NIL
	aCutTreeNodes	:= NIL
	aCopyTreeNodes	:= NIL
	nPosMainGrp		:= NIL
	nLstMainGrp		:= NIL
	nSeedTree		:= NIL
	OrgTSetSeq( 0 , 0 , .F. )	
Return

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTSetSeq	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInclusao de novo Grupo/Item no Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OrgTSetSeq( nLastSeq , nSizeSeq , lUseSeq )
	Local nSeq
	Local cSeq
	
	DEFAULT nSizeSeq := 06
	DEFAULT lUseSeq  := .T.
	
	lTreeUseSeq := lUseSeq
	
	IF ( lTreeUseSeq )
		DEFAULT nLastSeq := 0
		cSeq := Replicate( "0" , nSizeSeq )
		nSeq := 0
		While ( nLastSeq <> nSeq )
			++nSeq
			cSeq := Soma1( cSeq )
		End While
	EndIF

	cLastSeq := cSeq
Return cLastSeq

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTUseSeq	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё20/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Esta Utilizando Sequencia na Montagem do Tree   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OrgTUseSeq()
	DEFAULT lTreeUseSeq := .F.
Return( lTreeUseSeq )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgGetNodes  ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarrega os Nodes para a Montagem do dbTree                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OrgGetNodes(	cAliasFather				,;
						cFilFather					,;
						cKeyFather					,;
						cFldDescFather				,;
						nRegFather					,;
						cFldRes1Father				,;
						cFldRes2Father				,;
						cdbTreeAlias		 		,;
						bItemField					,;
						bDescField					,;
						nTreeOrder					,;
						bTreeField					,;
						nItemOrder					,;
						bTreeGetDet		 			,;
						bRes1Field					,;
						bRes2Field					,;
						cLastItemNum				 ;
				 )
	Local bAscanMain
	Local cMainGroup
	Local cFirstNodeName
	Local cResource1
	Local cResource2
	
	aTreeNodes				:= {}
	
	DEFAULT aMainTree		:= {}
	DEFAULT aLstMainTree	:= {}
	DEFAULT aTreeNodes		:= {}
	DEFAULT nPosMainGrp		:= 0
	DEFAULT nLstMainGrp		:= 0
	
	cFilFather := xFilial( cAliasFather , cFilFather )
	bAscanMain := { |x| ( x[1] == cAliasFather );
						.AND.;
						( x[2] == cFilFather );
						.AND.;
						( x[3] == cKeyFather );
				  }		
	
	nPosMainGrp := aScan( aMainTree , bAscanMain )
	IF ( nLstMainGrp <> nPosMainGrp )
		nLstMainGrp := aScan( aLstMainTree , bAscanMain )
		nPosMainGrp := nLstMainGrp
	Else
		nLstMainGrp := nPosMainGrp
	EndIF
	
	IF (;
			( nPosMainGrp == 0 );
			.or.;
			Empty( aMainTree[ nPosMainGrp , 4 ] );
		)
	
		aAdd( aMainTree 	, { cAliasFather , cFilFather , cKeyFather , {} } )
		aAdd( aLstMainTree	, { cAliasFather , cFilFather , cKeyFather , {} } )
		nLstMainGrp  := ( nPosMainGrp := Len( aMainTree ) )
	
		( cAliasFather )->( MsGoto( nRegFather ) )
		cFirstNodeName	:= Eval( FieldWBlock( cFldDescFather , Select( cAliasFather ) ) )
		cFirstNodeName	:= PadR( OemToAnsi( cFirstNodeName ) , NODE_DESC_SIZE )
		
		IF ( cFldRes1Father <> NIL )
			If ValType(cFldRes1Father) == "B"
				cResource1	:= Eval( cFldRes1Father	)
			Else
				cResource1	:= Eval( FieldWBlock( cFldRes1Father, Select( cAliasFather ) ) )
			EndIf
		Else
			cResource1	:= "PMSTASK1"
		EndIF
		
		IF ( cFldRes2Father <> NIL )
			If ValType(cFldRes2Father) == "B"
				cResource2	:= Eval( cFldRes2Father	)
			Else
				cResource2	:= Eval( FieldWBlock( cFldRes2Father , Select( cAliasFather ) ) )
			EndIf
		Else
			cResource2	:= "PMSTASK2"
		EndIF	
		
		cMainGroup	:= Replicate( "0" , Len( ( cdbTreeAlias )->( Eval( bTreeField ) ) ) )
		BldTreeNodes( @aTreeNodes , cMainGroup , cMainGroup , cFirstNodeName , NIL , cResource1 , cResource2 , .F. , nRegFather )
	
		( cdbTreeAlias )->( dbSetOrder( nItemOrder ) )
		cKeyFather	:= ( xFilial( cdbTreeAlias , cFilFather ) + cKeyFather )
		( cdbTreeAlias )->( MsSeek( cKeyFather , .F. ) )
	
		OrgSupNodes(;
						cMainGroup		,;
						cdbTreeAlias	,;
						cKeyFather		,;
						bItemField		,;
						bDescField		,;
						nTreeOrder		,;
						bTreeField		,;
						nItemOrder	 	,;
						bTreeGetDet		,;
						bRes1Field		,;
						bRes2Field		,;
						@cLastItemNum	 ;
					 )
	
		aMainTree[ nPosMainGrp , 4 ] := aClone( aTreeNodes )
	
	Else
		aTreeNodes	:= aClone( aMainTree[ nPosMainGrp , 4 ] )
		cKeyFather	:= ( xFilial( cdbTreeAlias , cFilFather ) + cKeyFather )
	EndIF
	
	aLstMainTree[ nLstMainGrp , 4 ] := aClone( aTreeNodes )
Return( aTreeNodes )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgSupNodes  ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta os Grupos para a Montagem do dbTree                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgSupNodes(	cMainGroup		,;
								cdbTreeAlias	,;
								cKeyFather		,;
								bItemField		,;
								bDescField		,;
								nTreeOrder		,;
								bTreeField		,;
								nItemOrder		,;
								bTreeGetDet		,;
								bRes1Field		,;
								bRes2Field		,;
								cLastItemNum	 ;
						    )
	Local aAreaAnt		:= GetArea()
	Local aArea			:= ( cdbTreeAlias )->( GetArea() )
	Local aRecnos		:= {}
	Local bWhile		:= { || .F. }
	
	Local cSeek
	Local cSeekItem
	Local cIndexKey
	Local nSizeSeek
	Local nLoop
	Local nLoops
	
	( cdbTreeAlias )->( dbSetOrder( nTreeOrder ) )
	cIndexKey := ( cdbTreeAlias )->( IndexKey() )
	IF ( ( cdbTreeAlias )->( MsSeek( cSeek := ( cKeyFather + cMainGroup ) , .F. ) ) )
		bWhile	:= { || ( cSeekItem := SubStr( __ExecMacro( cIndexKey ) , 1 , nSizeSeek ) ) == cSeek }
		nSizeSeek := Len( cSeek )
		While ( ( cdbTreeAlias )->( !Eof() .and. Eval( bWhile ) ) )
			IF ( ( cdbTreeAlias )->( Eval( bTreeGetDet ) ) )
				aAdd( aRecnos , ( cdbTreeAlias )->( Recno() ) )
			EndIF
			( cdbTreeAlias )->( dbSkip() )
		End While
	EndIF
	
	IF ( ( nLoops := Len( aRecnos ) ) > 0 )
		For nLoop := 1 To nLoops
			( cdbTreeAlias )->( dbGoTo( aRecnos[ nLoop ] ) )
			OrgSubNodes(	cdbTreeAlias		,;
							bItemField			,;
							bDescField			,;
							cKeyFather			,;
							nTreeOrder			,;
							bTreeField			,;
							bTreeGetDet			,;
							bRes1Field			,;
							bRes2Field		 	,;
							@cLastItemNum		 ;
						 )
		Next nLoop
	EndIF
	
	RestArea(aArea)
	RestArea(aAreaAnt)
Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgSubNodes  ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta os Sub-Grupos para a Montagem do dbTree               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgSubNodes(	cdbTreeAlias	,;
								bItemField		,;
								bDescField		,;
								cKeyFather		,;
								nTreeOrder		,;
								bTreeField		,;
								bTreeGetDet		,;
								bRes1Field		,;
								bRes2Field		,;
								cLastItemNum	 ;
							 )
	Local aRecnos	:= {}
	Local cDesc
	Local cSeek
	Local cSeekItem
	Local cIndexKey
	Local cGrupoInc
	Local cGrupoSup
	Local cResource1
	Local cResource2
	Local nSizeSeek
	Local nLoop
	Local nLoops
	
	DEFAULT bRes1Field		:= { || "PMSTASK1" }
	DEFAULT bRes2Field		:= { || "PMSTASK2" }
	
	cGrupoInc		:= ( cdbTreeAlias )->( Eval( bItemField ) )
	DEFAULT cLastItemNum	:= cGrupoInc
	cLastItemNum    := IF( ( cGrupoInc > cLastItemNum ) , cGrupoInc , cLastItemNum )
	
	cDesc 			:= ( PadR( cGrupoInc + " - " + ( cdbTreeAlias )->( Eval( bDescField ) ) , NODE_DESC_SIZE ) )
	cGrupoSup		:= ( cdbTreeAlias )->( Eval( bTreeField ) )
	cResource1		:= Upper( AllTrim( ( cdbTreeAlias )->( Eval( bRes1Field ) ) ) )
	cResource2		:= Upper( AllTrim( ( cdbTreeAlias )->( Eval( bRes2Field ) ) ) )
	
	BldTreeNodes( @aTreeNodes , cGrupoSup , cGrupoInc , cDesc , NIL , cResource1 , cResource2 , .F. , ( cdbTreeAlias )->( Recno() ) )
	
	( cdbTreeAlias )->( dbSetOrder( nTreeOrder ) )
	cIndexKey	:= ( cdbTreeAlias )->( IndexKey() ) 
	cSeek		:= ( cKeyFather + cGrupoInc )
	IF ( ( cdbTreeAlias )->( dbSeek( cSeek , .F. ) ) )
		
		nSizeSeek := Len( cSeek )
		
		While (;
					( cdbTreeAlias )->(;
											!Eof();
											.and.;
											(;
												( cSeekItem := SubStr( __ExecMacro( cIndexKey ) , 1 , nSizeSeek ) ) == cSeek ;
											);
									   );
				)
			IF ( ( cdbTreeAlias )->( Eval( bTreeGetDet ) ) )
				aAdd( aRecnos , ( cdbTreeAlias )->( Recno() ) )
			EndIF
			( cdbTreeAlias )->( dbSkip() )
		End While
	
		nLoops := Len( aRecnos )
		For nLoop := 1 To nLoops
			( cdbTreeAlias )->( dbGoTo( aRecnos[ nLoop ] ) )
			OrgSubNodes(	cdbTreeAlias		,;
							bItemField			,;
							bDescField			,;
							cKeyFather			,;
							nTreeOrder			,;
							bTreeField			,;
							bTreeGetDet			,;
							bRes1Field			,;
							bRes2Field		 	,;
							@cLastItemNum		 ;
						 )
		Next nLoop
	
	EndIF	
Return

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetTreeNodes ЁAutorЁMarinaldo de Jesus    Ё Data Ё24/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aTreeNodes                                          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OrgGetTreeNodes()
Return aTreeNodes

Function OrgSetTreeNodes(aNodesSet)
	aTreeNodes:= aNodesSet
Return


/*/
зддддддддддбдддддддддддддддбдддддбддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetCutTreeNodesЁAutorЁMarinaldo de Jesus  Ё Data Ё24/08/2004Ё
цддддддддддедддддддддддддддадддддаддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aCutTreeNodes                                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GetCutTreeNodes()
Return( aCutTreeNodes )

/*/
зддддддддддбдддддддддддддддбдддддбддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁClsCutTreeNodesЁAutorЁMarinaldo de Jesus  Ё Data Ё01/09/2004Ё
цддддддддддедддддддддддддддадддддаддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa aCutTreeNodes                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ClsCutTreeNodes()
	aCutTreeNodes := {}
Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetCopyTreeNodesЁAutorЁMarinaldo de Jesus Ё Data Ё25/08/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aCopyTreeNodes                                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GetCopyTreeNodes()
Return( aCopyTreeNodes )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁClsCopyTreeNodesЁAutorЁMarinaldo de Jesus Ё Data Ё01/09/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa aCopyTreeNodes                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ClsCopyTreeNodes()
	aCopyTreeNodes := {}
Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeMaxItem   ЁAutorЁMarinaldo de Jesus   Ё Data Ё31/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna a Maior Numeracao do Item do Tree                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeMaxItem( aTreeNodes , cMaxItem )
	Local nLoop
	Local nLoops
	
	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		DEFAULT cMaxItem := aTreeNodes[ nLoop , NODE_INFERIOR ]
		IF ( cMaxItem < aTreeNodes[ nLoop , NODE_INFERIOR ] )
			cMaxItem := aTreeNodes[ nLoop , NODE_INFERIOR ]
		EndIF
		cMaxItem := NodeMaxItem( aTreeNodes[ nLoop , NODE_TREE ] , cMaxItem )
	Next nLoop
Return( cMaxItem )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeMaxSeq	  ЁAutorЁMarinaldo de Jesus   Ё Data Ё31/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna a Maior Sequencia Tree                   		    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeMaxSeq( aTreeNodes , cMaxSeq )
	Local nLoop
	Local nLoops
	
	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		DEFAULT cMaxSeq := aTreeNodes[ nLoop , NODE_SEQ ]
		IF ( cMaxSeq < aTreeNodes[ nLoop , NODE_SEQ ] )
			cMaxSeq := aTreeNodes[ nLoop , NODE_SEQ ]
		EndIF
		cMaxSeq := NodeMaxSeq( aTreeNodes[ nLoop , NODE_TREE ] , cMaxSeq )
	Next nLoop
Return( cMaxSeq )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetSup    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Node Superior                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeGetSup( aTreeNodes , cNode )
	Local cNodeSup := cNode
	
	NodeExtSup( aTreeNodes , @cNodeSup )
Return cNodeSup

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeExtSup    ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Existe Node Superior e Retorna-o por Referencia Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeExtSup( aTreeNodes , cNode , cSeq )
	Local lSeq		:= ( cSeq <> NIL )
	Local lExtSup	:= .F.
	
	Local nLoop
	Local nLoops
	
	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		IF (;
				lExtSup := (;
								( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
								.and.;
								IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
							);	
			)
			cNode := aTreeNodes[ nLoop , NODE_SUPERIOR ]
			Exit
		Else
			IF ( lExtSup := ( NodeExtSup( aTreeNodes[ nLoop , NODE_TREE ] , @cNode , cSeq ) ) )
				Exit
			EndIF
		EndIF
	Next nLoop
Return lExtSup

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetPrompt ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Conteudo do Resource2 do Node                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeGetPrompt( aTreeNodes , cNode , cSeq )
	Local lSeq	:= ( cSeq <> NIL )
	
	Local cPrompt
	Local nLoop
	Local nLoops
	
	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		IF (;
				( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
				.and.;
				IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
			)	
			cPrompt := aTreeNodes[ nLoop , NODE_PROMPT ]
	    	Exit
	    Else
	    	cPrompt := NodeGetPrompt( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
			IF ( cPrompt <> NIL )
				Exit
			EndIF
	    EndIF
	Next nLoop
Return cPrompt 

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetPrompt ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta Conteudo do Resource2 do Node                          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeSetPrompt( aTreeNodes , cNode , cSeq , cPrompt )
	Local lSetRes	:= .F.
	Local lSeq		:= ( cSeq <> NIL )
	
	Local nLoop
	Local nLoops
	
	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		IF (;
				lSetRes := (;
								( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
								.and.;
								IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
							);
			)
			aTreeNodes[ nLoop , NODE_PROMPT ] := cPrompt
	    	Exit
	    Else
	    	IF ( lSetRes := NodeSetPrompt( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , cPrompt ) )
	    		Exit
	    	EndIF
	    EndIF
	Next nLoop
Return lSetRes

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetSeq    ЁAutorЁMarinaldo de Jesus   Ё Data Ё02/09/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta a Sequencia do Node                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeSetSeq( aTreeNodes , cNode , cSeq )
	Local lSetSeq := .F.
	Local nLoop
	Local nLoops:= Len(aTreeNodes)
	
	For nLoop := 1 To nLoops
		IF (;
				( aTreeNodes[ nLoop , NODE_ACTIVE ] );
				.and.;
				( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			)
			lSetSeq := .T.
			aTreeNodes[ nLoop , NODE_SEQ ] := cSeq
			Exit
		EndIF
		lSetSeq := NodeSetSeq( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( lSetSeq )
			Exit
		EndIF
	Next nLoop
Return lSetSeq

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetSeq    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna a Sequencia do Node                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeGetSeq( aTreeNodes , cNode , aNotSeqs )
	Local lNoSeq := ( aNotSeqs <> NIL )
	
	Local cSeq
	Local nLoop
	Local nLoops
	
	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		IF (;
				( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
				.and.;
				IF( lNoSeq , ( aScan( aNotSeqs , aTreeNodes[ nLoop , NODE_SEQ ] ) == 0 ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
			)	
			cSeq := aTreeNodes[ nLoop , NODE_SEQ ]
			IF ( lNoSeq )
				aAdd( aNotSeqs , cSeq )
			EndIF
			Exit
		Else
			cSeq := NodeGetSeq( aTreeNodes[ nLoop , NODE_TREE ] , cNode , @aNotSeqs )
			IF !Empty( cSeq )
				Exit
			EndIF
		EndIF
	Next nLoop
Return cSeq

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetTree   ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Tree de Sub-Itens do Node		                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeGetTree( aTreeNodes , cNode , cSeq )
	Local lSeq		:= ( cSeq <> NIL )
	Local aTreeSup
	Local nLoop
	Local nLoops:= Len( aTreeNodes )
	
	For nLoop := 1 To nLoops
		IF (;
				( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
				.and.;
				IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
			)	
				aTreeSup := aClone( aTreeNodes[ nLoop , NODE_TREE ] )
				Exit
		Else
			aTreeSup := NodeGetTree( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
			IF ( aTreeSup <> NIL )
				Exit
			EndIF
		EndIF
	Next nLoop
Return aTreeSup

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetSub    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Array com Todos os Sub-Itens do Node		        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeGetSub( aTreeNodes , cNode , cSeq , lAddTree , aNodeGetSub )
	Local lSeq	:= ( cSeq <> NIL )
	Local nLoop
	Local nLoops
	DEFAULT aNodeGetSub := {}
	DEFAULT lAddTree	:= .F.
	
	nLoops := Len( aTreeNodes )    
	
	For nLoop := 1 To nLoops
		IF (;
				( aTreeNodes[ nLoop , NODE_SUPERIOR ] == cNode );
				.and.;
				IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
			)	
			aAdd( aNodeGetSub , { aTreeNodes[ nLoop , NODE_INFERIOR ] , IF( lAddTree , aClone( aTreeNodes[ nLoop , NODE_TREE ] ) , {} ) } )
		EndIF      
		
		NodeGetSub( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , lAddTree , @aNodeGetSub )
	Next nLoop
Return( aNodeGetSub )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetAct    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Status do Node                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeGetAct( aTreeNodes , cNode , cSeq )
	Local lSeq	:= ( cSeq <> NIL )
	Local lNodeAct
	Local nLoop
	Local nLoops := Len( aTreeNodes ) 
	
	For nLoop := 1 To nLoops
		IF (;
				( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
				.and.;
				IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
			)
			lNodeAct := aTreeNodes[ nLoop , NODE_ACTIVE ]
	    	Exit
	    Else
	    	lNodeAct := NodeGetAct( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
			IF ( lNodeAct <> NIL )
				Exit
			EndIF
	    EndIF
	Next nLoop

Return( lNodeAct )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeRetCol    ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/09/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aCols com Todos os Itens de aCols do aTreeNodes     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeRetCol( aTreeNodes , aCols )

Local nLoop
Local nLoops

DEFAULT aCols := {}

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF !Empty( aTreeNodes[ nLoop , NODE_ACOLS ] )
		aAdd( aCols , aClone( aTreeNodes[ nLoop , NODE_ACOLS ] ) )
	EndIF
	NodeRetCol( aTreeNodes[ nLoop , NODE_TREE ] , @aCols )
Next nLoop

Return( aCols )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetCol    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Conteudo do aCols do Node                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeGetCol( aTreeNodes , cNode , cSeq )

Local lSeq	:= ( cSeq <> NIL )

Local aCols
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)	
		IF !Empty( aTreeNodes[ nLoop , NODE_ACOLS ] )
			aCols := aClone( aTreeNodes[ nLoop , NODE_ACOLS ] )
		Else
			aCols := {}
		EndIF
    	Exit
    Else
    	aCols := NodeGetCol( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( aCols <> NIL )
			Exit
		EndIF
    EndIF
Next nLoop

Return( aCols )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetCol    ЁAutorЁMarinaldo de Jesus   Ё Data Ё20/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta o Conteudo do aCols do Node                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeSetCol( aTreeNodes , cNode , cSeq , aCols )

Local lSeq		:= ( cSeq <> NIL )
Local lSetaCols	:= .F.

Local nLoop
Local nLoops

DEFAULT aCols := {}

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			lSetaCols := (;
								( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
								.and.;
								IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
						 );
		)
		aTreeNodes[ nLoop , NODE_ACOLS ] := aClone( aCols )
    	Exit
    Else
		lSetaCols := NodeSetCol( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , aCols )
		IF ( lSetaCols )
			Exit
		EndIF
    EndIF
Next nLoop

Return( lSetaCols )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetRs1    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Conteudo do Resource1 do Node                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeGetRs1( aTreeNodes , cNode , cSeq )

Local lSeq	:= ( cSeq <> NIL )

Local cResource
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)	
		cResource := aTreeNodes[ nLoop , NODE_RESOURCE1 ]
    	Exit
    Else
    	cResource := NodeGetRs1( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( cResource <> NIL )
			Exit
		EndIF
    EndIF
Next nLoop

Return( cResource )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetRs1    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta o Conteudo do Resource1 do Node                        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeSetRs1( aTreeNodes , cNode , cSeq , cResource )

Local lSetRes	:= .F.
Local lSeq		:= ( cSeq <> NIL )

Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			lSetRes := (;
							( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
							.and.;
							IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
						);
		)
		aTreeNodes[ nLoop , NODE_RESOURCE1 ] := cResource
    	Exit
    Else
    	IF ( lSetRes := NodeSetRs1( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , cResource ) )
    		Exit
    	EndIF
    EndIF
Next nLoop

Return( lSetRes )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeGetRs2    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o Conteudo do Resource2 do Node                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeGetRs2( aTreeNodes , cNode , cSeq )

Local lSeq	:= ( cSeq <> NIL )

Local cResource
Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
			.and.;
			IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
		)	
		cResource := aTreeNodes[ nLoop , NODE_RESOURCE1 ]
    	Exit
    Else
    	cResource := NodeGetRs2( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq )
		IF ( cResource <> NIL )
			Exit
		EndIF
    EndIF
Next nLoop

Return( cResource )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁNodeSetRs2    ЁAutorЁMarinaldo de Jesus   Ё Data Ё19/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeta Conteudo do Resource2 do Node                          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function NodeSetRs2( aTreeNodes , cNode , cSeq , cResource )

Local lSetRes	:= .F.
Local lSeq		:= ( cSeq <> NIL )

Local nLoop
Local nLoops

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF (;
			lSetRes := (;
							( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNode );
							.and.;
							IF( lSeq , ( aTreeNodes[ nLoop , NODE_SEQ ] == cSeq ) , aTreeNodes[ nLoop , NODE_ACTIVE ] );
						);
		)
		aTreeNodes[ nLoop , NODE_RESOURCE2 ] := cResource
    	Exit
    Else
    	IF ( lSetRes := NodeSetRs2( aTreeNodes[ nLoop , NODE_TREE ] , cNode , cSeq , cResource ) )
    		Exit
    	EndIF
    EndIF
Next nLoop

Return( lSetRes )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁBldTreeNodes ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInclusao de novo Grupo/Item no Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function BldTreeNodes(	aTreeNodes		,;
								cSuperior		,;
								cInferior		,;
								cPrompt			,;
								aCols			,;
								cResource1		,;
								cResource2		,;
								lForceAddNew	,;
								nRecno			 ;
						 )
                
Local lAddOk	:= .F.

Local nLoop
Local nLoops

DEFAULT lForceAddNew	:= .F.

Begin Sequence
    
	IF ( lAddOk := (;
						( ( nLoops := Len( aTreeNodes ) ) == 0 );
						.or.;
						( lForceAddNew );
					);
		)
		AddNewNode( aTreeNodes , cInferior , cSuperior , cPrompt , aCols , cResource1 , cResource2 , nRecno )
		Break
	Else
		For nLoop := 1 To nLoops
			IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
				IF ( lAddOk := ( aTreeNodes[ nLoop , NODE_INFERIOR ] == cSuperior ) )
					AddNewNode( @aTreeNodes[ nLoop , NODE_TREE ] , cInferior , cSuperior , cPrompt , aCols , cResource1 , cResource2 , nRecno )
					Break
				EndIF
				IF ( Len( aTreeNodes[ nLoop , NODE_TREE ] ) > 0 )
					IF ( lAddOk := BldTreeNodes( @aTreeNodes[ nLoop , NODE_TREE ] , cSuperior , cInferior , cPrompt , aCols , cResource1 , cResource2 , .F. , nRecno ) )
						Break
					EndIF
				EndIF
			EndIF
		Next nLoop
	EndIF

End Sequence
			
Return( lAddOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁAddNewNode	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInclusao de novo Grupo/Item no Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function AddNewNode(		aTreeNodes	,;
								cInferior	,;
								cSuperior	,;
								cPrompt		,;
								aCols		,;
								cResource1	,;
								cResource2	,;
								nRecno		 ;
						  )

Local aNode := Array( NODE_ELEMENTS )

DEFAULT aCols := {}

aNode[ NODE_INFERIOR 	]	:= cInferior
aNode[ NODE_SUPERIOR 	]	:= cSuperior
aNode[ NODE_PROMPT   	]	:= cPrompt
aNode[ NODE_ACOLS	 	]	:= aClone( aCols )
aNode[ NODE_ACTIVE   	]	:= .T.
aNode[ NODE_TREE     	]	:= {}
IF ( OrgTUseSeq() )
	cLastSeq := Soma1( cLastSeq )
EndIF
aNode[ NODE_SEQ			]	:= cLastSeq
aNode[ NODE_RESOURCE1	]	:= cResource1
aNode[ NODE_RESOURCE2	]	:= cResource2
aNode[ NODE_RECNO		] 	:= nRecno

aAdd( aTreeNodes , aClone( aNode ) )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁDelTreeNodes ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁExclusao de novo Grupo/Item no Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function DelTreeNodes( aTreeNodes , cNodeExc , lRemove )

Local nDeleted	:= 0

Local nLoop
Local nLoops

DEFAULT lRemove := .F.

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] ) 
		IF ( aTreeNodes[ nLoop , NODE_INFERIOR ] == cNodeExc )
			aTreeNodes[ nLoop , NODE_ACTIVE ] := .F.
			IF ( lRemove )
				aDel( aTreeNodes ,  nLoop )
				++nDeleted
				Exit
			EndIF	
			IF ( Len( aTreeNodes[ nLoop , NODE_TREE ] ) > 0 )
				DelTreeNodes( @aTreeNodes[ nLoop , NODE_TREE ] , aTreeNodes[ nLoop , NODE_TREE , 01 , NODE_INFERIOR ] , lRemove )
			EndIF
		Else
			DelTreeNodes( aTreeNodes[ nLoop , NODE_TREE ] , cNodeExc , lRemove )
		EndIF
	EndIF
Next nLoop 
    
IF (;
		( lRemove );
		.and.;
		( nDeleted > 0 );
	)
	aSize( aTreeNodes , ( nLoops - nDeleted ) )
EndIF	

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgDbTree    ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁChamada a dbTree com Carga das Informacoes Iniciais         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgDbTree(	adbTree			,;
							oTreeDlg		,;
							bTreeInit		,;
							bTreeRClicked	,;
							bTreeChange		,;
							aObjSize		,;
							nWidthTree		,;
							oTreeRef		;
						 )
	Local cMainGroup
	Local nLoop
	Local nLoops
	Local oTree
	
	If oTreeRef != NIL
		oTree:= oTreeRef
		oTree:BeginUpdate()
		oTree:Reset()
	Else
		oTree:= DBTree():New(	aObjSize[01,01],;
								aObjSize[01,02],;
								aObjSize[01,03],;
								(aObjSize[01,04] / 100 * nWidthTree),;
								oTreeDlg,;
								NIL,;
								NIL,;
								.T. )
		oTree:BeginUpdate()
		oTree:lVisibleControl := .F.	//:Hide()
	EndIf
	
	nLoops := Len( adbTree )
	For nLoop := 1 To nLoops
		cMainGroup := ( "*-" + adbTree[ nLoop , NODE_SUPERIOR ] )

		DBADDTREE oTree PROMPT adbTree[ nLoop , NODE_PROMPT ] RESOURCE adbTree[ nLoop , NODE_RESOURCE1 ],adbTree[ nLoop , NODE_RESOURCE2 ] CARGO cMainGroup OPEN

		Proc2BarGauge( { || OrgSupTree( adbTree[ nLoop , NODE_TREE ] , @oTree , cMainGroup , Time() ) } , OemToAnsi(STR0005) , NIL , NIL , .F. , .T. , .T. , .T. )

		DBENDTREE oTree
	Next nLoop
	
	oTree:bRClicked  		:= bTreeRClicked
	oTree:bChange			:= bTreeChange
	oTree:lVisibleControl := .T.	
	oTree:EndUpdate()
	
	IF ( ValType( bTreeInit ) == "B" )
		Eval( bTreeInit )
	EndIF
	
Return oTree

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgSupTree   ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta os Grupos do Tree                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgSupTree( adbTree , oTree , cMainGroup , cTimeIni )

Local nLoop
Local nLoops
Local nContPrc
Local nSubTree

oTree:TreeSeek( cMainGroup )

DEFAULT nSeedTree := 1000

IF ( ( nLoops := Len( adbTree ) ) > 0 )
	BarGauge1Set( nLoops )
	IncProcG1( STR0034 , .F. )	 //'Incluindo Grupo'
	nContPrc := Aleatorio( 15000 , @nSeedTree )
	oTree:BeginUpdate()
		For nLoop := 1 To nLoops
			IncPrcG1Time( STR0034 + ": " + AllTrim( Str( nLoop ) ) , nLoops , cTimeIni , .F. , nContPrc , 1 ) //'Incluindo Grupo'
			OrgSubTree(;
							adbTree[ nLoop , NODE_TREE ],;
							@oTree,;
							cMainGroup,;
							adbTree[ nLoop , NODE_PROMPT ],;
							( "+-" + adbTree[ nLoop , NODE_INFERIOR ] ),;
			 				adbTree[ nLoop , NODE_RESOURCE1 ],;
			 				adbTree[ nLoop , NODE_RESOURCE2 ],;
							cTimeIni,;
							@nSubTree;
						)
		Next nLoop
	oTree:EndUpdate()
EndIF

oTree:TreeSeek( cMainGroup )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgSubTree	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё17/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta os Sub-Grupos do Tree                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgSubTree(		adbTree		,;
								oTree		,;
								cSupTree	,;
								cNewDesc	,;
								cNewItem	,;
								cResource1	,;
								cResource2	,;
								cTimeIni	,;
								nSubTree	 ;
						  )

Local a2BarSet
Local nLoop
Local nLoops
Local nContPrc

DEFAULT cResource1	:= "PMSTASK1"
DEFAULT cResource2	:= "PMSTASK2"
DEFAULT nSubTree	:= 0

oTree:TreeSeek( cSupTree )
oTree:AddItem( cNewDesc , cNewItem , cResource1 , cResource2 , NIL , NIL , 2 )
oTree:TreeSeek( cNewItem )

IF ( ( nLoops := Len( adbTree ) ) > 0 )
	BarGauge2Set( nLoops )
	IncProcG2( STR0035 , .F. )	//'Incluindo Sub-Grupo'
	nContPrc	:= Aleatorio( 15000 , @nSeedTree )
	For nLoop := 1 To nLoops
		++nSubTree
		IncPrcG2Time( STR0035 + ": " + AllTrim( Str( nSubTree ) ) , nLoops , cTimeIni , .F. , nContPrc , 1 )	//'Incluindo Sub-Grupo'
		a2BarSet := Get2BarSet()
			OrgSubTree(;
			 				adbTree[ nLoop , NODE_TREE ],;
			 				@oTree,;
			 				cNewItem,;
			 				adbTree[ nLoop , NODE_PROMPT ],;
			 				( "+-" + adbTree[ nLoop , NODE_INFERIOR ] ),;
			 				adbTree[ nLoop , NODE_RESOURCE1 ],;
			 				adbTree[ nLoop , NODE_RESOURCE2 ],;
			 				cTimeIni,;
			 				@nSubTree;
			 			)
		Rst2BarSet( a2BarSet )
	Next nLoop
EndIF

oTree:TreeSeek( cSupTree )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgBldMnuTreeЁAutorЁMarinaldo de Jesus    Ё Data Ё12/09/2003Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCria e Retorna Menu para Estruturacao do Tree               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OrgBldMnuTree( aMenuPopUp , aMenuDisable )

Local aDsbMenu
Local nMenu
Local nMenus
Local nLoop
Local nLoops
Local oMenu
Local cResource

oMenu := MenuBegin( NIL , NIL , NIL , NIL , .T. , NIL , NIL , NIL )
	nMenus := Len( aMenuPopUp )
    For nMenu := 1 To nMenus
    	If Len(aMenuPopUp[nMenu]) >= 5
	    	cResource:= aMenuPopUp[nMenu , 5]
	    Else
		    cResource:= NIL
	    EndIF
		MenuAddItem(;
						aMenuPopUp[nMenu , 1],;
						NIL	,;
						.F.	,;
						NIL	,;
						aMenuPopUp[nMenu , 2],;	//5
						NIL	,;
						cResource,;
						NIL	,;
						NIL	,;
						NIL	,;						//10
						NIL	,;
						.F.	,;
						NIL	,;
						NIL	,;
						.F.	 ;
					 )
		IF (;
				( Len( aMenuPopUp[ nMenu ] ) >= 4 );
				.and.;
				( ValType( aMenuPopUp[ nMenu , 4 ] ) == "A" );
			)	
			MenuBegin( NIL , NIL , NIL , NIL , .T. , NIL , NIL , NIL )
				aDsbMenu := {}
				IF ( aScan( aMenuDisable , { |x| ( x == nMenu ) } ) > 0 )
					nLoops := Len( aMenuPopUp[ nMenu , 4 ] )
					For nLoop := 1 To nLoops
						aAdd( aDsbMenu , nLoop )
					Next nLoop	
				EndIF
				OrgBldMnuTree( aMenuPopUp[ nMenu , 4 ] , aDsbMenu )
			MenuEnd()
		EndIF
		
		IF ( aScan( aMenuDisable , { |x| ( x == nMenu ) } ) > 0 )
			aMenuPopUp[ nMenu , 03 ] := .F.
		EndIF
		
		IF !( aMenuPopUp[ nMenu , 03 ] )
			oMenu:aItems[ nMenu ]:Disable()
		EndIF
		
		oMenu:aItems[ nMenu ]:bValid := { || Alert( aMenuPopUp[ nMenu , 01 ] ) , .T. }
	Next nMenu
MenuEnd()

Return( oMenu )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeSeek  ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁEfetua pesquisa no Tree                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeSeek( oTree , cGrp , cdbTreeF3 , nSize )

Local aSvKeys	:= GetKeys()
Local cKeySeek	:= Space( nSize )

Local nOpcA		:= 0

Local oDlg
Local oBut1
Local oBut2
Local oGetPesq

DEFAULT cGrp := ""

DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0001 ) FROM 0,0 TO 005,035 OF GetWndDefault() //'Pesquisar'

	DEFINE FONT oBold NAME "Arial" 			SIZE  0, -13 BOLD
                                                      
	@ 012.5,005 SAY OemToAnsi(STR0011)		SIZE 040,010 PIXEL FONT oBold //'Item:'
	@ 010.0,025 MSGET oGetPesq VAR cKeySeek	SIZE nSize,010 VALID .T. PIXEL
	IF !Empty( cdbTreeF3 )
		oGetPesq:cF3 := cdbTreeF3
	EndIF

	DEFINE SBUTTON oBut1 FROM 010,075 Type 1 ACTION ( nOpcA := 1 , oDlg:End() ) ENABLE OF oDlg
	DEFINE SBUTTON oBut2 FROM 010,105 Type 2 ACTION ( nOpcA := 0 , oDlg:End() ) ENABLE OF oDlg

ACTIVATE MSDIALOG oDlg CENTERED  
 
IF ( nOpcA == 1 )
	IF !( oTree:TreeSeek( cGrp + AllTrim( cKeySeek ) ) )
		MsgInfo( OemToAnsi( STR0010 ) , OemToAnsi( STR0007 ) ) //'N└o existe ║tem pesquisado...'###'Aten┤└o!'
	EndIF
EndIF 

RestKeys( aSvKeys , .T. )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeVis   ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVisualizar Detalhes do Item do Tree                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeVis(	oTree , cKeyFather , cdbTreeAlias , nItemOrder )

Local aSvKeys	:= GetKeys()

Local cCargo

IF ( Left( ( cCargo := oTree:GetCargo() ) , 1 ) == "+" )

	( cdbTreeAlias )->( dbSetOrder( nItemOrder ) )

	IF ( ( cdbTreeAlias )->( MsSeek( cKeyFather + SubStr( cCargo , 3 ) , .F. ) ) )
		SetMemoFields( cdbTreeAlias , GetMemoDb( cdbTreeAlias ) )	//Seta os Campos Memos Virtuais
		AxVisual( cdbTreeAlias, ( cdbTreeAlias )->( Recno() ) , 2 )
	EndIF
	
EndIF

RestKeys( aSvKeys , .T. )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeInc	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁInclui Novo Item no Tree                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeInc( oTree			,;
							aTreeNodes		,;
							cKeyFather		,;
							cdbTreeAlias	,;
							bItemField		,;
							bDescField		,;
							nItemOrder		,;
							cSetFilConPad	,;
							lAllRegs		,;
							bTreeGetDet		,;
							bRes1Field		,;
							bRes2Field		 ;
						   )

Local aSvKeys		:= GetKeys()
Local nAddCount		:= 0


Local bIncOption
Local bCnPdFilter
Local cbCnPdFilter
Local cDesc
Local cCargo
Local cNewInc
Local cAddItem
Local cGrpInc
Local cItemSeekKey
Local cIndexKey
Local cFilterKey
Local cLastAddItem
Local cResource1
Local cResource2
Local lFound
Local lMaster
Local lConPad1
Local nIncOption
Local nAt
Local nItenSeekKey

DEFAULT lAllRegs	:= .F.

Begin Sequence

	IF !( lAllRegs )

		IF (;
				!Empty( cSetFilConPad );
				.and.;
				FindFunction( cSetFilConPad );
			)
			Public aOrgFltTree	:= aClone( aTreeNodes ) //Public aqui para Set Filter em ConPad1, nao retirar (by naldo)
			Public bGetDetTree	:= bTreeGetDet			//Public aqui para Set Filter em ConPad1, nao retirar (by naldo)
			Public cOrgFltKey	:= ""                  	//Public aqui para Set Filter em ConPad1, nao retirar (by naldo)
			cbCnPdFilter		:= "{ |cKeyFilter| cOrgFltKey := cKeyFilter , OrgNoExistNode( aOrgFltTree , cOrgFltKey ) .and. Eval( bGetDetTree ) }"
			IF ( ( nAt := At( "(" , cSetFilConPad ) ) > 0 )
				cSetFilConPad := SubStr( cSetFilConPad , 1 , --nAt )
			EndIF
			__ExecMacro( cSetFilConPad + "(" + cbCnPdFilter + ")" )
		EndIF
		
		MsAguarde( { || lConPad1 := ConPad1( NIL , NIL , NIL , cdbTreeAlias , NIL , NIL , .F. ) } )
		IF ( !( lConPad1 ) )
			Break
		EndIF
		
		cCargo	:= oTree:GetCargo()
		
		lMaster		:= ( "*-" $ cCargo )
		
		oTree:TreeSeek( cCargo )
		
		bIncOption	:= { || IF( ( lMaster ) , 2 /*/Sempre um Nivel Abaixo*/ , Aviso( OemToAnsi( STR0013 ) /*/'Inclus└o de novo ║tem'*/, OemToAnsi( STR0014 ) /*/'Selecione o n║vel'*/ , { OemToAnsi( "&"+STR0015 ) /*/'Novo Item'*/ , OemToAnsi( "&"+STR0016 ) /*/'Sub-Item'*/ } ) ) }

	Else

		CursorWait()
		
		( cdbTreeAlias )->( dbSetOrder( nItemOrder ) )
		cIndexKey		:= ( cdbTreeAlias )->( IndexKey() )
		
		cItemSeekKey	:= cKeyFather
		nItenSeekKey	:= Len( cItemSeekKey )

		( cdbTreeAlias )->( dbSeek( cItemSeekKey , .F. ) )
		
		oTree:TreeSeek( "*-" )
		cCargo			:= oTree:GetCargo()

		nIncOption      := 2
		
	EndIF

	bCnPdFilter	:= { |cKeyFilter| cFilterKey := cKeyFilter , !( OrgNoExistNode( aTreeNodes , cFilterKey ) ) }

	cGrpInc	:= SubStr( cCargo , 3 )
	While (;
				IF( lAllRegs ,;
								(;
									( cdbTreeAlias )->(;
														!Eof();
														.and.;
														( SubStr( __ExecMacro( cIndexKey ) , 1 , nItenSeekKey ) == cItemSeekKey );
													  );	
								),;
								lConPad1;
					);
			)

		IF ( ( cdbTreeAlias )->( !( Eval( bTreeGetDet ) ) ) )
			( cdbTreeAlias )->( dbSkip() )
			Loop
		EndIF

		IF ( Empty( cNewInc := Eval( bItemField ) ) )
			//'N└o ┌ permitida a inser┤└o de ║tem em branco.'###'Aten┤└o!'
			IF ( !( lAllRegs ) )
				MsgInfo( OemToAnsi( STR0023  ) , OemToAnsi( STR0007 ) )
				Break
			Else
				( cdbTreeAlias )->( dbSkip() )
				Loop
			EndIF	
		EndIF

		cAddItem := ( "+-" + cNewInc )
		
		IF ( lFound	:= Eval( bCnPdFilter , cNewInc ) )
			//'J═ existe o ║tem...'###'Aten┤└o!'
			IF ( !( lAllRegs ) )
				MsgInfo( OemToAnsi( STR0009 ) , OemToAnsi( STR0007 ) )
				Break
			Else
				( cdbTreeAlias )->( dbSkip() )
				Loop
			EndIF
		EndIF

		cDesc := PadR( cNewInc + " - " + Eval( bDescField ) , NODE_DESC_SIZE )

		IF ( !( lAllRegs ) )
			nIncOption	:= Eval( bIncOption )
		EndIF

		cResource1 := IF( Empty( cResource1 ) , "PMSTASK1" , cResource1 )
		cResource2 := IF( Empty( cResource2 ) , "PMSTASK2" , cResource2 )

		oTree:AddItem( cDesc , cAddItem , cResource1 , cResource2 , NIL , NIL , nIncOption )
		cLastAddItem	:= cAddItem
		++nAddCount

		IF ( !( lAllRegs ) )
			IF (;
					!( lMaster );
					.and.;
					( nIncOption == 1 );
				)
				cGrpInc := NodeGetSup( aTreeNodes , cGrpInc )
			EndIF
		EndIF

		BldTreeNodes( @aTreeNodes , cGrpInc , cNewInc , cDesc , NIL , cResource1 , cResource2 , .F. , ( cdbTreeAlias )->( Recno() ) )

		IF ( lAllRegs )
			( cdbTreeAlias )->( dbSkip() )
		Else
			lConPad1 := .F.
		EndIF
	
	End While

	IF ( lAllRegs )
		CursorArrow()
	EndIF

	IF ( nAddCount > 0 )
		oTree:TreeSeek( cLastAddItem )
		IF ( lAllRegs )
			//'Novos Itens Foram Incluidos.'###'Aten┤└o!'
			//'Novo Item Foi Incluido.'
			MsgInfo( Str( nAddCount ) + " " + OemToAnsi( IF( nAddCount > 1 , STR0026 , STR0027 ) ) , OemToAnsi( STR0007 ) )
		EndIF	
	Else
		oTree:TreeSeek( cCargo )
		IF ( lAllRegs )
			//'N└o existem itens a serem Incluidos.'###'Aten┤└o!'
			MsgInfo( OemToAnsi( STR0025  ) , OemToAnsi( STR0007 ) )
		EndIF	
	EndIF

End Sequence

RestKeys( aSvKeys , .T. )

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgNoExistNodeЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Ja Existe o Node                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OrgNoExistNode( aOrgFltTree , cOrgFltKey )

Local lNoExistNode := .T.

Local nLoop
Local nLoops

nLoops := Len( aOrgFltTree )
For nLoop := 1 To nLoops
	IF ( aOrgFltTree[ nLoop , NODE_ACTIVE ] )
		IF !( lNoExistNode := !( aOrgFltTree[ nLoop , NODE_INFERIOR ] == cOrgFltKey ) )
			Exit
		Else
			IF ( !( lNoExistNode := ( OrgNoExistNode( aOrgFltTree[ nLoop , NODE_TREE ] , cOrgFltKey ) ) ) )
				Exit
			EndIF
		EndIF
	EndIF
Next nLoop

Return( lNoExistNode )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeExc	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁExclui Item e Sub-Itens do Tree                             Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeExc( oTree , aTreeNodes , bMenuVldExc , lRemove )

Local aLogGer		:= {}
Local aLogGerTitle	:= {}
Local cGrupoExc		:= SubStr( oTree:GetCargo() , 3 )
Local lExcluOk		:= .T.

Begin Sequence

	IF (;
			!( lExcluOk := OrgTreeCkExc(	@aTreeNodes		,;
											cGrupoExc		,;
											bMenuVldExc 	,;
											@aLogGer		,;
											@aLogGerTitle	 ;
								  );
		 	);
		)	
		Break
	EndIF
		
	oTree:DelItem()
	DelTreeNodes( @aTreeNodes , cGrupoExc , lRemove )

End Sequence

IF ( !( lExcluOk ) )
	CursorArrow()
	//'Este Grupo/Sub-Grupo nЦo pode ser Excluido. Deseja visualizar o Log?'###*'Aten┤└o!'
	IF ( MsgNoYes( OemToAnsi( STR0033 ) , OemToAnsi( STR0007 ) ) ) 
		CursorWait()
		//'Log de Inconsistencia na Exclusao de Grupo/Sub-Grupo'
		fMakeLog( aLogGer , aLogGerTitle , NIL , NIL , FunName() , STR0012 )
	EndIF	
EndIF

Return( lExcluOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeCkExc ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Item e Sub-Item(ns) podem ser Excluidos         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeCkExc(	aTreeNodes	,;
								cGrupoExc	,;
								bMenuVldExc ,;
								aLogGer		,;
								aLogGerTitle ;
							)

Local aLog			:= {}
Local aLogTitle		:= {}
Local lTreeChkExc	:= .T.

Local aNodesAux	
Local cGrpExc
Local nLoop
Local nLoops
Local nLoop1
Local nLoops1

DEFAULT bMenuVldExc := { || .T. }

Begin Sequence

	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
			IF ( aTreeNodes[ nLoop , NODE_INFERIOR ] == cGrupoExc )
				IF ( !( lTreeChkExc := Eval( bMenuVldExc , cGrupoExc , @aLog , @aLogTitle ) ) )
					aAdd( aLogGer , aClone( aLog ) )
					aAdd( aLogGerTitle , aLogTitle[1] )
					Break
				EndIF
				aNodesAux := aTreeNodes[ nLoop , NODE_TREE ]
				nLoops1 := Len( aNodesAux )
				For nLoop1 := 1 To nLoops1
					cGrpExc := aNodesAux[ nLoop1 , NODE_INFERIOR ]
					IF (;
							!( lTreeChkExc := OrgTreeCkExc(	aNodesAux		,;
															cGrpExc 		,;
															bMenuVldExc		,;
															@aLogGer		,;
															@aLogGerTitle	 ;
														 );
							);
						)
						Break
					EndIF
				Next nLoops1
			Else
				IF (;
						!( lTreeChkExc := OrgTreeCkExc(	aTreeNodes[ nLoop , NODE_TREE ]	,;
														cGrupoExc						,;
														bMenuVldExc						,;
														@aLogGer						,;
														@aLogGerTitle					 ;
													 );
						  );
					)
					Break
				EndIF	
			EndIF
		EndIF
	Next nLoop

End Sequence
	
Return( lTreeChkExc )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeCpy	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё25/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRecortar Informacoes do Tree                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeCpy(	oTree			,;
							aTreeNodes		,;
							aCopyTreeNodes	,;
							aMenuPopUp		,;
							nIndEnable		,;
							bMenuVldCut 	,;
							lCut			,;
							cRes1ChgCut		,;
							cRes2ChgCut		,;
							aCutTreeNodes	 ;
						  )

Local cCargo	:= oTree:GetCargo()
Local cGrpSup	:= SubStr( cCargo , 3 )

Local cMsgInfo

Begin Sequence

	IF ( OrgExistCut( aCutTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0039	//"N└o ┌ possivel copiar informa┤└o(■es) de ║tem(ns) recortados.' 
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//'A opera┤└o nao ser═ efetuada.'
		Break
	EndIF

	oTree:TreeSeek( cCargo )

	DEFAULT cRes1ChgCut := "note"
	DEFAULT cRes2ChgCut := "note"

	OrgTreeCut(;
					@oTree,;
					@aTreeNodes,;
					@aCopyTreeNodes,;
					@aMenuPopUp,;
					@nIndEnable,;
					@bMenuVldCut,;
					@lCut,;
					@cRes1ChgCut,;
					@cRes2ChgCut;
				)

End Sequence

IF !Empty( cMsgInfo )
	MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) /*/'Aten┤└o!'*/ )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgPstCpyTreeЁAutorЁMarinaldo de Jesus    Ё Data Ё25/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCola as Informacoes da Copia 								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgPstCpyTree(	oTree 			,;
								aTreeNodes		,;
								aCopyTreeNodes	,;
								aMenuPopUp		,;
								nIndDisable		,;
								bChangeValue	,;
								aCutTreeNodes	,;
								nIncOption		 ;
							 )

Local aNewNodes
Local aNodeUnCopy
Local cCargo
Local cGrpSup
Local cMsgInfo
Local nLoop
Local nLoops

Begin Sequence

	IF Empty( aCopyTreeNodes )
		Break
	EndIF

	cCargo	  	:= oTree:GetCargo()		
	cGrpSup		:= SubStr( cCargo , 3 )

	IF ( OrgExistCut( aCutTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0020	//'N└o ┌ possivel colar informa┤└o(■es) sobre ║tem(ns) recortados.' 
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//'A opera┤└o nao ser═ efetuada.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0022	//'Selecione outro n║vel para colar a(s) informa┤└o(■es).'
		Break
	EndIF

	CursorWait()
		aNewNodes	:= aClone( aCopyTreeNodes )
		OrgChgInfValue( @aNewNodes , bChangeValue , @aNodeUnCopy )
	CursorArrow()
	OrgTreePst(	@oTree , @aTreeNodes , @aNewNodes , @aMenuPopUp , nIndDisable , .F. , @nIncOption )
	cCargo := oTree:GetCargo()

	oTree:lVisibleControl := .F.	//:Hide()
		CursorWait()
			nLoops := Len( aNodeUnCopy )
			For nLoop := 1 To nLoops
				OrgTreeGrCut( @oTree , @aTreeNodes , @aCopyTreeNodes , aNodeUnCopy[ nLoop ] , .F. )
			Next nLoops
			oTree:TreeSeek( cCargo )
		CursorArrow()	
	oTree:lVisibleControl := .T.	//:Show()

	aCopyTreeNodes := {}
	ClsCopyTreeNodes()

End Sequence

IF !Empty( cMsgInfo )
	MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) /*/'Aten┤└o!'*/ )
EndIF

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgChgInfValueЁAutorЁMarinaldo de Jesus   Ё Data Ё25/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAltera o conteudo do Node Inferior							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgChgInfValue( aNewNodes , bChangeValue , aNodeUnCopy )

Local cLastNode
Local cNewNode
Local cLastDesc
Local cNewDesc

Local nLoop
Local nLoops

DEFAULT aNodeUnCopy := {}

nLoops := Len( aNewNodes )
For nLoop := 1 To nLoops
	cNewNode	:= Eval( bChangeValue , aNewNodes , nLoop )
	IF Empty( cNewNode )
		Loop
	EndIF
	cLastNode	:= aNewNodes[ nLoop , NODE_INFERIOR ]
	aAdd( aNodeUnCopy , cLastNode )
	aNewNodes[ nLoop , NODE_INFERIOR ] := cNewNode
	cLastDesc	:= aNewNodes[ nLoop , NODE_PROMPT ]
	IF ( cLastNode == SubStr( cLastDesc , 1 , Len( cLastNode ) ) )
		cNewDesc := ( cNewNode + SubStr( cLastDesc , Len( cLastNode ) + 1 ) )
		aNewNodes[ nLoop , NODE_PROMPT ] := cNewDesc
	EndIF
	OrgChgSupValue( aNewNodes[ nLoop , NODE_TREE ] , bChangeValue , cLastNode , cNewNode )
	OrgChgInfValue( aNewNodes[ nLoop , NODE_TREE ] , bChangeValue , @aNodeUnCopy )
Next nLoop

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgChgInfValueЁAutorЁMarinaldo de Jesus   Ё Data Ё25/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAltera o conteudo do Node Superior							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgChgSupValue( aNewNodes , bChangeValue , cLastNode , cNewNode )

Local nLoop
Local nLoops

nLoops := Len( aNewNodes )
For nLoop := 1 To nLoops
	IF ( aNewNodes[ nLoop , NODE_SUPERIOR ] == cLastNode )
		aNewNodes[ nLoop , NODE_SUPERIOR ] := cNewNode
	EndIF
Next nLoop

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgCutTree	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRecortar Informacoes do Tree                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgCutTree(	oTree			,;
							aTreeNodes		,;
							aCutTreeNodes	,;
							aMenuPopUp		,;
							nIndEnable		,;
							bMenuVldCut 	,;
							lCut			,;
							cRes1ChgCut		,;
							cRes2ChgCut		,;
							aCopyTreeNodes	 ;
						  )

Local cCargo	:= oTree:GetCargo()
Local cGrpSup	:= SubStr( cCargo , 3 )

Local cMsgInfo

Begin Sequence

	IF ( OrgExistCut( aCopyTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	+ CRLF + CRLF	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += STR0040	+ CRLF + CRLF	//"N└o ┌ possivel recortar informa┤└o(■es) de ║tem(ns) copiados.' 
		cMsgInfo += STR0021					//'A opera┤└o nao ser═ efetuada.'
		Break
	EndIF

	oTree:TreeSeek( cCargo )

	DEFAULT cRes1ChgCut := "EXCLUIR"
	DEFAULT cRes2ChgCut := "EXCLUIR"

	OrgTreeCut(	@oTree			,;
				@aTreeNodes		,;
				@aCutTreeNodes	,;
				@aMenuPopUp		,;
				@nIndEnable		,;
				@bMenuVldCut 	,;
				@lCut			,;
				@cRes1ChgCut	,;
				@cRes2ChgCut	 ;
			  )

End Sequence

IF !Empty( cMsgInfo )
	MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) /*/'Aten┤└o!'*/ )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeCut	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRecortar Informacoes do Tree                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeCut(	oTree			,;
							aTreeNodes		,;
							aCutTreeNodes	,;
							aMenuPopUp		,;
							nIndEnable		,;
							bMenuVldCut 	,;
							lCut			,;
							cRes1ChgCut		,;
							cRes2ChgCut		 ;
						  )

	Local aLogGer		:= {}
	Local aLogGerTitle	:= {}
	Local cCargo       	:= oTree:GetCargo()
	Local cGrupoCut		:= SubStr( cCargo , 3 )
	
	Local cMsgInfo
	
	oTree:lVisibleControl := .F.	//:Hide()
	
	Begin Sequence

		IF ( "*-" $ cCargo )
			MsgInfo( OemToAnsi( STR0044 ) )	//"Este Item NЦo Pode Ser Recortado e Nem Copiado" 
			Break
		EndIF

		IF ( lCut )
			IF (;
					!( OrgTreeCkExc(	aTreeNodes		,;
										cGrupoCut		,;
										bMenuVldCut 	,;
										@aLogGer		,;
										@aLogGerTitle	 ;
								    );
					 );
				)
				Break
			EndIF
		Else
			IF Empty( aCutTreeNodes )
				Break
			EndIF
			IF !( OrgChkUnCut( aCutTreeNodes , cGrupoCut ) )
				cMsgInfo	:= STR0030	//'Este ║tem n└o pode ser "Desmarcado".
				cMsgInfo	+= CRLF + CRLF
				cMsgInfo	+= STR0031	//'Desmarque a partir do(s) ║tem(ns) superiores que est└o "Marcados" para serem recortados."
				MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) ) //'Aten┤└o!'
				Break
			EndIF
		EndIF

		oTree:TreeSeek( cCargo )

		OrgTreeGrCut( @oTree , @aTreeNodes , @aCutTreeNodes , cGrupoCut , lCut , NIL , cRes1ChgCut , cRes2ChgCut )

		oTree:TreeSeek( cCargo )
	
		aMenuPopUp[ nIndEnable  , 03 ] := !Empty( aCutTreeNodes )

	End Sequence

	oTree:lVisibleControl := .T.	//:Show()
	
	IF ( !Empty( aLogGer ) )
		CursorArrow()
		//'Este Grupo/Sub-Grupo nЦo pode ser Excluido. Deseja visualizar o Log?'###*'Aten┤└o!'
		IF ( MsgNoYes( OemToAnsi( STR0033 ) , OemToAnsi( STR0007 ) ) ) 
			CursorWait()
			//'Log de Inconsistencia na Exclusao de Grupo/Sub-Grupo'
			fMakeLog( aLogGer , aLogGerTitle , NIL , NIL , FunName() , STR0012 )
		EndIF
	EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeGrCut ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAdiciona o Item e Sub-Itens que foram recortados            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeGrCut(	oTree			,;
								aTreeNodes		,;
								aCutTreeNodes	,;
								cGrupoCut		,;
								lCut			,;
								lChangeBmp		,;
								cRes1ChgCut		,;
								cRes2ChgCut		 ;
							)

Local aNodesAux
Local lForceAddNew
Local nLoop
Local nLoops
Local nLoop1
Local nLoops1

DEFAULT lChangeBmp := .T.

Begin Sequence
    
	nLoops := Len( aTreeNodes )
	For nLoop := 1 To nLoops
		IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
			IF ( aTreeNodes[ nLoop , NODE_INFERIOR ] == cGrupoCut )
				IF ( lChangeBmp )
					oTree:TreeSeek( ( "+-" + cGrupoCut ) )
				EndIF
				
				IF ( lCut )
					IF ( OrgExistCut( aCutTreeNodes , cGrupoCut ) )
						DelTreeNodes( @aCutTreeNodes , cGrupoCut , .T. )
					EndIF
					
					IF ( lChangeBmp )
						oTree:ChangeBmp( cRes1ChgCut , cRes2ChgCut )
					EndIF
					
					lForceAddNew := !( OrgExistCut( aCutTreeNodes , aTreeNodes[ nLoop , NODE_SUPERIOR ] ) )
					BldTreeNodes(	@aCutTreeNodes,;
									aTreeNodes[ nLoop , NODE_SUPERIOR	],;
									aTreeNodes[ nLoop , NODE_INFERIOR	],;
									aTreeNodes[ nLoop , NODE_PROMPT 	],;
									aTreeNodes[ nLoop , NODE_ACOLS		],;
									aTreeNodes[ nLoop , NODE_RESOURCE1	],;
									aTreeNodes[ nLoop , NODE_RESOURCE2	],;
									lForceAddNew,;
									aTreeNodes[ nLoop , NODE_RECNO		];
								)
				Else
					DelTreeNodes( @aCutTreeNodes , cGrupoCut , .T. )
					IF ( lChangeBmp )
						oTree:ChangeBmp( aTreeNodes[ nLoop , NODE_RESOURCE1	] , aTreeNodes[ nLoop , NODE_RESOURCE2 ] )
					EndIF
				EndIF
				aNodesAux := aTreeNodes[ nLoop , NODE_TREE ]
				nLoops1 := Len( aNodesAux )
				For nLoop1 := 1 To nLoops1
					cGrupoCut := aNodesAux[ nLoop1 , NODE_INFERIOR ]
					OrgTreeGrCut( @oTree , aNodesAux , @aCutTreeNodes , cGrupoCut , lCut , lChangeBmp , cRes1ChgCut , cRes2ChgCut )
				Next nLoop1
				Exit	
			Else
				aNodesAux := aTreeNodes[ nLoop , NODE_TREE ]
				OrgTreeGrCut( @oTree , aNodesAux , @aCutTreeNodes , cGrupoCut , lCut , lChangeBmp , cRes1ChgCut , cRes2ChgCut )
			EndIF
		EndIF
	Next nLoop

End Sequence

Return

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgChkUnCut  ЁAutorЁMarinaldo de Jesus    Ё Data Ё05/01/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Pode Desmarcar o Node                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgChkUnCut( aCutTreeNodes , cNodeUnCut )

Local lChkUnCutOk := .T.

IF ( NodeExtSup( aCutTreeNodes , @cNodeUnCut ) )
	lChkUnCutOk := !( OrgExistCut( aCutTreeNodes , cNodeUnCut ) )
EndIF

Return( lChkUnCutOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgPstRecTreeЁAutorЁMarinaldo de Jesus    Ё Data Ё26/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁColar Informacoes no Tree                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgPstRecTree(	oTree 			,;
								aTreeNodes		,;
								aCutTreeNodes	,;
								aMenuPopUp		,;
								nIndDisable		,;
								lTreePstExc		,;
								aCopyTreeNodes	,;
								nIncOption		 ;
					  	  	)

Local cCargo
Local cGrpSup
Local cMsgInfo

Local nLoop
Local nLoops

Begin Sequence

	IF ( ( nLoops := Len( aCutTreeNodes ) ) == 0 )
		Break
	EndIF

	cCargo		:= oTree:GetCargo()
	cGrpSup		:= SubStr( cCargo , 3 )

	IF ( OrgExistCut( aCutTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0020	//'N└o ┌ possivel colar informa┤└o(■es) sobre ║tem(ns) recortados.' 
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//'A opera┤└o nao ser═ efetuada.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0022	//'Selecione outro n║vel para colar a(s) informa┤└o(■es).'
		Break
	EndIF

	IF ( OrgExistCut( aCopyTreeNodes , cGrpSup ) )
		cMsgInfo := STR0019	//'Aviso de Inconsist┬ncia!'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0038	//'N└o ┌ possivel colar informa┤└o(■es) sobre ║tem(ns) copiados.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//'A opera┤└o nao ser═ efetuada.'
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0022	//'Selecione outro n║vel para colar a(s) informa┤└o(■es).'
		Break
	EndIF

	aNewNodes	:= aClone( aCutTreeNodes )
	CursorWait()
		OrgChgInfValue( @aNewNodes , { | aNewNodes , nLoop | aNewNodes[ nLoop , NODE_SEQ ] } )
		IF !ArrayCompare( aNewNodes , aCutTreeNodes )
			OrgPstExc( @oTree , @aTreeNodes , aCutTreeNodes )
		EndIF
	CursorArrow()

	oTree:TreeSeek( cCargo )
	OrgTreePst(	@oTree , @aTreeNodes , @aNewNodes , @aMenuPopUp , @nIndDisable , @lTreePstExc , @nIncOption )

	aCutTreeNodes	:= {}
	ClsCutTreeNodes()

End Sequence

IF !Empty( cMsgInfo )
	MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0007 ) /*/'Aten┤└o!'*/ )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreePst	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁColar Informacoes no Tree                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreePst(	oTree 			,;
							aTreeNodes		,;
							aCutTreeNodes	,;
							aMenuPopUp		,;
							nIndDisable		,;
							lTreePstExc		,;
							nIncOption		 ;
					  	  )

Local cCargo		:= oTree:GetCargo()
Local cGrpSup		:= SubStr( cCargo , 3 )

Local bIncOption
Local cPstCargo
Local lMaster
Local lTreeSeek
Local nLoop
Local nLoops

Begin Sequence

	IF ( ( nLoops := Len( aCutTreeNodes ) ) == 0 )
		Break
	EndIF

	lMaster		:= ( "*-" $ cCargo )
	bIncOption	:= { ||;
							IF( ( lMaster ),;
								2,;	//Sempre um Nivel Abaixo
								IF( ( nIncOption == NIL ) ,;
									Aviso(;
											OemToAnsi( STR0013 ),;	//'Inclus└o de novo ║tem'
											OemToAnsi( STR0014 ),;	//'Selecione o n║vel'
											{;
												OemToAnsi( "&"+STR0015 ),;	//'Novo Item'
												OemToAnsi( "&"+STR0016 );	//'Sub-Item'
											};
										 ),;
									nIncOption;
								  );
							   );
					}
	nIncOption	:= Eval( bIncOption )

	oTree:lVisibleControl := .F.	//:Hide()

		CursorWait()

			DEFAULT lTreePstExc := .T.
			IF ( lTreePstExc )
				OrgPstExc( @oTree , @aTreeNodes , aCutTreeNodes )
			EndIF
	
			oTree:TreeSeek( cCargo )

			lTreeSeek := .T.
			IF (;
					!( lMaster );
					.and.;
					( nIncOption == 1 );
				)
				IF ( lTreeSeek := !( NodeExtSup( aTreeNodes , @cGrpSup ) ) )
					nIncOption := 2
				EndIF
			EndIF

			cPstCargo	:= CutSub2NextPst( @oTree , @aTreeNodes , @aCutTreeNodes , nIncOption )

			OrgPstTree( @oTree , @aTreeNodes , aCutTreeNodes , cGrpSup , nIncOption , lTreeSeek )

			IF !Empty( cPstCargo )
				oTree:TreeSeek( cPstCargo )
			EndIF

			IF (;
					( lTreeSeek );
					.and.;
					( nIncOption == 2 );
				)
				oTree:TreeSeek( cCargo )
			EndIF

			oTree:Refresh()

			aMenuPopUp[ nIndDisable , 03 ] := .F.
	
		CursorArrow()

	oTree:lVisibleControl := .T.	//:Show()

End Sequence

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁCutSub2NextPstЁAutorЁMarinaldo de Jesus   Ё Data Ё20/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRecorta os Itens Posteriores para que o item ser inserido enЁ
Ё          Ёtre um e outro e retorna-os na ordem em que foram recortadosЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁOrgTreePst() em ORGXTREE                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function CutSub2NextPst( oTree , aTreeNodes , aCutTreeNodes , nIncOption )

Local aSvCutTreeNodes
Local aNodeGetSub
Local cPstCargo
Local cAuxCargo

Local nLoop
Local nLoops

IF ( nIncOption == 1 ) //Mesmo Nivel
	cPstCargo 		:= oTree:GetCargo()
	aSvCutTreeNodes	:= aClone( aCutTreeNodes )
	IF ( SuperGetMv( "MV_SUPCTSB" , NIL , "N" ) == "S" )
		SuperCutSub2NextPst( @oTree , @aTreeNodes , @aCutTreeNodes , cPstCargo )
	Else
		cAuxCargo		:= SubStr( cPstCargo , 3 )
		aNodeGetSub		:= NodeGetSub( aTreeNodes , NodeGetSup( aTreeNodes , cAuxCargo ) )
		nLoop			:= ( aScan( aNodeGetSub , { |x| ( x[1] == cAuxCargo ) } ) + 1 )
		nLoops			:= Len( aNodeGetSub )
		For nLoop := nLoop To nLoops
			OrgTreeGrCut( @oTree , @aTreeNodes , @aCutTreeNodes , aNodeGetSub[ nLoop , 1 ] , .T. , .F. )
		Next nLoop
	EndIF
	IF !ArrayCompare( aSvCutTreeNodes , aCutTreeNodes )
		OrgPstExc( @oTree , @aTreeNodes , aCutTreeNodes )
	EndIF
	oTree:TreeSeek( cPstCargo )
EndIF

Return( cPstCargo )

/*/
зддддддддддбдддддддддддддддддддбдддддбддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁSuperCutSub2NextPstЁAutorЁMarinaldo de JesusЁDataЁ20/08/2004Ё
цддддддддддедддддддддддддддддддадддддаддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁEfetua o mesmo processo que a CutSub2NextPst() mas e mais raЁ
Ё          Ёpida														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁCutSub2NextPst() em OrgTreePst() em ORGXTREE                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function SuperCutSub2NextPst( oTree , aTreeNodes , aCutTreeNodes , cPstCargo )

Local cAlias		:= oTree:cArqTree

Local cT_IdTree
Local cT_Cargo
Local nNextRecno
Local nOrder
Local nSvOrder

cT_IdTree	:= ( cAlias )->( T_IDTREE )
nOrder		:= 2 //T_IDTREE
nSvOrder	:= ( cAlias )->( IndexOrd() )
( cAlias )->( dbSetorder( nOrder ) )
( cAlias )->( dbSkip() )
While (;
			( cAlias )->(;
							!Eof();
							.and.;
							( T_IDTREE == cT_IdTree );
						 );
		)				 
	IF !GetNextRecno( cAlias , @nNextRecno , NIL , nOrder )
		Exit
	EndIF
	cT_Cargo := SubStr( ( cAlias )->( T_CARGO ) , 3 )
	OrgTreeGrCut( @oTree , @aTreeNodes , @aCutTreeNodes , cT_Cargo , .T. , .F. )
	IF !GotoNextRecno( cAlias , nNextRecno , nOrder )
		Exit
	EndIF
End While

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgExistCut   ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Ja Existe o Elemento Recortado                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgExistCut( aCutTreeNodes , cItem )
   
Local lExistCut := .F.

Local nLoop
Local nLoops

nLoops := Len( aCutTreeNodes )
For nLoop := 1 To nLoops 
	IF ( aCutTreeNodes[ nLoop , NODE_ACTIVE ] )
		IF ( lExistCut := ( aCutTreeNodes[ nLoop , NODE_INFERIOR ] == cItem ) )
			Exit
		Else
			IF ( lExistCut := OrgExistCut( aCutTreeNodes[ nLoop , NODE_TREE ] , cItem ) )
				Exit
			EndIF
		EndIF
	EndIF
Next nLoop

Return( lExistCut )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgPstExc     ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁExclui os Elementos antes de efetuar o Past					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgPstExc( oTree , aTreeNodes , aCutTreeNodes )	

Local cTreeSeek
Local nLoop
Local nLoops

nLoops := Len( aCutTreeNodes )
For nLoop := 1 To nLoops
	IF ( aCutTreeNodes[ nLoop , NODE_ACTIVE ] )
		cTreeSeek := aCutTreeNodes[ nLoop , NODE_INFERIOR ]
		IF ( oTree:TreeSeek( "+-" + cTreeSeek ) )
			OrgTreeExc( @oTree , @aTreeNodes ,  { || .T. } , .T. )
		EndIF
		OrgPstExc( @oTree , @aTreeNodes , aCutTreeNodes[ nLoop , NODE_TREE ] )
	EndIF
Next nLoop

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgPstTree    ЁAutorЁMarinaldo de Jesus   Ё Data Ё01/01/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁEfetua o Past do Node                  						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgPstTree( oTree 			,;
							aTreeNodes		,;
							aCutTreeNodes	,;
							cGrpSup			,;
							nIncOption		,;
							lTreeSeek		 ;
						  )

Local aCols

Local cNewInc
Local cDesc
Local cAddItem
Local cResource1
Local cResource2

Local nRecno
Local nLoop
Local nLoops

DEFAULT lTreeSeek	:= .T.

IF ( lTreeSeek )
	oTree:TreeSeek( ( "+-" + cGrpSup ) )
EndIF
nLoops := Len( aCutTreeNodes )
For nLoop := 1 To nLoops
	IF ( aCutTreeNodes[ nLoop , NODE_ACTIVE ] )
		cNewInc 	:= aCutTreeNodes[ nLoop , NODE_INFERIOR 	]
		cDesc		:= aCutTreeNodes[ nLoop , NODE_PROMPT		]
		aCols		:= aCutTreeNodes[ nLoop , NODE_ACOLS		]
		cResource1	:= aCutTreeNodes[ nLoop , NODE_RESOURCE1	]
		cResource2	:= aCutTreeNodes[ nLoop , NODE_RESOURCE2	]
		nRecno		:= aCutTreeNodes[ nLoop , NODE_RECNO		]
		cAddItem	:= ( "+-" + cNewInc )
		DEFAULT cResource1	:= "PMSTASK1"
		DEFAULT cResource2	:= "PMSTASK2"
		oTree:AddItem( cDesc , cAddItem , cResource1 , cResource2 , NIL , NIL , nIncOption )
		BldTreeNodes( @aTreeNodes , cGrpSup , cNewInc , cDesc , aCols , cResource1 , cResource2 , .F. , nRecno )
		IF ( Len( aCutTreeNodes[ nLoop , NODE_TREE ] ) > 0 )
			OrgPstTree(	@oTree													,;
						@aTreeNodes 											,;
						aCutTreeNodes[ nLoop , NODE_TREE ] 						,;
						aCutTreeNodes[ nLoop , NODE_TREE , 01 , NODE_SUPERIOR ]	,;
						2														,;
						.T.														 ;	
					  )
		Else
			oTree:TreeSeek( cAddItem )
		EndIF
		IF ( lTreeSeek )
			oTree:TreeSeek( ( "+-" + cGrpSup ) )
		EndIF
	EndIF
Next nLoop

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeMenu  ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁHabilitar e Desabilitar as Opcoes do Menu                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeMenu( oTree , oMenu , nX , nY , aMenuPopUp )

Local nMenu
Local nMenus
Local aDiff

DEFAULT aMenuPopUp	:= {}

IF ( ValType( oMenu ) == "O" )

	aEval( oMenu:aItems, { |o| o:Disable() } )
	
	cCargo := oTree:GetCargo()

	nMenus := Len( aMenuPopUp )
	IF ( Left( cCargo , 1 ) == "+" )
		For nMenu := 1 To nMenus
			IF ( aMenuPopUp[ nMenu , 3 ] )
				oMenu:aItems[nMenu]:Enable()
			EndIF
		Next nMenu
	ElseIF ( Left( cCargo, 1 ) == "*" )
		IF (;
				( nMenus >= 3 );
				.and.;
				( aMenuPopUp[ 3 , 3 ] );
			)
			oMenu:aItems[ 3 ]:Enable()
		EndIF
		IF (;
				( nMenus >= 4 );
				.and.;
				( aMenuPopUp[ 4 , 3 ] );
			)
			oMenu:aItems[ 4 ]:Enable()
		EndIF
	EndIF
		
	IF (;
			( nMenus >= 1 );
			.and.;
			( aMenuPopUp[ 1 , 3 ] );
		)
		oMenu:aItems[1]:Enable()
	EndIF
	
	aDiff:= GetDiffPosition(oTree)
	
	oMenu:Activate( nX - aDiff[1] , nY - aDiff[2], oTree:oWnd)
EndIF
	
Return( NIL )

Function GetDiffPosition(oTree)
	Local oTemp:= oTree
	Local nXDiff:= oTemp:nLeft
	Local nYDiff:= oTemp:nTop
               
	While oTemp:oParent != oTree:oWnd
		oTemp:= oTemp:oParent
		
		nXDiff+= oTemp:nLeft
		nYDiff+= oTree:nTop
	EndDo          
                                   
Return {nXDiff, nYDiff}
/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeGrv	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGrava as Informacoes do Tree                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeGrv(	aTreeNodes		,;
							aLstMainTree	,;
							cdbTreeAlias	,;
							bFilField		,;
							bCodField		,;
							bItemField		,;
							bTreeField		,;
							bDescField		,;
							cFilFather		,;
							cKeyFather		,;
							nItemOrder		 ;
						  )

Local cGrpBranco := Space( Len( Eval( bTreeField ) ) )

Local cIndexKey
Local lOrgTreeGrv

Begin Sequence

	IF !( lOrgTreeGrv := !ArrayCompare( aTreeNodes , aLstMainTree ) )
		Break
	EndIF

	Begin Transaction
		( cdbTreeAlias )->( dbSetOrder( nItemOrder ) )
		cIndexKey := ( cdbTreeAlias )->( IndexKey() )
		OrgExcSup(	aTreeNodes		,;
					cdbTreeAlias	,;
					bTreeField		,;
					cFilFather		,;
					cKeyFather		,;
					cIndexKey		,;
					cGrpBranco		 ;
				 )
		OrgGrvSup(	aTreeNodes		,;
					cdbTreeAlias	,;
					bFilField		,;
					bCodField		,;
					bItemField		,;
					bTreeField		,;
					bDescField		,;
					cFilFather		,;
					cKeyFather		 ;
				)
	End Transaction

End Sequence

Return( lOrgTreeGrv )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgExcSup	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё01/01/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁElimina os Grupos Superiores								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgExcSup(	aTreeNodes 		,;
							cdbTreeAlias	,;
							bTreeField		,;
							cFilFather		,;
							cKeyFather		,;
							cIndexKey		,;
							cGrpBranco		 ;
						 )

Local cFilTreeAlias := xFilial( cdbTreeAlias , cFilFather )
Local cKeySeek		:= ( cFilTreeAlias + cKeyFather )

Local cGrupoExc
Local cItemSeekKey
Local nLoop
Local nLoops
Local nSizeKey

nLoops := Len( aTreeNodes )
For nLoop := 1 To nLoops
	IF ( !( aTreeNodes[ nLoop , NODE_ACTIVE ] ) )
		cGrupoExc		:= aTreeNodes[ nLoop , NODE_INFERIOR ]
		cItemSeekKey	:= ( cdbTreeAlias )->( cKeySeek + cGrupoExc )
		nSizeKey		:= Len( cItemSeekKey )
		IF ( ( cdbTreeAlias )->( MsSeek( cItemSeekKey , .F. ) ) )
			While (;
						( cdbTreeAlias )->(;
												!Eof();
												.and.;
												( SubStr( __ExecMacro( cIndexKey ) , 1 , nSizeKey ) == cItemSeekKey );
										   );
				  )												   
				IF ( cdbTreeAlias )->( RecLock( cdbTreeAlias , .F. ) )
					( cdbTreeAlias )->( Eval( bTreeField , cGrpBranco ) )
					( cdbTreeAlias )->( MsUnLock() )
				EndIF
				( cdbTreeAlias )->( dbSkip() )
			End While
		EndIF
	EndIF
	OrgExcSup(	aTreeNodes[ nLoop , NODE_TREE ] ,;
				cdbTreeAlias					,;
				bTreeField						,;
				cFilFather						,;
				cKeyFather						,;
				cIndexKey						,;
				cGrpBranco						 ;
			 )
Next nLoop

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgGrvSup	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё01/01/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGrava os Grupos Superiores									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgGrvSup(	aTreeNodes		,;
							cdbTreeAlias	,;
							bFilField		,;
							bCodField		,;
							bItemField		,;
							bTreeField		,;
							bDescField		,;
							cFilFather		,;
							cKeyFather		 ;
						)
	Local cFilTreeAlias := xFilial( cdbTreeAlias , cFilFather )
	Local cKeySeek		:= ( cFilTreeAlias + cKeyFather )
	Local lExecAddNew	:= ( ( bFilField <> NIL ) .and. ( bCodField <> NIL ) )
	Local cMaster		:= Replicate( "0" , Len( ( cdbTreeAlias )->( Eval( bTreeField ) ) ) )	
	Local cItem
	Local cTree
	Local cDesc
	Local lAddNew
	Local nLoop
	Local nLoops:= Len( aTreeNodes )
	
	For nLoop := 1 To nLoops
		IF ( aTreeNodes[ nLoop , NODE_ACTIVE ] )
			cItem := aTreeNodes[ nLoop , NODE_INFERIOR ]
			IF ( cItem <> cMaster )
				lAddNew := ( cdbTreeAlias )->( !MsSeek( cKeySeek + cItem , .F. ) )
				IF (;
						( lAddNew );
						.and.;
						!( lExecAddNew );
					)	
					Loop
				EndIF
				IF ( cdbTreeAlias )->( RecLock( cdbTreeAlias , lAddNew ) )
					IF ( lAddNew )
						cDesc := aTreeNodes[ nLoop , NODE_PROMPT ]
						( cdbTreeAlias )->( Eval( bFilField  , cFilTreeAlias	) )
						( cdbTreeAlias )->( Eval( bCodField  , cKeyFather		) )
						( cdbTreeAlias )->( Eval( bItemField , cItem			) )
						( cdbTreeAlias )->( Eval( bDescField , cDesc			) )
					EndIF
					cTree := aTreeNodes[ nLoop , NODE_SUPERIOR ]
					( cdbTreeAlias )->( Eval( bTreeField , cTree ) )
					( cdbTreeAlias )->( MsUnLock() )
				EndIF
			EndIF
		EndIF
		
		OrgGrvSup(	aTreeNodes[ nLoop , NODE_TREE ]	,;
					cdbTreeAlias					,;
					bFilField						,;
					bCodField						,;
					bItemField						,;
					bTreeField						,;
					bDescField						,;
					cFilFather						,;
					cKeyFather		 				 ;
				)
	Next nLoop
	
Return

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁOrgTreeBar   ЁAutorЁMarinaldo de Jesus    Ё Data Ё18/06/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁBarra do Tree ( Equivalente a EnchoiceBar )                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁORGXTREE 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function OrgTreeBar(	oDlg			,;	//Objeto Dialog
							lTudoOk			,;	//Tudo Ok por Referencia
							oEnchoice		,;	//Objeto Enchoice
							oGetDados		,;	//Objeto GetDados (New)
							aCols			,;	//aCols
							aButtons		,;	//aButtons
							bTreeOk			,;	//Bloco Tudo Ok para o Tree
							lExecValid		,;	//Se deve Executar os Valids
							bTrfaCols		 ;	//Bloco Para Transferencia de Informacoes do aCols
						)
	Local bGdOk			:= { || .T. }
	Local bEnOk			:= { || .T. }
	Local bOk			:= { || oDlg:End() }
	Local bCancel		:= { || oDlg:End() }
	Local lGdIsObject	:= ( ValType( oGetDados ) == "O" )
	Local lEnIsObject	:= ( ValType( oEnchoice ) == "O" )
	
	DEFAULT lTudoOk		:= .F.
	DEFAULT aCols		:= {}
	DEFAULT aButtons	:= {}
	DEFAULT bTreeOk		:= { || .T. }
	DEFAULT lExecValid	:= .T.
	DEFAULT bTrfaCols	:= { || aCols := oGetDados:aCols }
	
	IF ( lExecValid )
		bGdOk	:= { || ( !( lGdIsObject ) .or. oGetDados:TudoOk() ) }
		bEnOk	:= { || ( !( lEnIsObject ) .or. EnchoTudOk( oEnchoice ) ) }
		bOk		:= { |lGdOk,lEnOk,lTreeOk|;
						lGdOk	:= Eval( bGdOk )	,;
						lEnOk	:= Eval( bEnOk )	,;
						lTreeOk := Eval( bTreeOk )	,;
						lTudoOk := ( ( lGdOk ) .and. ( lEnOk ) .and. ( lTreeOk ) ),;
						IF( ( lTudoOk ) , (;
												IF( lGdIsObject , Eval( bTrfaCols ) , NIL ),;
												oDlg:End();
						  			  	   ),;
				 						  NIL;
				 		  );
				   }
		bCancel	:= { || ( lTudoOk := .F. ) , oDlg:End() }
	EndIF
	
Return EnchoiceBar( oDlg , bOK , bCancel , NIL , aButtons )


  
Function OrgTreeRevoke(oTree)
	Local aNode, aNodeMaster
	Local cCargo:= oTree:GetCargo()
	Local lInherited:= .F.
	Local nResource:= REVOKE

	BEGIN SEQUENCE
		IF ( "*-" $ cCargo )
			MsgInfo("Este item nao pode ser alterado.")
			Break
		EndIF
		
		aNode:= OrgFindNode(SubStr(cCargo, 3))

		IF aNode[NODE_RESOURCE1] == PERMISSION[CHILD_GRANT] .OR.;
		   aNode[NODE_RESOURCE1] == PERMISSION[CHILD_DENY]
			MsgInfo("Nao И possivel remover a permissao pois ela esta sendo herdada.")
			BREAK
		EndIf		

		IF aNode[NODE_RESOURCE1] == PERMISSION[MASTER_GRANT] .OR.;
		   aNode[NODE_RESOURCE1] == PERMISSION[MASTER_DENY]
		   lInherited:= .T.
		EndIf
		
		aNodeMaster:= OrgFindNode(aNode[NODE_SUPERIOR])
			    
		If aNodeMaster != NIL
			While aNodeMaster[NODE_INFERIOR] != aNodeMaster[NODE_SUPERIOR]
				Do Case
					Case aNodeMaster[NODE_RESOURCE1] == PERMISSION[MASTER_GRANT]
				        nResource:= CHILD_GRANT	
					Case aNodeMaster[NODE_RESOURCE1] == PERMISSION[MASTER_DENY]
				        nResource:= CHILD_DENY
				 	Otherwise
						aNodeMaster:= OrgFindNode(aNodeMaster[NODE_SUPERIOR])
						Loop
				End Case
					
				Exit
	    	EndDo
		EndIf
		
		OrgChangePermission(@oTree, NIL, nResource, lInherited)
	END SEQUENCE

Return



Function OrgTreeGrant(oTree, lInherited)
	Local aNode
	Local nResource:= IIf(lInherited, MASTER_GRANT, GRANT)
	Local cCargo:= oTree:GetCargo()
	
	
	BEGIN SEQUENCE
		IF ( "*-" $ cCargo )
			MsgInfo("Este item nao pode ser alterado.")
			Break
		EndIF
		
		aNode:= OrgFindNode(SubStr(cCargo, 3))

		IF aNode[NODE_RESOURCE1] == PERMISSION[CHILD_DENY]
			MsgInfo("Nao И possivel conceder a permissao pois ela esta sendo negada por heranГa.")
			BREAK
		EndIf
		
		IF aNode[NODE_RESOURCE1] == PERMISSION[CHILD_GRANT]
			MsgInfo("Nao И possivel conceder a permissao pois ela jА esta sendo concedida por heranГa.")
			BREAK
		EndIf
        
		IF aNode[NODE_RESOURCE1] == PERMISSION[MASTER_DENY]	 .OR.;
		   aNode[NODE_RESOURCE1] == PERMISSION[MASTER_GRANT]	
			lInherited:= .T.
		EndIf
		
		OrgChangePermission(@oTree, NIL, nResource, lInherited)
	END SEQUENCE
Return



Function OrgTreeDeny(oTree, lInherited)
	Local aNode
	Local nResource:= IIf(lInherited, MASTER_DENY, DENY)
	Local cCargo:= oTree:GetCargo()


	BEGIN SEQUENCE
		IF ( "*-" $ cCargo )
			MsgInfo("Este item nao pode ser alterado.")
			Break
		EndIF

		aNode:= OrgFindNode(SubStr(cCargo, 3))

		IF aNode[NODE_RESOURCE1] == PERMISSION[CHILD_DENY]
			MsgInfo("Nao И possivel negar a permissao pois ela jА esta sendo negada por heranГa.")
			BREAK
		EndIf
		
		IF aNode[NODE_RESOURCE1] == PERMISSION[MASTER_DENY]	 .OR.;
		   aNode[NODE_RESOURCE1] == PERMISSION[MASTER_GRANT]	
			lInherited:= .T.
		EndIf

		OrgChangePermission(@oTree, NIL, nResource, lInherited)
	END SEQUENCE		
Return


Static Function OrgFindNode(cCargo, aNodes)
	Local nCount
	Local aTemp
	Default aNodes:= OrgGetTreeNodes()
	
	For nCount:= 1 to Len(aNodes)
		If cCargo == aNodes[nCount, NODE_INFERIOR]
			aTemp:= aNodes[nCount]
		Else
			aTemp:= OrgFindNode(@cCargo, aNodes[nCount, NODE_TREE])
		EndIf
	         
		If aTemp != NIL; Exit; EndIf
	Next
Return aTemp



Static Function OrgChildNodes(cCargo, aNodes)
	Local nCount
	Local aTemp
	Default aNodes:= OrgGetTreeNodes()
	
	For nCount:= 1 to Len(aNodes)
		If cCargo == aNodes[nCount, NODE_INFERIOR]
			aTemp:= aNodes[nCount, NODE_TREE]
		Else
			aTemp:= OrgChildNodes(@oTree, cCargo, aNodes[nCount, NODE_TREE])
		EndIf
	         
		If aTemp != NIL; Exit; EndIf
	Next
Return aTemp



Function OrgChangePermission(	oTree		,;
								aTreeNodes	,;
								nResource	,;
								lInherit	;
							  )
	Local cCargo       	:= oTree:GetCargo()
	Local cGrupoCut		:= SubStr(cCargo , 3 )
	Default aTreeNodes:= OrgGetTreeNodes()
	
	//oTree:lVisibleControl := .F.
	
	Begin Sequence
		/// Validar operacao aqui
		
		oTree:TreeSeek( cCargo )

		OrgTreePermission(	@oTree,;
							@aTreeNodes,;
							cGrupoCut,;
							nResource,;
							lInherit)

		oTree:TreeSeek( cCargo )
	
		//aMenuPopUp[ nIndEnable  , 03 ] := !Empty( aCutTreeNodes )
	End Sequence

	//oTree:lVisibleControl := .T.
	//oTree:SetFocus()
Return




Static Function OrgTreePermission(	oTree		,;
									aTreeNodes	,;
									cGrupoCut	,;
									nResource	,;
									lInherit	,;
									lOnlyChild	;
								)

	Local aNodesAux
	Local nLoop
	Local nLoop1
	Local nResChild
	Default lOnlyChild:= .F.
	
	BEGIN SEQUENCE
		If lInherit
			DO CASE
				CASE nResource == MASTER_GRANT .OR. nResource == CHILD_GRANT
			        nResChild:= CHILD_GRANT
				CASE nResource == MASTER_DENY .OR. nResource == CHILD_DENY
			        nResChild:= CHILD_DENY
			 	OTHERWISE
					nResChild:= REVOKE
			END CASE
		EndIf

		For nLoop := 1 To Len(aTreeNodes)
			IF (aTreeNodes[nLoop, NODE_ACTIVE] )
				IF ( aTreeNodes[ nLoop , NODE_INFERIOR ] == cGrupoCut )
					If !lOnlyChild
						oTree:TreeSeek("+-" + cGrupoCut)
						oTree:ChangeBmp(PERMISSION[nResource], PERMISSION[nResource])
					
						aTreeNodes[nLoop, NODE_RESOURCE1]:= PERMISSION[nResource]
						aTreeNodes[nLoop, NODE_RESOURCE2]:= PERMISSION[nResource]
					
					
						BldTreeNodes(	{},;
										aTreeNodes[nLoop, NODE_SUPERIOR],;
										aTreeNodes[nLoop, NODE_INFERIOR],;
										aTreeNodes[nLoop, NODE_PROMPT],;
										aTreeNodes[nLoop, NODE_ACOLS],;
										aTreeNodes[nLoop, NODE_RESOURCE1],;
										aTreeNodes[nLoop, NODE_RESOURCE2],;
										.F.,;
										aTreeNodes[nLoop, NODE_RECNO];
									)
					EndIf
					
					If lInherit
						aNodesAux := aTreeNodes[nLoop, NODE_TREE]
		
						For nLoop1 := 1 To Len(aNodesAux)
							lOnlyChild:= .F.
							
							If (nResChild == REVOKE .AND.;
						       (aNodesAux[nLoop1, NODE_RESOURCE1] == PERMISSION[MASTER_DENY] .OR.;
							    aNodesAux[nLoop1, NODE_RESOURCE1] == PERMISSION[MASTER_GRANT]) ) .OR.;
							   (nResChild == CHILD_GRANT .AND.;
							    aNodesAux[nLoop1, NODE_RESOURCE1] == PERMISSION[MASTER_DENY] )
								Loop
							EndIf										

							If (nResChild == REVOKE .AND.;
						       (aNodesAux[nLoop1, NODE_RESOURCE1] == PERMISSION[DENY] .OR.;
							    aNodesAux[nLoop1, NODE_RESOURCE1] == PERMISSION[GRANT]) ) .OR.;
							   (nResChild == CHILD_GRANT .AND.;
							    aNodesAux[nLoop1, NODE_RESOURCE1] == PERMISSION[DENY] )
							   lOnlyChild:= .T.			
							EndIF
							
							OrgTreePermission(@oTree, aNodesAux, aNodesAux[nLoop1 , NODE_INFERIOR], nResChild, lInherit, lOnlyChild)
						Next nLoop1
					EndIf
						
					Exit	
				Else
					OrgTreePermission( @oTree, aTreeNodes[nLoop, NODE_TREE], cGrupoCut, nResource, lInherit)
				EndIF
			EndIF                                                                    
		Next nLoop
	
	END SEQUENCE

RETURN

