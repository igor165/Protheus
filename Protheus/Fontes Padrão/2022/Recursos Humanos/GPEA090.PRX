#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEA1090.CH"
#INCLUDE "FONT.CH"
#INCLUDE "COLORS.CH"
#INCLUDE "HEADERGD.CH"
#Include 'fwmvcdef.ch'

Static lGP090CHK	:= ExistBlock("GP090CHK")
Static lGP090ALT	:= ExistBlock("GP090ALT")
Static lGP090Ok		:= ExistBlock("GP090OK")
Static lIntegDef	:= FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
Static __lMemCalc
Static lExibMsg   := .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GPEA090  ³ Autor ³ J.Ricardo                        ³ Data ³ 20.02.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cadastro Valores Variaveis                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador  ³ Data   ³ BOPS           ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr.  |29/10/12|    M12RH01     |Unificacao das folhas. Tratamento para    ³±±
±±³             |        | REQ.0008       |utilizacao de RGB no Brasil.              ³±±
±±³Esther V.    |22/04/14|    M_RH003     |Replica V11 para V12. Tratamento do para- ³±±
±±³             |        |                |metro MV_ITMCLVL para aceitar '3', nao    ³±±
±±³             |        |                |obrigando o preenchimento dos campos.     ³±±
±±³ Esther V.   |21/10/14|    TQWCM8      |Adicionada opcao 'Calcular Folha' no menu ³±±
±±³             |        |                |de 'Outras Acoes' nas telas de 'Incluir' e³±±
±±³             |        |                |'Alterar'. Criada a funcao fCalcLanc().   ³±±
±±³PHILIPE      |09/04/15|    TPPAI7      |Adicionadas as opções de Inclusão,Alteração±±
±±³POMPEU       |        |                |e Visualização de Lançamentos tabela RGB no±±
±±³             |        |                |menu Outras Opções. Criada função ChamaRGB.±±
±±³Gustavo M.   |08/06/15|    TSMXXC      |Ajuste para buscar o roteiro correto.     ³±±
±±³Allyson M.   |29/07/18|    TSXEG1      |Ajuste p/ nao obrigar o preenchimento da  ³±±
±±³             |        |                |data de pagamento (conceito da P11).      ³±±
±±³Allyson M.   |05/08/15|    TSUT35      |Ajuste na consulta padrao do roteiro      ³±±
±±³M.Camargo    |06/10/15|PDR_SER_MI001152|Ajuste periodo y num pago cuando se llama ³±±
±±³             |        |PCREQ-5930      |desde GPEM042.                            ³±±
±±³Allyson M.   |19/10/15|    TTJJCZ      |Ajuste p/ validar alteracao/exclusao de   ³±±
±±³             |        |                |verba gerada por outro roteiro.           ³±±
±±³Cecilia Carv.|03/12/15|PCDEF-86832     |Ajuste para nao permitir exclusao verba ge³±±
±±³             |        |                |rada pelo Ponto Eletronico.               ³±±
±±³Allyson M.   |15/01/16|    TUETN1      |Ajuste p/ validar exclusao de verba que   ³±±
±±³             |        |                |esta na SRC. 	 		 				 ³±±
±±³Flavio C.    |16/02/16|    TUHAQJ      |Ajuste p/ validar data de referencia de   ³±±
±±³             |        |                |acordo com a configuracao de RV_LCTODIA	 ³±±
±±³Renan Borges |17/02/16|    TTSRTF      |Ajuste para integrar os lançamentos mensa-³±±
±±³             |        |                |is corretamente, independentemente se o   ³±±
±±³             |        |                |funcionário já possui lançamentos.        ³±±
±±³Renan Borges |26/02/16|    TUMJG1      |Ajuste para integrar os lançamentos mensa-³±±
±±³             |        |                |is corretamente, independentemente se o   ³±±
±±³             |        |                |funcionário já possui lançamentos.        ³±±
±±³Gustavo M.   |13/03/16|    TUNXUL      |Ajuste para corrigir erro ao entrar via   ³±±
±±³             |        |                |rescisão nos lancaments.					 ³±±
±±³Renan Borges |15/03/16|    TUQZKS      |Ajuste para carregar registros na consulta³±±
±±³             |        |                |padrão do campo de periodo.               ³±±
±±³Renan Borges |28/04/16|    TUTJKP      |Ajuste para acessar a consulta de calculo ³±±
±±³             |        |                |corretamente mesmo que seja acessado pelo ³±±
±±³             |        |                |menu funcional.                           ³±±
±±³Raquel Hager |22/06/16|TVAIZA          |Remoção de opções de Manutenção/Cálculo   ³±±
±±³             |        |                |nas rotinas de consulta. Incluída função  ³±±
±±³             |        |                |Gp090Src para exclusão do cálculo caso    ³±±
±±³             |        |                |verba do tipo Informada seja deletada.    ³±±
±±³Raquel Hager |23/06/16|TVAIZA          |Ajuste no Protheus.Doc da função Gp090Src.³±±
±±³Renan Borges |23/06/16|TVMEVB          |Ajuste para não gerar o error.log  quando ³±±
±±³             |        |                |tentar incluir registro para funcionários ³±±
±±³             |        |                |que já possuem dados na RGB.              ³±±
±±³Raquel Hager |04/07/16|TVNUM0          |Ajuste para visualização dos dados da RGB ³±±
±±³             |        |                |na rotina de Consulta de Cálculos por Fun-³±±
±±³             |        |                |cionários. Ajuste para visualização dos   ³±±
±±³             |        |                |dados da SRC na rotina de Lançamentos por ³±±
±±³             |        |                |Funcionários. Correção na exclusão de ver-³±±
±±³             |        |                |ba informada e alerta para recalculo.     ³±±
±±³Raquel Hager |05/07/16|TVNUM0          |Correção de ajustes indevidos.            ³±±
±±³Gabriel A.   |28/07/16|TVDYO9          |Alteração na validação p/ mensagem ùnica. ³±±
±±³Esther V.    |17/08/16|     TVVHM2     |Ajuste na chamada do PE GP090OK.          ³±±
±±³             |        |                |Ajuste na validacao do campo RGB_DTREF.   ³±±
±±³Renan Borges |29/09/16|TWDTE6          |Ajuste para ao mudar de funcionário seja  ³±±
±±³             |        |                |calculado os valores corretos, independen-³±±
±±³             |        |                |temente da alteração de filial ou processo³±±
±±³Allyson M.   |26/10/16|TWHDNC      	  |Ajuste p/ não matar a atalho da tecla F6  ³±±
±±³             |        |                |quando rotina executada pelo GPEM040.	 ³±±
±±³M.Camargo    ³22/11/16|MMI-4222        |Ajustes Loc. Chile: Se anexa función      ³±±
±±³             |        |                |fGetRotRes para obtener el roteiro de tipo³±±
±±³             |        |                |resición									 ³±±
±±³Renan Borges |03/12/16|MRH-1899        |Ajuste para não gerar access violation    ³±±
±±³             |        |                |quando for executar o bblock e melhoria de³±±
±±³             |        |                |performance.                              ³±±
±±³Marcos Cout. |08/12/16|MRH-180         |Ajustes na rotina para salvar e voltar a  ³±±
±±³             |        |                |tela de lançamentos por funcionários de   ³±±
±±³             |        |                |modo automatico. Ajustes na consulta de   ³±±
±±³             |        |                |calculo setando para o roteiro ativo.     ³±±
±±³Claudinei S. |28/04/17|DRHPAG-410      |Ajuste em gp090MontaGetDados() para que em³±±
±±³             |        |                |caso de Rescisão carregar o roteiro RES.  ³±±
±±³Paulo O.     |05/05/17|DRHPAG-1279     |correção de error log caso seja incluso um³±±
±±³Inzonha      |        |                |novo registro após clicar em não na msg   ³±±
±±³             |        |                |"Deseja gravar as alterações"			 ³±±
±±³Paulo O.     |08/05/17|DRHPAG-1269     |Ajuste no valor inicial da variavel       ³±±
±±³Inzonha      |        |                |bCalcular de array para bloco de codigo   ³±±
±±³Eduardo.     |24/05/17|DRHESOCP-293/273|Merge de fontes de Inovação e Sustentação ³±±
±±³			    |        |                |Ajustes e Chamada de Tela de MultiVinc.   ³±±
±±³Cícero Alves |05/07/17|DRHPAG-3520     |Ajuste na gpRCHFiltro para atualizar a	 ³±±
±±³				|		 |				  |variável cFilRCJ							 ³±±
±±³M. Silveira  ³28/07/17|DRHPAG-4531     |Ajustes na Gpea090Mnt para nao perder a   ³±±
±±³             |        |                |referencia da SRA no calculo da rescisao. ³±±
±±³Gabriel A.   |29/08/17|DRHPAG-5108     |Retirada alteração que gerou "error.log"  ³±±
±±³             |        |                |para análise posterior.                   ³±±
±±³WinstonCosta |02/01/19|DRHPAG-22991    |Retirada do trecho que trata o AS/400     ³±±
±±³Diego Rivera |04/12/19|DMINA-7856      |Se reactiva la opción "borrar" en la fun- ³±±
±±³             |        |                |ción menuDef para MI.                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GPEA090(nOpcAuto)

Local aSvRotSetOpc	:= {}
Local bblock		:= Nil
Local nPos			:= 0
Local lGestPubl:= IIF(ExistFunc("fUsaGFP"), fUsaGFP(), .F.)
Local cFiltraRH     := ""
Local oBrowse

DEFAULT __lMemCalc := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo

Private aArray		:= {}
Private cLancAlias  := "SRC"
Private cCRLF       := CHR(13) + CHR(10)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define array contendo as Rotinas a executar do programa      ³
//³ ----------- Elementos contidos por dimensao ------------     ³
//³ 1. Nome a aparecer no cabecalho                              ³
//³ 2. Nome da Rotina associada                                  ³
//³ 3. Usado pela rotina                                         ³
//³ 4. Tipo de Transa‡„o a ser efetuada                          ³
//³    1 - Pesquisa e Posiciona em um Banco de Dados             ³
//³    2 - Simplesmente Mostra os Campos                         ³
//³    3 - Inclui registros no Bancos de Dados                   ³
//³    4 - Altera o registro corrente                            ³
//³    5 - Remove o registro corrente do Banco de Dados          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private aRotina    := MenuDef() // ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina

cCadastro := Iif(FWIsInCallStack("GPEA090"), Iif(cModulo == "GFP", OemToAnsi(STR0097), OemToAnsi(STR0076)), OemToAnsi(STR0010))  //"Consulta de Cálculos por Funcionário"###"Lançamentos por Funcionários / Servidor

If nOpcAuto <> Nil
	aSvRotSetOpc := aRotSetOpc( NIL , NIL , nOpcAuto )
	dbSelectArea('SRA')
	nPos := Ascan(aRotina,{|x| x[4]== nOpcAuto})
	If ( nPos <> 0 )
		bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nPos,2 ] + "(a,b,c,d,e) }" )
		Eval( bBlock, Alias(), (Alias())->(Recno()),nPos)
	EndIf
	aRotReSetOpc( aSvRotSetOpc )
Else

	If !lGestPubl

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o Arquivo Esta Vazio                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !ChkVazio("SRA")
			Return( NIL )
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicializa o filtro utilizando a funcao FilBrowse, Faltara um filtro   ³
		//³ da tabela SRC que sera executado depois do dbSetOrder pois o dbSetOrder|
		//³ elimina o filtro do FilBrowse                                          |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aArray := {"SRA", "SRV", cLancAlias }
		ffiltro("GPEA090",aArray,2)//2- Cria as variaveis
		ffiltro("GPEA090",aArray,1,1)//1- Executa os Filtros

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Endereca a funcao de BROWSE                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SRA")
		mBrowse( 6, 1,22,75,"SRA",,,,,,fCriaCor() )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Deleta o filtro utilizando a funcao FilBrowse                     	   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ffiltro("GPEA090",aArray,0)//0- Limpa os filtros
	Else
		oBrowse := FWMBrowse():New()
		oBrowse:SetAlias('SRA')
		oBrowse:SetDescription(STR0097) //"Consulta de Cálculo por Servidor"
		GpLegend(@oBrowse,.T.) //Cria legenda
		oBrowse:SetMenuDef( 'GPEA090' )
		oBrowse:SetChgAll(.F.)

		//------------------------------------------
		//Busca o filtro a ser utilizado no Browse
		//------------------------------------------
		cFiltraRh 	:= CHKRH("GPEA090","SRA","1")
		cFiltraRh += IF(!Empty(cFiltraRh),' .and. ','')
		If cModulo $ "GFP*VDF"
			cFiltraRh += " (SRA->RA_REGIME == '2' ) "
		ElseIf cModulo == "GPE"
			cFiltraRh += " (SRA->RA_REGIME == '1' .OR. Empty(SRA->RA_REGIME) ) "
		EndIf
			//Filtro padrao do Browse conforme tabela SRW (Controle de Restricoes de Usuarios)
			oBrowse:SetFilterDefault(cFiltraRh)
			oBrowse:Activate()
		EndIf
	EndIf

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea090Mnt	 ³ Autor ³Marinaldo de Jesus   ³ Data ³05/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Lancamentos Mensais     									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONA170  													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Gpea090Mnt( cAlias , nReg , nOpcx, aFields, cRotCalculo, nTipo, lDisable )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis Local                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Local aButtons		:= {}
	Local aArea			:= GetArea()
	Local aAreaSRA		:= SRA->( GetArea() )
	Local aAdvSize		:= {}
	Local aInfoAdvSize	:= {}
	Local aObjSize		:= {}
	Local aObjCoords	:= {}
	Local aVirtual		:= {}
	Local aSRCCols		:= {}
	Local aColsRec		:= {}
	Local aGrupos		:= UsrRetGrp( cUserName )
	Local aSitFunc		:= ""
	Local cNome    		:= ""
	Local cLancDemi		:= SuperGetMv("MV_DEMISRC" )
	Local cDigLancam	:= SuperGetmv("MV_DIGLANC")
	Local cCodUser 		:= RetCodUsr()
	Local cGrupos 		:= ""
	Local dPerIniPar	:= Ctod("//")
	Local dPerFimPar	:= Ctod("//")
	Local nOpca			:= 0
	Local uSvMvPar01	:= IF( Type("MV_PAR01") <> "U" , MV_PAR01 , NIL )
	Local nCoordLin		:= 0
	Local bFreeLocks	:= {|| FreeLocks(cAlias , NIL , .T. ), .T.}
	Local bGravar		:= {}
	Local bCalcular		:= {||}
	Local bApliFin 		:= {}
	Local bRevAplFin 	:= {}
	Local aPesqIdx 		:= {}
	Local aPesqOrd		:= {}
	Local lSeeAll		:= .T.
	Local lRet 			:= .T.
	Local lOfuscaNom	:= .F.
	Local lOfuscaAdm	:= .F.
	Local lOfuscaFun	:= .F.
	Local cPesqOrd
	Local cPesqCampo	:= space(40)
	Local lAxPesqui 	:=.F.
	Local lValPer		:= .T.
	Local cPrefixo		:= ""
	Local nPosStatus:= If( SRA->RA_SITFOLH = 'D', 2, 1)
	Local nX			:= 0
	Local nY			:= 0
	Local aColsRecx		:= {}
	Local lGP042Reg		:= (cPaisLoc $ "COL" .And. FunName() == "GPEM042" .And. !IsBlind())

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Objetos          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	Local oFont
	Local oGroup
	Local oDlg
	Local oBtnPgNext
	Local oBtnPgPrev
	Local oBntNext
	Local oBntPrev
	Local oPesqCbx
	Local oPesqGet
	Local oPeriodo
	Local oNrPagto
	Local oRoteiro
	Local oFunc
	Local oPers

	Local bRetrocOne := {|| .T. }
	Local bRetrocAll := {|| .T. }
	Local bAvancaOne := {|| .T. }
	Local bAvancaAll := {|| .T. }
	Local bFica      := {|| .T. }
	Local bImpr      := {|| .T. }

	Local bVisuali := {||ChamaRGB(2),gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),oGet:ForceRefresh()}
	Local bIncluir := {||ChamaRGB(3),gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),oGet:ForceRefresh()}
	Local bAlterar := {||ChamaRGB(4),gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),oGet:ForceRefresh()}
	Local bBotaoCalc2	:= {|| fCalcLanc(cFil, cMat),lCalcExec := .T., gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),oGet:ForceRefresh()}

	Local oBrwAux
	Local oFilAux
	Local cFilterAux

	Local cRoteiroAux := Iif(TYPE("cRoteiro") == "U", "",cRoteiro) //Variavel para auxiliar na abertura do Consultar Calculo
	Local lDelOk := .T.

	Local nPosPD	:= 0
	Local nPosCC	:= 0
	Local nPosSEQ	:= 0
	Local nPosDTREF	:= 0
	Local nPosRec	:= 0
	Local lHistMed	:= AliasInDic("RJK") .And. AliasInDic("SRP") .And. FindFunction("fVerHistMed") .And. FindFunction("fTemHMed")

	Local aOfusca	 := If(FindFunction('ChkOfusca'), ChkOfusca(), {.T.,.F.}) //[1] Acesso; [2]Ofusca
	Local aFldOfusca := {}
	Local aFldRot	 := {}

	nModAuto := If (Type("nModAuto") == "U", 1, nModAuto)
	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)

	Private cFil := ""
	Private cMat
	Private lCalcExec	:= .F.

	//--> Variável para controlar o texto do título que será adicionado à janela.
	If Type("lTitCalc") == "U"
		Private lTitCalc	:= .F.
	EndIf

	//--> Variável para controlar o texto do título que será adicionado à janela.
	If Type("lTitLanc") == "U"
		Private lTitLanc	:= .F.
	EndIf

	If lGp580Auto

		cFil :=	xFilial("SRA")
		If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='RA_MAT'})) > 0
			cMat :=	aAutoCab[nT,2]
		EndIf

		dbSelectArea("SRA")
		dbSetOrder(1)
		If !dbSeek(cFil+cMat)
			Help( " ", 1, "REGNOIS" )
			Return
		EndIf
		cFil		:= SRA->RA_FILIAL
		cMat     	:= SRA->RA_MAT
		cNome    	:= SRA->RA_NOME

	Else
		If !IsInCallStack("GPEM040") .AND. !IsInCallStack("GPEM042")
			oBrwAux 		:= GetMBrowse()
			If !oBrwAux:lNoBrowse
				oFilAux 		:= oBrwAux:FwFilter()
				cFilterAux		:= oFilAux:GetExprADVPL()

				If !Empty(cFilterAux)
					DbSelectArea("SRA")
					cFilterAux := StrTran(cFilterAux, 'RA_SITFOLH== ""', 'RA_SITFOLH== " "')
				EndIf

				If Len(fValidFil()) <= 2000
					cFilterAux += If( !( Empty( cFilterAux ) ), ' .And. SRA->RA_FILIAL $ fValidFil() ', ' SRA->RA_FILIAL $ fValidFil() ' )
				Else
					cFilterAux += If( !( Empty( cFilterAux ) ), ' .And. !( SRA->RA_FILIAL $ fValidFil(,.T.) ) ', ' !( SRA->RA_FILIAL $ fValidFil(,.T.) ) ' )
				EndIf

				DbSetFilter({||&cFilterAux},cFilterAux)
			EndIf
		Endif

		cFil		:= SRA->RA_FILIAL
		cMat    	:= SRA->RA_MAT
		cNome   	:= SRA->RA_NOME

	EndIf

	aSitFunc		:= RetSituacao( SRA->RA_FILIAL , SRA->RA_MAT , .F. )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Blocos de Codigo                                            ³
	//³================                                            ³
	//³Serao utilizados na acao do botoes de movimentacao, "Avanca"³
	//³"Retrocede", "Avanca Todos" e "Retrocede Todos".            ³
	//³O Bloco "bFica" sera utilizado quando forem alterados os    ³
	//³campos data de referencia, semana e tipo de lancamento.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	bRetrocOne := {|| SRA->( dbskip(-1))	 ,gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.), oGet:oBrowse:Refresh(),oDLG:Refresh()}
	bRetrocAll := {|| SRA->( dbGoTop())	 ,gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.), oGet:oBrowse:Refresh(),oDLG:Refresh()}
	bAvancaOne := {|| SRA->( dbskip())	 ,If( SRA->(! EOF()),aCols:= {},.T.), gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.), oGet:oBrowse:Refresh(),oDLG:Refresh()}
	bAvancaAll := {|| SRA->( dbGoBottom()),gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.),oGet:oBrowse:Refresh(),oDLG:Refresh()}
	bFica      := {|| gp090MontaGetDados(cAlias, nOpcX, @cFil, @cMat, @aVirtual, @aColsRec, @aSRCCols, .T., .F.),If(lDaRefresh,(oGet:oBrowse:Refresh(),oDLG:Refresh()),.t.)}

	If Type("cLancAlias") == "U"
		cLancAlias := "SRC"
	EndIf

	cAlias   := cLancAlias
	cPrefixo := ( PrefixoCpo( cAlias ) + "_" )

	If cAlias == "SRC" .and. ( MV_MODFOL == '2' .Or. cPaisLoc $ "PTG|COL|VEN" )
		If nOpcx > 2
			nOpcx += 2
		EndIf
	ElseIf ( cPaisLoc == "PER" .and. nOpcX == 3 .and. !( IsInCallStack("GPEA580") .or. IsInCallStack("GPEA590") ) )
		nOpcX := 5
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis Privadas                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private aTELA			:= {}
	Private aGETS			:= {}
	Private aHeader 		:= {}
	Private aCols			:= {}
	Private aColsAnt		:= {}
	Private aGdAltera		:= {}
	Private aIndexSrv		:= {}
	Private bBlkGravar		:= {||;
									 If(Gpea090LinOk() .AND. If(cPaisLoc $ "PTG",Gpea090TudOk(),.T.) ,;
									 Gpea090Grava(cAlias,cFil,cMat,aVirtual,aColsRec,nOpcx,.F.,.F.), .T.) ;
								}
	Private bBotaoGravar	:= {||;
									 If(Gpea090LinOk() .AND. If(cPaisLoc $ "PTG",Gpea090TudOk(),.T.) ;
									 .AND. If(lGP090CHK,ExecBlock( "GP090CHK", .F., .F., {cCodUser, cGrupos, aClone( aColsAnt ), aClone( aCols )} ),.T.),;
									 Gpea090Grava(cAlias,cFil,cMat,aVirtual,aColsRec,nOpcx,.T.,.F.), .T.) ;
								}


	Private bBotaoCalc		:= {|| fCalcLanc(cFil, cMat)}
	Private cDigSemana		:= SuperGetmv("MV_DIGSEMA")
	Private cDigHoras		:= SuperGetmv("MV_HORASDE")
	Private cSemana  		:= Space( TamSx3(cPrefixo+"SEMANA")[1] )
	Private cCategoria		:= SRA->RA_CATFUNC
	Private cProcesso		:= SRA->RA_PROCES
	Private cPosto 			:= SRA->RA_POSTO
	Private cPeriodo
	Private cPeriodoAnt
	Private cNumPagto		:= ""
	Private cSemanaAnt
	Private cDataIni
	Private cDataFim
	Private cRoteiro		:= If( !Empty(cRotCalculo), cRotCalculo, (Iif(TYPE("cRoteiro") == "U" ,"",cRoteiro)))
	Private cRoteiroAnt
	Private cCodRoteiro		:= ""
	Private cCodProcesso	:= ""
	Private cKeyRCH 		:= ""
	Private aGhCols			:= {}
	Private nValLanc		:= 0
	Private nValCalc		:= 0
	Private oGet
	Private lSRCLock		:= .F.
	Private cCond			:= "1"
	Private lDaRefresh		:= .F.
	Private lAchouMsg 		:= .T.
	Private nAchou 				:= 0
	Private nUsado  		:= 0
	Private lVerificaMes	:= .F.
	Private nTotHorAcm		:= 0
	Private lItemClVl		:= SuperGetMv("MV_ITMCLVL",NIL,"2")  $ "1*3" //variavel que define se os campos "Item Contabil" e Classe de Valor" estão ativos
	Private lDelCalc		:= .F.   // flag para exclusao de calculo quando existir exclusao de verba do tipo I-Informado.
	lM2Modif				:= .F.   //flag para saber se houve alteracoes (utilizado em chamada de rotinas a partir da tela de rescisao)

	//variaveis localizacao arg
	Private cAnoAcuIni := ""
	Private cAnoAcuFim := ""
	_SetOwnerPrvt( "nOpcNewGd", IF( nOpcX == 2 .or. nOpcX == 5 , 0 , GD_INSERT + GD_UPDATE + GD_DELETE))

	DEFAULT nTipo	 := 1
	DEFAULT lDisable := .F.

	//Inicializa as variaveis da chave quando for execauto
	If lGp580Auto
		If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CROTEIRO'})) > 0
			cRoteiro :=	aAutoCab[nT,2]
		EndIf
		If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CNUMPAGTO'})) > 0
			cNumPagto :=	aAutoCab[nT,2]
		EndIf
		If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CPERIODO'})) > 0
			cPeriodo :=	aAutoCab[nT,2]
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lGp580Auto
		aAdvSize		:= MsAdvSize()
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
		aAdd( aObjCoords , { 000, 020, .T. , .F. } )
		aAdd( aObjCoords , { 000, 020, .T. , .F. } )
		aAdd( aObjCoords , { 000, 000, .T. , .T. } )
		aAdd( aObjCoords , { 000, 025, .T. , .F. } )
		aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )
	EndIf
	If (!lGp580Auto) .AND. (nOpcx == 2)  .AND. (cPaisLoc == 'BRA' .AND. fGP90MultV("A"))
		Aadd(aButtons, {"VINCULO", {|| fGP90MultV("V") },  OemToAnsi(STR0082) }) //"Multiplos Vinculos"
	EndIf
	If (nOpcx = 3) .OR. (nOpcx = 4)

		bGravar	:= { || (;
			 			 MsAguarde( bBotaoGravar, OemToAnsi(STR0024)),;
						 NIL;
						);
					}

		if cPaisLoc != "RUS"
			aAdd(;
					aButtons	,;
									{;
										"SALVAR" 			,;
										bGravar				,;
										OemToAnsi( STR0028 ),;	//"Gravar"
										OemToAnsi( STR0028 ) ;	//"Gravar"
									};
				)
		endif

		if(IsInCallStack("GPEA580") .and. !(IsInCallStack("GPEM040")) .and. !(IsInCallStack("GPEM042")) .and. !(IsInCallStack("GPEM030"))) //Não deve exibir o botão para cálculo quando rotina for aberta pela rotina de rescisão ou férias.
			bCalcular	:= { || (;
								MsAguarde( bBotaoCalc, OemToAnsi(STR0024)),;
								NIL;
								);
							}
			if cPaisLoc != "RUS"
				aAdd(;
					aButtons	,;
								{;
									"CALCULAR" 			,;
									bCalcular			,;
									OemToAnsi( STR0062 ),;	//"Calcular Lancamento"
									OemToAnsi( STR0062 ) + " (F6)" ;	//"Calcular Lancamento"
								};
					)
			endif

			//--> Adicionado HotKey para cálcular o lançamento
			SetKey(VK_F6, bCalcular)

		endIf
	EndIf

	//--> Consulta dos lançamentos na SRC. O registro ja está posicionado no Recno correto para efetuar a consulta.
	If FWIsInCallStack("GPEA580") .And. !FWIsInCallStack("GPEA090")
		Aadd(aButtons, {"CARGA", {|| lTitCalc:= .T.,  SetKey(VK_F6, {||Nil}), Gpea090(2), SetKey(VK_F6, bCalcular) }, OemToAnsi( STR0075 )+" (F7)" }) //"Consultar Calculo"
		bConsultar	:= { || (;
								MsAguarde( Gpea090(2), OemToAnsi(STR0024)),;
								NIL;
								);
							}
		SetKey(VK_F7, bConsultar)
		Aadd(aButtons, {"CARGA", {|| Gpea630(2,2) }, OemToAnsi( STR0099 ) }) //"Recibo Pgto."
	EndIf

	If cPaisLoc != "RUS"
		bImpr	:= { || lTitLanc:= .T.,GPER101(2) }

		//--> Consulta dos lançamentos na RGB. O registro ja está posicionado no Recno correto para efetuar a consulta..
		If FWIsInCallStack("GPEA090") .And. !FWIsInCallStack("GPEA580")
			Aadd(aButtons, {"CARGA", {|| lTitLanc:= .T.,Gpea580(2) }, OemToAnsi( STR0077 ) }) //"Consultar Lançamentos"
			Aadd(aButtons, {"CARGA", {|| eval(bImpr) }, OemToAnsi( STR0095 ) })  //"Imprimir"
			SetKey( VK_F10 , bImpr )
		EndIf

		//--> Consulta LOG de Calculo. -- Outras Ações parte de dentro
		If (FWIsInCallStack("GPEA090")) .And. __lMemCalc
			Aadd(aButtons, {"LOG", {|| GPEA091(1) }, OemToAnsi( STR0087 ) }) //"Consultar Memória de Calculo"
		EndIf
		If lHistMed
			Aadd(aButtons, {"CARGA", {|| fMedHist() }, OemToAnsi( STR0117 ) }) //"Médias"
		EndIf
	EndIf

	// Visualizacao de Finiquitos - Mexico
	If cPaisLoc == "MEX" .and. nTipo == 2
		If nOpcx <> 5
			bApliFin 	:= { || If( Gpm040Fin(1, @cRoteiro, @cPeriodo, @cNumPagto), (;
															   	gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),;
															   	oGet:Refresh();
																), .F.) }
			bRevAplFin 	:= { || If( Gpm040Fin(2, @cRoteiro, @cPeriodo, @cNumPagto), (;
															   	gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.),;
															   	oGet:Refresh();
																), .F.) }
			bGPEA550 	:= { || GpeA550(),;
			 					If( lM2Modif, IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, lM2Modif:= .F., oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			bGPEA580 	:= { || ;
			 					If(GPEA580(), IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			bGPEA240 	:= { || GpeA240(),;
			 					If(lM2Modif, IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, lM2Modif:= .F., oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			bGPEA110 	:= { || Gpea110(),;
			 					If(lM2Modif, IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, lM2Modif:= .F., oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			bGPEA640 	:= { || Gpea640(),;
			 					If(lM2Modif, IF( MsgNoYes(	OemToAnsi(	STR0051 + CRLF + CRLF + STR0052), OemToAnsi( STR0040 ) ),GPEM022(cProcesso, cRoteiro, nPosStatus, .T., SRA->RA_MAT,,,, .T.), ), );
							, lM2Modif:= .F., oGet:Refresh()}   //"Estas modificações só terão efeito se a rescisão for recalculada." ## "Deseja recalcular agora?" ## "Attention"

			aAdd(aButtons, { "E5" , bApliFin  , OemToAnsi( STR0033 ), OemToAnsi( STR0032 ) } ) // "Aplicacão de Finiquitos"
			aAdd(aButtons, { "ATALHO", bRevAplFin, OemToAnsi( STR0035 ) , OemToAnsi( STR0034 ) } ) // "Reversao de Aplicação de Finiquitos"
			aAdd(aButtons, { "Fixos"      , bGPEA550, , OemToAnsi( STR0053 ) } ) //"Lançamentos Fixos"
			aAdd(aButtons, { "Incidencias", bGPEA580, , OemToAnsi( STR0054 ) } ) //"Incidências por funcionário"
			aAdd(aButtons, { "Ausencias"  , bGPEA240, , OemToAnsi( STR0055 ) } ) //"Ausências"
			aAdd(aButtons, { "Prestamos"  , bGPEA110, , OemToAnsi( STR0056 ) } ) //"Valores Futuros"
			aAdd(aButtons, { "Extra"      , bGPEA640, , OemToAnsi( STR0057 ) } ) //"Tempo Extra"

		EndIf
	EndIf

	//Monta o título da janela de acordo com a chamada
	If nOpcx == 2 .And. FunName() == "GPEA580" .And. lTitCalc
		cCadastro := If(cModulo == "GFP", OemToAnsi(STR0097), OemToAnsi(STR0076)) //"Consulta de Cálculo por Funcionário" / Servidor
	ElseIf nOpcx == 2 .And. FunName() == "GPEA090"
		cCadastro := If(!lTitLanc,If(cModulo == "GFP", OemToAnsi(STR0097), OemToAnsi(STR0076)),If(cModulo == "GFP", OemToAnsi(STR0098), OemToAnsi(STR0079))) //"Consulta de Cálculo por Funcionário/Servidor"###"Consulta de Lançamentos por Funcionário\Servidor"
	Else
		if cPaisLoc == "RUS"
			cCadastro := OemToAnsi(STR0090)
		else
			cCadastro := OemToAnsi(STR0010)
		endif
	EndIf

	aEval( aGrupos , { |x| ( cGrupos += ( x + "/" ) ) } )

	Begin Sequence

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Cria Array de Campos Alteraveis                              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		dbSelectArea(cAlias)


		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se o Funcionario Esta Demitido                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( aSitFunc[1] == "D" )
			If !( cLancDemi == "S" )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Nao Permite o Lancamento Para o Funcionario                  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If FunName() <> "GPEM040" .and. FunName() <> "GPEM042"
					Help(" ",1,"NOLANCDEMI")
					Break
				EndIf
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Permite o Lancamento Para o Funcionario                      ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If MV_MODFOL <> "2"
					If FunName() <> "GPEM040" .and. FunName() <> "GPEM042"
						If !lGp580Auto
							Help(" ",1,"A090DEMITI")
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		If !lGp580Auto
			If ( aSitFunc[1] == "A" )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Funcionario Esta Afastado.                                   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				Help(" ",1,"A090AFASTA")
			ElseIf ( aSitFunc[1] == "F" )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Funcionario Esta de F‚rias                                   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				Help(" ",1,"A090FERIAS")
			ElseIf ( aSitFunc[1] == "T" )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se o Funcionario Esta de Transferido                ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				Help(" ",1,"A090TRANSF")
			EndIf
		EndIf

		//Seleciona periodo aberto
		If Empty(cRoteiro)
			if cPaisLoc == "CHI" .AND. FunName() == "GPEM042"
				cRoteiro 	:= fGetRotRes()
			EndIf
		EndIf
		//Seleciona periodo aberto
		If Empty(cRoteiro)
			If IsInCallStack("GPEM040")
				cRot := cRoteiro := fGetCalcRot('4')
			//ElseiF IsInCallStack("GPEM042")
				//cRoteiro 	:= fGetCalcRot('4')
			Else
				If SRA->RA_CATFUNC $ "A*P"
					cRoteiro := fGetCalcRot("9")
				Else
					cRoteiro := Iif(cRoteiroAux == "VEX", cRoteiroAux, fGetRotOrdinar())
				EndIf
			EndIf
		EndIf

		If !lGp580Auto
			If FunName() == "GPEM030" .and. !Empty(M->RH_PERIODO)
				cPeriodoAnt := cPeriodo := M->RH_PERIODO
				cSemanaAnt := cNumPagto:= M->RH_NPAGTO
				cRoteiroAnt := cRoteiro := M->RH_ROTEIR
				RCH->(DbSetORder(1))//RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
				RCH->(DbSeek(xFilial("RCH")+cProcesso+cPeriodo+cNumPagto+cRoteiro))
			Else
				If lGP042Reg .And. !Empty(M->RG_ROTEIR) .And. !Empty(M->RG_PERIODO) .And. !Empty(M->RG_SEMANA)
					cRoteiro	:= M->RG_ROTEIR
					cPeriodo	:= M->RG_PERIODO
					cNumPagto	:= M->RG_SEMANA
				Else
					cPeriodo	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_DTFECH = '' ", "RCH_PER" ,,.T. )
					cNumPagto 	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_DTFECH = '' ", "RCH_NUMPAG" ,,.T. )
				EndIf
				If Empty( cPeriodo )
					cPeriodo	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_DTFECH = '' ", "RCH_PER" ,,.T. )
					cNumPagto 	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_DTFECH = '' ", "RCH_NUMPAG" ,,.T. )
				EndIf
				If Empty(cRoteiro)
					cRoteiro	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_DTFECH = '' ", "RCH_ROTEIR" ,,.T. )
				EndIf
			EndIf
		EndIf

		If IsInCallStack("GPEM040")
			If !Empty(GetMemVar("RG_PERIODO"))
				cPeriodo := GetMemVar("RG_PERIODO")
				cNumPagto := GetMemVar("RG_SEMANA")
				RCH->(DbSetORder(1))//RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
				RCH->(DbSeek(xFilial("RCH")+cProcesso+cPeriodo+cNumPagto+cRoteiro))
			EndIf
		EndIf

		//Para nao buscar um novo roteiro na entrada - Funcao Gp090MontaGetDados
		cPeriodoAnt := cPeriodo
		cSemanaAnt	:= cNumPagto

		If ( Empty(cPeriodo) .and. Empty(cPeriodoAnt) )
			Help(" ",1,OemToAnsi(STR0049), Nil,OemToAnsi(STR0040))
//			Help(" ",1,"A090VLDPER")
			Return .F.
		EndIf

		gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F., .T.)

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Mostra Tela para Informar Total do Lan‡amento MV_DIGLANC="S"³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If lGp580Auto
			cDigLancam:="N"
		EndIf

		If ( ( nOpcx <> 5 ) .and. ( nOpcx <> 2 ) )
			If ( cDigLancam == "S" )
				fTotLanc()
			EndIf
		EndIf

		If !lGp580Auto
			DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
			DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL
			//Protecao de Dados Sensiveis
			If aOfusca[2]
				aFldRot := {'RA_NOME', 'RA_ADMISSA', 'RA_CODFUNC'}
				aFldOfusca 	:= FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRot ) // CAMPOS SEM ACESSO

				IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0
					lOfuscaNom	:= FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
				ENDIF

				IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_ADMISSA" } ) > 0
					lOfuscaAdm	:= FwProtectedDataUtil():IsFieldInList( "RA_ADMISSA" )
				ENDIF

				IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_CODFUNC" } ) > 0
					lOfuscaFun	:= FwProtectedDataUtil():IsFieldInList( "RA_CODFUNC" )
				ENDIF
			EndIf
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Define grupo do cabecalho       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Matricula, Nome, Admissao, Processo e Posto       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			@ aObjSize[1,1],aObjSize[1,2] 			GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.1 	LABEL OemToAnsi(STR0013) OF oDlg PIXEL // Matricula:
			oGroup:oFont:= oFont
			If cPaisLoc == "RUS"
				@ aObjSize[1,1],aObjSize[1,4]*0.105	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.20 	LABEL OemToAnsi(STR0096) OF oDlg PIXEL // Personal Registration Number
				oGroup:oFont:= oFont
				@ aObjSize[1,1],aObjSize[1,4]*0.205 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.7 	LABEL OemToAnsi(STR0014) OF oDlg PIXEL // Nome:
				oGroup:oFont:= oFont
			Else
				@ aObjSize[1,1],aObjSize[1,4]*0.105 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.7 	LABEL OemToAnsi(STR0014) OF oDlg PIXEL // Nome:
				oGroup:oFont:= oFont
			EndIf
			@ aObjSize[1,1],aObjSize[1,4]*0.705 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.8	LABEL OemToAnsi(STR0019) OF oDlg PIXEL	// Admiss„o:
			oGroup:oFont:= oFont
			@ aObjSize[1,1],aObjSize[1,4]*0.805 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.9 	LABEL OemToAnsi(STR0021) OF oDlg PIXEL // Processo:
			oGroup:oFont:= oFont

			If cPaisLoc != "RUS"
				@ aObjSize[1,1],aObjSize[1,4]*0.905 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4] 		LABEL OemToAnsi(STR0043) OF oDlg PIXEL // Função:
				oGroup:oFont:= oFont
			EndIf

			/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Codigo do Periodo, Numero de Pagamento, Roteiro, Data Inicio e Data Fim do periodo ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			@ aObjSize[2,1],aObjSize[2,2] 			GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.18  LABEL OemToAnsi(STR0027) OF oDlg PIXEL	// Codigo do Periodo:
			oGroup:oFont:= oFont
			@ aObjSize[2,1],aObjSize[2,4]*0.185	GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.36 	LABEL OemToAnsi(STR0026) OF oDlg PIXEL	// Numero de Pagamento:
			oGroup:oFont:= oFont
			@ aObjSize[2,1],aObjSize[2,4]*0.365	GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.54 	LABEL OemToAnsi(STR0029) OF oDlg PIXEL  // Roteiro:
			oGroup:oFont:= oFont
			@ aObjSize[2,1],aObjSize[2,4]*0.545	GROUP oGroup TO aObjSize[2,3], aObjSize[2,4]*0.76 	LABEL OemToAnsi(STR0023) OF oDlg PIXEL	// Periodo:
			oGroup:oFont:= oFont

			@ aObjSize[1,1]+10,aObjSize[1,2]*2.5 	SAY oFunc Var cMat	SIZE 050,10 OF oDlg PIXEL FONT oFont
			If cPaisLoc == "RUS"
				@ aObjSize[1,1]+10,aObjSize[1,4]*0.12 	SAY oPers Var OemToAnsi(SRA->RA_CODUNIC)				SIZE 050,10 OF oDlg PIXEL FONT oFont
				@ aObjSize[1,1]+10,aObjSize[1,4]*0.22	SAY AllTrim(OemToAnsi(SRA->RA_NOME))	SIZE 196,10 OF oDlg PIXEL FONT oFont
			Else
				@ aObjSize[1,1]+10,aObjSize[1,4]*0.12	SAY If(lOfuscaNom,Replicate('*',15),OemToAnsi(SRA->RA_NOME))			SIZE 146,10 OF oDlg PIXEL FONT oFont
			EndIf
			@ aObjSize[1,1]+10,aObjSize[1,4]*0.72	SAY If(lOfuscaAdm,Replicate('*',10),Dtoc(SRA->RA_ADMISSA)) 			SIZE 050,10 OF oDlg PIXEL FONT oFont
			@ aObjSize[1,1]+10,aObjSize[1,4]*0.82	SAY OemToAnsi(SRA->RA_PROCES) 		SIZE 050,10 OF oDlg PIXEL FONT oFont

			If cPaisLoc != "RUS"
				@ aObjSize[1,1]+10,aObjSize[1,4]*0.92	SAY If(lOfuscaFun,Replicate('*',5),OemToAnsi(SRA->RA_CODFUNC))		SIZE 050,10 OF oDlg PIXEL FONT oFont
			EndIf

			@ aObjSize[2,1]+8 , aObjSize[2,2]*2 MSGET oPeriodo Var cPeriodo WHEN !lDisable PICTURE GetSx3Cache( "RCH_PER" , "X3_PICTURE" ) F3 "RCH" HASBUTTON;
			VALID If( lValPer, lValPer := (Vazio() .OR. ExistCpo( "RCH", cProcesso + cPeriodo + "        ", 2)), lValPer := .T. )	.AND. ;
				fAtualRot() 																			    .AND. ;
				If( ExistBlock("GP090VLD"), ExecBlock("GP090VLD",.F.,.F.), .T.)						    .AND. ;
				If(cPeriodo <> cPeriodoAnt, If(lSRCLock, Eval(bFreeLocks), .T.), .T.)						.AND. ;
				If(cPeriodo <> cPeriodoAnt, If((lSRCLock := Gpea090Locks(nOpcx , cAlias)) , .T., .F.), .T.) 	.AND. ;
				If(cPeriodo <> cPeriodoAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .T.), .T.) ;
			SIZE 50,7 OF oDlg PIXEL

			@ aObjSize[2,1]+8 , aObjSize[2,4]*0.20  MSGET oNrPagto Var cNumPagto;
				PICTURE GetSx3Cache( "RCH_NUMPAG" , "X3_PICTURE" ) HASBUTTON;
				VALID If( lValPer, lValPer := ExistCpo( "RCH", cProcesso + cPeriodo + cNumPagto + "        ", 3),lValPer := .T.) 	.AND. ;
					fAtualRot() 														 .AND. ;
					If(cNumPagto <> cSemanaAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .T.), .T.) ;
				SIZE 50,7 OF oDlg PIXEL;
				WHEN If(cPaisLoc == "RUS", .F.,!lDisable);
				F3  If(cPaisLOc == "RUS",,"RCH01")

			oNrPagto:bHelp := {|| ShowHelpCpo("cNumPagto",{GetHlpSoluc("RCH_NUMPAG")[1]},2,{GetHlpSoluc("RCH_NUMPAG")[2]},2)}

			@ aObjSize[2,1]+8 , aObjSize[2,4]*0.38 MSGET oRoteiro Var cRoteiro;
				PICTURE GetSx3Cache( "RCH_ROTEIR" , "X3_PICTURE" )  HASBUTTON;
				VALID If( lValPer, lValPer := (Vazio() .OR. ExistCpo("SRY", cRoteiro)), lValPer := .T. )	.AND. ;
					If(cRoteiro <> cRoteiroAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .T.), .T.) ;
				SIZE 50,7 OF oDlg PIXEL;
				WHEN If(cPaisLoc == "RUS", .F.,!lDisable);
				F3  If(cPaisLOc == "RUS",,"SRYREL")

			@ aObjSize[2,1]+10, aObjSize[2,4]*0.56 SAY DTOC(cDataIni) + " - "  + DTOC(cDataFim) SIZE 060,10 OF oDlg PIXEL FONT oFont

			oGet := MsNewGetDados():New(aObjSize[3,1],;// nTop
										 aObjSize[3,2],;   	// nLelft
										 aObjSize[3,3],;	// nBottom
			                             aObjSize[3,4],;	// nRright
										 nOpcNewGd,;		// controle do que podera ser realizado na GetDado - nstyle
										 "Gpea090LinOk",;	// funcao para validar a edicao da linha - ulinhaOK
										 "Gpea090TudOk",;	// funcao para validar todas os registros da GetDados - uTudoOK
		  								 NIL,;				// cIniCPOS
										 aGdAltera,;		// aAlter
										 0,; 				// nfreeze
										 99999,;  			// nMax
										 NIL,;		 		// cFieldOK
										 NIL,;				// usuperdel
										 If(nOpcx=2.Or.nOpcx=5,.F.,{||Gp090VldDel(@cKeyRCH,nOpcx)}),;		// udelOK
										 @oDlg,;        	// objeto de dialogo - oWnd
										 @aHeader,;			// Vetor com Colunas - AparHeader
										 @aSRCCols;			// Vetor com Header - AparCols
										)

			// Validar a linha atual quando a GetDados perder o foco.
			oGet:oBrowse:bLostFocus := { || If(!Gpea090LinOk(), oGet:oBrowse:SetFocus(), .T.) }

			// Verificar se o roteiro foi informado antes de incluir a linha.
			oGet:oBrowse:bGotFocus := { || If(Empty(cRoteiro), oRoteiro:SetFocus(), If( lValPer := GpValidPer( NIL, cProcesso, cPeriodo, cNumPagto, cRoteiro,.T.), .T., (oRoteiro:SetFocus(), cRoteiro := Space(3), oRoteiro:Refresh()))) }

			If Type( "lNoShowFunc" ) == "U" .Or. !lNoShowFunc //Tratamento para chamada da rotina atraves de tela de rescisão (Modelo 2)
				/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Define grupo do rodape          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				@ aObjSize[4,1], aObjSize[4,2] GROUP oGroup TO  aObjSize[4,3], aObjSize[4,4] LABEL OemToAnsi(STR0030) OF oDlg PIXEL	 //"Pesquisar Funcionarios"
				oGroup:oFont:= oFont

				/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Lista Botoes de posicionamento do funcionario ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				@ aObjSize[4,1]+10, aObjSize[4,2]+08.96 BUTTON oBtnPgPrev 	PROMPT OemToAnsi("<<")	 SIZE 021.5, 10 DESIGN ACTION Gp090Movimenta(bRetrocAll) OF oDlg PIXEL
				@ aObjSize[4,1]+10, aObjSize[4,2]+29.96	BUTTON oBtnPrev		PROMPT OemToAnsi("<")	 SIZE 021.5, 10 DESIGN ACTION Gp090Movimenta(bRetrocOne) OF oDlg PIXEL
				@ aObjSize[4,1]+10, aObjSize[4,2]+50.96	BUTTON oBntNext 	PROMPT OemToAnsi(">")	 SIZE 021.5, 10 DESIGN ACTION Gp090Movimenta(bAvancaOne) OF oDlg PIXEL
				@ aObjSize[4,1]+10, aObjSize[4,2]+71.96	BUTTON oBtnPgNext 	PROMPT OemToAnsi(">>")	 SIZE 021.5, 10 DESIGN ACTION Gp090Movimenta(bAvancaALL) OF oDlg PIXEL

				AxPesqOrd("SRA",@aPesqIdx,,lSeeAll,@aPesqOrd)

				cPesqOrd := aPesqOrd[1]

				@ aObjSize[4,1]+10,aObjSize[4,4]*0.28 			COMBOBOX oPesqCbx 	VAR cPesqOrd ITEMS aPesqOrd SIZE 100,	36 	PIXEL OF oDlg ON CHANGE If(lAxPesqui,(DbSelectArea(cAlias),DbSetOrder(aPesqIdx[oPesqCbx:nAt][1]),__oObjBrow:Refresh()),)
				@ aObjSize[4,1]+10,(aObjSize[4,4]*0.28)+110 	MSGET    oPesqGet 	VAR cPesqCampo 				SIZE 100,	09 	PIXEL OF oDlg
				@ aObjSize[4,1]+10,(aObjSize[4,4]*0.28)+220 	BUTTON   "Ok" 									SIZE 021.5,	10 	PIXEL OF oDlg ACTION (AxPesqSeek("SRA",.F.,cPesqCampo,,aPesqIdx,oPesqCbx:nAt,lSeeAll,),Gp640Movimenta(bFica))
			Endif

			bSet15	:= {|| nOpca:=1, ;
						If(oGet:TudoOk(), oDlg:End(), If(cDigLancam=="S", fTotLanc(),nOpca:=0) ) }
			bSet24	:= {|| oDlg:End()}

			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24, NIL , aButtons ) CENTERED

		Else

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|Valid do cPeriodo				                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistCpo( "RCH", cProcesso + cPeriodo, 2)				 .And.;
				If(lGp580Auto .And. !Empty(cRoteiro), .T.,fAtualRot()) 																	 .AND. ;
				If( ExistBlock("GP090VLD"), ExecBlock("GP090VLD",.F.,.F.), .T.) .AND. ;
				If(cPeriodo <> cPeriodoAnt, If(lSRCLock, Eval(bFreeLocks), .T.), .T.) .AND. ;
				If(cPeriodo <> cPeriodoAnt, If((lSRCLock := Gpea090Locks(nOpcx , cAlias)) , .T., .F.), .T.) 	.AND. ;
				If(cPeriodo <> cPeriodoAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F.), .T.)
				nOpcA:=1
			Else
				nOpcA:=0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|Valid do cNumPagto  			                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistCpo( "RCH", cProcesso + cPeriodo + cNumPagto + "        ", 3) .AND. ;
				If(lGp580Auto .And. !Empty(cRoteiro), .T.,fAtualRot()) 	 														 				 .AND. ;
				If(cNumPagto <> cSemanaAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F.), .T.)
				nOpcA:=1
			Else
				nOpcA:=0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|Valid do cRoteiro  			                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistCpo("SRY", cRoteiro) .AND. ;
				GpValidPer( NIL, cProcesso, cPeriodo, cNumPagto, cRoteiro) .AND.;
				If(cRoteiro <> cRoteiroAnt, gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, @aVirtual, @aColsRec, @aSRCCols, .F.), .T.)
				nOpcA:=1
			Else
				nOpcA:=0
			EndIf

			If nOpcA==1
				If !MsGetDAuto(aAutoItens,"Gpea090LinOk","Gpea090TudOk",,nOpcNewGd)
					nOpcA:=0
				EndIf
			EndIf

		EndIf

		nPosPD := GdFieldPos(cPrefixo + "PD")
		nPosCC := GdFieldPos(cPrefixo + "CC")
		nPosSEQ := GdFieldPos(cPrefixo + "SEQ")
		nPosDTREF := GdFieldPos(cPrefixo + "DTREF")
		nPosRec := GdFieldPos( cPrefixo + "REC_WT" )

		If ( ( nOpcA == 1 ) .and. ( nOpcX <> 2 ) )
			If lGp580Auto

				If nOpcx == 4 // Alteração
					aColsRecx := aClone(aColsAnt)

					For nX := 1 To Len(aCols)
						If (nPos := aScan( aColsRecx, { |x| x[nPosPD] == aCols[nX][nPosPD] .And. x[nPosCC] == aCols[nX][nPosCC] .And. (x[nPosSEQ] == aCols[nX][nPosSEQ] .Or. ( Empty(x[nPosSEQ]) .And. aCols[nX][nPosSEQ] == "0" ) ).And. x[nPosDTREF] == aCols[nX][nPosDTREF] } )) == 0
							Aadd( aColsRecx, aCols[nX] )
						Else
							aCols[nX][nPosRec] := aColsRecx[nPos][nPosRec]
							aColsRecx[nPos] := aCols[nX]
						EndIf
					Next

					aCols := aClone(aColsRecx)
					For nY := 1 to Len(aCols)
						n := nY
						Gpea090LinOk()
					Next nY
				EndIf

				If nModAuto == 2
					If nOpcx == 5	// Exclusão
						For nX := 1 To Len(aCols)
							If (nPos := aScan( aColsAnt, { |x| x[nPosPD] == aCols[nX][nPosPD] .And. x[nPosCC] == aCols[nX][nPosCC] .And. (x[nPosSEQ] == aCols[nX][nPosSEQ] .Or. ( Empty(x[nPosSEQ]) .And. aCols[nX][nPosSEQ] == "0" ) ).And. x[nPosDTREF] == aCols[nX][nPosDTREF] } )) > 0
								Aadd( aColsRecx, aColsAnt[nPos][nPosRec] )
							EndIf
						Next
						aColsRec := aClone(aColsRecx)
					EndIf
				EndIf

				If Gpea090LinOk() .And. If(cPaisLoc $ "PTG", Gpea090TudOk(), .T.) .And. (If(lGP090CHK, ExecBlock( "GP090CHK", .F., .F., {cCodUser, cGrupos, aClone( aColsAnt ), aClone( aCols )} ),.T.))
					Gpea090Grava(cAlias, cFil, cMat, aVirtual, aColsRec, nOpcx, .F., .F.)
					//-- Ponto de entrada criado alteracao dos registros gravados
					If lGP090ALT
						ExecBlock("GP090ALT",.F.,.F.)
					EndIf
				EndIf
			Else
				lRet := .T.
				MsAguarde( { || If(Gpea090LinOk() .and. If(cPaisLoc $ "PTG",Gpea090TudOk(),.T.) .and. (If(lGP090CHK,ExecBlock( "GP090CHK", .F., .F., {cCodUser, cGrupos, aClone( aColsAnt ), aClone( aCols )} ),.T.)), lDelOk := Gpea090Grava(cAlias,cFil,cMat,aVirtual,aColsRec,nOpcx,.F.,.F.), lRet := .F.) }, OemToAnsi(STR0024))

				lExibMsg := .T.

				If nOpcX == 5 .And. lDelOk
					DelRecnos( cAlias , aColsRec )
					( cAlias )->( EvalTrigger() )
				EndIf

				//-- Ponto de entrada criado alteracao dos registros gravados
				If lRet .and. lGP090ALT
					ExecBlock("GP090ALT",.F.,.F.)
				EndIf
			EndIf
		EndIf

	End Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Libera Locks						                           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( lSRCLock .And. !lGp580Auto )
		FreeLocks( cAlias , NIL , .T. )
	ElseIf(lGp580Auto)
		(cAlias)->(MsUnlock())
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura o Conteudo do Parametro mv_par01       			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !Empty( uSvMvPar01 )
		mv_par01 := uSvMvPar01
	EndIf

	RestArea( aArea )

	//Na rescisao mantem a SRA posicionada no funcionario
	If ( IsInCallStack("GPEM040") .or. IsInCallStack("GPEM042") ) .And. Len(aAreaSRA) > 0
		RestArea( aAreaSRA )
	EndIf

	If ( nOpcX == 3 )
		MBrChgLoop(.F.)
	EndIf

	//Libera a HotKey utilizada
	If (IsInCallStack("GPEA580") .and. !(IsInCallStack("GPEM040")) .and. !(IsInCallStack("GPEM042")) .and. !(IsInCallStack("GPEM030")))
		SetKey(VK_F6, {||Nil})
	EndIf

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³                                                                       ³±±
±±³                                                                       ³±±
±±³                   ROTINAS DE CRITICA DE CAMPOS                        ³±±
±±³                                                                       ³±±
±±³                                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea090Grava³ Autor ³ Equipe Advanced RH  ³ Data ³26/05/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava no arquivo de Valores Variaveis   	                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA090                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function Gpea090Grava( cAlias , cFil , cMat , aVirtual , aRegAltera , nOpc, lMontaGetDados, lPerg )
Local aArea			:= GetArea()
Local aSRCCols		:= {}
Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
Local cCampo		:= ""
Local lTudoIgual	:= .F.
Local lAlteraOrig	:= .F.
Local nX 			:= 0
Local nY 			:= 0
Local nLenHeader	:= Len( aHeader 	)
Local nLenCols		:= Len( aSRCCols   	)
Local nLenRegAlt	:= Len( aRegAltera	)
Local nPosSeq		:= GdFieldPos( cPrefixo+"SEQ" )
Local nPosDeleted	:= GdFieldPos( "GDDELETED" )
Local nPosTp1		:= GdFieldPos( cPrefixo+"TIPO1"	, aHeader )
Local nPosTp2		:= GdFieldPos( cPrefixo+"TIPO2"	, aHeader )
Local aColsDel		:= {}
Local aRecAux		:= {}
Local aRecAux2		:= {}
Local aRecDel		:= {}
Local nCont			:= 0
Local nCols			:= 0
Local nPos			:= 0
Local nPosRec 		:= GdFieldPos( cPrefixo + "REC_WT", aHeader )
Local lBloqPON		:= ("1" $ SuperGetMv( "MV_BLOQPON",,"" ))
Local nPosCC 		:= 0
Local nPosItem 		:= 0
Local nPosClvl 		:= 0
Local nPosPd 		:= 0
Local lSalvaAlt		:= .T.
Local lContinua		:= .T.

cNumId		:= If (Type("cNumId") == "U", "", cNumId) //Recebida no GPEA580() para tratamento do Consignado.
lGp580Auto 	:= If (Type("lGp580Auto") == "U", .F., lGp580Auto)

If lGp580Auto
	aSRCCols		:= aCols
	lPerg := .F.
	nPosPd := GdFieldPos(cPrefixo + "PD")
Else
	aSRCCols		:= ( oGet:aCols )
EndIF

If !Empty(cNumId)
	fAjustAcols(@aSRCCols)
EndIf

nLenCols		:= Len( aSRCCols   	)

Begin Transaction

	IF ( nOpc == 5 ) //Exclusao
		If !( Gp090VldDel(@cKeyRCH,nOpc) )
	        lContinua := .F.
		EndIf

		// Multiplos vinculos desabilitado
		If (cPaisLoc == 'BRA' .AND. !lGp580Auto )
			fGP90ExcMV()
		EndIf

			/* Bloqueia a exclusão de verbas vindas do SIGAPON */
			If cPrefixo == "RGB_" .And. lBloqPON
				For nX := 1 To nLenCols
				    If aSRCCols[nX, nPosTp2] == "E"
				        Help(" ", 1, OemToAnsi(STR0040), Nil, OemToAnsi(STR0067), 1, 0 )
				        lContinua := .F.
				        Exit
				    EndIF
              Next nX
           EndIf

           If lContinua

				If !lMontaGetDados
					If cAlias == "RGB" .And. cPaisLoc == "BRA"

						nPosCC 		:= GdFieldPos("RGB_CC")
						nPosItem 	:= GdFieldPos("RGB_ITEM")
						nPosClvl 	:= GdFieldPos("RGB_CLVL")
						nPosPd 		:= GdFieldPos("RGB_PD")

						If !lItemClVl
							SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						Else
							SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						EndIf

						For nCont := 1 To Len(aRegAltera)

						    If lGp580Auto
						    	RGB->(DbGoTo(aRegAltera[nCont]))
								If !lItemClVl
									lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + RGB->RGB_PD + RGB->RGB_CC ) )
								Else
									lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + RGB->RGB_PD + RGB->RGB_CC + RGB->RGB_ITEM + RGB->RGB_CLVL ) )
								EndIf
						    Else
								If ( nPos := aScan( aSRCCols, { |x| x[nPosRec] == aRegAltera[nCont] } ) ) > 0
									If !lItemClVl
										lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + aSRCCols[nPos, nPosPd] + aSRCCols[nPos, nPosCC] ) )
									Else
										lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + aSRCCols[nPos, nPosPd] + aSRCCols[nPos, nPosCC] + aSRCCols[nPos, nPosItem] + aSRCCols[nPos, nPosClvl] ) )
									EndIf
								EndIf
							EndIf

							If !lAchou
								aAdd( aRecAux, aRegAltera[nCont] )
							Else
								aAdd( aRecAux2, aRegAltera[nCont])
							EndIf
						Next nCont

						aRegAltera := aClone(aRecAux)
					EndIf

					If !Empty(aRegAltera)
						PonDelRecnos( cAlias , aRegAltera )
						( cAlias )->( EvalTrigger() )
					EndIf

		            If !Empty(aRecAux2)
			            Help(" ", 1, OemToAnsi(STR0040), Nil, OemToAnsi(STR0069), 1, 0 )//"Atenção"##"Há verbas que não foram excluídas pois foram encontradas na tabela SRC"
		            EndIf
				EndIf

				If ( cPaisLoc =="ARG" )
					fDelRH8MAT( cRoteiro,cNumPagto, cFil, cMat  )
				EndIf

			EndIf

	Else //Inclusao ou Alteracao

		IF !ArrayCompare( aSRCCols , aColsAnt )
			lM2Modif := .T.

			If lPerg //Se deve fazer a pergunta ...
				If !(MsgYesNo( OemToAnsi( STR0025 ) ) )	//"Deseja salvar as alteracoes?"
					lSalvaAlt := .F.
				EndIf
			EndIf

			If lSalvaAlt
			dbSelectArea(cAlias)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Por causa da sequencia foi separado os registros deletados ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			GdSplitDel( aHeader , @aSRCCols , aRegAltera , @aColsDel , @aRecDel)

			// Elimina os registros deletados do aColsAnt
			If !Empty(aColsAnt)
				nCols := Len(aColsAnt)
				For nX := 1 To Len(aColsAnt)
					If Ascan(aColsDel,{|x| x[nPosRec]==aColsAnt[nX,nPosRec]}) > 0
						aColsAnt[nX,nPosRec] := NIL
					EndIf
				Next nX
				Do While ( nPos := Ascan(aColsAnt,{|x| x[nPosRec]==NIL}) ) > 0
					aDel(aColsAnt,nPos)
					Asize(aColsAnt,--nCols)
				EndDo
			EndIf
			If !Empty(aRecDel)
				For nX := 1 To Len(aRecDel)
					( cAlias )->( dbGoto( aRecDel[nX] ) )
					RecLock(cAlias,.F.,.T.)
					If aColsDel[nX,nPosDeleted]
						( cAlias )->( dbDelete() )
					Endif
					(cAlias)->( MsUnlock() )
				Next
			Endif

			If !Empty( aRegAltera )
				nLenRegAlt := Len(aRegAltera)
				For nX := 1 To nLenRegAlt
					lTudoIgual := ArrayCompare( aSRCCols[ nX ] , aColsAnt[nX] )
					IF ( lTudoIgual ) .and. !( aSRCCols[nX,nPosDeleted] )
						Loop
					EndIF

					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se Teve Apenas alteracao na sequencia de lancamento nao altera³
					³o Flag de Origem											   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					lAlteraOrig := .F.
					For nY := 1 To Len( aSRCCols[ nX ] )
						IF !( nY == nPosSeq )
							IF !( lTudoIgual := aSRCCols[ nX , nY ] == aColsAnt[ nX , nY ] )
							    lAlteraOrig := .T.
							EndIF
						EndIF
					Next nY
					( cAlias )->( dbGoto( aRegAltera[nX] ) )
					( cAlias )->( RecLock( cAlias , .F.))
					IF ( aSRCCols[nX,nPosDeleted] )
						(cAlias)->( dbDelete() )
					Else
						(cAlias)->(&(cPrefixo+"FILIAL"))	:= cFil
						(cAlias)->(&(cPrefixo+"MAT"))		:= cMat
						(cAlias)->(&(cPrefixo+"PROCES"))	:= cProcesso
						(cAlias)->(&(cPrefixo+"ROTEIR")) 	:= cRoteiroAnt
						(cAlias)->(&(cPrefixo+"POSTO")) 	:= cPosto
						(cAlias)->(&(cPrefixo+"TIPO2") ) 	:= If(! lGp580Auto, "I", aSRCCols[nX][nPosTp2])
						(cAlias)->(&(cPrefixo+"SEMANA"))	:= cNumPagto

						//Precisa verificar se o campo existe, pois este fonte é
						//utilizado para lançamentos nas tabelas SRC e RGB e o nome do campo
						//periodo é diferente nessas tabelas (RC_PERIODO e RGB_PERIOD)
						If (cAlias)->( FieldPos(cPrefixo+"PERIODO") ) > 0
							(cAlias)->(&(cPrefixo+"PERIODO")) 	:= cPeriodoAnt
						ElseIf (cAlias)->( FieldPos(cPrefixo+"PERIOD") ) > 0
							(cAlias)->(&(cPrefixo+"PERIOD")) 	:= cPeriodoAnt
						EndIf

						For nY := 1 To nLenHeader
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Obtem o Campo para Gravacao  							       ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							cCampo := aHeader[nY,2]

							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Os campo horas e valor serao gravados no momento da gravacao  ³
							³dos campos horinfo e valinfo.                                 ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							//Para lançamentos na tabela SRC o campo horas e valor não devem ser atualizados.
							//Para a tabela RGB estes campos devem ser atualizados.
							If cAlias == "SRC"
							    If cCampo == (cPrefixo+"HORAS") .OR. cCampo == (cPrefixo+"VALOR")
									Loop
							    EndIf
							EndIf

							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Nao Grava Campo Virtual									   ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							IF ( aScan(aVirtual,cCampo) # 0 )
								Loop
							EndIF

							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Se MV_HORASDE = "S" e Campo _HORINFO/_HORAS Converte Horas   ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							IF ( cDigHoras == "S" ) .And. ;
   						   	   ( (cCampo == (cPrefixo+"HORINFO")) .OR. (cCampo == (cPrefixo+"HORAS")) ) .And. ;
							   (aSRCCols[nX,nPosTp1] == "H" )
								xConteudo := fConvHr( aSRCCols[nX,nY] , "D" )
							Else
								xConteudo := aSRCCols[nX,nY]
							EndIF
							(cAlias)->( &cCampo ) := xConteudo

							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Gravar em horas e valor o mesmo valor informado em horinfo e  ³
							³valinfo.                                                      ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						    If cCampo == (cPrefixo+"HORINFO") .And. lAlteraOrig
								(cAlias)->( &(cPrefixo+"HORAS") ) := xConteudo
							ElseIf cCampo == (cPrefixo+"VALINFO") .And. lAlteraOrig
								(cAlias)->( &(cPrefixo+"VALOR") ) := xConteudo
						    EndIf

						Next nY
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Se Teve Apenas alteracao na sequencia de lancamento nao altera³
						³o Flag de Origem											   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						If ! lGp580Auto
							For nY := 1 To Len( aSRCCols[ nX ] )
								lTudoIgual := .T.
								IF !( nY == nPosSeq )
									IF !( lTudoIgual := aSRCCols[ nX , nY ] == aColsAnt[ nX , nY ] )
										(cAlias)->(&(cPrefixo+"TIPO2")) := "I"
									EndIF
								EndIF
							Next nY
						EndIf
					EndIF
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Destrava o Registro										   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					( cAlias )->( MsUnLock() )
				Next nX
				IF ( nLenCols > nLenRegAlt ) // Se Trata de Inclusao de Itens
					Gpea090GrInc( cAlias , cPrefixo , cFil , cMat , aVirtual , ( nLenRegAlt + 1 ) )
				EndIF
			Else
				Gpea090GrInc( cAlias , cPrefixo , cFil , cMat , aVirtual , 1 )
			EndIF

			( cAlias )->( EvalTrigger() )

			If ( lMontaGetDados )
				gp090MontaGetDados(cAlias, nOpc, cFil, cMat, @aVirtual, @aRegAltera, @aSRCCols, .F.)
			EndIf

			If lDelCalc
				Gp090Src() // Exclui dados da SRC
			EndIf
		EndIF

	EndIF
EndIF
	if lSalvaAlt .And. (lIntegDef) .And. (!IsInCallStack("GPEI090"))
		FwIntegDef("GPEA090")
	endIf
End Transaction

If Type( "lResM2" ) <> "U" .And. lResM2 .And. Type( "lAltRGB" ) <> "U"  //Tratamento para chamada da rotina atraves de tela de rescisão (Modelo 2)
	lAltRGB:= .T.
EndIf

//Se excluiu algum item integrado, retirada a data de integração do roteiro
If !Empty(cKeyRCH)
	RCH->(DbSetOrder(1))//RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
	If RCH->(DbSeek(cKeyRCH))
		RecLock("RCH",.F.)
		RCH->RCH_DTINTE := CtoD("")
		RCH->(MsUnLOck())
	EndIf
EndIf
RestArea(aArea)
Return( lContinua )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea090GrInc³ Autor ³Equipe Advanced RH   ³ Data ³ 24.05.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava os registros Incluidos na GetDados	                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Gpea090GrInc                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function Gpea090GrInc( cAlias , cPrefixo , cFil , cMat , aVirtual , nIniciar )

Local aSRCCols		:= {}
Local cCampo		:= ""
Local nLenHeader	:= Len( aHeader )
Local nLenCols		:= Len( aSRCCols )
Local nPosDeleted	:= GdFieldPos( "GDDELETED" )
Local nX			:= 0
Local nY 			:= 0
Local nPosTp1		:= GdFieldPos( cPrefixo+"TIPO1"	, aHeader )
Local nPosPd		:= GdFieldPos( cPrefixo+"PD"	, aHeader )
lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
If lGp580Auto
	aSRCCols		:= aCols
Else
	aSRCCols		:= ( oGet:aCols )
EndIF
nLenCols		:= Len( aSRCCols )

//Passa o valor do periodo para evitar erros
cPeriodoAnt := cPeriodo

For nX := nIniciar To nLenCols
	IF !( aSRCCols[nX,nPosDeleted] ) .And. !Empty(aSRCCols[nx,nPosPd])

	   	If !lItemClVl
			(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"SEMANA+"+cPrefixo+"SEQ" ) ) )
	    Else
	    	(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"ITEM+"+cPrefixo+"CLVL+"+cPrefixo+"SEMANA+"+cPrefixo+"SEQ" ) ) )
	    EndIf

	    (cAlias)->( RecLock(cAlias,.T.) )
		(cAlias)->(&(cPrefixo+"FILIAL"))	:= cFil
		(cAlias)->(&(cPrefixo+"MAT"))		:= cMat
		(cAlias)->(&(cPrefixo+"PROCES"))	:= cProcesso
		(cAlias)->(&(cPrefixo+"ROTEIR")) 	:= cRoteiroAnt
		(cAlias)->(&(cPrefixo+"POSTO")) 	:= cPosto
		(cAlias)->(&(cPrefixo+"TIPO2")) 	:= "I"
		(cAlias)->(&(cPrefixo+"SEMANA"))	:= cNumPagto

		//Precisa verificar se o campo existe, pois este fonte é
		//utilizado para lançamentos nas tabelas SRC e RGB e o nome do campo
		//periodo é diferente nessas tabelas (RC_PERIODO e RGB_PERIOD)
		If (cAlias)->( FieldPos(cPrefixo+"PERIODO") ) > 0
			(cAlias)->(&(cPrefixo+"PERIODO")) 	:= cPeriodoAnt
		ElseIf (cAlias)->( FieldPos(cPrefixo+"PERIOD") ) > 0
			(cAlias)->(&(cPrefixo+"PERIOD")) 	:= cPeriodoAnt
		EndIf

		For nY := 1 To nLenHeader
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Obtem o Campo para Gravacao  							       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cCampo := aHeader[nY,2]

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Os campo horas e valor serao gravados no momento da gravacao  ³
			³dos campos horinfo e valinfo.                                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			//Para lançamentos na tabela SRC o campo horas e valor não devem ser atualizados.
			//Para a tabela RGB estes campos devem ser atualizados.
			If cAlias == "SRC"
			    If cCampo == (cPrefixo+"HORAS") .OR. cCampo == (cPrefixo+"VALOR")
					Loop
			    EndIf
			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Nao Grava Campo Virtual									   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( aScan(aVirtual,cCampo) # 0 )
				Loop
			EndIF
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se MV_HORASDE = "S" e Campo _HORINFO/_HORAS Converte Horas   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF ( cDigHoras == "S" ) .And. ;
		   	   ( (cCampo == (cPrefixo+"HORINFO")) .OR. (cCampo == (cPrefixo+"HORAS")) ) .And. ;
			   (aSRCCols[nX,nPosTp1] == "H" )
				xConteudo := fConvHr( aSRCCols[nX,nY] , "D" )
			Else
				xConteudo := aSRCCols[nX,nY]
			EndIF
			(cAlias)->( &cCampo ) := xConteudo

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Gravar em horas e valor o mesmo valor informado em horinfo e  ³
			³valinfo.                                                      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		    If cCampo == (cPrefixo+"HORINFO")
				(cAlias)->( &(cPrefixo+"HORAS") ) := xConteudo
			ElseIf cCampo == (cPrefixo+"VALINFO")
				(cAlias)->( &(cPrefixo+"VALOR") ) := xConteudo
		    EndIf

		Next nY
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Destrava o Registro										   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		( cAlias )->( MsUnLock() )
	EndIF
Next nX

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea090LinOk³ Autor ³ Marinaldo de Jesus  ³ Data ³26/05/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Critica linha digitada                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA090                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gpea090LinOk( oBrowse )

Local aCriterio		:= {}
Local aCposKey		:= {}
Local lLinOk		:= .T.
Local cPrefixo		:= ( PrefixoCpo( cLancAlias ) + "_" )
Local nPosSeq		:= GdFieldPos(cPrefixo+"SEQ") //If(cLancAlias=="RGB", GdFieldPos("RGB_SEQ"), 0 )
Local nPosTipo  	:= GdFieldPos(cPrefixo+"TIPO1")
Local nPosTipo2  	:= GdFieldPos(cPrefixo+"TIPO2")
Local nPosHoras 	:= If(cLancAlias=="SRC", GdFieldPos("RC_HORINFO"), GdFieldPos("RGB_HORAS"))
Local nPosValor 	:= If(cLancAlias=="SRC", GdFieldPos("RC_VALINFO"), GdFieldPos("RGB_VALOR"))
Local nPosHorasC 	:= GdFieldPos(cPrefixo+"HORAS")
Local nPosValorC 	:= GdFieldPos(cPrefixo+"VALOR")
Local nPosDtRef 	:= GdFieldPos(cPrefixo+"DTREF")
Local nPosPD 		:= GdFieldPos(cPrefixo+"PD")
Local nPosOri		:= GdFieldPos(cPrefixo+"ROTORI")
Local nPosRec		:= GdFieldPos(cPrefixo+"REC_WT" )
Local nPosItem 	 	:= GdFieldPos(cPrefixo+"ITEM" )
Local nPosClVl   	:= GdFieldPos(cPrefixo+"CLVL" )
Local nPosCc     	:= GdFieldPos(cPrefixo+"CC" )
Local nPosNumId		:= GdFieldPos("RGB_NUMID")
Local nLimHorDia 	:= gp090GetRCA("P_LIMEXDIA")
Local nLimDe		:= 0
Local nLimAte		:= 0
Local dDataAtual	:= Ctod("")
Local nHoraAtual	:= 0
Local dDataNX       := Ctod("")
Local nHoraNX       := 0
Local nPosDeleted	:= GdFieldPos( "GDDELETED" )
Local Nx            := 1
lOCAL nOrdem		:= 1
Local aArea			:= getArea()
Local nCount		:= 1
Local nCount1		:= 1
Local nQuant		:=  0
Local nQuant1		:=  0
Local cVerba		:= ""
Local cMensg		:= ""
Local lDataOk		:= .T.
Local lAchou		:= .F.
Local lBloqPON		:= ("1" $ SuperGetMv( "MV_BLOQPON",,"" ))
Local nAux			:= 0
Local nPosLOTPLS	:= GdFieldPos(cPrefixo+"LOTPLS") //Variável para controle na integração do SIGAPLS
Local nPosCODRDA	:= GdFieldPos(cPrefixo+"CODRDA") //Variável para controle na integração do SIGAPLS
Local nPosDTREF		:= GdFieldPos(cPrefixo+"DTREF")
Local nAuxPLS		:= 0 //Variável para controle na integração do SIGAPLS
//Local lGrupo        := IIF(!Empty(cGrupo),Posicione("RGF",1,xFILIAL("RGF"),"RGF_CODIGO") )                                          //Busca Qual Grupo Pertence a Verba
Local lIntPFS    := SuperGetMV("MV_JINTGPE", .F., "1") == "2"

// Variavel n nao estara criada quando a funcao de validacao
// for chamada pelo LostFocus da GetDados. Se estiver criada,
// continua com o valor de n, senao, recebe a linha que estava
// selecionada da GetDados no momento que perdeu o foco.
n 	   := If(Type("n")="U" .or. n > Len(aCols),oGet:nat, n)

lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
If !lGp580Auto
	aCols  := oGet:aCols
ElseIf !IsInCallStack("MSGETDAUTO") .And. Type("aAutoItens") == "A" .And. !Empty(aAutoItens) .And. nPosDTREF > 0 .And. Len(aAutoItens) >= n .And. aScan( aAutoItens[n], { |x| AllTrim(x[1]) == "RGB_DTREF" } ) == 0 
	If Empty(aCols[n, nPosRec]) .And. aCols[n, nPosTipo2] <> "F"  
		aCols[n, nPosDTREF] := cToD("//")
	EndIf
EndIf

Begin Sequence

	If ArrayCompare( aCols , aColsAnt )
		Break
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se periodo de lancamento esta bloqueado			     ³
	//³Se for roteiro de Adiantamento, realiza validacao por verbas  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cRoteiro $ fGetCalcRot('2') // Roteiro de Adiantamento
		If !fVldAccess( SRA->RA_FILIAL,IIF(!Empty( aCols[n, nPosDtRef]), aCols[n, nPosDtRef], dDataBase ),cNumPagto,.T.,cRoteiro, "3", "V" )
			lLinOk := .F.
			Break
		EndIf
	ElseIf !fVldAccess( SRA->RA_FILIAL,IIF(!Empty( aCols[n, nPosDtRef]), aCols[n, nPosDtRef], dDataBase ),cNumPagto,.T., cRoteiro)
		lLinOk := .F.
		Break
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	|Bloqueia Verbas vindas do SIGAPON							   |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If (nPosTipo2 > 0)
		If lBloqPON .And. Upper(aCols[n, nPosTipo2]) == "E"
			If n <= Len( aColsAnt ) .And. !fCompArray( aColsAnt[n], aCols[n] )
				fVldAltPon( "1" )	//?-Apresenta Mensagem
				lLinOk := .F.
				Break
			EndIf
		EndIf
	EndIf

	If cPaisLoc == "BRA" .And. !IsBlind() .And. (nPosNumId == 0 .Or. Empty(acols[n,nPosNumId])) .And. aCols[n, nPosTipo2] == "I" .And. RetValSrv( aCols[n, nPosPD], SRA->RA_FILIAL, 'RV_CODFOL', 1 ) $ '0086/0248'
		Aviso(STR0040,STR0116)  //"ATENCAO !"###""Necessário preencher campo Num. Identif (RGB) com as datas inicial e final do período aquisitivo correspondente à verba lançada, no formato AAAAMMDD - AAAAMMDD para que o lançamento seja impresso corretamente no TRCT. Este lançamento deve ser feito pela tela de rescisão"
		lLinOk := .F.
		Break
	EndIf


	//Se a verba for oriunda de outro roteiro
	If ! lGp580Auto
		If ( ( nPosOri > 0 .And. ! Empty(aCols[n, nPosOri]) ) .Or. aCols[n, nPosTipo2] == "A" ) .and. n <= Len( aColsAnt ) .And. !fCompArray( aColsAnt[n], aCols[n] )
			If lExibMsg
				lExibMsg := .F.
				If ! (MsgYesNo( OemToAnsi( STR0065 )))	// "Esta verba foi gerada por outro roteiro. Deseja confirmar a alteração?"
					lLinOk := .F.
					Break
				EndIf
			Endif
		EndIf
	EndIf

	If cLancAlias == "RGB"
		If nPosLOTPLS > 0 .AND. nPosCODRDA > 0 .AND. !(EmpTy(aCols[n,nPosLOTPLS])) .and. nModulo <> 77
			nAuxPLS := aScan( aColsAnt, { |x| ( x[nPosRec] == aCols[n,nPosRec] ) } )
			If nAuxPLS > 0 .AND. !PLSxGPEVLD(aCols[n], aColsAnt[nAuxPLS])
				If lIntPFS
					MsgInfo(STR0111 + aCols[n,nPosLOTPLS] + STR0119) //"O registro não pode ser Alterado, pois sua origem é um lote de pagamento [ " ### " ] do módulo SIGAPFS."
				Else

					MsgInfo(STR0111 + aCols[n,nPosLOTPLS] + STR0112) //"O registro não pode ser Alterado, pois sua origem é um lote de pagamento [ " ### " ] do módulo SIGAPLS."

				EndIf
				lLinOk := .F.
				Break
			EndIf
		EndIf
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Monta a Sequencia da Verba "Chave Inicial Codigo da Verba"    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !( lLinOk := fMontaSeq( cPrefixo+"PD", ,cPrefixo, aGhCols ) )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Para Linhas Deletadas o Retorno devera ser "True"             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( GdDeleted() )
			lLinOk := .T.
		EndIF
		Break
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	|Bloqueia Verbas vindas do SIGAPON							   |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
//	If lBloqPON .And. Upper(aCols[n, nPosTipo2]) == "E"
//		If n <= Len( aColsAnt ) .And. !fCompArray( aColsAnt[n], aCols[n] )
//			fVldAltPon( "1" )	//?-Apresenta Mensagem
//			lLinOk := .F.
//			Break
//		EndIf
//	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se a Linha da GetDados Nao Estiver Deletada				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF !( GdDeleted() )
		If cPaisLoc == "PER"
			If !(lLinOk := RGBRucValid())
				Break
			EndIf
		EndIf
		If (FwOnSpFilter(cLancAlias))
			dbSelectArea(cLancAlias)
			nPosCC	   := GdFieldPos(cPrefixo + "CC")
			nPosItem   := GdFieldPos(cPrefixo + "ITEM")
			nPosClvl   := GdFieldPos(cPrefixo + "CLVL")

				cKey := xFilial(cLancAlias)
				cKey += cProcesso
				cKey += cMat
				cKey += cPeriodo
				cKey += cNumPagto
				cKey += cRoteiro
				cKey += aCols[n, nPosPd]
				cKey += aCols[n, nPosCC]
				If lItemClVl
					cKey += aCols[n, nPosItem]
					cKey += aCols[n, nPosClvl]
				EndIf
				cKey += aCols[n, nPosSeq]
				cKey += DToS(aCols[n, nPosDtRef])

			SpFilterOff( { "SRA", cLancAlias } )

			If (cLancAlias == "RGB")
				If !lItemClVl
					nOrdem := RetOrder(cLancAlias, "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_SEQ+DTOS(RGB_DTREF)")
				 Else
				 	nOrdem := RetOrder(cLancAlias, "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_ITEM+RGB_CLVL+RGB_SEQ+DTOS(RGB_DTREF)")
				 EndIf
			elseif(cLancAlias == "SRC")
				If !lItemClVl
					nOrdem := RetOrder(cLancAlias, "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)")
				Else
					nOrdem := RetOrder(cLancAlias, "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)")
				EndIf
			endif

			(cLancAlias)->(dbSetOrder( nOrdem ))
			If (cLancAlias)->(dbSeek(cKey))
				nPosRec := GdFieldPos( cLancAlias + "_REC_WT" )
				cKeyAux := cKey
				While (cLancAlias)->(!Eof()) .AND. cKey == cKeyAux

					If nPosRec > 0 .AND. aCols[n, nPosRec] <> (cLancAlias)->(Recno())
						lLinOk := .F.
						SpFilterOff( { "SRA", cLancAlias }, .F. )
						MsgAlert(OemToAnsi(STR0042))	 //Registro já gravado
						Break
					EndIF

					(cLancAlias)->(dbSkip())
					//Monta nova chave auxiliar para verificar se ainda continua no seek
						cKeyAux := (cLancAlias) ->&(cPrefixo + "FILIAL" )
						cKeyAux += (cLancAlias) ->&(cPrefixo + "PROCES" )
						cKeyAux += (cLancAlias) ->&(cPrefixo + "MAT" )
						cKeyAux += (cLancAlias) ->&(cPrefixo + iif(cLancAlias == "SRC", "PERIODO", "PERIOD" ))
						cKeyAux += (cLancAlias) ->&(cPrefixo + "SEMANA" )
						cKeyAux += (cLancAlias) ->&(cPrefixo + "ROTEIR" )
						cKeyAux += (cLancAlias) ->&(cPrefixo + "PD" )
						cKeyAux += (cLancAlias) ->&(cPrefixo + "CC" )
						If lItemClVl
							cKeyAux += (cLancAlias) ->&(cPrefixo + "ITEM" )
							cKeyAux += (cLancAlias) ->&(cPrefixo + "CLVL" )
						EndIf
						cKeyAux += (cLancAlias) ->&(cPrefixo + "SEQ" )
						cKeyAux += DtoS((cLancAlias) ->&(cPrefixo + "DTREF" ))
				EndDo
			EndIf
			SpFilterOff( { "SRA", cLancAlias }, .F. )
		Endif
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Itens Duplicados na GetDados						   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_LCTODIA" ) == "S" )
			aCposKey := { cPrefixo+"PD" , cPrefixo+"DTREF" , If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN")}
		Else
			If ( cDigSemana == "S" )
				 If !lItemClvl
					aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" , cPrefixo+"SEQ", cPrefixo+"DTREF", If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN") }
				 Else
					aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" ,cPrefixo+"ITEM",cPrefixo+"CLVL", cPrefixo+"SEQ", cPrefixo+"DTREF", If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN") }
				 EndIf
			Else
				If !lItemClvl
					aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" , cPrefixo+"SEMANA" , cPrefixo+"SEQ", cPrefixo+"DTREF", If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN") }
				Else
					aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" ,cPrefixo+"ITEM",cPrefixo+"CLVL", cPrefixo+"SEMANA" , cPrefixo+"SEQ", cPrefixo+"DTREF", If(cLancAlias=="SRC","RC_CODFUNC","RGB_CODFUN") }
				EndIf
			EndIf
		EndIf

		IF !( lLinOk := GdCheckKey( aCposKey , 4 ) )
			Break
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Se o Campos Estao Devidamente Preenchidos		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !( SRA->RA_TIPOPGT == "S" ) .or. ( cDigSemana == "S" )
			aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" , cPrefixo+"TIPO1" }
		Else
			aCposKey := { cPrefixo+"PD" , cPrefixo+"CC" , cPrefixo+"TIPO1" , cPrefixo+"SEMANA" }
		EndIF
		IF !( lLinOk := GdNoEmpty( aCposKey ) )
			Break
		EndIF

		//Não valida se foi digitado horas ou valor na rescisão complementar para possibilitar zerar uma verba no cálculo.
		If !(fGetTipoRot(cRoteiro) == "4" .and. !Empty(SRA->RA_DEMISSA))
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Se a Quantidade de Horas Esta Devidamente Preenchida³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF !( lLinOk := !( ( aCols[n, nPosTipo] $ "DH" ) .and. ( aCols[n, nPosHoras] == 0 ) ) )
				Help(" ",1,"A040SHORAS")
				Break
			EndIF

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Se a Quantidade de Horas ou Valor Estao  Devidamente³
			³ Preenchidos												   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF !( lLinOk := !( aCols[n, nPosTipo] $ "V"  .and. ( aCols[n, nPosValor] == 0 ) ) )
				Help(" ",1,"A040SVAHOR")
				Break
			EndIF

			//--Checar campo valor ou horas para lancamentos diferentes de calculad
			If aCols[n, nPosValor] == 0 .and. aCols[n, nPosHoras] == 0.00 .and. aCols[n, nPosTipo2] #  "C"
				Help(" ",1,"A040SVAHOR")
				lRet := .F.
				Break
			Endif

			//--Checar campo valor ou horas para lancamentos diferentes de calculad
			If aCols[n, nPosValorC] == 0 .and. aCols[n, nPosHorasC] == 0.00 .and. aCols[n, nPosTipo2] ==  "C"
				Help(" ",1,"A040SVAHOR")
				lRet := .F.
				Break
			EndIF
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Se a Quantidade de Horas ou Valor Estao  conforme os³
		³ limites do cadastro de verbas.							   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		// Valor
		IF (aCols[n, nPosTipo] $ "V")
			nLimDe  := PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_VLIMDE" )
			nLimAte := PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_VLIMATE" )
			If (nLimDe != 0) .OR. (nLimAte != 0)
				If !(aCols[n, nPosValor] >= nLimDe .AND. ;
					 aCols[n, nPosValor] <= nLimAte)
					Help(" ",1,"GPA120LIM")
					lLinOk := .F.
					Break
				EndIf
			EndIf
  		// Horas
  		ElseIf (aCols[n, nPosTipo] $ "DH")
  			nLimDe  := PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_RLIMDE" )
			nLimAte := PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_RLIMATE" )
			If (nLimDe != 0) .OR. (nLimAte != 0)
				If !(aCols[n, nPosHoras] >= nLimDe .AND.;
	   				 aCols[n, nPosHoras] <= nLimAte)
					Help(" ",1,"GPA120LIM")
					lLinOk := .F.
					Break
				EndIf
			EndIf
  		EndIF

		If !Empty(aCols[n, nPosPD])
		 	If PosSRV(aCols[n, nPosPD], SRA->RA_FILIAL, "RV_LCTODIA" ) == "S" .And. Empty(aCols[n, nPosDtRef])
		 		Help( "", 1, OemToAnsi( STR0040 ), NIL, OemToAnsi( STR0070 ), 1, 0 )//"Atenção"##"Lançamento sem data de referência informada."
		 		lLinOk := .F.
				Break
		 	ElseIf aCols[n][nPosTipo2] == "I" .AND. PosSRV(aCols[n, nPosPD], SRA->RA_FILIAL, "RV_LCTODIA" ) == "N" .And. !Empty(aCols[n, nPosDtRef])  //valida apenas verbas informadas
		 		Help( "", 1, OemToAnsi( STR0040 ), NIL, OemToAnsi( STR0071 ), 1, 0 )//"Atenção"##"Data de referência não deve ser informada pois a verba não possui configuração para lançamento diário"
		 		lLinOk := .F.
		 		Break
		 	EndIf
		EndIf

		//-
		//- Localização para Portugal - verificação de Limites de Horas Extras Dia
		//-

		If cPaisLoc == "PTG"
		   If ( PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_HE" ) == "S" )
		      dDataAtual := aCols[n,nPosDtRef]
		      nHoraAtual := aCols[n,nPosHoras]
		      nTotHora   := 0
		      For nx := 1 to Len(aCols)
		          dDataNx := aCols[nx,nPosDtRef]
		          nHoraNx := aCols[nx,nPosHoras]
		          If dDataNx == dDataAtual .and. Nx <> n .and. !Acols[nx,nPosDeleted]
		             nTotHora += nHoraNx
		          EndIf
		      Next


		      If !Empty(nLimHorDia)
		         If nHoraAtual+nTotHora > VAL(nLimHorDia)
		            cMsgHelp	:= OemtoAnsi(STR0037)                            //"Limite de Horas Extras Diarias
		            cMsgHelp    += CHR(13)+CHR(10)
		            cMsgHelp    += OemtoAnsi(STR0038) + " " + DTOC(dDataAtual)   //Excedido para o Dia:
		            cMsgHelp    += CHR(13)+CHR(10)
		            cMsgHelp    += OemtoAnsi(STR0039) + " P_LIMEXDIA" + "= "+nLimHorDia
		            Help( "" , 1 , "LIMHEXCED" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
		            lLinOk := .F.
		         EndIf
  		      EndIf
  		   EndIf
		EndIf

		If lLinOk
			// Se o campo de filtro numero de pagamento estiver preenchido, o
			// campo RC_SEMANA da GetDados devera ser o informado no filtro.
			// Se o campo de filtro numero de pagamento nao estiver preenchido, o
			// campo RC_SEMANA da GetDados podera ser qualquer numero de pagamento
			// da consulta padrao.
			lLinOk := gp090NrPagtoValid(cNumPagto, cPrefixo)
		EndIf

		If lLinOk
			If aCols[n, nPosTipo2] == "I" .And. !( PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_LEEINC" ) == "1" )
				MsgAlert(OemToAnsi(STR0061))	 //Não permitido a inclusão de lançamentos para esta verba.
				lLinOk := .F.
			EndIf
		EndIf
	EndIF
	//Realiza chamada do PE para todas as linhas, inclusive as deletadas.
	If lLinOk .And. lGP090Ok
		lLinOk := ExecBlock( "GP090OK", .F., .F., {aCols[n]} )
	EndIf

	// Validação para lançamento de faltas quando usa o cálculo outomático de benefícios
	If lLinOk
		If ( PosSRV(aCols[n, nPosPD], xFilial("SRV", SRA->RA_FILIAL), "RV_CODFOL" ) == "0054" )
			CargaCrit("VA', 'VR", @aCriterio, cDataIni, cDataFim)
			If Len(aCriterio) > 0
				If( aCols[n, nPosHoras] > 1) .Or. ( Empty(aCols[n, nPosDtRef]) )
					MsgAlert(OemToAnsi(STR0086))	// Para que as faltas sejam consideradas corretamente no cálculo automático de benefícios devem ser informadas em dias, um dia por lançamento e com a data de referência preenchida.
					lLinOk := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	If lLinOk .and. !lGp580Auto
		If !Empty(aCols[n,nPosRec])
			If ( nAux := aScan( aColsAnt, { |x| ( x[nPosRec] == aCols[n,nPosRec] ) } ) ) > 0
				If !ArrayCompare(aColsAnt[nAux], aCols[n])
					Iif(nAchou == 0 .OR. nAchou != n, lAchouMsg := .T., lAchouMsg := .F. )

					If !lItemClVl
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + aCols[n,nPosPD] + aCols[n,nPosCC] ) )
					Else
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + aCols[n,nPosPD] + aCols[n,nPosCC] + aCols[n,nPosItem] + aCols[n,nPosClvl] ) )
					EndIf

					If lAchou	.and. lAchouMsg
						MsgInfo( OemToAnsi(STR0089) + Chr(13)+ Chr(10) +;  //"Esta verba já foi calculada e encontra-se na tabela de movimento (SRC). Para que a alteração tenha efeito, deverá efetuar o recalculo.
						OemToAnsi(STR0078))			//"Para recalcular os lançamentos use a tecla F6 (Calcular)."
						lAchouMsg := .F.
						nAchou := n
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

End Sequence

RestArea(aArea)

Return( lLinOk )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ

±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea090TudOk³ Autor ³Equipe Advanced RH   ³ Data ³09/01/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica o Tudo OK                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA090                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gpea090TudOk( oBrowse )

LOCAL aAreaRCH
Local aSRVMult	 := {}
Local aSRCCols   := {}
Local cBkpPer	 := cPeriodo
Local cBkpRot	 := cRoteiro
Local cPrefixo   := ( PrefixoCpo( cLancAlias ) + "_" )
Local lRetorna   := .T.
Local dDataAtual := Ctod("")
Local dDataNX    := Ctod("")
Local nHoraAtual := 0
Local Nx         := 1
Local nY         := 1
Local nPosDel	:= len(aHeader)+1
Local nPosItem 	 := GdFieldPos( cPrefixo+"ITEM" )
Local nPosClVl   := GdFieldPos( cPrefixo+"CLVL" )
Local nPosPd     := GdFieldPos( cPrefixo+"PD" )
Local nPosCc     := GdFieldPos( cPrefixo+"CC" )
Local nPosTipo2  := GdFieldPos( cPrefixo+"TIPO2" )
Local nPosHor 	 := If(cLancAlias=="SRC", GdFieldPos("RC_HORINFO"), GdFieldPos("RGB_HORAS"))
Local nPosVal 	 := If(cLancAlias=="SRC", GdFieldPos("RC_VALINFO"), GdFieldPos("RGB_VALOR"))
Local nPosDtRef  := GdFieldPos(cPrefixo+"DTREF")
Local nLimHorMes := gp090GetRCA("P_LIMEXMES")
Local nHoraNX    := 0
Local nPosDeleted:= GdFieldPos( "GDDELETED" )
Local cRotPermit := ""
Local nOrdem	 := 0
Local lRetRot	 := .T.
n 	             := If(Type("n")="U",oGet:nat, n)

lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)

If lGp580Auto
	aSRCCols   := aCols
Else
	aSRCCols   := ( oGet:aCols )
EndIf
Continua         := .F.
nValCalc         := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Testa Total do Lan‡amento com Total Calculado                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nValLanc # 0
	nValCalc := Val( SRA->RA_MAT )
	If !lItemClvl
		aEval( aSRCCols, { |X| nValCalc += Val(X[nPosPd]) + X[nPosVal] + X[nPosHor] + Val(X[nPosCc]) } )
	Else
		aEval( aSRCCols, { |X| nValCalc += Val(X[nPosPd]) + X[nPosVal] + X[nPosHor] + Val(X[nPosCc]) + Val(X[nPosItem]) + Val(X[nPosClVl]) } )
	EndIf
	If Len(aColsAnt) > 0
		If !lItemClvl
			aEval( aColsAnt, { |X| nValCalc -=( Val(X[nPosPd]) + X[nPosVal] + X[nPosHor] + Val(X[nPosCc] ) ) } )
		Else
			aEval( aColsAnt, { |X| nValCalc -=( Val(X[nPosPd]) + X[nPosVal] + X[nPosHor] + Val(X[nPosCc]) + Val(X[nPosItem]) + Val(X[nPosClVl] ) ) } )
		EndIf
	Endif
	If Round(nValCalc,3) # Round(nValLanc,3)
		Help(" ",1,"NAOBATELAW")
		lRetorna := .F.
	Endif
Endif
//-
//- Localização para Portugal - verificação de Limites de Horas Extras no Mês
//-
IF cPaisLoc == "PTG"

   IF ( PosSRV(aCols[n, nPosPD] , SRA->RA_FILIAL , "RV_HE" ) == "S" )
      dDataAtual := aCols[n,nPosDtRef]
	  nHoraAtual := aCols[n,nPosHor]
	  nTotHora   := 0
	  For nx := 1 to Len(aCols)
	      dDataNx := aCols[nx,nPosDtRef]
	      nHoraNx := aCols[nx,nPosHor]
	      IF dDataAtual >= cDataIni .AND. dDataAtual <= cDataFim .and. Nx <> n .and. !Acols[nx,nPosDeleted]
	         nTotHora += nHoraNx
	      ENDIF
	  Next


	  If !Empty(nLimHorMes)                      //Se o Parametro não For Vazio
	     If nHoraAtual+nTotHora > VAL(nLimHorMes)
		    cMsgHelp	:= OemtoAnsi(STR0036)   // "Limite de Horas Extras Mensal Excedido
		    cMsgHelp    += CHR(13) + CHR(10)
		    cMsgHelp    += OemtoAnsi(STR0023) + " "+DTOC(cDataIni)+" - "+DTOC(cDataFim)   //Periodo:
		    cMsgHelp    += CHR(13) + CHR(10)
		    cMsgHelp    += OemtoAnsi(STR0039) + " P_LIMEXMES" + "= "+nLimHorMes
			Help( "" , 1 , "LIMHEXCEM" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
		    lRetorna := .F.
		 EndIf
  	  EndIF
   ENDIF
ENDIF
//Condicao eSocial para apresentar a tela de Multiplos Vinculos
//Se Cliente quiser usar execAuto para Multiplos Vinculos, devera usar o model diretamente
//Multiplos vinculos desabilitado

If !Empty( cProcesso ) .AND. !Empty( cPeriodo ).AND. !Empty( cRoteiro )
	aAreaRCH := RCH->(GETAREA())
	DbSelectArea( "RCH" )
	nOrdem := RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR")
	lRetRot := fPosPeriodo( xFilial( "RCH" ), cProcesso, cPeriodo, cNumPagto, cRoteiro, NIL, NIL, nOrdem )
	RESTAREA(aAreaRCH)
EndIf


If !lGp580Auto .AND. lRetorna .AND. cPaisLoc=="BRA" .AND. lRetRot
	aEval( aCols, {|x| aAdd( aSRVMult, {x[nPosDel], PosSrv(x[nPosPd],FwxFilial("SRV",SRA->RA_FILIAL),{"RV_CODFOL"}), x[nPosTipo2] }  ) } )
	If cRoteiro == "132"
		cPeriodo 	:= SubStr(cPeriodo, 1, 4)+"13"
	ElseIf cRoteiro == "FER"
		cRoteiro	:= If(SRA->RA_CATFUNC $ "P*A", fGetCalcRot("9"), fGetRotOrdinar())
	EndIf

	cRotPermit := fGetTipoRot(cRoteiro)
	//Somente irá abrir a tela de Multiplos vínculos se for para os roteiros FOL, AUT ou Segunda parcela do 13 (132)
	If (!EMPTY(cRotPermit) .AND. cRotPermit $ "1|6|9") .AND. (aScan(aSRVMult, {|y| y[2][1] $ '288|0288|289|0289|290|0290|291|0291|396|0396|397|0397' .And. !y[1] .And. y[3] != "K"})) > 0
		oModel     	:= FWLoadModel( "GPEA924")
		cAliasRAW	:= "RAW"
		dbSelectArea("RAW")
		(cAliasRAW)->(dbSetOrder(1))
		If (cAliasRAW)->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo+IIF(cRotPermit == "6", "2", "1")+cProcesso+cRoteiro) )
			oModel:SetOperation( MODEL_OPERATION_UPDATE )
			oModel:Activate()
			FWExecView(OemtoAnsi(STR0030), "GPEA924", MODEL_OPERATION_UPDATE,,{||.T.},,,,,,,oModel) //"Multiplos Vinculos"
		Else
			oModel:SetOperation( MODEL_OPERATION_INSERT )
			oModel:Activate()
			FWExecView(OemtoAnsi(STR0030), "GPEA924", MODEL_OPERATION_INSERT,,{||.T.}) //"Multiplos Vinculos"
		EndIf
		// Desativando o Model
		oModel:DeActivate()
	ElseIf aScan(aSRVMult, {|y|y[2][1] $ '288|0288|289|0289|290|0290|291|0291|396|0396|397|0397' .And. y[1] .And. y[3] != "K"}) > 0
		fGP90ExcMV()
	Endif
	cPeriodo := cBkpPer
	cRoteiro := cBkpRot
EndIf

For nY := 1 to Len(aSRCCols)
	n := nY
	If !Gpea090LinOk()
		lRetorna := .F.
	EndIf
Next nY

Return( lRetorna )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp090Mov  ³ Autor ³ Marcos Stiefano       ³ Data ³ 28/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Move o cursor para posicionamento pelo tipo                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp090Mov(lMov)

Local ni		:= 0
Local nPosicao	:= 0
Local nPosTip	:= 0
Local nStep		:= 0
Local nPulos	:= 0
Local cCampo	:= cCampo := &(ReadVar())

DEFAULT lMov := .F.

lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
If !lMov
	Return( .T. )
Endif

nPosTip	:= GdFieldPos( "RC_TIPO1" )
IF ( cCampo == "H" .Or. cCampo == "D" )
	nPosicao := GdFieldPos( "RC_HORINFO" )
ElseIF ( cCampo == "V" .Or. cCampo == "F" )
	nPosicao := GdFieldPos( "RC_VALINFO" )
EndIF

nStep  := IF(nPosTip > nPosicao , -1 , 1)
nPulos := Abs( nPosicao - nPosTip )

If ( nStep > 0 )
	nPulos--
Else
	If ( nPostip != Len(aHeader) )
		nPulos++
	Endif
Endif

IF ( Alltrim(Substr(readvar(),4)) == "RC_TIPO1" )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Garante o Posicionamento na Coluna Chamadora da Funcao.       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lGp580Auto
		While ( oGet:oBrowse:nColPos <> nPosTip )
	   		  IF ( oGet:oBrowse:nColPos > nPosTip )
				  	oGet:oBrowse:GoLeft()
			  ElseIF ( oGet:oBrowse:nColPos < nPosTip )
					oGet:oBrowse:GoRight()
			  EndIF
		End While
	EndIf

EndIF

If !lGp580Auto
	For ni := 1 to nPulos
		If ( nStep > 0 )
			oGet:oBrowse:GoRight()
		Else
			oGet:oBrowse:GoLeft()
		Endif
	Next
EndIf

IF ( nPulos <= 0 )
	oGet:oBrowse:bEditCol:= { || AllWaysTrue() }
EndIF

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp090Pula ³ Autor ³ Marcos Stiefano       ³ Data ³ 28/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Move o cursor para posicionamento pelo tipo Horas           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gp090Pula(lPul)

Local nPosTip	:= GdFieldPos( "RC_TIPO1" )
Local nPosh		:= GdFieldPos( "RC_HORA" )
Local nPosv		:= GdFieldPos( "RC_VALOR" )

DEFAULT lPul := .F.

lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
If !lPul
	Return( .T. )
Endif

if !(aCols[n,nPosTip] $ "VHFD")
	HELP(" ",1,"GP090TIPO")
	Return( .F. )
Endif

If !lGp580Auto
	IF aCols[n,nPosTip] $ "HD" .And. nPosv <= nPosh+1
		oGet:oBrowse:GoRight()
	Endif

	IF aCols[n,nPosTip] == "V" .And. nPosh <= nPosv+1
		oGet:oBrowse:GoRight()
	Endif
EndIf

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fTotLanc()³ Autor ³ M. Stiefano           ³ Data ³ 27/06/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta tela para informar Total do Lote.                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fTotLanc()

Local oDlg1
Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdvSize		:= MsAdvSize( , .T., 390)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 15 , 5 }
aAdd( aObjCoords , { 000 , 005 , .T. , .F. } )
aAdd( aObjCoords , { 000 , 020 , .T. , .F. } )
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE MSDIALOG oDlg1 FROM aAdvSize[7],0 TO aAdvSize[6]*0.40,aAdvSize[5] TITLE OemToAnsi(STR0016) PIXEL  //"Lan‡amentos"

	@ aObjSize[2,1], aObjSize[2,2] SAY STR0017 SIZE 48, 7 OF oDlg1 PIXEL // "Total do Lote:"
	@ aObjSize[2,1], aObjSize[2,2]+45 MSGET nValLanc SIZE 46, 10 OF oDlg1 PIXEL Picture "@E 999,999,999.99"
	@ aObjSize[2,1], (aObjSize[2,4]*0.50) SAY STR0018 SIZE 48, 7 OF oDlg1 PIXEL // "Total Calculado:"
	@ aObjSize[2,1], (aObjSize[2,4]*0.50)+50 MSGET nValCalc SIZE 46, 10 OF oDlg1 PIXEL Picture "@E 999,999,999.99" WHEN .F.

	bSet15 := {||nOpcA := 1, oDlg1:End()}
	bSet24 := {||nOpcA := 0, oDlg1:End()}

ACTIVATE MSDIALOG oDlg1 ON INIT EnchoiceBar( oDlg1 , bSet15 , bSet24 ) CENTERED

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fLimEdit()³ Autor ³ Mauro                 ³ Data ³ 05/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Voltar o bDitcol ao Padrao apos pular coluna.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fLimEdit()

	oGet:oBrowse:bEditCol:= { || AllWaysTrue() }

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp090MovPD³ Autor ³ Marinaldo de Jesus    ³ Data ³11/05/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Posiciona Cursor de Acordo com o Tipo da Verba.             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³lMov - Logico define se devera haver Movimentacao em aCols  ³
³          ³cCod - Campo Disparador da Validacao                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico por se Tratar de Validacao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Gp090MovPD(lMov,cCod)

Local cPD		:= IF( ValType(cCod) != "U" , cCod , &(ReadVar() ) )
Local cTipo		:= ""
Local nPosPD	:= GdFieldPos( IF( ValType(cCod) = "U" , "RC_PD" , "RC_MAT" ) )
Local nPosTip	:= GdFieldPos( "RC_TIPO1" )
Local nPosHrs 	:= GdFieldPos( "RC_HORINFO" )
Local nPosVal	:= GdFieldPos( "RC_VALINFO" )
Local nPulos	:= 0
Local nSalta	:= 0
Local lRet		:= .T.

DEFAULT lMov	:= .F.

lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
Begin Sequence
	IF !( lMov )
		Break
	EndIF

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se a Verba nao Estiver Cadastrada.                            ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF  ( cTipo := AllTrim(PosSRV(  cPD , SRA->RA_FILIAL , "RV_TIPO" )) ) == "@"
		Break
	EndIF

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Altera Tipo da Verba em aCols para Substituir na  Redigitacao ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aCols[n,nPosTip] := cTipo

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Quantidade de Vezes a Saltar                                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF Empty(cTipo)				//Se o Tipo da Verba nao Estiver Definido
		nPulos :=  ( ( nPosTip - nPosPD ) - 1 )
	ElseIF ( cTipo $ "H_D" )	//Se o Tipo da Verba For Horas ou Dias
		nPulos := ( ( nPosHrs - nPosPD ) - 1 )
	ElseIF ( cTipo $ "F_V" )	//Se o Tipo da Verba For Fixo ou Valor
		nPulos :=  ( ( nPosVal - nPosPD ) - 1 )
	EndIF

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Posiciona Ponteiro na Coluna Correspondente                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lGp580Auto
		While ( nPulos <> 0 )
			IF ( nPulos-- > 0 )
				oGet:oBrowse:GoRight()
		    ElseIF ( nPulos++ < 0 )
		  		oGet:oBrowse:GoLeft()
			EndIF
		End While
	EndIf

End Sequence

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fNaoLancPD³ Autor ³ Marinaldo de Jesus    ³ Data ³04/08/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Verifica se Verba Pode Ser Lancada no Movimento            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fNoLancPD( cCodVerba , cFil , lShowHelp , @nQtdLanc )		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cCodVerba	- Codigo da Verba                               ³
³          ³ cFil		- Codigo da Filial                              ³
³          ³ lShowHelp	- Logico Mostrar Help                           ³
³          ³ nQtdLanc   - Quantidade de Lancametos Possiveis            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico por se Tratar de Validacao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fNoLancPD( cCodVerba , cFil , lShowHelp , nQtdLanc )
Return( fNotLancPD( @cCodVerba , @cFil , @lShowHelp , @nQtdLanc ) )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fMontaSeq ³ Autor ³ Marinaldo de Jesus    ³ Data ³04/08/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Montar Sequencia Automatica das Verbas                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fMontaSeq( cCampo )                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cCampo -> Campo para a Chave da Sequencia "RC_PD ou RC_MAT" ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico por se Tratar de Validacao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fMontaSeq( cCampo, cCod, cPrefixo, aGhostCols )

Local aSRCCols		:= {}
Local aColsAnt		:= {}
Local aColsCopy		:= {}
Local cNumSeq		:= ""
Local cStrCols 		:= ""
Local cStrCopy		:= ""
Local lRet			:= .T.
Local nX			:= 0
Local nY			:= 0
Local aNSeq			:= {}
Local nProxSeq		:= 0
Local nSeq			:= 0
Local nPosOrd		:= 0
Local nPosCc		:= 0
Local nPosSe		:= 0
Local nPosSq		:= 0
Local nPosPd		:= 0
Local nPosMat		:= 0
Local nPosFil		:= 0
Local nPosDeleted	:= GdFieldPos( "GDDELETED" )
//Local nLenCols		:= Len( aSRCCols )
//Local nSvn			:= n
Local nLenCols		:= 0
//Local n				:= oGet:nAt
Local nSvn			:= 0
Local nLenGhCols	:= 0
Local nPosRecRgb	:= 0
Local nIndexOf		:= 0
Local cNomeFunc		:= FunName()
Local nCount 		:= 0
Local nCount1 		:= 0
Local nQuant		:= 0
Local cVerba		:= ""
Local nPosDtRef 	:= 0
Local lDataOk		:= .T.
Local nPosItem		:= 0
Local nPosClvl		:= 0
Local nConta		:= 0


DEFAULT cPrefixo    := ( Iif(MV_MODFOL!="2", PrefixoCpo( "SRC" ) + "_", PrefixoCpo( "RGB" ) + "_" ))
Default aGhostCols := {}
lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)

If !lGp580Auto
	n		:= oGet:nAt
	nSvn	:= n
EndIf

If lGp580Auto
	aSRCCols		:= aCols
Else
	aSRCCols		:= ( oGet:aCols )
EndIf

aColsAnt		:= aClone( aSRCCols )
aColsCopy		:= aClone( aSRCCols )

//DEFAULT cPrefixo    := ( PrefixoCpo( "SRC" ) + "_" )

nPosCc		:= GdFieldPos( cPrefixo+"CC" )
nPosSe		:= GdFieldPos( cPrefixo+"SEMANA" )
nPosSq		:= GdFieldPos( cPrefixo+"SEQ" )
nPosPd		:= GdFieldPos( IF( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" , cPrefixo+"PD" , cPrefixo+"MAT"  ) )
nPosMat		:= GdFieldPos( cPrefixo+"MAT" )
nPosFil		:= GdFieldPos( cPrefixo+"FILIAL" )
nPosDtRef	:= GdFieldPos(cPrefixo+"DTREF")
nPosItem	:= GdFieldPos( cPrefixo+"ITEM" )
nPosClvl	:= GdFieldPos( cPrefixo+"CLVL" )

DEFAULT cCod		:= aSRCCols[ n , nPosPd ]

IF ( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" )
	cNumSeq		:= PosSrv( aSRCCols[ n , nPosPD ] , SRA->RA_FILIAL, "RV_QTDLANC" )
	If !lItemClVl
		cStrCols 	:= aSRCCols[ n , nPosPd ] + aSRCCols[ n , nPosCc ]+ cNumPagto
	Else
	   	cStrCols 	:= aSRCCols[ n , nPosPd ] + aSRCCols[ n , nPosCc ]+ aSRCCols[ n , nPosItem ]+aSRCCols[ n , nPosClvl ] + cNumPagto
	EndIf

	If cNomeFunc=="GPEA520"
		cStrCols+= aSRCCols[ n , nPosMat ]
	EndIf
Else
	cNumSeq		:= SRV->RV_QTDLANC
	If !lItemClVl
		cStrCols 	:= aSRCCols[ n , nPosMat ] + aSRCCols[ n , nPosCc ]+ cNumPagto
	Else
	   	cStrCols 	:= aSRCCols[ n , nPosMat ] + aSRCCols[ n , nPosCc ]+ aSRCCols[ n , nPosItem ]+aSRCCols[ n , nPosClvl ] + cNumPagto
	EndIf
EndIF

nLenCols:= Len(aColsCopy)

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³O Numero Minimo de Lancamentos Permitidos e sempre "1"        ³
³ ->Se a verba tem a opcao de lancamento diario, nao tratar    ³
³ sequencia pois so podera ter um lancamento da verba por dia. ³
³ Se for lancamento de tempo extra, sempre validar a     	   ³
³ sequencia de lancamentos.                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If (!(FunName()=="GPEA640"))
	If ( Empty( cNumSeq ) .or. ( cNumSeq == "1" ) .or. Empty( cCod ) ) .or. ;
	   ( PosSRV(cCod , SRA->RA_FILIAL , "RV_LCTODIA" ) == "S" )
    	For nConta:=1 to Len(aSRCCols)
        	If !(aSRCCols[nConta, nPosDeleted] == .T. .or. aSRCCols[n, nPosDeleted] == .T.)
        		If nPosMat > 0
        			If	aSRCCols[nConta, nPosPd] == aSRCCols[n, nPosPd] .and. aSRCCols[nConta,nPosMat] == aSRCCols[n, nPosMat] .and.;
        				( nPosFil > 0 .and. aSRCCols[nConta, nPosFil] == aSRCCols[n, nPosFil]) .and.;
        				(n <> nConta)
						If (aSRCCols[nConta, nPosDtRef] == aSRCCols[n, nPosDtRef]).or.;
							( ( Empty( cNumSeq ) .or. ( cNumSeq == "1" ) ) .And. ( PosSRV(cCod , SRA->RA_FILIAL , "RV_LCTODIA" ) == "N" ) ) // qdo a verba possui lançamento diário, a sequencia é sempre 1
							Help(" ",1,"A090MAXSEQ")
							lRet:=.F.
							Return(lRet)
						Endif
					ElseIf !Empty(aSRCCols[n, nPosSq])
						aSRCCols[n, nPosSq] :=	" "
					EndIf
				Else
				    If	aSRCCols[nConta, nPosPd]== aSRCCols[n, nPosPd] .and. (n <> nConta)
						If (aSRCCols[nConta, nPosDtRef] == aSRCCols[n, nPosDtRef]) .or.;
							( ( Empty( cNumSeq ) .or. ( cNumSeq == "1" ) ) .And. ( PosSRV(cCod , SRA->RA_FILIAL , "RV_LCTODIA" ) == "N" ) ) // qdo a verba possui lançamento diário, a sequencia é sempre 1
							Help(" ",1,"A090MAXSEQ")
							lRet:=.F.
							Return(lRet)
						Endif
					ElseIf !Empty(aSRCCols[n, nPosSq])
						aSRCCols[n, nPosSq] :=	" "
					EndIf
				EndIf
			EndIf
		Next

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica se Existe o Objeto oGet:oBrowse para o Refresh()	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( Type("oGet:oBrowse") == "O" )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Compara o Conteudo para verificar se Houve Alteracao          ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If !ArrayCompare( aColsAnt , aSRCCols )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Repintando o Browse da GetDados							   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				oGet:oBrowse:Refresh()
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Restaura Posicao de n Apos Refresh do Browse da GetDados	   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				n := nSvn
			EndIf
		EndIf
		Return( lRet )
	EndIf
EndIf
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Salva Sequencia inicial de aCols para poder restaura-la na mes³
³ma ordem.                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To nLenCols
	aAdd( aColsCopy[ nX ] , StrZero( nX , 4 ) )
Next nX

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Posicao da Ordem de Entrada								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nPosOrd := Len( aColsCopy[ nX - 1 ] )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Ordena aColsCopy com as Chaves Respectivas                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF ( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" )
	If !lItemClvl
		aSort( aColsCopy ,,, { |x,y| x[ nPosPd ] + x[ nPosCc ] + cNumPagto + x[ nPosSq ] < ;
		 							  y[ nPosPd ] + y[ nPosCc ] + cNumPagto + y[ nPosSq ]   ;
							 }																 				    ;
		  	)
	Else
		aSort( aColsCopy ,,, { |x,y| x[ nPosPd ] + x[ nPosCc ] + x[ nPosItem ]+ x[ nPosClVl ]+ cNumPagto + x[ nPosSq ] < ;
									  y[ nPosPd ] + y[ nPosCc ] + y[ nPosItem ]+ y[ nPosClVl ]+ cNumPagto + y[ nPosSq ]   ;
							 }																 				    ;
			 )
	EndIf
Else
	If !lItemClvl
		aSort( aColsCopy ,,, { |x,y| x[ nPosMat ] + x[ nPosCc ] + cNumPagto + x[ nPosSq ] < ;
								 	  y[ nPosMat ] + y[ nPosCc ] + cNumPagto + y[ nPosSq ]   ;
					 }												                  				 	 ;
		  )
	Else
		aSort( aColsCopy ,,, { |x,y| x[ nPosMat ] + x[ nPosCc ] + x[ nPosItem ] +  x[ nPosClVl ]+ cNumPagto + x[ nPosSq ] < ;
									  y[ nPosMat ] + y[ nPosCc ] + y[ nPosItem ] +  y[ nPosClVl ]+ cNumPagto + y[ nPosSq ]   ;
					 }												                  				 	 ;
		  )
	EndIf
EndIF

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Renumera Sequencia de Lancamentos                             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To nLenCols
	IF ( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" )
		If !lItemClvl
			cStrCopy := aColsCopy[ nX , nPosPd ] + aColsCopy[ nX , nPosCc ] + cNumPagto
		Else
			cStrCopy := aColsCopy[ nX , nPosPd ] + aColsCopy[ nX , nPosCc ] + aColsCopy[ nX , nPosItem ] + aColsCopy[ nX , nPosClVl ] + cNumPagto
		EndIf
		If cNomeFunc=="GPEA520"
			cStrCopy+= aColsCopy[ nX , nPosMat ]
		EndIf
    Else
		If !lItemClvl
			cStrCopy := aColsCopy[ nX , nPosMat ] + aColsCopy[ nX , nPosCc ]+ cNumPagto
		Else
			cStrCopy := aColsCopy[ nX , nPosMat ] + aColsCopy[ nX , nPosCc ]+ aColsCopy[ nX , nPosItem ] + aColsCopy[ nX , nPosClVl ] + cNumPagto
		EndIf
    EndIF
	IF !( aColsCopy[ nX , nPosDeleted ] )
		IF ( cStrCopy == cStrCols )
			If cPrefixo == "RGB_"
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Se estiver trabalhando com a tabela RGB, a numeracao de       ³
				³sequencia das verbas e controlada por varias telas de lanca-  ³
				³mentos(GPEA090,GPEA100,GPEA520,GPEA640) sendo que a tela de   ³
				³lancamento GPEA640 nao exibe os mesmos lancamentos de GPEA090 ³
				³por ex. Sendo assim quando uma montagem de sequencia e soli-  ³
				³tada um array chamado aGhCols e somado ao array da getDados   ³
				³e a sequencia e entao gerada, mas lembre se que o aGhostCols  ³
				³e um array de visualizacao e portanto suas sequencias nao po- ³
				³dem ser alteradas ou duplicadas.                              ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If Empty(aColsCopy[ nX , nPosSq ])
					/*Gera array com todas sequencias ja existentes*/
					aNSeq := {}
					For nY:=1 To nLenCols
						IF ( Upper( AllTrim( cCampo ) ) == cPrefixo+"PD" )
							If !lItemClvl
								cStrCopy := aColsCopy[ nY , nPosPd ] + aColsCopy[ nY , nPosCc ] + cNumPagto
							Else
								cStrCopy := aColsCopy[ nY , nPosPd ] + aColsCopy[ nY , nPosCc ] + aColsCopy[ nY , nPosItem ] + aColsCopy[ nY , nPosClVl ] + cNumPagto
							EndIf
							If cNomeFunc=="GPEA520"
								cStrCopy+= aColsCopy[ nY , nPosMat ]
							EndIf
					    Else
							If !lItemClvl
								cStrCopy := aColsCopy[ nY , nPosMat ] + aColsCopy[ nY , nPosCc ] + cNumPagto
							Else
								cStrCopy := aColsCopy[ nY , nPosMat ] + aColsCopy[ nY , nPosCc ] + aColsCopy[ nY , nPosItem ] + aColsCopy[ nY , nPosClVl ] + cNumPagto
							EndIf
					    EndIF
						If ( cStrCopy == cStrCols ) .AND. !( aColsCopy[ nY , nPosDeleted ] )
							aAdd(aNSeq, aColsCopy[ nY , nPosSq ])
						EndIf
					Next nY

					/*Encontra o primeiro intervalo de sequencia valido*/
					nSeq:=0
					cNumSeq := if( Val(cNumSeq) = 0, "1", cNumSeq)
					For nY:=1 To Val(cNumSeq)
						If  aScan(aNSeq, StrZero( nY , aHeader[ nPosSq , 4 ]) ) == 0
							nSeq:= nY
							nY:=Val(cNumSeq)+1
						EndIf
					Next nY
					If nSeq==0
						nSeq:=Val(cNumSeq)+1
					EndIf
				Else
					nSeq := Val(aColsCopy[ nX , nPosSq ])
				EndIf
			Else
				nSeq++
			EndIf

			If Len(aNSeq) == 1
				lRet := .T.
				aColsCopy[ nX , nPosSq ] := " "
			Else
				IF ( lRet := ( nSeq <= Val( cNumSeq ) ) )
					If cPrefixo=="RGB_"
						If Empty(aColsCopy[ nX , nPosSq ])
							aColsCopy[ nX , nPosSq ] := StrZero( nSeq , aHeader[ nPosSq , 4 ] )
						EndIf
					Else
						aColsCopy[ nX , nPosSq ] := StrZero( nSeq , aHeader[ nPosSq , 4 ] )
					EndIf
				Else
					Help(" ",1,"A090MAXSEQ")
					Return( lRet )
				EndIF
			EndIf
		EndIF
	Else
		aColsCopy[ nX , nPosSq ] := Space( aHeader[ nPosSq , 4 ] )
	EndIF
Next nX

If Len(aGhostCols)> 0
	//Elimina os Itens de aGhostCols que foram somados anteriormente
	For nX:=1 To nLenGhCols
		nIndexOf := aScan(aColsCopy, { |x| x[nPosRecRgb]==aGhostCols[nX,nPosRecRgb]})
		If nIndexOf > 0
			ADel(aColsCopy, nIndexOf)
			ASize(aColsCopy, Len(aColsCopy)-1)
		EndIf
	Next
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura Sequencia original de aColsCopy                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nPosOrd := iIf(Len(aColsCopy)>0, Len(aColsCopy[1]), nPosOrd)
aSort( aColsCopy ,,, { |x,y| x[ nPosOrd  ] < y[ nPosOrd  ] } )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Atualiza a Sequencia de Lancamentos                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To Len( aSRCCols )
	aSRCCols[ nX , nPosSq ] := aColsCopy[ nX , nPosSq ]
Next nX

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se Existe o Objeto oGet:oBrowse para o Refresh()	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF ( Type("oGet:oBrowse") == "O" )
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Compara o Conteudo para verificar se Houve Alteracao          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF !ArrayCompare( aColsAnt , aSRCCols )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Repintando o Browse da GetDados							   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		oGet:oBrowse:Refresh()
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Restaura Posicao de n Apos Refresh do Browse da GetDados	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		n := nSvn
	EndIF
EndIF

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RcPdValid ³ Autor ³ Marinaldo de Jesus    ³ Data ³04/08/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Conteudo do RC_PD                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RcPdValid( lMovPd )                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³lMovPd para a funcao Gp090MovPd( lMovPd )					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico por se Tratar de Validacao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RC_PD                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function RcPdValid( lMovPd )

Local cPd			:= &( ReadVar() )
Local cDescPd		:= ""
Local cDigSema		:= Upper( AllTrim( SuperGetMv( "MV_DIGSEMA" , NIL , "N" ) ) )
Local lRcPdValid	:= .T.

DEFAULT lMovPd		:= .F.

Begin Sequence
	if Type( "aCols" ) != "U"
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica se Verba Aceita Lancamentos                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !( lRcPdValid := fNoLancPD() )
			Break
		EndIF

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Carrega a Descricao da Verba                                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cDescPd := fDesc( "SRV" , cPd , "RV_DESC" )
		GdFieldPut( "RC_DESCPD" , cDescPd )

		SRV->(dbSetOrder(1))
		if(SRV->(dbSeek(xFilial('SRV') + cPd)))
			GdFieldPut( "RC_INSS", SRV->RV_INSS )
			GdFieldPut( "RC_FGTS", SRV->RV_FGTS )
			GdFieldPut( "RC_IR"	, SRV->RV_IR )
		endIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Carrega o Conteudo do campo RC_SEMANA                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !Empty(cNumPagto)
			GdFieldPut("RC_SEMANA", cNumPagto)
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Posiciona Cursor na Coluna Correspondente                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		Gp090MovPd( lMovPd )
	EndIf
End Sequence

Return( lRcPdValid )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp090MontaGetDados ³ Autor ³ Tatiane Matias        ³ Data ³27/07/2004							   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Montar a GetDados de acordo com o periodo informado             						           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³Sintaxe   ³gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, aVirtual, aColsRec, aSRCCols, lGravarAntes, lEntrada)³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias                                                                               		       ³
³          ³nOpcX  																							   ³
³          ³cFil - Filial.																					   ³
³          ³cMat - Matricula.																				   ³
³          ³aVirtual - array dos campos virtuais.															   ³
³          ³aColsRec - array que contem o Recno() dos registros da aCols.									   ³
³          ³aSRCCols 																					       ³
³          ³lGravarAntes - indica se deve chamar a funcao de gravacao antes de montar a tela.				   ³
³          ³lEntrada - indica se a funcao gp090MontaGetDados esta sendo chamada na entrada da rotina de lanca- ³
³          ³           mentos por periodo.                                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Logico                                                          								   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpea090Mnt                                                            							   ³
³          ³Na alteracao do campo periodo                                         							   ³
³          ³Gpea090Grava                                                           							   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function gp090MontaGetDados(cAlias, nOpcX, cFil, cMat, aVirtual, aColsRec, aSRCCols, lGravarAntes, lEntrada)

Local lUseGhClm		:= .T.
Local aGdNaoAltera	:= {}
Local bSkip			:= { || .F. }
Local cQueryCond	:= ""
Local cQueryGh		:= ""
Local cAcessaSrc    := ""
Local aNotFields	:= {}
Local aVisual		:= {}
Local cKeySeek		:= ""
Local nPosPd		:= 0
Local nPosDesc		:= 0
Local nPosHoras		:= 0
Local nPosTp1		:= 0
Local nX			:= 0
Local nTamArray		:= 0
Local cChkNrPagto	:= Getmv("MV_CATNPGT")
Local cPrefixo      := ( PrefixoCpo( cAlias ) + "_" )
Local bSaveBefore   := { || iif(Gpea090TudOk(),Gpea090Grava(cAlias,cFil,cMat,aVirtual,aColsRec,nOpcx, .T.,.T.),) }
Local lGP042Reg		:= (cPaisLoc $ "COL" .And. FunName() == "GPEM042")
lVerificaMes        := .F.
Default lEntrada 	:= .F.

cNumId	:= If (Type("cNumId") == "U", "", cNumId) //Recebida no GPEA580() para tratamento do Consignado.

	// Antes de montar a tela, verifica se deseja gravar ... caso tenha tido alguma alteracao.
	If lGravarAntes
		MsAguarde( bSaveBefore, OemToAnsi(STR0024))
	EndIf

	If Empty(SRA->RA_MAT)
		SRA->( DbSkip(-1) )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza os dados do Funcionario.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFil		:= SRA->RA_FILIAL
	cMat		:= SRA->RA_MAT
	cCategoria	:= SRA->RA_CATFUNC
	cProcesso	:= SRA->RA_PROCES
	cPosto 		:= SRA->RA_POSTO

	lDaRefresh := .F.
	If !lGp580Auto
		If (cPeriodo <> cPeriodoAnt) .or. (cNumPagto <> cSemanaAnt) .or. cRoteiro <> cRoteiroAnt
			lDaRefresh := .T.

			// Recupera o roteiro do periodo/numero de pagamento informado.
			If (cRoteiro <> RCH->RCH_ROTEIR .and. !Empty(RCH->RCH_ROTEIR)) .or. Empty(cRoteiro)
				DbSelectArea( cAlias )
				cRoteiro	:= gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_NUMPAG ='" + cNumPagto + "'", "RCH_ROTEIR" ,,.T. )
				If Empty(cRoteiro)
					cRoteiro := fGetRotOrdinar()
				EndIf
			ElseIf cRoteiro <> RCH->RCH_ROTEIR .and. Empty(RCH->RCH_ROTEIR)
				// somente posicionar na tabela RCH e nao atualizar o roteiro
				DbSelectArea( cAlias )
				gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_NUMPAG ='" + cNumPagto + "'", "RCH_ROTEIR" ,,.T. )
			Else
				DbSelectArea( cAlias )
				gp240RetCont("RCH", 1, "RCH_FILIAL = '" + xFilial("RCH", SRA->RA_FILIAL) + "' AND RCH_PROCES = '" + cProcesso + "' AND RCH_ROTEIR = '" + cRoteiro + "' AND RCH_NUMPAG ='" + cNumPagto + "'", "RCH_ROTEIR" ,,.T. )
			EndIf
			//Recarrega o array de validacao das verbas para a GetDados
			MontaF3SRV(.T., cRoteiro, cProcesso, @aIndexSrv, .T.)
		EndIf
	EndIf

	// Recupera a data de inicio e a data fim do periodo informado.
	cDataIni := gp090RetDtRef(.T.)
	cDataFim := gp090RetDtRef()

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta Bloco para Skip em GdMontaCols                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	bSkip := { || .F. }
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta Query para a Selecao das Informacoes em GdMontaCols    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cQueryCond	:= cPrefixo+"FILIAL='"+cFil+"'"
	cQueryCond	+= " AND "
	cQueryCond	+= cPrefixo+"MAT='"+cMat+"'"
	cAcessaSrc	:= ChkRH(If(cAlias=="SRC","GPEA090","GPEA580"),cAlias,"1")
	cAcessaSrc	:= fSFiltrSQL(cAcessaSrc)

	If (!Empty(cAcessaSrc))
		cQueryCond	+= " AND "
		cAcessaSrc := StrTran(cAcessaSrc, cAlias+".","")
		cQueryCond	+= cAcessaSrc
	EndIf

	cQueryCond	+= " AND "
	cQueryCond	+= "D_E_L_E_T_ = ' ' "

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define os Campos que nao serao Mostrados                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aNotFields	:= {cPrefixo+"FILIAL"	, ;
						cPrefixo+"MAT" 	, ;
						cPrefixo+"NOME" 	, ;
						If(cAlias=="SRC",cPrefixo+"PERIODO",cPrefixo+"PERIOD"), ;
						cPrefixo+"PROCES"	, ;
						cPrefixo+"POSTO"	, ;
						If ( (FunName() == "GPEM040" .or. !Empty(cNumId)) ,"", cPrefixo+"NUMID" ), ;
						cPrefixo+"ROTEIR" , ;
						cPrefixo+"SEMANA" , }

	If cAlias == "RGB"
		aAdd(aNotFields, "RGB_DUM")
		aAdd(aNotFields, "RGB_DDOIS")
		aAdd(aNotFields, "RGB_DTRES")
		aAdd(aNotFields, "RGB_DQUATR")
		aAdd(aNotFields, "RGB_DCINCO")
		aAdd(aNotFields, "RGB_DSEIS")
		aAdd(aNotFields, "RGB_DSETE")
		If cPaisLoc == "RUS"
			aAdd(aNotFields, "RGB_DEPTO")
		EndIf
	EndIf

	If !lItemClVl
		AAdd(aNotFields, cPrefixo+"ITEM")
		AAdd(aNotFields, cPrefixo+"CLVL")
	EndIf

	// Se esta entrando na tela, verifica se existe algum lancamento, independente do periodo,
	// para o funcionario selecionado. Se for inclusao, nao deve ter nenhum registro. Se for
	// alteracao, deve ter pelo menos um registro.
	If lEntrada
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta a chave para Pesquisa em GdMontaCols                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cKeySeek := ( cFil + cMat )

		//Limpa array para não ocasionar erro na navegação de registros devido aos campos virtuais inseridos (RC_INSS, RC_IR, RC_FGTS, RC_INCORP)
		aHeader := {}

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta os Detalhes                                    		 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aSRCCols := GdMontaCols(	@aHeader,;
									@nUsado,;
									@aVirtual,;
									@aVisual,;
									cAlias,;
									aNotFields,;
									@aColsRec,;
									cAlias,;
									cKeySeek,;
									NIL,;
									bSkip,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									NIL,;
									cQueryCond,;
									.F.,;
									.F.,;
									.T.)

		IF ( ( nOpcX == 3 ) .and. ( Len( aColsRec ) > 0 ) ) .and. !lCalcExec .And. !lGp580Auto //Quando for Inclusao
			Help(" ",1,"A040CLANC")
			Break
		ElseIf ( nOpcX <> 3 ) .and. ( Len( aColsRec ) == 0 ) .And. (Type( "lResM2" ) == "U" .Or. !lResM2) .And. !( IsInCallStack("GPEI090") )  .and. !lCalcExec  .And. !lGp580Auto//Quando Nao for Inclusao
			Help(" ",1,"A040SLANC")
			Break
		EndIF
	EndIf

	If !( lSRCLock := Gpea090Locks( nOpcx , cAlias ) )
		Break
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define os Campos que nao Serao Alterados                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If ! lGp580Auto
		aGdNaoAltera := { cPrefixo + "TIPO2", cPrefixo + "SEMANA"}
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Define os Campos para a GetDados										 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	//cChkNrPagto -> Categorias que não deverao validar o número de pagamento informado
	If !(cCategoria $ cChkNrPagto) .OR. (cCategoria $ cChkNrPagto .AND. !Empty(cNumPagto))

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega a Semana para Digitacao                              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cSemana := cNumPagto

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta Bloco para Skip em GdMontaCols                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		bSkip := { || &(cAlias+"->"+cPrefixo+"SEMANA") <> cNumPagto }

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta Query para a Selecao das Informacoes em GdMontaCols    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

		cQueryCond	:= cPrefixo+"FILIAL='"+cFil+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= cPrefixo+"MAT='"+cMat+"'"

		IF !Empty( cPeriodo )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo + If(cAlias == "SRC","PERIODO","PERIOD")+ "='" + cPeriodo + "'"
		EndIF

		IF !Empty( cSemana )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo+"SEMANA='"+cSemana+"'"
		EndIF

		IF !Empty( cRoteiro )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo+"ROTEIR='"+cRoteiro+"'"
		EndIF

		cAcessaSrc	:= ChkRH(If(cAlias=="SRC","GPEA090","GPEA580"),cAlias,"1")
		cAcessaSrc	:= fSFiltrSQL(cAcessaSrc)

		If (!Empty(cAcessaSrc))
			cQueryCond += " AND "
			cAcessaSrc := StrTran(cAcessaSrc, cAlias+".","")
			cQueryCond	+= cAcessaSrc
		EndIf

		cQueryCond	+= " AND "
		cQueryCond	+= "D_E_L_E_T_ = ' ' "

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta a chave para Pesquisa em GdMontaCols                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cKeySeek := ( cFil + cMat + cPeriodo + cRoteiro + cSemana )

	Else
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta Bloco para Skip em GdMontaCols                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		bSkip := { || .F. }
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta Query para a Selecao das Informacoes em GdMontaCols    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

		cQueryCond	:= cPrefixo+"FILIAL='"+cFil+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= cPrefixo+"MAT='"+cMat+"'"

		IF !Empty( cPeriodo )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo + If(cAlias == "SRC","PERIODO","PERIOD")+ "='" + cPeriodo + "'"
		EndIF

		IF !Empty( cRoteiro )
			cQueryCond	+= " AND "
			cQueryCond	+= cPrefixo+"ROTEIR='"+cRoteiro+"'"
		EndIF

		cQueryCond	+= " AND "
		cQueryCond	+= "D_E_L_E_T_ = ' ' "

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta a chave para Pesquisa em GdMontaCols                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cKeySeek := ( cFil + cMat + cPeriodo + cRoteiro )

    EndIf

    /*
    	Se for referente a tabela RGB entao nao exibe campos que tem os dados
      de lancamento de tempos extra, serao exibidas em outras telas, GPEA520 e GPEA640
    */
	If cAlias == "RGB"
		/* Clona a query de abertura, considerando todos os calculos,
			para o calculo de chequencia de verbas
		*/

		cCodRoteiro		:= cRoteiro
		cCodProcesso 	:= cProcesso
		cQueryGh 		:= cQueryCond

		cQueryCond += " AND ("
		cQueryCond += " RGB_DUM = 0 AND"
		cQueryCond += " RGB_DDOIS = 0 AND"
		cQueryCond += " RGB_DTRES = 0 AND"
		cQueryCond += " RGB_DQUATR = 0 AND"
		cQueryCond += " RGB_DCINCO = 0 AND"
		cQueryCond += " RGB_DSEIS = 0 AND"
		cQueryCond += " RGB_DSETE = 0 ) "

		//Query para abertura de aCols Ghost
		cQueryGh += " AND ("
		cQueryGh += " RGB_DUM != 0 OR"
		cQueryGh += " RGB_DDOIS != 0 OR"
		cQueryGh += " RGB_DTRES != 0 OR"
		cQueryGh += " RGB_DQUATR!= 0 OR"
		cQueryGh += " RGB_DCINCO!= 0 OR"
		cQueryGh += " RGB_DSEIS != 0 OR"
		cQueryGh += " RGB_DSETE != 0 ) "
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta os Detalhes                                    		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+If(cAlias=="SRC","PERIODO+","PERIOD+")+cPrefixo+"ROTEIR+"+cPrefixo+"SEMANA" ) ) )


	//Limpa array para não ocasionar erro na navegação de registros devido aos campos virtuais inseridos (RC_INSS, RC_IR, RC_FGTS, RC_INCORP)
	aHeader := {}

 	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Executa o filtro depois do dbSetOrder pois o mesmo tira o fil|
	³ tro de FilBrowse, que a funcao ffiltro executa               |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
  	If Len(aArray)>0
		ffiltro(If(cAlias=="SRC","GPEA090","GPEA580"),aArray,1,1,3)//1- Executa os Filtros
	Endif

	If (cPaisLoc == "RUS")
		lUseGhClm := .F.
	EndIf

	//Coluna Oculta para o calculo da sequencia, com todos os dados
	If (cAlias == "RGB" .AND. IsInCallStack("GPEA580"))
		aGhCols	 := GdMontaCols(@aHeader, @nUsado, @aVirtual, @aVisual, cAlias, aNotFields, @aColsRec, cAlias, ;
									 NIL, NIL, bSkip, NIL, NIL, NIL, NIL, NIL, NIL, cQueryGh, .F., .F., lUseGhClm )
		MontaF3Srv(.F., cRoteiro, cProcesso, @aIndexSrv, .T.)
	EndIf

	aSRCCols := GdMontaCols(	@aHeader,;		//01
								@nUsado,;
								@aVirtual,;
								@aVisual,;
								cAlias,;		//05
								aNotFields,;
								@aColsRec,;
								cAlias,;
								cKeySeek,;
								NIL,;			//10
								bSkip,;
								NIL,;
								NIL,;
								NIL,;
								NIL,;			//15
								NIL,;
								NIL,;
								cQueryCond,;
								.F.,;
								.F.,;			//20
								lUseGhClm)

	nPosSemana	:= GdFieldPos( cPrefixo+"SEMANA", aHeader)

	If nPosSemana > 0
		aAdd(aVisual, cPrefixo+"SEMANA")
		aHeader[nPosSemana, __AHEADER_VISUAL__]  := "V"
		aHeader[nPosSemana, __AHEADER_INITPAD__] := "cNumPagto"

		For nX:= 1 To Len(aSRCCols)
			If Empty(aSRCCols[nX,nPosSemana])
				aSRCCols[nX, nPosSemana] := cNumPagto
			EndIf
		Next
	EndIf

	If !lItemClVl
		(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"SEMANA+"+cPrefixo+"SEQ" ) ) )
    Else
    	(cAlias)->( dbSetOrder( RetOrder( cAlias , cPrefixo+"FILIAL+"+cPrefixo+"MAT+"+cPrefixo+"PD+"+cPrefixo+"CC+"+cPrefixo+"ITEM+"+cPrefixo+"CLVL+"+cPrefixo+"SEMANA+"+cPrefixo+"SEQ" ) ) )
    EndIf
	//(cAlias)->( dbSetOrder(1))
	If Len(aArray)>0
		ffiltro(If(cAlias=="SRC","GPEA090","GPEA580"),aArray,1,1,3)//1- Executa os Filtros
	Endif

	nPosPd		:= GdFieldPos( cPrefixo+"PD"		, aHeader )
	nPosDesc	:= GdFieldPos( cPrefixo+"DESCPD"	, aHeader )
	nPosHoras	:= If(cAlias=="SRC", GdFieldPos( cPrefixo+"HORINFO", aHeader ), GdFieldPos( cPrefixo+"HORAS", aHeader ))
	nPosTp1		:= GdFieldPos( cPrefixo+"TIPO1"	, aHeader )


	//Guarda campos virtuais que não são do X3, são adicionados manualmente.
	If cPaisLoc != "RUS"
		addVirtCpo(aHeader,aSRCCols,aVirtual,cPrefixo,@aGhCols)
	EndIf

	For nX := 1 To Len( aSRCCols )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega a Descricao das Verbas         					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aSRCCols[ nX , nPosDesc ] := fDesc( "SRV" , aSRCCols[ nX , nPosPd ] , "RV_DESC" )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se MV_HORASDE = "S" e Campo RC_HORINFO Converte Horas          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( cDigHoras == "S" ) .And. (aSRCCols[nX,nPosTp1] == "H" )
			//Se o campo HORINFO nao for usado no pais, utiliza o campo HORAS
			If nPosHoras == 0
				nPosHoras := GdFieldPos( cPrefixo+"HORAS", aHeader )
			EndIf
			aSRCCols[ nX , nPosHoras ] := fConvHr( aSRCCols[ nX , nPosHoras ] , "H" )
		EndIF
	Next nX

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega, apenas, os Campos Editaveis            			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aGdAltera := {}
	For nX := 1	To nUsado
		IF (;
				( aScan( aVirtual 		, aHeader[ nX , 02 ] ) == 0 );
				.and.;
		   		( aScan( aVisual  		, aHeader[ nX , 02 ] ) == 0 );
		   		.and.;
		   		( aScan( aNotFields	, aHeader[ nX , 02 ] ) == 0 );
		   		.and.;
		   		( aScan( aGdNaoAltera	, aHeader[ nX , 02 ] ) == 0 );
		  	)
			aAdd( aGdAltera , aHeader[ nX , 02 ] )
		EndIF
	Next nX

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ salva o acols e o periodo antes da alteracao 	 			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aColsAnt	:= aClone( aSRCCols )
	cPeriodoAnt := cPeriodo
	cSemanaAnt	:= cNumPagto
	cRoteiroAnt := cRoteiro

	// atualiza a getdados
	If !(oGet == nil)
		oGet:SetArray(aClone(aSRCCols))
		oGet:lModified := .F.
 		If ( Type("oGet:oBrowse") == "O" )
			oGet:Refresh()
		EndIf
	EndIf

	If !lGP042Reg .And. !lGp580Auto .And. !Empty(RCH->RCH_ROTEIR) .AND. cRoteiro <> "VEX" .And. RCH->RCH_PER <> cPeriodo
		cRoteiro := RCH->RCH_ROTEIR
	EndIf

	If FunName() == "GPEM040"
		cRoteiro := "RES"
	Endif
Return (.T.)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp090RetDtRef ³ Autor ³ Tatiane Matias        ³ Data ³27/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³retorna data de referencia do periodo informado             	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³Sintaxe   ³gp090RetDtRef(lDataIni)											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³lDataIni - indica se retorna o primeiro dia do periodo (.T.).   ³
³          ³        Se esse parametro nao for passado (NIL ou .F.) essa  	³
³          ³  		funcao ira retornar o ultimo dia do periodo informado.  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Data de referencia. Primeiro dia do periodo, se lDataIni = .T.  ³                                                          								   ³
³          ³ ou ultimo dia do periodo.                                   	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpea090LinOk                                                    ³
³          ³GPEA100                                                         ³
³          ³gp090MontaGetDados                                              ³
³          ³X3_RELACAO (SX3) do campo RC_DTREF                              ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function gp090RetDtRef(plDataIni)

Local aArea := RCH->( GetArea() )
Local dDataRef   := CTOD("")
Default plDataIni  := .F.

	// retorna ano e mes do periodo informado.
	If plDataIni
		dDataRef := RCH->RCH_DTINI
	Else
		dDataRef := RCH->RCH_DTFIM
	EndIf

RestArea( aArea )
Return (dDataRef)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpRetorno ³Autor³Tatiane Vieira Matias      ³Data³31/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorno da Consulta Padrao									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gpRCHRetorno(cTipo)

//cTipo == "NUMPAGO"
//	    == "PERIODO"
//      == "PROCESSO"

Local cCpoRet		:= ""

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Essa variavel determina se na Consulta RCH devera ou nao reto³
³ rnar o Nro de Pagamento. Quando nao quer o retorno devera    ³
³ criar a variavel lNumPago como .F. no programa que executa a ³
³ a consulta Padrao.                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If Type( "lNumPago" ) == "U"
	lNumPago := .T.
EndIf

If cTipo == "NUMPAGO"
	If lNumPago
		cCpoRet := "RCH->RCH_NUMPAG"
	Else
		cCpoRet := Space( GetSx3Cache( "RCH_NUMPAG", "X3_TAMANHO" ) )
	EndIf
ElseIf  cTipo =="PROCES"
	If ( Type("oGetRG8") == "O" )
		cCpoRet := "RCH->RCH_PROCES"
	Endif
ElseIf  cTipo =="ROTEIR"
	If ( Type("oGetRG8") == "O" )
		cCpoRet := "RCH->RCH_ROTEIR"
	Endif
ElseIf  cTipo =="MES"
	If ( Type("oGetRG8") == "O" )
		cCpoRet := "RCH->RCH_MES"
	Endif
ElseIf  cTipo =="ANO"
	If ( Type("oGetRG8") == "O" )
		cCpoRet := "RCH->RCH_ANO"
	Endif
Else
	cCpoRet := "RCH->RCH_PER"
EndIf

cCpoRet := If ( Empty(&(cCpoRet)), "",  &(cCpoRet) )

Return ( cCpoRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpFiltro  ³Autor³Tatiane Vieira Matias      ³Data³31/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtro da Consulta Padrao									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ExpC2 - Filtro de Tipo de roteiro (RY_TIPO) 				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gpRCHFiltro(cTipo, cTpRot)

Local cFiltro		:= ""
Local cRotFiltro	:= ""
Local lPonto		:= FWIsInCallStack("PONA180") .Or. FWIsInCallStack("PONA240") .Or. FWIsInCallStack("PONA190") .Or. FWIsInCallStack("PONA270") .Or. FWIsInCallStack("PONA220")

DEFAULT cTipo 		:= ""
DEFAULT cTpRot 		:= ""

If Type("cFilRCJ") <> "U" .and. !Empty(cFilRCJ)
	If FWModeAccess("RCJ",1) == "E" .AND. FWModeAccess("RCJ",2) == "E" .AND. FWModeAccess("RCJ",3) == "E"
		cFilAnt := cFilRCJ
	Else
		cFilAnt := FWArrFilAtu(cEmpAnt,Padr(cFilRCJ,FwSizeFilial()))[2]
	EndIf
EndIf

cFiltro		:= "(RCH->RCH_FILIAL == '" + xFilial("RCH") + "')"

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Criar as variaveis DEFAULT 								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If Type( "cCond" ) == "U"
	cCond := "3"
EndIf

If Type( "cProcesso" ) == "U"
	cProcesso := ""
EndIf

If Type( "cPeriodo" ) == "U"
	cPeriodo := ""
EndIf

If Type( "cRot" ) == "U"
	cRot := ""
EndIf

If Type( "lRotEmpty" ) == "U"
	lRotEmpty := .F.
EndIf

If Type( "cModuloFlt" ) == "U"
	cModuloFlt := ""
EndIf

If Len(cTpRot) > 0
	DbSelectArea("SRY")
	DbSetOrder(1)
	dbSeek(xFilial("SRY"))
	While (!Eof()) .And. (SRY->RY_FILIAL == xFilial("SRY") )
		//Condicao para separar todos roteiros, que são do tipo estipulado no 2. parametro desta função
		//usado na consulta padrao RCH11
		If 	!Empty(SRY->RY_TIPO) .AND. 	(SRY->RY_TIPO == (cTpRot))
			If Len(cRotFiltro)= 0
				cRotFiltro += " .AND. (RCH->RCH_ROTEIR == '" + SRY->RY_CALCULO + "'"
			Else
				cRotFiltro += " .OR. RCH->RCH_ROTEIR == '" + SRY->RY_CALCULO + "'"
			EndIf
		EndIf
		dbSkip()
	EndDo

	cRotFiltro		:= IIf ( Len(cRotFiltro) > 0,cRotFiltro + ")","")

EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Documentacao das Variaveis 								   ³
³															   ³
³cCond == 1 -> Periodos Abertos 							   ³
³      == 2 -> Periodos Fechados							   ³
³      == 3 -> Ambos	         							   ³
³cTipo == "NUMPAGO"                         				   ³
³      == "PERIODO"                         				   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If cCond == "1" .OR. cCond == "2" // Periodo aberto ou fechado
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	If cCond == "2" // Periodo fechado
		cFiltro := "!"
	EndIf
	cFiltro	+= "EMPTY(RCH->RCH_DTFECH) "
	If !lPonto .And. !(cPaisLoc == "RUS" .And. IsInCallStack("GPEA580"))
		cFiltro	+= ".AND. RCH_PERSEL = '1'"
	EndIf
EndIf

If cTipo == "NUMPAGO"
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	cFiltro += " (RCH->RCH_PER == '" + cPeriodo + "')"
EndIf

If !Empty(cProcesso)
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	cFiltro	+= " (RCH->RCH_PROCES == '" + cProcesso + "')"
EndIf

If len(cRotFiltro)>0
	cFiltro	+= cRotFiltro
EndIf

If !Empty(cRot)
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf

	cFiltro	+= " (RCH->RCH_ROTEIR == '" + cRot + "'"

	If lRotEmpty
		cFiltro	+= " .OR. RCH->RCH_ROTEIR == '" + Space(3) + "'"
	EndIf

	if(IsIntegracao())
		cFiltro	+= " .OR. RCH->RCH_ROTEIR == 'AUT'"
	endIf

	cFiltro += ")"
Else
	if(IsIntegracao())
		If !Empty(cFiltro)
			cFiltro	+= " .AND. "
		EndIf
		cFiltro	+= " ((RCH->RCH_ROTEIR == 'AUT') .OR. (RCH->RCH_ROTEIR == '"  + FGETROTORDINAR() + "')) "
	endIf
EndIf

If !Empty(cModuloFlt)
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	cFiltro	+= " (RCH->RCH_MODULO== '" + cModuloFlt + "')"
EndIf
cFiltro := "@#" + cFiltro + "@#"

Return ( cFiltro )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp090NrPagtoValid ³ Autor ³ Tatiane Matias        ³ Data ³31/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Valida o numero de pagamento informado 	                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³Sintaxe   ³gp100NrPagtoValid()					    		                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RC_SEMANA                                         ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function GP090NrPagtoValid(cNrPag, cPrefixo)
	Local lRet			:= .T.
	Local cChkNrPagto	:= Getmv("MV_CATNPGT")
	Local cMatricula	:= ""
	Local cFilMat
	Local nPosMat
	Local nPosFil
	DEFAULT cPrefixo    := ( PrefixoCpo( "SRC" ) + "_" )

	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)
	If IsInGetDados( { cPrefixo + "MAT" } )
		nPosMat 	:= GdFieldPos(cPrefixo + "MAT" )
		nPosFil 	:= GdFieldPos(cPrefixo + "FILIAL" )
		cMatricula 	:= If(lGp580Auto,aCols[n, nPosMat],oGet:aCols[n, nPosMat])
		cFilMat		:= If(lGp580Auto,aCols[n, nPosMat],oGet:aCols[n, nPosFil])
	Else
		cMatricula	:= SRA->RA_MAT
		cFilMat 	:= xFilial("SRA", SRA->RA_FILIAL)
	EndIf

	cCategoria 	:= gp240RetCont("SRA", 1, "RA_FILIAL = '" + cFilMat + "' AND RA_MAT = '" + cMatricula + "'", "RA_CATFUNC", ,.T.)

	If !Empty(cCategoria) .AND. !(cCategoria $ cChkNrPagto)
		If Type( "cNumPagto" ) = "U"
		    lRet := ExistCpo("RCH", cProcesso + cPeriodo + cNrPag + "        ", 3)
		Else
			// Se o campo de filtro numero de pagamento estiver preenchido, o
			// campo RC_SEMANA da GetDados devera ser o informado no filtro.
			// Se o campo de filtro numero de pagamento nao estiver preenchido, o
			// campo RC_SEMANA da GetDados podera ser qualquer numero de pagamento
			// da consulta padrao.
			If ( cNumPagto <> cNrPag )
				Help(" ",1,"GPA120NPGT")
				lRet := .F.
			Else
			    lRet := ExistCpo("RCH", cProcesso + cPeriodo + cNrPag + "        ", 3)
			EndIf
		EndIf
	EndIf
Return ( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GPEA090Locks    ³Autor³Tatiane Matias      ³ Data ³28/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Bloqueia Lancamentos                                         ³
³          ³(por Funcionario e Periodo)                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL		                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³gp090MontaGetDados                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GPEA090Locks( nOpc , cAlias , aRecnos )

Local lLocks	:= .T.

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se nao For Visualizacao				 					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( nOpc == 3 )
		Break
	EndIf

	If !( lLocks := WhileNoLock( cAlias , aRecnos , { xFilial( cAlias ) + SRA->RA_MAT + cPeriodo} , 1 , 1 , .T. , NIL ) )
		Break
	EndIf

End Sequence

Return( lLocks )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcFilialInit	³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_FILIAL					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_FILIAL                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_FILIAL                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcFilialInit()
If Type("cLancAlias") == "U"
	cLancAlias := "SRC"
EndIf

Return( xFilial( cLancAlias , SRA->RA_FILIAL ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcMatInit		³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_MAT					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_MAT		                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_MAT		                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcMatInit()

Local cRcMatInit

IF ( FunName() == "GPEA100" ) //Lancamentos por Verba
	cRcMatInit := Space( GetSx3Cache( "RC_MAT" , "X3_TAMANHO" ) )
Else
	cRcMatInit := SRA->RA_MAT
EndIF

Return( cRcMatInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcCcInit		³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_CC						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_CC		                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_CC		                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcCcInit()
Return( SRA->RA_CC )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcProcesInit	³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_PROCES					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_PROCES	                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_PROCES	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcProcesInit()
Return( SRA->RA_PROCES )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcPeriodoInit	³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_PERIODO				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_PERIODO	                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_PERIODO	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcPeriodoInit()

Local cRcPeriodoInit

IF ( GetRotExec() == "__cRotInExec" )
	cRcPeriodoInit := Space( GetSx3Cache( "RC_PERIODO" , "X3_TAMANHO" ) )
Else
	cRcPeriodoInit := GetPeriodCalc()
EndIF

Return( cRcPeriodoInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcRoteirInit	³Autor³Marinaldo de jesus  ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_ROTEIR				 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_ROTEIR	                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_ROTEIR	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcRoteirInit()

Local cRcRoteirInit

IF ( GetRotExec() == "__cRotInExec" )
	cRcRoteirInit := Space( GetSx3Cache( "RC_ROTEIR" , "X3_TAMANHO" ) )
Else
	cRcRoteirInit := GetRotExec()
EndIF

Return( cRcRoteirInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcTipo2Init		³Autor³Marinaldo de jesus  ³ Data ³18/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_TIPO2					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_TIPO2	                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_TIPO2	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcTipo2Init()
Return( GetTipo2( fGetTipoRot( RcRoteirInit() ) ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcPostoInit		³Autor³Marinaldo de jesus  ³ Data ³20/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_POSTO					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_POSTO							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_POSTO	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcPostoInit()

Local cRcPostoInit

IF ( GetRotExec() == "__cRotInExec" )
	cRcPostoInit := Space( GetSx3Cache( "RC_POSTO" , "X3_TAMANHO" ) )
Else
	cRcPostoInit := SRA->RA_POSTO
EndIF

Return( cRcPostoInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcDataInit		³Autor³Marinaldo de jesus  ³ Data ³22/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_DATA					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_DATA								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_DATA		                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcDataInit()

Local aArea := RCH->( GetArea() )
Local cRchIndexOrd
Local cRchKeySeek
Local cPeriod		:= GetPeriodCalc()
Local cNumPag		:= GetNumPgCalc()
Local cRotExec		:= GetRotExec()

Local dRcDataInit

Local nRchIndexOrd

IF ( GetRotExec() == "__cRotInExec" )
	dRcDataInit := Ctod("//")
Else
	If RCH->( RCH_PROCES + RCH_PER + RCH_NUMPAG + RCH_ROTEIR ) == ( SRA->RA_PROCES + cPeriod + cNumPag + cRotExec )
		dRcDataInit		:= RCH->RCH_DTPAGO
	Else
		If RCH->( RCH_PROCES + RCH_PER + RCH_NUMPAG + RCH_ROTEIR ) == ( SRA->RA_PROCES + cPeriod + cNumPag + Space( Len( cRotExec ) ) )
			dRcDataInit		:= RCH->RCH_DTPAGO
		Else
			cRchIndexOrd	:= "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR"
			cRchKeySeek		:= ( SRA->RA_PROCES + cPeriod + cNumPag + cRotExec )
			nRchIndexOrd	:= RetOrder( "RCH" , cRchIndexOrd )
			dRcDataInit		:= PosAlias( "RCH" , cRchKeySeek , SRA->RA_FILIAL , "RCH_DTPAGO" , nRchIndexOrd , .F. )
			IF Empty( dRcDataInit ) .and. ( RCH->( RCH_PROCES + RCH_PER + RCH_NUMPAG + RCH_ROTEIR ) != ( SRA->RA_PROCES + cPeriod + cNumPag + cRotExec ) )
				cRchKeySeek		:= ( SRA->RA_PROCES + cPeriod + cNumPag + Space( Len( cRotExec ) ) )
				dRcDataInit		:= PosAlias( "RCH" , cRchKeySeek , SRA->RA_FILIAL , "RCH_DTPAGO" , nRchIndexOrd , .F. )
			EndIF
		EndIF
	EndIF
	IF Empty( dRcDataInit )
		dRcDataInit := dDataBase
	EndIF
EndIF

RestArea( aArea )
Return( dRcDataInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcDtRefInit		³Autor³Marinaldo de jesus  ³ Data ³27/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_DATA					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_DATA								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_DATA		                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcDtRefInit()

Local dRcDtRefInit

dRcDtRefInit := gp090RetDtRef()
IF Empty( dRcDtRefInit )
	dRcDtRefInit := RcDataInit()
EndIF

Return( dRcDtRefInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcTipo1Init		³Autor³Marinaldo de jesus  ³ Data ³22/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_TIPO1					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo da Filial para o RC_TIPO1							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_TIPO1	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcTipo1Init()
Return( "V" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcTipo1Vld		³Autor³Marinaldo de jesus  ³ Data ³22/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valid para o Campo RC_TIPO1									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T. or .F.													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RC_TIPO1	                             	 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcTipo1Vld()
Return( Pertence("HVD") .And. GP090MOV(.T.)  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcNumPgInit 	³Autor³Tatiane Matias      ³ Data ³10/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializador Padrao para o Campo RC_SEMANA 				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Codigo do Numero de Pagamento para o RC_SEMANA        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RC_SEMANA	                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RcNumPgInit()

Local cRcNumPgInit

IF ( GetRotExec() == "__cRotInExec" )
	cRcNumPgInit := Space( GetSx3Cache( "RC_SEMANA" , "X3_TAMANHO" ) )
Else
	cRcNumPgInit := GetNumPgCalc()
EndIF

Return( cRcNumPgInit )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao  ³Gp090MovimentaºAutor  ³Tatiane Matias      º Data ³  11/08/05   º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³ Executa bloco de codigo a cada movimentacao dos botoes de      º±±
±±º        ³ movimentacao.                                                  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gp090Movimenta( bFunc )

Eval(bFunc)

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao  ³fAtualRot	  ºAutor  ³Mauricio Takakura   º Data ³  25/10/05   º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³ Atualiza a variavel croteiro quando alterar o codigo do periodoº±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fAtualRot()

// Validar o Roteiro //
If !Empty(RCH->RCH_ROTEIR) .OR. (Empty(RCH->RCH_ROTEIR) .AND. cRoteiro <> cRoteiroAnt)
	If cRoteiro <> RCH->RCH_ROTEIR
		If !Empty(RCH->RCH_ROTEIR)
			cRoteiro 	:= RCH->RCH_ROTEIR
		Else
			cRoteiro	:= fGetRotOrdinar()
		EndIf

		// Forcar a carga da getdados //
		cPeriodoAnt := ""
		cSemanaAnt	:= ""
	EndIf
EndIf

Return( .T. )
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RcFuncInitºAutor  ³Silvia Taguti       º Data ³  07/19/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializador Padrao para o campo RC_CODFUNC                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RcFuncInit()

Return( SRA->RA_CODFUNC)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RcDeptoInitºAutor ³Silvia Taguti       º Data ³  03/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializador Padrao para o campo RC_DEPTO                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function RcDeptoInit()

Return( SRA->RA_DEPTO )


/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ MenuDef		³Autor³  Luiz Gustavo     ³ Data ³03/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Isola opcoes de menu para que as opcoes da rotina possam    ³
³          ³ser lidas pelas bibliotecas Framework da Versao 9.12 .      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA090                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³aRotina														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

Static Function MenuDef()
	Local aRotina :=  {}

	aAdd( aRotina, { STR0004 , "PesqBrw"		, 0 , 1 } )	//"Pesquisar"
	aAdd( aRotina, { STR0005 , "Gpea090Mnt"		, 0 , 2 } ) //"Visualizar"
	If cPaisLoc <> "BRA"
		aAdd( aRotina, { STR0008 , "Gpea090Mnt"		, 0 , 5 } ) //"Excluir"
	EndIf
	aAdd( aRotina, { STR0020 , "GPER101(1)" 	, 0 , 6 } ) //"Imprimir"
	If cPaisLoc != "RUS"
		aAdd( aRotina, { STR0031 , "GpLegend"	, 0 , 6 , ,.F.}	) //"Legenda"
	EndIf
	If (FWIsInCallStack("GPEA090")) .and. __lMemCalc
		Aadd(aRotina, {OemToAnsi( STR0087 ), "GPEA091(1)",0,6}) //"Consultar Memória de Calculo"
		Aadd(aRotina, {OemToAnsi( STR0088 ), "GPER091()",0,6}) //"Relatório Memória de Calculo"
	EndIf
Return aRotina
/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp090RetDtRef ³ Autor ³ Tatiane Matias        ³ Data ³27/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³retorna data de referencia do periodo informado             	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
³Sintaxe   ³gp090RetDtRef(lDataIni)											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³lDataIni - indica se retorna o primeiro dia do periodo (.T.).   ³
³          ³        Se esse parametro nao for passado (NIL ou .F.) essa  	³
³          ³  		funcao ira retornar o ultimo dia do periodo informado.  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Data de referencia. Primeiro dia do periodo, se lDataIni = .T.  ³                                                          								   ³
³          ³ ou ultimo dia do periodo.                                   	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpea090LinOk                                                    ³
³          ³GPEA100                                                         ³
³          ³gp090MontaGetDados                                              ³
³          ³X3_RELACAO (SX3) do campo RC_DTREF                              ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function gp090GetRCA(pParam)
	Local aArea  := RCH->( GetArea() )
	Local nLimite:= 0

	// retorna Limite de Horas Dia ou Mes
	dbSelectArea("RCA")
	dbSetOrder(RetOrder("RCA","RCA_FILIAL+RCA_MNEMON") )
	dbSeek(xFilial("RCA")+pParam)

	nLimite := Alltrim(RCA->RCA_CONTEU)

	RestArea( aArea )
Return (nLimite)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RGBRUCEMP_WHEN³ Autor ³Leandro Drumond    ³ Data ³11/01/2012³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³When do campo RGB_RUCEMP 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RGBRUCEMP_WHEN()			                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function RGBRUCEMP_WHEN()

Local aArea		:= GetArea()
Local cRgbPd 	:= aCols[n,GdFieldPos("RGB_PD")]
Local lRet 		:= .F.

If !Empty(cRgbPd) .and. SRV->( dbSeek(xFilial("SRV")+cRgbPd,.F.) )
	If SRV->RV_CODFOL $ "1118|1187"
		lRet := .T.
	EndIf
EndIf

RestArea(aArea)

Return (lRet)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RBRucValid³ Autor ³Leandro Drumond        ³ Data ³11/01/2012³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Valid do campo RGB_RUCEMP									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RBRucValid()				                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function RGBRucValid()

Local aArea		:= GetArea()
Local cRgbPd 	:= aCols[n,GdFieldPos("RGB_PD")]
Local cRucEmp	:= ""
Local nPosRuc   := GdFieldPos("RGB_RUCEMP")
Local lRet 		:= .T.

If nPosRuc > 0
	cRucEmp := If (Type('M->RGB_RUCEMP') == "U", aCols[n,nPosRuc],M->RGB_RUCEMP)

	If Empty(cRucEmp) .and. SRV->( dbSeek(xFilial("SRV")+cRgbPd,.F.) )
		If SRV->RV_CODFOL $ "1118|1187"
			lRet := .F.
			If lGp580Auto
				AutoGrLog(OemtoAnsi(STR0060))
			Else
			 	MsgInfo( OemtoAnsi(STR0060) )  //"RUC do empregador deve ser informado para esta verba"
		 	EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return (lRet)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp090VldDel³ Autor ³Leandro Drumond       ³ Data ³03/04/2014³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Valid se verba pode ser deletada							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gp090VldDel()				                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Gp090VldDel(cKeyRCH,nOpcx)

Local aArea		:= GetArea()
Local lAchou 	:= .T.
Local lRet 		:= .T.
Local nPosTipo2 := 0
Local nPosOri	:= 0
Local lBloqPON	:= ("1" $ SuperGetMv( "MV_BLOQPON",,"" ))
Local nPosCC 	:= 0
Local nPosItem 	:= 0
Local nPosClvl 	:= 0
Local nPosPd 	:= 0
Local nPosSRC	:= 0
Local cPd		:= ""
Local cEol      := Chr(13) + Chr(10)
Local lSRC		:= .F.
Local nPosLOTPLS := 0 //Para controle dos registros que vieram do módulo SIGAPLS
Local nPosCODRDA := 0 //Para controle dos registros que vieram do módulo SIGAPLS
Local lIntPFS    := SuperGetMV("MV_JINTGPE", .F., "1") == "2" //Para controle dos registros que vieram do módulo SIGAPFS

If cLancAlias == "RGB"

	lGp580Auto := If (Type("lGp580Auto") == "U",.F.,lGp580Auto)

	If !lGp580Auto
		aCols  := oGet:aCols
	EndIf

	nPosTipo2 	:= GdFieldPos("RGB_TIPO2")
	nPosOri   	:= GdFieldPos("RGB_ROTORI")
	nPosCC		:= GdFieldPos("RGB_CC")
	nPosItem 	:= GdFieldPos("RGB_ITEM")
	nPosClvl 	:= GdFieldPos("RGB_CLVL")
	nPosLOTPLS	:= GdFieldPos("RGB_LOTPLS")
	nPosCODRDA	:= GdFieldPos("RGB_CODRDA")

	If FunName() == "GPEA590"
		cPd		:= cCod	// Código da verba posicionada.
	ElseIf nOpcx # 5
		nPosPd 	:= GdFieldPos("RGB_PD")
		cPd		:= aCols[n,nPosPd]
	EndIf

	If (nOpcx == 5)

		If aScan( aCols, { |x| x[nPosTipo2] == "F" } ) > 0
			MsgInfo( OemtoAnsi(STR0083) ) // "Há uma ou mais verbas provenientes do periodo anterior que não podem ser excluídas. A exclusão não sera realizada."
			lRet := .F.
		Else
			/* 	Bloqueia exclusão de verbas vindas do SIGAPON	*/
			If lBloqPON .And. aScan( aCols, { |x| x[nPosTipo2] == "E" } ) > 0
				lRet := .F.
				If lGp580Auto
					AutoGrLog(OemtoAnsi(STR0066))
				Else
				 	MsgInfo( OemtoAnsi(STR0066) )  //"As verbas vindas do SIGAPON estão bloqueadas para exclusão! Contate o responsavel do RH!"
			 	EndIf
			EndIf

			If lRet .And. nModAuto != 2
				If aScan( aCols, { |x| (!Empty( x[nPosOri] ) .AND. x[nPosTipo2] <> "E" ) .Or. x[nPosTipo2] == "A" } ) > 0
					MsgInfo( OemToAnsi( STR0080 ) ) 	//Esta verba foi gerada através da rotina de integração. Para estas verbas é necessário utilizar o Cancelamento de Integração, na rotina de Integração.
					lRet := .F.
				EndIf
			EndIf

			If lRet
				If ( nPosSRC := aScan( aCols, { |x| x[nPosTipo2] == "I" } ) ) > 0

					If !lItemClVl
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lSRC := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[nPosSRC,nPosCC] ) )
					Else
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lSRC := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[nPosSRC,nPosCC] + aCols[nPosSRC,nPosItem] + aCols[nPosSRC,nPosClvl] ) )
					EndIf

					If lSRC
						If (MsgYesNo( OemToAnsi(STR0074) + cEol+cEol+;  //"Esta verba é do tipo Informado.Se apagá-la, o cálculo também será apagado por motivos de integridade. Deseja continuar?
						 			  OemToAnsi(STR0078))) 				//"Para recalcular os lançamentos use a tecla F6 (Calcular)."
							lRet		:= .T.
							lDelCalc	:= .T.
						Else
							lRet := .F.
						EndIf
					EndIf
				EndIf
			EndIf

			If lRet .And. ( nPosSRC := aScan( aCols, { |x| !( x[nPosTipo2] == "I" ) } ) ) > 0
				If !lItemClVl
					SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
					lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[nPosSRC,nPosCC] ) )
				Else
					SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
					lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[nPosSRC,nPosCC] + aCols[nPosSRC,nPosItem] + aCols[nPosSRC,nPosClvl] ) )
				EndIf

				If lAchou
					Help(" ", 1, OemToAnsi(STR0040), Nil, OemToAnsi(STR0068), 1, 0 )//"Atenção"##"Exclusão não permitida pois a verba foi encontrada na tabela SRC"
					lRet := .F.
				EndIf
			EndIf
		EndIf

		If nPosLOTPLS > 0 .AND. nPosCODRDA > 0 .AND. aScan( aCols, { |x| !(empTy(x[nPosLOTPLS])) } ) > 0 .And. nModulo <> 77
			If lIntPFS // Integração conta corrente participante SIGAPFS com SIGAGPE pois é utilizado o mesmo campo do lote do PLS (RGB_LOTPLS)
				MsgInfo(STR0120) //"Não é possível prosseguir a exclusão, pois há pelo menos um lançamento com origem no módulo SIGAPFS."
			Else
				MsgInfo(STR0113) //"Não é possível prosseguir a exclusão, pois há pelo menos um lançamento com origem no módulo SIGAPLS."
			EndIf
			lRet := .F.
		EndIf
	Else
		If aCols[n,nPosTipo2] == "F"
			MsgInfo( OemtoAnsi(STR0083) ) // "Há uma ou mais verbas provenientes do periodo anterior que não podem ser excluídas. A exclusão não sera realizada."
			lRet := .F.
		Else
			/* 	Bloqueia exclusão de verbas vindas do SIGAPON	*/
			If lBloqPON .And. Upper(aCols[n,nPosTipo2]) == "E"
				lRet := .F.
				If lGp580Auto
					AutoGrLog(OemtoAnsi(STR0066))
				Else
				 	MsgInfo( OemtoAnsi(STR0066) )  //"As verbas vindas do SIGAPON estão bloqueadas para exclusão! Contate o responsavel do RH!"
			 	EndIf
			EndIf

	      	If lRet
				If ((!Empty( aCols[n,nPosOri] ) .AND. aCols[n,nPosTipo2] <> "E" ) .Or. aCols[n,nPosTipo2] == "A") .And. (aCols[n,nPosTipo2] != "I" .And. aCols[n,nPosOri] == "PON")
					MsgInfo( OemToAnsi( STR0080 ) ) 	//Esta verba foi gerada através da rotina de integração. Para estas verbas é necessário utilizar o Cancelamento de Integração, na rotina de Integração.
					lRet := .F.
				EndIf
	      	EndIf

	      	If lRet
				If !Empty(aCols[n,nPosOri]) .Or. aCols[n,nPosTipo2] == "I"

					If !lItemClVl
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lSRC := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[n,nPosCC] ) )
					Else
						SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
						lSRC := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[n,nPosCC] + aCols[n,nPosItem] + aCols[n,nPosClvl] ) )
					EndIf

					If lSRC
						If (MsgYesNo( OemToAnsi(STR0074) + cEol+cEol+;  //"Esta verba é do tipo Informado.Se apagá-la, o cálculo também será apagado por motivos de integridade. Deseja continuar?
						 			  OemToAnsi(STR0078))) 				//"Para recalcular os lançamentos use a tecla F6 (Calcular)."
							lRet		:= .T.
							lDelCalc	:= .T.
						Else
							lRet := .F.
						EndIf
					EndIf
			 	EndIf
	    	EndIf

			If lRet .And. !GdDeleted() .And. !(aCols[n,nPosTipo2] == "I")
				If !lItemClVl
					SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ) )
					lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[n,nPosCC] ) )
				Else
					SRC->( dbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ+DTOS(RC_DTREF)" ) ) )
					lAchou := SRC->( dbSeek( SRA->RA_FILIAL + cProcesso + SRA->RA_MAT + cPeriodo + cSemana + cRoteiro + cPd + aCols[n,nPosCC] + aCols[n,nPosItem] + aCols[n,nPosClvl] ) )
				EndIf

				If lAchou
					Help(" ", 1, OemToAnsi(STR0040), Nil, OemToAnsi(STR0068), 1, 0 )//"Atenção"##"Exclusão não permitida pois a verba foi encontrada na tabela SRC"
					lRet := .F.
				EndIf
			EndIf
		EndIf

		If nPosLOTPLS > 0 .AND. nPosCODRDA > 0 .AND. !(EmpTy(aCols[n,nPosLOTPLS])) .AND. ( !(EmpTy(aCols[n,nPosCODRDA])) .OR. lIntPFS ) .And. nModulo <> 77
			lRet := .F.
			If lIntPFS
				MsgInfo(STR0114 + aCols[n,nPosLOTPLS] + STR0119) //"O registro não pode ser excluído, pois sua origem é um lote de pagamento [ " ### " ] do módulo SIGAPFS."
			Else
				MsgInfo(STR0114 + aCols[n,nPosLOTPLS] + STR0112) //"O registro não pode ser excluído, pois sua origem é um lote de pagamento [ " ### " ] do módulo SIGAPLS."

			EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*/{Protheus.doc} fCalcLanc
Efetua o cálculo da Folha para o funcionario em edicao.

@author Esther de Viveiro
@since 22/10/2014
@version P12

@param cFil, caractere, Filial do funcionario
@param cMat, caractere, Matricula do funcionario

@return nulo
/*/
Static Function fCalcLanc(cFil, cMat)
Local aArea		:= GetArea()
Local cFiltraWF	:= ""
Local cFilAux	:= ''
Local aSRCCols	:= {}
Local aPerAtual := {}
Local nRecno	:= SRA->(Recno())

Private lGestPubl	:= fUsaGFP()	 //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

aSRCCols := oGet:aCols

If !ArrayCompare( aSRCCols , aColsAnt ) //se houve alteracoes
	If !(MsgNoYes ( (STR0063), (STR0040)))
			//As alteracoes nao foram salvas e nao serao consideradas para o calculo. Deseja continuar mesmo assim?
		Return //cancela calculo
	EndIf
EndIf

cFiltraWF := "RA_FILIAL == '" + cFil + "' .AND. RA_MAT == '" + cMat + "'"

If Empty(cRoteiro) .or. fGetTipoRot(cRoteiro) $ "3/4/G/J"
	MsgInfo( OemtoAnsi(STR0072) )  //"Cálculo não disponível para este roteiro."
	Return Nil
EndIf

If !fGetPerAtual( @aPerAtual, , cProcesso, cRoteiro ) .or. aPerAtual[1,1] <> cPeriodo
	MsgInfo( OemtoAnsi(STR0073) )  //"Período selecionado não corresponde ao período ativo de cálculo."
	Return Nil
EndIf


cFilAux:= dbFilter()
SRA->(DBClearFilter())

Gpem020(.T.,;			//Define Que a Chamada Esta Sendo Efetuada Atraves do WorkFlow
		 cProcesso,;	//Define o processo que sera calculado
		 cRoteiro,;	//Define o roteiro que sera calculado
		 cFiltraWF;	//Filtro executado na rotina
		 )

MostraErro() //Mostra Log do Calculo

Set Filter To &cFilAux

SRA->(dbGoto(nRecno))
RstExecCalc() //Restaurar as Static apos o calculo
RestArea(aArea)
Return (Nil)


/*/{Protheus.doc} ChamaRGB
	Faz chamada de Inclusão/Alteração e Exclusão da tabela RGB
@author philipe.pompeu
@since 09/04/2015
@version P12
@param nOpcao, numérico, Opção à ser chamada
@return Nil, Valor Nulo
/*/
Static Function ChamaRGB(nOpcao)
	Local aArea	:= RGB->( GetArea() )
	Local cValAnt	:= "SRC"

	if(Type("cLancAlias") == "U")
		Private cLancAlias:="RGB"
	Else
		cValAnt := cLancAlias
		cLancAlias:="RGB"
	endIf

	Gpea090Mnt( cLancAlias , 0 , nOpcao)

	cLancAlias:=cValAnt

	RestArea(aArea)
Return Nil


/*/{Protheus.doc} IsIntegracao
Verifica se algum do fonte de Integração estão na Pilha de chamada
@author PHILIPE.POMPEU
@since 29/06/2015
@version P12
@return lReturn, verdadeiro se encontrado
/*/

Static Function IsIntegracao()
	Local lResult := (IsInCallStack("GPEM009") .Or. IsInCallStack("GPEM015") .Or. IsInCallStack("GPEM015A"))
Return lResult

/*/{Protheus.doc} IntegDef
	Rotina responsável pela Mensagem Única da Rotina GPEA090
@author PHILIPE.POMPEU
@since 14/04/2015
@version P12
@param cXML, character, o XML em forma de string
@param nTypeTrans, numérico, Tipo de Transmissão
@param cTypeMessage, character, Tipo da Mensagem
@param cVerMsg, character, Versão da Mensagem
@return aRet, Vetor
/*/

Static Function IntegDef( cXML, nTypeTrans, cTypeMessage,cVerMsg)
	Local aRet := {}
	Default cVerMsg := "1.000"
	aRet:= GPEI090( cXML, nTypeTrans, cTypeMessage, cVerMsg)
Return aRet


/*/{Protheus.doc} Gp090Src()
	Realiza a exclusao do calculo na tabela SRC para quando
	for deletada uma verba do tipo Informada.
@author raquel.andrade
@since 23/06/2016
@version P12.1.7
/*/
Static Function Gp090Src()

Local aArea    := GetArea()
Local cQuery
Local cNameDB
Local cDelet
Local cSqlName := InitSqlName( "SRC" )

//O banco DB2 nao aceita o nome da tabela apos o comando DELETE
cNameDB	:= Upper(TcGetDb())

cQuery := "DELETE "

cDelet := "SRC.D_E_L_E_T_ = ' ' "

If ( cNameDB $ "INFORMIX" )
	cDelet	:= cSqlName +  ".D_E_L_E_T_ = ' ' "
EndIf

If !( cNameDB $ "DB2_ORACLE_INFORMIX_POSTGRES" )
	cQuery += cSqlName
EndIf

//O Informix precisa do nome da tabela ao inves do Alias no comando DELETE
If ( cNameDB $ "INFORMIX" )
	cQuery += " FROM " + cSqlName
Else
	cQuery += " FROM " + cSqlName + " SRC"
	cSqlName := "SRC"
EndIf

cQuery += " WHERE " + cSqlName + ".RC_FILIAL = '" + SRA->RA_FILIAL + "'"
cQuery += " AND " + cSqlName + ".RC_MAT = '" + SRA->RA_MAT + "'"
cQuery += " AND " + cSqlName + ".RC_PROCES = '" + cProcesso + "'"
cQuery += " AND " + cSqlName + ".RC_ROTEIR = '" + cRoteiro + "'"
cQuery += " AND " + cSqlName + ".RC_PERIODO = '" + cPeriodo + "'"
cQuery += " AND " + cSqlName + ".RC_SEMANA = '" + cNumPagto + "'"

cQuery += " AND " + cDelet

TcSqlExec( cQuery )
RestArea( aArea )
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGetRotRes  ºAutor  ³Alfredo Medrano   º Data ³  16/06/2015 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna el Procedimiento de calculo Finiquito / Recisión   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA090                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
static Function fGetRotRes(lTransfEmp )
Local aArea 			:= GetArea()
Local cRotRes			:= ""
Local cAliasSRY		:= "SRY"

	DbSelectArea( "SRY" )


	(cAliasSRY)->( DbGoTop() )
	While (cAliasSRY)->( !Eof() )
		If (cAliasSRY)->RY_TIPO == "4"
			cRotRes := (cAliasSRY)->RY_CALCULO
			Exit
		EndIf
		(cAliasSRY)->( DbSkip() )
	EndDo
RestArea( aArea )

Return( cRotRes )


Static Function addVirtCpo(aHeader,aCols,aVirtual,cPrefixo,aGhCols)
	Local aAreas := {SX3->(GetArea()),SRV->(GetArea())}
	Local nPosGhost := 0
	Local nPosDesc := 0
	Local aCampos := {'RV_INSS','RV_FGTS','RV_IR','RV_INCORP'}
	Local nI := 0
	Local nX := 0
	Local nJ := 0
	Local nT := 0
	Local cCpNome 	:= ''
	Local nCount 	:= 0
	Local lGhCols	:= Len(aGhCols) > 0
	nPosGhost := GdFieldPos("GHOSTCOL", aHeader)
	if(nPosGhost > 0)
		nPosDesc	:= GdFieldPos( cPrefixo + "DESCPD"	, aHeader)
		nPosPd		:= GdFieldPos( cPrefixo + "PD"		, aHeader )
		SRV->(dbSetOrder(1))
		SX3->(dbSetOrder(2))
		for nI:= 1 to Len(aCampos)
			cCpNome := cPrefixo + SubStr( aCampos[nI], At('_',aCampos[nI])+ 1)

			if(GdFieldPos(cCpNome, aHeader) == 0)
				if(SX3->(dbSeek(aCampos[nI])))
					nCount++
					aSize(aHeader,Len(aHeader) + 1)
					nX := nPosGhost + (nCount - 1)
					aIns(aHeader, nX)
					aHeader[nX] := aClone(aHeader[nPosDesc])
					aHeader[nX,1] := AllTrim(SX3->X3_TITULO)
					aHeader[nX,2] := cCpNome
					aHeader[nX,3] := AllTrim(SX3->X3_PICTURE)
					aHeader[nX,4] := SX3->X3_TAMANHO
					aHeader[nX,5] := SX3->X3_DECIMAL
					aHeader[nX,6] := ""
					aHeader[nX,8] := SX3->X3_TIPO
					aHeader[nX,9] := SX3->X3_ARQUIVO
					aHeader[nX,11]:= SX3->X3_CBOX
					aHeader[nX,17]:= .F.

					for nJ:= 1 to Len(aCols)
						If lGhCols
							For nT := 1 to Len(aGhCols)
								aSize(aGhCols[nT],Len(aGhCols[nT]) + 1)
								aIns(aGhCols[nT], nX)
								aGhCols[nT,nX] := ""
								If(Left(aCampos[nI],2) == 'RV')
									If(SRV->(dbSeek(xFilial('SRV')+ aGhCols[nT ,nPosPd])))
										aGhCols[nT,nX]	:= SRV->(&(aCampos[nI]))
									EndIf
								EndIf
							Next nT
						EndIf
						aSize(aCols[nJ],Len(aCols[nJ]) + 1)
						aIns(aCols[nJ], nX)
						aCols[nJ,nX] := ""
						If(Left(aCampos[nI],2) == 'RV')
							If(SRV->(dbSeek(xFilial('SRV')+ aCols[nJ ,nPosPd])))
								If Empty(AllTrim(SRV->(&(aCampos[nI]))))
									aCols[nJ,nX] := "N"
								Else
									aCols[nJ,nX] := SRV->(&(aCampos[nI]))
								EndIf
							EndIf
						EndIf
					next nJ

					aAdd(aVirtual,cCpNome)
				endIf
			endIf
		next nI
	endIf
	aEval(aAreas,{|x|RestArea(x)})
Return Nil
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGP90MultV      ºAutor  ³Equipe RH        º Data ³ 15/10/13 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que avalia se existe no FOLMES em uso, lancamento de º±±
±±º          ³Multiplos Vinculos.                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cTipo:	'A'-avaliar se tem multiplos vinculos             º±±
±±º          ³       	'V'-avaliar e visualizar multiplos vinculos       º±±
±±º          ³ cOrigem:	'1'-Origem Lancamentos Mensais                    º±±
±±º          ³ 			'2'-Lancamentos 13 salario                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA090 - Acoes relacionas "Multiplos Vinculos"            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fGP90MultV(cTipo,cOrigem)
Local aArea			:= GetArea()
Local aRet       	:= {}
Local lRet			:= .F.
Local oModel
Local cAliasRAW		:= "RAW"
Local cRawFOLMES	:= IIF(cPeriodo==nil, RGB->RGB_PERIOD,cPeriodo)

DEFAULT cTipo	:= 'A' //A - de Averigua se existe Multiplo Vinculos
DEFAULT cOrigem	:= '1' //1-Origem Lancamentos Mensais - 2-Lancamentos 13 salario

If cTipo # 'A'
	oModel     	:= FWLoadModel( "GPEA924")
EndIf

dbSelectArea("RAW")
(cAliasRAW)->(dbSetOrder(1))

If (cAliasRAW)->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cRawFOLMES) )
	If cTipo $ 'A'
		lRet:= .T.
	Else
		oModel:SetOperation( MODEL_OPERATION_VIEW )
		oModel:Activate()
		FWExecView(OemtoAnsi(STR0030), "GPEA924", MODEL_OPERATION_VIEW,,{||.T.}) 	//"Multiplos Vinculos"
	EndIf
EndIf

RestArea(aArea)
Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGP90ExcMV      ºAutor  ³Equipe RH        º Data ³ 24/09/13 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que avalia se existe no FOLMES em uso, lancamento de º±±
±±º          ³Multiplos Vinculos.                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cOrigem:	'1'-Origem Lancamentos Mensais                    º±±
±±º          ³ 			'2'-Lancamentos 13 salario                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA090 - Acoes relacionas "Multiplos Vinculos"            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fGP90ExcMV(cOrigem)
Local aArea			:= GetArea()
Local oModel     	:= FWLoadModel( "GPEA924")
Local aRet       	:= {}
Local lRet			:= .F.
Local cAliasRAW		:= "RAW"
Local cRawFOLMES	:= cPeriodo

DEFAULT cOrigem		:= '1'

dbSelectArea("RAW")
(cAliasRAW)->(dbSetOrder(1))

If (cAliasRAW)->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cRawFOLMES+cOrigem) )

	oModel:SetOperation( MODEL_OPERATION_DELETE )
	oModel:Activate()
	If ( lRet := oModel:VldData() )
		lRet := oModel:CommitData()
	EndIf

	If !lRet
		// Se os dados não foram validados obtemos a descrição do erro para gerar LOG ou mensagem de aviso
		aRet   := oModel:GetErrorMessage()
		HELP(2,aRet[5],aRet[6],aRet[7])
	EndIf

	// Desativamos o Model
	oModel:DeActivate()
EndIf

RestArea(aArea)
Return lRet

/*/{Protheus.doc} PLSxGPEVLD
Verifica se algum campo de um determinado lançamento teve alteração, caso algum tenha, retorna .F.
para a validação da Linha na verificação de alteração de registro gravado pelo SIGAPLS
@type Static function
@author Oscar Zanin
@since 08/05/2019
@version 1.0
/*/
Static Function PLSxGPEVLD(aColsZ, aColsAntZ)

Local lRet	:= .T.
Local nI	:= 0

Default aColsZ 		:= {}
Default aColsAntZ	:= {}

For nI := 1 To Len(aColsZ)
	If aColsZ[nI] <> aColsAntZ[nI]
		lRet := .F.
		Exit
	EndIf
Next

Return lRet

/*/{Protheus.doc} fMedHist
Geração relatório de médias
@author Flavio Correa
@since 31/10/19
@version 1.0
/*/
Static Function fMedHist()

If fTemHMed(cDataIni,,cPeriodo,cNumPagto,cRoteiro)
	fVerHistMed("",cDataIni)
Else
	Aviso(STR0040,STR0118) //Atenção##"Sem dados para imprimir!"
EndIf

Return

/*/{Protheus.doc} fAjustAcols
	Se o RGB_NUMID já existir nos lancamentos sera tratado como Alteração
	@type  Function
	@author Emerson Grassi Rocha
	@since 16/10/2020
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function fAjustAcols(aSRCCols)
Local nPosRecRgb 	:= GdFieldPos("RGB_REC_WT")
Local nPosPd		:= GdFieldPos("RGB_PD")
Local nPosNumId		:= GdFieldPos("RGB_NUMID")
Local nPosSeq		:= GdFieldPos("RGB_SEQ")
Local nSRCCols 		:= 0
Local nColsAnt		:= Len(aColsAnt)
Local nColsSRC		:= Len(aSRCCols)
Local nx
Local cChave
Local nPos

// Verificar se a rotina relacionou indevidamente um registro diferente já gravado
For nx := 1 To nColsAnt
	If nX <= nColsSRC .And.;
		aSRCCols[nx][nPosRecRgb] = aColsAnt[nx][nPosRecRgb] .And.;
		aSRCCols[nx][nPosNumId] <> aColsAnt[nx][nPosNumId]

		Aadd(aSRCCols, Aclone(aSRCCols[nx]))
		aSRCCols[Len(aSRCCols)][nPosRecRgb] := 0
		aSRCCols[Len(aSRCCols)][nPosSeq] := Str(Val(aColsAnt[nx][nPosSeq]) + 1, 1,0)
		aSRCCols[nx]:= Aclone(aColsAnt[nx])
	EndIf
Next nx

// Verificar se passou alteração de um contrato já gravado
nSRCCols := Len(aSRCCols)
For nx := 1 To nSRCCols
	If aSRCCols[nx][nPosRecRgb] = 0
		cChave := aSRCCols[nx][nPosPd]+aSRCCols[nx][nPosNumId]

		nPos := Ascan(aSRCCols, {|x| ( x[nPosPd]+x[nPosNumId] == cChave .and. x[nPosRecRgb] != 0) })

		If nPos > 0
			aSRCCols[nPos] := aClone(aSRCCols[nx])
			aSRCCols[nx][nPosNumId] := ""
			aSRCCols[nx][nPosRecRgb] := 9999999999
		EndIf
	EndIf
Next nx

Do While ( nPos := Ascan(aSRCCols,{|x| x[nPosRecRgb]==9999999999}) ) > 0
	ADel(aSRCCols,nPos)
	Asize(aSRCCols,--nSRCCols)
EndDo

Return
