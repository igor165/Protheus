#INCLUDE "ATFA370.ch"
#INCLUDE "FILEIO.CH"  
#INCLUDE "PROTHEUS.CH"

Static __cExt 	:= GetDbExtension()
Static lBlind	:= IsBlind()
Static a330RegCTB := {} // Array com filiais a serem processadas na contabilizacao
Static __lConOut := if( GetNewPar("MV_CONOUTR",0) > 0, .T., .F. )

//********************************
// Controle de multiplas moedas  *
//********************************
Static lMultMoed := .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ ATFA370	³ Autor ³ Claudio D. de Souza	³ Data ³ 31/07/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±± 
±±³Descri‡…o ³ Programa de contabilizacao off-line do Ativo        		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Atfa370  								  				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SIGAATF									  				  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION ATFA370(lDireto, aPARAMAUTO)
LOCAL nOpca    	:= 0
LOCAL aButtons 	:= {}
LOCAL aSays    	:= {}
LOCAL cPerg		:= "AFA370"
LOCAL cSEMATF	:= GetNextAlias()
LOCAL lATF130VLD := ExistBlock("ATF370VLD")
Local lRet		 := .T.	

DEFAULT lDireto		:= .F.
DEFAULT aPARAMAUTO	:= {}

PRIVATE cCadastro := STR0003 //"Contabilização off-line do Ativo fixo"

AADD(aSays, STR0001 ) //"Este programa tem como objetivo contabilizar as     "
AADD(aSays, STR0002 ) //"correções, depreciações e correções das depreciações"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para parametros                         ³
//³ mv_par01 // Data Inicial ?                                   ³
//³ mv_par02 // Data Final ?                                     ³
//³ mv_par03 // Aglutina Lancamentos: (Sim/Nao)                  ³
//³ mv_par04 // Considera C.Custo (Sim/Nao)                      ³
//³ mv_par05 // Mostra Lanctos Contabeis                         ³
//³ mv_par06 // Considera Filiais Abaixo (Sim/Nao)               ³
//³ mv_par07 // Da Filial                                        ³
//³ mv_par08 // Ate a Filial                                     ³
//³ mv_par09 // Do Bem                                           ³
//³ mv_par10 // Ate o Bem                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Pergunte(cPerg,.F.)

//Verifica se o Ativo está atualizado
ATFXKERNEL()

IF lBlind .Or. lDireto // Processamento Batch ou Chamada Direta por outra Rotina

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa o log de processamento                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogIni( aButtons )

	If mv_par06 == 1 // Seleciona filiais
		If ATFCanProc(cSEMATF, mv_par01, mv_par02, mv_par07,mv_par08) // Data de, Data Ate, Filial de, Filial Ate
			ProcLogAtu("INICIO")
			BatchProcess(cCadastro, "Este programa tem como objetivo gerar Lançamentos Contábeis Off para as movimentações" + CRLF + "do módulo Ativo Fixo.",cPerg,{ || Atfa370Proc(.T.,aPARAMAUTO) }, { || .F. }) ////"Este programa tem como objetivo gerar Lançamentos Contábeis Off para as movimentações"#"do módulo Ativo Fixo."
		EndIf
	Else
		If ATFCanProc(cSEMATF, mv_par01, mv_par02) // Data de, Data Ate, Filial a processar
			ProcLogAtu("INICIO")
			BatchProcess(cCadastro, "Este programa tem como objetivo gerar Lançamentos Contábeis Off para as movimentações" + CRLF + "do módulo Ativo Fixo.",cPerg,{ || Atfa370Proc(.T.,aPARAMAUTO) }, { || .F. })////"  Este programa tem como objetivo gerar Lançamentos Contábeis Off para as movimentações"#"do módulo Ativo Fixo."
		EndIf	
	EndIf	

	//Libera o Processamento e envia mensagem no server (tempo)
	ATFFreeProc(cSEMATF)        
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogAtu("FIM")
	RETURN .T.

ELSE

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa o log de processamento                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogIni( aButtons )
	
	AADD(aButtons, { 5,.T.,{|| Pergunte("AFA370",.T. ) } } )
	AADD(aButtons, { 1,.T.,{|o| nOpca:= 1,o:oWnd:End()}})
	AADD(aButtons, { 2,.T.,{|o| o:oWnd:End() }})
	
	
	FormBatch( STR0003, aSays, aButtons,,,440) //"Contabilização off-line do Ativo fixo"
		
	If nOpcA == 1
	
		If lATF130VLD
			lRet := ExecBlock("ATF370VLD", .F., .F.,)
        Endif                                              
		         
        If !lRet
        	Return
        Endif
		
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ProcLogAtu("INICIO")

		If mv_par06 == 1 // Seleciona filiais
			If ATFCanProc(cSEMATF, mv_par01, mv_par02, mv_par07,mv_par08) // Data de, Data Ate, Filial de, Filial Ate
				ProcLogAtu("INICIO")
				Processa({|lEnd| Atfa370Proc(.F.)})
			EndIf
		Else
			If ATFCanProc(cSEMATF, mv_par01, mv_par02) // Data de, Data Ate, Filial a processar
				ProcLogAtu("INICIO")
				Processa({|lEnd| Atfa370Proc(.F.)})
			EndIf	
		EndIf	
		//Libera o Processamento e envia mensagem no server (tempo)
		ATFFreeProc(cSEMATF)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o log de processamento   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ProcLogAtu("FIM")	
	Endif

ENDIF

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³Atfa370Pro³ Autor ³ Claudio D. de Souza   ³ Data ³ 31/07/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de contabilizacao off-line do ativo				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Atfa370Proc()											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ ATFA370													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Atfa370Proc(lBat,aPARAMAUTO)
Local aCampos
Local cArqTmp
Local cAtfMoedas
Local cLoteAtf := LoteCont("ATF")
Local cConta
Local cCCusto
Local cSubCta
Local cDebito 
Local cCredito
Local cSubDeb
Local cSubCre
Local cMesAno
Local cCodCusto := ""
Local cDescr
//********************************
// Controle de multiplas moedas  *
//********************************
Local aValor	:= If(lMultMoed,AtfMultMoe(,,{|x| 0}), {0,0,0,0,0} )
/*Local nValor1
Local nValor2
Local nValor3
Local nValor4
Local nValor5*/
Local cQuaisMoedas
Local aLancam := Array( 19 )
Local cQuery
Local cAliasQry
Local cAliasSn3
Local cAliasSn1
Local cArquivo
Local nHdlPrv
Local lCtb 		:= CtbInUse()
Local lPadrao	:= VerPadrao("820")
Local lATFInfl	:= If( cPaisLoc=="ARG", GetNewPar("MV_ATFINFL",.F.), .F. ) // Ajuste por Inflacao
Local lPdrAju	:= .F.  // 830 - cPadrao para Ajuste por Inflacao (Paises Localizados)
Local nTotal	:= 0
Local cProva 	:= ""

Local aCamposTrc := {}
Local cNomTRC   :="",cNomTRC1 :=""
Local nThreads:= 1 //IIf(lCtb .And. SuperGetMv('MV_A370THR',.F.,1))
Local cFilDe  := cFilAnt
Local cFilAte := cFilAnt
Local cFilOld := cFilAnt
Local nX	  := 0

Local aFlagCTB := {}
Local lUsaFlag := GetNewPar( "MV_CTBFLAG" , .F.) // controle de flags do CTB

Local nInc		:= 0
Local aSM0		:= AdmAbreSM0()

//Variaveis para gravação do código de correlativo
Local aDiario	:= {}
Local lSeqCorr	:= UsaSeqCor("SN1/SN3/SN4")

Local lExclusivo	:= ADMTabExc("SN4")
Local cFilProc		:= ""

Local aStru   := SN4->(dbStruct())

DEFAULT lBat	:= .F.

IF lBat .AND. ValType(aPARAMAUTO) == "A"
	FOR nX := 1 to Len(aPARAMAUTO)
		&("mv_par"+StrZero(nX,2)) := aPARAMAUTO[nX]
	NEXT nX
ENDIF

If nThreads > 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Realiza a criacao e a abertura do arquivo de trabalho "TRC" e cria seu indice.    |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	AADD(aCamposTrc,{ "TRC_FILIAL","C",len(cFilAnt),0 } )
	AADD(aCamposTrc,{ "TRC_SEQUEN","C",12,0 } )
	AADD(aCamposTrc,{ "TRC_LANTRC","C",03,0 } )
	AADD(aCamposTrc,{ "TRC_RECSN3","N",14,0 } )
	AADD(aCamposTrc,{ "TRC_RECSN4","N",14,0 } )
	cNomTRC   := CriaTrab(aCamposTrc,.T.)
	cNomTRC1  := Substr(cNomTRC,1,7)+"Z"

	dbUseArea( .T.,,cNomTRC,"TRC",.T.) //Cria compartilhado para multithread

	IndRegua("TRC",cNomTRC1,"TRC_FILIAL+TRC_SEQUEN")

	dbClearIndex()
	dbSetIndex(cNomTRC1+OrdBagExt())
	dbSetOrder(1)    
Endif

If mv_par06 == 1 // considera filiais
  	cFilDe := mv_par07
  	cFilAte := mv_par08
Endif

//Para usuarios do SigaCon
If ! CtbInUse()
	lUsaFlag := .F.
Endif

For nInc := 1 To Len( aSM0 )
	If aSM0[nInc][1] == cEmpAnt .AND. aSM0[nInc][2] <= cFilAte
		nHdlPrv  := 0	// Endereco do arquivo de contra prova dos lanctos cont.	
		nTotal   := 0	// Total dos lancamentos contabeis
		cArquivo :=""	// Nome do arquivo contra prova
		cFilAnt := aSM0[nInc][2]
		lPadrao	:= VerPadrao("820") // Verificar a existencia do lancamento Padrao na Filial 
		//Tratamento Gestao Corporativa
		If Len(AllTrim(XFilial("SN4")) ) > 2
			If Alltrim(cFilProc) != Alltrim(xFilial("SN4"))
				cFilProc:= xFilial("SN4")
			Else
				Loop
			EndIf
		EndIf

		cAliasQry := GetNextAlias()
		cAliasSn3 := "SN3"
		cAliasSn1 := "SN1"


		cQuery := "SELECT	N4_DATA, N4_OCORR, N4_TIPOCNT, SN4.R_E_C_N_O_ RECNOSN4,"
		//********************************
		// Controle de multiplas moedas  *
		//********************************
		If lMultMoed
			AtfMultMoe(,,{|x| cQuery += "N4_VLROC" + Alltrim(Str(x)) + "," })
		Else
			cQuery += "N4_VLROC1, N4_VLROC2, N4_VLROC3, N4_VLROC4, N4_VLROC5,"
		EndIf	
		cQuery += " SN3.R_E_C_N_O_ RECNOSN3,"
		cQuery += "			SN1.R_E_C_N_O_ RECNOSN1 "

		cQuery += "FROM "+RetSqlName("SN4")+" SN4,"
		cQuery +=         RetSqlName("SN1")+" SN1,"
		cQuery +=         RetSqlName("SN3")+" SN3 "

		cQuery += "WHERE "
		cQuery += "N4_FILIAL = '"+xFilial("SN4")+"' AND "
		cQuery += "N4_DATA  >= '"+Dtos(MV_PAR01)+"' AND "
		cQuery += "N4_DATA  <= '"+Dtos(MV_PAR02)+"' AND "
		cQuery += "N4_CBASE >= '" + MV_PAR09 + "' AND "
		cQuery += "N4_CBASE <= '" + MV_PAR10 + "' AND "
		cQuery += "N4_DCONTAB = ' ' AND "
		cQuery += "N4_OCORR IN ('06','07','08', '10','11','12', '20') AND "
		cQuery += "N4_TIPOCNT IN ('2','3','5') AND "
		cQuery += "N1_FILIAL='"+xFilial("SN1")+"' AND "
		cQuery += "N1_CBASE = N4_CBASE AND "
		cQuery += "N1_ITEM  = N4_ITEM  AND "
		cQuery += "N3_FILIAL='"+xFilial("SN3")+"' AND "
		cQuery += "N3_CBASE = N4_CBASE AND "
		cQuery += "N3_ITEM  = N4_ITEM  AND "
		cQuery += "N3_TIPO  = N4_TIPO  AND "
		cQuery += "N3_SEQ   = N4_SEQ   AND "
		cQuery += "N3_SEQREAV = N4_SEQREAV  AND "
		cQuery += "SN4.D_E_L_E_T_=' '  AND "
		cQuery += "SN1.D_E_L_E_T_=' '  AND "
		cQuery += "SN3.D_E_L_E_T_=' ' "
		//cQuery += "ORDER BY " + SqlOrder(SN4->(IndexKey(1)))

		cQuery := ChangeQuery(cQuery)

		if __lConOut
			CONOUT("ATFA370 | "+ALLTRIM(STR(ThreadId())) + " ChangeQuery " + Time() + " " + ALLTRIM(STR(Seconds())))
			CONOUT("QUERY: " + cQuery) 
		endif

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
		aEval(aStru, {|e| If(e[2]!= "C" .And. (cAliasQry)->(FieldPos(Alltrim(e[1]))) > 0, TCSetField(cAliasQry, e[1], e[2],e[3],e[4]),Nil)})
		
		// Se houver dados a contabilizar, existir o LP ou se nao existir o LP e nao for CTB
		// contabiliza, ou seja somente contabiliza quando nao existir o LP se nao for SIGACTB
		If lATFInfl .And. lPadrao
			lPdrAju	:= VerPadrao("850")
			lPadrao	:= lPdrAju        
		Endif
		
		If ( cAliasQry )->( ! Eof() ) .And. ( lPadrao .Or. ( ! lPadrao .And. ! lCtb ))
			If ! lPadrao .And. ! lCtb // se não tiver LP e Não for do CTB
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gera arquivo de Trabalho                                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
				//********************************
				// Controle de multiplas moedas  *
				//********************************
				aCampos :=	{}
				aAdd(aCampos,{"CONTA"  , "C" , 40,0})
				aAdd(aCampos,{"CONTA"  , "C" , 40,0})
				aAdd(aCampos,{"DATAX"  , "D" , 08,0})
				aAdd(aCampos,{"DESCR"  , "C" , 40,0})
				If lMultMoed
					AtfMultMoe(,,{|x| aAdd(aCampos,{ "VALOR"+Alltrim(Str(x)) , "N" , 17,2}) })
				Else
					aAdd(aCampos,{ "VALOR1" , "N" , 17,2})
					aAdd(aCampos,{ "VALOR2" , "N" , 17,2})
					aAdd(aCampos,{ "VALOR3" , "N" , 17,2})
					aAdd(aCampos,{ "VALOR4" , "N" , 17,2})
					aAdd(aCampos,{ "VALOR5" , "N" , 17,2})
				EndIf
				aAdd(aCampos,{"PATRIM" , "C" ,  1,0})
				aAdd(aCampos,{"CCUSTO" , "C" , 09,0})
				aAdd(aCampos,{"SUBCTA" , "C" , 18,0})
	
				/*aCampos :=	{{"CONTA"  , "C" , 40,0},;
							 {"DATAX"  , "D" , 08,0},;
							 {"DESCR"  , "C" , 40,0},;
							 {"VALOR1" , "N" , 17,2},;
							 {"VALOR2" , "N" , 17,2},;
							 {"VALOR3" , "N" , 17,2},;
							 {"VALOR4" , "N" , 17,2},;
							 {"VALOR5" , "N" , 17,2},;
							 {"PATRIM" , "C" ,  1,0},;
							 {"CCUSTO" , "C" , 09,0},;
							 {"SUBCTA" , "C" , 18,0} }*/
				
				cArqTmp := CriaTrab( aCampos ) // cria o arquivo de trabalho
	
				dbUseArea( .T.,, cArqTmp, "cArqTmp", .T., .F. )
				IndRegua ( "cArqTmp",cArqTmp,"CONTA+CCUSTO",,,STR0004) //"Selecionando Registros..."
			Endif
	
			// Se nao estiver usando multithread, chama Headprova, pois a contabilizacao sera efetuada
			// no modelo antigo.
			If nThreads <= 1
				// Se existir o LP, cria CPROVA
				If lPadrao
					nHdlPrv := HeadProva(cLoteAtf,"ATFA370",Substr(cUsuario,7,6),@cArquivo)
				ElseIf !lPadrao .And. !lCtb
					nHdlPrv := HeadProva( cLoteAtf,"ATFA370",Substr(cUsuario,7,6),@cArquivo,.T.)	
				Endif
			Endif	
				
			While (cAliasQry)->(!Eof())
				dbSelectArea("SN4")
				MsGoto((cAliasQry)->RECNOSN4)
				dbSelectArea("SN1")
				MsGoto((cAliasQry)->RECNOSN1)
				dbSelectArea("SN3")
				MsGoto((cAliasQry)->RECNOSN3)
	
				// mes de referencia
				cMesAno := StrZero( Month( ( cAliasQry )->N4_DATA ) ,2) + "/" + Subs( StrZero( Year( ( cAliasQry )->N4_DATA ) ,4) ,3 ,2)
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se o usuario desejar utilizar centro de custo (MV_PAR04 ==1 ), a cada  ³
				//³ despesa ser  considerado, caso contr rio, dever  ser analisado a obriga³
				//³ toriedade do centro de custo na CONTA, se for obrigado ele sera        ³
				//³ considerado.                                                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If mv_par04 == 1 .Or. lCtb	
					// considerar centro de custo
					cCodCusto := (cAliasSn3)->N3_CUSTBEM
				Else 
					// Nao considerar centro de custo ou nao esta utilizando SIGACTB
					dbSelectArea("SI1")
					dbSetOrder(1)
					
					If dbSeek(xFilial("SI1")+(cAliasSn3)->N3_CCONTAB)
						If SI1->I1_CCOBRIG == "S"	// se CC for obrigat¢rio, deve considerar C.Custo
							cCodCusto := (cAliasSn3)->N3_CUSTBEM
						Endif
					Endif
				Endif
			
				DbSelectArea(cAliasQry)
				If !lPadrao .And. !lCtb
					Do Case
					Case (cAliasQry)->N4_OCORR = "07" .And. (cAliasQry)->N4_TIPOCNT = "2" // Correcao no mes
						//********************************
						// Controle de multiplas moedas  *
						//********************************
						If lMultMoed
							aValorMoed	:= AtfMultMoe(,,{|x| If(x=1,Round((cAliasQry)->N4_VLROC1,2),0) })
						Else
							aValorMoed	:= { Round((cAliasQry)->N4_VLROC1,2),0,0,0,0 }
						EndIf
						a050Traba( (cAliasSn3)->(N3_CCONTAB+N3_CCORREC),(cAliasQry)->N4_DATA,;
									  aValorMoed ,;
									  STR0005+cMesAno				,; //"CORRECAO NO MES "
									  cCodCusto										,;
									  (cAliasSn1)->N1_PATRIM					,;
									  (cAliasSn3)->(N3_SUBCCON+N3_SUBCCOR),;
									  mv_par03==1)
	
					Case (cAliasQry)->N4_OCORR = "06" .And. (cAliasQry)->N4_TIPOCNT = "3" 	// Depreciacao no mes
						//********************************
						// Controle de multiplas moedas  *
						//********************************
						If lMultMoed
							aValorMoed	:= AtfMultMoe(cAliasQry,"N4_VLROC")
						Else
							aValorMoed	:= { (cAliasQry)->N4_VLROC1,(cAliasQry)->N4_VLROC2,(cAliasQry)->N4_VLROC3,(cAliasQry)->N4_VLROC4,(cAliasQry)->N4_VLROC5 }
						EndIf
						a050Traba(	(cAliasSn3)->(N3_CDEPREC+N3_CCDEPR),(cAliasQry)->N4_DATA,;
									aValorMoed ,;
									STR0006+cMesAno		  ,; //"DEPRECIACAO NO MES "
									cCodCusto									  ,;
									(cAliasSn1)->N1_PATRIM				  ,;
									(cAliasSn3)->(N3_SUBCDEP+N3_SUBCCDE),;
									mv_par03==1)
	
					Case (cAliasQry)->N4_OCORR = "08" .And. (cAliasQry)->N4_TIPOCNT = "5" // Correcao da depreciacao no mes
						//********************************
						// Controle de multiplas moedas  *
						//********************************
						If lMultMoed
							aValorMoed	:= AtfMultMoe(,,{|x| If(x=1,Round((cAliasQry)->N4_VLROC1,2),0) })
						Else
							aValorMoed	:= { Round((cAliasQry)->N4_VLROC1,2),0,0,0,0 }
						EndIf
						a050Traba(	(cAliasSn3)->(N3_CDESP+N3_CCDEPR) ,(cAliasQry)->N4_DATA,;
									aValorMoed ,;
									STR0007+cMesAno,; //"CORRECAO DA DEPRECIACAO NO MES "
									Space(9)									 ,;
									(cAliasSn1)->N1_PATRIM				 ,;
									(cAliasSn3)->(N3_SUBCDES+N3_SUBCCDE),;
									mv_par03==1)
					EndCase
	
				ElseIf lPadrao
					cProva := "820"
	
					If lATFInfl .And. ( (cAliasQry)->N4_OCORR $ "07|08" )
						cProva := "850"
					EndIf
	
					// Se nao estiver usando multithread, chama detprova, pois a contabilizacao sera efetuada
					// no modelo antigo.
					If nThreads <= 1
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Tratamento utilização do controle de flags do ctb                      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lUsaFlag
							aAdd(aFlagCTB,{"N4_DCONTAB",dDataBase,"SN4",SN4->(Recno()),0,0,0})
						EndiF
						
						If lSeqCorr
							aAdd(aDiario, {"SN4",SN4->(Recno()),SN4->N4_DIACTB,"N4_NODIA","N4_DIACTB"})
	               		EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Tratamento para campos de controle no CTK e CV3 (TABORI e RECORI)      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aTabRecOri := {"SN4",SN4->(RECNO())}
	
						nTotal += DetProva( nHdlPrv, cProva, "ATFA370", cLoteATF,,,,,,,, @aFlagCTB, aTabRecOri)
					Endif	
				Endif	
	
	
				// Se nao estiver usando multithread, nao cria arquivo temporario,pois a contabilizacao sera efetuada
				// no modelo antigo.
				If nThreads > 1
					GravaRegCT(cFilAnt,SN3->(Recno()),SN4->(Recno()),cProva)
				Else
					If !lUsaFlag
						If RecLock("SN4")
							Replace N4_DCONTAB With dDataBase
							SN4->(MsUnlock())
						Endif	
					Endif
				Endif	
	
				DbSelectArea(cAliasQry)
				DbSkip()
			EndDo	
	
			// Se nao existir o LP e nao for CTB, forca a criacao do Lancamento contabil
			If !lPadrao .And. !lCtb
				//********************************
				// Controle de multiplas moedas  *
				//********************************
				cAtfMoedas := ""
				If lMultMoed
					AtfMultMoe(,,{|x| cAtfMoedas += If(x>1 .and. Empty(GetMV("MV_MOEDA"+Alltrim(Str(x)))),"N","S") })
				Else
				cAtfMoedas :=	"S"+If(Empty(GetMV("MV_MOEDA2")),"N","S") + ;
								 	 If(Empty(GetMV("MV_MOEDA3")),"N","S") + ;
									 If(Empty(GetMV("MV_MOEDA4")),"N","S") + ;
									 If(Empty(GetMV("MV_MOEDA5")),"N","S")
				EndIf
	
				dbSelectArea("cArqTmp")
	
				dbGoTop()
				Procregua( Reccount() )
				While !Eof()
		
					cConta  := CONTA
					cCCusto := CCUSTO
					cSubCta := SUBCTA
			    
					If Patrim != "S"
						cDebito := SubStr( cConta,  1, 20 )
						cCredito:= SubStr( cConta, 21, 20 )
						cSubDeb := SubStr( cSubCta, 1,  9 )
						cSubCre := SubStr( cSubCta,10,  9 )
					Else
						cDebito := SubStr( cConta , 21, 20 )
						cCredito:= SubStr( cConta ,  1, 20 )
						cSubDeb := SubStr( cSubCta, 10,  9 )
						cSubCre := SubStr( cSubCta,  1,  9 )
					Endif
					cDescr  := Descr
					//********************************
					// Controle de multiplas moedas  *
					//********************************
					aValor	:= If(lMultMoed,AtfMultMoe(,,{|x| 0}), {0,0,0,0,0} )
					/*nValor1 := 0
					nValor2 := 0
					nValor3 := 0
					nValor4 := 0
					nValor5 := 0*/
			
					While !Eof() .and. cConta == CONTA .And. cCCusto == CCUSTO
			
						IF !lBat
							INCPROC()
						ENDIF
						//********************************
						// Controle de multiplas moedas  *
						//********************************					
						If lMultMoed
							aValor	:= AtfMultMoe(,,{|x| aValor[x] += &("VALOR"+Alltrim(Str(x))) })
						Else
							aValor[1] += VALOR1
							aValor[2] += VALOR2
							aValor[3] += VALOR3
							aValor[4] += VALOR4
							aValor[5] += VALOR5
			            EndIf
						dbSkip()
			   		     
						If mv_par03 == 2  // Nao Aglutina
							Exit
						Endif
			        
					Enddo
			    
					//********************************
					// Controle de multiplas moedas  *
					//********************************
					cQuaisMoedas := ""
					If lMultMoed
						AtfMultMoe(,,{|x| cQuaisMoedas += IIf( aValor[x] # 0, "S","N") })
					Else
					cQuaisMoedas := ""
					cQuaisMoedas += IIf( nValor1 # 0, "S","N")
					cQuaisMoedas += IIf( nValor2 # 0, "S","N")
					cQuaisMoedas += IIf( nValor3 # 0, "S","N")
					cQuaisMoedas += IIf( nValor4 # 0, "S","N")
					cQuaisMoedas += IIf( nValor5 # 0, "S","N")
					EndIf
			    
					aLancam[1] := "X"
					aLancam[2] := cDebito
					aLancam[3] := cCredito
					aLancam[4] := aValor[1]
					aLancam[5] := cQuaisMoedas
					aLancam[6] := cDescr
					aLancam[7] := IIf('CORR' $ cDescr,0,aValor[2])
					aLancam[8] := IIf('CORR' $ cDescr,0,aValor[3])
					aLancam[9] := IIf('CORR' $ cDescr,0,aValor[4])
					aLancam[10]:= IIf('CORR' $ cDescr,0,aValor[5])
					aLancam[11]:= Space( 9 )
					aLancam[12]:= Space( 9 )
					SX3->(DbSetOrder(2))
			    
					If SX3->(dbSeek("I2_CCD")) .and. X3USO(SX3->X3_USADO)
						aLancam[11]:= SubStr(cCCusto+Space(9),1,9)
						aLancam[12]:= Space(9)
					Endif
			    	
					SX3->(DbSetOrder(1))
					aLancam[13]:= Space( 5 )
					aLancam[14]:= "  /  /    "
					aLancam[15]:= Space(40 )
					aLancam[16]:= Space(1)     //inter cp
					aLancam[17]:= Space(10)    //nome do programa
					aLancam[18]:= cSubDeb
					aLancam[19]:= cSubCre
							
					nTotal += AF050DETAL( nHdlPrv,"ATFA010",cLoteAtf, aLancam )
					dbSelectArea("cArqTmp")
			    
				Enddo
			EndIf	
	
			// Se nao estiver usando multithread, chama rodaprova e ca100incl, pois a contabilizacao sera efetuada
			// no modelo antigo.
			If nThreads <= 1
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Envia para Lancamento Contabil                                       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nTotal > 0
					if __lConOut
						CONOUT("ATFA370 | "+ALLTRIM(STR(ThreadId())) + " FUNCTION CATF370INC " + Time() + " " + ALLTRIM(STR(Seconds())))
					endif	
					
					cATF370Inc( cArquivo, @nHdlPrv, cLoteATF, nTotal, @aFlagCTB ,,@aDiario )
				Endif
			Endif	
		Endif
	
		// Fecha a query
		DbSelectArea(cAliasQry)
		DbCloseArea()
	
		// Se o arquivo for compartilhado, processa apenas uma vez
		If !lExclusivo
			Exit
		Endif
	EndIf
Next

If ! Empty( a330RegCTB ) .And. nThreads > 1
	A370Contab(cNomTRC,cNomTRC1,lBat,nThreads)
EndIf			

If Select("TRC") > 0
	DbSelectArea("TRC")
	DbCloseArea()
	fErase(cNomTRC+GetDBExtension())
	fErase(cNomTRC1+IndexExt())
Endif	

If Select("cArqTmp") > 0
	DbSelectArea("cArqTmp")
	DbCloseArea()
	fErase(cArqTmp+GetDBExtension())
	fErase(cArqTmp+IndexExt())
Endif	

If Select("TRC") > 0
	DbSelectArea("TRC")
	DbCloseArea()
	fErase(cNomTRC+GetDBExtension())
	fErase(cNomTRC1+IndexExt())
Endif	
//Ponto de entrada após efetivação da contabilização off line 
If ExistBlock("ATF370CFR")
	ExecBlock("ATF370CFR", .F., .F.,)
Endif
// Restaura a filial
cFilAnt := cFilOld

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ A330Contab                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 29/01/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Processa geracao de lancamentos contabeis                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = Nome do processo utilizado na funcao ProcLogAtu    ³±±
±±³           ³ ExpC2 = Nome do arquivo de trabalho                        ³±±
±±³           ³ ExpC3 = Nome do indice do arquivo de trabalho              ³±±  
±±³           ³ ExpN4 = Numero de threads avaliadas anteriormente          ³±±  
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A370Contab( cNomTRC, cNomTRC1, lBat, nThreads )
Static aCt5 := {}	 // Variavel para armazenar os lancamentos padroes envolvidos na rotina - Melhora de perfomance na DetProva para SigaCTB

// Armazena filial original
LOCAL cFilBack := cFilAnt  

// Numero de threads para processamento
// Array com controle dos registros para cada thread
LOCAL aThreads	:= {}

// Numero de registros
LOCAL nRegistros := 0
LOCAL nRegProc   := 0
LOCAL nInicio    := 0
LOCAL nValLancto := 0

// Contador
LOCAL nX:=0
LOCAL nZ:=0

// Id do arquivo de log
LOCAL nHdl, nHdlA

// Variaveis utilizadas na contabilizacao
LOCAL nHdlPrv    :=NIL	// Endereco do arquivo de contra prova dos lanctos cont.
LOCAL nTotal     :=0	// Total dos lancamentos contabeis
LOCAL nTotRead   :=0   	// Total lido da thread
LOCAL cLoteAtf   :=""	// Numero do lote para lancamentos do estoque
LOCAL cArquivo   :=""	// Nome do arquivo contra prova
LOCAL aDadosProva:={}  // Array com dados gerados na abertura do lancamento
LOCAL cArray     :=""
Local aFlags     :={}

// Retorna o StartPath
LOCAL cStartPath := GetSrvProfString( "Startpath", "" )
LOCAL cJobFile
Local lUsaFlag := GetNewPar( "MV_CTBFLAG" , .F.) // controle de flags do CTB
Local aFlagCTBs := {} //Estrutura de Arrays p/ Controle independente por Filial

//Variaveis para gravação do código de correlativo
Local aDiario	:= {}
Local lSeqCorr	:= UsaSeqCor("SN1/SN3/SN4")

Local nCol
Local nSize

DEFAULT nThreads:= 1 // SuperGetMv( 'MV_A370THR', .F. ,1 )

If nThreads > 1
	dbSelectArea("TRC")
	dbGoTop()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica Limite Maximo de 15 Threads	    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nThreads > 15
		nThreads := 15
	EndIf

	If ! lBat
		ProcRegua( nThreads * Len( a330RegCTB ), 16, 4)
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajustar o tamanho do Array p/controlar todas as filiais      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aFlagCTBs := Array( Len( a330RegCTB ) )
	
	If lSeqCorr
		TRC->(dbGoTop())	
		While TRC->(!EOF())
			SN4->(dbGoto(TRC->TRC_RECSN4))
			aAdd(aDiario, {"SN4",SN4->(Recno()),SN4->N4_DIACTB,"N4_NODIA","N4_DIACTB"})
			TRC->(dbSkip())
		EndDo
	EndIf     

	For nZ := 1 to Len( a330RegCTB )
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona registros para lancamento contabil                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cFilAnt := a330RegCTB[ nZ, 1 ]
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica numero de registros a serem processados             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nRegistros := a330RegCTB[ nZ, 2 ]

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Analisa a quantidade de Threads X nRegistros                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nRegistros < nThreads
			aThreads   := ARRAY(1) 	// Processa somente em uma Thread
		Else
			aThreads   := ARRAY(nThreads) // Processa com o numero de Threads informada
		EndIf
		
		cLoteAtf := LoteCont("ATF")
		
		nHdlPrv := HeadProva( cLoteAtf, "ATFA370", Substr( cUsuario, 7, 6), @cArquivo, , aDadosProva )
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Armazena dados do cabecalho                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		a330RegCTB[nZ,3]:=nHdlPrv
		a330RegCTB[nZ,4]:=cLoteAtf
		a330RegCTB[nZ,5]:=cArquivo
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Processa os primeiros lancamentos com a DetProva para gerar o|
		//| codigo sequencial do lancamento e informar o codigo para as  |
		//| Threads no array aDadosProva.                                | 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		// Contador de Registros Processados
		nRegProc := 0
		
		// Posiciona no registro inicial
		dbSelectArea("TRC")
		dbSeek(XFilial("TRC",a330RegCTB[nz,1]))

		While !Eof() .AND. TRC->TRC_FILIAL == XFilial("TRC",a330RegCTB[nz,1]) .And. aDadosProva[5] == -5

			// Posiciona registro na tabela SN3
			SN3->(dbGoto(TRC->TRC_RECSN3))

			// Posiciona registro na tabela SN4
			SN4->(dbGoto(TRC->TRC_RECSN4))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Tratamento utilização do controle de flags do ctb                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lUsaFlag
				If aFlagCTBs[nZ] == NIL
					aFlagCTBs[nZ] := {}
				EndIf	
				aAdd( aFlagCTBs[nZ], {"N4_DCONTAB", dDataBase, "SN4", SN4->(Recno()) ,0,0,0})
			EndiF

			// Gera lancamento do 1 registro
			nValLancto := DETPROVA( nHdlPrv, TRC->TRC_LANTRC, "ATFA370"	, cLoteATF,,,,,,aCt5,,@aFlagCTBs[nZ],,aDadosProva)
			
			If !lUsaFlag
				If nValLancto > 0 .And. RecLock("SN4")
					Replace N4_DCONTAB With dDataBase
					SN4->(MsUnlock())
				Endif
			Endif

			nRegProc ++
			
			dbSelectArea("TRC")
			dbSkip()
		End
			
		// Registro Inicial para Contabilizacao
		nInicio := nRegProc + 1
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula o registro original de cada thread e     ³
		//³ aciona thread gerando arquivo de fila.           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX:=1 to Len(aThreads)

			aThreads[nX]:={0,0}

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Na primeira thread registro inicial 2       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nX == 1 .Or. (nX # 1 .And. aThreads[nX-1,2] # (nRegistros))
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calculo para quebra de registros entre as Threads ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				// Registro inicial para processamento
				aThreads[nX,1] := IIf( nX==1, nInicio, aThreads[nX-1,1]+aThreads[nX-1,2] )

				// Quantidade de Registros a Processar
				aThreads[nX,2] := IIf( nX==Len(aThreads), nRegistros-nRegProc, Int((nRegistros-nInicio)/nThreads) )

				// Total de Registros Processados
				nRegProc += aThreads[nX,2]

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Dispara thread para contabilizar            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				StartJob("A370JCTB",GetEnvServer(),.F.,cEmpAnt,cFilAnt,cNomTRC,cNomTRC1,cFilAnt+StrZero(aThreads[nX,1],10,0),aThreads[nX,2],nZ,nX,nHdlPrv,cLoteAtf,cArquivo,aDadosProva,ddatabase,lUsaFlag,__lConOut)
			EndIf		

		Next nX
		
	Next nZ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Incluido para aguardar tempo de abertura da tabela           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Inkey(1)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Chama CA100INCL para cada thread, verificando atraves de arquivo |
	//| se terminou de gerar lancamentos.                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("TRC")
	For nZ:=1 to Len(a330RegCTB)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona registros para lancamento contabil                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cFilAnt := a330RegCTB[nZ,1]
		dbSeek(XFilial("TRC",a330RegCTB[nZ,1]))
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Analisa a quantidade de Threads X nRegistros                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nRegistros:=a330RegCTB[nZ,2]

		If nRegistros < nThreads
			// Processa somente em uma Thread
			aThreads   := ARRAY(1)
		Else
			// Processa com o numero de Threads informada
			aThreads   := ARRAY(nThreads)
		EndIf
		
		// Variaveis utilizadas na contabilizacao
		nHdlPrv  := "" // Endereco do arquivo de contra prova dos lanctos cont.	
		nTotal   := 0  // Total dos lancamentos contabeis
		cLoteAtf := "" // Numero do lote para lancamentos do Ativo
		cArquivo := "" // Nome do arquivo contra prova
		
		For nX := 1 to Len(aThreads)
			// Informacoes do semaforo
			cJobFile:= cStartPath + "mj"+cEmpAnt+cFilAnt+StrZero(nZ,3,0)+StrZero(nX,3,0)+".job"
			
			if __lConOut
					CONOUT("ATFA370 | "+ALLTRIM(STR(ThreadId())) + " Aguardando Abertura do Arquivo H " + Time() + " " + ALLTRIM(STR(Seconds())))
			endif
         
			IF ! lBat
				IncProc("Aguardando a abertura do arquivo: " + cJobFile)
			ENDIF

			nHdl    := 0  // Endereco do arquivo de semaforo  
			While ! KillApp() .And. ! ( File( cJobFile ) .And. ( ( nHdl := FOpen( cJobFile, FO_READWRITE )) > 0 ))
				Sleep(50)
			End

			IF ! lBat
				IncProc("Gerando Arquivo de Contra-Prova ")
			ENDIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pega a primeira posicao do arquivo que identifica o NOVO Lay-Out ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 			If nHdl > 0
				nHdlPrv  := "" // Endereco do arquivo de contra prova dos lanctos cont.	
				cLoteAtf := "" // Numero do lote para lancamentos do estoque
				cArquivo := "" // Nome do arquivo contra prova
				nTotRead := "" // Total dos lancamentos contabeis 
				cArray   := "" // Variavel com conteudo do array

				fSeek( nHdl, 0, 0)

				cLinha		:= Space(64 * 1024)
				FReadLn(nHdl, @cLinha, 64 * 1024)
				
				nCol		:= 1
				nSize		:= len(cFilAnt)
				cFilAnt		:= SubStr(cLinha,nCol,nSize)
				nCol		+= nSize
				nSize		:= 10
				nHdlPRV		:= Val(SubStr(cLinha,nCol,nSize))
				nCol		+= nSize
				nSize		:= 15
				cLoteAtf	:= SubStr(cLinha,nCol,nSize)
				nCol		+= nSize
				nSize		:= 18
				nTotRead	:= SubStr(cLinha,nCol,nSize)
				nCol		+= nSize
				nSize		:= 20
				cArquivo	:= SubStr(cLinha,nCol,nSize) 
				nCol		+= nSize
				nSize		:= 80
				cArray		:= SubStr(cLinha,nCol,nSize) 
				
				// Arquivo contendo a estrutura do aFlagCTB >>>>>
					cJobFileA := cStartPath + "mjA" + cEmpAnt + cFilAnt + StrZero(nZ,3,0) + StrZero(nX,3,0) + ".job"
					nHdlA := 0
					// Utiliza funcoes de arquivo binario apenas para testar a disponibilizade.
					if __lConOut
						CONOUT("ATFA370 | "+ALLTRIM(STR(ThreadId())) + " Aguardando Abertura do Arquivo D " + Time() + " " + ALLTRIM(STR(Seconds())))
					endif
					
					While ! KillApp() .And. ! ( File( cJobFileA ) .And. ( ( nHdlA := FOpen( cJobFileA, FO_READWRITE )) > 0 ))
						Sleep(50)
					End
					// Libera Arquivo disponivel para abertura com funcoes FT_F*(). (NanForum ToolKit)
					FClose( nHdlA )
				// Arquivo contendo a estrutura do aFlagCTB <<<<<
				
				// Abre arquivo detalhe e carrega o Array aFlags.
					FT_FUse( cJobFileA )
					if __lConOut
						CONOUT("ATFA370 | "+ALLTRIM(STR(ThreadId())) + " Carregando arquivo ["+str(ft_flastrec(),6)+"] " + Time() + " " + ALLTRIM(STR(Seconds())))
					endif	
				
					FT_FGOTOP()
					While !FT_FEof()
					   cLinhaA := FT_FREADLN()
					   AADD( aFlags, {	      SubStr( cLinhaA,  1, 10 ),;
				   						CTOD( SubStr( cLinhaA, 11, 08 ) ),;
				   						      SubStr( cLinhaA, 19, 03 ),;
					   					 Val( SubStr( cLinhaA, 22, 10 ) ),;
					   					 Val( SubStr( cLinhaA, 32, 10 ) ),;
					   					 Val( SubStr( cLinhaA, 42, 10 ) ),;
					   					 Val( SubStr( cLinhaA, 52, 10 ) ) } )
					   FT_FSKIP()
					Enddo
					FT_FUSE()
				// Fim da execucao de carga de aFlags.
				
				cLoteAtf	:= Alltrim( cLoteAtf )
				cArquivo	:= Alltrim( cArquivo )
				aDadosProva	:= STR2Array( cArray, .F. )
				
				aEval( aFlags, {|e| Aadd(aFlagCTBs[nZ], e)} )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Confere dados do cabecalho                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If a330RegCTB[ nZ, 3 ] == nHdlPrv .And. a330RegCTB[ nZ, 4 ] == cLoteAtf
					nTotal += VAL( nTotRead )
	    		EndIf
			EndIf

	      // Fecha o arquivo Job
    	   fClose( nHdl )

        	// Apaga arquivo Job
        	fErase( cJobFile )
        	fErase( cJobFileA )
		Next nX

		// efetua a contabilização
		if nTotal > 0 
			if __lConOut
				CONOUT("ATFA370 | "+ALLTRIM(STR(ThreadId())) + " FUNCTION CATF370INC " + Time() + " " + ALLTRIM(STR(Seconds())))
			endif	
			cATF370Inc( cArquivo, @nHdlPrv, cLoteATF, nTotal, @aFlagCTBs[nZ], aDadosProva, @aDiario )
		endif

	Next nZ
	
Endif

// Restaura filial original apos processamento
cFilAnt := cFilBack

Return 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GravaRegCT³ Autor ³Rodrigo de A Sartorio  ³ Data ³ 18/08/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava registro no arquivo de trabalho para contabilizacao  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cFilTRC    = Endereco do arquivo de contra-prova           ³±±
±±³          ³ cAliasTRC  = Alias do Movimento SD1/SD2/SD3                ³±±
±±³          ³ nRecTRC    = Numero do Registro do Movimento               ³±±
±±³          ³ cSeqTRC    = Codigo sequencial do Movimento                ³±±
±±³          ³ cLanctoTRC = Numero do Lancamento Padrao                   ³±±
±±³          ³ cRotTRC    = Rotina que originou a chamada da funcao       ³±±
±±³          ³ lProcLanc  = Avalia Lancamentos 667/669                    ³±±
±±³          ³ nRecSB1    = Registro do SB1                               ³±±
±±³          ³ nRecSF4    = Registro do SF4                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GravaRegCT(cFil,nRecSn3,nRecSn4,cLanctoTRC)
Local nAcho := ASCAN(a330RegCTB,{|x| x[1] == cFil})

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza array de controle de Filiais processadas                                 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nAcho == 0
	AADD(a330RegCTB,{cFil,1,0,"",""})
Else
	a330RegCTB[nAcho,2]+=1
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza registros                                                                |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("TRC")
DbAppend()
Replace TRC_FILIAL With cFil
Replace TRC_RECSN3 With nRecSn3
Replace TRC_RECSN4 With nRecSn4
Replace TRC_LANTRC With cLanctoTRC
Replace TRC_SEQUEN With cFil + StrZero(IIf(nAcho == 0,1,a330RegCTB[nAcho,2]),10,0)
MsRUnlock()

RETURN

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ATFCanProcº Autor ³ Marcos S. Lobo     º Data ³  06/26/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cria Semaforo de processamento e verifica concorrencia com  º±±
±±º          ³base nos intervalos de parametros                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP - Contabilizacao Off-Line Ativo Fixo                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ATFCanProc(cSEMATF, dDtVldDe, dDtVldAte, cFilDe, cFilAte)
LOCAL lRet		:= .F.
LOCAL nX		:= 1
LOCAL aInfos	:= {}
LOCAL nEr		:= 0 
LOCAL cFile		:= ""
LOCAL cBuffer	:= ""
LOCAL cUserLck	:= ""
LOCAL dDTDe
LOCAL dDTAte
LOCAL nHandle 	:= -1
LOCAL lCreate	:= .F.
LOCAL lOK
LOCAL cUserCTB	:= PADR('SCHED',15)

DEFAULT cFilDe := cFilAnt
DEFAULT cFilAte:= cFilAnt

If !lBlind
	cUserCTB := cUserName
EndIf
 
While !LockByName("ATFA370LOCKPROC"+cEmpAnt,.T.,.T.,.T.)
    nER++
	If !lBlind
		MsAguarde({|| Sleep(1000) }, "Semaforo de processamento... tentativa "+ALLTRIM(STR(nER)), "Aguarde, arquivo sendo criado por outro usuário.") //"Semaforo de processamento... tentativa "#"Aguarde, arquivo sendo criado por outro usuário."
	Else
		Sleep(50)		
	EndIf
	If nER > 5	/// A PARTIR DA QUINTA TENTATIVA
		If !lBlind
			If Aviso("Criação de Semaforo de processamento.","Não foi possivel acesso exclusivo para criar o semaforo de processamento.",{"Repetir","Fechar"},2) == 2//"Criação de Semaforo de processamento."#"Não foi possivel acesso exclusivo para criar o semaforo de processamento."#"Repetir"#"Fechar"
				ProcLogAtu("ERRO","Atenção!","Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo) por outro usuário no momento"+"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde.") //"Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo) por outro usuário no momento"#"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde."	
				Return lRet
			Else
				nER := 0
			EndIf		
		ElseIf nER >= 30
			ProcLogAtu("ERRO","Atenção!","Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo) por outro usuário no momento"+"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde.") //"Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo) por outro usuário no momento"#"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde."	)	
			Return lRet
		EndIf
    EndIf
EndDo

//MakeDir("\SEMAFORO\")
cFile := "ATF370"+AllTrim(cEmpAnt)

If !File(cFile+__cExt) 
	aStruct  := {}
	AAdd( aStruct, { "FILDE"	, "C", Len( cFilAnt )	, 0 } )
	AAdd( aStruct, { "FILATE"	, "C", Len( cFilAnt )	, 0 } )
	AAdd( aStruct, { "DTDE"		, "D", 8 				, 0 } )
	AAdd( aStruct, { "DTATE"	, "D", 8 				, 0 } )
	AAdd( aStruct, { "CUSER"	, "C", Len( cUserCTB )	, 0 } )
	AAdd( aStruct, { "HORAI"	, "C", Len(Time())		, 0 } )
	AAdd( aStruct, { "DATAI"	, "D", 8				, 0 } )
	AAdd( aStruct, { "HORAF"	, "C", Len(Time())		, 0 } )
	AAdd( aStruct, { "DATAF"	, "D", 8				, 0 } )

	MsCreate( cFile , aStruct , __LOCALDRIVER )
	
	cArqTrab := cFile
Else
	cArqTrab := cFile
EndIf

IF Select(cSEMATF) > 0
	dbSelectArea(cSEMATF)
	DbCloseArea()
ENDIF
dbUseArea(.T.,,cArqTrab,cSEMATF,.T.,.F.)

dbSelectArea(cSEMATF)			
dbGoTop()

lSai		:= .F.
lRet1		:= .T.
lRet2		:= .T.

While !lSai .and. (cSEMATF)->(!Eof())
	        
	IF cFilDe <= (cSEMATF)->FILDE .and. cFilAte >= (cSEMATF)->FILATE
		lRet1 := .F.
	ElseIF cFilDe >= (cSEMATF)->FILDE .and. cFilDe <= (cSEMATF)->FILATE
		lRet1 := .F.
	ElseIf cFilAte >= (cSEMATF)->FILDE .and. cFilAte <= (cSEMATF)->FILATE
		lRet1 := .F.
	ElseIf cFilDe > cFilAte
		lRet1 := .F.		
	Endif	    

	IF dDtVldDe <= (cSEMATF)->DTDE .and. dDtVldAte >= (cSEMATF)->DTATE
		lRet2 := .F.
	ElseIF dDtVldDe >= (cSEMATF)->DTDE .and. dDtVldDe <= (cSEMATF)->DTATE
		lRet2 := .F.
	ElseIf dDtVldAte >= (cSEMATF)->DTDE .and. dDtVldAte <= (cSEMATF)->DTATE
		lRet2 := .F.
	ElseIf dDtVldDe > dDtVldAte
		lRet2 := .F.		
	Endif
	
	If !lRet1 .and. !lRet2
		/// SE LOCALIZOU NO MESMO PERIODO E NAS MESMAS FILIAIS E MESMA CARTEIRA

		If (cSEMATF)->(RLock())			/// SE CONSEGUIR ALOCAR 	
			(cSEMATF)->(dbDelete())		/// NAO TEM CONCORRENCIA
			(cSEMATF)->(MsUnlock())
		Else		
			If !lBlind
				Aviso("Atenção!","Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo ) por outro usuário no momento."+Alltrim((cSEMATF)->CUSER)+" "+(cSEMATF)->HORAI+" "+"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde.",{"Fechar"},2) //"Atenção!"###"Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo ou carteiras ) por outro usuário ( "###" ) no momento. Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde."###"Fechar"
			EndIf
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o log de processamento com o erro  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ProcLogAtu("ERRO","Atenção!","Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo ) por outro usuário no momento."+Alltrim((cSEMATF)->CUSER)+"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde.")
			lSai		:= .T.
		EndIf
	EndIf
	(cSEMATF)->(dbSkip())
EndDo

If !lSai
	RecLock(cSEMATF,.T.)
	Field->FILDE		:= PADR(cFilDe,len(cFilAnt))
	Field->FILATE		:= PADR(cFilAte,len(cFilAnt))
	Field->DTDE			:= dDtVldDe
	Field->DTATE	    := dDtVldAte
	Field->CUSER		:= cUserCTB
	Field->HORAI		:= Time()
	Field->DATAI	    := Date()
	MsUnlock()	
	RecLock(cSEMATF,.F.) ///DEIXA REGISTRO ALOCADO
	if __lConOut
		CONOUT("ATFA370 | "+ALLTRIM(STR(ThreadId())) +" Start Time "+Time()+" "+ALLTRIM(STR(Seconds())))
	endif	
	lRet := .T.		///PROCESSAMENTO PODE SER EFETUADO
EndIf

UnLockByName("ATFA370LOCKPROC"+cEmpAnt,.T.,.T.,.T.)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ATFFREEPRC³Autor  ³ Marcos S. Lobo     ³ Data ³  06/26/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Libera registro alocado no semaforo de processamento.      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP Contabilizacao Off-Line Ativo Fixo                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ATFFreeProc(cSEMATF)

LOCAL cFile 	:= "ATF370"+AllTrim(cEmpAnt)
LOCAL nER		:= 0

If !File(cFile+__cExt)
	Return
EndIf

If Select(cSEMATF) <= 0
	Return
EndIf

While !LockByName("ATFA370LOCKPROC"+cEmpAnt,.T.,.T.,.T.)
    nER++
	If !lBlind
		MsAguarde({|| Sleep(1000) }, "Semaforo de processamento... tentativa "+ALLTRIM(STR(nER)), "Aguarde, arquivo sendo criado por outro usuário.")//"Semaforo de processamento... tentativa "#"Aguarde, arquivo sendo criado por outro usuário."
	Else
		Sleep(50)		
	EndIf
	If nER > 5	/// A PARTIR DA QUINTA TENTATIVA
		If !lBlind
			If Aviso("Gravacao de Semaforo de processamento.","Não foi possivel acesso exclusivo para gravar o semaforo de processamento.",{"Repetir","Fechar"},2) == 2//"Gravacao de Semaforo de processamento."#"Não foi possivel acesso exclusivo para gravar o semaforo de processamento."#"Repetir"#"Fechar"
				ProcLogAtu("ERRO","Atenção!","Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo ) por outro usuário no momento."+"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde.")	     //"Atenção!"#"Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo ) por outro usuário no momento."#"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde."
				Return
			Else
				nER := 0
			EndIf		
		ElseIf nER >= 30
			ProcLogAtu("ERRO","Atenção!","Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo ) por outro usuário no momento."+"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde.")	     //"Atenção!"#"Este processo esta sendo utilizado com parametros conflitantes ( mesmo periodo ) por outro usuário no momento."#"Verifique o período e os parametros selecionados para o processamento ou tente novamente mais tarde."
			Return
		EndIf
    EndIf
EndDo

dbSelectArea(cSEMATF)
If !Eof()
	If (cSEMATF)->(RLock())
		Field->HORAF	:= Time()
		Field->DATAF	:= Date()
	EndIf
	MsUnlock()
	if __lConOut
		CONOUT("ATFA370 | "+ALLTRIM(STR(ThreadId())) +" End Time   "+Time()+" "+ALLTRIM(STR(Seconds())))
	endif	
	RecLock(cSEMATF,.F.)
	(cSEMATF)->(dbDelete())
	MsUnlock()
EndIf

UnLockByName("ATFA370LOCKPROC"+cEmpAnt,.T.,.T.,.T.)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³cATF370Inc³ Autor ³ Renato F. Campos      ³ Data ³ 15/11/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Envia lancamentos para contabilizade.                  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³cATF370Inc(cArquivo,nHdlPrv,cLoteATF,nTotal,aFlagCTB		  ³±±
±±|			 ³			,aDadosProva)									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ATFA370							        				  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function cATF370Inc(cArquivo,nHdlPrv,cLoteATF,nTotal,aFlagCTB,aDadosProva,aDiario)
LOCAL lDigita := .F.
LOCAL lAglut  := .F.

DEFAULT aDadosProva := nil
DEFAULT aFlagCTB	:= {}
DEFAULT aDiario	:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava Rodapé 									  	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nHdlPrv > 0
	RodaProva( nHdlPrv , nTotal, aDadosProva )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Seta os parametro para a utilização da aglutinação e digitação ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lDigita := IIF( mv_par05 == 1, .T., .F.)
	lAglut  := IIF( mv_par03 == 1, .T., .F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Envia para Lan‡amento Cont bil 						³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if __lConOut
		CONOUT("ATFA370 | "+ALLTRIM(STR(ThreadId())) + " FUNCTION CA100INCL " + Time() + " " + ALLTRIM(STR(Seconds())))
		CONOUT("ATFA370 | aFlagCTB Tam: " + STR(LEN(aFlagCTB)))
	endif	
	cA100Incl( cArquivo, nHdlPrv, 3, cLoteATF, lDigita, lAglut,,,, @aFlagCTB, aDadosProva,aDiario )

	aFlagCTB := {}  
	aDiario  := {}
	nHdlPrv := 0
Endif

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AdmAbreSM0³ Autor ³ Orizio                ³ Data ³ 22/01/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna um array com as informacoes das filias das empresas ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function AdmAbreSM0()
	Local aArea			:= SM0->( GetArea() )
	Local aAux			:= {}
	Local aRetSM0		:= {}
	Local lFWLoadSM0	:= .T.
	Local lFWCodFilSM0 	:= .T.

	If lFWLoadSM0
		aRetSM0	:= FWLoadSM0()
	Else
		DbSelectArea( "SM0" )
		SM0->( DbGoTop() )
		While SM0->( !Eof() )
			aAux := { 	SM0->M0_CODIGO,;
						IIf( lFWCodFilSM0, FWGETCODFILIAL, SM0->M0_CODFIL ),;
						"",;
						"",;
						"",;
						SM0->M0_NOME,;
						SM0->M0_FILIAL }

			aAdd( aRetSM0, aClone( aAux ) )
			SM0->( DbSkip() )
		End
	EndIf

	RestArea( aArea )
Return aRetSM0


