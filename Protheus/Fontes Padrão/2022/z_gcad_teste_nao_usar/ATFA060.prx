#Include 'Protheus.ch'
#Include 'FWMVCDEF.ch'
#Include 'ATFA060.CH'


//AVP 
Static aAvpCtbO		:= {}
Static aAvpCtbD		:= {}

//Taxa da moeda
Static nTaxaDepr	:= 0

//Se é execauto
Static lAuto		:= .T.

// Controle de multiplas moedas
Static lMultMoed	:= .T. 

//Variavel de Controle do Rateio
Static __lExisEnt	:= .T.

Static lFN9			:= .T.

Static aCamposAlt	:= {}

//Variavel para de visualização
Static lVisu	:= .F.

//Função para saber se a rotina e de ExecAuto
Static lAtfAuto	:= .F.

//Variavel para Controlar a exibição da mensagem de Grupo
Static lMsgGrupo	:= .F.

Static __cProcPrinc :="ATFA060"

//Static aFN9CpoUsr   := NIL
Static aFN9CpoUsr   := {} // Alterado por Edu da FSW EM 19/06/16 p/ oModel ser utilizado de outro PRW 

Static lPeAF060GRP  := ExistBlock("AF060GRP")

//Objeto para a classe FwTemporaryTable (Cria tabela temporária no banco de dados)
Static _oATFA0601

Static __nAtuGrp	:= 2 //1-Atualiza/2-Espelha (considera campos em branco na SNG)/3-Nao Atualiza
Static _lAltNGCTB	:= .T.

STATIC lIsRussia	:= If(cPaisLoc$"RUS",.T.,.F.) // CAZARINI - Flag to indicate if is Russia location

/*{Protheus.doc} ATFA060.prw
Transferencia de Ativos
@author José Augusto Ribeiro
@since 08/05/2015
@version P12
@menu SIGATF->Atualizações ->Movimentos
*/
Function ATFA060(xAtivo,nOpcAuto,xParam)
Local lRet			:= .T.
Local oBrowse		:= NIL
Local nI			:= 0
Local aRet			:= {}
Local aParam		:= {}
Local lAF060BRW	:= ExistBlock("AF060BRW")
Local cFiltro		:= ""

Private aRotina	:= MenuDef()
Private cCadastro	:= STR0005	// "Transferência de Ativos para chamar a função da legenda
Private cBaseAuto	:= ""
Private cItemAuto	:= ""
Private cTipoAuto	:= ""
Private aParamAuto	:= {}
Private cN4_HORA	:= SubStr(Time(),1,5)

DEFAULT xAtivo		:= {}
DEFAULT nOpcAuto	:= 0
DEFAULT xParam		:= {}

If(Len(xAtivo) > 0 .And. nOpcAuto != 0)
	
	lAtfAuto := .T.
	
EndIf

//If aFN9CpoUsr == NIL  
If aFN9CpoUsr == NIL .OR. Len(aFN9CpoUsr) == 0 // Alterado por Edu da FSW EM 19/06/16 p/ oModel ser utilizado de outro PRW 
	aFN9CpoUsr := AF060CpUsr("FN9")
EndIf

If(!lAtfAuto)
	
	oBrowse := FWMBrowse():New()
	oBrowse:SetAlias("SN3")
	oBrowse:SetDescription(STR0005)//"Transferência de Ativos"
	oBrowse:AddLegend( "N3_BAIXA == '0' .AND. !AfxLegTran()"							,"GREEN"	,STR0114) //"Ativo Fixo Vigente"
	oBrowse:AddLegend( "N3_BAIXA > '0' .And. !Empty(N3_DTBAIXA) .AND. !AfxLegTran()"	,"RED"		,STR0115)//"Ativo Fixo Baixado"
	oBrowse:AddLegend( "AfxLegTran()"													,"PINK"		,STR0116)//"Ativo Transferido de Filial"
	If(lAF060BRW)
		cFiltro := ExecBlock("AF060BRW",.F.,.F.)
		oBrowse:SetFilterDefault(cFiltro)
	EndIf
	oBrowse:Activate()
	lRet := .T.
Else
	SN3->(DbSetOrder(1))
	
	aParamAuto := xParam
	For nI := 1 To Len(xAtivo)
		
		If(xAtivo[nI][1] == "N3_CBASE")
			
			cBaseAuto := xAtivo[nI][2]
			
		ElseIf(xAtivo[nI][1] == "N3_ITEM")
			
			cItemAuto := xAtivo[nI][2]
			
		ElseIf(xAtivo[nI][1] == "N3_TIPO")
			
			cTipoAuto := xAtivo[nI][2]
			
		ElseIf(!Empty(cTipoAuto) .And. !Empty(cItemAuto) .And. !Empty(cBaseAuto))

			Exit
			
		ElseIf(xAtivo[nI][1] == "N4_HORA")
		
			cN4_HORA := xAtivo[nI][2]
			
		EndIf
	Next nI
	If(SN3->(DbSeek(xFilial("SN3")+cBaseAuto+cItemAuto+cTipoAuto)))
		
		If !nOpcAuto == 7
			lRet := AF060AutRot(xAtivo,nOpcAuto,aParam)
		Else
			AF060CaTra("SN3",SN3->(RECNO()),7,.T.)
						
		EndIf
		
	Else
		
		lRet := .F.
		
	EndIf
EndIf

aFN9CpoUsr := {} // Alterado por Edu da FSW EM 19/06/16 p/ oModel ser utilizado de outro PRW

Return lRet

/*{Protheus.doc}MenuDef
Cria os Menus para visualizar
@author Jose Augusto Ribeiro
@since 08/05/2015
@version P12
@return aRotina , Vetor,Vetor com as opções da Rotina do Vetor
*/
Static Function MenuDef()
	Local aRot			:= {}
	Local aRotNew		:= {}
	Local nX			:= 0

	ADD OPTION aRot Title STR0003		ACTION 'ATF060TRAN'			OPERATION 4 ACCESS 0 //'Transferir'
	ADD OPTION aRot Title STR0004		ACTION 'AF060Auto'			OPERATION 3 ACCESS 0 //"Automatico" 'Transferir em Lote'
	ADD OPTION aRot Title STR0046		ACTION 'AF190Trans(1)'		OPERATION 7 ACCESS 0 //'Transf.Resp.'
	ADD OPTION aRot Title STR0089		ACTION 'CTBC662'			OPERATION 8 ACCESS 0 //'Tracker Contábil'
	ADD OPTION aRot Title STR0002		ACTION 'ATFA060Vis'			OPERATION 2 ACCESS 0 //'Visualizar'
	ADD OPTION aRot Title STR0157		ACTION 'ATF060VTR'			OPERATION 2 ACCESS 0 //'Visualizar Transferencia'

	// Adiciona a opção de cancelamento da transferencia entre filiais ou  transferência contábil
	If GetMV("MV_ATFCATR",.F.,'2') == '1'
		// Foi definida a opcao 3 pois a filial é posicionada corretamente, diferente
		// das outras opcoes, em que a posicao do browse define a filial para query
		Aadd(aRot, {STR0090,"AF060CaTra",0,3})	// "Canc. Transf."
	EndIf

	ADD OPTION aRot Title "Log Proc."		ACTION 'AFA060LOG'				OPERATION 8 ACCESS 0 //"Log Proc."

	//Ponto de entrada para inclusao de botao no arotina
	If ExistBlock("AF060BUT")
		aRotNew := ExecBlock("AF060BUT",.F.,.F.,{aRot})
		For nX := 1 To len(aRotNew)
			aAdd(aRot,aRotNew[nX])
		Next
	Endif

Return aRot

/*{Protheus.doc} ModelDef
Model da Rotina da Transferencia de Ativo
@author Jose Augusto Ribeiro
@since 08/05/2015
@version P12
@return oModel ,Objeto , Modelo da Rotina Transferencia de Ativo
*/
Static Function ModelDef()
//Criando a Estrutura do Model
Local oStruFn9	:= FWFormStruct( 1, 'FN9', /*bAvalCampo*/,/*lViewUsado*/ )
Local oStruFns	:= FWFormStruct( 1, 'FNS', /*bAvalCampo*/,/*lViewUsado*/ )
Local oStruFnr	:= FWFormStruct( 1, 'FNR', /*bAvalCampo*/,/*lViewUsado*/ )
Local oModel	:= NIL
Local aDados := {}

//-------------Para uso com o release 12.1.17--------------------------------
Aadd(aDados,{{'FNS_CCBEMD'},{{'X3_F3','A060F3','CTT'}}})
EngSX3117( aDados )

// Alterado por Edu da FSW EM 19/06/16 p/ oModel ser utilizado de outro PRW  
If aFN9CpoUsr == NIL .OR. Len(aFN9CpoUsr) == 0  
	aFN9CpoUsr := AF060CpUsr("FN9")
EndIf

//Adicionando o Campo Check
oStruFnr:AddField(STR0170,STR0171 , 'OK', 'L', 1, 0, {||AF060VLATF(oModel:GetModel('GridFNR'):GetValue('FNR_FILDES'),oModel:GetModel('GridFNR'):GetValue('FNR_CBAORI'), oModel:GetModel('GridFNR'):GetValue('FNR_ITEORI'), .F.)} ,{||FWIsInCallStack('AF060Auto') } , {}	, .F.	, , .F., .F., .F., , )//'Transfere?'#//'Seleção'
oStruFns:AddField(' ',' ' , 'OK', 'L', 1, 0,{|| VldMarkFNS(oModel) }	,{||.T. } , {}	, .F.	, , .F., .F., .F., , )//'Baixa?'#//'Seleção'
oStruFn9:AddField(STR0172,STR0172 , 'TOTBEM', 'N', 10, 0, /*bValid*/	,{||.F. } , {}	, .F.	, , .F., .F., .F., , )//'Total de Bens'#//'Total de Bens'

//Gatilhos FN9 - Dados Gerais
oStruFn9:AddTrigger('FN9_FILDES','FN9_FILDES',{|| .T. },{||AF060TRG("FN9_FILDES" )})
oStruFn9:AddTrigger('FN9_DATA'  ,'FN9_DATA'  ,{|| .T. },{||AF060TRG("FN9_DATA"   )})
oStruFn9:AddTrigger('FN9_GRPDES','FN9_GRPDES',{|| .T. },{||AF060TRG("FN9_GRPDES" )})
oStruFn9:AddTrigger('FN9_LOCDES','FN9_LOCDES',{|| .T. },{||AF060TRG("FN9_LOCDES" )})
oStruFn9:AddTrigger('FN9_TXPADD','FN9_TXPADD',{|| .T. },{||AF060TRG("FN9_TXPADD" )})
oStruFn9:AddTrigger('FN9_CCDESD','FN9_CCDESD',{|| .T. },{||AF060TRG("FN9_CCDESD" )})
oStruFn9:AddTrigger('FN9_QTDDES','FN9_QTDDES',{|| .T. },{||AF060TRG("FN9_QTDDES" )})

//Gatilhos FN9 - Conta Contabil
oStruFn9:AddTrigger('FN9_CONTAD','FN9_CONTAD',{|| .T. },{||AF060TRG("FN9_CONTAD" )})
oStruFn9:AddTrigger('FN9_CONCOD','FN9_CONCOD',{|| .T. },{||AF060TRG("FN9_CONCOD" )})
oStruFn9:AddTrigger('FN9_CONDDD','FN9_CONDDD',{|| .T. },{||AF060TRG("FN9_CONDDD" )})
oStruFn9:AddTrigger('FN9_CONDAD','FN9_CONDAD',{|| .T. },{||AF060TRG("FN9_CONDAD" )})
oStruFn9:AddTrigger('FN9_CONCDD','FN9_CONCDD',{|| .T. },{||AF060TRG("FN9_CONCDD" )})

//Gatilhos FN9 - Centro de custo
oStruFn9:AddTrigger('FN9_CCBEMD','FN9_CCBEMD',{|| .T. },{||AF060TRG("FN9_CCBEMD" )})
oStruFn9:AddTrigger('FN9_CCCORD','FN9_CCCORD',{|| .T. },{||AF060TRG("FN9_CCCORD" )})
oStruFn9:AddTrigger('FN9_CCDDD' ,'FN9_CCDDD' ,{|| .T. },{||AF060TRG("FN9_CCDDD"  )})
oStruFn9:AddTrigger('FN9_CCDAD' ,'FN9_CCDAD' ,{|| .T. },{||AF060TRG("FN9_CCDAD"  )})
oStruFn9:AddTrigger('FN9_CCCDD' ,'FN9_CCCDD' ,{|| .T. },{||AF060TRG("FN9_CCCDD"  )})

//Gatilhos FN9 - Item Contabil
oStruFn9:AddTrigger('FN9_ITBEMD','FN9_ITBEMD',{|| .T. },{||AF060TRG("FN9_ITBEMD" )})
oStruFn9:AddTrigger('FN9_ITCORD','FN9_ITCORD',{|| .T. },{||AF060TRG("FN9_ITCORD" )})
oStruFn9:AddTrigger('FN9_ITDEDD','FN9_ITDEDD',{|| .T. },{||AF060TRG("FN9_ITDEDD" )})
oStruFn9:AddTrigger('FN9_ITDEAD','FN9_ITDEAD',{|| .T. },{||AF060TRG("FN9_ITDEAD" )})
oStruFn9:AddTrigger('FN9_ITCDED','FN9_ITCDED',{|| .T. },{||AF060TRG("FN9_ITCDED" )})

//Gatilhos FN9 - Classe de Valor
oStruFn9:AddTrigger('FN9_CVBEMD','FN9_CVBEMD',{|| .T. },{||AF060TRG("FN9_CVBEMD" )})
oStruFn9:AddTrigger('FN9_CVCORD','FN9_CVCORD',{|| .T. },{||AF060TRG("FN9_CVCORD" )})
oStruFn9:AddTrigger('FN9_CVDEPD','FN9_CVDEPD',{|| .T. },{||AF060TRG("FN9_CVDEPD" )})
oStruFn9:AddTrigger('FN9_CVCDED','FN9_CVCDED',{|| .T. },{||AF060TRG("FN9_CVCDED" )})
oStruFn9:AddTrigger('FN9_CVDESD','FN9_CVDESD',{|| .T. },{||AF060TRG("FN9_CVDESD" )})

//Gatilhos FN9 - Nota Fiscal
oStruFn9:AddTrigger('FN9_GERNF' ,'FN9_GERNF' ,{|| .T. },{||AF060TRG("FN9_GERNF"  )})
oStruFn9:AddTrigger('FN9_SERIE' ,'FN9_SERIE' ,{|| .T. },{||AF060TRG("FN9_SERIE"  )})
oStruFn9:AddTrigger('FN9_CLSNF' ,'FN9_CLSNF' ,{|| .T. },{||AF060TRG("FN9_CLSNF"  )})
oStruFn9:AddTrigger('FN9_TESSAI','FN9_TESSAI',{|| .T. },{||AF060TRG("FN9_TESSAI" )})
oStruFn9:AddTrigger('FN9_TESENT','FN9_TESENT',{|| .T. },{||AF060TRG("FN9_TESENT" )})
oStruFn9:AddTrigger('FN9_VALNF' ,'FN9_VALNF' ,{|| .T. },{||AF060TRG("FN9_VALNF"  )})

//Gatilhos FNR
oStruFnR:AddTrigger('FNR_GRPDES','FNR_GRPDES',{|| .T. },{||Af060Grupo(FWFldGet("FNR_GRPDES"), 'FNR'), FWFldGet('FNR_GRPDES') })

//Gatilhos FNS
oStruFnS:AddTrigger("FNS_CCDESD","FNS_CCDDD" ,{|| SuperGetMv("MV_ATFCCDP",.F.,.F.) },{||FWFldGet('FNS_CCDESD')})

//Gatilhos da FNS
// Conta Contabil
oStruFnS:AddTrigger("FNS_CONTAD","FNS_CONTAD",{|| .T. },{||AF060PE("FNS_CONTAD" )})
oStruFnS:AddTrigger("FNS_CONCOD","FNS_CONCOD",{|| .T. },{||AF060PE("FNS_CONCOD" )})
oStruFnS:AddTrigger("FNS_CONDDD","FNS_CONDDD",{|| .T. },{||AF060PE("FNS_CONDDD" )})
oStruFnS:AddTrigger("FNS_CONDAD","FNS_CONDAD",{|| .T. },{||AF060PE("FNS_CONDAD" )})
oStruFnS:AddTrigger("FNS_CONCDD","FNS_CONCDD",{|| .T. },{||AF060PE("FNS_CONCDD" )})

//CENTRO DE CUSTO
oStruFnS:AddTrigger("FNS_CCBEMD","FNS_CCBEMD",{|| .T. },{||AF060PE("FNS_CCBEMD" )})
oStruFnS:AddTrigger("FNS_CCCORD","FNS_CCCORD",{|| .T. },{||AF060PE("FNS_CCCORD" )})
oStruFnS:AddTrigger("FNS_CCDAD" ,"FNS_CCDAD" ,{|| .T. },{||AF060PE("FNS_CCDAD"  )})		
oStruFnS:AddTrigger("FNS_CCCDD" ,"FNS_CCCDD" ,{|| .T. },{||AF060PE("FNS_CCCDD"  )})		
oStruFnS:AddTrigger("FNS_CCDDD" ,"FNS_CCDDD" ,{|| .T. },{||AF060PE("FNS_CCDDD"  )})		

//ITEM CONTABIL
oStruFnS:AddTrigger("FNS_ITBEMD","FNS_ITBEMD",{|| .T. },{||AF060PE("FNS_ITBEMD" )})
oStruFnS:AddTrigger("FNS_ITCORD","FNS_ITCORD",{|| .T. },{||AF060PE("FNS_ITCORD" )})
oStruFnS:AddTrigger("FNS_ITDEDD","FNS_ITDEDD",{|| .T. },{||AF060PE("FNS_ITDEDD" )})
oStruFnS:AddTrigger("FNS_ITDEAD","FNS_ITDEAD",{|| .T. },{||AF060PE("FNS_ITDEAD" )})
oStruFnS:AddTrigger("FNS_ITCDED","FNS_ITCDED",{|| .T. },{||AF060PE("FNS_ITCDED" )})

//CLASSE DE VALOR
oStruFnS:AddTrigger("FNS_CVBEMD","FNS_CVBEMD",{|| .T. },{||AF060PE("FNS_CVBEMD" )})
oStruFnS:AddTrigger("FNS_CVCORD","FNS_CVCORD",{|| .T. },{||AF060PE("FNS_CVCORD" )})
oStruFnS:AddTrigger("FNS_CVDEPD","FNS_CVDEPD",{|| .T. },{||AF060PE("FNS_CVDEPD" )})
oStruFnS:AddTrigger("FNS_CVCDED","FNS_CVCDED",{|| .T. },{||AF060PE("FNS_CVCDED" )})
oStruFnS:AddTrigger("FNS_CVDESD","FNS_CVDESD",{|| .T. },{||AF060PE("FNS_CVDESD" )})

//Fazendo a validação de data
oStruFn9:SetProperty('FN9_DATA',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060Data(FWFldGet('FN9_DATA'))"))
oStruFnr:SetProperty('FNR_DATA',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060Data(FWFldGet('FNR_DATA'))"))
oStruFns:SetProperty('FNS_DATA',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060Data(FWFldGet('FNS_DATA'))"))

//Fazendo a Validação do Grupo de Bem
oStruFnr:SetProperty('FNR_GRPDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060VLGRP(FWFldGet('FNR_GRPDES'),FWFldGet('FNR_FILDES'),'FNR')"))
oStruFn9:SetProperty('FN9_GRPDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060VLGRP(FWFldGet('FN9_GRPDES'),FWFldGet('FN9_FILDES'),'FN9')"))

//Validação da Filial de Destino
oStruFn9:SetProperty('FN9_FILDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AFA060FIL(FWFldGet('FN9_FILDES'),FWFldGet('FN9_GERNF') == '1')"))
oStruFnr:SetProperty('FNR_FILDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AFA060FIL(FWFldGet('FNR_FILDES'),FWFldGet('FNR_GERNF') == '1')"))

oStruFn9:SetProperty('FN9_GERNF',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AFA060FIL(FWFldGet('FN9_FILDES'),FWFldGet('FN9_GERNF') == '1')"))
oStruFnr:SetProperty('FNR_GERNF',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AFA060FIL(FWFldGet('FNR_FILDES'),FWFldGet('FNR_GERNF') == '1')"))

//Validacao do Local
oStruFn9:SetProperty('FN9_LOCDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060VLLOC(FWFldGet('FN9_FILDES'),FWFldGet('FNR_FILORI'),FWFldGet('FNR_LOCORI'),FWFldGet('FN9_LOCDES'))"))
oStruFnr:SetProperty('FNR_LOCDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"AF060VLLOC(FWFldGet('FN9_FILDES'),FWFldGet('FNR_FILORI'),FWFldGet('FNR_LOCORI'),FWFldGet('FNR_LOCDES'))"))

//Validacao da transferencia parcial
oStruFNR:SetProperty('FNR_QTDDES',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"FWFldGet('FNR_QTDDES') > 0 .And. FWFldGet('FNR_QTDDES') <=  FWFldGet('FNR_QTDORI')"))

If lVisu
	oStruFNR:SetProperty("FNR_DESCRI",MODEL_FIELD_INIT,FWBuildFeature(STRUCT_FEATURE_INIPAD,'POSICIONE("SN1",1,XFilial("SN1",FNR->FNR_FILORI)+FNR->(FNR_CBAORI+FNR_ITEORI),"N1_DESCRIC","")'))
	oStruFNS:SetProperty("FNS_HISTOR",MODEL_FIELD_INIT,FWBuildFeature(STRUCT_FEATURE_INIPAD,'POSICIONE("SN3",12,XFilial("SN3",FWFldGet("FNR_FILORI"))+FWFldGet("FNR_CBAORI")+FWFldGet("FNR_ITEORI")+FNS->(FNS_TIPO+FNS_SEQ),"N3_HISTOR","")'))
EndIf

//Validacao da taxa padrão
oStruFnr:SetProperty('FNR_TXPADD',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"A060TXRVLD(FWFldGet('FNR_TXPADD'),FWFldGet('FNR_FILDES'))"))
oStruFn9:SetProperty('FN9_TXPADD',MODEL_FIELD_VALID,FWBuildFeature(STRUCT_FEATURE_VALID,"A060TXRVLD(FWFldGet('FN9_TXPADD'),FWFldGet('FN9_FILDES'))"))


//Adicionando o When na FN9
oStruFn9:SetProperty('FN9_GRPDES',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFn9:SetProperty('FN9_FILDES',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFn9:SetProperty('FN9_GERNF' ,MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFn9:SetProperty('FN9_TXPADD',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"A060TXRALT(FWFldGet('FN9_GRPDES')) .And. AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFn9:SetProperty('FN9_TESENT',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"If(FWFldGet('FN9_CLSNF') == '2', .T.,.F.)"))

//Adicionando o When na FNR
oStruFnr:SetProperty('FNR_GRPDES',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFnr:SetProperty('FNR_FILDES',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFnr:SetProperty('FNR_GERNF' ,MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFnr:SetProperty('FNR_TXPADD',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"A060TXRALT(FWFldGet('FNR_GRPDES')) .And. AF060LibCpo(FWFldGet('FNR_CBAORI'),FWFldGet('FNR_ITEORI'))"))
oStruFnr:SetProperty('FNR_TESENT',MODEL_FIELD_WHEN,FWBuildFeature(STRUCT_FEATURE_WHEN,"If(FWFldGet('FNR_CLSNF') == '2', .T.,.F.)"))

oModel := MPFormModel():New('ATFA060',/*preValid */,{|oModel|AF060TDOK(oModel)}/*bPosValidacao*/,{ |oModel| af060Commit( oModel ) }, /*bCancel*/ )

//Criando os AddFields e AddGrid
If(lVisu)
	
	oModel:AddFields("FieldFN9",		,oStruFn9, /*bPreVld*/	, /*bPost*/									,/*{||LoadFN9(oModel)}*/)
	oModel:AddGrid("GridFNR","FieldFN9",oStruFnr, /*bLinePre*/	, /*bLinePost*/	, /*bPreVal*/, /*bPosVal*/	,/*{|oModel| LoadFNR(oModel)}*/)
	oModel:AddGrid("GridFNS","GridFNR"	,oStruFns, /*bLinePre*/	, /*bLinePost*/	, /*bPreVal*/, /*bPosVal*/	,/*{|oModel|LoadFNS(oModel)}*/)

Else
	
	oModel:AddFields("FieldFN9",		,oStruFn9, /*bPreVld*/	, /*bPost*/									,{||LoadFN9(oModel)})
	oModel:AddGrid("GridFNR","FieldFN9",oStruFnr, /*bLinePre*/	, /*bLinePost*/	, /*bPreVal*/, /*bPosVal*/	,{|oModel| LoadFNR(oModel)})
	oModel:AddGrid("GridFNS","GridFNR"	,oStruFns, /*bLinePre*/	, /*bLinePost*/	, /*bPreVal*/, /*bPosVal*/	,{|oModel|LoadFNS(oModel)})
	
EndIf

//Efetuando o SetRelation
oModel:SetRelation('GridFNR',{{'FNR_FILIAL','XFilial("FNR")'},{'FNR_IDMOV','FN9_IDMOV'}},FNR->(IndexKey(1)))
oModel:SetRelation('GridFNS',{{'FNS_FILIAL','XFilial("FNS")'},{'FNS_IDMOV','FNR_IDMOV'},{'FNS_CODREL','FNR_CODREL'}},FNS->(IndexKey(1)))

oModel:GetModel("FieldFN9"):SetDescription(STR0005) //"Transferencia de Ativos"
oModel:GetModel("GridFNS") :SetDescription(STR0117) //"Ativos"
oModel:GetModel("GridFNR") :SetDescription(STR0118) //"Tipo de Ativos"

oModel:SetVldActivate({||AF060VLD()})
oModel:SetActivate( {|oModel| AF060Activ(oModel) } )

Return oModel

/*{Protheus.doc} ViewDef
View da Rotina da Transferencia de Ativo
@author Jose Augusto Ribeiro
@since 08/05/2015
@version P12
@return oView ,Objeto ,View da Rotina de Transferencia de Ativo
*/
Static Function ViewDef()
Local oModel		:= FwLoadModel("ATFA060")
Local oView			:= FwFormView():New()
//Criando a Estrutura
Local oStruFn9		:= FWFormStruct( 2, 'FN9', /*bAvalCampo*/,/*lViewUsado*/ )
Local oStruFns		:= FWFormStruct( 2, 'FNS', /*bAvalCampo*/,/*lViewUsado*/ )
Local oStruFnr		:= FWFormStruct( 2, 'FNR', /*bAvalCampo*/,/*lViewUsado*/ )
Local lTransf		:= FwIsInCallStack("ATF060TRAN")
Local lTransfAut	:= FwIsInCallStack("AF060Auto")
Local aCposFN9		:= {}
Local nX			:= 0

oView:SetModel(oModel)

//Campos virtuais
If !lVisu
	oStruFnr:AddField( 'OK' ,'01',' ',' ',, 'Check' ,,,,,,,,,,,, ) //'Baixa?'#//'Baixa?'
	oStruFns:AddField( 'OK' ,'01',' ',' ',, 'Check' ,,,,,,,,,,,, ) //'Baixa?'#//'Baixa?'
EndIf

If lTransfAut

	//AddField(	cIdField	,cOrdem	,cTitulo	,cDescric	,aHelp		,cType	,cPicture	,bPictVar	,cLookUp	,lCanChange	,cFolder	,cGroup	,aComboValues	,nMaxLenCombo	,cIniBrow	,lVirtual	,cPictVar, lInsertLine )
	oStruFn9:AddField(	'TOTBEM'	,'10'	,STR0153		, STR0153	,{STR0153}	,'N'	,NIL		,NIL		,NIL		,.T.		,'1'		,'1'	,NIL			,NIL			,nil		,.T.		,NIL ) //"Total de Bens"##"Exercício Contábil"

	oView:AddUserButton(STR0194,"",{|| MSGRUN(STR0193,STR0160,{|| A060InvSel() }) }) //"Inverte Seleção Ativos"###"Aguarde, invertendo a seleção dos ativos..."###"Processando"

EndIf

//---------------------------------------------------------------------------------
// Remove os campos que não precisam ser exibidos na visualização da transferencia
//---------------------------------------------------------------------------------
If lVisu

	aCposFN9 :=	AClone(oStruFn9:GetFields())

	For nX := 1 To Len(aCposFN9)
		If oStruFN9:GetProperty(aCposFN9[nX][MVC_VIEW_IDFIELD],MVC_VIEW_VIRTUAL)
			oStruFN9:RemoveField(aCposFN9[nX][MVC_VIEW_IDFIELD])
		EndIf
	Next nX

	Asize(aCposFN9,0)
	aCposFN9 := Nil

EndIf

//Remove campos que nao precisam ser exibidos na Transferencia e Transferencia Automatica
If lTransf .Or. lTransfAut .Or. lVisu
	//FNR
	oStruFnr:RemoveField("FNR_IDMOV")
	oStruFnr:RemoveField("FNR_STATUS")
	oStruFnr:RemoveField("FNR_CBADES")
	oStruFnr:RemoveField("FNR_ITEDES")
	oStruFnr:RemoveField("FNR_CODREL")
	//FNS
	oStruFns:RemoveField("FNS_IDMOV")
	oStruFns:RemoveField("FNS_CODREL")
EndIf

//Adicionando o Componente
oView:AddField('View_FN9',oStruFn9,"FieldFN9")
oView:AddGrid ('View_FNR' ,oStruFnr,"GridFNR")
oView:AddGrid ('View_FNS' ,oStruFns,"GridFNS")

//Criando o a Estrutura do Pai , Filho e Neto
oView:CreateHorizontalBox('Pai',If(lVisu,20,40))
oView:CreateHorizontalBox('Filho',If(lVisu,40,35))
oView:CreateHorizontalBox('Neto',If(lVisu,40,25))

//Não permite apagar linha
oView:SetNoDeleteLine('View_FNR')
oView:SetNoDeleteLine('View_FNS')

//Não permite inluir linha
oView:SetNoInsertLine('View_FNR')
oView:SetNoInsertLine('View_FNS')

//Amarrando as Estruturas com as grids
oView:SetOwnerView('View_FN9','Pai')
oView:SetOwnerView('View_FNR','Filho')
oView:SetOwnerView('View_FNS','Neto')

oView:EnableTitleView('GridFNS'	, STR0118 ) //'Tipos de Ativos'
oView:EnableTitleView('GridFNR'	, STR0117) //'Ativos' 

oView:lModify			:= .F.
oView:oModel:lModify	:= .F.

Return oView

/*{Protheus.doc} AF060Auto
Transferencia em lote
@author Mayara Alves
@since 18/05/2015
@version P12
*/
//Todo verificar o filto, para trazar os itens selecionados.
Function AF060Auto()
	Local aArea		:= GetArea()
	Local lRet		:= .F.

	Private cPerg	:= "AFA060A"

	lFN9			:= .T.

	//Zero arrays de contabilizacao AVP
	aAvpCtbO := {}
	aAvpCtbD := {}

	//Valida data
	If !af060data( dDataBase, .T. )
		Return
	Endif

	lRet := AF060Trans(.T.)

	If lRet  
		//Chama a tela
		//"Transferencia em Lote" - Alterada a opção para 9, pois ao bloquear o acesso para 
		//opcao "Transferir" também bloqueava a automatica na execucao do FWExecView
		MSGRUN(STR0159,STR0160,{|| FWExecView(STR0119, "ATFA060", 9/*MODEL_OPERATION_UPDATE*/, /*oDlg*/, { || .T. } )})//"Aguarde, Carregando os Registros"##"  Processando"
	EndIf

	//--------------------------------------------------------------------
	// Desabilita a reabertura da tela na conclusão do processo, pois foi
	// utilizada a opção 3 no menu para possibilitar a seleção da filial
	//--------------------------------------------------------------------
	MBrChgLoop(.F.)

	RestArea(aArea)

Return

/*{Protheus.doc} ATF060TRAN
Chama a tela de Transferencia
@author Mayara Alves
@since 18/05/2015
@version P12
*/
Function ATF060TRAN()
	Local lRet := .T.

	lAuto			:= .T.
	lAtfAuto	:= IsBlind()
	//Chama a tela
	lRet := AF060Trans(.F.)
	If(lRet)
		If	!lAtfAuto
		MSGRUN(STR0177,STR0178,{|| FWExecView (STR0120, "ATFA060", MODEL_OPERATION_UPDATE, /*oDlg*/, { || .T. } ) })//"Aguarde, Carregando os Registros... "##"  Processando ..."
		Endif
	EndIf

Return lRet

/*{Protheus.doc} LOADFN9
Faz o Load na FN9 para abrir a tela.
@author Mayara Alves
@since 18/05/2015
@param oModel
@return aDados
@version P12
*/
Static Function LOADFN9(oModel)
Local aDados		:= {}
Local oModelFN9		:= oModel:GetModel('FieldFN9')
Local aCposVlr		:= oModelFN9:GetStruct():GetFields()
Local aFilCpos		:= {}
Local nContCpo		:= 0
Local cIDMOV		:= ""
Local cAliasTRAN	:= QryFNR(.T.) //Retorna o numero de linhas da FNR

dbSelectArea("FN9")
FN9->(dbSetOrder(1)) //FN9_FILIAL+FN9_IDMOV

dbSelectArea("FNR")
FNR->(dbSetOrder(1)) //FNR_FILIAL+FNR_IDMOV

dbSelectArea("FNS")
FNS->(dbSetOrder(1)) //FNS_FILIAL+FNS_IDMOV+FNS_CODREL+FNS_TIPO+FNS_SEQ

While .T.
	cIDMOV := GetSxENum("FN9", "FN9_IDMOV")
	ConfirmSx8()
	If FN9->(!DBSeek(xFilial("FN9") + cIDMOV)) .AND. FNR->(!DBSeek(xFilial("FNR") + cIDMOV)) .AND. FNS->(!DBSeek(xFilial("FNS") + cIDMOV))
		Exit
	EndIf
EndDo

For nContCpo := 1 To Len(aCposVlr)
	If aCposVlr[nContCpo][3] == "FN9_FILIAL"
		AADD(aFilCpos,xFilial("FN9"))
	ElseIf aCposVlr[nContCpo][3] == "FN9_IDMOV"
		AADD(aFilCpos,cIDMOV)
	ElseIf aCposVlr[nContCpo][3] == "FN9_DATA"
		AADD(aFilCpos,DDATABASE)
	ElseIf aCposVlr[nContCpo][3] == "TOTBEM"
		AADD(aFilCpos, (cAliasTRAN)->NLINHA)
	ElseIf aCposVlr[nContCpo][3] == "FN9_FILDES"
		AADD(aFilCpos, cFilAnt)
	Else
		AADD(aFilCpos,CriaVar(aCposVlr[nContCpo][3],.T.))
	EndIf
Next nContCpo

aDados := {aFilCpos,0}

If Select(cAliasTRAN) > 0
	(cAliasTRAN)->(DbCloseArea())
EndIf

Return aDados

/*{Protheus.doc} LoadFNR
Faz o Load na FNR para abrir a tela.
@author Mayara Alves
@since 18/05/2015
@param oModel
@return aDados
@version P12
*/
Static Function LoadFNR(oModel,cAliasFNR)
Local aDados		:= {}
Local oFNRStruct	:= oModel:GetStruct()
Local oModelFN9	:= oModel:GetModel('FieldFN9')
Local aCposVlr	:= {}
Local aFilCpos	:= {}
Local aArea		:= GetArea()
Local nContCpo	:= 0
Local cAliasFNR	:= QryFNR(.F.) //Query SN1
Local nItem		:= 0
Local cExpFiltro	:= ""
Local cFiltro		:= ""
Local lAF060FIL	:= ExistBlock("AF060FIL")
Local lLote		:= FwIsInCallStack("AF060Auto")
Local cIdMov		:= oModelFN9:GetValue('FieldFN9','FN9_IDMOV')
Local cChavAux	:= ""
Local nBem			:= 0
Local lAmbComp		:= .F.

aCposVlr := oFNRStruct:GetFields()
If(lLote)
	If(MV_PAR04 == 1)
		cExpFiltro := BuildExpr("SN3")
		If(lAF060FIL)
			cFiltro := ExecBlock("AF060FIL",.F.,.F.)
			If !Empty(cFiltro)
				If !Empty(cExpFiltro)
					cExpFiltro += " .AND. " + cFiltro
				Else
					cExpFiltro := cFiltro
				Endif
			EndIf
		EndIf
	EndIf
Endif

While (cAliasFNR)->(!Eof())

If IsInCallStack("ATFA126")
	lAmbComp := IIF(Empty(SN1->N1_FILIAL), .T., .F.)
EndIf

	If(lLote)
		SN3->(DbGoto((cAliasFNR)->(RECNO)))
		
		//Aplica filtro personalizado do usuario
		If !Empty(cExpFiltro) .And. (!SN3->&(cExpFiltro))
			(cAliasFNR)->(DbSkip())
			Loop
		EndIf
		
		//Tratamento para não repetir o ativo na tela
		If Empty(cChavAux) .Or. cChavAux != (cAliasFNR)->N1_CBASE+(cAliasFNR)->N1_ITEM
			cChavAux := (cAliasFNR)->N1_CBASE+(cAliasFNR)->N1_ITEM
		Else
			(cAliasFNR)->(DbSkip())
			Loop
		EndIf
		
		nItem++
		For nContCpo := 1 To Len(aCposVlr)
			If aCposVlr[nContCpo][3] == "FNR_FILIAL"
				Aadd(aFilCpos,xFilial("FNR"))
			ElseIf aCposVlr[nContCpo][3] == "FNR_DATA"
				Aadd(aFilCpos,dDatabase)
			ElseIf aCposVlr[nContCpo][3] $ "FNR_QTDORI|FNR_QTDDES"
				Aadd(aFilCpos,(cAliasFNR)->N1_QUANTD)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILORI|FNR_FILDES"
				If lAmbComp
					If AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILORI"
						Aadd(aFilCpos,(cAliasFNR)->N3_FILORIG)
					ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILDES"	
						Aadd(aFilCpos,Iif(lAmbComp,SNM->NM_FILDEST,cFilAnt))
					EndIf
				Else
					Aadd(aFilCpos,(cAliasFNR)->N1_FILIAL)
				EndIf	
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_GRPORI|FNR_GRPDES"	//Grupo
				Aadd(aFilCpos,(cAliasFNR)->N1_GRUPO)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_LOCORI|FNR_LOCDES"	//Local
				Aadd(aFilCpos,(cAliasFNR)->N1_LOCAL)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_CBAORI|FNR_CBADES"	//C Base Ori
				Aadd(aFilCpos,(cAliasFNR)->N1_CBASE)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_ITEORI|FNR_ITEDES"
				Aadd(aFilCpos,(cAliasFNR)->N1_ITEM)
			ElseIf aCposVlr[nContCpo][3] == "FNR_CODREL"
				Aadd(aFilCpos,cvaltochar(nItem))
			ElseIf aCposVlr[nContCpo][3] == "FNR_IDMOV"
				Aadd(aFilCpos,cIdMov)
			ElseIf aCposVlr[nContCpo][3] == "FNR_DESCRI"
				Aadd(aFilCpos,(cAliasFNR)->N1_DESCRIC)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_TXPADO|FNR_TXPADD"
				Aadd(aFilCpos,(cAliasFNR)->N1_TAXAPAD)
			ElseIf aCposVlr[nContCpo][3] == "OK"
				Aadd(aFilCpos,.T.)
			ElseIf aCposVlr[nContCpo][3] == "FNR_STATUS"
				Aadd(aFilCpos,1)
			Else
				Aadd(aFilCpos,CriaVar(aCposVlr[nContCpo][3],.T.))
			EndIf
		Next nContCpo
	Else
		
		nItem++
		For nContCpo := 1 To Len(aCposVlr)
			If aCposVlr[nContCpo][3] == "FNR_FILIAL"
				Aadd(aFilCpos,xFilial("FNR"))
			ElseIf aCposVlr[nContCpo][3] == "FNR_DATA"
				Aadd(aFilCpos,dDatabase)
			ElseIf aCposVlr[nContCpo][3] $ "FNR_QTDORI|FNR_QTDDES"
				Aadd(aFilCpos,(cAliasFNR)->N1_QUANTD)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILORI|FNR_FILDES"
				If lAmbComp
					If AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILORI"
						Aadd(aFilCpos,(cAliasFNR)->N3_FILORIG)
					ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_FILDES"	
						Aadd(aFilCpos,Iif(lAmbComp,SNM->NM_FILDEST,cFilAnt))
					EndIf
				Else
					Aadd(aFilCpos,cFilAnt)
				EndIf				
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_GRPORI|FNR_GRPDES"	//Grupo
				Aadd(aFilCpos,(cAliasFNR)->N1_GRUPO)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_LOCORI|FNR_LOCDES"	//Local
				Aadd(aFilCpos,(cAliasFNR)->N1_LOCAL)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_CBAORI|FNR_CBADES"	//C Base Ori
				Aadd(aFilCpos,(cAliasFNR)->N1_CBASE)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_ITEORI|FNR_ITEDES"
				Aadd(aFilCpos,(cAliasFNR)->N1_ITEM)
			ElseIf aCposVlr[nContCpo][3] == "FNR_CODREL"
				Aadd(aFilCpos,cvaltochar(nItem))
			ElseIf aCposVlr[nContCpo][3] == "FNR_IDMOV"
				Aadd(aFilCpos,cIdMov)
			ElseIf aCposVlr[nContCpo][3] == "FNR_DESCRI"
				Aadd(aFilCpos,(cAliasFNR)->N1_DESCRIC)
			ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNR_TXPADO|FNR_TXPADD"
				Aadd(aFilCpos,(cAliasFNR)->N1_TAXAPAD)
			ElseIf aCposVlr[nContCpo][3] == "OK"
				Aadd(aFilCpos,.T.)
			ElseIf aCposVlr[nContCpo][3] == "FNR_STATUS"
				Aadd(aFilCpos,1)
			Else
				Aadd(aFilCpos,CriaVar(aCposVlr[nContCpo][3],.T.))
			EndIf
		Next nContCpo
	EndIf
	
	Aadd(aFilCpos,.T.)
	Aadd(aDados,{0,aFilCpos})
	
	aFilCpos := {}
	nBem ++
	(cAliasFNR)->(DbSkip())
EndDo

If Select(cAliasFNR) > 0
	(cAliasFNR)->(DbCloseArea())
EndIf

If(lLote)
	oModelFN9:GetModel('FieldFN9'):LoadValue('TOTBEM',nBem)
EndIf
RestArea(aArea)

Return aDados

/*{Protheus.doc} AT060QryFNR
Query para carregar FNR com base na SN1
@author Mayara Alves
@since 18/05/2015
@return cAliasTRAN
@version P12
*/
Static Function QryFNR(lLinha)
Local cQry			:= ""
Local lLote			:= FWIsInCallStack('AF060Auto')
Local cAliasTRAN	:= GetNextAlias()
Local lAmbComp		:= .F.

If(lAtfAuto)
	
	lLote := .F.
	
EndIF

If lLinha
	cQry := "SELECT COUNT(N1_CBASE) NLINHA" +CRLF
Else
	cQry := "SELECT N1_FILIAL,N1_GRUPO,N1_LOCAL,N1_CBASE,N1_QUANTD,N1_ITEM,N1_DESCRIC,N1_TAXAPAD " +CRLF
	
	If lLote
		
		cQry += ",SN3.R_E_C_N_O_ RECNO " +CRLF
		
	EndIf
EndIf

If lAmbComp .and. !lLinha
	cQry += ", N3_FILORIG"
EndIf	

cQry += "FROM " + RetSqlName("SN1") + " SN1 " +CRLF
If lAmbComp .and. !lLinha
	cQry += " INNER JOIN " + RetSqlName("SN3") + " SN3 " +CRLF
	cQry += " ON N3_FILIAL = '" + xFilial("SN3") + "' AND " +CRLF
	cQry += " N3_CBASE = N1_CBASE AND N3_ITEM = N1_ITEM "  +CRLF
ElseIf lLote .And. !lLinha
	cQry += " INNER JOIN " + RetSqlName("SN3") + " SN3 " +CRLF
	cQry += " ON N3_FILIAL = '" + xFilial("SN3") + "' AND " +CRLF
	cQry += " N3_CBASE = N1_CBASE AND N3_ITEM = N1_ITEM "  +CRLF
EndIf
cQry += "WHERE N1_FILIAL = '" + FWXFilial("SN1") + "' "+CRLF

If lLote
	cQry += "AND N1_CBASE BETWEEN '" + MV_PAR05	+ "' AND '"  + MV_PAR06	+ "' "  +CRLF //Do Bem - Até Bem
	cQry += "AND N1_ITEM BETWEEN  '" + MV_PAR07	+ "' AND '"  + MV_PAR08	+ "' "  +CRLF //Do Item - Até Item
Else
	cQry += "AND N1_CBASE = '" + SN3->N3_CBASE	+ "' "  +CRLF //Até Bem
	cQry += "AND N1_ITEM =  '" + SN3->N3_ITEM	+ "' "  +CRLF //Do Item
EndIf
cQry += "AND N1_STATUS = '1' "  +CRLF //Bem em uso
cQry += "AND N1_BAIXA = ' ' "  +CRLF //Bem em uso
cQry += "AND SN1.D_E_L_E_T_ = ' ' "  +CRLF

cQry := ChangeQuery( cQry )

dbUseArea( .T. , "TOPCONN" , TcGenQry(,,cQry) , cAliasTRAN , .T. , .F.)

dbSelectArea(cAliasTRAN)

Return cAliasTRAN

/*{Protheus.doc} AF060Activ
Executa após a validação.
@author Alvaro Camillo
@since 24/06/2015
@version P12
@project Inovação Controladoria
*/
Static Function AF060Activ(oModel)
Local oView := FWViewActive()

If oView <> Nil
	oView:lModify 		:= .F.
	oView:oModel:lModify	:= .F.
EndIf

Return .T.

/*{Protheus.doc} AF060VLD
Efetua a Validação para saber se carrega a tela ou não
@author Jose Augusto Ribeiro
@since 24/06/2015
@version P12
@return lRet,logico, Retorna  .T. para verdadeiro e .F. para nao validado
@project Inovação Controladoria
*/
Static Function AF060VLD()

Local lRet			:= .T.
Local cAliasFNR	:= QryFNR(.F.) //Query SN1

If(((cAliasFNR)->(EOF())) .And. !FwIsInCallStack("ATF060VTR"))
	
	(cAliasFNR)->(DbCloseArea())
	HELP(" ",1,"AF060VLD",,STR0121 ,1,0) //"Não Foi Localizado o Bem na SN1"
	lRet := .F.
	
EndIf

If Select(cAliasFNR) > 0
	(cAliasFNR)->(DbCloseArea())
EndIf

Return lRet

/*{Protheus.doc} LoadFNS
Faz o Load na FNS para abrir a tela.
@author Mayara Alves
@since 18/05/2015
@param oModel
@return aDados
@version P12
*/
Static Function LoadFNS(oModel,cAliasFNS)

Local aDados		:= {}
Local oFNSStruct	:= oModel:GetStruct()
Local oModelFN9		:= oModel:GetModel()
Local oModelFNR		:= oModelFN9:GetModel("GridFNR")
Local oModelFNS		:= oModelFN9:GetModel("GridFNS")
Local aCposVlr		:= {}
Local aFilCpos		:= {}
Local nItem			:= 0
Local cIDMOV		:= oModelFNR:GetValue("FNR_IDMOV")
Local cAliasFNS		:= ""
Local nContCpo		:= 0

aCposVlr := oFNSStruct:GetFields()

If (Type("cBaseAuto") <> "U" .Or. Type("cItemAuto") <> "U") .and. !empty(cBaseAuto +cItemAuto) 
	cAliasFNS := QryFNS(cBaseAuto,cItemAuto)
Else
	cAliasFNS := QryFNS(oModelFNR:GetValue("FNR_CBAORI"),oModelFNR:GetValue("FNR_ITEORI"))
EndIf

While (cAliasFNS)->(!Eof())
	
	nItem++
	For nContCpo := 1 To Len(aCposVlr)
		If aCposVlr[nContCpo][3] == "FNS_FILIAL"
			AADD(aFilCpos,xFilial("FNS"))
		ElseIf aCposVlr[nContCpo][3] == "FNS_DATA"
			AADD(aFilCpos,oModelFNR:GetValue("FNR_DATA"))
		ElseIf aCposVlr[nContCpo][3] == "FNS_TIPO"
			AADD(aFilCpos,(cAliasFNS)->N3_TIPO)
		ElseIf aCposVlr[nContCpo][3] == "FNS_SEQ"
			AADD(aFilCpos,(cAliasFNS)->N3_SEQ)
		ElseIf aCposVlr[nContCpo][3] == "FNS_HISTOR"
			AADD(aFilCpos,(cAliasFNS)->N3_HISTOR)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONTAO|FNS_CONTAD"	//Conta Contabil
			AADD(aFilCpos,(cAliasFNS)->N3_CCONTAB)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCBEMO|FNS_CCBEMD"	//C Custo da Conta do Bem
			AADD(aFilCpos,(cAliasFNS)->N3_CUSTBEM)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONDDO|FNS_CONDDD"	//Conta Despesa Depreciacao
			AADD(aFilCpos,(cAliasFNS)->N3_CDEPREC)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCDESO|FNS_CCDESD"	//Centro de Custo Despesa
			AADD(aFilCpos,(cAliasFNS)->N3_CCUSTO)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONDAO|FNS_CONDAD"	//Conta Deprec. Acumulada
			AADD(aFilCpos,(cAliasFNS)->N3_CCDEPR)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONCDO|FNS_CONCDD"	//Cta Correcao Depreciacao
			AADD(aFilCpos,(cAliasFNS)->N3_CDESP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CONCOO|FNS_CONCOD"	//Conta Correcao Bem
			AADD(aFilCpos,(cAliasFNS)->N3_CCORREC)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCDDO|FNS_CCDDD"	//Centro Custo Desp Depr.
			AADD(aFilCpos,(cAliasFNS)->N3_CCDESP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCDAO|FNS_CCDAD"	//Centro Custo Dep. Acumul.
			AADD(aFilCpos,(cAliasFNS)->N3_CCCDEP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCCDO|FNS_CCCDD"	//Centro Custo Corr. Depr.
			AADD(aFilCpos,(cAliasFNS)->N3_CCCDES)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CCCORO|FNS_CCCORD"	//Centro Custo Corr. Monet.
			AADD(aFilCpos,(cAliasFNS)->N3_CCCORR)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITBEMO|FNS_ITBEMD"	//Item Conta do Bem
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCCON)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITDEDO|FNS_ITDEDD"	//Item Despesa Depreciacao
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCDEP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITDEAO|FNS_ITDEAD"	//Item Depreciacao Acm
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCCDE)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITCDEO|FNS_ITCDED"	//Item Cor.Des. Depreciacao
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCDES)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_ITCORO|FNS_ITCORD"	//Item Correcao Monetaria
			AADD(aFilCpos,(cAliasFNS)->N3_SUBCCOR)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVBEMO|FNS_CVBEMD"	//Classe de Valor do Bem
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLCON)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVDEPO|FNS_CVDEPD"	//Classe Vlr Despesa Dep.
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLDEP)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVCDEO|FNS_CVCDED"	//Classe de Vlr Dep. Acum.
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLCDE)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVDESO|FNS_CVDESD"	//Classe de Vlr Cor. Depr.
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLDES)
		ElseIf AllTrim(aCposVlr[nContCpo][3]) $ "FNS_CVCORO|FNS_CVCORD"	//Classe de Vlr Correc Bem
			AADD(aFilCpos,(cAliasFNS)->N3_CLVLCOR)
		ElseIf aCposVlr[nContCpo][3] == "FNS_IDMOV"
			AADD(aFilCpos,cIDMOV)
		ElseIf aCposVlr[nContCpo][3] == "FNS_CODREL"
			AADD(aFilCpos,oModelFNR:GetValue("FNR_CODREL"))
		ElseIf aCposVlr[nContCpo][3] == "OK"
			AADD(aFilCpos,.T.)
		Else
			AADD(aFilCpos,CriaVar(aCposVlr[nContCpo][3],.T.))
		EndIf
		
	Next nContCpo
	
	AADD(aFilCpos,.T.)
	AADD(aDados,{0,aFilCpos})
	
	aFilCpos := {}
	
	(cAliasFNS)->(DbSkip())
EndDo

If Select(cAliasFNS) > 0
	(cAliasFNS)->(DbCloseArea())
EndIf

Return aDados

/*{Protheus.doc} AT060QryFNS
Query para carregar FNS com base na SN3
@author Mayara Alves
@since 18/05/2015
@return cAliasFNS
@version P12
*/
Static Function QryFNS(cBase,cItem)
	Local cQry		:= ""
	Local cAliasFNS	:= GetNextAlias()
	Local lTransf		:=  FWIsInCallStack("AF126TRANS") .And. !(xFilial("SN1",SNM->NM_FILDEST) !=  xFilial("SN1")) // Transferência de Filial não se considera TIPO

	Default cBase	:= ""
	Default cItem	:= ""

	cQry := "SELECT N3_ITEM,N3_TIPO,N3_SEQ,N3_HISTOR,N3_CCUSTO,N3_CCONTAB,N3_CCORREC,N3_CDESP," +CRLF
	cQry += "N3_CCDEPR,N3_CDEPREC,N3_CUSTBEM,N3_CCCORR,N3_CCDESP,N3_CCCDEP,N3_CCCDES," +CRLF
	cQry += "N3_SUBCCON,N3_SUBCCOR,N3_SUBCDEP,N3_SUBCCDE,N3_SUBCDES,N3_CLVLCON,N3_CLVLCOR," +CRLF
	cQry += "N3_CLVLDEP,N3_CLVLCDE,N3_CLVLDES" +CRLF
	cQry += "FROM " + RetSqlName("SN3") + " SN3 " +CRLF
	cQry += "WHERE N3_FILIAL = '" + FWXFilial("SN3") + "' "+CRLF
	cQry += "AND N3_CBASE = '" + cBase	+ "' " +CRLF //Até Bem
	cQry += "AND N3_ITEM =  '" + cItem+ "' " +CRLF //Do Item
	cQry += "AND N3_BAIXA <> '1' " +CRLF //Nao transfere tipo baixado
	If lTransf
		cQry += "AND N3_TIPO =  '" + cTipoAuto+ "' " +CRLF 
	EndIf
	cQry += "AND SN3.D_E_L_E_T_ = '' " +CRLF

	cQry := ChangeQuery( cQry )

	dbUseArea( .T. , "TOPCONN" , TcGenQry(,,cQry) , cAliasFNS , .T. , .F.)

	dbSelectArea(cAliasFNS)

Return cAliasFNS

/*{Protheus.doc}AF060TRG
Função de Gatilho , para gatilhar os campos da FN9 para FNR
@author Jose Augusto Ribeiro
@since 11/05/2015
@version P12
@param cCampo, Caracter, Nome do Campo que ira ser gatilhado
@return cRet,Caracter ,Retorno do Conteudo que deve ser gatilhado
*/
Function AF060TRG(cCampo)

	Local aArea			:= GetArea()
	Local oModel		:= FwModelActive()
	Local oModelFN9		:= oModel:GetModel('FieldFN9')
	Local cRet			:= ""
	Local oModelFNR		:= oModel:GetModel('GridFNR')
	Local oModelFNS		:= oModel:GetModel('GridFNS')
	Local nI			:= 0
	Local nFNs			:= 0
	Local oView			:= FWViewActive()
	Local aSaveLines	:= FWSaveRows()

	If "FN9" $ cCampo
		cRet := oModelFN9:GetValue(cCampo)
	ElseIf "FNR" $ cCampo
		cRet := oModelFNR:GetValue(cCampo)
	EndIf
	//Realizar Alltrim apenas se o campo for do tipo caractere, campos numéricos não realizar
	If  ValType(cRet) == 'C'
		cRet := Alltrim(cRet)
	EndIf

	For nI := 1 To oModelFNR:Length()
		oModelFNR:GoLine(nI)

		//------------------------------
		// Campos da pasta Dados Gerais
		//------------------------------
		If(cCampo == "FN9_FILDES")
			oModelFNR:SetValue('FNR_FILDES',cRet)

		ElseIf(cCampo == "FN9_DATA")
			oModelFNR:SetValue('FNR_DATA',cRet)

		ElseIf(cCampo == "FN9_GRPDES")
			If ReadVar() == "M->FN9_GRPDES"
				If oModelFNR:LoadValue("FNR_GRPDES", If(cRet == '*', oModelFNR:GetValue("FNR_GRPORI"), cRet) )
					Af060Grupo( If(cRet == '*', oModelFNR:GetValue("FNR_GRPORI"), cRet) )
				EndIf
			Else
				If oModelFNR:SetValue("FNR_GRPDES", If(cRet == '*', oModelFNR:GetValue("FNR_GRPORI"), cRet) )
					Af060Grupo( If(cRet == '*', oModelFNR:GetValue("FNR_GRPORI"), cRet) )
				EndIf
			EndIf

		ElseIf(cCampo == "FN9_LOCDES")
			oModelFNR:SetValue("FNR_LOCDES", If(cRet == '*', oModelFNR:GetValue("FNR_LOCORI"), cRet) )

		ElseIf(cCampo == "FN9_TXPADD")
			oModelFNR:SetValue("FNR_TXPADD", If(cRet == '*', oModelFNR:GetValue("FNR_TXPADO"), cRet) )

		ElseIf(cCampo == "FN9_QTDDES")
			oModelFNR:SetValue("FNR_QTDDES", If(cRet == 0, oModelFNR:GetValue("FNR_QTDORI"), cRet) )

		ElseIf(cCampo == "FN9_CCDESD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCDESD", If(cRet == '*', oModelFNS:GetValue("FNS_CCDESO"), cRet) )
			Next nFNs

		//--------------------------------
		// Campos da pasta Conta Contabil
		//--------------------------------
		ElseIf(cCampo == "FN9_CONTAD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONTAD", If(cRet == '*', oModelFNS:GetValue("FNS_CONTAO"), cRet) )
			Next nFNs

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CONCOD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONCOD", If(cRet == '*', oModelFNS:GetValue("FNS_CONCOO"), cRet) )
			Next nFNs

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CONDDD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONDDD", If(cRet == '*', oModelFNS:GetValue("FNS_CONDDO"), cRet) )
			Next nFns	

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CONDAD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONDAD", If(cRet == '*', oModelFNS:GetValue("FNS_CONDAO"), cRet) )
			Next nFNs

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CONCDD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CONCDD", If(cRet == '*', oModelFNS:GetValue("FNS_CONCDO"), cRet) )
			Next nFNs

			oModelFNS:GoLine(1)

		//---------------------------------
		// Campos da pasta Centro de Custo
		//---------------------------------
		ElseIf(cCampo == "FN9_CCBEMD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCBEMD", If(cRet == '*', oModelFNS:GetValue("FNS_CCBEMO"), cRet) )
			Next nFns

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CCCORD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCCORD", If(cRet == '*', oModelFNS:GetValue("FNS_CCCORO"), cRet) )
			Next nFns

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CCDDD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCDDD", If(cRet == '*', oModelFNS:GetValue("FNS_CCDDO"), cRet) )
			Next nFns

			oModelFNS:GoLine(1)

		ElseIf(cCampo == "FN9_CCDAD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCDAD", If(cRet == '*', oModelFNS:GetValue("FNS_CCDAO"), cRet) )
			Next nFns

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CCCDD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CCCDD", If(cRet == '*', oModelFNS:GetValue("FNS_CCCDO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		//-------------------------------
		// Campos da pasta Item Contabil
		//-------------------------------
		ElseIf(cCampo =="FN9_ITBEMD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_ITBEMD", If(cRet == '*', oModelFNS:GetValue("FNS_ITBEMO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_ITCORD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_ITCORD", If(cRet == '*', oModelFNS:GetValue("FNS_ITCORO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_ITDEDD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_ITDEDD", If(cRet == '*', oModelFNS:GetValue("FNS_ITDEDO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_ITDEAD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_ITDEAD", If(cRet == '*', oModelFNS:GetValue("FNS_ITDEAO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_ITCDED")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_ITCDED", If(cRet == '*', oModelFNS:GetValue("FNS_ITCDEO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		//---------------------------------
		// Campos da pasta Classe de Valor
		//---------------------------------
		ElseIf(cCampo =="FN9_CVBEMD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CVBEMD", If(cRet == '*', oModelFNS:GetValue("FNS_CVBEMO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CVCORD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CVCORD", If(cRet == '*', oModelFNS:GetValue("FNS_CVCORO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CVDEPD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CVDEPD", If(cRet == '*', oModelFNS:GetValue("FNS_CVDEPO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CVCDED")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CVCDED", If(cRet == '*', oModelFNS:GetValue("FNS_CVCDEO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		ElseIf(cCampo =="FN9_CVDESD")
			For nFNs := 1 To oModelFNS:Length()
				oModelFNS:GoLine(nFns)
				oModelFNS:SetValue("FNS_CVDESD", If(cRet == '*', oModelFNS:GetValue("FNS_CVDESO"), cRet) )
			Next nFNS

			oModelFNS:GoLine(1)

		//-----------------------------
		// Campos da pasta Nota Fiscal
		//-----------------------------
		ElseIf(cCampo == "FN9_GERNF")
			oModelFNR:SetValue("FNR_GERNF",cRet)

		ElseIf(cCampo == "FN9_SERIE")
			oModelFNR:SetValue("FNR_SERIE",cRet)

		ElseIf(cCampo == "FN9_CLSNF")
			oModelFNR:SetValue("FNR_CLSNF",cRet)

		ElseIf(cCampo == "FN9_TESSAI")
			oModelFNR:SetValue("FNR_TESSAI",cRet)

		ElseIf(cCampo == "FN9_TESENT")
			oModelFNR:SetValue("FNR_TESENT",cRet)

		ElseIf(cCampo == "FN9_VALNF")
			oModelFNR:SetValue("FNR_VALNF",cRet)

		EndIf

	Next nI

	FWRestRows(aSaveLines)

	//--------------------------------------------------------------------------------
	// Restaura o valor da variavel que define a forma de atualização com base na SNG
	//--------------------------------------------------------------------------------
	If cCampo == "FN9_GRPDES"
		__nAtuGrp	:= 2
	EndIf

	If oView != Nil
		oView:Refresh('View_FNR')
		oView:Refresh('View_FNS')
	EndIf

	RestArea(aArea)

Return cRet

/*{Protheus.doc} AF060DATA
Função de Validação da Data de Tansferencia
@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param dData, data , Data da Transferencia
@param lAuto,Logico, (Descrição do parâmetro)
@return lRet,Logico, Retorno .T. validado  ou .F. não validado
*/
Function AF060Data(dData)
Local lRet			:= .T.
Local dUltDepr		:= GetMV("MV_ULTDEPR")
Local lGspInUseM	:= IIf(Type('lGspInUse')=='L', lGspInUse, .F.)
Local cCalcDep		:= GetMV("MV_CALCDEP",.F.,"0")
Local dDataBloq		:= GetNewPar("MV_ATFBLQM",CTOD("")) //Data de Bloqueio da Movimentação - MV_ATFBLQM
Local cTipDepr		:= GetMv("MV_TIPDEPR")
Default dData		:= dDatabase

If lGspInUseM
	dUltDepr := MsSomaMes(dUltDepr,-1,.T.)//Se for GSP, pega o ultimo dia do mes anterior
Endif

If !Empty(dData) .AND. (dData <= dDataBloq)
	HELP(" ",1,"AF060BLQM",,STR0061 + DTOC(dDataBloq) ,1,0) //"A data de aquisição do bem é igual ou menor que a data de bloqueio de movimentação : "
	lRet := .F.
ElseIf cCalcDep == "0" // Depreciação Mensal
	If dData <= dUltDepr .Or. dData > LastDay(dUltDepr+1)
		//Tipo Depreciacao diferente 02-Mes Subsequente
		If cTipDepr <> "2"
			Help(" ",1,"AFDTTRANS") //A transferência só pode ocorrer no mês  imediatamente posterior ao último cálculo mensal de correção e depreciação.
			lRet := .F.
		ElseIf dData < (FirstDay(dUltDepr))
			Help(" ",1,"AfA060DFIL",,STR0049+DTOC(dUltDepr),1,0) //"A Database do sistema deve ter o mês igual ao parâmetro MV_ULTDEPR = "
			lRet := .F.
		Endif
	End
Else
	If Year(dDataBase) <= Year(dUltDepr) .Or. (Year(dDataBase) > Year(dUltDepr) + 1)
		Help(" ",1,"AFDTTRANS") //A transferência só pode ocorrer no mês  imediatamente posterior ao último cálculo mensal de correção e depreciação.  
		lRet := .F.
	Endif
EndIf

//Validacao para o bloqueio do proceco
If lRet .And. !CtbValiDt(,dData  ,,,,{"ATF001"},)
	lRet := .F.
EndIf 

If lRet .And. dData < SN1->N1_AQUISIC
	Help(" ",1,"A060DTAQUI") //A data da transferência não pode ser    anterior a data de aquisição do bem.
	lRet := .F.
End

Return lRet

/*{Protheus.doc} AFA060FIL
Verifica as Filiais de Destino
@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param cFildes,caracter,Codigo da Filial Destino
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Function AFA060FIL(cFilDes,lGerNF)
Local lRet			:= .T.
Local aArea			:= GetArea()
Local cEmpAtu		:= SM0->M0_CODIGO
Local cFilOri		:= cFilAnt
Local cTipoDepr		:= GetMv("MV_TIPDEPR")
Local dUltDeprOr	:= GetMv("MV_ULTDEPR")
Local dUltDeprDs	:= ""
Local nRecEmp		:= 0
Local cCNPJCli		:= ""
Local cCNPJFor		:= SM0->M0_CGC
Local lAF060DES		:= ExistBlock("AF060DES")

DbSelectArea("SM0")
nRecEmp := Recno()

If(!DbSeek(cEmpAtu+cFilDes))

	Help(" ",1,"AFA060FIL") // Esta filial nao existe
	lRet := .F.

ElseIf lAF060DES
	lRet := ExecBlock("AF060DES",.F.,.F.,{cFilDes,dUltDeprOr,dUltDeprDs})			

ElseIf !A060VLDFil(cFilDes) .And. (IIf(FindFunction("ADMTabExc"), ADMTabExc("SN3"), !Empty(xFilial("SN3"))))//Valida a filial somente para situação de tabela exclusiva
	lRet := .F.
	Help('',1,'AFA060VLD',,STR0113,1,0) //"Usuario não possui acesso a filial destino"

ElseIf(cTipoDepr == '2' .And. ( cFilOri <> cFilDes )) //Tipo Depreciacao = 02(Mes Subsequente)

	DbGoto(nRecEmp)
	cFilAnt := cFilDes
	dUltDeprDs	:= GetMv("MV_ULTDEPR")
	If( dUltDeprOr <> dUltDeprDs )//Compara data da ultima depreciacao (filiais origem e destino)

		Help(" ",1,"AfA060Fil",,STR0050+CRLF+STR0051+DTOC(dUltDeprOr)+CRLF+STR0052+DTOC(dUltDeprDs)+CRLF+CRLF+STR0053,1,0) //"A Data do último cálculo de depreciação da Filial Origem está diferente da Filial Destino"##"Filial Origem = "##"Filial Destino = "##"A transferência não poderá ser realizada para esta Filial"
		lRet := .F.

	EndIf
EndIf

DbGoto(nRecEmp)
cFilAnt := cFilOri
dUltDeprDs := GetMv("MV_ULTDEPR")
If(lRet)
	If( cFilOri <> cFilDes )
		If ( SN1->N1_TPCTRAT $ "2/3")

			Help(" ",1,"AfA060TERC",,STR0068 ,1,0)//"Bens em controle de terceiro não podem ser transferidos"
			lRet := .F.

		EndIf
	EndIf
EndIf

//---------------------------------------------------------------------
// Verifica se a filial destino possui CNPJ informado na geracao de NF
//---------------------------------------------------------------------
If lRet .And. lGerNF .And. Empty( cCNPJCli := GetAdvFVal("SM0","M0_CGC",cEmpAnt+cFilDes,1,""))
	lRet := .F.
	Help( "", 1, "AFA060FIL", , STR0122 ,1, 0 )//"A filial de destino não possui CNPJ cadastrado, impossibilitando a geração da NF."
EndIf

//---------------------------------------------------------------------------------------------------
// Verifica se a filial de destino esta cadastrada como cliente na filial de origem na geracao de NF
//---------------------------------------------------------------------------------------------------
If lRet .And. lGerNF .And. Empty(GetAdvFVal("SA1","A1_COD",XFilial("SA1") + PadR(cCNPJCli,TamSX3("A1_CGC")[1]),3,""))
	lRet := .F.
	Help( "", 1, "AFA060FIL", , STR0123 ,1, 0 )//"A filial de destino não está cadastrada como cliente na filial de origem, impossibilitando a geração da NF. Efetue o cadastro utilizando o CNPJ da filial de destino."
EndIf

//------------------------------------------------------------------------------------------------------
// Verifica se a filial de origem esta cadastrada como fornecedor na filial de destino na geracao de NF
//------------------------------------------------------------------------------------------------------
If lRet .And. lGerNF .And. Empty(GetAdvFVal("SA2","A2_COD",XFilial("SA2",cFilDes) + PadR(cCNPJFor,TamSX3("A2_CGC")[1]),3,""))
	Help( "", 1, "AFA060FIL", , STR0124 ,1, 0 ) //"A filial de origem não está cadastrada como fornecedor na filial de destino, impossibilitando a geração da NF. Efetue o cadastro utilizando o CNPJ da filial de origem."
	lRet :=.F.
EndIf

RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060VLGRP
Valida o Grupo de Transferencia do Bem
@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param  cGrupo,Caracter,Codigo do Grupo
@param  cFilDest,Caracter,Codigo da Filial Destino
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Function AF060VLGRP( cGrupo , cFilDest , cTabela )
Local lRet		:= .T.
Local aArea		:= GetArea()
Local aAreaSNG	:= SNG->(GetArea())

Default cGrupo := ""
Default cFilDest := ""
Default cTabela	:= SUBSTR(ReadVar(),4,3)

If lRet .And. !Empty(cGrupo) .And. AllTrim(cGrupo) <> "*"
	DbSelectArea("SNG")
	SNG->(DbSetOrder(1))
	lRet := SNG->(DbSeek(xFilial("SNG",cFilDest)+cGrupo))
EndIf



If lRet .And. (("FN9" $ cTabela) .Or. "FNR" $ cTabela .And. !FWIsInCallStack("AF060TRG"))

	//----------------------------------------------------------------------------------------------------
	// Caso o grupo seja informado, apresenta para o usuário a opção de espelhar ou complementar os dados
	// __nAtuGrp == 1 - Atualizar - Campos em branco na SNG serão desconsiderados
	// __nAtuGrp == 2 - Espelhar - Campos em branco na SNG serão considerados
	// __nAtuGrp == 3 - Cancelado pelo usuário
	//----------------------------------------------------------------------------------------------------
	If !Empty(cGrupo)

		If IsBlind()
			__nAtuGrp := 2 //Caso não tenha tela, mantém a opção de espelhar
		Else

			__nAtuGrp := AVISO( "AF060VLGRP",				;
								STR0187 + CRLF + CRLF +		;	//"Grupo de Bens alterado, defina a forma de atualização dos dados:"
								STR0188 + CRLF + CRLF +		;	//"Espelhar - Considera todos os campos do cadastro do Grupo de Bens (inclusive campos em branco)."
								STR0189,					;	//"Atualizar - Considera somente os campos preenchidos no cadastro de Grupo de Bens (desconsidera campos em branco)."
								{STR0190,STR0191,STR0192},	;	//"Atualizar"###"Espelhar"###"Cancelar"
								3 )
		EndIf

		If __nAtuGrp == 3 //Cancelado pelo Usuário 
			HELP(" ",1,"AF060VLGRP",,"Grupo nao confirmado. Verifique!" ,1,0) 
			lRet := .F.
			_lAltNGCTB := .T.
		Else
			_lAltNGCTB := .F.
		EndIf

	//-------------------------------------------------------------------------------
	// Caso o grupo seja limpo, apresenta a opção de limpar todos os dados contábeis
	//-------------------------------------------------------------------------------
	Else

		If IsBlind()
			_lAltNGCTB := .F.
			__nAtuGrp := 2 //Caso não tenha tela, mantém a opção de espelhar
		Else

			If MsgYesNo(STR0107,STR0106) //"Grupo de Bens alterado, alterar dados contabeis?" ,"Confirma?"
				_lAltNGCTB := .F.
				__nAtuGrp := 2 //Espelhar - Considera campos em branco da SNG
			Else
				lRet := .F.
				HELP(" ",1,"AF060VLGRP",,"Grupo nao confirmado. Verifique!" ,1,0)
				_lAltNGCTB := .T.
			EndIf

		EndIf

	EndIf

EndIf

RestArea( aAreaSNG )
RestArea( aArea    )

Return lRet

/*{Protheus.doc} AFTemTp14
Valida se existe Tipo 14 - AVP para o Ativo 
@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param  cTipo ,Caracter,Tipo do Bem
@param  cCbase,Caracter,Codigo do Bem
@param  cItem,Caracter,Codigo do Item do Bem
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Static Function AFTemTp14(cTipo , cCbase, cItem)
Local aArea		:= GetArea()
Local aAreaSN3	:= SN3->(GetArea())
Local lRet		:= .F.

DEFAULT cCbase	:= ""
DEFAULT cTipo	:= ""
DEFAULT cItem	:= ""

If cTipo == '14'
	lRet := .T.
Else
	DbSelectArea("SN3")
	SN3->(DbSetOrder(11))//N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO
	If(SN3->(MsSeek(xFilial("SN3") + cCbase + cItem + "14")))
		lRet := .T.
	EndIf
EndIf

RestArea(aAreaSN3)
RestArea(aArea)

Return lRet

/*{Protheus.doc} A060TXRALT
Não permite alterar a taxa caso ela seja preenchida pelo grupo de bens

@author Jose Augusto Ribeiro
@since 18/05/2015
@version P12
@param  cCbase,Caracter,Codigo do Grupo do Bem
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Function A060TXRALT(cGrupo)
Local lRet		:= .T.
Local aArea		:= GetArea()
Local aAreaSNG	:= SNG->(GetArea())

If !FWIsInCallStack("Af060Grupo") //Tratamento para permitir o preenchimento quando feito pelo Grupo de Bens

	If !Empty( cGrupo )
		DbSelectArea("SNG")
		SNG->( DbSetOrder(1) )

		If SNG->( DbSeek( xFilial( "SNG" ) + cGrupo ) )
			lRet := Empty(SNG->NG_TAXAPAD)
		EndIf
	EndIf

EndIf

RestArea(aAreaSNG)
RestArea(aArea)

Return lRet

/*{Protheus.doc} A060TXRVLD
Validação do cadastro de taxa
@author Daniel Mendes
@since 20/10/2016
@version P12
@param  cTaxa, cFilDest
@return lRet,Logico,Retorno .T. validado  ou .F. não validado
*/
Function A060TXRVLD(cTaxa,cFilDest)
Local lRet			:= .T.
Local aArea			:= GetArea()
Local aAreaSNH		:= SNH->( GetArea() )

Default cTaxa		:= ""
Default cFilDest	:= XFilial("SNH")

If !Empty(cTaxa) .And. AllTrim(cTaxa) <> "*"
	SNH->(DBSetOrder(1)) //NH_FILIAL+NH_CODIGO
	lRet := SNH->(MsSeek(xFilial("SNH",cFilDest)+cTaxa))
EndIf

RestArea(aAreaSNH)
RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060MOEDA
Verifica se tem data cadastrada na data informada
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param dData, data, data a ser verificada
@return lRet, Logico, Retorno .T. validado  ou .F. não validado
*/
Function AF060MOEDA(dData,nTaxaDepr)
Local aArea			:= GetArea()
Local aAreaSM2		:= SM2->(GetArea())
Local lRet			:= .T.

Default nTaxaDepr		:= 0

Private cAtfMoeda	:= GETMV("MV_ATFMOED")

DbSelectArea("SM2")
DbSetOrder(1)
If SM2->(MsSeek(dData))
	nTaxaDepr := &("SM2->M2_MOEDA"+cAtfMoeda)
EndIf

RestArea(aAreaSM2)
RestArea(aArea)

Return lRet

/*{Protheus.doc} A060BLQLOC
Bloqueia e Desbloqueia o bem dependendo do local
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param cLocalAtf, caracter, Codigo do Local do Ativo
@param cBase, caracter, Codigo base o Bem
@param cItem, caracter, Codigo do Item do Bem
*/
Static Function A060BLQLOC(cLocalAtf,cBase,cItem)
	Local aArea		:= GetArea()
	Local aAreaSN1	:= SN1->(GetArea())
	Local aAreaSNL	:= SNL->(GetArea())
	Local cStatus	:= ""

	DbSelectArea("SNL")
	SNL->(DbSetOrder(1))
	SN1->(DbSetOrder(1))

	If(SNL->(DbSeek(xFilial("SNL")+cLocalAtf)))
		If(SNL->NL_BLOQ == '1')

			cStatus := "3"

		Else

			cStatus := "1"

		EndIf
	EndIf
	If(SN1->(DbSeek(xFilial("SN1")+cBase+cItem)))

		RecLock("SN1",.F.)

		SN1->N1_STATUS := cStatus

		SN1->(MsUnlock())
	EndIf

	RestArea(aAreaSN1)
	RestArea(aAreaSNL)
	RestArea(aArea)

Return

/*{Protheus.doc} A060VERIND
Verifica se ha um indicie de depreciação na filial destino
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param nRecnoSN3, numérico , (Descrição do parâmetro)
@param cFilDest , caracter, (Descrição do parâmetro)
@return lRet    , Logico   , Retorno .T. validado  ou .F. não validado
*/
Static Function A060VERIND(nRecnoSN3,cFilDest)
	Local aArea		:= GetArea()
	Local aAreaSN3	:= SN3->(GetArea())
	Local cFilAux	:= ""
	Local cBaseAux	:= ""
	Local cItemAux	:= ""
	Local cTipoInd	:= ""
	Local lRet		:= .T.

	SN3->(DbSetOrder(1))
	SN3->(DbGoto(nRecnoSN3))

	cFilAux		:= SN3->N3_FILIAL
	cBaseAux	:= SN3->N3_CBASE
	cItemAux	:= SN3->N3_ITEM

	While(SN3->(!EOF()) .And. cFilAux+cBaseAux+cItemAux == SN3->(N3_FILIAL+N3_CBASE+N3_ITEM))
		If(SN3->N3_TPDEPR == "A")
			If(FNI->(MsSeek(xFilial("FNI")+SN3->N3_CODIND)))

				cTipoInd := FNI->NI_TIPO

			EndIf
			If(!(FNI->(MsSeek(xFilial("FNI"+cFilDest)+SN3->N3_CODIND))) .Or.FNI->NI_TIPO != cTipoInd)

				Help( ,, "AF060FNI",, STR0078 + SN3->N3_CODIND + STR0079  , 1, 0 ) //"A ficha de ativo possui o método de depreciação por índice, e o índice "##" não existe na filial de destino, ou o tipo é diferente."
				lRet := .F.
				Exit

			EndIf
		EndIf
		SN3->(DbSkip())
	EndDo

	RestArea(aAreaSN3)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060VLLOC
Valida o Status do Local do Ativo Origem e Destino
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param cFilDest, caracter, Codigo da Filial do Destino
@param cFilOrig, caracter, Codigo da Filial de Origem
@param cLocOri , caracter, Codigo de Local de Origem
@param cLocDest, caracter, Codigo de Local de Destino
@return lRet   , Logico  , Retorno .T. validado  ou .F. não validado
*/
Function AF060VLLOC(cFilDest,cFilOrig,cLocOri,cLocDest)
Local lRet     := .T.
Local aArea    := GetArea()
Local aAreaSNL := SNL->(GetArea())
Local cFilSNL  := Nil

If !Empty( cLocDest ) .And. AllTrim( cLocDest ) <> "*"
	If cFilDest == cFilOrig .Or. Empty( cFilDest ) .Or. Empty( FwxFilial( "SNL" ) )
		cFilSNL := xFilial( "SNL" )
	Else
		cFilSNL := xFilial( "SNL" , IIf( Empty( cFilDest ) , Nil , cFilDest ) )
	EndIf

	If !SNL->( MsSeek( cFilSNL + cLocDest ) )
		Help( " ", 1, "ATFBLQLOC", , STR0182, 1, 0 )		// 'Cadastro de Locais inválido!'	//-- JRJ 20170828-A
		lRet := .F.
	EndIf
EndIf

If lRet .And. cLocOri != cLocDest
	If Posicione("SNL",1,xFilial("SNL")+cLocDest,"NL_BLOQ") == '1'
		Help( " ", 1, "ATFBLQLOC", , STR0071, 1, 0 ) //"Endereços de origem e destino bloqueados. Não é possivel tranferir entre endereços bloqueados."
		lRet := .F.
	EndIf
EndIf

RestArea( aAreaSNL )
RestArea( aArea    )
Return lRet

/*{Protheus.doc} AF060VLATF
Verifica se o Bem exite na Filial de Destino
@author Jose Augusto Ribeiro
@since 20/05/2015
@version P12
@param cFilDest, caracter, Codigo da Filial de Destino
@param cCodigo , caracter,  Codigo do Bem , parametro apenas ser chamado no TUDOOK
@param cItem   , caracter, Codigo do Item do Bem , parametro apenas ser chamado no TUDOOK
@param lTudoOk , Logico  , Parametro para saber ser foi chamado no tudook ou no valid do check , passar .T. no TUDOOK
@return lRet   , Logico  , Retorno .T. validado  ou .F. não validado
@Obs Foi contemplada nesta função a AF060ValATF
*/
Static Function AF060VLATF(cFilDest,cCodigo,cItem,lTudoOk)
	Local lRet		:= .T.
	Local aArea		:= GetArea()
	Local aAreaSN1	:= SN1->(GetArea())
	Local oModel	:= FWModelActive()
	Local oModelFNR	:= oModel:GetModel("GridFNR")
	Local nCont		:= 0
	Local aItem 		:= {}

	//conta o numero de bens
	lRet := Af060FunSk(oModel)

	//Desmarca e Marca Grid FNS
	lRet := FDesFNS(oModel)

	If(!lTudoOk)
		If(oModelFNR:GetValue("OK"))

			lRet := AF060Valid(cFilDest,cCodigo,cItem,0,oModelFNR:Length(),{})

		EndIf
		
	Else
		For nCont := 1 to oModelFNR:Length()
			oModelFNR:GoLine(nCont)
			If(oModelFNR:GetValue("OK"))
				aAdd(aItem,{oModelFNR:GetValue("FNR_CBAORI"),oModelFNR:GetValue("FNR_ITEORI")})
				lRet := AF060Valid(cFilDest,oModelFNR:GetValue("FNR_CBAORI"),oModelFNR:GetValue("FNR_ITEORI"),nCont,oModelFNR:Length(),aItem)

			EndIf
		Next nCont
	EndIf

	RestArea(aAreaSN1)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060Valid
Função de Validação do Bem
@author Jose Augusto Ribeiro
@since 22/05/2015
@version P12
@param cFilDest, caracter, Codigo da Filial de Destino
@param cCodigo , caracter, Codigo do Bem , parametro apenas ser chamado no TUDOOK
@param cItem   , caracter, Codigo do Item do Bem , parametro apenas ser chamado no TUDOOK
@param nCont   , numerico, Numero do Contador do Loop quando for transferencia em lote
@param nLinhas , numerico, Numero de Bens a ser transferido
@param aItens  , Array   , Array com o numero de  Base e Item dos Ativos
@return lRet   , Logico  , Retorno .T. validado  ou .F. não validado
@Obs Foi contemplada nesta função a AF060ValATF
*/
Static Function AF060Valid(cFilDest,cCodigo,cItem,nCont,nLinhas,aItens)
	Local oModel	:= FWModelActive()
	Local lRet		:= .T.
	Local aArea		:= GetArea()
	Local aAreaSN1	:= SN1->(GetArea())
	Local lAF060Val	:= ExistBlock("AF060Val")
	Local nAux 		:= 0
	Local cTexto		:= "" 
	
	SN1->(DbSetOrder(1))
	If(xFilial("SN1",cFilDest) != xFilial("SN1"))
		If(SN1->(MsSeek(xFilial("SN1",cFilDest)+cCodigo+cItem)))
			If(lAF060Val)

				lRet := ExecBlock("AF060Val",.F.,.F.)

			Else
				If(!lAtfAuto)
					If(nCont == 0 )
						If Aviso(STR0084,STR0085,{STR0086, STR0087}) == 1  //"Atencao"##"Bem ja Existente na Filial Destino. Para ser transferido temos que incrementar o item mantendo o codigo Base. Prossegue ?"##"Sim"##"Nao"

							lRet := .T. //prossegue a transferencia e incrementa o item do bem

						Else

							lRet := .F. 

						EndIf
					ElseIf(nCont == nLinhas)
							For nAux := 1 To Len(aItens)
								If(nAux == 1)
									cTexto := STR0125 //"Há bens já existentes na Filial de Destino."
									cTexto += CRLF
									cTexto += STR0126 //"Deseja incrementar o item dos seguintes bens ?"
								EndIf
								cTexto += CRLF
								cTexto += aItens[nAux][1]
								cTexto += "- " + aItens[nAux][2]
								
							Next nAux
							If MsgYesNo(STR0084,cTexto) //"Atencao"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
							
								lRet := .T.
							
							Else
							
								lRet := .F.
								oModel:SetErrorMessage("",,,"","AF060Valid",STR0156) //"Operação cancelada"
							
							EndIf 
					EndIf
				Else
				
					lRet := .T.
				
				EndIf
			EndIf
		EndIf
	EndIf

	If lIsRussia
		If lRet
			If SN3->N3_OPER <> '1' // CAZARINI - 20.01.2017 - Asset Into Operation?
				Help(" ",1,"SN3NOOPER") // This asset is not in operation. Put it into operation
				lRet := .F.
			Endif
		Endif
	Endif

	RestArea(aArea)
	RestArea(aAreaSN1)

Return lRet

/*{Protheus.doc} AF060EXIFI
Verifica se Ctas/CCustos transfer. existem na filial Destino e Valida a Conta
para qual os valores estao sendo transferidos ou entidades gerencial (Centro de custo, item e classe Valor)
@author Jose Augusto Ribeiro
@since 21/05/2015
@version P12
@param cAlias   , caracter, Alias da tabela a ser posicionada
@param cEntOrig , caracter, Conta de Origem caso a de Destino estiver preenchida com '*'
@param cTabela  , caracter, Informa de qual tabela o campo pertence , pois para carregar o Modelo
@param cCamp    , caracter, Informa o campo a ser validado
@return lRet    , Logico  , Retorno .T. validado  ou .F. não validado
@Obs  Esta Função esta validando o que a função AF060Conta e AF060EXIFIL
@Obs Função tambem contempla a Validação da Função AF060CCusto
*/
Function AF060EXIFIL(cAlias,cEntOrig,cTabela,cCamp,cFilDest,nRecnoSN3)

	Local lRet			:= .T.
	Local aArea		:= GetArea()
	Local aAreaSN3	:= SN3->(GetArea())
	Local aAlias		:= IIf(!lGspInUse .And. CtbInUse(), { "CT1", "CTT" }, IIf(lGspInUse,{ "NI1", "NI3" }, { "SI1", "SI3" } ))
	Local oModel		:= FWModelActive()
	Local oModelFn9	:= oModel:GetModel("FieldFN9")
	Local oModelFns	:= oModel:GetModel("GridFNS")
	Local cContAux	:= A060MExec(ReadVar())
	Local cFilAux		:= cFilAnt
	Local aAreaCT1	:= CT1->(GetArea())
	Local aAreaCTT	:= CTT->(GetArea())
	Local aAreaCTH	:= CTH->(GetArea())
	Local aAreaCTD	:= CTD->(GetArea())

	Default nRecnoSN3	:= SN3->(RECNO())
	Default cFilDest	:= M->FN9_FILDES

	lRet := A060VERIND(nRecnoSN3, cFilDest) //Verificando a taxa de Depreciação da filial destino
	
	cFilAnt := cFilDest

	If lRet .And. (cContAux != '*' .Or. cTabela != "FN9") .And. !Empty(cContAux)
	//------------------------------------
	//Valdida as contas contabeis destinos
	//------------------------------------
		If (cCamp $ "CONTAD|CONCOD|CONDDD|CONDAD|CONCDD")
			dbSelectArea(aAlias[1])
			(aAlias[1])->(dbSetOrder(1))
			lRet := &(aAlias[1])->(DbSeek(xFilial(aAlias[1])+cContAux))
			If(lRet .And. cAlias $ "SI1,CT1")
				lRet := Ctb105Cta(@cContAux)
					If lRet
						lRet:=iif(cAlias=='CT1',CT1->CT1_CLASSE=='2',.T.)
						Help(" ",1,"NORECS") //"Este arquivo não contem dados a apresentar."
					Endif
			Else
				HELP(" ",1,"AF060EXIFIL",,STR0127 ,1,0) //"Não existe esta conta contabil na filial de destino"
			EndIf
		EndIf
	EndIf	
	//-----------------------------------
	//Valdida os centro de custo destino
	//-----------------------------------
	If (cContAux != '*' .Or. cTabela != "FN9")	.And. !Empty(cContAux)
		If (cCamp $ "CCDESD|CCBEMD|CCCORD|CCDDD|CCDAD|CCCDD")
			dbSelectArea(aAlias[2])
			(aAlias[2])->(dbSetOrder(1))
			lRet := &(aAlias[2])->(DbSeek(xFilial(aAlias[2])+cContAux))

			If(lRet .And. cAlias $ "SI3,CTT")
				lRet := Ctb105Cc(@cContAux)
				If lRet
					lRet:=iif(cAlias=='CTT',CTT->CTT_CLASSE=='2',.T.)
					Help(" ",1,"NORECS") //"Este arquivo não contem dados a apresentar."
				Endif
			Else
				HELP(" ",1,"AF060EXIFIL",,STR0128,1,0) //"Não existe esta centro de custo na filial de destino" 
			EndIf
		EndIf
	EndIf
	//-----------------------------------
	// Valida os Itens Contabeis Destino
	//-----------------------------------
	If (cContAux != '*' .Or. cTabela != "FN9") .And. !Empty(cContAux)
		If (cCamp $ "ITBEMD|ITCORD|ITDEDD|ITDEAD|ITCDED")			
		dbSelectArea("CTD")
			CTD->(dbSetOrder(1))
			lRet := (cAlias)->(DbSeek(xFilial(cAlias)+cContAux))

			If(lRet .And. cAlias $ "CTD")
				lRet := Ctb105Item(@cContAux)
				If lRet
					lRet:=iif(cAlias=='CTD',CTD->CTD_CLASSE=='2',.T.)
					Help(" ",1,"NORECS") //"Este arquivo não contem dados a apresentar."
				Endif
			Else
				HELP(" ",1,"AF060EXIFIL",,STR0129,1,0) //"Não existe esta item contabil na filial de destino" 
			EndIf
		EndIf
	EndIf
	//------------------------------------
	// Valida as Classes de Valor Destino
	//------------------------------------
	If (cContAux != '*' .Or. cTabela != "FN9")	.And. !Empty(cContAux)
		If (cCamp $ "CVBEMD|CVCORD|CVDEPD|CVCDED|CVDESD")			
		dbSelectArea("CTH")
			CTH->(dbSetOrder(1))
			lRet := (cAlias)->(DbSeek(xFilial(cAlias)+cContAux))

			If(lRet .And. cAlias $ "CTH")
				lRet := Ctb105Clvl(@cContAux)
				If lRet
					lRet:=iif(cAlias=='CTH',CTH->CTH_CLASSE=='2',.T.)
					Help(" ",1,"NORECS") //"Este arquivo não contem dados a apresentar."
				Endif
			Else
				HELP(" ",1,"AF060EXIFIL",,STR0130,1,0) //"Não existe esta classe de valor na filial de destino" 
			EndIf
		EndIf
	EndIf

	cFilAnt := cFilAux

	RestArea(aAreaCTD)
	RestArea(aAreaCTH)
	RestArea(aAreaCTT)
	RestArea(aAreaCT1)
	RestArea(aAreaSN3)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060LibCpo
Verifica se deve bloquear o campo dependendo do bem, função para ser chamada no When
@author Jose Augusto Ribeiro
@since 25/05/2015
@version P12
@param cBase, caracter, Codigo do Bem
@param cItem, caracter, Codigo do Item do Bem
@return lRet, Logico  , Retorno .T. validado  ou .F. não validado
*/
Function AF060LibCpo(cBase,cItem)
	Local lRet		:= .T.
	Local aArea		:= GetArea()
	Local aAreaSN1	:= SN1->(GetArea())

	SN1->(DbSetOrder(1))
	If(SN1->(MsSeek(xFilial("SN1")+ cBase+cItem)))
		If ATFXVerPrj(cBase,cItem)

			lRet := .F.

		EndIf

		If(lRet)
			If(SN1->N1_STATUS $ "2|3") //Bloqueio ou Bloqueio Provisorio

				lRet := .F.

			EndIf
		EndIf

		//Imobilizado nao gerado por projeto mas relacionado a projeto para execucao do mesmo
		//Exemplo: bem vindo de classificacao de compras ou por inclusao manual de bem
		If(lRet .and. !Empty(SN1->N1_PROJETO) .and. Empty(SN1->N1_PROJREV))
			lRet := .F.
		EndIf
	EndIf

	RestArea(aAreaSN1)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} Af060FunSk
Função para contar numeros de bens na transferencia em lote.
transferencia de ativos
@author Mayara Alves
@since 22/05/2015
@version P12
*/
Static Function Af060FunSk(oModel)
	Local aSaveLines	:= FWSaveRows()
	Local oModelFNR		:= oModel:GetModel('GridFNR')
	Local oModelFN9		:= oModel:GetModel('FieldFN9')
	Local nLinha		:= 0

	If oModelFNR:GetValue("OK")
		nLinha := FWFLDGET("TOTBEM")
		nLinha++
		oModelFN9:LoadValue("TOTBEM",nLinha)
	Else
		nLinha := FWFLDGET("TOTBEM")
		nLinha--
		oModelFN9:LoadValue("TOTBEM",nLinha)
	EndIf

	FWRestRows(aSaveLines)

Return(.T.)

/*{Protheus.doc} FDesFNS
Desmaca grid FNS
transferencia de ativos
@param oModel
@author Mayara Alves
@since 22/05/2015
@version P12
*/
Static Function FDesFNS(oModel)
	Local oModelFNR		:= oModel:GetModel('GridFNR')
	Local oModelFNS		:= oModel:GetModel('GridFNS')
	Local aSaveLines	:= FWSaveRows()
	Local oView			:= FWViewActive()
	Local nX			:= 0
	Local nZ			:= 0
	
	For nZ := 1 to oModelFNR:Length()
		oModelFNR:GoLine(nZ)
		If oModelFNR:GetValue("FNR_FILDES") <> oModelFNR:GetValue("FNR_FILORI")
			For nX := 1 to oModelFNS:Length()
				oModelFNS:GoLine(nX)
				oModelFNS:LoadValue("OK",oModelFNR:GetValue("OK"))
			Next nX
		Endif
	Next nZ

	FWRestRows(aSaveLines)

	oModelFNS:GoLine(1)

	If !IsBlind() .And. oView != Nil
		oView:Refresh('View_FNS')
	EndIf

Return(.T.)

/*{Protheus.doc} VldMarkFNS
Valid check da FNS, não permite se o check do grid da FNS não estiver ativo.
transferencia de ativos
@param oModel
@author Mayara Alves
@since 22/05/2015
@version P12
*/
Static Function VldMarkFNS(oModel)
	Local lRet			:= .T.
	Local oModelFNR		:= oModel:GetModel('GridFNR')
	Local oModelFNS		:= oModel:GetModel('GridFNS')
	Local aSaveLines	:= FWSaveRows()
	Local oView			:= FWViewActive()
	//Local lCheck		:= oModelCli:GetValue("FJY_OK")
	Local nX			:= 0

	If oModelFNR:SeekLine( { {"FNR_CODREL", oModelFNS:GetValue("FNS_CODREL") } } )

		If !oModelFNR:GetValue("OK")
			lRet := .F.
			oModel:SetErrorMessage("",,oModel:GetId(),"","VLDMARKFNS",STR0131) //"Ativo não selecionado, verifique." ## "O processo de baixa foi interrompido, pois não foi possível criar a nota fiscal de venda."
		EndIf
		If(oModelFNR:GetValue("FNR_FILDES") <> oModelFNR:GetValue("FNR_FILORI"))
			
				HELP(" ",1,"AF060VLATF",,STR0132,1,0) //"Em transferencia de filal , todos os tipos do bem são obrigatoriamente levado" 
				lRet := .F.
				
		EndIf
	EndIf

	FWRestRows(aSaveLines)

Return lRet

/*{Protheus.doc} AF060F3DES
Função chamada da consulta especifica A060F3, para subistituir a função
AF060codigo do antidgo ATFA060.
Troca o cFilant antes de abrir a consulta padrão dos campos de destino.
@author Mayara Alves
@since 26/05/2015
@version P12
@return lRet
*/
Function AF060F3DES()
	Local aArea		:= GetArea()
	Local _cFilOri	:= cFilAnt
	Local _cFilDest	:= ""
	Local lRet		:= .T.
	Local _cAlias	:= ""
	Local cTabCpo	:= SubStr(ReadVar(),4,3)
	Local cCampo	:= AllTrim(SubStr(ReadVar(),7))
	Local oModel	:= FwModelActive()
	Local oModelFN9	:= oModel:GetModel('FieldFN9')
	Local oModelFNR	:= oModel:GetModel('GridFNR')
	Local cRetF3	:= ""

	If cTabCpo == "FN9" .And. !Empty(FWFLDGET('FN9_FILDES')) 
		_cFilDest := FWFLDGET('FN9_FILDES')
	ElseIf  cTabCpo $ "FNR|FNS" .And. !Empty(oModelFNR:GetValue('FNR_FILDES')) 
		_cFilDest := oModelFNR:GetValue('FNR_FILDES')
	Else
		lRet := .F.
		HELP(" ",1,"AF060FILDEST",,STR0133 ,1,0) //"Preencha a filial de destino"

	EndIf

	If lRet
		//ATENCAO! alteracao do valor da variavel publica cFilAnt
		If _cFilDest != cFilAnt
			cFilAnt := _cFilDest
		EndIf

		Do Case
			//
			Case cCampo $ "_GRPDES" //Grupo - FN9 e FNR
				_cAlias	:= "SNG"
				cRetF3	:= "SNG->NG_GRUPO"

			Case cCampo $ "_LOCDES" //Local - FN9 e FNR
				_cAlias	:= "SNL"
				cRetF3	:= "SNL->NL_CODIGO"

			Case cCampo $ "_TESENT" //TES Entrada FN9 e FNR
				_cAlias	:= "SF4"
				cRetF3	:= "SF4->F4_CODIGO"

			Case cCampo $ "_TXPADD" //Taxa padrao na filial destino FN9 e FNR
				_cAlias	:= "SNH"
				cRetF3	:= "SNH->NH_CODIGO"

			Case cCampo $ "_CONTAD|_CONCOD|_CONDDD|_CONDAD|_CONCDD" //CONTA FN9 e FNS 
				_cAlias := "CT1"
				cRetF3	:= "CT1->CT1_CONTA"

			Case cCampo $ "_CCDESD|_CCBEMD|_CCCORD|_CCDDD|_CCDAD|_CCCDD" //Centro de Custo FN9 e FNS
				_cAlias	:= "CTT"
				cRetF3	:= "CTT->CTT_CUSTO"

			Case cCampo $ "_ITBEMD|_ITCORD|_ITDEDD|_ITDEAD|_ITCDED" //Item Contabeil FN9 e FNS
				_cAlias	:= "CTD"
				cRetF3	:= "CTD->CTD_ITEM"

			Case cCampo $ "_CVBEMD|_CVCORD|_CVDEPD|_CVCDED|_CVDESD" //CLASSE DE VALOR - FN9 e FNS
				_cAlias	:= "CTH"
				cRetF3	:= "CTH->CTH_CLVL"

			OtherWise
				Help( " ", 1, "ATFBLQLOC", , STR0182, 1, 0 )		// 'Cadastro de Locais inválido!'	//-- JRJ 20170828-A
			
		EndCase

		If Conpad1( , , , _cAlias )
			VAR_IXB := &(cRetF3)
		Else
			lRet := .F.
		EndIf

		//ATENCAO! retorno do valor da variavel publica cFilAnt
		If cFilAnt	!= _cFilOri
			cFilAnt	:= _cFilOri
		EndIf

	EndIf

	RestArea( aArea )

Return lRet

/*{Protheus.doc} Af060Grupo
Preenche as entidades contabeis de acordo com o grupo
@author Mayara Alves
@since 27/05/2015
@param cGrupo - codigo de grupo
@version P12
@return lRet
*/
Static Function Af060Grupo( cGrupo , cTabela )
Local lRet			:= .T.
Local lAltera		:= .T.
Local oModel		:= FwModelActive()
Local oModelFN9		:= oModel:GetModel('FieldFN9')
Local oModelFNR		:= oModel:GetModel('GridFNR')
Local oModelFNS		:= oModel:GetModel('GridFNS')
Local aArea			:= GetArea()
Local aAreaSN1		:= SN1->(GetArea())
Local aAreaSNG		:= SNG->(GetArea())
Local cFilDest		:= ""
Local aSaveLines	:= FWSaveRows()
Local nCont			:= 0
Local oView			:= FWViewActive()
Local lExstCad		:= .F.

Default cTabela := SUBSTR(ReadVar(),4 ,3 ) 

If "FN9" $ cTabela
	cFilDest	:= FWFLDGET('FN9_FILDES')
ElseIf("FNR" $ cTabela)
	cFilDest 	:= oModelFNR:GetValue('FNR_FILDES')
EndIf

dbSelectArea("SN1")
SN1->(dbSetOrder(1))
SN1->(dbSeek(xFilial("SN1")+SN3->N3_CBASE+SN3->N3_ITEM))

If lPeAF060GRP
	ExecBlock("AF060GRP",.F.,.F.,{SN1->N1_GRUPO,cGrupo})
EndIf

lExstCad := SNG->( MsSeek( xFilial( "SNG" , cFilDest ) + cGrupo ) )

If !Empty(cGrupo)

	If lAltera
		If SNG->(MsSeek(xFilial("SNG",cFilDest)+cGrupo))

			If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_TAXAPAD), oModelFNR:SetValue("FNR_TXPADD", SNG->NG_TAXAPAD ), Nil) // Taxa Regulamentada (SNH)

			For nCont := 1 to oModelFNS:Length()

					oModelFNS:GoLine(nCont)

					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCORREC), oModelFNS:SetValue("FNS_CONCOD", SNG->NG_CCORREC ), Nil) // Conta Correc
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCONTAB), oModelFNS:SetValue("FNS_CONTAD", SNG->NG_CCONTAB ), Nil) // Conta Des
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CDEPREC), oModelFNS:SetValue("FNS_CONDDD", SNG->NG_CDEPREC ), Nil) // Cta Desp Dep
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCDEPR) , oModelFNS:SetValue("FNS_CONDAD", SNG->NG_CCDEPR  ), Nil) // Cta Dep Acum
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CDESP)  , oModelFNS:SetValue("FNS_CONCDD", SNG->NG_CDESP   ), Nil) // Cta Cor Depr

					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCUSTO) , oModelFNS:SetValue("FNS_CCDESD", SNG->NG_CCUSTO ), Nil) // CC Despesa Depreciação					
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CUSTBEM), oModelFNS:SetValue("FNS_CCBEMD", SNG->NG_CUSTBEM), Nil) // CC do Bem Origem
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCCORR) , oModelFNS:SetValue("FNS_CCCORD", SNG->NG_CCCORR ), Nil) // CC Correcao monetaria
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCDESP) , oModelFNS:SetValue("FNS_CCDDD" , SNG->NG_CCDESP ), Nil) // CC Desp Depreciacao
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCCDEP) , oModelFNS:SetValue("FNS_CCDAD" , SNG->NG_CCCDEP ), Nil) // CC da Depr Acumulada
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CCCDES) , oModelFNS:SetValue("FNS_CCCDD" , SNG->NG_CCCDES ), Nil) // CC Cor Depreciacao
					
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCCON), oModelFNS:SetValue("FNS_ITBEMD", SNG->NG_SUBCCON), Nil) // Item do Bem
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCCOR), oModelFNS:SetValue("FNS_ITCORD", SNG->NG_SUBCCOR), Nil) // Item Correcao Monet.
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCDEP), oModelFNS:SetValue("FNS_ITDEDD", SNG->NG_SUBCDEP), Nil) // Item Desp. Depreciacao
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCCDE), oModelFNS:SetValue("FNS_ITDEAD", SNG->NG_SUBCCDE), Nil) // Item Depre Acumulada
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_SUBCDES), oModelFNS:SetValue("FNS_ITCDED", SNG->NG_SUBCDES), Nil) // Item da corr. Depreciacao
					
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLCON), oModelFNS:SetValue("FNS_CVBEMD", SNG->NG_CLVLCON), Nil) // Classe de Valor bem
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLCOR), oModelFNS:SetValue("FNS_CVCORD", SNG->NG_CLVLCOR), Nil) // Cl Vlr da corr. Monetaria
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLDEP), oModelFNS:SetValue("FNS_CVDEPD", SNG->NG_CLVLDEP), Nil) // Cl Vl desp de depreciacao
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLCDE), oModelFNS:SetValue("FNS_CVCDED", SNG->NG_CLVLCDE), Nil) // Cl Vl deprec. acumulada O
					If( __nAtuGrp == 2 .Or. !Empty(SNG->NG_CLVLDES), oModelFNS:SetValue("FNS_CVDESD", SNG->NG_CLVLDES), Nil) // Cl Vl corr da depreciacao
			Next nCont
		EndIf
	EndIf
	
Else 
	For nCont := 1 to oModelFNS:Length()
						
					oModelFNS:GoLine(nCont)
					
					oModelFNS:SetValue("FNS_CONCOD"		, Space(len(FNS->FNS_CONCOD)))	// Conta Correc
					oModelFNS:SetValue("FNS_CONTAD"		, Space(len(FNS->FNS_CONTAD)))	// Conta Des
					oModelFNS:SetValue("FNS_CONDDD"		, Space(len(FNS->FNS_CONDDD)))	// Cta Desp Dep
					oModelFNS:SetValue("FNS_CONDAD"		, Space(len(FNS->FNS_CONDAD)))	// Cta Dep Acum
					oModelFNS:SetValue("FNS_CONCDD"		, Space(len(FNS->FNS_CONCDD)))	// Cta Cor Depr
	
					oModelFNS:SetValue("FNS_CCDESD"		, Space(len(FNS->FNS_CCDESD)))	// CC Despesa Depreciação					
					oModelFNS:SetValue("FNS_CCBEMD"		, Space(len(FNS->FNS_CCBEMD)))	// CC do Bem Origem
					oModelFNS:SetValue("FNS_CCCORD"		, Space(len(FNS->FNS_CCCORD)))	// CC Correcao monetaria
					oModelFNS:SetValue("FNS_CCDDD"		, Space(len(FNS->FNS_CCDDD)))	// CC Desp Depreciacao
					oModelFNS:SetValue("FNS_CCDAD"		, Space(len(FNS->FNS_CCDAD)))	// CC da Depr Acumulada
					oModelFNS:SetValue("FNS_CCCDD"		, Space(len(FNS->FNS_CCCDD)))	// CC Cor Depreciacao
					
					oModelFNS:SetValue("FNS_ITBEMD"		, Space(len(FNS->FNS_ITBEMD)))	// Item do Bem
					oModelFNS:SetValue("FNS_ITCORD"		, Space(len(FNS->FNS_ITCORD)))	// Item Correcao Monet.
					oModelFNS:SetValue("FNS_ITDEDD"		, Space(len(FNS->FNS_ITDEDD)))	// Item Desp. Depreciacao
					oModelFNS:SetValue("FNS_ITDEAD"		, Space(len(FNS->FNS_ITDEAD)))	// Item Depre Acumulada
					oModelFNS:SetValue("FNS_ITCDED"		, Space(len(FNS->FNS_ITCDED)))	// Item da corr. Depreciacao
					
					oModelFNS:SetValue("FNS_CVBEMD"		, Space(len(FNS->FNS_CVBEMD)))	// Classe de Valor bem
					oModelFNS:SetValue("FNS_CVCORD"		, Space(len(FNS->FNS_CVCORD)))	// Cl Vlr da corr. Monetaria
					oModelFNS:SetValue("FNS_CVCORD"		, Space(len(FNS->FNS_CVCORD)))	// Cl Vl desp de depreciacao
					oModelFNS:SetValue("FNS_CVCDED"		, Space(len(FNS->FNS_CVCDED)))	// Cl Vl deprec. acumulada O
					oModelFNS:SetValue("FNS_CVDESD"		, Space(len(FNS->FNS_CVDESD)))	// Cl Vl corr da depreciacao
	Next nCont
		
EndIf

//------------------------------------------------------------------------------------------------
// Caso a rotina tenha sido chamada diretamente pelo preenchimento da FNR_GRPDES e não FN9_GRPDES
//------------------------------------------------------------------------------------------------
If !FWIsInCallStack("AF060TRG")
	__nAtuGrp := 2
EndIf

If !IsBlind() .And. oView != Nil
	oView:Refresh('View_FNS')
EndIf

FWRestRows( aSaveLines )
RestArea( aAreaSNG )
RestArea( aAreaSN1 )
RestArea( aArea    )
Return lRet

/*{Protheus.doc} AF060TDOK
Faz a validacao do modelo
@author Jose Augusto Ribeiro
@since 27/05/2015
@version P12
@return lRet, Logico , Retorno .T. validado  ou .F. não validado
*/
Static Function AF060TDOK(oModel)
Local lRet			:= .T.
Local lAF060TOK		:= ExistBlock("AF060TOK")
Local aArea			:= GetArea()
Local aAreaSNG		:= SNG->(GetArea())
Local aAreaSNH		:= SNH->(GetArea())
Local aAreaSN1		:= SN1->(GetArea())
Local aAreaSN3		:= SN3->(GetArea())
Local cFilBkp		:= cFilAnt
Local lAux			:= .T.
Local oModFNR		:= oModel:GetModel("GridFNR")
Local oModFNS		:= oModel:GetModel("GridFNS")
Local cFilOrig		:= ""
Local dDataTrans	:= CtoD("  /  /    ")
Local nFNR			:= 0
Local nFNS			:= 0
Local aSaveRows		:= FWSaveRows()
Local cFileLog		:= ""
Local cPathLog		:= ""
Local lMVTECATF		:= GetNewPar("MV_TECATF","N") == "S"
Local cSubProc		:= "ATFA060NFS"
Local cIdCV8		:= ""
Local cFilDest   := oModFNR:GetValue("FNR_FILDES")

Private cMensNF		:= ""

Default lMVTECATF:= .F.

//Validação das contas  na Filial de Origem e Destino

cFilAnt := cFilDest

//Se for transferencia compara os modelos para não deixar salvar sem alteracao
If !IsBlind()
	lRet := CompareDif(oModel)
EndIf

//Fazendo a Validação de data
If (lRet)
	lRet := AF060Data(oModFNS:GetValue("FNS_DATA"))
EndIf

//Fazendo a Validação da Moeda
If(lRet)
	lRet := AF060MOEDA(oModFNS:GetValue("FNS_DATA"),0)
EndIf

//Valida o Bem na Filial de Destino
If(lRet)
	lRet := AF060VLATF(oModFNR:GetValue("FNR_FILDES"), oModFNR:GetValue("FNR_CBADES"), oModFNR:GetValue("FNR_ITEDES"), .T.)
EndIf

cFilOrig   := oModFNR:GetValue("FNR_FILIAL")
dDataTrans := oModFNR:GetValue("FNR_DATA")

cFilAnt := cFilBkp

//Ponto de Entrada
If (lRet .AND. lAF060TOK)
	lAux := ExecBlock("AF060TOK",.F.,.F.,{oModel})
	If ValType(lAux) == "L"
		lRet := lAux
	EndIf
Endif

dbSelectArea("SNG")
SNG->(dbSetOrder(1))

If lRet

	For nFNR := 1 To oModFNR:Length(.T.)

		oModFNR:GoLine(nFNR)

		If oModFNR:GetValue("OK")

			//----------------------------------------------------------
			// Valida se o Ativo possui transferência em data posterior
			//----------------------------------------------------------
			If lRet
				lRet := AF060VldDt(oModFNR:GetValue("FNR_CBAORI"),oModFNR:GetValue("FNR_ITEORI"))
			EndIf

			//-------------------------------
			// Validacoes para geracao da NF
			//-------------------------------
			If lRet .And. oModFNR:GetValue("FNR_GERNF") == "1"
				If Empty(oModFNR:GetValue("FNR_CLSNF"))
					lRet:= .F.
					Help( "", 1, "AF060TDOK", ,STR0173,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} ) //"O campo classificacao da NF esta em branco"###'Verifique os dados no painel "Ativo", Código + Item:'

				ElseIf Empty(oModFNR:GetValue("FNR_SERIE"))
					lRet:= .F.
					Help( "", 1, "AF060TDOK", ,STR0174,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} ) //"O campo serie da NF esta em branco"###'Verifique os dados no painel "Ativo", Código + Item:'

				ElseIf oModFNR:GetValue("FNR_VALNF") == 0
					lRet:= .F.
					Help( "", 1, "AF060TDOK", ,STR0176,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} ) //"O campo valor da NF esta em branco"###'Verifique os dados no painel "Ativo", Código + Item:'

				EndIf
			EndIf

			//----------------------------------------------------
			// Validacao para transferencia parcial entre filiais
			//----------------------------------------------------
			If lRet .And. oModFNR:GetValue("FNR_QTDORI") <> oModFNR:GetValue("FNR_QTDDES") .And. oModFNR:GetValue("FNR_FILORI") == oModFNR:GetValue("FNR_FILDES") 
				Help("",1,"AF060TDOK",,STR0179,1,0,,,,,,{STR0180 + AllTrim(Str(nFNR)) + "."}) //"A transferência parcial só pode ser realizada entre filiais."###"Confira a filial de destino ou a quantidade para transferência. Linha: "
				lRet:= .F.
			EndIf

			//----------------------------------------------------
			// Validacao do Gestao de Servicos - Equipe Materiais
			//----------------------------------------------------
			If lRet .And. lMVTECATF
				lRet := TcAtfVldMov(oModFNR:GetValue("FNR_FILORI"),oModFNR:GetValue("FNR_CBAORI"),oModFNR:GetValue("FNR_QTDORI"))
			EndIf

			//Valida a existencia da Taxa na filial destino
			If lRet .And. !Empty(oModFNR:GetValue("FNR_TXPADD"))
				SNH->(DbSetOrder(1))
				If !SNH->(MsSeek(xFilial("SNH",cFilDest)+oModFNR:GetValue("FNR_TXPADD")))
					lRet := .F.
					Help(" ",1,"ATFNOTXR",, STR0069,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} )//"Taxa regulamentadora não cadastrada na filial destino"###'Verifique os dados no painel "Ativo", Código + Item:'
				EndIf
			EndIf

			// Nao transfere ativo com AVP
			If lRet .And. AFTemTp14(oModFNS:GetValue("FNS_TIPO"),oModFNR:GetValue("FNR_CBAORI"),oModFNR:GetValue("FNR_ITEORI")) 
				lRet := .F.
				Help(" ",1,"AF060AVPX",,STR0080+AllTrim(oModFNR:GetValue("FNR_CBAORI"))+STR0081+AllTrim(oModFNR:GetValue("FNR_ITEORI"))+STR0083,1,0) //"O ativo base: "//" item: "//" possui cálculo de AVP, e não poderá ser transferido."
			EndIf

			// Avalia se o bem está pendente de classificação
			If lRet
				SN1->(DBSetOrder(1)) 
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If !Af240JaClas()
						lRet := .F.
						Help(" ",1,"AF060CLASS")
					EndIf
				EndIf
			EndIf

			//Nao transferir bens de provisao que sejam filhos de bem de Orcamento
			If lRet
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If SN1->N1_PATRIM == 'V' .And. !(Empty(SN1->N1_BASESUP))
						lRet := .F.
						Help(" ",1,"AF060NOCPR",,STR0073+CRLF+STR0074+SN1->N1_BASESUP +"-"+SN1->N1_ITEMSUP,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //'Este ativo foi gerado a partir do processo de constituição de provisão. Este tipo de ativo não poderá ser selecionado diretamente. Selecione o ativo superior (PAI) para que a tranferencia deste ocorra.'###"C.Base-Item: "###'Verifique os dados no painel "Ativo", Código + Item:'
					EndIf
				EndIf
			EndIf

			//Caso o bem pertença a um projeto, não pode ser transferido.
			If lRet .And. ATFXVerPrj(oModFNR:GetValue("FNR_CBAORI"),oModFNR:GetValue("FNR_ITEORI"), .T. )
				lRet := .F.
			EndIf

			//PRV
			//Imobilizado nao gerado por projeto mas relacionado a projeto para execucao do mesmo
			//Exemplo: bem vindo de classificacao de compras ou por inclusao manual de bem
			If lRet
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If !Empty(SN1->N1_PROVIS)
						Help(" ",1,"AF060NOPRV",,STR0077,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //'Este ativo está relacionado a realização de um controle de provisão. Este tipo de ativo não poderá ser selecionado para transferência entre filiais.'###'Verifique os dados no painel "Ativo", Código + Item:'
						lRet := .F.
					EndIf
				EndIf
			EndIf

			//BPI
			//Nao marcar bens de de realizacao realacionados a projeto
			If lRet .And. oModFNR:GetValue("FNR_FILORI") != oModFNR:GetValue("FNR_FILDES") 
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If !(Empty(SN1->N1_PROJETO)) .And. Empty(SN1->N1_PROJREV)
						lRet := .F.
						Help(" ",1,"AF060NOBPI",,STR0076,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //'Este ativo está relacionado a realização de um projeto (baixa de provisão). Este tipo de ativo não poderá ser selecionado para transferência entre filiais.###'Verifique os dados no painel "Ativo", Código + Item:'
					Endif
				Endif
			Endif

			//Bens em controle de terceiro não podem ser transferidos
			If lRet .And. oModFNR:GetValue("FNR_FILORI") != oModFNR:GetValue("FNR_FILDES")
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If SN1->N1_TPCTRAT $ "2/3"
						lRet := .F.
						Help(" ",1,"AfA060TERC",,STR0068,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))})//"Bens em controle de terceiro não podem ser transferidos"###'Verifique os dados no painel "Ativo", Código + Item:'
					EndIf
				EndIf
			EndIf

			//Bens bloqueados não podem ser transferidos entre filiais
			If lRet .And. oModFNR:GetValue("FNR_FILORI") != oModFNR:GetValue("FNR_FILDES")
				SN1->(DBSetOrder(1))
				If SN1->(MsSeek(xFilial("SN1")+oModFNR:GetValue("FNR_CBAORI")+oModFNR:GetValue("FNR_ITEORI")))
					If(SN1->N1_STATUS $ "2|3")
						Help(" ",1,"A060BLOQ")   //Este bem esta bloqueado, nao pode ser transferido.
						lRet := .F.
					EndIf
				EndIf
			EndIf

			If lRet
				//----------------------
				// Avalia dados da FNS
				//----------------------
				For nFNS := 1 To oModFNS:Length()

					oModFNS:GoLine(nFNS)

					If oModFNS:GetValue("OK")
						
						//VALIDA A CONTA DO ATIVO
						If lRet .and. Empty(oModFNS:GetValue("FNS_CONTAD"))
							lRet := .F.
							Help(" ",1,"AF060TDOK",,STR0197,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))})
							Exit
						EndIf
						SN3->(DBSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
						If SN3->(MSSeek(XFilial("SN3",oModFNR:GetValue("FNR_FILORI")) + oModFNR:GetValue("FNR_CBAORI") + oModFNR:GetValue("FNR_ITEORI") + oModFNS:GetValue("FNS_TIPO") + "0" + oModFNS:GetValue("FNS_SEQ") ))
							If lRet .And. !Empty(SN3->N3_CDEPREC) .AND. Empty(oModFNS:GetValue("FNS_CONDDD"))
								lRet := .F.
								Help(" ",1,"AF060TDOK",,STR0185,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //"A Conta Contábil de Despesa de Depreciação (FNS_CONDD), não pode ficar em branco no destino, pois possui informação na origem (N3_CDEPREC)."###'Verifique os dados no painel "Ativo", Código + Item:'
								Exit
							EndIf

							If lRet .And. !Empty(SN3->N3_CCDEPR) .AND. Empty(oModFNS:GetValue("FNS_CONDAD"))
								lRet := .F.
								Help(" ",1,"AF060TDOK",,STR0186,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))}) //"A Conta Contábil de de Depreciação Acumulada (FNS_CONDAD), não pode ficar em branco no destino, pois possui informação na origem (N3_CCDEPR)."###'Verifique os dados no painel "Ativo", Código + Item:'
								Exit 
							EndIf
						EndIf

					EndIf
			
				Next nFNS
			EndIf

		EndIf

		If !lRet
			Exit
		EndIf

	Next nFNR

EndIf

FWRestRows(aSaveRows)

RestArea(aAreaSN3)
RestArea(aAreaSN1)
RestArea(aAreaSNH)
RestArea(aAreaSNG)
RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060Trans
Efetua a Validação antes do FWExecView
@author Jose Augusto Ribeiro
@since 29/05/2015
@version P12
@param lAuto - se é tranferencia automatica
@return lRet,Logico,Retorna .T. para validado e .F. para nao validado
*/
Static Function AF060Trans(lLote)

	Local cN1TipoNeg	:= Alltrim(SuperGetMv("MV_N1TPNEG",.F.,"")) // Tipos de N1_PATRIM que aceitam Valor originais negativos
	Local cN3TipoNeg	:= Alltrim(SuperGetMv("MV_N3TPNEG",.F.,"")) // Tipos de N3_TIPO que aceitam Valor originais negativos
	Local lCcdp			:= GetMv("MV_ATFCCDP",.F.,.F.)
	Local dUltDepr		:= GetNewPar("MV_ULTDEPR", STOD("19800101"))
	Local lAF060CHA		:= ExistBlock("AF060CHA")
	Local lRet			:= .T.
	Local aAreaSN3		:= SN3->(GetArea())
	Local aAreaSN1		:= SN1->(GetArea())
	Local aArea			:= GetArea()
	Local cVarParam		:= ""
	Local nX			:= 0
	Local lTransfAut	:= FwIsInCallStack("AF060Auto")			//-- JRJ 20170828-C
	
	// VARIAVEIS PARA CONTABILIZACAO CONTA
	Private CTABEM		:= ""
	Private DESPDEPR	:= ""
	Private DEPREACUM	:= ""
	Private CORREDEPR	:= ""
	Private CORREBEM	:= ""
	// Variaveis para contabilizacao Centro de custo, item e classe de valor
	Private Custo 		:= ""
	Private CUSTBEMCTB	:= ""
	Private CCCORRCTB	:= ""
	Private CCDESPCTB	:= ""
	Private CCCDESCTB	:= ""
	Private CCCDEPCTB	:= ""

	Private SUBCCONCTB	:= ""
	Private SUBCCORCTB	:= ""
	Private SUBCDESCTB	:= ""
	Private SUBCDEPCTB	:= ""
	Private SUBCCDECTB	:= ""
	//Variavel de Classe de Valor
	Private CLVLCONCTB	:= ""
	Private CLVLCORCTB	:= ""
	Private CLVLDESCTB	:= ""
	Private CLVLDEPCTB	:= ""
	Private CLVLCDECTB	:= ""

	//³Verifica se o controle de solicitações está ativado, se sim encerra baixa³
	If (( SuperGetMv( "MV_ATFSOLD", .F. ,"2" ) == "1" ) .And. !lTransfAut .And. Alltrim(FunName()) == "ATFA060")		//-- JRJ 20170828-C
		HELP(" ",1,"AF060SOLD",,STR0065 ,1,0)    //"Utilize a opção Solic. Baixa/Transf, parâmetro de controle de solicitações (MV_ATFSOLD) ativado."
		lRet := .F.
	EndIf

	//Tipo Depreciacao diferente 02-Mes Subsequente
	If (GetMv("MV_TIPDEPR") == "2" .And. dDatabase < (FirstDay(GetMv("MV_ULTDEPR"))))
		Help(" ",1,"AfA060ULDP",,STR0049+DTOC(SuperGetMv("MV_ULTDEPR")) ,1,0) //"A Database do sistema deve ter o mês igual ao parâmetro MV_ULTDEPR = "
		lRet := .F.
	Endif

	If lIsRussia
		If SN3->N3_OPER <> '1' // CAZARINI - 21.01.2017 - Asset Into Operation?
			Help(" ",1,"SN3NOOPER") // This asset is not in operation. Put it into operation
			lRet := .F.
		Endif
	Endif
	
	//³Posiciona no SN3 caso seja chamado por rotina automatica³
	If (lAtfAuto)
		SN3->(dbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
		 If Type("aAutoTrans") == 'A'
		nPosBase	:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_CBASE"})
		nPosItem	:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_ITEM"})
		nPosTipo	:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_TIPO"})
		nPosBaixa	:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_BAIXA"})
		nPosSeq		:= aScan(aAutoTrans,{|x| AllTrim(x[1]) == "N3_SEQ"})

		cBaseAut	:= IIF( nPosBase > 0 , aAutoTrans[nPosBase][2], "" )
		cItemAut	:= IIF( nPosItem > 0 , aAutoTrans[nPosItem][2], "" )
		cTipoAut	:= IIF( nPosTipo > 0 , aAutoTrans[nPosTipo][2], "" )
		cBxAut		:= IIF( nPosBaixa > 0 , aAutoTrans[nPosBaixa][2], "" )
		cSeqAut		:= IIF( nPosSeq > 0 , aAutoTrans[nPosSeq][2], "" )

		SN3->(MsSeek( xFilial("SN3") + cBaseAut + cItemAut + cTipoAut + cBxAut + cSeqAut ))
		 EndIf
	EndIf

	If(!lAtfAuto .And. lLote)
		lRet := pergunte(cPerg,.T.)
	EndIf

	If (lAtfAuto) .And. !lLote
		Pergunte("AFA060", .F.)
		lCtbInTran := CTBINTRAN(0,.F.)

		MV_PAR01 := IIF(lCtbInTran,MV_PAR01,2)
		MV_PAR02 := 2
		If(Type("aParamAuto") == "A")
			For nX := 1 to Len(aParamAuto)
				cVarParam := Alltrim(Upper(aParamAuto[nX][1]))
				If("MV_PAR" $ cVarParam)
					&(cVarParam) := aParamAuto[nX][2]
				EndIf
			Next nX
		EndIf
	ElseIf !lLote .And. lRet					//-- JRJ 20170828-B

		lRet := Pergunte("AFA060", .T.)

	EndIf

	If (!lAuto .Or. lAtfAuto)
		// Recebe codigo do ativo
		cBase := SN3->N3_CBASE
		cItem := SN3->N3_ITEM

		// Verifica existencia do Ativo
		dbSelectArea("SN1")
		dbSetOrder(1)

		If(!dbSeek(XFilial("SN1",cFilial)+cBase+cItem))
			Help(" ",1,"020ATIVO") //"Não foi localizado no  SN1  (Cadastro deAtivo Imobilizado)"
			lRet := .F.
		End

		// Verifica se ativo nao esta' baixado
		If (Val( SN3->N3_BAIXA ) # 0)
			Help(" ",1,"060BAIXADO",,STR0110,1,0) //"Não é possivel transferir um bem já baixado."
			lRet := .F.
		EndIf

		If(! SoftLock("SN3"))
			lRet := .T.
		EndIf
	EndIf

	// No caso de contas de Capital, não vai a correção monetaria
	cPatrim		:= SN1->N1_PATRIM
	nValor		:= Iif( cPatrim # "C" , SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1, SN3->N3_VORIG1+SN3->N3_AMPLIA1 )
	nQtdeSn		:= IIf(SN1->N1_QUANTD == 0, 1, SN1->N1_QUANTD)
	nQtdOrig	:= nQtdeSn
	nQuant		:= nQtdeSn
	nCustAtu	:= nValor

	If (SN3->N3_TIPO = "05" .Or. (SN1->N1_PATRIM $ cN1TipoNeg) .Or. (SN3->N3_TIPO $ cN3TipoNeg))
		nValResid:= nValor + Abs( (SN3->N3_VRDACM1 + SN3->N3_VRCDA1) )
	Else
		nValResid:= nValor - ( SN3->N3_VRDACM1 + SN3->N3_VRCDA1 )
	Endif

	If(!lAtfAuto .And. lAF060CHA .And. lRet )

		Execblock("AF060CHA",.F.,.F.)

	Endif

	//  Libera o softlock instalado acima do while.
	dbSelectArea("SN3")
	MsUnlock()
	MsUnlock()

	RestArea(aAreaSN3)
	RestArea(aAreaSN1)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} af060Commit
Função chamada para gravação da transferencia e tranferencia em lote
@author Mayara Alves
@since 03/06/2015
@version P12
@param oModel
@return lRet - Se o resgistro foi gravado
@Obs a função AF060LESN3 foi implementando nessa função, agora a
gravação da transferencia e da transferencia em lote estão sendo chamada no mesmo lugar
*/
Static Function af060Commit(oModel)
Local aArea		:= GetArea()
Local aAreaSN3	:= SN3->(GetArea())
Local oModelFN9	:= oModel:GetModel("FieldFN9")
Local oModelFNR	:= oModel:GetModel("GridFNR")
Local oModelFNS	:= oModel:GetModel("GridFNS")
Local aSaveLines	:= FWSaveRows()
Local nFNR			:= 0
Local nFNS			:= 0
Local lCont		:= .T. //Continua o processo
Local cIDMOVFNR	:= ""	//Id do movimento
Local cIDMOV		:= ""
Local cCodRel		:= ""	//cod de relacionamento FNR - FNS
Local cSeq			:= ""
Local cCodBase	:= ""
Local cLocDes		:= ""
Local cItem		:= ""
Local cTpBem		:= ""
Local lLote		:= FWIsInCallStack('AF060Auto')
Local nQtdBens	:= 0 //Quantidade de bens marcado
Local lGspInUseM	:= If(Type('lGspInUse')=='L', lGspInUse, .F.)
Local dUltDepr	:= GetNewPar("MV_ULTDEPR", STOD("19800101"))
Local lMult		:= .T.
Local aAux			:= {}
Local aSavRowsLine	:= FwSaveRows()
Local nPosSN1		:= 0
Local cNewItem	:= ""
Local cFilOrig	:= "" 
Local cFilDest	:= ""
Local cNFSaida	:= ""
Local cNFEntrada	:= ""
Local cLocAtivo	:= ""
Local nX			:= 0
Local cLoteAtf	:= LoteCont("ATF")
Local dDataTrans	:= dDataBase
Local aCentro		:= {}
Local nHdlPrv		:= 0
Local lPrim		:= .T.
Local nTotal		:= 0
Local nTaxaMedia	:= 0
Local cLocOrig 	:=SN1->N1_LOCAL
Local nQtdTransf	:= 0
Local lGeraNF		:= .F.
Local cSubProc	:= "ATFA060NFS"
Local cIdCV8		:= ""
Local cMensNF		:= ""
Local cNotaFeita	:= ""
Local cSerie		:= ""
Local aCposFN9		:= oModelFN9:GetStruct():GetFields()
Local nContCpo		:= 0
Local lNgmntat		:= SuperGetMv("MV_NGMNTAT",.F.,"4") $ "1#3"

Private cArquivo	:= ""
Private cFilOrig	:= cFilAnt //Augusto : Declarado como private para a Integração para o SIGAMNT
	
//Aqui estou criando um vetor com as filiais e as ordenandos da FNR
For nFNR := 1 To oModelFNR:Length(.T.)
	oModelFNR:GoLine(nFNR)
	If oModelFNR:Getvalue("OK") //Transferencia de dados com diferentes filiais Origem e Destino
		Aadd(aAux,{oModelFNR:GetValue("FNR_FILDES"),nFNR})
	EndIf
Next nFNR

aSort(aAux, , , { | x,y | x[1]+Str(x[2]) < y[1]+Str(y[2])} )

FWRestRows(aSavRowsLine)

// Cria as tabelas temporarias antes do controle de transação
// devido ao Oracle dar commit dentro do controle ao receber instrução de create table (FwTenporaryTable)
If FindFunction("fNgCrtTemp") .And. SuperGetMv("MV_NGMNTAT",.F., "4") $ "1#3" .And. nModulo != 19
	Private oTmpTblSTZ //Tabela temporaria (STZ) - Movimentacao de Bens
	Private oTmpTblSTC //Tabela temporaria (STC) - Estrutura
	Private oTmpTblIn  //Tabela de Inconsistencias
	Private oTmpTblx   //Tabela de STC do NGESTRUTRB
	fNgCrtTemp(@oTmpTblSTZ,@oTmpTblSTC,@oTmpTblIn, @oTmpTblx)
EndIf

If SuperGetMv("MV_NGMNTAT",.F., "4") $ "1#3" .And. nModulo != 19
	cN4_HORA    := SubStr(Time(),1,5)   // Esta variavel será utilizada para gravar a hora da transferencia na funçãop ATFXMOV
EndIf 

BEGIN TRANSACTION

	//---------------------------------
	// Grava FN9 - ID da transferencia
	//---------------------------------
	Reclock( "FN9",.T. )
		For nContCpo := 1 To Len(aCposFN9)
			If aCposFN9[nContCpo][3] == "FN9_FILIAL"
				FN9->FN9_FILIAL := xFilial("FN9")
			ElseIf aCposFN9[nContCpo][3] == "FN9_IDMOV" .Or. aCposFN9[nContCpo][3] == "FN9_DATA"
				&("FN9->"+(aCposFN9[nContCpo][3])) := oModelFN9:Getvalue(aCposFN9[nContCpo][3])
			Else
				If Len(aFN9CpoUsr) > 0 .And. aScan(aFN9CpoUsr, aCposFN9[nContCpo][3]) > 0
					&("FN9->"+(aCposFN9[nContCpo][3])) := oModelFN9:Getvalue(aCposFN9[nContCpo][3])
				EndIf			
			EndIf
		Next nContCpo
	FN9->(MsUnlock())

	//---------------------------------------------------------
	// Laço dos ativos para Transferência (Filial ou Contábil)
	//---------------------------------------------------------
	For nX:= 1 TO Len(aAux)
		
		oModelFNR:GoLine(aAux[nX][2])

		//Verifico se é diferentes filiais
		lMult := oModelFNR:GetValue("FNR_FILORI") != oModelFNR:GetValue("FNR_FILDES")
		
		//Criação do Arquivo na Origem
		If(nHdlPrv <= 0 .And. nx == 1 .And. !lMult )
			nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
		Endif

		//-------------------------------------------------------------------------------------------------------------------------------------
		// Zera a variavel pois na transferencia automatica de mais de um ativo, o N4_IDMOV do segundo ativo não segue ordem crescente, devido
		// o movimento de baixa (N4_OCORR=01 N4_MOTIVO=18), prejudicando o cancelamento da transferencia de somente um dos ativos
		//-------------------------------------------------------------------------------------------------------------------------------------
		cIDMOV := ""

		//-----------------------------------
		// Transferencia para a mesma filial
		//-----------------------------------
		If !lMult .And. oModelFNR:Getvalue("OK")
			cLocDes		:= oModelFNR:Getvalue("FNR_LOCDES")
			cCodBase	:= oModelFNR:Getvalue("FNR_CBAORI")
			cItem		:= oModelFNR:Getvalue("FNR_ITEORI")
			cLocAtivo := oModelFNR:GetValue("FNR_LOCDES")
			cFilDest	:= oModelFNR:Getvalue("FNR_FILDES")
			nQtdBens++
			DbSelectArea("SN1")
			SN1->(DbSetOrder(1))
			SN1->(DbSeek(xFilial("SN1")+cCodBase+cItem))
			cLocOrig 	:=SN1->N1_LOCAL

			If (!Empty(cLocAtivo) .Or.!Empty(SN1->N1_LOCAL)) .And. SN1->N1_LOCAL != cLocAtivo
				Reclock( "SN1",.F. )
				SN1->N1_LOCAL := cLocAtivo
				SN1->(msUnlock())
				A060BLQLOC(cLocAtivo,SN1->N1_CBASE,SN1->N1_ITEM)
			Endif

			If SN1->N1_GRUPO != oModelFNR:Getvalue("FNR_GRPDES")
				Reclock( "SN1",.F. )
				SN1->N1_GRUPO 	:= oModelFNR:Getvalue("FNR_GRPDES")
				SN1->(msUnlock())
			Endif

			If SN1->N1_TAXAPAD != oModelFNR:Getvalue("FNR_TXPADD")
				Reclock( "SN1",.F. )
					SN1->N1_TAXAPAD := oModelFNR:Getvalue("FNR_TXPADD")
				SN1->(msUnlock())
			EndIf

			//---------------------------------
			// Grava FNR - Ativos Transferidos
			//---------------------------------
			GravaFNR(oModelFNR)

			For nFNS:= 1 TO oModelFNS:Length()
				oModelFNS:GoLine(nFNS)
				If oModelFNS:Getvalue("OK")

					//-----------------------------------------
					// Grava FNS - Tipos de Saldo Transferidos
					//-----------------------------------------
					GravaFNS(oModelFNS)

					//////////////////////////////////////////////////////////////////////////////////////////////////////
					//Neste If foi adicionado por que a integração com o SIGAMNT deve ser feita apenas 1 vez por ativo. //
					//e foi adicionado no Laço da FNS para , pegar o centro de custo do bem 								  //
					//////////////////////////////////////////////////////////////////////////////////////////////////////
					If(nFNS == 1 )
						aAdd(aCentro,{oModelFNS:GetValue("FNS_CCBEMD"),oModelFNS:GetValue("FNS_CCCORD"),oModelFNS:GetValue("FNS_CCDDD"),;
							oModelFNS:GetValue("FNS_CCDAD"),oModelFNS:GetValue("FNS_CCCDD")})
						
						//Transfere o Bem se houver integracao, com a mesma filial
						If lNgmntat .And. FindFunction("MNTA550")
							If !Empty(SN1->N1_CODBEM) .and. _lAltNGCTB
								If !MNTTRACCAT(cFilDest,SN1->N1_CODBEM,dDataTrans,aCentro[1],cN4_HORA)
									lCont := .F.
									oModel:SetErrorMessage("","","","","AF060CoMMIT",STR0134,"") //"A Transferencia do Bem , com o Modulo SIGAMNT foi abortada"
									DisarmTransaction()
									Break
									Exit
								EndIf
							EndIf
						EndIf
					EndIf
					
					cIDMOVFNR 	:= oModelFNS:Getvalue("FNS_IDMOV")		//Id do movimento
					cCodRel		:= oModelFNS:Getvalue("FNS_CODREL")	//cod de relacionamento FNR - FNS
					cSeq		:= oModelFNS:Getvalue("FNS_SEQ")
					cTpBem		:= oModelFNS:Getvalue("FNS_TIPO")
					
					cNewItem  :=SN1->N1_ITEM
					//Chama função de gravação
					lCont := af060Grava( oModel, @cIDMOV, cCodRel,cSeq, cLocDes,cCodBase, cItem,lMult,nFNS,nX,cNewItem,cTpBem,cIDMOVFNR, @cLoteAtf, @nHdlPrv, @cArquivo, @lPrim, @nTotal,,cLocOrig)					

					If !lCont
						Exit
					EndIf
				EndIf
			Next nFNS
	
		//-----------------------------
		// Transferencia entre filiais
		//-----------------------------
		ElseIf oModelFNR:Getvalue("OK")
			
			Af060moeda(IIf(lGspInUseM,MsSomaMes(dUltDepr,-1,.T.),dUltDepr),nTaxaMedia)
			
			cLocDes		:= oModelFNR:Getvalue("FNR_LOCDES")
			cCodBase	:= oModelFNR:Getvalue("FNR_CBAORI")
			cItem		:= oModelFNR:Getvalue("FNR_ITEORI")
			cNewItem	:= oModelFNR:Getvalue("FNR_ITEORI")
			cFilDest	:= oModelFNR:Getvalue("FNR_FILDES")
			cFilOrig	:= oModelFNR:Getvalue("FNR_FILORI")
			nQtdTransf	:= oModelFNR:Getvalue("FNR_QTDDES")
			lGeraNF		:= oModelFNR:GetValue("FNR_GERNF") == "1"
			cSerie		:= oModelFNR:Getvalue("FNR_SERIE")

			nQtdBens++

			//------------------------
			// Geracao da Nota fiscal
			//------------------------
			If lCont .And. lGeraNF

				ProcLogIni( {},__cProcPrinc ,cSubProc,@cIdCV8 )

				//--------------------------------
				// Nota de saida na filial origem
				//--------------------------------
				If AFA060NFS(oModel)

					cNotaFeita := oModelFNR:GetValue('FNR_NOTA')

					cMensNF		+= "------------------------------------------"+CRLF
					cMensNF		+=  STR0161 + cNotaFeita	+ CRLF//"Nota de Saida Gerada: "
					cMensNF		+=  STR0162 + cSerie		+ CRLF	//"Série: "
					cMensNF		+=  STR0163 + cFilOrig	+ CRLF	//"Filial: "
					cMensNF		+=  STR0164 + cCodBase	+ CRLF	//"Bem: "	
					cMensNF		+=  STR0165 + cItem		+ CRLF	//"Item: "

				Else	
					lCont := .F.
				EndIf

				//-----------------------------------
				// Nota de entrada na filial destino
				//-----------------------------------
				If AFA060NFE(oModel,cNotaFeita)

					cMensNF	+= "------------------------------------------" + CRLF
					cMensNF	+=  STR0166 + cNotaFeita	+ CRLF	//"Nota de Entrada Gerada "
					cMensNF	+=  STR0162 + cSerie		+ CRLF	//"Série: "
					cMensNF	+=  STR0163 + cFilDest	+ CRLF	//"Filial: "
					cMensNF	+=  STR0164 + cCodBase	+ CRLF	//"Bem: "	
					cMensNF	+=  STR0165 + cItem		+ CRLF	//"Item: "
					cMensNF	+= "------------------------------------------" + CRLF

				Else
					lCont := .F.
				EndIf

			EndIf

			//----------------------------------------------------
			// Validacao do Gestao de Servicos
			// Se nao tiver saldo livre para movimentar entao breca a operacao
			//----------------------------------------------------
			If lCont .And. GetNewPar("MV_TECATF","N") == "S"
				lCont := TcAtfVldMov(cFilOrig,cCodBase,nQtdTransf,cItem)
			EndIf

			//---------------------------------
			// Cria o SN1 na Filial de destino
			//---------------------------------
			If lCont
				DbSelectArea("SN1")
				SN1->(DbSetOrder(1))
				nPosSN1 := Iif(SN1->(DbSeek(xFilial("SN1")+cCodBase+cItem)),SN1->(RECNO()),0)

				//Caso o codigo + item do bem exista na filial destino incrementa o item
				While SN1->(MsSeek(xFilial("SN1",cFilDest)+SN1->N1_CBASE+cNewItem)) .Or.	!(MayIUseCode(xFilial("SN1",cFilDest)+SN1->N1_CBASE+cNewItem))
					FreeUsedCode(.T.)
					cNewItem := ATFXProxIt(cFilDest, SN1->N1_CBASE,cNewItem)
					//Atualiza os campos da FNR
					oModelFNR:Setvalue("FNR_ITEDES",cNewItem)
				EndDo
				SN1->(DbGoTo(nPosSN1))
				cFilOrig := oModelFNR:GetValue("FNR_FILORI")
				Aadd(aCamposAlt,{"N1_LOCAL"		,oModelFNR:Getvalue("FNR_LOCDES")})
				Aadd(aCamposAlt,{"N1_GRUPO"		,oModelFNR:Getvalue("FNR_GRPDES")})
				Aadd(aCamposAlt,{"N1_TAXAPAD"	,oModelFNR:Getvalue("FNR_TXPADD")})
				Aadd(aCamposAlt,{"N1_ITEMSUP"	,SN1->N1_ITEMSUP})
				Aadd(aCamposAlt,{"N1_ITEM"		,cNewItem})
				Aadd(aCamposAlt,{"N1_QUANTD"	,nQtdTransf})
			
				AFA060COPY("SN1",nPosSN1,cFilDest,aCamposAlt)
				aCamposAlt := {}
			
				FreeUsedCode(.T.)
			EndIf

			If lCont
				//---------------------------------
				// Grava FNR - Ativos Transferidos
				//---------------------------------
				GravaFNR(oModelFNR)
			EndIf

			//-------------------------------------
			// Cria o SN3/SN4 na Filial de destino
			//-------------------------------------
			If lCont
				For nFNS := 1 To oModelFNS:Length()
					oModelFNS:GoLine(nFNS)
					If oModelFNS:GetValue("OK")

						//-----------------------------------------
						// Grava FNS - Tipos de Saldo Transferidos
						//-----------------------------------------
						GravaFNS(oModelFNS)


						//////////////////////////////////////////////////////////////////////////////////////////////////////
						//Neste If foi adicionado por que a integração com o SIGAMNT deve ser feita apenas 1 vez por ativo. //
						//e foi adicionado no Laço da FNS para , pegar o centro de custo do bem 								  //
						//////////////////////////////////////////////////////////////////////////////////////////////////////
						cIDMOVFNR 	:= oModelFNS:Getvalue("FNS_IDMOV")	//Id do movimento
						cCodRel		:= oModelFNS:Getvalue("FNS_CODREL")	//cod de relacionamento FNR - FNS
						cSeq		:= oModelFNS:Getvalue("FNS_SEQ")
						cTpBem		:= oModelFNS:Getvalue("FNS_TIPO")
						cFilDest	:= oModelFNR:GetValue("FNR_FILDES")
						cFilOrig	:= oModelFNR:GetValue("FNR_FILORI")
						If(nFNS == 1)
						
							aAdd(aCentro,{oModelFNS:Getvalue("FNS_CCBEMD"),oModelFNS:Getvalue("FNS_CCCORD"),oModelFNS:Getvalue("FNS_CCDDD"),;
								oModelFNS:Getvalue("FNS_CCDAD"),oModelFNS:Getvalue("FNS_CCCDD")})
							//Transfere o Bem se houver integracao  com o modulo SIGAMNT, com filiais diferentes
							If lNgmntat .And. FindFunction("MNTA550") .And. nModulo != 19
								If !Empty(SN1->N1_CODBEM)
									If !MNTA550({dDataTrans,cN4_HORA,@cFilDest,SN1->N1_CODBEM,aCentro[1],cFilOrig})
										lCont :=  .F.
										oModel:SetErrorMessage("","","","","AF060CoMMIT",STR0134,"") //"A Transferencia do Bem , com o Modulo SIGAMNT foi abortada"
										Exit
									EndIf
								EndIf
							EndIf
						EndIf

						If (lCont)
							lCont	:= AF060Grava(oModel, @cIDMOV, cCodRel, cSeq, cLocDes, cCodBase, cItem, lMult,nFns,nX,cNewItem,cTpBem,cIDMOVFNR, @cLoteAtf, @nHdlPrv, @cArquivo, @lPrim, @nTotal,cFilDest)
						EndIF
					
						//AVP2
						//se tipo for bem classificado como O = orcamento
						//Transfere filhos do bem principal de Orçamento com AVP por parcela
						If SN1->N1_PATRIM == 'O' .AND. SN1->N1_TPAVP == '2'
							Af060GrvOrc(oModel, cIDMOV, cCodRel, cSeq, cLocDes, cCodBase, cItem, lMult)
							cNewItemSup := ""
						Endif
					
						If(!lCont)
							Exit
						EndIf
					EndIf
				Next nFNS
			EndIf
						
			//-----------------------------------
			// Integracao com Gestao de Servicos
			// Comita a movumentação no lado do Gestao de Serviços
			//-----------------------------------
			If lCont .And. GetNewPar("MV_TECATF","N") == "S"
				lCont := TcTransAtf(cFilOrig,cCodBase,cItem,cFilDest,nQtdTransf,lGeraNF,cNewItem)
			EndIf

		EndIf

		If lCont .And. nHdlPrv > 0 .And. nX == Len(aAux) .And. !lMult
			RodaProva(nHdlPrv,nTotal)
			cA100Incl(cArquivo,nHdlPrv,2,cLoteAtf,Iif(mv_par02==1,.T.,.F.),Iif(mv_par03==1,.T.,.F.))
		EndIf

		If !lCont
			Exit
		EndIf

	Next nX

	If lCont .And. lMult
		//Função para efetuar a Contabilização entre Filiais
		AF060CTB(oModel)
	EndIf

	If lCont .And. ExistBlock ("ATF060GRV")
		ExecBlock("ATF060GRV",.F.,.F.,{oModel})
	EndIf

	//-----------------------------------------
	// Apresenta mensagem com as notas geradas
	//-----------------------------------------
	If lCont .And. !Empty(cMensNF)
		ProcLogAtu(STR0167,STR0168,cMensNF,,.T.)	//"MENSAGEM"## "Geração de Notas Fiscais"
		ProcLogView(cFilAnt,__cProcPrinc,cSubProc,cIdCV8)
	EndIf

	//---------------------------------
	// Em caso de erro efetua Rollback
	//---------------------------------
	If !lCont
		DisarmTransaction()
		Break
	EndIf

END TRANSACTION

// Deleta as tabelas temporarias depois do controle de transação
// devido ao Oracle dar commit dentro do controle ao receber instrução de create table (FwTenporaryTable)
If FindFunction("fNgDelTemp") .And. SuperGetMv("MV_NGMNTAT",.F., "4") $ "1#3" .And. nModulo != 19
	fNgDelTemp()
EndIf

// Ponto de Entrada após realizar a transação (transferencia do ativo)
If lCont .And. ExistBlock ("ATF060END") 
	ExecBlock("ATF060END",.F.,.F.,{oModel}) 
EndIf
 
lFN9 := .T.

FWRestRows(aSaveLines)

RestArea(aAreaSN3)
RestArea(aArea)

Return lCont

/*{Protheus.doc} af060Grava
Função de gravacao de transferencia na propria filial
@author Mayara Alves
@since 03/06/2015
@version P12
@param oModel
@param cIDMOV	 ,caracter,Id do movimento
@param cCodRel ,caracter,Codigo de relacionamento
@param cSeq	 ,caracter,Sequencia
@param cLocDest,caracter,Local de destino
@param cCodBase,caracter,Codigo base do bem
@param cItem	 ,caracter,Item do bem
@param nFNS	 ,Quantidade de Linha da FNS
@return lRet	 ,Logico  ,Se o resgistro foi gravado
@Obs	Implementando tambem a Função Af060CtbFil
*/ 
Static Function af060Grava( oModel, cIDMOV, cCodRel,cSeq, cLocDest, cCodBase,cItem,lMult,nFNS,nFNR,cNewItem,cTpbem,cIDMOVFNR, cLoteAtf, nHdlPrv, cArquivo, lPrim, nTotal,cFilDest,cLocOrig)
Local lRet			:= .T.
Local lGspInUseM	:= IIf(Type('lGspInUse')=='L', lGspInUse, .F.)
Local lProcura	:= .F.
Local lAchou		:= .F.
Local cPatrim		:= SN1->N1_PATRIM //No caso de contas de Capital, não vai a correção monetaria
Local lBem			:= .F.
Local lCorrecao	:= .F.
Local lDepAcum	:= .F.
Local lCorMDep	:= .F.
Local lDespDep	:= .F.
Local lLocal		:= .F.
Local lTaxaPad	:= .F.
Local lSCDP		:= GetMv("MV_ATFSCDP",.F.,.F.)
Local lCVDP		:= GetMv("MV_ATFCVDP",.F.,.F.)
Local dUltDepr 	:= GetMV("MV_ULTDEPR")
Local oModelFNS	:= oModel:GetModel("GridFNS")
Local oModelFNR	:= oModel:GetModel("GridFNR")
Local nTaxaMedia	:= nTaxaDepr
Local lNgaTfMnt	:= .T.
Local cOcorren	:= ""
Local cSN3Atu		:= ""
Local aRecSn2		:= {}
Local nPosSN3		:= 0
Local aCamposAlt	:= {}
Local cFilOrig	:= ""
Local cFilDest	:= ""
Local nX			:= 0
Local DDATATRANS := dDatabase  //Adic. por Edu em 14/06/16
Local cFilSN2		:= ""
Local nY			:= 0
Local aTiposReav	:= {}
Local cAliasQry		:= ""
Local cTypes10		:= IIF(lIsRussia,AtfNValMod({1}, "*"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - main models
Local cTypesNM		:= IIF(lIsRussia,AtfNValMod({3,4}, "*"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - 17 and 16 models
Local aTypes10		:= {}
Local nTypes10		:= 0
Local cUltSeq		:= ""
Local cTpSal		:= ''
Local cSeqReav		:= ''
Local nTaxaSNH		:= 0

Private lUsaMntAt	:= .F. //Utilizada no SIGAMNT
Private cMotivo		:= "08" //Utilizada no SIGAMNT

DEFAULT cLocOrig	:= ""
DEFAULT cFilDest	:= ""

DbSelectArea("SN1")
SN1->(DbSetOrder(1)) //N1_FILIAL+N1_CBASE+N1_ITEM
SN1->(DbSeek(XFilial("SN1")+cCodBase+cItem))

DbSelectArea("SN3")
SN3->(DbSetOrder(12))	//N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
SN3->(DbSeek(XFilial("SN3")+cCodBase+cItem+cTpBem+cSeq))

cTpSal		:= SN3->N3_TPSALDO
cSeqReav	:= SN3->N3_SEQREAV

If(!lMult)
	cCContab	:= oModelFNS:Getvalue("FNS_CONTAD")
	cCCorrec	:= oModelFNS:GetValue("FNS_CONCOD")
	cCDeprec	:= oModelFNS:Getvalue("FNS_CONDDD")
	cCCDepr		:= oModelFNS:Getvalue("FNS_CONTAD")
	cCDesp		:= oModelFNS:Getvalue("FNS_CONDAD")
	cCusto		:= oModelFNS:Getvalue("FNS_CCDESD")
	cLocAtivo	:= oModelFNR:Getvalue("FNR_LOCDES")
	cFilOrig	:= oModelFNR:GetValue("FNR_FILORI")
	cFilDest	:= oModelFNR:GetValue("FNR_FILDES")

	Af060VarCtb(oModel)

	nValor		:= Iif( cPatrim # "C" , SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1, SN3->N3_VORIG1+SN3->N3_AMPLIA1 )
	cCContab	:= IIF(cCContab == SN3->N3_CCONTAB, " " , cCContab)
	cCCorrec	:= IIF(cCCorrec == SN3->N3_CCORREC, " " , cCCorrec)
	cCDeprec	:= IIF(cCDeprec == SN3->N3_CDEPREC, " " , cCDeprec)
	cCDesp		:= IIF(cCDesp	== SN3->N3_CDESP  , " " , cCDesp  )
	cCCDepr		:= IIF(cCCDepr  == SN3->N3_CCDEPR , " " , cCCDepr )

	// Qdo da transf de local verifico se existem os tipos 02 ou 04. O local  gravado no SN1 e nao posso atualizar na transf desses tipos.
	// O local deve ser o mesmo para todos os tipos ( 01 02 04 )
	If !Empty(cLocAtivo)
		nPosSN3	:= SN3->(RECNO())
		nOrder	:= SN3->(IndexOrd())
		cBase	:= SN3->N3_CBASE
		cItem	:= SN3->N3_ITEM
		cTipo	:= SN3->N3_TIPO

		dbSelectArea("SN3")
		dbSetorder(1)

		//Tipos de reavaliação
		AAdd(aTiposReav,"02") // Reavaliacao
		AAdd(aTiposReav,"04") // Lei 8.200
		AAdd(aTiposReav,"41") // Reavaliação anual de bens não totalmente depreciados
		AAdd(aTiposReav,"42") // Reavaliação anual de bens totalmente depreciados
		AAdd(aTiposReav,"50") // Colombia: Depreciacao gerencial "metodo linear"
		AAdd(aTiposReav,"51") // Colombia: Depreciacao gerencial "soma dos digitos"
		AAdd(aTiposReav,"52") // Colombia: Depreciacao gerencial "reducao de saldos"
		AAdd(aTiposReav,"53") // Colombia: Depreciacao gerencial "soma dos anos"
		AAdd(aTiposReav,"54") // Colombia: Depreciacao gerencial "unidades produzidas"

		// Verifica se o bem tem filhos
		If cTipo $ ("01*10*16*17" + "*" + cTypes10 + "*" + cTypesNM)
			For nX := 1 to Len(aTiposReav)
				If SN3->( MSSeek(xFilial("SN3")+cBase+ cItem+aTiposReav[nX]) )
					lProcura := .T.
					Exit
				Endif
			Next nX
		ElseIf cTipo $ "02/04/41/42"
			lProcura := SN3->( MSSeek( xFilial("SN3")+ cBase + cItem + "01" ) ) .OR. SN3->( MSSeek( xFilial("SN3")+ cBase + cItem + "10" ) )
			If !lProcura
				aTypes10 := Separa(cTypes10, '*', .f.)
				For nTypes10 := 1 to len(aTypes10)
					lProcura := SN3->( MSSeek( xFilial("SN3")+ cBase + cItem + aTypes10[nTypes10] ) )
					If lProcura
						Exit
					Endif
				Next nTypes10
			Endif
		Else
			lProcura:= .F.
		EndIf
		If lProcura
			dbSelectArea("SN4")
			dbSetOrder(1)
			If (MsSeek(xFilial("SN4")+cBase+cItem))
				cChave := xFilial("SN4")+cBase+cItem
				While !Eof() .And. SN4->N4_FILIAL+SN4->N4_CBASE+SN4->N4_ITEM == cChave
					If SN4->N4_DATA == dDataTrans .And. SN4->N4_OCORR == "03"
						lAchou := .T.
						Exit
					Endif
					SN4->(DbSkip())
				EndDo
			Endif
		Endif

		dbSelectArea("SN3")
		dbSetorder(nOrder)
		dbGoto(nPosSN3)
	Endif
	// cOcorrencia 03 - transferência de
	//             04 - transferência para

	cOcorren := "03"
	For nX := 1 To 2

		// Verifica se ocorreu alteracao na conta do bem
		//DbSelectArea("SN3")
		lBem		:= nX == 2 .And. lBem
		lLocal		:= nX == 2 .And. lLocal
		lTaxaPad	:= nX == 2 .And. lTaxaPad
		lCorrecao	:= nX == 2 .And. lCorrecao
		lDepAcum	:= nX == 2 .And. lDepAcum
		lCorMDep	:= nX == 2 .And. lCorMDep
		lDespDep	:= nX == 2 .And. lDespDep

		If !lLocal .And. (cLocDest <> cLocOrig) 
			lLocal := .T.		
		ElseIf(oModelFNS:Getvalue("FNS_CCDDO") <> oModelFNS:Getvalue("FNS_CCDDD"))
			lLocal := .T.
		Endif

		If !lTaxaPad .And. (oModelFNR:GetValue("FNR_TXPADO") <> oModelFNR:GetValue("FNR_TXPADD")) 
			lTaxaPad := .T.		
		Endif

		If !lBem	.And. (	oModelFNS:Getvalue("FNS_CONTAO") <> oModelFNS:Getvalue("FNS_CONTAD");
					.Or.	oModelFNS:Getvalue("FNS_CCBEMO") <> oModelFNS:Getvalue("FNS_CCBEMD");
					.Or.	oModelFNS:Getvalue("FNS_ITBEMO") <> oModelFNS:Getvalue("FNS_ITBEMD");
					.Or.	oModelFNS:Getvalue("FNS_CVBEMO") <> oModelFNS:Getvalue("FNS_CVBEMD"))
			lBem := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da correcao monetaria
		If			(oModelFNS:Getvalue("FNS_CONCOO") <> oModelFNS:Getvalue("FNS_CONCOD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CCCORO") <> oModelFNS:Getvalue("FNS_CCCORD"));
			.Or. 	(oModelFNS:Getvalue("FNS_ITCORO") <> oModelFNS:Getvalue("FNS_ITCORD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CVCORO") <> oModelFNS:Getvalue("FNS_CVCORD"))
			lCorrecao := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da depreciacao acumulada
		If			(oModelFNS:Getvalue("FNS_CONDAO")	<> oModelFNS:Getvalue("FNS_CONDAD"));
			.Or.	(oModelFNS:Getvalue("FNS_CCDAO")	<> oModelFNS:Getvalue("FNS_CCDAD"));
			.Or.	(oModelFNS:Getvalue("FNS_ITDEAO")	<> oModelFNS:Getvalue("FNS_ITDEAD"));
			.Or.	(oModelFNS:Getvalue("FNS_CVCDEO")	<> oModelFNS:Getvalue("FNS_CVCDED"))
			lDepAcum := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da corr. monet. da deprec.
		If			(oModelFNS:Getvalue("FNS_CONCDO")	<> oModelFNS:Getvalue("FNS_CONCDD"));
			.Or.	(oModelFNS:Getvalue("FNS_CCCDO")	<> oModelFNS:Getvalue("FNS_CCCDD"));
			.Or.	(oModelFNS:Getvalue("FNS_ITCDEO")	<> oModelFNS:Getvalue("FNS_ITCDED"));
			.Or.	(oModelFNS:Getvalue("FNS_CVDESO")	<> oModelFNS:Getvalue("FNS_CVDESD"))
			lCorMDep := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da Despesa Depreciacao
		If			(oModelFNS:Getvalue("FNS_CONDDO")	<> oModelFNS:Getvalue("FNS_CONDDD"));
			.Or.	(oModelFNS:Getvalue("FNS_CCDDO")	<> oModelFNS:Getvalue("FNS_CCDDD"));
			.Or.	(oModelFNS:Getvalue("FNS_ITDEDO")	<> oModelFNS:Getvalue("FNS_ITDEDD"));
			.Or.	(oModelFNS:Getvalue("FNS_CVDEPO")	<> oModelFNS:Getvalue("FNS_CVDEPD"))
			lDespDep := .T.
		Endif

		//-----------------------------------------------------------------------------------------------------
		// ADAPTACAO PROVISORIA (A rotina precisa ser revisada para usar a FNR e FNS ao invés da SN4)
		//-----------------------------------------------------------------------------------------------------
		// Como na SN4 não há N4_TIPOCNT que registre transferencia somente do campo N3_CCUSTO será gerado o
		// N4_TIPOCNT = 3 (Despesa de Depreciacao), para que o canelamento da transferencia contábil funcione.
		// O cancelamento da transferencia já foi adequado para resgatar os dados da FNS.
		//-----------------------------------------------------------------------------------------------------
		If oModelFNS:Getvalue("FNS_CCDESO") <> oModelFNS:Getvalue("FNS_CCDESD")
			lDespDep := .T.
		EndIf

		Af060Mov(nX,cOcorren,nTaxaMedia,{lBem,lCorrecao,lDepAcum,lCorMDep,lDespDep,lLocal,lTaxaPad},@cIDMOV,, @cLoteAtf, @nHdlPrv, @cArquivo, @lPrim, @nTotal)

		If nX == 1 

			If !(SN1->N1_STATUS $ "2|3")
				DbSelectArea("SN3")
				If RecLock("SN3",.F.)

					//Conta
					SN3->N3_CCONTAB	:= oModelFNS:Getvalue("FNS_CONTAD")
					SN3->N3_CCORREC	:= oModelFNS:Getvalue("FNS_CONCOD")
					SN3->N3_CDEPREC	:= oModelFNS:Getvalue("FNS_CONDDD")
					SN3->N3_CCDEPR	:= oModelFNS:Getvalue("FNS_CONDAD")
					SN3->N3_CDESP	:= oModelFNS:Getvalue("FNS_CONCDD")

					//Centro de Custo
					SN3->N3_CCUSTO	:= oModelFNS:Getvalue("FNS_CCDESD")
					SN3->N3_CUSTBEM	:= oModelFNS:Getvalue("FNS_CCBEMD")
					SN3->N3_CCCORR	:= oModelFNS:Getvalue("FNS_CCCORD")
					SN3->N3_CCDESP	:= oModelFNS:Getvalue("FNS_CCDDD")
					SN3->N3_CCCDEP	:= oModelFNS:Getvalue("FNS_CCDAD")
					SN3->N3_CCCDES	:= oModelFNS:Getvalue("FNS_CCCDD")

					//Item
					SN3->N3_SUBCCON := oModelFNS:Getvalue("FNS_ITBEMD")
					SN3->N3_SUBCDEP := oModelFNS:Getvalue("FNS_ITDEDD")
					SN3->N3_SUBCCDE := oModelFNS:Getvalue("FNS_ITDEAD")
					SN3->N3_SUBCDES := oModelFNS:Getvalue("FNS_ITCDED")
					SN3->N3_SUBCCOR := oModelFNS:Getvalue("FNS_ITCORD")
					
					If lSCDP
						SN3->N3_SUBCTA:= oModelFNS:Getvalue("FNS_ITDEDD")
					EndIf

					//Classe de Valor
					SN3->N3_CLVLCON := oModelFNS:Getvalue("FNS_CVBEMD")
					SN3->N3_CLVLDEP := oModelFNS:Getvalue("FNS_CVDEPD")
					SN3->N3_CLVLCDE := oModelFNS:Getvalue("FNS_CVCDED")
					SN3->N3_CLVLDES := oModelFNS:Getvalue("FNS_CVDESD")
					SN3->N3_CLVLCOR := oModelFNS:Getvalue("FNS_CVCORD")

					If lCVDP
						SN3->N3_CLVL := oModelFNS:Getvalue("FNS_CVDEPD")
					EndIf

					//Local
					SN3->N3_LOCAL	:= oModelFNR:Getvalue("FNR_LOCDES")

					SN3->(MsUnlock())
				EndIf

				If !Empty(oModelFNR:Getvalue("FNR_TXPADD")) .And. oModelFNR:Getvalue("FNR_TXPADO") != oModelFNR:Getvalue("FNR_TXPADD")
					nTaxaSNH := GetAdvFval("SNH","NH_TAXA",xFilial("SNH")+oModelFNR:Getvalue("FNR_TXPADD"),1,SN3->N3_TXDEPR1) 
					RecLock("SN3",.F.)
						AtfMultMoe("SN3","N3_TXDEPR",{|x| nTaxaSNH})
					SN3->(MSUnlock())
				EndIf

			EndIf

		EndIf
		//Ajusta parametros para a segunda passagem
		cOcorren := "04"

	Next

Else
	cCContab	:= oModelFNS:Getvalue("FNS_CONTAD")
	cCCorrec	:= oModelFNS:GetValue("FNS_CONCOD")
	cCDeprec	:= oModelFNS:Getvalue("FNS_CONDDD")
	cCCDepr		:= oModelFNS:Getvalue("FNS_CONTAD")
	cCDesp		:= oModelFNS:Getvalue("FNS_CONDAD")
	cCusto		:= oModelFNS:Getvalue("FNS_CCDESD")
	cFilDest	:= oModelFNR:GetValue("FNR_FILDES")
	cLocAtivo	:= oModelFNR:Getvalue("FNR_LOCDES")
	nQtdOri		:= oModelFNR:GetValue("FNR_QTDORI")
	nQtdDes		:= oModelFNR:GetValue("FNR_QTDDES")
	nValor		:= Iif( cPatrim # "C" , SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1, SN3->N3_VORIG1+SN3->N3_AMPLIA1 )
	cCContab	:= IIf(cCContab == SN3->N3_CCONTAB, " " , cCContab)
	cCCorrec	:= IIf(cCCorrec == SN3->N3_CCORREC, " " , cCCorrec)
	cCDeprec	:= IIf(cCDeprec == SN3->N3_CDEPREC, " " , cCDeprec)
	cCDesp		:= IIf(cCDesp	== SN3->N3_CDESP  , " " , cCDesp  )
	cCCDepr		:= IIf(cCCDepr  == SN3->N3_CCDEPR , " " , cCCDepr )
	cFilOrig	:= oModelFNR:GetValue("FNR_FILORI")
	nPosSN3		:= SN3->(RECNO())

	nOrder	:= SN3->(IndexOrd())

	If(!Empty(cLocAtivo))
		dbSelectArea("SN3") 
		dbSetorder(1)
		If cTpBem $ ("01*10*16*17" + "*" + cTypes10 + "*" + cTypesNM)		//	JRJ 20170828-D
			If (SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"02")) .Or. SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"04")))
				lProcura := .T.
			Endif
		ElseIf cTpBem == "02"
			If (SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"01")) .Or. SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"04")))
				lProcura := .T.
			Endif
		ElseIf cTpBem == "04"
			If (SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"01")) .Or. SN3->(dbSeek(xFilial("SN3")+cCodBase+cItem+"01")))
				lProcura := .T.
			Endif
		Endif
		If lProcura
			dbSelectArea("SN4")
			dbSetOrder(1)
			If (SN4->(dbSeek(xFilial("SN4")+cCodBase+cItem)))
				cChave     := xFilial("SN4")+cCodBase+cItem
				While SN4->(!Eof()) .And. SN4->N4_FILIAL+SN4->N4_CBASE+SN4->N4_ITEM == cChave
					If SN4->N4_DATA == dDataTrans .Or. SN4->N4_OCORR == "03"
						SN4->(DbSkip())
						cChave :=SN4->N4_FILIAL+SN4->N4_CBASE+SN4->N4_ITEM
						Loop
					Else
						lAchou := .T.
						Exit
					Endif
				EndDo
			Endif
		Endif
		dbSelectArea("SN3")
		dbSetorder(nOrder)
		dbGoto(nPosSN3)
	EndIf

	//----------------------------------------------------------------------------------------------------------------------------------------
	// Primeiro baixo o ativo na Filial de Origem para obter o N3_SEQ que sera utilizado na geracao dos N3_OCORR 03(origem) e 04(destino)
	// Caso a baixa seja parcial (quantidade) é gerado SN3 proporcionalizado (valores) que utilizo para gerar o novo bem na filial de destino
	//----------------------------------------------------------------------------------------------------------------------------------------
	If nFNS == 1
		lRet := AFA060BX(oModel)
	EndIf

	//Esta validação foi efetuada pois a sequência a ser posicionada na baixa parcial e total precisam ser diferentes.
	//Na baixa parcial utiliza o último N3_SEQ (gerado na baixa), para ser usado nos movimentos de origem e destino na SN4
	//Na baixa total utiliza o N3_SEQ posicionado
	If nQtdOri <> nQtdDes
	
		//------------------------------------------------------------------------------------------------------------
		// Posiciona na ultima sequencia da SN3 gerada pela baixa para criar:
		// - SN3 na filial destino
		// - SN4 - 03 na filial origem
		// - SN4 - 04 na filial destino
		// Importante considerar que a baixa pode ser:
		//  - Parcial (quantidade)
		//  - Bem com dois tipos iguais (N3_TIPO) e tipo de saldo diferentes (N3_TPSALDO)
		//  - Bem com tipo (N3_TIPO) e tipo de saldo (N3_TPSALDO) iguais e N3_SEQREAV diferente - ex. duas ampliações
		//------------------------------------------------------------------------------------------------------------
		cAliasQry := GetNextAlias()
		BeginSql Alias cAliasQry
		SELECT MAX(N3_SEQ) N3_SEQ
		FROM %table:SN3% SN3
		WHERE 	SN3.N3_FILIAL	= %xfilial:SN3% AND
				SN3.N3_CBASE	= %Exp:cCodBase% AND 
				SN3.N3_ITEM		= %Exp:cItem% AND
				SN3.N3_TIPO		= %Exp:cTpBem% AND
				SN3.N3_TPSALDO	= %Exp:cTpSal% AND
				SN3.N3_SEQREAV	= %Exp:cSeqReav% AND
				SN3.%notDel%
		EndSql
	
		If (cAliasQry)->(!Eof())
			cUltSeq := (cAliasQry)->N3_SEQ
		EndIf
		(cAliasQry)->(DbCloseArea())
	
	Else
		cUltSeq	:= SN3->N3_SEQ
	Endif
	
	DBSelectArea("SN3")
	SN3->(DBSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
	SN3->(DBSeek(XFilial("SN3")+cCodBase+cItem+cTpBem+"1"+cUltSeq))

	cSN3Atu := SN3->(N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO)
	cOcorren := "03"
	For nX := 1 To 2
		// Verifica se ocorreu alteracao na conta do bem
		DbSelectArea("SN3")
		lBem		:= nX == 2 .And. lBem
		lLocal		:= nX == 2 .And. lLocal
		lTaxaPad	:= nX == 2 .And. lTaxaPad
		lCorrecao	:= nX == 2 .And. lCorrecao
		lDepAcum	:= nX == 2 .And. lDepAcum
		lCorMDep	:= nX == 2 .And. lCorMDep
		lDespDep	:= nX == 2 .And. lDespDep

		If !lBem 	.And. (	oModelFNS:Getvalue("FNS_CONTAO") <> oModelFNS:Getvalue("FNS_CONTAD");
					.Or. 	oModelFNS:Getvalue("FNS_CCBEMO") <> oModelFNS:Getvalue("FNS_CCBEMD");
					.Or. 	oModelFNS:Getvalue("FNS_ITBEMO") <> oModelFNS:Getvalue("FNS_ITBEMD");
					.Or. 	oModelFNS:Getvalue("FNS_CVBEMO") <> oModelFNS:Getvalue("FNS_CVBEMD"))
			lBem := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da correcao monetaria
		If			(oModelFNS:Getvalue("FNS_CONCOO") <> oModelFNS:Getvalue("FNS_CONCOD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CCCORO") <> oModelFNS:Getvalue("FNS_CCCORD"));
			.Or. 	(oModelFNS:Getvalue("FNS_ITCORO") <> oModelFNS:Getvalue("FNS_ITCORD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CVCORO") <> oModelFNS:Getvalue("FNS_CVCORD"))
			lCorrecao := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da depreciacao acumulada
		// Depreciacao acumulada
		If			(oModelFNS:Getvalue("FNS_CONDAO") 	<> oModelFNS:Getvalue("FNS_CONDAD"));
			.Or.	(oModelFNS:Getvalue("FNS_CCDAO") 	<> oModelFNS:Getvalue("FNS_CCDAD"));
			.Or.	(oModelFNS:Getvalue("FNS_ITDEAO")	<> oModelFNS:Getvalue("FNS_ITDEAD"));
			.Or.	(oModelFNS:Getvalue("FNS_CVCDEO") 	<> oModelFNS:Getvalue("FNS_CVCDED"))
			lDepAcum := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da corr. monet. da deprec.
		If 			(oModelFNS:Getvalue("FNS_CONCDO") 	<> oModelFNS:Getvalue("FNS_CONCDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CCCDO") 	<> oModelFNS:Getvalue("FNS_CCCDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_ITCDEO") 	<> oModelFNS:Getvalue("FNS_ITCDED"));
			.Or. 	(oModelFNS:Getvalue("FNS_CVDESO") 	<> oModelFNS:Getvalue("FNS_CVDESD"))
			lCorMDep := .T.
		Endif

		// Verifica se ocorreu alteracao na conta da Despesa Depreciacao
		If 			(oModelFNS:Getvalue("FNS_CONDDO") 	<> oModelFNS:Getvalue("FNS_CONDDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CCDDO") 	<> oModelFNS:Getvalue("FNS_CCDDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_ITDEDO") 	<> oModelFNS:Getvalue("FNS_ITDEDD"));
			.Or. 	(oModelFNS:Getvalue("FNS_CVDEPO") 	<> oModelFNS:Getvalue("FNS_CVDEPD"))
			lDespDep := .T.
		Endif

		If(nX == 1)
			dbSelectArea("ST9")
			dbSetOrder(1)
			If dbSeek( xFilial("ST9",cFilDest)+SN1->N1_CODBEM )
				If !Empty(cNewItem)
					RecLock("ST9", .F.)
					ST9->T9_CODIMOB := SN1->N1_CBASE+cNewItem
					MsUnlock("ST9")
				EndIf
			EndIf
			PcoIniLan("000368")
			aAdd(aCamposAlt,{"N3_ITEM"		,cNewItem})
			aAdd(aCamposAlt,{"N3_FILORIG"	,oModelFNR:Getvalue("FNR_FILORI")})
			aAdd(aCamposAlt,{"N3_TIPO"		,oModelFNS:Getvalue("FNS_TIPO")})
			aAdd(aCamposAlt,{"N3_ATVORIG"	,AllTrim(oModelFNR:GetValue("FNR_CBAORI")) + "|" + AllTrim(oModelFNR:GetValue("FNR_ITEORI"))})
			aAdd(aCamposAlt,{"N3_CBASE"		,oModelFNR:GetValue("FNR_CBAORI")})

			//---------------------- CONTA ---------------------------------
			aAdd(aCamposAlt,{"N3_CCONTAB"	,oModelFNS:Getvalue("FNS_CONTAD")})
			aAdd(aCamposAlt,{"N3_CCORREC"	,oModelFNS:Getvalue("FNS_CONCOD")})
			aAdd(aCamposAlt,{"N3_CDEPREC"	,oModelFNS:Getvalue("FNS_CONDDD")})
			aAdd(aCamposAlt,{"N3_CCDEPR"	,oModelFNS:Getvalue("FNS_CONDAD")})
			aAdd(aCamposAlt,{"N3_CDESP"		,oModelFNS:Getvalue("FNS_CONCDD")})

			//----------------------- Centro de Custo ----------------------
			aAdd(aCamposAlt,{"N3_CCUSTO"	,oModelFNS:Getvalue("FNS_CCDESD")})
			aAdd(aCamposAlt,{"N3_CUSTBEM"	,oModelFNS:Getvalue("FNS_CCBEMD")})
			aAdd(aCamposAlt,{"N3_CCCORR"	,oModelFNS:Getvalue("FNS_CCCORD")})
			aAdd(aCamposAlt,{"N3_CCDESP"	,oModelFNS:Getvalue("FNS_CCDDD")})
			aAdd(aCamposAlt,{"N3_CCCDEP"	,oModelFNS:Getvalue("FNS_CCDAD")})
			aAdd(aCamposAlt,{"N3_CCCDES"	,oModelFNS:Getvalue("FNS_CCCDD")})

			//------------------ITEM--------------------------------------
			aAdd(aCamposAlt,{"N3_SUBCCON"	,oModelFNS:Getvalue("FNS_ITBEMD")})
			aAdd(aCamposAlt,{"N3_SUBCDEP"	,oModelFNS:Getvalue("FNS_ITDEDD")})
			aAdd(aCamposAlt,{"N3_SUBCCDE"	,oModelFNS:Getvalue("FNS_ITDEAD")})
			aAdd(aCamposAlt,{"N3_SUBCDES"	,oModelFNS:Getvalue("FNS_ITCDED")})
			aAdd(aCamposAlt,{"N3_SUBCCOR"	,oModelFNS:Getvalue("FNS_ITCORD")})
			If lSCDP
				aAdd(aCamposAlt,{"N3_SUBCTA",oModelFNS:Getvalue("FNS_ITDEDD")})
			Else	
				aAdd(aCamposAlt,{"N3_SUBCTA",""})
			EndIf

			//---------------------- classe de valor -----------------------
			aAdd(aCamposAlt,{"N3_CLVLCON"	,oModelFNS:Getvalue("FNS_CVBEMD")})
			aAdd(aCamposAlt,{"N3_CLVLDEP"	,oModelFNS:Getvalue("FNS_CVDEPD")})
			aAdd(aCamposAlt,{"N3_CLVLCDE"	,oModelFNS:Getvalue("FNS_CVCDED")})
			aAdd(aCamposAlt,{"N3_CLVLDES"	,oModelFNS:Getvalue("FNS_CVDESD")})
			aAdd(aCamposAlt,{"N3_CLVLCOR"	,oModelFNS:Getvalue("FNS_CVCORD")})
			If lCVDP
				aAdd(aCamposAlt,{"N3_CLVL"	,oModelFNS:Getvalue("FNS_CVDEPD")})
			Else
				aAdd(aCamposAlt,{"N3_CLVL"	,""})
			EndIf

			//--------------------------------------------------------------------------------------------------
			// Como o novo SN3 tem como base o que foi baixado, ajusta os campos para que ele esteja disponivel
			//--------------------------------------------------------------------------------------------------
			Aadd(aCamposAlt,{"N3_BAIXA"		,"0"})
			Aadd(aCamposAlt,{"N3_IDBAIXA"	,""})
			Aadd(aCamposAlt,{"N3_DTBAIXA"	,SToD("")})
			Aadd(aCamposAlt,{"N3_FILORIG"	,cFilDest}) //Necessario alterar para depois de gerado, poder baixa-lo e cancelar a baixa do bem gerado na filial de destino
			Aadd(aCamposAlt,{"N3_LOCAL"		,cLocAtivo})

			If(cOcorren == "03")
				AFA060COPY("SN3", SN3->(Recno()),cFilDest, aCamposAlt)
			EndIf

			DbSelectArea("SN2")

			cFilSN2	:= xFilial("SN2")

			If(SN2->(MsSeek(cFilSN2+SN3->(N3_CBASE+N3_ITEM+N3_TIPO))))
				While SN2->(!Eof()) .And. SN2->(N2_FILIAL+N2_CBASE+N2_ITEM+N2_TIPO)==cSN3Atu
					If SN3->N3_SEQ == SN2->N2_SEQ
						Aadd(aRecSn2, SN2->(Recno()))
					EndIf
					SN2->(DbSkip())
				EndDo
			EndIf
			For nY := 1 To Len(aRecSn2)
				aAdd(aCamposAlt,{"N2_ITEM",cNewItem})
				AFA060COPY("SN2",aRecSn2[nY],cFilDest,aCamposAlt)
				aCamposAlt := {}
			Next nY
			If AFXVerRat()

				AF060Rat(SN3->N3_CODRAT, cFilOrig, cFilDest)

			EndIf
		EndIf

		//----------------------------------------------------------------------------------
		// Posiciona no ativo transferido para correta geracao dos dados na funcao AF060Mov
		//----------------------------------------------------------------------------------
		If cOcorren == "04"
			SN3->(DbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
			SN3->(DbSeek(XFilial("SN3",cFilDest)+cCodBase+cNewItem+cTpBem+"0"+cUltSeq))
			
			If !Empty(oModelFNR:Getvalue("FNR_TXPADD")) .And. oModelFNR:Getvalue("FNR_TXPADO") != oModelFNR:Getvalue("FNR_TXPADD")
				nTaxaSNH := GetAdvFval("SNH","NH_TAXA",xFilial("SNH")+oModelFNR:Getvalue("FNR_TXPADD"),1,SN3->N3_TXDEPR1) 
				RecLock("SN3",.F.)
					AtfMultMoe("SN3","N3_TXDEPR",{|x| nTaxaSNH})
				SN3->(MSUnlock())
			EndIf			
		EndIf

		Af060Mov(nX, cOcorren, nTaxaMedia,{lBem,lCorrecao,lDepAcum,lCorMDep,lDespDep,lLocal,lTaxaPad},@cIDMOV, cNewItem,nil, nil, nil, nil, nil,oModel)
		cOcorren := "04"

	Next nX

	//Restaura a posicao da SN3
	DBSelectArea("SN3")
	DBSetorder(nOrder)
	SN3->(DBGoto(nPosSN3))

EndIf

Return lRet

/*{Protheus.doc} GravaFNR
Função para incluir FNR
@author Mayara Alves
@since 03/06/2015
@version P12
@param oModelFNR - Modelo de dados da tabela FNR
*/
Static Function GravaFNR(oModelFNR)
Local aArea		:= GetArea()
Local aCposFNR	:= oModelFNR:GetStruct():GetFields()
Local nContCpo	:= 0
Local lIncReg		:= .T.

lIncReg := FNR->(DbSeek(oModelFNR:GetValue("FNR_FILIAL")+oModelFNR:GetValue("FNR_IDMOV")+oModelFNR:GetValue("FNR_CBAORI")+oModelFNR:GetValue("FNR_ITEORI")))   

Reclock( "FNR",!lIncReg )
	For nContCpo := 1 To Len(aCposFNR)
		If aCposFNR[nContCpo][3] == "FNR_FILIAL"
			FNR->FNR_FILIAL := xFilial("FNR")
		ElseIf Alltrim(aCposFNR[nContCpo][3]) == "FNR_STATUS"
			FNR->FNR_STATUS := "1"
		ElseIf !Alltrim(aCposFNR[nContCpo][3]) $ ("FNR_DESCRI|OK")
			&("FNR->"+(aCposFNR[nContCpo][3])) := oModelFNR:Getvalue(aCposFNR[nContCpo][3])
		EndIf
	Next nContCpo
FNR->(MsUnlock())

RestArea(aArea)

Return

/*{Protheus.doc} GravaFNS
Função para incluir FNS
@author Mayara Alves
@since 03/06/2015
@version P12
@param oModelFNS - Modelo de dados da tabela FNS
*/
Static Function GravaFNS(oModelFNS)
Local aArea		:= GetArea()
Local aCposFNS	:= oModelFNS:GetStruct():GetFields()
Local nContCpo	:= 0

Reclock("FNS",.T.)
	For nContCpo := 1 To Len(aCposFNS)
		If aCposFNS[nContCpo][3] == "FNS_FILIAL"
			FNS->FNS_FILIAL := xFilial("FNS")
		ElseIf !Alltrim(aCposFNS[nContCpo][3]) $("FNS_HISTOR|OK")
			&("FNS->"+(aCposFNS[nContCpo][3])) := oModelFNS:Getvalue(aCposFNS[nContCpo][3])
		EndIf
	Next nContCpo
FNS->(MsUnlock())

RestArea(aArea)

Return

/*{Protheus.doc} Af060Mov
Grava movimentacao de transferencia de acordo com o tipo de mudancas efetuadas
@author Jose Augusto Ribeiro
@since 02/06/2015
@version P12
@param nX        , Numérico , Idenfifica o tipo de registro a gravar de/para
@param cOcorren  , Caracter, Codigo de ocorrencia para gravacao no SN4
@param nTaxaMedia, Numérico , Taxa media para calculo de depreciacao
@param aGrava    , Array    , Array com logicos indicando tipos de transferencias efetuadas
@param cIDMOV    , Caracter, Identificação do movimento, passar como referencia na primeira sequencia do processo e passar o ID
@param cIDMOV    , Caracter, criado nas proximas movimentações do processo
@param cNewItem  , Caracter, Codigo do novo Item do Ativo
@return ${return}, Logico   , ${return_description}
*/
Static Function Af060Mov(nX, cOcorren, nTaxaMedia, aGrava,cIDMOV,cNewItem,cLoteAtf, nHdlPrv, cArquivo, lPrim, nTotal,oModel)
// Verificação da classificação de Ativo se sofre depreciação
Local lAtClDepr		:= .F.
Local lExclusivo	:= ADMTabExc("SN4")	 //Analisa se a tabela esta exclusiva
Local lNgmntat		:= GetMV("MV_NGMNTAT") $ "1#3"
// Controle de multiplas moedas
Local aValorMoed	:= {}
Local aValores		:= {}
Local aDadosComp	:= {}
Local __nQuantas	:= IIf(lMultMoed,AtfMoedas(),5)
Local aAtuSal		:= IIf(lMultMoed,AtfMultMoe(,,{|x| 0}), {0,0,0,0,0} )
Local nI			:= 0
Local cItemPco		:= "01"
Local lMov			:= .T.
Local aArea			:= GetArea()
Local aEntidades	:= {'','','',''}
Local cPadrao		:= ""
Local lAF060GSN4	:= ExistBlock("AF060GSN4")
Local lFilDif		:= .F.
Local cMoed			:= ""
Local lBem			:= .T.
Local lLocal		:= .T.
Local lTaxaPad		:= .T.
Local cTipoTrDe		:= ""
Local cTipoTrPara	:= ""
Local cAliasCTB		:= ""
Local oModFNS		:= Nil
Local oModFNR		:= Nil
Local cNota		:= ""
Local cSerie		:= ""
Local cFilOrig	:= ""
Local cFilDest	:= ""
Local dDataTrans	:= CTOD("")
Local cLocOrig	:= ""
Local nQtdDest	:= 0

// Verificação da classificação de Ativo se sofre depreciação
lAtClDepr	:= AtClssVer(SN1->N1_PATRIM)

Default cIDMOV		:= ""
Default cNewItem	:= "001"
Default oModel := FwModelActive()

oModFNS			:= oModel:GetModel("GridFNS")
oModFNR			:= oModel:GetModel("GridFNR")
cNota			:= oModFNR:GetValue("FNR_NOTA")
cSerie			:= oModFNR:GetValue("FNR_SERIE")
cFilOrig		:= oModFNR:GetValue("FNR_FILORI")
cFilDest		:= oModFNR:GetValue("FNR_FILDES")
dDataTrans		:= oModFNR:GetValue("FNR_DATA")
cLocOrig		:= oModFNR:GetValue("FNR_LOCORI")
nQtdDest		:= oModFNR:GetValue("FNR_QTDDES")

// Para Filial destino bem esta baixado na filial origem e podendo ainda ter novo codigo de item
If(xFilial("SN1",cFilDest) != xFilial("SN1",cFilOrig))
	cN3Item 	:= IiF(nX == 1 ,SN3->N3_ITEM	,cNewItem)
	cN3Baixa	:= IiF(nX == 1 ,SN3->N3_BAIXA	,"0")
Else
	cN3Item 	:= SN3->N3_ITEM
	cN3Baixa	:= SN3->N3_BAIXA
EndIf

// Transferencia Contábil grava n4_lp = '833'
If (xFilial("SN1",cFilDest) == xFilial("SN1",cFilOrig))
	cPadrao := "833" 
Else
	// Transferencia Fisica DE   (ORIGEM) grava n4_lp = '831'
	// Transferencia Fisica PARA (DESTINO) grava n4_lp = '832'
	If NX == 1
		cPadrao := "831"
	Else
		cPadrao := "832"
	EndIf
EndIf

// Trata contas patrimoniais
If(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM))
	cTipoTrDe  := "8"
	cTipoTrPara:= "9"
ElseIf(SN1->N1_PATRIM $ "CAS")
	cTipoTrDe  := "G"
	cTipoTrPara:= "I"
Else
	cTipotrDe  := "H"
	cTipotrPara:= "J"
EndIf

If(xFilial("SN1",cFilDest) <> xFilial("SN1",cFilOrig))
	
	lFilDif := .T.
EndIf

lBem		:= aGrava[1] .Or. lFilDif
lCorrecao	:= aGrava[2] .Or. lFilDif
lDepAcum	:= aGrava[3] .Or. lFilDif
lCorMDep	:= aGrava[4] .Or. lFilDif
lDespDep	:= aGrava[5] .Or. lFilDif
lLocal		:= aGrava[6]
lTaxaPad	:= aGrava[7]

dbSelectArea("SN4")
cFilSN4	:= xFilial("SN4")
If(lFilDif .And. nX = 2)		// Mudo a filial atual para gravacao
	cFilAnt := cFilDest			// na filial de destino
	If(!Empty(cFilDest) .and. lExclusivo)
		cFilSN4	:= xFilial("SN4",cFilDest)
	EndIf
Endif

// Utilizo as variaveis de contabilizacao pois caso nao seja alterada o conteudo
// estara em branco
cTpSaldo := SN3->N3_TPSALDO
If(lNgmntat)
	If(!Empty(SN1->N1_CODBEM))
		dbSelectArea("SN1")
		dbSetOrder(1)
		If(SN1->(dbSeek(cFilSN4 + SN3->N3_CBASE + cN3Item )))
			If(lCorrecao .Or. lDespDep)
				If(!Empty(SN1->N1_CODBEM))
					DbSelectArea("TQ2")
					dbSetOrder(1)
					If(TQ2->(DbSeek(xFilial("TQ2")+SN1->N1_CODBEM+DtoS(dDataTrans))))
						cHora := TQ2->TQ2_HORATR
					EndIf
				Else
					dbSelectArea("TPN")
					dbSetOrder(1)
					If(TPN->(DbSeek(xFilial("TPN")+SN1->N1_CODBEM+DtoS(dDataTrans))))
						While(SN1->N1_CODBEM == TPN->TPN_CODBEM)
						cHora := TPN->TPN_HRINIC
						dbSelectArea("TPN")
						dbSkip()
					End While
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
EndIf

cTpSaldo := SN3->N3_TPSALDO

aDadosComp := ATFXCompl(nTaxaMedia,SN3->N3_TXDEPR1/*nTxDepre*/,/*cMotivo*/,/*cBaixa*/,cFilOrig,cSerie,cNota,/*nVenda*/,Iif(nX == 1, cLocOrig, cLocAtivo), SN3->N3_PRODMES )

If (lCorrecao .Or. lDespDep)

	aValores   := IIf(lMultMoed, AtfMultMoe(,,{|x| 0}) , {0,0,0,0,0} )
	If(lCorrecao)

		aValores[1] := Round(SN3->N3_VRCACM1 , X3Decimal("N4_VLROC1") )

		If(cOcorren == "03")// Origem
			aEntidades[1] := oModFNS:GetValue("FNS_CONCOO")
			aEntidades[2] := oModFNS:GetValue("FNS_CCCORO")			
			aEntidades[3] := oModFNS:GetValue("FNS_ITCORO")
			aEntidades[4] := oModFNS:GetValue("FNS_CVCORO")
		Else // Destino
			aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONCOD") == "*", oModFNS:GetValue("FNS_CONCOO"), oModFNS:GetValue("FNS_CONCOD") ) /// SE DESTINO = * DESTINO=ORIGEM	
			aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCCORD") == "*", oModFNS:GetValue("FNS_CCCORO"), oModFNS:GetValue("FNS_CCCORD") ) /// SE DESTINO = * DESTINO=ORIGEM			
			aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITCORD") == "*", oModFNS:GetValue("FNS_ITCORO"), oModFNS:GetValue("FNS_ITCORD") ) /// SE DESTINO = * DESTINO=ORIGEM
			aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVCORD") == "*", oModFNS:GetValue("FNS_CVCORO"), oModFNS:GetValue("FNS_CVCORD") ) /// SE DESTINO = * DESTINO=ORIGEM
		EndIf

		ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'2',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,.T.,cPadrao)

	EndIf

	If(lDespDep)

		If(cOcorren == "03") // Origem			
			aEntidades[1] := oModFNS:GetValue("FNS_CONDDO")
			aEntidades[2] := oModFNS:GetValue("FNS_CCDDO")
			aEntidades[3] := oModFNS:GetValue("FNS_ITDEDO")
			aEntidades[4] := oModFNS:GetValue("FNS_CVDEPO")
		Else // Destino
			aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONDDD") == "*", oModFNS:GetValue("FNS_CONDDO"), oModFNS:GetValue("FNS_CONDDD"))
			aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCDDD")  == "*", oModFNS:GetValue("FNS_CCDDO") , oModFNS:GetValue("FNS_CCDDD"))
			aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITDEDD") == "*", oModFNS:GetValue("FNS_ITDEDO"), oModFNS:GetValue("FNS_ITDEDD"))
			aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVDEPD") == "*", oModFNS:GetValue("FNS_CVDEPO"), oModFNS:GetValue("FNS_CVDEPD"))
		Endif

		ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'3',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,.T.,cPadrao)

	EndIf
EndIf

If(lBem .Or. lLocal .Or. lTaxaPad )

	aValores   := AtfMultMoe(,,{|x| SN3->&("N3_VORIG"+Alltrim(Str(x)))+SN3->&(IIf(x>9,"N3_AMPLI","N3_AMPLIA")+Alltrim(Str(x))) })

	If(cOcorren == "03")// Origem
		aEntidades[1] := oModFNS:GetValue("FNS_CONTAO")		
		aEntidades[2] := oModFNS:GetValue("FNS_CCBEMO")
		aEntidades[3] := oModFNS:GetValue("FNS_ITBEMO")
		aEntidades[4] := oModFNS:GetValue("FNS_CVBEMO")
	Else // Destino
		aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONTAD") == "*", oModFNS:GetValue("FNS_CONTAO"), oModFNS:GetValue("FNS_CONTAD")) /// SE DESTINO = * DESTINO=ORIGEM	
		aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCBEMD") == "*", oModFNS:GetValue("FNS_CCBEMO"), oModFNS:GetValue("FNS_CCBEMD")) /// SE DESTINO = * DESTINO=ORIGEM
		aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITBEMD") == "*", oModFNS:GetValue("FNS_ITBEMO"), oModFNS:GetValue("FNS_ITBEMD")) /// SE DESTINO = * DESTINO=ORIGEM
		aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVBEMD") == "*", oModFNS:GetValue("FNS_CVBEMO"), oModFNS:GetValue("FNS_CVBEMD")) /// SE DESTINO = * DESTINO=ORIGEM		
	EndIf

	ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'1',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,.T.,cPadrao)

EndIf

If(lDepAcum)

	aValores   := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x)))+ IIf(x==1,SN3->N3_VRCDA1,0) })

	If(cOcorren == "03") // Origem
		aEntidades[1] := oModFNS:GetValue("FNS_CONDAO")		
		aEntidades[2] := oModFNS:GetValue("FNS_CCDAO")
		aEntidades[3] := oModFNS:GetValue("FNS_ITDEAO")
		aEntidades[4] := oModFNS:GetValue("FNS_CVCDEO")
	Else // Destino
		aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONDAD") == "*", oModFNS:GetValue("FNS_CONDAO"), oModFNS:GetValue("FNS_CONDAD"))	
		aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCDAD")  == "*", oModFNS:GetValue("FNS_CCDAO") , oModFNS:GetValue("FNS_CCDAD"))
		aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITDEAD") == "*", oModFNS:GetValue("FNS_ITDEAO"), oModFNS:GetValue("FNS_ITDEAD"))
		aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVCDED") == "*", oModFNS:GetValue("FNS_CVCDEO"), oModFNS:GetValue("FNS_CVCDED"))
	Endif

	ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'4',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,.T.,cPadrao)

EndIf

If(lCorMDep)
	aValores   := IIf(lMultMoed, AtfMultMoe(,,{|x| 0}) , {0,0,0,0,0} )
	aValores[1] := Round(SN3->N3_VRCACM1 , X3Decimal("N4_VLROC1") )

	If(cOcorren == "03") // Origem
		aEntidades[1] := oModFNS:GetValue("FNS_CONCDO")
		aEntidades[2] := oModFNS:GetValue("FNS_CCCDO")
		aEntidades[3] := oModFNS:GetValue("FNS_ITCDEO")
		aEntidades[4] := oModFNS:GetValue("FNS_CVDESO")		
	Else // Destino
		aEntidades[1] := IIf(oModFNS:GetValue("FNS_CONCDD") == "*", oModFNS:GetValue("FNS_CONCDO"), oModFNS:GetValue("FNS_CONCDD"))
		aEntidades[2] := IIf(oModFNS:GetValue("FNS_CCCDD")  == "*", oModFNS:GetValue("FNS_CCCDO") , oModFNS:GetValue("FNS_CCCDD"))
		aEntidades[3] := IIf(oModFNS:GetValue("FNS_ITCDED") == "*", oModFNS:GetValue("FNS_ITCDEO"), oModFNS:GetValue("FNS_ITCDED"))
		aEntidades[4] := IIf(oModFNS:GetValue("FNS_CVDESD") == "*", oModFNS:GetValue("FNS_CVDESO"), oModFNS:GetValue("FNS_CVDESD"))
	EndIf

	ATFXMOV(cFilSN4,@cIDMOV,dDataTrans,cOcorren,SN3->N3_CBASE,cN3Item,SN3->N3_TIPO,cN3Baixa,SN3->N3_SEQ,SN3->N3_SEQREAV,'5',nQtdDest,cTpSaldo,aEntidades,aValores,aDadosComp,/*nRecnoSN4*/,/*lComple*/,.F.,,.T.,cPadrao)

Endif

//Posiciono nas tabelas apenas para fazer o lançamento caso for transferencia para mesma filial
If(cFilOrig == cFilDest)
	//Chamado do TDI para posicionar nas Tabelas FNR e FNS para ter a filial de destino e origem nos LP's
	FNR->(DbSetOrder(1))
	FNS->(DbSetOrder(1))
	FNR->(DbSeek(xFilial("FNR",cFilOrig)+oModFnr:GetValue("FNR_IDMOV")+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")))
	FNS->(DbSeek(xFilial("FNS",cFilOrig)+oModFns:GetValue("FNS_IDMOV")+oModFns:GetValue("FNS_CODREL")+oModFns:GetValue("FNS_TIPO")+oModFns:GetValue("FNS_SEQ")))
EndIf

If cFilOrig == cFilDest	//Comparação Entre a filial cheia do destino e da origem.
	If(VerPadrao("833"))
		If( lPrim .And. (nHdlPrv <= 0))
			nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
			lPrim := .f.
		Endif
		nTotal += DetProva( nHdlPrv,"833","ATFA060",cLoteAtf)
	Endif
Endif
	
If(lCorrecao)	
	If(lMultMoed)
		aValorMoed := AtfMultMoe(,,{|x| IIf(x==1,SN3->N3_VRCACM1,0) })
	EndIf
	
	ATFXSLDCTB(SN3->N3_CCORREC, dDataTrans, IIf(nX == 1, cTipoTrDe, cTipoTrPara),SN3->N3_VRCACM1,0,0,0,0 ,"+",nTaxaMedia,SN3->N3_SUBCCOR,,SN3->N3_CLVLCOR,SN3->N3_CCCORR,"2", aValorMoed)
EndIf
	
If(lBem .Or. lLocal)		// Atualizar contas na transf de contas. Controle de multiplas moedas
	aAtuSal[1] := SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1

	For nI := 2 to __nQuantas
		cMoed := Alltrim(Str(nI))
		aAtuSal[nI]	:= SN3->&("N3_VORIG"+cMoed)+SN3->&(IIf(nI > 9,"N3_AMPLI","N3_AMPLIA")+cMoed)
	Next nI

	ATFXSLDCTB(SN3->N3_CCONTAB, dDataTrans, IIf(nX = 1, cTipoTrDe, cTipoTrPara),aAtuSal[1],aAtuSal[2],aAtuSal[3],aAtuSal[4],aAtuSal[5],"+",;
					nTaxaMedia,SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aAtuSal )
EndIf
	
If(lDepAcum)		// Controle de multiplas moedas
	If(lMultMoed)
		aValorMoed := AtfMultMoe(,,{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x))) + IIf(x=1,SN3->N3_VRCDA1,0) })
	EndIf

	ATFXSLDCTB(SN3->N3_CCDEPR , dDataTrans, IIf(nX = 1, cTipoTrDe, cTipoTrPara),SN3->(N3_VRDACM1+N3_VRCDA1),SN3->N3_VRDACM2,;
			SN3->N3_VRDACM3,SN3->N3_VRDACM4,SN3->N3_VRDACM5,"+", nTaxaMedia,SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"4",aValorMoed )
EndIf
	
If(lCorMDep) // Controle de multiplas moedas  *
	If(lMultMoed)
		aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,SN3->N3_VRCDA1,0) })
	EndIf

	ATFXSLDCTB(SN3->N3_CDESP  , dDataTrans, IIf(nX = 1, cTipoTrDe, cTipoTrPara),SN3->N3_VRCDA1,0,0,0,0 ,"+",nTaxaMedia,	SN3->N3_SUBCDES,,SN3->N3_CLVLDES,SN3->N3_CCCDES,"5", aValorMoed )
EndIf

// Lançamento no Módulo SigaPCO
lLancPco := .T.
If cFilOrig == cFilDest
	If(nX == 1)
		cItemPco := "01" // Transferencia Contábil
	Else
		lLancPco := .F.
	EndIf
ElseIf(nX == 1)
	cItemPco := "02" // Transferencia Filial - Origem
Else
	cItemPco := "03" // Transferencia  Filial - Destino
Endif

If(lLancPco)
	PcoIniLan("000368")
	PcoDetLan("000368",cItemPco,"ATFA060")
	PcoFinLan("000368")
EndIf

If(xFilial("SN1",cFilDest) <> xFilial("SN1",cFilOrig))
	cFilAnt := cFilOrig
Endif

If(mv_par01 == 1)//Contabiliza
	If cFilOrig == cFilDest
		If(NX = 1 .And. VerPadrao("830"))
			cAliasCTB := Alias()
			dbSelectArea( "SN4" )
			Af060VarCtb(oModel)
			If (lPrim .And. (nHdlPrv <= 0))
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
				lPrim := .f.
			Endif
			nTotal += DetProva( nHdlPrv,"830","ATFA060",cLoteAtf)
			dbSelectArea( cAliasCTB )
		Endif
	ElseIf(nX = 1)
		If(VerPadrao("831"))
			Af060VarCtb(oModel)
		Endif
		
		cFilAnt := cFilDest
		If(VerPadrao("832"))// FIL DESTINO
			Af060VarCtb(oModel)
		Endif
		//		cFilAnt := cFilOrig
	Endif
Endif

If(lAF060GSN4)
	ExecBlock("AF060GSN4",.F.,.F.)
EndIf

RestArea(aArea)

Return

/*{Protheus.doc} AF060CTBFIL
Função de Contabilização de Filiais Diferentes
@author Jose Augusto Ribeiro
@since 04/06/2015
@version P12
@param cLoteAtf, Caracter, Lote para contabilização do bem
@param nHdlPrv , Numérico, Handle de Contabilização
@param cArquivo, Caracter, Nome do Arquivo para contabilização
@param cOcorren, Caracter, Numero da Ocorrencia
*/
Static Function AF060CTBFIL(cLoteAtf,cArquivo,cFilOrig,cFilDest,cOcorren,nFNS,nFNR,oModel,nTotal,nHdlPrv)
	Local nLen			:= 0
	Local nAtual		:= 0
	Local lPad86A		:= VerPadrao("86A")  //Contabiliza AVP da Filial de Origem (Baixa por Transferencia)
	Local lPad86B		:= VerPadrao("86B")  //Contabiliza AVP da Filial de Destino(Constituicao por Transferencia)
	Local LanceiCtb		:= If(Type("LanceiCtb") != "L",.F.,LanceiCtb)//Controle de lancamento - Detprova]
	Local oModFns		:= oModel:GetModel("GridFNS")
	Local oModFnr		:= oModel:GetModel("GridFNR")
	Local dDataTrans	:= oModFnr:GetValue("FNR_DATA")
	Local nPosSN3  	:= 0 

	If(cOcorren == "03")
		oModFnr:GoLine(nFNR)
		oModFns:GoLine(nFNS)
		//Chamado do TDI para posicionar nas Tabelas FNR e FNS para ter a filial de destino e origem nos LP's
		FNR->(DbSetOrder(1))
		FNS->(DbSetOrder(1))
		FNR->(DbSeek(xFilial("FNR",cFilOrig)+oModFnr:GetValue("FNR_IDMOV")+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEORI")))
		FNS->(DbSeek(xFilial("FNS",cFilOrig)+oModFns:GetValue("FNS_IDMOV")+oModFns:GetValue("FNS_CODREL")+oModFns:GetValue("FNS_TIPO")+oModFns:GetValue("FNS_SEQ")))
		SN1->(Dbseek(xFilial("SN1",cFilOrig)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEORI")))
		SN3->(DbSeek(xFilial("SN3",cFilOrig)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEORI")+oModFns:GetValue("FNS_TIPO")))
		SN4->(DBSEEK( SN3->(N3_FILIAL + N3_CBASE + N3_ITEM + "01" + DTOS(dDataTrans) + "03"))) //posicionar na Movimentacao de Transferencia Para
		nTotal += DetProva( nHdlPrv,"831","ATFA060",cLoteAtf)
		If SN3->N3_TPDEPR $ "4|5|8|9|"
			//Apontamento inicial de estimativa de produção - P0
			nPosSn3 := SN3->(Recno())
			AF110GrvAp(nPosSn3,"P0")
			cPadrao := "870"		//Apontamento de estimativa de produção
			lPadrao := VerPadrao(cPadrao)
			If ValType(nHdlPrv) == "N" .And. nHdlPrv > 0 .And. lPadrao
				nTotal += DetProva(nHdlPrv,cPadrao,"ATFA060",cLoteAtf)
			EndIf
			If (SN3->N3_PRODACM > 0) .And. (SN3->N3_VRDACM1 > 0)
				//Apontamento de produção acumulada - P5
				AF110GrvAp(nPosSn3,"P5")
			EndIf
		EndIf
		//AVP
		//Contabiliza AVP - Filial de Origem
		If lPad86A
			For nAtual := 1 to Len(aAvpCtbO)
				If(nAtual = 1 .And. (nHdlPrv <= 0))
					nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
				Endif

				//Posiciono no SN1
				SN1->(dbSetOrder(1))
				SN1->(MsSeek(xFilial("SN1")+FNF->(FNF_CBASE+FNF_ITEM)))
	
				//Posiciono no SN3
				SN3->(dbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_TPSALDO
				SN3->(MsSeek(xFilial("SN1")+FNF->(FNF_CBASE+FNF_ITEM)+"14"+"1"+FNF->FNF_SEQ))
	
				//Posiciono no FNF
				FNF->(DbSetOrder(1))
				FNF->(DbSeek(xFilial("FNF")+SN3->N3_CBASE+SN3->N3_ITEM+SN3->N3_TIPO+SN3->N3_SEQ+SN3->N3_TPSALDO))
	
				nTotal += DetProva( nHdlPrv,"86A","ATFA060",cLoteAtf)
	
				//Gravo flag de contabilizacao
				If(LanceiCtb)
					RecLock("FNF")
					FNF->FNF_DTCONT  := dDatabase
					MsUnlock( )
				Endif
			Next
		Endif
		
	ElseIf(cOcorren == "04")
		oModFnr:GoLine(nFNR)
		oModFns:GoLine(nFNS)
		FNR->(DbSetOrder(1))
		FNS->(DbSetOrder(1))
		FNR->(DbSeek(xFilial("FNR",cFilOrig)+oModFnr:GetValue("FNR_IDMOV")+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")))
		FNS->(DbSeek(xFilial("FNS",cFilOrig)+oModFns:GetValue("FNS_IDMOV") + PadR(oModFns:GetValue("FNS_CODREL"),TamSx3("FNS_CODREL")[1]) + oModFns:GetValue("FNS_TIPO")+oModFns:GetValue("FNS_SEQ")))																																
		SN1->(Dbseek(xFilial("SN1",cFilDest)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")))
		SN3->(DbSeek(xFilial("SN3",cFilDest)+oModFnr:GetValue("FNR_CBADES")+oModFnr:GetValue("FNR_ITEDES")+oModFns:GetValue("FNS_TIPO")))
		SN4->(DBSEEK( SN3->(N3_FILIAL + N3_CBASE + N3_ITEM + "01" + DTOS(dDataTrans) + "04"))) //posicionar na Movimentacao de Transferencia Para

		Af060VarCtb(oModel)
		nTotal += DetProva( nHdlPrv,"832","ATFA060",cLoteAtf)

		//Contabiliza AVP - Filial de Destino
		If lPad86B
			If(nAtual = 1 .And. (nHdlPrv <= 0))
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
			Endif

			//Posiciono no SN1
			SN1->(dbSetOrder(1))
			SN1->(MsSeek(xFilial("SN1")+FNF->(FNF_CBASE+FNF_ITEM)))

			//Posiciono no SN3
			SN3->(dbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_TPSALDO
			SN3->(MsSeek(xFilial("SN1")+FNF->(FNF_CBASE+FNF_ITEM)+"14"+"0"+FNF->FNF_SEQ))

			FNF->(DbSetOrder(1))
			FNF->(DbSeek(xFilial("FNF")+SN3->N3_CBASE+SN3->N3_ITEM+SN3->N3_TIPO+SN3->N3_SEQ+SN3->N3_TPSALDO))

			nTotal += DetProva( nHdlPrv,"86B","ATFA060",cLoteAtf)
			//Gravo flag de contabilizacao
			If(LanceiCtb)
				RecLock("FNF")
				FNF->FNF_DTCONT  := dDatabase
				MsUnlock( )
			Endif

		Endif
	EndIf
Return

/*{Protheus.doc} AF060RAT
Função que Realiza a Transferencia de Rateio
@author Jose Augusto Ribeiro
@since 04/06/2015
@version P12
@param cRateio , caracter, Codigo de Rateio
*/
Static Function AF060Rat(cRateio,cFilOrig,cFilDest)
	Local aArea		:= GetArea()
	Local aAreaSN3	:= SN3->(GetArea())
	Local aAreaSNV	:= SNV->(GetArea())
	Local aAreaCT1	:= CT1->(GetArea())
	Local aAreaCTT	:= CTT->(GetArea())
	Local aAreaCTD	:= CTD->(GetArea())
	Local aAreaCTH	:= CTH->(GetArea())
	Local cFilAux	:= cFilAnt
	Local cFilRat	:= ""
	Local aCampoAlt	:= {}
	Local aNewRat	:= {}

	CT1->(dbSetOrder(1)) //CT1_FILIAL+CT1_CONTA
	CTT->(dbSetOrder(1)) //CTT_FILIAL+CTT_CUSTO
	CTD->(dbSetOrder(1)) //CTD_FILIAL+CTD_ITEM
	CTH->(dbSetOrder(1)) //CTH_FILIAL+CTH_CLVL
	SN3->(DbOrderNickName("RATEIO"))
	SNV->(DbSetOrder(1))		//NV_FILIAL+NV_CODRAT+NV_NV_REVISAO+NV_SEQUEN

	If !Empty(cRateio) .AND. SN3->(DbSeek(xFilial("SN3",cFilDest)+cRateio))

		cFilRat := cFilAnt
		cFilAnt := cFilOrig
		cRevAtu := Af011GetRev(SN3->N3_CODRAT)

		If SNV->(DbSeek(xFilial("SNV")+PadR(SN3->N3_CODRAT,TamSx3("NV_CODRAT")[1]) + PadR(cRevAtu,TamSx3("NV_REVISAO")[1])))

			aNewRat	:= Eval({|x| cFilAnt := cFilRat,x:= AF011COD(),cFilAnt := cFilOrig,x})
			aCamposAlt := {{"NV_CODRAT",aNewRat[1]},{"NV_REVISAO",aNewRat[2]}}
			While SNV->(!Eof()) .AND. xFilial("SNV") == SNV->NV_FILIAL .AND. Alltrim(SN3->N3_CODRAT+cRevAtu) == Alltrim(SNV->(NV_CODRAT+NV_REVISAO))
				AFA060COPY("SNV",SNV->(Recno()),cFilDest,aCamposAlt)
				SNV->(DbSkip())
			EndDo

			//Atualizar o status do rateio da filial antiga para baixado
			Af011AtuStatus(SN3->N3_CODRAT,cRevAtu,"4")
			cFilAnt := cFilRat

			//Verifica se as entidades do novo rateio existem na filial destino
			If SNV->(MsSeek(xFilial("SNV",cFilDest)+aNewRat[1]+aNewRat[2]))		//NV_FILIAL+NV_CODRAT+NV_REVISAO+NV_SEQUEN
				While SNV->(!EoF()) .And. (SNV->(NV_FILIAL+NV_CODRAT+NV_REVISAO) == xFilial("SNV",cFilDest)+aNewRat[1]+aNewRat[2])

					If !Empty(SNV->NV_CONTA)
						If !CT1->(MsSeek(xFilial("CT1",cFilDest)+SNV->NV_CONTA))
							__lExisEnt := .F.
							Exit
						EndIf
					EndIf
					If !Empty(SNV->NV_CC)
						If !CTT->(MsSeek(xFilial("CTT",cFilDest)+SNV->NV_CC))
							__lExisEnt := .F.
							Exit
						EndIf
					EndIf
					If !Empty(SNV->NV_ITEMCTA)
						If !CTD->(MsSeek(xFilial("CTD",cFilDest)+SNV->NV_ITEMCTA))
							__lExisEnt := .F.
							Exit
						EndIf
					EndIf
					If !Empty(SNV->NV_CLVL)
						If !CTH->(MsSeek(xFilial("CTH",cFilDest)+SNV->NV_CLVL))
							__lExisEnt := .F.
							Exit
						EndIf
					EndIf

					SNV->(dbSkip())
				EndDo
			EndIf

			//Atualizar o codigo do rateio do bem para o codigo novo do rateio para a filial nova
			RecLock("SN3",.F.)
			SN3->N3_CODRAT := aNewRat[1]
			SN3->(MsUnlock())

			If !__lExisEnt
				If SNV->(MsSeek(xFilial("SNV",cFilDest)+aNewRat[1]+aNewRat[2]))
					While SNV->(!EoF()) .And. SNV->(NV_FILIAL+NV_CODRAT+NV_REVISAO) == xFilial("SNV",cFilDest)+aNewRat[1]+aNewRat[2]
						RecLock("SNV", .F.)
						SNV->NV_MSBLQL := "1"
						MsUnlock()
						SNV->(dbSkip())
					EndDo
				EndIf
			EndIf
		Endif
	Endif

	cFilAnt := cFilAux
	RestArea(aAreaCTH)
	RestArea(aAreaCTD)
	RestArea(aAreaCTT)
	RestArea(aAreaCT1)
	RestArea(aAreaSNV)
	RestArea(aAreaSN3)
	RestArea(aArea)

Return

/*{Protheus.doc} AFA060COPY
Função que copia os dados da tabela para diferentes filiais
@author $Jose Augusto Ribeiro
@since 04/06/2015
@version P12
@param cAlias    , caracter, Tabela para ser gravado
@param nRecno    , numérico, Numero do registro a ser copiado
@param aCamposAlt, array   , Array com os campos e o conteudo para ser salvo
*/
Static Function AFA060COPY(cAlias,nRecno,cFilDest,aCamposAlt)
	Local aSaveArea	:= GetArea()
	Local cFilOrig	:= cFilAnt
	Local aArea		:= {}
	Local aCampos	:= {}
	Local nI		:= 0
	Local nJ		:= 0
	Local nY		:= 0
	Local lAlterFil	:= .F.

	Default aCamposAlt	:= {}
	Default cAlias		:= ""
	Default nRecno		:= 0

	lAlterFil := !Empty(cFilDest)

	If !Empty(cAlias) .and.  nRecno != 0
		aArea:= (cAlias)->(GetArea())
		(cAlias)->(DbGoto(nRecno))
		aAdd(aCampos,Array((cAlias)->(FCount())))

		For nI := 1 To &(cAlias)->(FCount())
			aCampos[Len(aCampos),nI] := (cAlias)->&(FieldName(nI))
		Next nI

		If lAlterFil
			cFilAnt := cFilDest
		EndIf
		For nJ := 1 to len(aCampos)
			RecLock(cAlias,.T.)
			For nI := 1 to len(aCampos[nJ])
				If "FILIAL" $ (cAlias)->(FieldName(nI))
					(cAlias)->&(FieldName(nI)) := xFilial(cAlias)
				Else
					(cAlias)->&(FieldName(nI)) := aCampos[nJ,nI]
				EndIf
			Next nI
			If !Empty(aCamposAlt)
				For nY := 1 To Len(aCamposAlt)
					If FieldPos(aCamposAlt[nY,1])>0
						(cAlias)->&(aCamposAlt[nY,1]) := aCamposAlt[nY,2]
					EndIf
				Next nY
			EndIf
			(cAlias)->(MSunlock())
		Next nJ
		(cAlias)->(RestArea(aArea))
		If lAlterFil
			cFilAnt := cFilOrig
		EndIf
	EndIf

	RestArea(aSaveArea)

Return

/*{Protheus.doc} AF060SELORC
Transfere os bens de provisao filhos do bem de orcamento
@author Jose Augusto Ribeiro
@since 05/06/2015
@version P12
@param cBaseSup, Caracter, Codigo Base do bem Superior
@param cItemSup, Caracter, Codigo Item do bem Superior
@return aRecnos, Array   , Array com os RENCNOS da SN3
*/
Static Function AF060SELORC(cBaseSup,cItemSup)
	Local cQuery		:= ""
	Local aRecnos		:= {}
	Local aArea			:= GetArea()
	Local aAreaSN1		:= SN1->(GetArea())
	Local cNextAlias	:= GetNextAlias()

	//Selecao de bens constituidos para apuracao do AVP
	//- Bens com constituicao ativa e
	//- que nao possuam movimentos posteriores a data de processamento
	cQuery := "SELECT SN3.R_E_C_N_O_ RECSN3, N3_FILIAL, N3_CBASE, N3_ITEM FROM "+RetSQLNAME("SN3") + " SN3"

	cQuery += "INNER JOIN " + RetSQLNAME('SN1') + " SN1"
	cQuery += "  ON  SN3.N3_FILIAL = SN1.N1_FILIAL AND "
	cQuery += "      SN3.N3_CBASE  = SN1.N1_CBASE  AND "
	cQuery += "      SN3.N3_ITEM   = SN1.N1_ITEM       "
	cQuery += "WHERE "
	cQuery += " SN3.N3_FILIAL = '"+xFilial("SN3")+"' AND "
	cQuery += " SN1.N1_FILIAL = '"+xFilial("SN1")+"' AND "
	cQuery += " SN1.N1_PATRIM = 'V' AND  "
	cQuery += " SN1.N1_BASESUP = '"+cBaseSup+"' AND "
	cQuery += " SN1.N1_ITEMSUP = '"+cItemSup+"' AND "
	cQuery += " SN1.N1_BAIXA = ' ' AND "
	cQuery += " SN3.N3_BAIXA = '0' AND "
	cQuery += " SN3.N3_TIPO = '14' AND "
	cQuery += " SN1.D_E_L_E_T_ = ' ' AND "
	cQuery += " SN3.D_E_L_E_T_ = ' ' "
	cQuery += " ORDER BY N3_FILIAL, N3_CBASE, N3_ITEM "

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cNextAlias,.T.,.T.)

	While(!(cNextAlias)->(Eof()))

		aAdd(aRecnos,(cNextAlias)->RECSN3)

		(cNextAlias)->(dbSkip())

	EndDo

	//Fecho o temporario
	(cNextAlias)->(dbCloseArea())

	RestArea(aAreaSN1)
	RestArea(aArea)

Return aRecnos

/*{Protheus.doc} AF060VARCTB
Função para Carregar as variaveis privadas para contabilização
@author Jose Augusto Ribeiro
@since 09/06/2015
@version P12
*/
Static Function Af060VarCtb(oModel)
	Local nPosCtb	:= 0
	Local nGets		:= 1
	Local nEntidade	:= 2
	Local oGRIDFNS	:= oModel:GetModel("GridFNS")

	//----------------
	// Conta Contabil
	//----------------
	CTABEM    := oGRIDFNS:Getvalue("FNS_CONTAD") //N3_CCONTAB - Bem
	CORREBEM  := oGRIDFNS:Getvalue("FNS_CONCOD") //N3_CCORREC - Correcao do Bem
	DESPDEPR  := oGRIDFNS:Getvalue("FNS_CONDDD") //N3_CDEPREC - Despesa de Depreciacao
	DEPREACUM := oGRIDFNS:Getvalue("FNS_CONDAD") //N3_CCDEPR  - Deprecicao Acumulada
	CORREDEPR := oGRIDFNS:Getvalue("FNS_CONCDD") //N3_CDESP   - Correcao de Depreciacao

	//-----------------
	// Centro de Custo
	//-----------------
	CUSTO      := oGRIDFNS:Getvalue("FNS_CCDESD") //N3_CCUSTO  - Despesa
	CUSTBEMCTB := oGRIDFNS:GetValue("FNS_CCBEMD") //N3_CUSTBEM - Bem
	CCCORRCTB  := oGRIDFNS:GetValue("FNS_CCCORD") //N3_CCCORR  - Correção monetária
	CCDESPCTB  := oGRIDFNS:GetValue("FNS_CCDDD")  //N3_CCDESP  - Despesa de Depreciacao
	CCCDEPCTB  := oGRIDFNS:GetValue("FNS_CCDAD")  //N3_CCCDEP  - Depreciação Acumulada
	CCCDESCTB  := oGRIDFNS:GetValue("FNS_CCCDD")  //N3_CCCDES  - Correção da Depreciação

	//---------------
	// Item Contábil
	//---------------
	SUBCCONCTB := oGRIDFNS:GetValue("FNS_ITBEMD") //N3_SUBCCON - Bem
	SUBCCORCTB := oGRIDFNS:GetValue("FNS_ITCORD") //N3_SUBCCOR - Correcao Monetaria
	SUBCDEPCTB := oGRIDFNS:GetValue("FNS_ITDEDD") //N3_SUBCDEP - Despesa Depreciacao
	SUBCCDECTB := oGRIDFNS:GetValue("FNS_ITDEAD") //N3_SUBCCDE - Depreciacao Acumulada
	SUBCDESCTB := oGRIDFNS:GetValue("FNS_ITCDED") //N3_SUBCDES - Correcao Depreciacao

	//-----------------
	// Classe de Valor
	//-----------------
	CLVLCONCTB := oGRIDFNS:GetValue("FNS_CVBEMD") //N3_CLVLCON - Bem
	CLVLCORCTB := oGRIDFNS:GetValue("FNS_CVCORD") //N3_CLVLCOR - Correção Monetaria
	CLVLDEPCTB := oGRIDFNS:GetValue("FNS_CVDEPD") //N3_CLVLDEP - Despesa de Depreciacao
	CLVLCDECTB := oGRIDFNS:GetValue("FNS_CVCDED") //N3_CLVLCDE - Depreciacao Acumulada
	CLVLDESCTB := oGRIDFNS:GetValue("FNS_CVDESD") //N3_CLVLDES - Correcao Depreciacao

Return

/*{Protheus.doc} Af060GrvOrc
Transfere os bens de provisao filhos do bem de orcamento
@author Mayara Alves
@since 08/06/2015
@version P12
@param oModel		- modelo
@param cIDMOV		- Id do movimento
@param cCodRel	- Codigo do relacionamento
@param cSeq		- Sequencia
@param cLocDes	- Local de Destino
@param cCodBase	- Codigo base
@param cItem		- Item
@param lAutomatico-Lote
@return aRecnos, Array   , Array com os RENCNOS da SN3
*/
Function Af060GrvOrc(oModel, cIDMOV, cCodRel, cSeq, cLocDes, cCodBase, cItem,lAutomatico)
	Local aRecnoSN3	:= {}
	Local nX		:= 0
	Local aArea		:= GetArea()
	Local oModel	:= FwModelActive()
	Local oModelFNR	:= oModel:GetModel('GridFNR')
	Local oModelFNS	:= oModel:GetModel('GridFNS')
	Local nTotalOrig	:= 0
	Local nTotal		:= 0 
	
	//Seleciono os registros filho do bem classificado como Orcamento
	aRecnoSN3 := Af060SelOrc(cCodBase,cItem)

	//Transfiro os Filhos
	For nX := 1 to Len(aRecnoSN3)

		dbselectArea('SN3')
		SN3->(dbSetOrder(1))
		SN3->(DBGoTo(aRecnoSn3[nX]))

		Af060VarCtb(oModel)
		If lAutomatico
			//A função Af060GrvFil virou AF060Grava
			AF060Grava(oModel, @cIDMOV, cCodRel, cSeq, cLocDes, cBaseSup, cItemSuP, lAutomatico)
		Else
			//A função Af060GrvFil virou AF060Grava
			AF060Grava(oModel, @cIDMOV, cCodRel, cSeq, cLocDes, cCodBase, cItem, lAutomatico)
		Endif

	Next

	RestArea(aArea)

Return

/*{Protheus.doc} AFA060BX
Chama o execauto do ATF036
@author Mayara Alves
@since 08/06/2015
@version P12
@param oModel		- modelo
@param cIDMOV		- Id do movimento
@param cCodRel	- Codigo do relacionamento
@param cSeq		- Sequencia
@param cLocDes	- Local de Destino
@param cCodBase	- Codigo base
@param cItem		- Item
@param lAutomatico-Lote
@return aRecnos, Array   , Array com os RENCNOS da SN3
*/
Static Function AFA060BX(oModel)
	Local aArea			:= GetArea()
	Local aAreaSN1		:= SN1->(GetArea())
	Local aAreaSN3		:= SN3->(GetArea())
	Local nCampo		:= 0
	Local __nQuantas	:= IIf(lMultMoed,AtfMoedas(),5)
	Local xAtivo		:= {}
	Local xCab			:= {}
	Local aParam		:= {}
	Local lRet			:= .T.
	Local oModelFNR 	:= oModel:GetModel('GridFNR')
	Local cFilOri		:= oModelFNR:GetValue("FNR_FILORI")
	Local nQtdOri		:= oModelFNR:GetValue("FNR_QTDORI")
	Local nQtdDes		:= oModelFNR:GetValue("FNR_QTDDES")
	Local nPerTransf	:= (nQtdDes/nQtdOri)*100

	Private lMsErroAuto	:= .F.

	cFilAnt := cFilOri

	SN3->(DbSetOrder(1))
	SN1->(DbSetOrder(1))

	aAdd( aParam, {"MV_PAR01", 2} )
	aAdd( aParam, {"MV_PAR02", 2} )
	aAdd( aParam, {"MV_PAR03", 2} )

	If SN3->(DBSeek(xFilial("SN3",cFilOri)+oModelFNR:GetValue("FNR_CBAORI")+oModelFNR:GetValue("FNR_ITEORI")))

		If SN1->(DBSeek( xFilial("SN1",cFilOri) + SN3->N3_CBASE + SN3->N3_ITEM ))

			//-------------------------------------------------------------------
			// So altera o status caso a quantidade total do bem for transferida
			//-------------------------------------------------------------------
			If nPerTransf == 100
				If !Empty(SN1->N1_FILIAL)
					RecLock("SN1",.F.)
					SN1->N1_STATUS := '4' // Transferencia entre filiais
					MsUnLock()
				Else
					RecLock("SN1",.F.)
					SN1->N1_STATUS := '1' // Transferencia entre filiais
					MsUnLock()
				EndIf	
			EndIf

			dDinDepr := SN3->N3_DINDEPR
			// Posicionar e efetuar a baixa.

			dBaixa030 := oModelFNR:GetValue("FNR_DATA")

			xCab := {	{"FN6_FILIAL"	,xFilial("SN3",cFilOri)			,NIL},;
						{"FN6_CBASE"	,SN3->N3_CBASE			,NIL},;
						{"FN6_CITEM"	,SN3->N3_ITEM			,NIL},;
						{"FN6_MOTIVO"	,"18"					,NIL},;
						{"FN6_QTDATU"	,SN1->N1_QUANTD			,NIL},;
						{"FN6_BAIXA"	,nPerTransf				,NIL},;
						{"FN6_QTDBX"	,nQtdDes				,NIL},;
						{"FN6_DTBAIX"	,dDatabase				,NIL},;
						{"FN6_PERCBX"	,nPerTransf				,NIL},;
						{"FN6_FILORI"	,SN3->N3_FILORIG		,NIL},;
						{"FN6_DEPREC"	,'0'					,NIL}}

			xAtivo := {	{"N3_FILIAL"	, xFilial("SN3")	,NIL},;
						{"N3_CBASE"		, SN3->N3_CBASE		,NIL},;
						{"N3_ITEM"		, SN3->N3_ITEM		,NIL},;
						{"N3_TIPO"		, SN3->N3_TIPO		,NIL},;
						{"N3_BAIXA"		, SN3->N3_BAIXA		,NIL},;
						{"N3_TPSALDO"	, SN3->N3_TPSALDO	,NIL} }

			MsExecAuto({|a,b,c,d|ATFA036(a,b,c,,,d)},xCab,xAtivo,3,aParam)
			If lMsErroAuto
				MostraErro()
				lRet := .F.
			Endif

		EndIf
	EndIf

	RestArea(aAreaSN3)
	RestArea(aAreaSN1)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060AutRot
Função que executa a Rotina da ExecAuto
@author Jose Augusto Ribeiro
@since 17/06/2015
@version P12
@param xAtivo, variável, Com o conteudo da ExecAuto
@param nOpcAuto, numérico, Numero da Opção desejada
@param aParam, array, Array com o conteudo do pergunte
@return ${return}, ${return_description}
*/
Static Function AF060AutRot(xAtivo,nOpcAuto,aParam)
Local aAreaSN3	:= SN3->(GetArea())
Local aAreaSN1	:= SN1->(GetArea())
Local aAreaFNS	:= FNS->(GetArea())
Local aAreaFNR	:= FNR->(GetArea())
Local aAreaFN9	:= FN9->(GetArea())
Local aArea		:= GetArea()
Local oModel	:= FwLoadModel("ATFA060")
Local oModlFNS	:= oModel:GetModel("GridFNS")
Local oModlFNR	:= oModel:GetModel("GridFNR")
Local oModlFN9	:= oModel:GetModel("FieldFN9")
Local nFNR		:= 0
Local aCampsFNR	:= {}
Local oHash		:= tHashMap():New()//Cria o Objeto do Hash Map
Local aRet		:= {}
Local lEncontro	:= .T.
Local lRet			:= .T.
Local aLog		:= ""
Local nX			:= 0
Local cVarParam	:= ""

	aAdd(aCampsFNR,{"N1_FILIAL"		,"FNR_FILDES"})
	aAdd(aCampsFNR,{"N3_CBASE"		,"FNR_CBADES"})
	aAdd(aCampsFNR,{"N1_ITEM"		,"FNR_ITEDES"})
	aAdd(aCampsFNR,{"N1_GRUPO"		,"FNR_GRPDES"})
	aAdd(aCampsFNR,{"N1_LOCAL"		,"FNR_LOCDES"})
	aAdd(aCampsFNR,{"N1_TAXAPAD"	,"FNR_TXPADD"})
	aAdd(aCampsFNR,{"N1_NFISCAL"	,"FNR_NOTA"})
	aAdd(aCampsFNR,{"N4_DATA"		,"FNS_DATA"})
	aAdd(aCampsFNR,{"N1_NSERIE"		,"FNR_SERIE"})
	aAdd(aCampsFNR,{"N3_ITEM"		,"FNR_ITEDES"})
	aAdd(aCampsFNR,{"N3_TIPO"		,"FNS_TIPO"})
	aAdd(aCampsFNR,{"N3_CCONTAB"	,"FNS_CONTAD"})
	aAdd(aCampsFNR,{"N3_CCORREC"	,"FNS_CONCOD"})
	aAdd(aCampsFNR,{"N3_CDEPREC"	,"FNS_CONDDD"})
	aAdd(aCampsFNR,{"N3_CCDEPR"		,"FNS_CONDAD"})
	aAdd(aCampsFNR,{"N3_CDESP"		,"FNS_CONCDD"})
	aAdd(aCampsFNR,{"N3_CCUSTO"		,"FNS_CCDESD"})
	aAdd(aCampsFNR,{"N3_CUSTBEM"	,"FNS_CCBEMD"})
	aAdd(aCampsFNR,{"N3_CCCORR"		,"FNS_CCCORD"})
	aAdd(aCampsFNR,{"N3_CCDESP"		,"FNS_CCDDD"})
	aAdd(aCampsFNR,{"N3_CCCDEP"		,"FNS_CCDAD"})
	aAdd(aCampsFNR,{"N3_CCCDES"		,"FNS_CCCDD"})
	aAdd(aCampsFNR,{"N3_SUBCCON"	,"FNS_ITBEMD"})
	aAdd(aCampsFNR,{"N3_SUBCDEP"	,"FNS_ITDEDD"})
	aAdd(aCampsFNR,{"N3_SUBCCDE"	,"FNS_ITDEAD"})
	aAdd(aCampsFNR,{"N3_SUBCDES"	,"FNS_ITCDED"})
	aAdd(aCampsFNR,{"N3_SUBCCOR"	,"FNS_ITCORD"})
	aAdd(aCampsFNR,{"N3_CLVLCON"	,"FNS_CVBEMD"})
	aAdd(aCampsFNR,{"N3_CLVLDEP"	,"FNS_CVDEPD"})
	aAdd(aCampsFNR,{"N3_CLVLCDE"	,"FNS_CVCDED"})
	aAdd(aCampsFNR,{"N3_CLVLDES"	,"FNS_CVDESD"})
	aAdd(aCampsFNR,{"N3_CLVLCOR"	,"FNS_CVCORD"})

	aAdd(aCampsFNR,{"N1_QUANTD"		,"FNR_QTDDES"})

	If(nOpcAuto == 3 .Or. nOpcAuto == 4 .or. nOpcAuto == 7)

		//---------------------
		// Atribuicao do Pergunte
		//---------------------
		Pergunte("AFA060", .F.)

		MV_PAR01 := If(CTBINTRAN(0,.F.),MV_PAR01,2)
		MV_PAR02 := 2

		If(aParamAuto != Nil)
			For nX := 1 to Len(aParamAuto)
				cVarParam := Alltrim(Upper(aParamAuto[nX][1]))
				If("MV_PAR" $ cVarParam)
					&(cVarParam) := aParamAuto[nX][2]
				EndIf
			Next nX
		EndIf

		//-----------------
		// Carga do modelo
		//-----------------
		oModel:SetOperation(MODEL_OPERATION_UPDATE)
		If(oModel:Activate())
			//na transferencia, posiciona no item correto do model FNS, caso tenha sido enviado o campo N3_TIPO no execauto
			If nOpcAuto == 4 .And. (nPosTipo := aScan(xAtivo, {|x|  x[1] == "N3_TIPO"})) > 0
				oModlFNS:SeekLine({{"FNS_TIPO", xAtivo[nPosTipo][2]}})
			EndIf		
			oHash :=  AToHM(aCampsFNR,1)//Converto o Vetor no Objeto Hash e indico qual sera a chave para a busca
			For nFNR := 1 To Len(xAtivo)
				lEncontro := HMGet(oHash,xAtivo[nFnr][1],@aRet)//Faz a busca da chave dentro do Objeto, ele vai retornar o logico e o vetor com a linha encontrada
				If(lEncontro)
					If(!Empty(xAtivo[nFnr][2]))
						If("N3_" $ xAtivo[nFNR][1])
							If("FNR_" $ aRet[1][2])

								oModlFNR:SetValue(aRet[1][2],xAtivo[nFNR][2])
							Else

								oModlFNS:SetValue(aRet[1][2],xAtivo[nFNR][2])

							EndIf
						ElseIf("N1_" $ xAtivo[nFNR][1])
							If aRet[1][2] == "FNR_SERIE" .And. FwIsInCallStack("ATFA126") 
								oModlFNR:LoadValue(aRet[1][2],xAtivo[nFNR][2])
							Else
								oModlFNR:SetValue(aRet[1][2],xAtivo[nFNR][2])
							EndIf	

						ElseIf("N4_" $ xAtivo[nFNR][1])

							oModlFNS:LoadValue(aRet[1][2],xAtivo[nFNR][2])
							oModlFNR:LoadValue("FNR_DATA",xAtivo[nFNR][2])
							oModlFN9:LoadValue("FN9_DATA",xAtivo[nFNR][2])

						ElseIf(xAtivo[nFNR][1] == "FNR_GERNF")

							oModlFNR:SetValue(xAtivo[nFNR][1],xAtivo[nFNR][2])

						EndIf
					EndIf
				EndIf
				If(!oModel:VldData())

					Exit

				EndIf
			Next nFNR
		EndIf
		If(oModel:VldData())

			oModel:CommitData()

		Else
			cLog := oModel:GetErrorMessage()[3]
			cLog += '--' + oModel:GetErrorMessage()[5]
			cLog += '--' + oModel:GetErrorMessage()[6]
			cLog += '--' + oModel:GetErrorMessage()[7]
			lMsErroAuto := .T.
			AutoGRLog(cLog)
			lRet := .F.
		EndIf
		oModel:DeActivate()
		oModel:Destroy()
		oModel := Nil
		oHash:Clean()

	EndIf
	RestArea(aAreaSN3)
	RestArea(aAreaSN1)
	RestArea(aAreaFN9)
	RestArea(aAreaFNR)
	RestArea(aAreaFNS)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060VldNF
Valida as premissas para geração da NF
@author Totvs
@since 18/06/2015
@version P12
@param lGerNF		,Logico, parametro para saber se valida a nota
@return lRet		,Logico, .T. para validado e .F. para nao validado
*/
Function AF060VldNF()
	Local aArea		:= GetArea()
	Local lRet		:= .T.
	Local cProduto	:= ""
	Local cFilDes	:= ""
	Local cBase		:= ""
	Local cItem		:= ""
	Local cCampo	:= ReadVar()
	Local lFN9		:= "FN9" $ cCampo 
	Local lFNR		:=	"FNR" $ cCampo
	Local lGerNF	:= &(cCampo) == "1"

	If lGerNF
		//----------------------------------------------------
		// Verifica se a filial origem possui CNPJ informado
		//----------------------------------------------------
		If lRet .And. Empty(SM0->M0_CGC)
			lRet := .F.
			Help( "", 1, "AF060VldNF", , STR0135,1, 0 ) //"A filial de origem não possui CNPJ cadastrado, impossibilitando a geração da NF."
		EndIf

		//-------------------------------------------------------
		// Valida se a de filial origem e destino sao diferentes
		//-------------------------------------------------------
		If lRet
			If lFN9 .And. cFilAnt == M->FN9_FILDES
				lRet := .F.
			ElseIf lFNR .And. FWFldGet('FNR_FILORI') == FWFldGet('FNR_FILDES')
				lRet := .F.
			EndIf

			If !lRet
				lRet := .F.
				Help( "", 1, "AF060VldNF", ,STR0155,1, 0 ) //"A filial de destino deve ser alterada para geracao da Nota Fiscal"
			EndIf

		EndIf
		If lRet

			cBase := FWFldGet('FNR_CBAORI')
			cItem := FWFldGet('FNR_ITEORI')

			//---------------------------------------------------
			// Verifica se o ativo esta relacionado a um produto
			//---------------------------------------------------
			If lRet .And. Empty(cProduto := GetAdvFVal("SN1","N1_PRODUTO",XFilial("SN1")+cBase+cItem,1,"") )
				lRet := .F.
				Help( "", 1, "AF060VldNF", , STR0136,1, 0 )//"O ativo não possui produto relacionado no seu cadastro, impossibilitando a geração da NF."
			EndIf

			//-----------------------------------------------------------------------
			// Verifica se o produto relacionado ao ativo existe na filial de origem
			//-----------------------------------------------------------------------
			If lRet .And. Empty(GetAdvFVal("SB1","B1_COD",XFilial("SB1")+cProduto,1,""))
				lRet := .F.
				Help( "", 1, "AF060VldNF", , STR0137,1, 0 ) //"O produto relacionado ao ativo não existe na filial de origem, impossibilitando a geração da NF."
			EndIf

			//-----------------------------------------------------------------------
			// Verifica se o produto relacionado ao ativo existe na filial de destino
			//-----------------------------------------------------------------------
			If lRet
				cFilDes := FWFldGet('FNR_FILDES')
				If Empty(GetAdvFVal("SB1","B1_COD",XFilial("SB1",cFilDes)+cProduto,1,""))
					lRet := .F.
					Help( "", 1, "AF060VldNF", , STR0138,1, 0 )//"O produto relacionado ao ativo não existe na filial de destino, impossibilitando a geração da NF."
				EndIf
			EndIf

		EndIf
	EndIf

	RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060VTES
Valida a TES de entrada na filial destino
@author Totvs
@since 18/06/2015
@version P12
@return lRet		,Logico, .T. para validado e .F. para nao validado
*/
Function AF060VTES()
	Local aArea		:= GetArea()
	Local aAreaSF4	:= SF4->(GetArea())
	Local lRet		:= .T.
	Local cCampo	:= ReadVar()
	Local cTes		:= &(cCampo)
	Local cFilDes	:= If("FN9"$cCampo,M->FN9_FILDES,FWFldGet("FNR_FILDES"))

	//-----------------------------------------------
	// Verifica se a TES existe na filial de destino
	//-----------------------------------------------
	If !Empty(cTes)
		If "TESSAI" $ cCampo
			DbSelectArea("SF4")
			SF4->(DbSetOrder(1))
			If SF4->(DbSeek(XFilial("SF4")+cTes))

				If lRet .And. SF4->F4_ESTOQUE != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0139,1,0) //"A TES de saida informada esta com a propriedade de atualização de estoque como 'SIM'."

				ElseIf lRet .And. SF4->F4_DUPLIC != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0140,1,0) //"A TES de saida informada esta com a propriedade de atualização de duplicata  como 'SIM'."

				ElseIf lRet .And. SF4->F4_ATUATF != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0141,1,0)//"A TES de saida informada esta com a propriedade de atualização de atualiza ativo fixo  como 'SIM'."

				ElseIf lRet .And. SF4->F4_TIPO $ 'E'
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0142,1,0) //"A TES informada é de entrada, por favor informar a TES de saída."

				EndIf
			Else
				lRet := .F.
				Help(" ",1, "AF060VTES",,STR0143,1,0) //"A TES de saida informada não existe na filial de origem."
			EndIf

		ElseIf "TESENT" $ cCampo
			DbSelectArea("SF4")
			SF4->(DbSetOrder(1))
			If SF4->(DbSeek(XFilial("SF4",cFilDes)+cTes))

				If lRet .And. SF4->F4_ESTOQUE != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0144,1,0) //"A TES de entrada informada esta com a propriedade de atualização de estoque como SIM"

				ElseIf lRet .And. SF4->F4_DUPLIC != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0145,1,0) //"A TES de entrada informada esta com a propriedade de atualização de duplicata  como SIM"

				ElseIf lRet .And.SF4->F4_ATUATF != "N"
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0146,1,0) //"A TES de entrada informada esta com a propriedade de atualização de atualiza ativo fixo  como SIM"

				ElseIf lRet .And. Val(SF4->F4_CODIGO) >= 501
					lRet := .F.
					Help(" ",1, "AF060VTES",,STR0147,1,0) //"A TES informada é de saída, por favor informar a TES de entrada."

				EndIf

			Else
				lRet := .F.
				Help(" ",1, "AF060VTES",,STR0148,1,0) //"A TES de entrada informada não existe na filial de destino."
			EndIf

		EndIf
	Endif

	RestArea(aAreaSF4)
	RestArea(aArea)

Return lRet

/*{Protheus.doc} AFA060NFS
Gera a Nota Fiscal de Saida na filial de origem
@author TOTVS
@since 18/06/2015
@version P12
@return cNotaFeita,Caracter, Numero da Nota Criada
*/
Static Function AFA060NFS(oModel)
	Local aArea			:= GetArea()
	Local aAreaSA1		:= SA1->(GetArea())
	Local aAreaSB1		:= SB1->(GetArea())
	Local aAreaSF4		:= SF4->(GetArea())
	Local cFilOri		:= oModel:GetValue("GridFNR","FNR_FILORI")
	Local cFilDes		:= oModel:GetValue("GridFNR","FNR_FILDES")
	Local cSerie		:= oModel:GetValue("GridFNR","FNR_SERIE")
	Local cTESSaida		:= oModel:GetValue("GridFNR","FNR_TESSAI")
	Local cCNPJ			:= GetAdvFVal("SM0","M0_CGC",cEmpAnt + cFilDes)
	Local cCliente		:= GetAdvFVal("SA1","A1_COD",XFilial("SA1")+cCNPJ,3) //A1_FILIAL+A1_CGC
	Local cLoja			:= GetAdvFVal("SA1","A1_LOJA",XFilial("SA1")+cCNPJ,3) //A1_FILIAL+A1_CGC
	Local cBase			:= oModel:GetValue("GridFNR","FNR_CBAORI")
	Local cItem			:= oModel:GetValue("GridFNR","FNR_ITEORI")
	Local cProduto		:= GetAdvFVal("SN1","N1_PRODUTO",XFilial("SN1")+cBase+cItem,1) //N1_FILIAL+N1_CBASE+N1_ITEM
	Local nQtdBx		:= oModel:GetValue("GridFNR","FNR_QTDDES")
	Local nValNF		:= oModel:GetValue("GridFNR","FNR_VALNF")
	Local dBaixa		:=  oModel:GetValue('FieldFN9','FN9_DATA')
	Local cNotaFeita	:= ""
	Local aCabec		:= {}
	Local aItens		:= {}
	Local nI			:= 0
	Local aStruSD2		:= {}
	Local aStruSF2		:= {}
	Local aSF2RecNo		:= {}
	Local lContabOn		:= .T.
	Local lMostraLan	:= .T.
	Local lAglutLan		:= .T.
	Local lRet			:= .T.

	SaveInter()

	Pergunte("AFA060",.F.)

	//Variaveis para contabilizacao
	lContabOn	:= MV_PAR01 == 1
	lMostraLan	:= MV_PAR02 == 1
	lAglutLan	:= MV_PAR03 == 1

	If QtdComp( nValNF, .T. ) == QtdComp( 0, .T. )
		nValNF := 1
	EndIf

	aStruSD2 := SD2->(dbStruct())
	aStruSF2 := SF2->(dbStruct())
	aItens := {{}}
	aCabec := {}

	SA1->(MsSeek(xFilial("SA1") + cCliente + cLoja))
	For nI := 1 to len(aStruSF2)
		Do Case
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_FILIAL'
			Aadd(aCabec,xFilial("SF2"))					// Filial
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_CLIENTE'
			Aadd(aCabec,cCliente)						// Cliente
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_LOJA'
			Aadd(aCabec,cLoja)							// Loja
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_CLIENT'
			Aadd(aCabec,cCliente)						// Cliente
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_LOJENT'
			Aadd(aCabec,cLoja)							// Loja
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_TIPO'
			Aadd(aCabec,"N")							// Tipo (Normal)
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_TIPOCLI'
			Aadd(aCabec,SA1->A1_PESSOA)					// Tipo de cliente (F=Pessoa Fisica; J=Pessoa Juridica)
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_EMISSAO'
			Aadd(aCabec,dBaixa)							// Data de emissao
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_HORA'
			Aadd(aCabec,SubStr(Time(),1,5))				// Hora do processamento
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_EST'
			Aadd(aCabec,SA1->A1_EST)					// Estado
		Case ALLTRIM(aStruSF2[nI,1]) == 'F2_NEXTDOC'
			Aadd(aCabec,"      ")						// Proximo docto
		Otherwise
			Aadd( aCabec, CriaVar(aStruSF2[nI,1]) )
		EndCase
	Next

	SB1->(MsSeek(xFilial("SB1") + cProduto))
	SF4->(MsSeek(xFilial("SF4") + cTESSaida))
	For nI := 1 to Len(aStruSD2)
		Do Case
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_FILIAL'
			Aadd( aItens[1],xFilial("SD2"))						// Filial
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_ITEM'
			Aadd( aItens[1],StrZero(1,TamSX3("D2_ITEM")[1]))	// Item
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_COD'
			Aadd( aItens[1],cProduto)							// Produto
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_UM'
			Aadd( aItens[1],SB1->B1_UM)							// Unidade de medida
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_QUANT'
			Aadd( aItens[1],nQtdBx)								// Quantidade
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_PRCVEN'
			Aadd( aItens[1],nValNF/nQtdBx) 						// Preco unitario
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_TOTAL'
			Aadd( aItens[1], nValNF)			 				// Valor total do item
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_TES'
			Aadd( aItens[1],cTESSaida)							// TES
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_CF'
			Aadd( aItens[1], SF4->F4_CF)						// Codigo Fiscal
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_DESCON'
			Aadd( aItens[1],0)									// Desconto
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_PEDIDO'
			Aadd( aItens[1],' ')								// Pedido de Venda
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_CLIENTE'
			Aadd( aItens[1],cCliente)							// Cliente
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_LOJA'
			Aadd(aItens[1],cLoja)								// Loja
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_TP'
			Aadd(aItens[1],SB1->B1_TIPO)						// Tp Produto
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_EMISSAO'
			Aadd(aItens[1],dBaixa)								// Emissao
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_PRUNIT'
			Aadd( aItens[1], nValNF/nQtdBx)	 					// Valor unitario do item
		Case ALLTRIM(aStruSD2[nI,1]) == 'D2_TIPO'
			Aadd(aItens[1],"N")									// Tipo
		Otherwise
			Aadd(aItens[1],CriaVar(aStruSD2[nI,1]) ) 				// demais campo da estrutura da tabela SD2 necessarios na criacao da nota fiscal sem pedido de vendas
		EndCase
	Next nI

	aSF2RecNo	:= {0}
	cNotaFeita	:= MaNfs2Nfs(,,cCliente,cLoja,cSerie,lMostraLan,lAglutLan,lContabOn,,,,,,,,,,{|| .T.},aSF2RecNo,aItens,aCabec,.F.,{|| .T.},,{|| .T.})

	If !Empty(cNotaFeita)
		oModel:SetValue("GridFNR","FNR_NOTA",cNotaFeita)		
	Else
		lRet := .F.

		oModel:SetErrorMessage("","","","","AFA060NFS",STR0149 + cBase + STR0165 + cItem,"") //"Não foi possível gerar a Nota Fiscal de Saída para o bem: "###"Item: "

	EndIf

	RestInter()

	RestArea(aAreaSF4)
	RestArea(aAreaSB1)
	RestArea(aAreaSA1)
	RestArea(aArea)

Return(lRet)

/*{Protheus.doc} AFA060NFE
Gera a Nota Fiscal de Entrada na filial de destino
@author TOTVS
@since 18/06/2015
@version P12
@param cNFSaida, caracter, Numero da Nota Fisca de Saida
*/
Static Function AFA060NFE(oModel,cNFSaida)
	Local aArea		:= GetArea()
	Local aCabec		:= {}
	Local aItens		:= {}
	Local cFilOri		:= oModel:GetValue("GridFNR","FNR_FILORI")
	Local cFilDes		:= oModel:GetValue("GridFNR","FNR_FILDES")
	Local cTESEntrad	:= oModel:GetValue("GridFNR","FNR_TESENT")
	Local cBase		:= oModel:GetValue("GridFNR","FNR_CBAORI")	
	Local cItem		:= oModel:GetValue("GridFNR","FNR_ITEORI")
	Local dMovimento	:= oModel:GetValue('FieldFN9','FN9_DATA')
	Local cCNPJCli		:=  GetAdvFVal("SM0","M0_CGC",cEmpAnt + cFilDes)
	Local cCliente		:= GetAdvFVal("SA1","A1_COD",XFilial("SA1")+cCNPJCli,3) //A1_FILIAL+A1_CGC
	Local cLoja		:= GetAdvFVal("SA1","A1_LOJA",XFilial("SA1")+cCNPJCli,3) //A1_FILIAL+A1_CGC
	Local cCNPJFor		:= SM0->M0_CGC
	Local cFornece		:= GetAdvFVal("SA2","A2_COD",XFilial("SA2",cFilDes)+cCNPJFor,3) //A2_FILIAL+A2_CGC
	Local cLojaFornece	:= GetAdvFVal("SA2","A2_LOJA",XFilial("SA2",cFilDes)+cCNPJFor,3) //A2_FILIAL+A2_CGC
	Local cLocalDes		:= oModel:GetValue("GridFNR","FNR_LOCDES")
	Local nClasNF		:= oModel:GetValue("GridFNR","FNR_CLSNF")
	Local lMostraErro	:= .F.
	Local aParam103		:= {}
	Local nItem		:= 0
	Local cSerie		:= oModel:GetValue("GridFNR","FNR_SERIE")
	Local lRet		:= .T. 
	Local aAreaSM0		:= SM0->(GetArea())
	
	Private lMsErroAuto	:= .F.
	// Variavel utilizada para verificar 1se o numero da nota foi alterado pelo usuario (notas de saida e entrada
	// com formulario proprio).
	Private lMudouNum	:= .F.
	// Variavel utilizada para tratamento especifico para poder de terceiros
	Private l310PODER3	:= .F. //Utilizado no MATA103

	SaveInter()

	Aadd(aParam103,{"MV_PAR01",2,Nil})

	DbSelectArea("SD2")
	SD2->(DbSetOrder(3))
	If SD2->( DbSeek( xFilial("SD2") + PadR( cNFSaida, TamSX3("D2_DOC")[1] ) + cSerie + cCliente + cLoja ) )
		// Cabecalho da nota fiscal de entrada
		Aadd(aCabec,{"F1_TIPO"		,"N"})
		Aadd(aCabec,{"F1_FORMUL"	,"N"})
		Aadd(aCabec,{"F1_DOC"		,cNFSaida})
		Aadd(aCabec,{"F1_SERIE"		,cSerie})
		Aadd(aCabec,{"F1_EMISSAO"	,dMovimento})
		Aadd(aCabec,{"F1_FORNECE"	,cFornece})
		Aadd(aCabec,{"F1_LOJA"	 	,cLojaFornece})
		Aadd(aCabec,{"F1_ESPECIE"	,"NFE"})
		Aadd(aCabec,{"F1_EST"		,""})
		Aadd(aCabec,{"F1_ORIGEM","ATFA060"})
		// Itens da nota fiscal de entrada
		While SD2->(!Eof()) .And. xFilial("SD2") + PadR( cNFSaida, TamSX3("D2_DOC")[1] ) + cSerie + cCliente + cLoja == SD2->(D2_FILIAL + D2_DOC + D2_SERIE + D2_CLIENTE + D2_LOJA)
			aLinha   := {}
			cProdRef := SD2->D2_COD
			nItem++
			Aadd(aLinha,{"D1_ITEM"	,StrZero(nItem,4)	,Nil})
			Aadd(aLinha,{"D1_COD"	,SD2->D2_COD		,Nil})
			Aadd(aLinha,{"D1_QUANT"	,SD2->D2_QUANT		,Nil})
			Aadd(aLinha,{"D1_VUNIT"	,SD2->D2_PRCVEN		,Nil})
			Aadd(aLinha,{"D1_TOTAL"	,SD2->D2_TOTAL		,Nil})
			Aadd(aLinha,{"D1_TES"	,cTESEntrad			,Nil})

			// Checa geracao de documento
			If nClasNF == "2"
				// Checa se utiliza rastreabilidade
				If Rastro(SD2->D2_COD,"L")
					Aadd(aLinha,{"D1_LOTECTL", SD2->D2_LOTECTL, Nil})
					Aadd(aLinha,{"D1_DTVALID", SD2->D2_DTVALID, Nil})
				EndIf
				If Rastro(SD2->D2_COD,"S")
					Aadd(aLinha,{"D1_NUMLOTE", SD2->D2_NUMLOTE, Nil})
					Aadd(aLinha,{"D1_DTVALID", SD2->D2_DTVALID, Nil})
				EndIf
			EndIf
			Aadd(aLinha,{"D1_ORIGEM", "ATFA060", Nil})
			
			Aadd(aItens,aLinha)
		SD2->(DbSkip())
		EndDo
		// Caso tenha itens e cabecalho definidos
		If Len(aItens) > 0 .And. Len(aCabec) > 0
			// Atualiza para a filial destino
			cFilant := cFilDes
			// Reinicializa ambiente para o fiscal
			If MaFisFound()
				MaFisEnd()
			EndIf
			// Checa geracao de documento
			lMsErroAuto := .F.
			If nClasNF == "2"
				MSExecAuto( { |x, y, z, p| MATA103(x, y, z,,,,p) }, aCabec,aItens,3,aParam103 ) //Inclusao
			Else
				// Inclui pre-nota
				MSExecAuto( { |x, y, z| MATA140(x, y, z) }, aCabec,aItens,3 ) //Inclusao
			EndIf
			// Checa erro de rotina automatica
			If lMsErroAuto
				lMostraErro	:=.T.
				lRet		:= .F.
			EndIf
			
		EndIf
	EndIf

	// Mostra erro em rotina automatica
	If lMostraErro

		oModel:SetErrorMessage("","","","","AFA060NFE",STR0181 + cBase + STR0165 + cItem,"") //"Não foi possível gerar a Nota Fiscal de Entrada para o bem: "###"Item: "

		Mostraerro()
		
	Else

		cFilant := cFilOri			
	 
	EndIf

	RestInter()

	RestArea(aArea)
	RestArea(aAreaSM0)

Return(lRet)

/*{Protheus.doc} AF060PE
Função de Ponto de Entrada que efetua o Gatilho
@author Jose Augusto Ribeiro
@since 17/06/2015
@version P12
@param cCampo, caracter,Campo que foi chamada a Função
*/
Static Function AF060PE(cCampo)
Local lAF060GAT	:= ExistBlock("AF060GAT")
Local aValue	:= {}
Local nI		:= 0
Local oModel	:= FwModelActivete()
Local oModelFNS	:= oModel:GetModel("GridFNS")
Local aCposFNS	:= oModelFNS:GetStruct():GetFields()
Local oHash		:= tHashMap():New()//Cria o Objeto do Hash Map
Local aVetPE	:= {}
Local aRet		:= {}
Local nFns 		:= 0
Local nAvet		:= 0

If(lAF060GAT)
	For nI := 1 to Len(aCposFNS)
		If(aCposFNS[nI][3] = "FNS_CONTAD,FNS_CONCOD,FNS_CONDDD,FNS_CONDAD,FNS_CONCDD,FNS_CCBEMD,FNS_CCCORD,FNS_CCDAD,FNS_CCCDD,FNS_CCDDD" + ;
								"FNS_ITBEMD,FNS_ITCORD,FNS_ITDEDD,FNS_ITDEAD,FNS_ITCDED,FNS_CVBEMD,FNS_CVCORD,FNS_CVDEPD,FNS_CVCDED,FNS_CVDESD")

			aAdd(aVetPE,{aCposFNS[nI][3],oModelFNS:GetValue(aCposFNS[nI][3])})

		EndIf
	Next nI
	aValue := Execblock("AF060GAT",.F.,.F., {cCampo,oModelFNS:GetValue(cCampo),aVetPE})
	If(ValType(aValue) == "A") .AND. !Empty(aValue)
		For nAvet := 1 To Len(aValue)
			For nFns := 1 To Len(aCposFNS)
				If aValue[nAvet][1] == aCposFNS[nFns][3]
					oModelFNS:SetValue(aCposFNS[nFns][3],aValue[nAvet][2])
					Exit
				Endif
			Next
		Next
	EndIf
EndIf

Return

/*{Protheus.doc} AF060CaTra
Realiza o cancelamento da transferencia entre filiais
@Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060CaTra(cAlias, nReg, nOpc,lAutomato)
Local aArea		:= GetArea()
Local aAlias	:= {}
Local oDlgMrk	:= Nil
Local aColumns	:= {}
Local cTrbMark	:= {}
Local aRotOld	:= aClone(aRotina)
Local lRet		:= .T.

Default lAutomato := .F.

SetFunName('ATFA060C')

aRotina := {} 

If lRet
	If Pergunte("AFA060C",Iif(IsBlind(),.F.,.T.))
		//Retorna as colunas para o preenchimento da FWMarkBrowse
		aAlias		:= AF060ExcQr()
		cAliasMrk	:= aAlias[1]
		aColumns 	:= aAlias[2]
		If !(cAliasMrk)->(Eof())
			
			//Criação da MarkBrowse no Layer LISTA_DAC
			oMrkBrowse:= FWMarkBrowse():New()
			oMrkBrowse:SetFieldMark("N3_OK")
			oMrkBrowse:SetOwner(oDlgMrk)
			oMrkBrowse:SetAlias(cAliasMrk)
			oMrkBrowse:bMark    := {|| AF060Mark(cAliasMrk )}
			oMrkBrowse:bAllMark := {|| AF060Inverte(cAliasMrk) }
			oMrkBrowse:SetDescription(STR0005 + " - " + STR0169) //"Transferencia de Ativos"###"Cancelar"
			oMrkBrowse:SetColumns(aColumns)
			oMrkBrowse:SetMenuDef("")
			oMrkBrowse:AddButton(STR0091, {||AF060ExeCa(1)},0, 3) //"Canc. Transf."
			
			If  !lAutomato
				oMrkBrowse:Activate()
			Else
				//---------------------------------------------------------------------------
				// Reposiciona o índice, pois ele perde a referencia na execução automática
				//---------------------------------------------------------------------------
				( cAliasMrk )->( DbSetOrder( 1 ) )
				
				//posiciona na SN3			
				oMrkBrowse:cMark := GetMark()
				
				AF060Mark( cAliasMrk, lAutomato )
				
				AF060ExeCa(1,lAutomato)
				
			EndIf
			
		Else
			
			Help(" ",1,"AF060RECNO",,STR0111,1,0 ) //'Não foram localizados ativos passiveis de cancelamento da transferência'
			
		EndIf
		If(!Empty (cAliasMrk))
			dbSelectArea(cAliasMrk)
			(cAliasMrk)->(dbCloseArea())
			cAliasMrk := ""
			dbSelectArea("SN3")
			SN3->(dBSetOrder(1))
		EndIf

		//Deleta tabela temporaria criada no banco de dados
		If _oATFA0601 <> Nil
			_oATFA0601:Delete()
			_oATFA0601 := Nil
		Endif
		
	EndIf
Endif

SetFunName('ATFA060')

RestArea(aArea)
aRotina := aClone(aRotOld)
cCadastro	:= STR0005	// "Transferência de Ativos para chamar a função da legenda

Return Nil

/*{Protheus.doc} AF060Mark
Marcacao de um registro
@author Totvs
@since 28/10/2013
@version 1.0
*/
Function AF060Mark(cAliasTRB, lAutomato)
Local lRet		:= .F.  
Local cMarca	:= oMrkBrowse:cMark
Local nLinha	:= oMrkBrowse:At()
Local cChvSN1
Local aSN1Area	:= SN1->(GetArea())
Local aSN3Area	:= SN3->(GetArea())
Local nAliasRec	:= (cAliasTRB)->RECNOSN3 	

Default lAutomato	 := .F.

If lAutomato
 	cMarca :=  oMrkBrowse:cMark
 	(cAliasTRB)->N3_OK := cMarca
 	
EndIf    

SN1->(DbGoto((cAliasTRB)->RECNOSN1))
SN3->(DbGoto((cAliasTRB)->RECNOSN3))

cChvSN1 := SN1->(N1_FILIAL+N1_CBASE+N1_ITEM)

If SN3->(MsRLock()) .AND. (cAliasTRB)->(MsRLock())
	
	//Verifica se pode deletar
	lRet := AF060VExc(.T.)
	
	//A FWMarkBrowse() ja traz o registro com a marca quando bMark
	//Caso a exclusao não seja permitida, desmarca registro
	IF	!lRet .and. (cAliasTRB)->N3_OK == cMarca
		(cAliasTRB)->N3_OK := "  "
		(cAliasTRB)->(MsUnlock())
		SN3->(MsUnlock())
		
		//Caso tenha desmarcado registro selecionado anteriormente
		//a FWMarkBrowse() ja traz o registro sem a marca quando bMark.
		//Entao destravamos o mesmo para uso de outro terminal
	ElseIf Empty( (cAliasTRB)->N3_OK )
				
		If (cAliasTRB)->(dbSeek(cChvSN1))
			While cChvSN1 == (cAliasTRB)->(N3_FILIAL+N3_CBASE+N3_ITEM) .And. (cAliasTRB)->(!Eof())
				RecLock(cAliasTRB, .F.)
				(cAliasTRB)->N3_OK := "  "
				MsUnlock()
				(cAliasTRB)->(DbSkip())
			End
		EndIf
		(cAliasTRB)->(DbGoTo(nAliasRec))
		
	EndIf
	
	If lRet
		
		//No cancelamento realizo a marcação automática dos outros itens referentes ao ativo.Uma vez que, o cancelamento
		//deve ser realizado sempre em sua totalidade. (Marcando todos os itens)
		If !Empty((cAliasTRB)->N3_OK)
			If (cAliasTRB)->(dbSeek(cChvSN1))
				While cChvSN1 == (cAliasTRB)->(N3_FILIAL+N3_CBASE+N3_ITEM) .And. (cAliasTRB)->(!Eof())
					RecLock(cAliasTRB, .F.)
					(cAliasTRB)->N3_OK := cMarca
					MsUnlock()
					(cAliasTRB)->(DbSkip())
				End
			EndIf
		EndIf
		(cAliasTRB)->(DbGoTo(nAliasRec))
		
	EndIf
	
Else
	lRet := .F.
EndIf

RestArea(aSN1Area)
RestArea(aSN3Area)

If !lAutomato
	oMrkBrowse:Goto(nLinha,.T.)
EndIf

Return lRet

/*{Protheus.doc} AF060Inverte
Marcacao de vários registros
@author Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060Inverte(cAliasTRB)
Local nReg		:= (cAliasTRB)->(Recno())
Local cMarca	:= oMrkBrowse:cMark

DbSelectArea(cAliasTRB)
DbGoTop() 

While !(cAliasTRB)->(Eof())
	SN1->(dbGoto((cAliasTRB)->RECNOSN1))
	SN3->(dbGoto((cAliasTRB)->RECNOSN3))
	If SN3->(MsRLock()) .AND. (cAliasTRB)->(MsRLock())
		If AF060VExc(.F.) 
			IF	(cAliasTRB)->N3_OK == cMarca
				(cAliasTRB)->N3_OK := "  "
				(cAliasTRB)->(MsUnlock())
				SN3->(MsUnlock())
			Else
				(cAliasTRB)->N3_OK := cMarca
			Endif
	    Endif
	Endif
	(cAliasTRB)->(dbSkip())
Enddo

(cAliasTRB)->(dbGoto(nReg))

oMrkBrowse:oBrowse:Refresh(.t.)

Return .T.

/*{Protheus.doc} AF060ExcQr
@author Jose Augusto Ribeiro
@since 18/06/2015
@version P12
@return ,Array, Array contendo o Alias temporario do arquivo e as colunas do Browse
*/
Static Function AF060ExcQr()
Local aArea		:= GetArea()
Local aStru		:= SN3->(DbStruct())
Local aColumns	:= {} //Array com as colunas a serem apresentadas
Local aRestrict	:= {}
Local nX		:= 0
Local cArqTrab	:= ""
Local cCodIni	:= MV_PAR01
Local cCodFim	:= MV_PAR03
Local cItemIni	:= MV_PAR02
Local cItemFim	:= MV_PAR04
Local cGrupoIni	:= MV_PAR05
Local cGrupoFim	:= MV_PAR06
Local cDataIni	:= DToS(FirstDay(dDataBase))
Local cDataFim	:= DToS(LastDay(dDataBase))
Local cQuery	:= ""

	cQuery += "SELECT "
	cQuery += " SN3.N3_FILIAL,SN3.N3_CBASE,SN3.N3_ITEM,SN3.N3_TIPO,SN3.N3_AQUISIC,SN3.N3_HISTOR,SN3.N3_OK, SN3.R_E_C_N_O_ RECNOSN3 , "
	cQuery += " SN1.N1_FILIAL, SN1.N1_GRUPO, SN1.N1_PATRIM, SN1.N1_CBASE, SN1.N1_ITEM, SN1.N1_QUANTD, SN1.N1_AQUISIC, SN1.N1_BAIXA, SN1.N1_OK, SN1.R_E_C_N_O_ RECNOSN1 "
	cQuery += " FROM " +	RetSqlName("SN1") + " SN1 "
	cQuery +=			" INNER JOIN "+RetSQLName("SN3")+" SN3 ON "
	cQuery +=			" SN3.N3_FILIAL  = SN1.N1_FILIAL AND "
	cQuery +=			" SN3.N3_CBASE   = SN1.N1_CBASE  AND "
	cQuery +=			" SN3.N3_ITEM    = SN1.N1_ITEM  "
	cQuery +=			" INNER JOIN "+RetSQLName("SN4")+" SN4 ON "
	cQuery +=			" SN4.N4_FILIAL  = SN3.N3_FILIAL AND "
	cQuery +=			" SN4.N4_CBASE   = SN3.N3_CBASE  AND "
	cQuery +=			" SN4.N4_ITEM    = SN3.N3_ITEM AND "
	cQuery +=			" SN4.N4_TIPO    = SN3.N3_TIPO AND "	
	cQuery +=			" SN4.N4_SEQREAV = SN3.N3_SEQREAV AND "
	cQuery +=			" SN4.N4_TPSALDO = SN3.N3_TPSALDO "
	cQuery += " WHERE SN1.N1_FILIAL = '" + XFilial("SN1")	+ "' "
	cQuery += " AND SN1.N1_CBASE	Between '"	+ cCodIni  	+ "' AND '" + cCodFim	+ "' "
	cQuery += " AND SN1.N1_ITEM		Between '"	+ cItemIni 	+ "' AND '" + cItemFim	+ "' "
	cQuery += " AND SN1.N1_GRUPO	Between '"	+ cGrupoIni	+ "' AND '" + cGrupoFim	+ "' "
	cQuery += " AND SN1.N1_BAIXA	= ' ' "
	cQuery += " AND SN1.N1_STATUS	= '1' "
	cQuery += " AND SN4.N4_DATA	Between '"	+ cDataIni		+ "' AND '" + cDataFim	+ "' "
	cQuery += " AND SN4.N4_OCORR = '04'  "
	If MV_PAR09 == 1 //Cancelamento de transferencia entre filiais
		cQuery += 	" AND SN4.N4_FILORIG <> SN4.N4_FILIAL   " //Tratamento para cancelamento do último tipo de transferencia Fiscal/Contabil
	ElseIf MV_PAR09 == 2 //Cancelamento de transferencia contabil
		cQuery += 	" AND SN4.N4_FILORIG = '" + XFilial("SN1")	+ "' " //Tratamento para cancelamento do último tipo de transferencia Fiscal/Contabil
	EndIF
	If lIsRussia
		cFiltro += " AND SN3.N3_OPER = '1' " // CAZARINI - 21.01.2017 - Asset Into Operation?
	Endif
	cQuery += " AND SN1.D_E_L_E_T_	= ' ' "
	cQuery += " AND SN3.D_E_L_E_T_	= ' ' "
	cQuery += " AND SN4.D_E_L_E_T_	= ' ' "

	//Ignora ativos que possuam movimento diferentes da aquisição e transferência

	cQuery += " AND NOT EXISTS ( SELECT N4_CBASE FROM " + RetSqlName("SN4") + " SN42 "
	cQuery +=                  " WHERE SN42.N4_FILIAL = '" + XFilial("SN4")+ "' "
	cQuery +=                        " AND SN42.N4_CBASE = SN1.N1_CBASE "
	cQuery +=                        " AND SN42.N4_ITEM  = SN1.N1_ITEM "
	If MV_PAR09 == 1 //Cancelamento de transferencia entre filiais
		cQuery +=                    " AND SN42.N4_OCORR NOT IN ('04','05') "
	ElseIf MV_PAR09 == 2 //Cancelamento de transferencia contabil
		cQuery +=                    " AND SN42.N4_DATA	Between '" + cDataIni + "' AND '" + cDataFim + "' "
		cQuery +=                    " AND SN42.N4_OCORR NOT IN ('03','04','05','13') "
	EndIf
	cQuery +=                        " AND SN42.D_E_L_E_T_ = ' ' )"

	cQuery += " GROUP BY SN3.N3_FILIAL,SN3.N3_CBASE,SN3.N3_ITEM,SN3.N3_TIPO,SN3.N3_AQUISIC,SN3.N3_HISTOR,SN3.N3_OK, SN3.R_E_C_N_O_ , SN1.N1_FILIAL, SN1.N1_GRUPO, SN1.N1_PATRIM, SN1.N1_CBASE, SN1.N1_ITEM, SN1.N1_QUANTD, SN1.N1_AQUISIC, SN1.N1_BAIXA, SN1.N1_OK, SN1.R_E_C_N_O_ "
	cQuery += " ORDER BY SN3.N3_FILIAL,SN3.N3_CBASE,SN3.N3_ITEM,SN3.N3_TIPO "

	cQuery := ChangeQuery(cQuery)

	cChave		:= SN3->(IndexKey())
	Aadd(aStru, {"RECNOSN1","N",10,0})
	Aadd(aStru, {"RECNOSN3","N",10,0})

	If _oATFA0601 <> Nil
		_oATFA0601:Delete()
		_oATFA0601 := Nil
	Endif

	cArqTrab := GetNextAlias()

	_oATFA0601 := FWTemporaryTable():New( cArqTrab )
	_oATFA0601:SetFields(aStru)
	_oATFA0601:AddIndex("1", {"N3_FILIAL","N3_CBASE","N3_ITEM","N3_TIPO","N3_BAIXA","N3_SEQ"})

	//------------------
	//Criação da tabela temporaria
	//------------------
	_oATFA0601:Create()

	Processa({||SqlToTrb(cQuery, aStru, cArqTrab)})	// Cria arquivo temporario

	DbSetOrder(0) // Fica na ordem da query

	//Define as colunas a serem apresentadas na markbrowse
	For nX := 1 To Len(aStru)
		If	aStru[nX][1] $ "N3_CBASE|N3_ITEM|N3_TIPO|N3_AQUISIC|N3_HISTOR"
			AAdd(aColumns,FWBrwColumn():New())
			aColumns[Len(aColumns)]:SetData( &("{||"+aStru[nX][1]+"}") )
			aColumns[Len(aColumns)]:SetTitle(RetTitle(aStru[nX][1])) 
			aColumns[Len(aColumns)]:SetSize(aStru[nX][3])
			aColumns[Len(aColumns)]:SetDecimal(aStru[nX][4])
			aColumns[Len(aColumns)]:SetPicture(PesqPict("SN3",aStru[nX][1]))
		EndIf
	Next nX

	RestArea(aArea)

Return({cArqTrab,aColumns})

//-------------------------------------------------------------------
/*/{Protheus.doc} AF060ExeCa
Executa o cancelamento de transferência (filial ou contábil) dos
imobilizados selecionados
@author Totvs
@since 08/07/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function AF060ExeCa(nOpcao, lAutomato)
Local aArea			:= GetArea()
Local cFilFNR		:= ""
Local cFilDes		:= cFilAnt
Local cBkpFilDes	:= cFilDes
Local cFilOri		:= ""
Local cAtvOri		:= ""
Local cCodBemOri	:= ""
Local cCodItOri		:= ""
Local lIntMNT		:= GetMV("MV_NGMNTAT") $ "1#3"
Local cSubProc		:= "ATFA060"+ "CANTRF"
Local cIdCV8			:= ""
Local cMensIni		:= ""
Local cTipTransf	:= 0 //1=Filial/2=Contabil
Local cBase			:= ""
Local cItem			:= ""
Local lLP8A1		:= VerPadrao("8A1")
Local lLP83A		:= VerPadrao("83A")
Local lLP83B		:= VerPadrao("83B")
Local lMostrLanc	:= .F.
Local lAglutLanc	:= .F.
Local lFNRExcl		:= FWModeAccess("FNR",3) == "E"
Local cLogErro		:= ""
Local cArquivo		:= ""
Local cLoteAtf		:= LoteCont("ATF")
Local lPrim			:= .T.
Local nHdlPrv		:= 0
Local nTotal		:= 0
Local dDataTrMnt	:= cHoraTrMnt := ""
Local aDadosMnt		:= {}
Local cIdMovFNR	:= ""
Local lExistNF	:= .F.
Local cFilOrig	:= ""
Local cNota		:= ""
Local cSerie		:= ""
Local lAf060Vlc := ExistBlock("AF060VLC")
Local lCont     := .T.
Local cChavAux	:= ""
Local lDtCAnt		:= .T.

//Acrescentado em 15/08/2018 - DSERCTR1-13130
Local lCanceled 	:= .t.
Local lAF060CAC		:= ExistBlock("AF060CAC")

Local cMensIniPE	:= ""
Local cLogErroPE	:= ""

Default lAutomato := .F.

If lAf060Vlc 
	lCont := ExecBlock("AF060VLC",.F.,.F.,{nOpcao, cLoteAtf}) 
EndIf

If lCont .And. nOpcao == 1 

	Pergunte("AFA060C",.F.)

	lMostrLanc	:= MV_PAR07 == 1
	lAglutLanc	:= MV_PAR08 == 1
	cTipTransf	:= MV_PAR09

	(cAliasMrk)->(dbGoTop())
	
	cSubProc	:= STR0090  //"Canc. Transf." 
	ProcLogIni( {},__cProcPrinc,cSubProc,@cIdCV8 )

	While (cAliasMrk)->(!Eof())

		If ((cAliasMrk)->N3_OK == oMrkBrowse:cMark) .And. ( cTipTransf == 2 .Or. (cAliasMrk)->(N3_CBASE+N3_ITEM) <> cBase + cItem )

			cBase	:= (cAliasMrk)->(N3_CBASE)
			cItem	:= (cAliasMrk)->(N3_ITEM)

			SN1->(DbGoto((cAliasMrk)->RECNOSN1))
			SN3->(DbGoto((cAliasMrk)->RECNOSN3))
			
			lDtCAnt := AF060VldDt(cBase,cItem,.F.)

			cMensIni:= STR0093 + AllTrim(SN3->N3_CBASE) + STR0081 + AllTrim(SN3->N3_ITEM) + "." //"Canc. Transf. Bem:"###" item: "

			ProcLogAtu( STR0094 , cMensIni ,,,.T. ) //"INICIO"

			BEGIN TRANSACTION

				//---------------------------------------------
				// Cancelamento da transferencia entre filiais
				//---------------------------------------------
				If cTipTransf == 1
					
					If !lDtCAnt

						cLogErro += STR0195 // Localizada transferência com data posterior a data base do sistema.
						DisarmTransaction()

						lCanceled := .F.
						
						Break

					EndIf				

					//Obtem o ID da ultima transferencia do bem, possibilitando obter os dados da NF, se gerada
					If cChavAux <> SN1->(N1_CBASE+N1_ITEM)
						cIdMovFNR  := AF060IDFNR(SN1->(N1_CBASE), SN1->(N1_ITEM), @cFilFNR, cTipTransf)
						cChavAux := SN1->(N1_CBASE+N1_ITEM)
					EndIf
					
					DbSelectArea("FNR")
					FNR->(DbSetOrder(2)) //FNR_FILIAL+FNR_IDMOV+FNR_CBADES+FNR_ITEDES
					If FNR->(DbSeek(iIf (lFNRExcl .and. !Empty(cFilFNR),cFilFNR,FwXFilial("FNR"))+ cIdMovFNR + SN1->(N1_CBASE)+ SN1->(N1_ITEM)))
						lExistNF	:= FNR->FNR_GERNF == "1"
						cFilOrig	:= FNR->FNR_FILORI
						cNota		:= FNR->FNR_NOTA
						cSerie		:= FNR->FNR_SERIE
						cCodBemOri	:= FNR->FNR_CBAORI
						cCodItOri	:= FNR->FNR_ITEORI
					EndIf

					//-----------------------------------------------------------
					// Realiza a contabilização do cancelamento da transferência
					// Exclui a Nota Fiscal de Entrada (se houver)
					// Exclui o ativo na filial destino
					//-----------------------------------------------------------
					If AF060ExcAu(SN1->N1_CBASE, SN1->N1_ITEM,lMostrLanc,lAglutLanc,lLP8A1,lExistNF,cFilOrig,cNota,cSerie)

						//-------------------------------------------
						// Cancela a baixa do ativo na filial origem
						//-------------------------------------------
						cFilAnt := cFilOrig

						If !AF060Canc(cCodBemOri,cCodItOri,lMostrLanc,lAglutLanc,@cLogErro,lExistNF,cNota,cSerie)
						
							cLogErro += STR0097 //"Não foi possivel cancelar a baixa na filial origem."
							DisarmTransaction()
						
							lCanceled := .F.
						
							Break
						
						EndIf

						cFilAnt := cFilDes

					Else
						
						cLogErro := STR0099 //"Não foi possivel excluir o bem na filial destino."
						DisarmTransaction()

						lCanceled := .F.
						
						Break

					EndIf

				//----------------------------------------
				// Cancelamento da transferencia contabil
				//----------------------------------------
				ElseIf cTipTransf == 2

					If !lDtCAnt
						cLogErro += STR0195 // Localizada transferência com data posterior a data base do sistema.
						DisarmTransaction()

						lCanceled := .F.

						Break

					EndIf 
				
					//Obtem o ID da ultima transferencia do bem, possibilitando obter os dados da NF, se gerada
					If cChavAux <> SN1->(N1_CBASE+N1_ITEM)
						cIdMovFNR := AF060IDFNR(SN1->(N1_CBASE), SN1->(N1_ITEM),,cTipTransf )
						cChavAux  := SN1->(N1_CBASE+N1_ITEM)

						//-----------------------
						// Restaura dados da SN1
						//-----------------------
						DBSelectArea("FNR")
						FNR->(DBSetOrder(1))
						If !Empty(cIdMovFNR) .And. FNR->(DBSeek(XFilial("FNR")+cIdMovFNR+(cAliasMrk)->(N3_CBASE+N3_ITEM)))
							RecLock("SN1",.F.)
								SN1->N1_GRUPO	:= FNR->FNR_GRPORI
								SN1->N1_TAXAPAD	:= FNR->FNR_TXPADO
								SN1->N1_LOCAL	:= FNR->FNR_LOCORI
							SN1->(MSUnlock())

							If FNR->FNR_LOCORI <> FNR->FNR_LOCDES
								A060BLQLOC(FNR->FNR_LOCORI,SN1->N1_CBASE,SN1->N1_ITEM)
							EndIf

						EndIf
					EndIf

					A060CanCtb(lLP83A,@cArquivo,@cLoteAtf,@lPrim,@nHdlPrv,@nTotal,,lLP83B,cIdMovFNR)
					
				EndIf

				//---------------------------------
				// Atualiza o status da tabela FNR
				//---------------------------------
				DbSelectArea("FNR")
				FNR->(DbSetOrder(2))
				If FNR->(DbSeek(iIf (lFNRExcl .and. !Empty(cFilFNR),cFilFNR,FwXFilial("FNR"))+ cIdMovFNR + SN1->(N1_CBASE)+ SN1->(N1_ITEM)))
					RecLock("FNR")
					FNR->FNR_STATUS := '2' //Transferêcia Cancelada
					FNR->(MsUnlock())
				EndIf

			END TRANSACTION

			//Ponto de Entrada após a efetivação do cancelamento da Transferência
			//Acrescentado em 15/08/2018 - DSERCTR1-13130
			If ( lCanceled .And. lAF060CAC )
				
				cLogErroPE := Execblock("AF060CAC",.F.,.F.,{cIdMovFNR})

				If ( !Empty(cLogErroPE) )
					cMensIniPE := STR0035	//"Cancel. Efetuado. Mas há erros na execução do P.E AF060CAC."
					ProcLogAtu("ALERTA",cMensIniPE,cLogErroPE,,.T. )
				EndIf	

			EndIf	

			//----------------------------------------
			// Gera o Log de erro fora da transaction
			//----------------------------------------
			If !Empty(cLogErro)
				ProcLogAtu(STR0095,cMensIni,cLogErro,,.T. ) //"ERRO"
			EndIf

			ProcLogAtu(STR0100,cMensIni,,,.T.) //"FIM"

		EndIf

	(cAliasMrk)->(DbSkip())
	EndDo 

	//------------------------------------------------
	// Contabilização da Transferência Contabil (83A)
	//------------------------------------------------
	If nHdlPrv > 0 .And. nTotal > 0
		RodaProva(nHdlPrv,nTotal)
		cA100Incl(cArquivo,nHdlPrv,2,cLoteAtf,lMostrLanc,lAglutLanc )
	Endif
	
	If !lAutomato
		ProcLogView(cFilAnt,__cProcPrinc,cSubProc,cIdCV8)
	EndIf
EndIf

MBrChgLoop(.F.) //Desabilita a chamada da tela de inclusão novamente.

If !lAutomato
	oMrkBrowse:GetOwner():End()
EndIf
RestArea(aArea)

Return .T.

/*{Protheus.doc} AF060VExc
Valida a possibilidade de se excluir um imobilizado
@author Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060VExc(lHelp,lLote)
Local aArea		:= GetArea()
Local lRet		:= .T.

Default lHelp	:= .T.
Default lLote	:= .T.

//Não Altera bens Bloqueados
If SN1->N1_STATUS $ '2/3'
	Help(" ",1,"AF010BLOQ") //"Este bem está bloqueado. Bens bloqueados não podem ser alterados/excluidos."
	lRet := .F.
EndIf

If lRet .and. SN1->N1_FILIAL != xFilial("SN1")
	If lHelp
		HELP(" ",1,"A000FI") //"Código da Filial não esta correto."
	Endif
	lRet  := .F.
	xRet := .T.
Endif

//Verificacao de possibilidade de deleção
If lRet .and. !AF012AVLDL("SN3",,lHelp)
	lRet  := .F.
EndIf

RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060ExcAu
Rotina automatica para exclusao dos imobilizados selecionados
@author Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060ExcAu(cCBase,cItem,lMostrLanc,lAglutLanc,lLP8A1,lExistNF,cFilOrig,cNota,cSerie)
Local aArea		:= GetArea()
Local aCab		:= {}
Local aItens	:= {}
Local aParam	:= {}
Local nY		:= 0
Local lRet		:= .T.
Local aLog		:= {}

//Variaveis para contabilizacao
Local cArquivo	:= ""
Local cLoteAtf	:= LoteCont("ATF")
Local lPrim		:= .T.
Local nHdlPrv	:= 0
Local nTotal	:= 0

//Controle de rotina automatica
Private lMsErroAuto		:= .F. //Determina se houve algum tipo de erro durante a execucao do ExecAuto
Private lMsHelpAuto		:= .T. //Define se mostra ou não os erros na tela (T= Nao mostra; F=Mostra)
Private lAutoErrNoFile	:= .F. //Habilita a gravacao de erro da rotina automatica

Default lMostrLanc	:= .F.
Default lAglutLanc	:= .F.
Default lLP8A1		:= .F.
Default lExistNF		:= .F.
Default cFilOrig		:= ""
Default cNota			:= ""
Default cSerie		:= ""

//------------------------------------
// Exclusao da Nota Fiscal de Entrada
//------------------------------------
If lExistNF
	lRet := AF060ExNFE(cFilOrig,cNota,cSerie)
EndIf

If lRet
	//--------------------------------------------------------------------------------------
	// Inserido tratamento na rotina (AF010ADLAT) para nao contabilizar a exclusao quando o 
	// processo for chamado e contabilizado pelo cancelamento da transferencia - Destino(8A1)
	//---------------------------------------------------------------------------------------
	Aadd( aParam, {"MV_PAR01", 2} ) //Mostra Lanc Contab
	Aadd( aParam, {"MV_PAR02", 2} ) //Repete Chapa
	Aadd( aParam, {"MV_PAR03", 2} ) //Descrição Estendida

	Aadd(aCab,{"N1_CBASE"	,cCBase	,NIL})
	Aadd(aCab,{"N1_ITEM"	,cItem	,NIL})

	//---------------------------------------------------------------------
	// Posiciona nos registros da tabela SN3 para contabilização dos dados
	//---------------------------------------------------------------------
	DbSelectArea("SN3")
	SN3->(DbSetOrder(1))
	If lLP8A1 .And. SN3->(DbSeek(XFilial("SN3")+cCBase+cItem))
		While XFilial("SN3")+cCBase+cItem == SN3->(N3_FILIAL+N3_CBASE+N3_ITEM)

			If lPrim .And. (nHdlPrv <= 0)
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
				lPrim := .F.
			Endif

			nTotal += DetProva( nHdlPrv,"8A1","ATFA060",cLoteAtf)

		SN3->(DbSkip())
		EndDo
	EndIf

	MSExecAuto({|x,y,z,w| Atfa012(x,y,z,w)},aCab,aItens,5,aParam)

	If lMsErroAuto
		lMsErroAuto := .F.
		DisarmTransaction()
		lRet := .F.

		cFileLog := NomeAutoLog()
		cPath := ""
		If !Empty(cFileLog) .And. !lRet
			MostraErro(cPath,cFileLog)
		EndIf
	Else
		//-------------------------------------------------------------------------------
		// Contabilização do Cancelamento Transferência Destino (8A1)
		//-------------------------------------------------------------------------------
		If nHdlPrv > 0 .And. nTotal > 0
			RodaProva(nHdlPrv,nTotal)
			cA100Incl(cArquivo,nHdlPrv,2,cLoteAtf,lMostrLanc,lAglutLanc )
		Endif
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*{Protheus.doc} AF060Canc
Processa o cancelamento da baixa por transferência na filial de origem
@Totvs
@since 08/07/2014
@version 1.0
*/
Function AF060Canc(cBaseSup, cItemSup,lMostrLanc,lAglutLanc,cLogErro,lExistNF,cNota,cSerie) 
Local aArea		:= GetArea()
Local aAreaSN1	:= SN1->(GetArea())
Local aAreaSN3	:= SN3->(GetArea())
Local aAreaSN4	:= SN4->(GetArea())
Local lRet		:= .T.
Local cQuery	:= ""
Local nX		:= 0
Local aRecnos	:= {}
Local aParam036	:= {}
Local aLog		:= {}
Local aCab		:= {}
Local cRotBaixa	:= AllTrim(GetNewPar("MV_ATFRTBX", "ATFA030"))
Local cModAnt	:= .F.
Local aBaixa	:={}

//Variaveis para contabilizacao
Local cArquivo	:= ""
Local cLoteAtf	:= LoteCont("ATF")
Local lPrim		:= .T.
Local nHdlPrv	:= 0
Local nTotal	:= 0
Local lLP8A0	:= VerPadrao("8A0")

//Controle de rotina automatica
Private lMsErroAuto		:= .F. //Determina se houve algum tipo de erro durante a execucao do ExecAuto
Private lMsHelpAuto		:= .T. //Define se mostra ou não os erros na tela (T= Nao mostra; F=Mostra)
Private lAutoErrNoFile	:= .F. //Habilita a gravacao de erro da rotina automatica

Default cBaseSup	:= ""
Default cItemSup	:= ""
Default lMostrLanc	:= .F.
Default lAglutLanc	:= .F.
Default cLogErro	:= ""

//--------------------------------------------------------
// Exclusao da Nota Fiscal de Saida na Filial Originadora
//--------------------------------------------------------
If lExistNF
	lRet := AF060ExNFS(cNota,cSerie)
EndIf

If lRet
	//--------------------------------------------------------------
	// Inserido tratamento para nao contabilizar o cancelamento.
	// Será contabilizado o cancelamento da transferencia - Origem (8A0)
	//--------------------------------------------------------------
	Aadd( aParam036, {"MV_PAR01", 3}) //Mostra lancamentos contabeis (1=Sim;2=Nao;3=Nao Contabiliza)
	Aadd( aParam036, {"MV_PAR02", 2}) //Aglutina (1=Sim;2=Nao)
	Aadd( aParam036, {"MV_PAR03", 2}) //Online (1=Sim;2=Nao)
	Aadd( aParam036, {"MV_PAR04", 1}) //Visualização (1=Baixas;2=Tipos de Ativo)
	
	If Empty(cBaseSup) .Or. Empty(cItemSup)
		lRet := .F.
		cLogErro := STR0101//"Erro na obtenção dos dados do ativo a ser cancelado." 
	Endif
	
	If lRet
	
		If SN1->(MsSeek( XFilial("SN1") + cBaseSup + cItemSup )) .And. SN3->(MsSeek( xFilial("SN3") + cBaseSup + cItemSup ))
	
			aCab :={	{"FN6_FILIAL"	,XFilial("SN3")	,NIL},;
						{"FN6_CBASE"	,SN3->N3_CBASE	,NIL},;
						{"FN6_CITEM"	,SN3->N3_ITEM	,NIL},;
						{"FN6_MOTIVO"	,"08"			,NIL},;
						{"FN6_DEPREC"	,'0'			,NIL} }
	
			aAtivo :={	{"N3_FILIAL"	,XFilial("SN3")	,NIL},;
						{"N3_CBASE"	,SN3->N3_CBASE		,NIL},;
						{"N3_ITEM"		,SN3->N3_ITEM	,NIL},;
						{"N3_TIPO"		,SN3->N3_TIPO	,NIL},;
						{"N3_BAIXA"   ,SN3->N3_BAIXA	,NIL},;
						{"N3_TPSALDO"	,SN3->N3_TPSALDO,NIL},;
						{"N3_SEQREAV"	,SN3->N3_SEQREAV,NIL},;
						{"N3_SEQ"		,SN3->N3_SEQ	,NIL}}
	
			//-------------------------------------------------------------
			//Verifica a existencia de dados nas tabelas novas do módulo
			// Caso negativo chama as rotina ATFA030 e ATFA035 para cancelamento
			//-------------------------------------------------------------
			FN6->(DbSetOrder(2))//posiciono pois na execAuto estava deposicionada a Tabela
			If FN6->(!MsSeek(SN3->N3_FILIAL + SN3->N3_FILORIG + SN3->N3_CBASE + SN3->N3_ITEM)) 
				cModAnt := .T.
			EndIf
			
			If cModAnt	
				While SN3->(N3_FILIAL + N3_CBASE + N3_ITEM) == SN1->(N1_FILIAL + N1_CBASE + N1_ITEM)
					aBaixa := {}
					AADD(aBaixa, {"N3_CBASE"	,SN1->N1_CBASE	,NIL })
					AADD(aBaixa, {"N3_ITEM"		,SN1->N1_ITEM	,NIL })
					AADD(aBaixa, {"N3_TIPO"		,SN3->N3_TIPO	,NIL })
					AADD(aBaixa, {"N3_BAIXA"	,SN3->N3_BAIXA	,NIL })
					AADD(aBaixa, {"AUTVLRVENDA"	,SN3->N3_VORIG1	,NIL })
					AADD(aBaixa, {"AUTQUANT"	,SN1->N1_QUANTD	,NIL })
					AADD(aBaixa, {"AUTMOTBX"	,"08"			,Nil })
					AADD(aBaixa, {"AUTBXFILHOS"	,.T.			,Nil })
					
					//------------------------------------------
					// Contabilização do cancelamento na origem
					//------------------------------------------
					If lLP8A0
		
						If lPrim .And. (nHdlPrv <= 0)
							nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
							lPrim := .F.
						Endif
		
						nTotal += DetProva( nHdlPrv,"8A0","ATFA060",cLoteAtf)
					Endif
				
					//³Executa a Baixa do Bem ³
					If cRotBaixa == "ATFA030"
						MSExecAuto( { |x, y,w| Atfa030( x, y, w ) }, aBaixa, 5 , aParam036 )
					Else
						MSExecAuto( { |x, y,w| Atfa035( x, y, w ) }, aBaixa, 5 , aParam036 )
					EndIf
					If SN1->N1_STATUS == '4' .and.  empty(SN1->N1_BAIXA)
						Reclock("SN1",.F.)
						SN1->N1_STATUS := '1' 
						SN1->(MSUNLOCK())		
					Endif 								
					SN3->(DBSkip())
				EndDo
			Else
				//------------------------------------------
				// Contabilização do cancelamento na origem
				//------------------------------------------
			 	While SN3->(N3_FILIAL + N3_CBASE + N3_ITEM) == SN1->(N1_FILIAL + N1_CBASE + N1_ITEM)
					If lLP8A0
		
						If lPrim .And. (nHdlPrv <= 0)
							nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
							lPrim := .F.
						Endif
		
						nTotal += DetProva( nHdlPrv,"8A0","ATFA060",cLoteAtf)
					Endif
				SN3->(DBSkip())
				EndDo
				
				//-----------------------
				// Cancelamento da baixa
				//-----------------------
				FN6->(DbSetOrder(1))//posiciono pois na execAuto estava deposicionada a Tabela
				MsExecAuto( { |a,b,c,d,e|ATFA036(a,b,c,,d,e)},aCab,aAtivo,5,.F.,aParam036)
			EndIf

			If lMsErroAuto
				cFileLog := NomeAutoLog()
				cPath := ""
				If !Empty(cFileLog)
					MostraErro(cPath,cFileLog)
				Endif
				lMsErroAuto := .F.
				lRet := .F.
				DisarmTransaction()
				cLogErro := STR0109 //"Bem possui restrições para a realização do cancelamento."
			Endif
	
		Else
			lRet := .F.
			ProcLogAtu(STR0095,STR0096,STR0102,,.T. ) //"ERRO"###"Cancelamento da baixa na filial origem"###"Bem não localizado na filial de origem."
		Endif
	
		//-----------------------------------------------------------------------
		// Contabilização do cancelamento da Transferência Contabil Origem (8A0)
		//-----------------------------------------------------------------------
		If lRet .And. lLP8A0
			If nHdlPrv > 0 .And. nTotal > 0
				RodaProva(nHdlPrv,nTotal)
				cA100Incl(cArquivo,nHdlPrv,2,cLoteAtf,lMostrLanc,lAglutLanc )
			Endif
		EndIf

	Endif

EndIf

RestArea(aAreaSN4)
RestArea(aAreaSN3)
RestArea(aAreaSN1)
RestArea(aArea)

Return lRet

/*
{Protheus.doc} A060CanCtb
Função para o cancelamento de transferência Contábil

@param   aDadosMNT - Esta váriavel esta obsoleta e esta sendo mantida devido a compatibilidade.

@author Totvs
@since 15/10/2014
@version 12.0
*/
Function A060CanCtb(lLP83A,cArquivo,cLoteAtf,lPrim,nHdlPrv,nTotal,aDadosMNT,lLP83B,cIdMovFNR)
Local aArea			:= GetArea()
Local aAreaSN3		:= SN3->(GetArea())
Local aAreaSN4		:= SN4->(GetArea())
Local aAreaSNG		:= SNG->(GetArea())
Local __nQuantas	:= If(lMultMoed,AtfMoedas(),5)
Local aAtuSal		:= If(lMultMoed,AtfMultMoe(,,{|x| 0}), {0,0,0,0,0} )
Local nI				:= 0
Local cMoed			:= ""
Local dDataTrans	:= dDataBase
Local lAtClDepr		:= .F.
Local cTipoTrDe		:= ""
Local cTipoTrPara	:= ""
Local nRecNoSN4 := 0
Local dUltDepr		:= GetMV("MV_ULTDEPR")
Local lGspInUseM	:= If(Type('lGspInUse')=='L', lGspInUse, .F.)
Local nTaxaMedia	:= Af060moeda(If(lGspInUseM,MsSomaMes(dUltDepr,-1,.T.),dUltDepr))
Local nUltIdMov		:= ""
Local lAF060CCTB 	:= ExistBlock("AF060CCTB")
Local lUsaFNS		:= .F.
Local nTxDepr		:= 0
Local nN4_TXDEPR	:= 0
Local lSCDP			:= GetMv("MV_ATFSCDP",.F.,.F.)
Local lIntMnt		:= GetMv("MV_NGMNTAT") $ "1#3"
Local cBase			:= ""

Default lLP83B		:= .F.
Default lLP83A		:= .F.
Default cArquivo	:= ""
Default cLoteAtf	:= ""
Default lPrim		:= .F.
Default nHdlPrv		:= 0
Default nTotal		:= 0
Default cIdMovFNR	:= ""

DbSelectArea("SN3")
SN3->(DbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ
SN3->(DbGoto((cAliasMrk)->RECNOSN3))

//--------------------------------------------------------------------
// Caso exista, utiliza a FNS para obter as contas transferidas, pois
// a SN4 não possui todas a contas necessarias para o estorno
//--------------------------------------------------------------------
If !Empty(cIdMovFNR)

	DBSelectArea("FNR")
	FNR->(DBSetOrder(1)) //FNR_FILIAL+FNR_IDMOV+FNR_CBAORI+FNR_ITEORI
	If FNR->(DBSeek(XFilial("FNR")+cIdMovFNR+SN3->N3_CBASE+SN3->N3_ITEM))

		DBSelectArea("FNS")
		FNS->(DBSetOrder(1)) //FNS_FILIAL+FNS_IDMOV+FNS_CODREL+FNS_TIPO+FNS_SEQ
		If FNS->(DBSeek(XFilial("FNS")+FNR->(FNR_IDMOV+FNR_CODREL)+SN3->(N3_TIPO+N3_SEQ)))
			lUsaFNS := .T.
		EndIf

	EndIf

EndIf

nUltIdMov := AF060IdMov(SN3->N3_CBASE,SN3->N3_ITEM)//Obtem o ultimo N4_IDMOV da transferencia contábil

//-------------------------------
// Busca a transferencia destino
//-------------------------------
DbSelectArea("SN4")
SN4->(DbSetOrder(6)) //N4_FILIAL+N4_IDMOV+N4_OCORR
If SN4->(DbSeek(XFilial("SN4")+nUltIdMov+"04"))

	//---------------------------------------------------------------------
	// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
	// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
	//---------------------------------------------------------------------
	While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "04"

		//------------------------------------------------------------------------
		// Tratamento necessario para quando houver dois tipos iguais.
		// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
		// Na transferencia automatica (mais de um ativo) o IDMOV fica o mesmo
		//------------------------------------------------------------------------
		If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
			SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
			SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
			SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.;
			SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
			SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

			SN4->(DBSkip())
			Loop
		Else
			Exit
		EndIf

	SN4->(DBSkip())
	EndDo

	//-------------------------------------------------------------
	// Contabilização antes de estornar os dados - (N4_OCORR = 04)
	//-------------------------------------------------------------
	If lLP83A

		If lPrim .And. (nHdlPrv <= 0)
			nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
			lPrim := .F.
		Endif

		CUSTO		:= "" //Centro de Custo de Despesa (N3_CCUSTO)

		//-----------------------------------
		// Bem
		//-----------------------------------
		CTABEM		:= ""	//Conta Contábil do Bem (N3_CCONTAB)
		CUSTBEMCTB	:= ""	//Centro de Custo do Bem (N3_CUSTBEM)
		SUBCCONCTB	:= ""	//Item Contábil do Bem (N3_SUBCCON)
		CLVLCONCTB	:= ""	//Classe de Valor do Bem (N3_CLVLCON)

		//-----------------------------------
		// Correcao Monetaria
		//-----------------------------------
		CORREBEM	:= ""	//Conta Contábil de Correcao do Bem (N3_CCORREC)
		CCCORRCTB	:= ""	//Centro de Custo de Correção monetária (N3_CCCORR)
		SUBCCORCTB	:= ""	//Item Contábil de Correcao Monetaria (N3_SUBCCOR)
		CLVLCORCTB	:= ""	//Classe de Valor de Correção Monetaria (N3_CLVLCOR)

		//-----------------------------------
		// Despesa Depreciação
		//-----------------------------------
		DESPDEPR	:= ""	//Conta Contábil de Despesa de Depreciacao (N3_CDEPREC)
		CCDESPCTB	:= ""	//Centro de Custo de Despesa de Depreciacao (N3_CCDESP)
		SUBCDEPCTB	:= ""	//Item Contábil de Despesa Depreciacao (N3_SUBCDEP)
		CLVLDEPCTB	:= ""	//Classe de Valor de Despesa de Depreciacao (N3_CLVLDEP)

		//-----------------------------------
		// Depreciação Acumulada
		//-----------------------------------
		DEPREACUM	:= ""	//Conta Contábil de Deprecicao Acumulada (N3_CCDEPR)
		CCCDEPCTB	:= ""	//Centro de Custo de Depreciação Acumulada (N3_CCCDEP)
		SUBCCDECTB	:= ""	//Item Contábil de Depreciacao Acumulada (N3_SUBCCDE)
		CLVLCDECTB	:= ""	//Classe de Valor de Depreciacao Acumulada (N3_CLVLCDE)

		//-----------------------------------
		// Depreciação de Correção Monetária
		//-----------------------------------
		CORREDEPR	:= ""	//Conta Contábil de Correcao de Depreciacao (N3_CDESP)
		CCCDESCTB	:= ""	//Centro de Custo de Correção da Depreciação (N3_CCCDES)
		SUBCDESCTB	:= ""	//Item Contábil de Correcao Depreciacao (N3_SUBCDES)
		CLVLDESCTB	:= ""	//Classe de Valor de Correcao Depreciacao (N3_CLVLDES)

		If lUsaFNS

			//-------------------------------------------------------------------------------------------------------------
			// Neste ponto implementaram a carga das variaveis privates os dados de origem, quando o certo seria o cliente
			// utilizar o LP 83B, este trecho foi preservado para não gerar colateral nos clientes orientados desta forma
			//-------------------------------------------------------------------------------------------------------------

			If !Empty(FNR->FNR_GRPORI)
				SNG->( DBSeek( XFilial( "SNG",FNR->FNR_FILORI) + FNR->FNR_GRPORI ) )
			EndIf

			//----------------
			// Conta Contabil
			//----------------
			CTABEM    := FNS->FNS_CONTAO //Bem (N3_CCONTAB)
			CORREBEM  := FNS->FNS_CONCOO //Correcao do Bem (N3_CCORREC)
			DESPDEPR  := FNS->FNS_CONDDO //Despesa de Depreciacao (N3_CDEPREC)
			DEPREACUM := FNS->FNS_CONDAO //Deprecicao Acumulada (N3_CCDEPR)
			CORREDEPR := FNS->FNS_CONCDO //Correcao de Depreciacao (N3_CDESP)

			//-----------------
			// Centro de Custo
			//-----------------
			CUSTO      := FNS->FNS_CCDESO //Despesa (N3_CCUSTO)
			CUSTBEMCTB := FNS->FNS_CCBEMO //Bem (N3_CUSTBEM)
			CCCORRCTB  := FNS->FNS_CCCORO //Correção monetária (N3_CCCORR)
			CCDESPCTB  := FNS->FNS_CCDDO  //Despesa de Depreciacao (N3_CCDESP)
			CCCDEPCTB  := FNS->FNS_CCDAO  //Depreciação Acumulada (N3_CCCDEP)
			CCCDESCTB  := FNS->FNS_CCCDO  //Correção da Depreciação (N3_CCCDES)

			//---------------
			// Item Contábil
			//---------------
			SUBCCONCTB := FNS->FNS_ITBEMO //Bem (N3_SUBCCON)
			SUBCCORCTB := FNS->FNS_ITCORO //Correcao Monetaria (N3_SUBCCOR)
			SUBCDEPCTB := FNS->FNS_ITDEDO //Despesa Depreciacao (N3_SUBCDEP)
			SUBCCDECTB := FNS->FNS_ITDEAO //Depreciacao Acumulada (N3_SUBCCDE)
			SUBCDESCTB := FNS->FNS_ITCDEO //Correcao Depreciacao (N3_SUBCDES)

			//-----------------
			// Classe de Valor
			//-----------------
			CLVLCONCTB := FNS->FNS_CVBEMO //Bem (N3_CLVLCON)
			CLVLCORCTB := FNS->FNS_CVCORO //Correção Monetaria (N3_CLVLCOR)
			CLVLDEPCTB := FNS->FNS_CVDEPO //Despesa de Depreciacao (N3_CLVLDEP)
			CLVLCDECTB := FNS->FNS_CVCDEO //Depreciacao Acumulada (N3_CLVLCDE)
			CLVLDESCTB := FNS->FNS_CVDESO //Correcao Depreciacao (N3_CLVLDES)

		Else

			//----------------------------------------------------------------------------------------------------
			// Este trecho deverá ser retirado futuramente, pois os clientes migrados (P11 para P12) já possuirão
			// os ultimos movimentos na FNR e FNS, não sendo necessário utilizar a SN4. Sabendo-se que após as
			// depreciações não é possivel cancelar transferencia contábil ou fisica.
			//----------------------------------------------------------------------------------------------------

			nRecNoSN4 := SN4->( RecNo() )

			//-------------------------------------------------------------------------------------------------------------------------------
			// Neste ponto implementaram um posicionamento na origem para carregar nas variaveis privates os dados de origem, quando o certo
			// seria o cliente utilizar o LP 83B, este trecho foi preservado para não gerar colateral nos clientes orientados desta forma...
			//-------------------------------------------------------------------------------------------------------------------------------
			If SN4->( DbSeek( xFilial("SN4") + nUltIdMov + "03" ) )

				CUSTO := SN3->N3_CCUSTO

				//Popula as variáveis de contabilização antes do cancelamento ser efetuado
				//---------------------------------------------------------------------
				// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
				// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
				//---------------------------------------------------------------------
				While !SN4->( Eof() ) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "03"

					//------------------------------------------------------------------------
					// Tratamento necessario para quando houver dois tipos iguais.
					// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
					//------------------------------------------------------------------------
					If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
						SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
						SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
						SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.;
						SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
						SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

						SN4->(DBSkip())
						Loop

					EndIf

					Do Case

						Case SN4->N4_TIPOCNT == "1" //Bem
							CTABEM		:= SN4->N4_CONTA	//Conta Contábil do Bem (N3_CCONTAB)
							CUSTBEMCTB	:= SN4->N4_CCUSTO	//Centro de Custo do Bem (N3_CUSTBEM)
							SUBCCONCTB	:= SN4->N4_SUBCTA	//Item Contábil do Bem (N3_SUBCCON)
							CLVLCONCTB	:= SN4->N4_CLVL		//Classe de Valor do Bem (N3_CLVLCON)

						Case SN4->N4_TIPOCNT == "2" //Correcao Monetaria
							CORREBEM	:= SN4->N4_CONTA	//Conta Contábil de Correcao do Bem (N3_CCORREC)
							CCCORRCTB	:= SN4->N4_CCUSTO	//Centro de Custo de Correção monetária (N3_CCCORR)
							SUBCCORCTB	:= SN4->N4_SUBCTA	//Item Contábil de Correcao Monetaria (N3_SUBCCOR)
							CLVLCORCTB	:= SN4->N4_CLVL		//Classe de Valor de Correção Monetaria (N3_CLVLCOR)

						Case SN4->N4_TIPOCNT == "3" //Despesa Depreciação
							DESPDEPR	:= SN4->N4_CONTA	//Conta Contábil de Despesa de Depreciacao (N3_CDEPREC)
							CCDESPCTB	:= SN4->N4_CCUSTO	//Centro de Custo de Despesa de Depreciacao (N3_CCDESP)
							SUBCDEPCTB	:= SN4->N4_SUBCTA	//Item Contábil de Despesa Depreciacao (N3_SUBCDEP)
							CLVLDEPCTB	:= SN4->N4_CLVL		//Classe de Valor de Despesa de Depreciacao (N3_CLVLDEP)

						Case SN4->N4_TIPOCNT == "4" //Depreciação Acumulada
							DEPREACUM	:= SN4->N4_CONTA	//Conta Contábil de Deprecicao Acumulada (N3_CCDEPR)
							CCCDEPCTB	:= SN4->N4_CCUSTO	//Centro de Custo de Depreciação Acumulada (N3_CCCDEP)
							SUBCCDECTB	:= SN4->N4_SUBCTA	//Item Contábil de Depreciacao Acumulada (N3_SUBCCDE)
							CLVLCDECTB	:= SN4->N4_CLVL		//Classe de Valor de Depreciacao Acumulada (N3_CLVLCDE)

						Case SN4->N4_TIPOCNT == "5" //Depreciação de Correção Monetária
							CORREDEPR	:= SN4->N4_CONTA	//Conta Contábil de Correcao de Depreciacao (N3_CDESP)
							CCCDESCTB	:= SN4->N4_CCUSTO	//Centro de Custo de Correção da Depreciação (N3_CCCDES)
							SUBCDESCTB	:= SN4->N4_SUBCTA	//Item Contábil de Correcao Depreciacao (N3_SUBCDES)
							CLVLDESCTB	:= SN4->N4_CLVL		//Classe de Valor de Correcao Depreciacao (N3_CLVLDES)

					EndCase

				SN4->(DbSkip())
				EndDo
			EndIf

			SN4->( DbGoTo( nRecNoSN4 ) )

		EndIf

		nTotal += DetProva( nHdlPrv,"83A","ATFA060",cLoteAtf)

	Endif

	//---------------------------------------------------------------------
	// Deleta os movimentos no destino N4_OCORR = 04
	//---------------------------------------------------------------------
	// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
	// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
	//---------------------------------------------------------------------
	While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "04"

		//------------------------------------------------------------------------
		// Tratamento necessario para quando houver dois tipos iguais .
		// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
		//------------------------------------------------------------------------
		If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
			SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
			SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
			SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.; 
			SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
			SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

			SN4->(DBSkip())
			Loop

		EndIf

		If lIntMnt .And. FindFunction("A550VLDCAN") .And. SN4->N4_OCORR == '04' .And. SN4->N4_TIPOCNT == '1'  .And. !Empty(SN1->N1_CODBEM)
			nRecno := SN4->(Recno())
			If SN3->N3_CBASE <> cBase
				aRet := A550VLDCAN(SN1->N1_CODBEM, SN1->N1_CBASE, SN4->N4_DATA, SN4->N4_HORA,/*FilOri*/,/*FilDest*/,.T.)
				If !aRet[1]
					cLogErro := aRet[2]
					DisarmTransaction()
					Break
				EndIf
				cBase := SN3->N3_CBASE				
			EndIf
			SN4->(DbGoTo(nRecno))					
		EndIf
		RecLock("SN4",.F.,.T.)
		SN4->(DBDelete())
		SN4->(MSUnlock())

	SN4->(DbSkip())
	EndDo

	// Verificação da classificação de Ativo se sofre depreciação
	lAtClDepr := AtClssVer(SN1->N1_PATRIM)

	//----------------------------
	// Trata contas patrimoniais
	//----------------------------
	If lAtClDepr .OR. EMPTY(SN1->N1_PATRIM)
		cTipoTrDe  := "8"
		cTipoTrPara:= "9"
	ElseIf SN1->N1_PATRIM $ "CAS"
		cTipoTrDe  := "G"
		cTipoTrPara:= "I"
	Else
		cTipotrDe  := "H"
		cTipotrPara:= "J"
	EndIf

	//---------------------------------------------------------------------
	// Atualiza conta no cancelamento da transferencia de contas - Destino
	// Controle de multiplas moedas
	//---------------------------------------------------------------------
	aAtuSal[1] := SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1
	For nI := 2 To __nQuantas
		cMoed := Alltrim(Str(nI))
		aAtuSal[nI] := SN3->&("N3_VORIG"+cMoed)+SN3->&(If(nI>9,"N3_AMPLI","N3_AMPLIA")+cMoed)
	Next nI
	ATFSaldo(SN3->N3_CCONTAB, dDataTrans, cTipoTrDe,aAtuSal[1],aAtuSal[2],aAtuSal[3],;
	aAtuSal[4],aAtuSal[5],"+", nTaxaMedia,SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aAtuSal )

EndIf

	//------------------------------------------------------------
	// Restaura e contabiliza os dados na Origem - N4_OCORR = 03
	//------------------------------------------------------------

	//-------------------------------------------------------------------------------------------
	// Utiliza a FNS para retornar os dados pois a SN4 além de depender da geração do N4_TIPOCNT
	// não possui o centro de custo de despesa (N3_CCUSTO)
	//-------------------------------------------------------------------------------------------
	If lUsaFNS

		RecLock("SN3",.F.)

			//Conta
			SN3->N3_CCONTAB	:= FNS->FNS_CONTAO
			SN3->N3_CCORREC	:= FNS->FNS_CONCOO
			SN3->N3_CDEPREC	:= FNS->FNS_CONDDO
			SN3->N3_CCDEPR	:= FNS->FNS_CONDAO
			SN3->N3_CDESP	:= FNS->FNS_CONCDO

			//Centro de Custo
			SN3->N3_CCUSTO	:= FNS->FNS_CCDESO
			SN3->N3_CUSTBEM	:= FNS->FNS_CCBEMO
			SN3->N3_CCCORR	:= FNS->FNS_CCCORO
			SN3->N3_CCDESP	:= FNS->FNS_CCDDO
			SN3->N3_CCCDEP	:= FNS->FNS_CCDAO
			SN3->N3_CCCDES	:= FNS->FNS_CCCDO

			//Item Contabil
			SN3->N3_SUBCCON	:= FNS->FNS_ITBEMO
			SN3->N3_SUBCDEP	:= FNS->FNS_ITDEDO
			SN3->N3_SUBCCDE	:= FNS->FNS_ITDEAO
			SN3->N3_SUBCDES	:= FNS->FNS_ITCDEO
			SN3->N3_SUBCCOR	:= FNS->FNS_ITCORO
			If lSCDP
				SN3->N3_SUBCTA	:= FNS->FNS_ITDEDO
			EndIf

			//Classe de Valor
			SN3->N3_CLVLCON	:= FNS->FNS_CVBEMO
			SN3->N3_CLVLDEP	:= FNS->FNS_CVDEPO
			SN3->N3_CLVLCDE	:= FNS->FNS_CVCDEO
			SN3->N3_CLVLDES	:= FNS->FNS_CVDESO
			SN3->N3_CLVLCOR	:= FNS->FNS_CVCORO

		SN3->(MsUnlock())

		//--------------------------------
		// Estorno da taxa de depreciacao
		//--------------------------------
		If !Empty(FNR->FNR_TXPADD) .And. FNR->FNR_TXPADO != FNR->FNR_TXPADD 

			DbSelectArea("SN4")
			SN4->(DbSetOrder(6)) //N4_FILIAL+N4_IDMOV+N4_OCORR
			If SN4->(DbSeek(XFilial("SN4")+nUltIdMov+"03"))

				//---------------------------------------------------------------------
				// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
				// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
				//---------------------------------------------------------------------
				While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "03"

					//------------------------------------------------------------------------
					// Tratamento necessario para quando houver dois tipos iguais.
					// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
					//------------------------------------------------------------------------
					If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
						SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
						SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
						SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.; 
						SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
						SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

						SN4->(DBSkip())
						Loop

					Else
						nN4_TXDEPR := SN4->N4_TXDEPR
						Exit
					EndIf

				SN4->(DBSkip())
				EndDo

			EndIf

			If !Empty(nN4_TXDEPR)
				nTxDepr := nN4_TXDEPR
			ElseIf !Empty(FNR->FNR_TXPADO)
				nTxDepr := GetAdvFval("SNH","NH_TAXA",xFilial("SNH")+FNR->FNR_TXPADO,1,SN3->N3_TXDEPR1)
			EndIf

			If nTxDepr <> SN3->N3_TXDEPR1
				Reclock("SN3",.F.)
					AtfMultMoe("SN3","N3_TXDEPR",{|x| nTxDepr})
				SN3->(MSUnlock())
			EndIf

		EndIf

	Else

		//----------------------------------------------------------------------------------------------------
		// Este trecho deverá ser retirado futuramente, pois os clientes migrados (P11 para P12) já possuirão
		// os ultimos movimentos na FNR e FNS, não sendo necessário utilizar a SN4. Sabendo-se que após as
		// depreciações não é possivel cancelar transferencia contábil ou fisica.
		//----------------------------------------------------------------------------------------------------

		DbSelectArea("SN4")
		SN4->(DbSetOrder(6)) //N4_FILIAL+N4_IDMOV+N4_OCORR
		If SN4->(DbSeek(XFilial("SN4")+nUltIdMov+"03"))

			//---------------------------------------------------------------------
			// Restabelece as contas originais do registro da SN3
			//---------------------------------------------------------------------
			// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
			// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
			//---------------------------------------------------------------------
			While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "03"

				//------------------------------------------------------------------------
				// Tratamento necessario para quando houver dois tipos iguais .
				// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
				//------------------------------------------------------------------------
				If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
					SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
					SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
					SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.; 
					SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
					SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

					SN4->(DBSkip())
					Loop

				EndIf

				RecLock("SN3",.F.)

					Do Case

						Case SN4->N4_TIPOCNT == "1" //Bem
							SN3->N3_CCONTAB	:= SN4->N4_CONTA
							SN3->N3_CUSTBEM	:= SN4->N4_CCUSTO
							SN3->N3_SUBCCON	:= SN4->N4_SUBCTA
							SN3->N3_CLVLCON	:= SN4->N4_CLVL

						Case SN4->N4_TIPOCNT == "2" //Correcao Monetaria
							SN3->N3_CCORREC	:= SN4->N4_CONTA
							SN3->N3_CCCORR	:= SN4->N4_CCUSTO
							SN3->N3_CCUSTO	:= SN4->N4_CCUSTO
							SN3->N3_SUBCCOR	:= SN4->N4_SUBCTA
							SN3->N3_CLVLCOR	:= SN4->N4_CLVL

						Case SN4->N4_TIPOCNT == "3" //Despesa Depreciação
							SN3->N3_CDEPREC	:= SN4->N4_CONTA
							SN3->N3_CCDESP	:= SN4->N4_CCUSTO
							SN3->N3_CCUSTO	:= SN4->N4_CCUSTO
							SN3->N3_SUBCDEP	:= SN4->N4_SUBCTA
							SN3->N3_CLVLDEP	:= SN4->N4_CLVL

						Case SN4->N4_TIPOCNT == "4" //Depreciação Acumulada
							SN3->N3_CCDEPR	:= SN4->N4_CONTA
							SN3->N3_CCCDEP	:= SN4->N4_CCUSTO
							SN3->N3_SUBCCDE	:= SN4->N4_SUBCTA
							SN3->N3_CLVLCDE	:= SN4->N4_CLVL

						Case SN4->N4_TIPOCNT == "5" //Depreciação de Correção Monetária
							SN3->N3_CDESP	:= SN4->N4_CONTA
							SN3->N3_CCCDES	:= SN4->N4_CCUSTO
							SN3->N3_SUBCDES	:= SN4->N4_SUBCTA
							SN3->N3_CLVLDES	:= SN4->N4_CLVL

					EndCase

				SN3->(MsUnlock())

			SN4->(DbSkip())
			EndDo

		EndIf

	EndIf

	If lAF060CCTB
		Execblock("AF060CCTB",.F.,.F.)
	EndIf

	//--------------------------------------------------------------------
	// Posiciona na SN4 para contabilização antes de deletar os registros
	//--------------------------------------------------------------------
	DbSelectArea("SN4")
	SN4->(DbSetOrder(6)) //N4_FILIAL+N4_IDMOV+N4_OCORR
	If SN4->(DbSeek(XFilial("SN4")+nUltIdMov+"03"))

		//---------------------------------------------------------------------
		// Deleta o movimento origem 03
		//---------------------------------------------------------------------
		// Tratamento para posicionar o SN4 correto. Na transferencia em lote,
		// havia um erro que deixou os bens com N4_IDMOV iguais (já corrigido)
		//---------------------------------------------------------------------
		While SN4->(!EOF()) .And. XFilial("SN4") == SN4->N4_FILIAL .And. SN4->N4_IDMOV == nUltIdMov .And. SN4->N4_OCORR == "03"

			//------------------------------------------------------------------------
			// Tratamento necessario para quando houver dois tipos iguais .
			// Ex: Duas ampliações, dois tipos 10 com tipo de saldo diferentes e etc.
			//------------------------------------------------------------------------
			If	SN4->N4_CBASE	<> SN3->N3_CBASE	.Or.;
				SN4->N4_ITEM	<> SN3->N3_ITEM		.Or.;
				SN4->N4_TIPO	<> SN3->N3_TIPO		.Or.;
				SN4->N4_TPSALDO	<> SN3->N3_TPSALDO	.Or.; 
				SN4->N4_SEQ		<> SN3->N3_SEQ		.Or.;
				SN4->N4_SEQREAV	<> SN3->N3_SEQREAV

				SN4->(DBSkip())
				Loop

			EndIf

			//---------------------------
			// Contabilização da origem
			//---------------------------
			If lLP83B
				nTotal += DetProva( nHdlPrv,"83B","ATFA060",cLoteAtf)
			Endif

			RecLock("SN4",.F.,.T.)
			SN4->(DbDelete())
			SN4->(MsUnlock())
		SN4->(DbSkip())
		EndDo
	EndIf

	//---------------------------------------------------------------------
	// Atualiza conta no cancelamento da transferencia de contas - Origem
	// Controle de multiplas moedas
	//---------------------------------------------------------------------
	aAtuSal[1] := SN3->N3_VORIG1+SN3->N3_VRCACM1+SN3->N3_AMPLIA1
	For nI := 2 To __nQuantas
		cMoed := Alltrim(Str(nI))
		aAtuSal[nI]	:= SN3->&("N3_VORIG"+cMoed)+SN3->&(If(nI>9,"N3_AMPLI","N3_AMPLIA")+cMoed)
	Next nI
	ATFSaldo(	SN3->N3_CCONTAB, dDataTrans, cTipoTrPara,aAtuSal[1],aAtuSal[2],aAtuSal[3],;
	aAtuSal[4],aAtuSal[5],"+", nTaxaMedia,SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aAtuSal )

RestArea(aAreaSNG)
RestArea(aAreaSN4)
RestArea(aAreaSN3)
RestArea(aArea)

Return Nil

/*{Protheus.doc} AF060IdMov
Query para obter o ultimo movimento de transferencia que ocorreu para o bem
é considerado somente os campos N4_CBASE e N4_ITEM pois a última transferencia
pode ter ocorrido para somente um dos tipos de saldo do bem (ex transf contabil).

@author Totvs
@since 15/10/2014
@version 12.0
*/
Static Function AF060IdMov(cBase,cItem)
Local aArea		:= GetArea()
Local cUltIdMov	:= ""
Local cQuery	:= ""
Local cAliasQry	:= GetNextAlias()

Default cBase	:= ""
Default cItem	:= ""

If Select(cAliasQry) > 0
	(cAliasQry)->(dbCloseArea())
EndIf

cQuery := " SELECT "										+CRLF
cQuery +=		" MAX(N4_IDMOV) N4_IDMOV "					+CRLF
cQuery += " FROM " + RetSqlName("SN4") + " SN4 "			+CRLF
cQuery += " WHERE "											+CRLF
cQuery +=		" SN4.N4_FILIAL  = '" + xFilial("SN4")+"' "	+CRLF
cQuery +=		" AND SN4.N4_CBASE   = '" + cBase    + "' "	+CRLF
cQuery +=		" AND SN4.N4_ITEM    = '" + cItem    + "' "	+CRLF
cQuery +=		" AND SN4.N4_OCORR   = '04' "				+CRLF
cQuery +=		" AND SN4.N4_FILORIG = '" + xFilial("SN4")+"' "	+CRLF
cQuery +=		" AND SN4.D_E_L_E_T_ = '' "					+CRLF
cQuery := ChangeQuery(cQuery)

DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

If (cAliasQry)->(!EOF())
	cUltIdMov := (cAliasQry)->N4_IDMOV
EndIf

(cAliasQry)->(DbCloseArea())

RestArea(aArea)

Return cUltIdMov

/*{Protheus.doc} ATF060VTR
Visualização da Transferencia do Ativo
@author José Augusto Ribeiro
@since 014/09/2015
@version P12
*/
Function ATF060VTR()
Local aArea		:= GetArea()
Local cTMPFNR	:= GetNextAlias()
Local cAux		:= ""
Local cFilAux	:= ""
Local cFilBkp	:= cFilAnt

//--------------------------------------------------------------------
// Query pra buscar o ultimo movimento do bem posicionado como Origem
//--------------------------------------------------------------------
BeginSql Alias cTMPFNR
	SELECT MAX(FNR_IDMOV) FNR_IDMOV, FNR_FILORI
	FROM %Table:FNR%
	WHERE	FNR_FILORI = %Exp:cFilAnt%
			AND FNR_CBAORI = %Exp:SN3->N3_CBASE%
			AND FNR_ITEORI = %Exp:SN3->N3_ITEM%
			AND FNR_STATUS = '1'
			AND %NotDel%
	GROUP BY FNR_FILORI
EndSql

If (cTMPFNR)->(!EOF())
   cAux		:= (cTMPFNR)->FNR_IDMOV
   cFilAux	:= (cTMPFNR)->FNR_FILORI
EndIf

//--------------------------------------------------------------
// Caso não encontre como origem, procura como destino, pois o 
// cliente pode ter posicionado no resultado da transferencia 
//--------------------------------------------------------------
If Empty(cAux)

	If Select(cTMPFNR) > 0
		(cTMPFNR)->(DBCloseArea())
	EndIf

	cTMPFNR := GetNextAlias()

	BeginSql Alias cTMPFNR
		SELECT MAX(FNR_IDMOV) FNR_IDMOV, FNR_FILORI
		FROM %Table:FNR%
		WHERE	FNR_FILDES = %Exp:cFilAnt%
				AND FNR_CBADES = %Exp:SN3->N3_CBASE%
				AND FNR_ITEDES = %Exp:SN3->N3_ITEM%
				AND FNR_STATUS = '1'
				AND %NotDel%
		GROUP BY FNR_FILORI
	EndSql

	If (cTMPFNR)->(!EOF())
		cAux	:= (cTMPFNR)->FNR_IDMOV
		cFilAux	:= (cTMPFNR)->FNR_FILORI
	EndIf

EndIf

(cTMPFNR)->(DBCloseArea())

If !Empty(cAux)

	DBSelectArea("FN9")
	FN9->(DBSetOrder(1))

	DBSelectArea("FNR")
	FNR->(DBSetOrder(1))

	DBSelectArea("FNS")
	FNS->(DBSetOrder(1))

	If	FN9->(DBSeek(XFilial("FN9",cFilAux)+cAux)) .And.;
		FNR->(DBSeek(XFilial("FNR",cFilAux)+cAux)) .And.;
		FNS->(DBSeek(XFilial("FNS",cFilAux)+cAux))

		lVisu := .T.

		//-------------------------------------------------------------------------------------------------------------------
		// A manipulação do cFilAnt é necessaria devido o FWExecView não exibir os dados mesmo com os registros posicionados
		// (FN9, FNR e FNS exclusivos), na transferencia entre filiais ao visualiar a transferencia do ativo no destino
		//-------------------------------------------------------------------------------------------------------------------
		cFilAnt := cFilAux
		
		FWExecView("Visualização da Transferencia" ,'ATFA060',	MODEL_OPERATION_VIEW,/*oDlg*/,{ || .T. })

		cFilAnt := cFilBkp

		lVisu := .F.

	Else
		Help(" ",1, "AF060VTR",,STR0158,1,0) //"Não foi locazida nenhuma transferência do Bem."
	EndIf

Else
	Help(" ",1, "AF060VTR",,STR0158,1,0) //"Não foi locazida nenhuma transferência do Bem."
EndIf

RestArea(aArea)

Return

/*{Protheus.doc}ATFA060Vis
Abre a visualizacao do cadastro do bem - ATFA012
@author Totvs
@since 26/06/2015
@version P12
*/
Function ATFA060Vis()
Local aArea := GetArea()

DbSelectArea("SN1")
SN1->(DbSetOrder(1)) //Filial + Código Base + Item
SN1->(DbSeek( FWxFilial("SN1") + SN3->N3_CBASE + SN3->N3_ITEM ) )

SaveInter() //Necessario pois a abertura da ATFA012 muda os valores dos parametros

FWExecView(STR0151,'ATFA012',MODEL_OPERATION_VIEW,/*oDlg*/,{||.T.}) //"Visualização da Ficha de Ativo"

RestInter()

RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} AF060ExNFE

Exclusao da Nota Fiscal de Entrada

@author Totvs
@since 05/07/2015
@version 12
/*/
//-------------------------------------------------------------------
Function AF060ExNFE(cFilOrig,cNota,cSerie)
Local aArea				:= GetArea()
Local aAreaSF1			:= SF1->(GetArea())
Local cCNPJFor			:= GetAdvFVal("SM0","M0_CGC",cEmpAnt+cFilOrig,1,"")
Local cF1_DOC				:= PadR(cNota,TamSx3("F1_DOC")[1])
Local cF1_SERIE			:= PadR(cSerie,TamSX3("F1_SERIE")[1])
Local cF1_FORN			:= GetAdvFVal("SA2","A2_COD",XFilial("SA2",cFilOrig) + PadR(cCNPJFor,TamSX3("A2_CGC")[1]),3,"")
Local cF1_LOJA			:= GetAdvFVal("SA2","A2_LOJA",XFilial("SA2",cFilOrig) + PadR(cCNPJFor,TamSX3("A2_CGC")[1]),3,"")
Local cF1_TIPO			:= "N"
Local lRet					:= .T.
Local cChaveSF1			:= ""
Local aCabNFE				:= {}
Local aIteNFE				:= {}
Local lPreNota			:= .T.
Local aErro				:= {}
Local nX					:= 0
Local cMsg					:= ""

//Controle de rotina automatica
Private lMsErroAuto		:= .F. //Determina se houve algum tipo de erro durante a execucao do ExecAuto
Private lMsHelpAuto		:= .T. //Define se mostra ou não os erros na tela (T= Nao mostra; F=Mostra)
Private lAutoErrNoFile	:= .F. //Habilita a gravacao de erro da rotina automatica

cChaveSF1 := XFilial("SF1") + cF1_DOC + cF1_SERIE + cF1_FORN + cF1_LOJA + cF1_TIPO

DbSelectArea("SF1")
SF1->(DbSetOrder(1)) //F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO
If SF1->(DbSeek(cChaveSF1))

	//Cabeçalho do Documento de Entrada
	Aadd(aCabNFE, {"F1_DOC"		,SF1->F1_DOC		,Nil})
	Aadd(aCabNFE, {"F1_SERIE"	,SF1->F1_SERIE		,Nil})
	Aadd(aCabNFE, {"F1_FORNECE"	,SF1->F1_FORNECE	,Nil})
	Aadd(aCabNFE, {"F1_LOJA"	,SF1->F1_LOJA		,Nil})
	Aadd(aCabNFE, {"F1_TIPO"	,SF1->F1_TIPO		,Nil})

	lPreNota := Empty(SF1->F1_STATUS) //Documento nao classificado, excluir pelo MATA140

Else
	lRet := .F.
	cMsg := STR0152 //"O documento de entrada não foi localizado para exclusão."
EndIf

If lRet

	If lPreNota	// Pré Nota - Exclusão do Documento de Entrada no MATA140
		MSExecAuto( { |x,y,z| MATA140(x,y,z) }, aCabNFE,aIteNFE,5 )
	Else // Documento Fiscal - Exclusão do Documento de Entrada no MATA103
		MSExecAuto( { |x,y,z| MATA103(x,y,z) }, aCabNFE,aIteNFE,5 )
	EndIf

	If lMsErroAuto
		aErro := GetAutoGrLog()
		cMsg := ""

		For nX := 1 To Len(aErro)
			cMsg += aErro[nX] + CRLF
		Next nX

		lRet := .F.
	EndIf
EndIf

RestArea(aAreaSF1)
RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} AF060ExNFS

Exclusao da Nota Fiscal de Saida

@author Totvs
@since 05/07/2015
@version 12
/*/
//-------------------------------------------------------------------
Function AF060ExNFS(cNumNFS,cSerie)
Local aAreaSF2	:= SF2->(GetArea())
Local aRegSD2		:= {}
Local aRegSE1		:= {}
Local aRegSE2		:= {}
Local lRet			:= .T.
Local lAglutCtb	:= .F.
Local lCtbOnLine	:= .F.

lAglutCtb		:= .F.//MV_PAR02 == 1
lCtbOnLine		:= .F.//MV_PAR03 == 1

SF2->(DbSetOrder(1))
If	SF2->(MsSeek(xFilial("SF2") + cNumNFS + cSerie, .F.))
	//-- Verifica se o estorno do documento de saida pode ser feito.
	If MaCanDelF2("SF2",SF2->(RecNo()),@aRegSD2,@aRegSE1,@aRegSE2)
		//-- Estorna o documento de saida.
		SF2->(MaDelNFS(aRegSD2,aRegSE1,aRegSE2,.F.,lAglutCtb,lCtbOnLine,.T.,,1))
	Else
		lRet := .F.
		Help(" ",1, "AF060ExNFS",,STR0153,1,0) //"Não é possivel cancelar a Nota Fiscal."
	EndIf
Else
	lRet := .F.
	Help(" ",1, "AF060ExNFS",,STR0154,1,0) //"Nota Fiscal não localizada."
EndIf

RestArea(aAreaSF2)

Return lRet

/*{Protheus.doc} AF060IDFNR
Query para obter o ultimo ID de Movimento do bem na FNR
@author Totvs
@since 05/07/2015
@version 12.0
*/
Static Function AF060IDFNR(cBase,cItem, cFilFNR, nTpTransf)
Local aArea		:= GetArea()
Local cUltIdMov	:= ""
Local cQuery	:= ""
Local cAliasQry	:= GetNextAlias()

Default cBase	:= ""
Default cItem	:= ""
Default cFilFNR := ""
Default nTpTransf := 0

If Select(cAliasQry) > 0
	(cAliasQry)->(dbCloseArea())
EndIf

cQuery := " SELECT "													+CRLF
cQuery += 		" FNR_FILIAL FNR_FILIAL, " 								+CRLF
cQuery +=		" MAX(FNR_IDMOV) FNR_IDMOV "							+CRLF
cQuery += " FROM " + RetSqlName("FNR") + " FNR "						+CRLF
cQuery += " WHERE "														+CRLF

If(!FwIsInCallStack("ATF060VTR")) .and. nTpTransf == 1 //If para que seja possivel visualizar a transferencia na filial de origem

	cQuery +=		" FNR.FNR_FILDES		= '" + cFilAnt + "' "		+CRLF

ELSE	
	
	cQuery +=		" FNR.FNR_FILIAL			= '" + xFilial("FNR")+"' "	+CRLF

EndIf

cQuery +=		" AND FNR.FNR_CBADES		= '" + cBase + "' "			+CRLF
cQuery +=		" AND FNR.FNR_ITEDES		= '" + cItem + "' "			+CRLF
cQuery +=		" AND FNR.FNR_STATUS		= '1' "						+CRLF
cQuery +=		" AND FNR.D_E_L_E_T_		= ' ' "							+CRLF

cQuery += 		" GROUP BY FNR_FILIAL "
cQuery := ChangeQuery(cQuery)

DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

If (cAliasQry)->(!EOF())
   cUltIdMov := (cAliasQry)->FNR_IDMOV 
   iIf (nTpTransf  == 1 ,cFilFNR := (cAliasQry)->FNR_FILIAL , cFilFNR := "")	 
EndIf

(cAliasQry)->(DbCloseArea())

RestArea(aArea)

Return cUltIdMov

//--------------------------------------------------
/*/{Protheus.doc} A060Mexec
Macro Execução
@author Totvs
@since 10/07/2015
@version 12.1.6
/*/
//--------------------------------------------------
Function A060Mexec(cVar)


Return &cVar


//-------------------------------------------------------------------
/*/
{Protheus.doc} A060VLDFil
Valida restrição de filiais para usuario

@author Igor S. Nascimento

@since 07/04/2015
@version 12.0
/*/
//-------------------------------------------------------------------

Static Function A060VLDFil(cFil)

Local lAdmin	:= FWIsAdmin( __cUserID ) //Se usuário é administrador ou está no grupo Administradores
Local aEmp		:= {}
Local aGrp		:= {}
local nI,nX,nY	:= 0
Local cUsrRul	:= FWUsrGrpRule(__cUserID) //0-Não encontrou o usuário informado; 1-Prioriza; 2-Desconsidera; 3-Soma
Local aUser		:= {}
Local lRet		:= .F.
Local _cEmpFil	:= cEmpAnt + cFil

If IsBlind() 
	Return(.T.)
EndIf

If lAdmin
	Return (.T.)
Endif

// Obtem os acessos dos grupos do usuario
aGrp := FWSFUsrGrps(__cUserID)  //000001

// Soma ou Prioriza acessos do grupo
If cUsrRul $ "3|1"  
	For nI:=1 to Len(aGrp)		
		// Retorna Empresa e Filial que o grupo tem acesso. Ex: 9901
		aAdd(aEmp, FWGrpEmp(aGrp[nI]) )
	Next nI	
EndIf

// Soma ou desconsidera - Soma com os acessos do usuário ou desconsidera grupo
If cUsrRul $ "3|2" .Or. Len(aGrp) == 0		
	//--Obtem os acessos do usuario
	PswSeek( __cUserID, .T. )

	aUser := PswRet( 2 )[1][6]

	//Se aUser for igual a @@@@, o usuário tem acesso a todas as empresas
	If ValType(aUser) == "A" .And. !Empty(aUser) 
		If aUser[1] == "@@@@"
			Return (.T.)
		EndIf

		//Soma aos acessos do grupo
		aAdd(aEmp, aUser)
	EndIf

EndIf

//Desconsidera Grupo, considera acessos do usuário	
If cUsrRul == "2" .Or. Len(aGrp) == 0
	For nY:=1 to len(aUser)
		If AllTrim(aUser[nY]) == AllTrim(_cEmpFil)
			Return (.T.)
		EndIf
	Next nY
Else	
	For nX:=1 To Len(aEmp)
		For nY:=1 To Len(aEmp[nX])
			If AllTrim(aEmp[nX][nY]) == AllTrim(_cEmpFil) .Or. AllTrim(aEmp[nX][nY]) == "@@@@"
				Return (.T.)
			EndIf
		Next nY
	Next nX
EndIf

Return lRet

/*{Protheus.doc} AF060CTB
Função para fazer a contabilização da transferencia entre filiais
@author Jose Augusto Ribeiro
@since 11/08/2015
@version P12
@param oModel, Objeto , Modelo Ativo no Commit
*/
Static Function AF060CTB(oModel)
Local oModFNR 	:= oModel:GetModel("GridFNR")
Local oModFNS 	:= oModel:GetModel("GridFNS")
Local cFilBkp 	:= cFilAnt
Local cFilDest 	:= oModFNR:GetValue("FNR_FILDES")
Local cFilOrig	:= oModFNR:GetValue("FNR_FILORI")
Local cArquivo	:= ""
Local nHdlPrv 	:= 0
Local nFNR			:= 0 
Local nFNS			:= 0
Local aAux			:= {}
Local nX			:= 0	
Local nTotal		:= 0 
Local cLoteAtf	:= LoteCont("ATF")
Local lAglutina 	:= .T.
Local lMostra		:= .T.
Local lLanc831	:= VerPadrao("831")
Local lLanc832	:= .T.
Local cFilAux		:= ""
	
	//Verificando se Foi a Transferencia automatica ou normal para carregar o seu devido pergunte
	If(FwIsInCallStack("ATF060TRAN"))
		
		Pergunte("AFA060", .F.)
	
	Else
	
		Pergunte("AFA060A", .F.)
	
	EndIf
	lMostra   := Iif(mv_par02==1,.T.,.F.)
	lAglutina := Iif(mv_par03==1,.T.,.F.)
	
	//Aqui estou criando um vetor com as filiais e as ordenandos da FNR
	For nFNR := 1 To oModFNR:Length(.T.)
		oModFNR:GoLine(nFNR)
		If oModFNR:Getvalue("OK") //Transferencia de dados com diferentes filiais Origem e Destino
			Aadd(aAux,{oModFNR:GetValue("FNR_FILDES"),nFNR})
		EndIf
	Next nFNR

	aSort(aAux, , , { | x,y | x[1]+Str(x[2]) < y[1]+Str(y[2])} )
	If(lLanc831 .And. MV_PAR01 == 1)
		//Criacao do Arquivo de Contabilização da Filial de Origem
		If(nHdlPrv <= 0)
		
			nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
			
		Endif
		
		For nX := 1 To Len(aAux)
			oModFNR:GoLine(aAux[nx][2])
			If(oModFNR:GetValue("OK"))
				For nFNS := 1 To oModFNS:Length(.T.)
					If(oModFNS:GetValue("OK"))
						//Chamando a Função para fazer o DetProva
						AF060CTBFIL(@cLoteAtf,@cArquivo, cFilOrig, cFilDest, "03", nFNS, nX, oModel,@nTotal,@nHdlPrv)
						
					EndIf
				Next nNFS
			EndIf
		Next nX
		//Fechamento do Arquivo de Contabilização da Filial de Origem
		If nHdlPrv > 0 .And. nTotal > 0
		
			RodaProva(nHdlPrv,nTotal)
			cA100Incl(cArquivo,nHdlPrv,2,cLoteAtf,lMostra,lAglutina)
			
		EndIf
	EndIf
		nTotal  := 0 
		nHdlPrv := 0 
		//Filial de Destino
		cFilAnt := cFilDest
		lLanc832 := VerPadrao("832")
	If(lLanc832 .And. MV_PAR01 == 1)
		cFilAux := oModFNR:GetValue("FNR_FILDES")
		For nX := 1 To Len(aAux)
			oModFNR:GoLine(aAux[nx][2])
			//Criação do Arquivo por Filiais diferentes
			If(nHdlPrv <= 0 .And. (nX == 1 .Or. cFilAux <> oModFNR:GetValue("FNR_FILDES")))
		
				nHdlPrv := HeadProva(cLoteAtf,"ATFA060",Substr(cUsername,1,6),@cArquivo)
			
			Endif
			If(oModFNR:GetValue("OK"))
				For nFNS := 1 To oModFNS:Length(.T.)
					If(oModFNS:GetValue("OK"))
						//Chamando a Função para fazer o DetProva
						AF060CTBFIL(@cLoteAtf,@cArquivo, cFilOrig, cFilDest, "04", nFNS, nX, oModel,@nTotal,@nHdlPrv)
						
					EndIf
				Next nNFS
			EndIf
			//Fechamento do Arquivo por diferentes Filiais
			If nHdlPrv > 0 .And. nTotal > 0 .And. ( nX == Len(aAux) .Or. oModFNR:GetValue("FNR_FILDES") <> Iif(Len(aAux) >= nx+1,aAux[nx+1][1],aAux[nx][1]))
		
				RodaProva(nHdlPrv,nTotal)
				cA100Incl(cArquivo,nHdlPrv,2,cLoteAtf,lMostra,lAglutina)
				nTotal  := 0
				nHdlPrv := 0
			EndIf
		Next nX
	EndIf
	//Restaurar variável cFilAnt (manipulada na função) após toda operação
	cFilAnt := cFilBkp
Return

//-------------------------------------------------------------------
/*/
{Protheus.doc} AFA060LOG
Exibe log do ATFA060

@author Simone Mie Sato Kakinoana 

@since 11/12/2015
@version 12.0
/*/
//-------------------------------------------------------------------

Function AFA060LOG()

ProcLogView(,__cProcPrinc)

Return

//-------------------------------------------------------------------
/*/
{Protheus.doc} AF060CpUsr
AF060CpUsr-Carrega campos de usuarios para gravacao FN9/FNR/FNS

@author Paulo Carnelossi 

@since 17/03/2016
@version 12.0
/*/
//-------------------------------------------------------------------

Static Function AF060CpUsr(cAliasAux)
Local aRetorno := {}
Local aArea    := GetArea()
Local aStruSX3 := {}
Local cCampo   := ""
Local nI

aStruSX3 := &(cAliasAux)->(DbStruct())

For nI := 1 to Len(aStruSX3)
	cCampo := AllTrim(aStruSX3[nI,1])
	
	If GetSX3Cache(cCampo, "X3_PROPRI")== "U" .And. GetSX3Cache(cCampo, "X3_CONTEXT") != "V" .And. GetSX3Cache(cCampo,"X3_TIPO") <> 'M' 
		aAdd( aRetorno, cCampo)
	EndIf
	
Next nI

RestArea(aArea)

Return(aRetorno) 

//-------------------------------------------------------------------
/*/
{Protheus.doc} A060InvSel
Inverte a seleção dos ativos na transferência Automatica

@author TOTVS

@since 21/04/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function A060InvSel()
Local oModel	:= FWModelActive()
Local oFNR		:= oModel:GetModel("GridFNR")
Local nFNR		:= 0
Local aSaveRows	:= FWSaveRows()

For nFNR := 1 To oFNR:Length()

	oFNR:GoLine(nFNR)

	oFNR:SetValue("OK",!(oFNR:GetValue("OK")))

Next nFNR

FWRestRows(aSaveRows)

Return 

//-------------------------------------------------------------------
/*/
{Protheus.doc} AF060VldDt
Valida se a transferia nao esta ocorrendo em data anterior a ultima

@author TOTVS

@since 17/05/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function AF060VldDt(cCodBase,cItem,lHelp)
Local aSaveArea	:= GetArea()
Local lRet		:= .T.
Local cTMPFNR	:= GetNextAlias()

Default lHelp := .T.

BeginSql Alias cTMPFNR
	SELECT FNR_IDMOV
	FROM %Table:FNR%
	WHERE	FNR_FILDES = %Exp:cFilAnt%
			AND FNR_CBADES = %Exp:cCodBase%
			AND FNR_ITEDES = %Exp:cItem%
			AND FNR_STATUS = '1'
			AND FNR_DATA > %Exp:dDataBase%
			AND %NotDel%
EndSql

If (cTMPFNR)->(!EOF())
	lRet := .F.
	If lHelp
		Help(" ",1,"AF060VldDt",,STR0195,1,0,,,,,,{STR0196 + Alltrim(cCodBase) + " " + AllTrim(cItem) + "."}) //"Localizada transferência com data posterior a data base do sistema."###"Confira a data da última transferência ocorrida para o ativo: "
	EndIf 	
EndIf

(cTMPFNR)->(DBCloseArea())

RestArea(aSaveArea)

Return lRet

//-------------------------------------------------------------------
/*/
{Protheus.doc} CompareDif
Validação para verificar se houve alteração de dados na trasferecia 

Obs.: 
A Função foi escrita deste modo pois os metodos IsFieldUpdated e Compare do modelo não atendem
IsFieldUpdated - quando vc edita o campo e não altera o contudo ele retorna que o campo foi alterado
Compare - o array de retorno de modificação não é possivel identificar pai e filho (FNS e FNR)

@author TOTVS

@since 28/06/2018
@version 12.1.17
/*/
//-------------------------------------------------------------------
Static Function CompareDif(oModel)
Local lRet	:= .T. //Retorna se houve alteração nos ativos selecionado
Local lAlt	:= .F.
Local nFNR		:= 0 
Local nFNS		:= 0 
Local oModFNR		:= oModel:GetModel('GridFNR')
Local oModFNS		:= oModel:GetModel('GridFNS')
Local aCposFNR		:= oModFNR:GetStruct():GetFields()
Local aCposFNS		:= oModFNS:GetStruct():GetFields()
Local nCposFNR		:= 0
Local nCposFNS		:= 0
Local lLote		:= FwIsInCallStack("AF060Auto")
Local aFNROri	:= {"FNR_QTDORI","FNR_FILORI","FNR_GRPORI","FNR_LOCORI","FNR_CBAORI","FNR_ITEORI","FNR_TXPADO"}
Local aFNRDest	:= {"FNR_QTDDES","FNR_FILDES","FNR_GRPDES","FNR_LOCDES","FNR_CBADES","FNR_ITEDES","FNR_TXPADD"}
Local aFNSOri	:= {"FNS_CONTAO","FNS_CCBEMO","FNS_CONDDO","FNS_CCDESO","FNS_CONDAO","FNS_CONCDO","FNS_CONCOO","FNS_CCDDO","FNS_CCDAO","FNS_CCCDO","FNS_CCCORO","FNS_ITBEMO","FNS_ITDEDO","FNS_ITDEAO","FNS_ITCDEO","FNS_ITCORO","FNS_CVBEMO","FNS_CVDEPO","FNS_CVCDEO","FNS_CVDESO","FNS_CVCORO" }
Local aFNSDest	:= {"FNS_CONTAD","FNS_CCBEMD","FNS_CONDDD","FNS_CCDESD","FNS_CONDAD","FNS_CONCDD","FNS_CONCOD","FNS_CCDDD","FNS_CCDAD","FNS_CCCDD","FNS_CCCORD","FNS_ITBEMD","FNS_ITDEDD","FNS_ITDEAD","FNS_ITCDED","FNS_ITCORD","FNS_CVBEMD","FNS_CVDEPD","FNS_CVCDED","FNS_CVDESD","FNS_CVCORD" }
Local aLinha	:= FWSaveRows()

For nFNR := 1 To oModFNR:Length() //Percorre grid FNR
	oModFNR:goline(nFNR)
	If oModFNR:getvalue("OK") //Se o campo OK estiver flagdo
		For nCposFNR := 1 To Len(aFNROri) //Percorre Campos da strutura FNR
			IF oModFNR:getValue(aFNROri[nCposFNR]) <> oModFNR:getValue(aFNRDest[nCposFNR])
				lAlt:= .T.
				Exit
			EndIf
		Next nCposFNR

		If 	!lAlt
		//percorre filhos FNS
			For nFNS := 1 To oModFNS:Length() //Percorre grid FNs
				oModFNS:goline(nFNS)
				If oModFNS:getvalue("OK") //Se o campo OK estiver flagdo
					For nCposFNS := 1 To Len(aFNSOri) //Percorre Campos da strutura FNS
						If	oModFNS:getValue(aFNSOri[nCposFNS]) <> oModFNS:getValue(aFNSDest[nCposFNS])
							lAlt:= .T.
							Exit
						EndIf
					Next nCposFNS
				EndIF
			Next nFNS
		EndIF
		//Se o ativo estiver marcado para transferencia e não sofreu alteração mostra a msg
		If !lAlt
			Help( "", 1, "AF060TDOK", ,STR0199,1,0,,,,,,{STR0184+" "+AllTrim(oModFNR:GetValue("FNR_CBAORI")) + " " +AllTrim(oModFNR:GetValue("FNR_ITEORI"))} ) //"O campo classificacao da NF esta em branco"###'Verifique os dados no painel "Ativo", Código + Item:'
			lRet := .F.
			Exit
		EndIf	
	EndIf
	lAlt:= .F. //Volta valor da variavel
Next nFNR

FWRestRows(aLinha)
Return lRet
//Validação changSets antes de tudo.
//Validação changSets antes de tudo.