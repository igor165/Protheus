#INCLUDE "PROTHEUS.CH"
#INCLUDE "TECA300.CH"
#INCLUDE "TBICONN.CH"


#DEFINE CADASTRO STR0007	//"Manuteno Chamado Tcnico"
#DEFINE  NUMITENS 300

Static aCtrRodape := {} 

/*/


Ŀ
Funo     TECA300   Autor          Eduardo Riera  Data  21.09.98 
Ĵ
Descrio  Programa de Manutencao no Chamado Tecnico                  
Ĵ
Sintaxe    ExpX1 := TECA300( ExpC1, ExpA1 )                           
Ĵ
Parametros ExpC1 -> Rotina a ser chamada / ExpA1 -> Dados telemarket. 
Ĵ
Retorno    ExpX1 -> .T. ou .F. ou array retorno p/ telemarketig       
Ĵ
 Uso       Generico                                                   
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL. 					  
Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO					  
Ĵ
Aline C.Vale  01/06/99ProtheVer chamada para controle de botoes     
Andrea Farias 20/06/05811   BOPS 83192 - Alterada expressao logica   
                            do 9. parametro da Mbrowse.              
Cleber M.     12/04/0696040 Inclusao de legenda na rotina.           
Conrado Q.    26/04/07124187Incluso do ponto de entrada AT300Fil    
                            para filtrar os registros exibidos.      
ٱ


/*/
Function TECA300( cRotina, aDadosTMK, xAutoCab, xAutoItens, nOpcAuto )

Local xRet			:= .T.			// Retorno da funo
Local cAt300Fil		:= ""			// Filtro fornecido pelo ponto de entrada
Local bFiltraBrw	:= {||}			// Bloco de cdigo para execuo do filtro
Local aIndexAB1		:= {}			// Indice do AB1
Local cFiltraAB1	:= ""			// Filtro utilizado no bloco de cdigo executado para ativar o filtro
Local aCores     := {}
Local aCoresNew  := {}

Private aRotina 	:= MenuDef()	// Itens do Menu
Private cCadastro	:= CADASTRO		// Ttulo do cadastro
Private cRoda  		:= ""			// Rotina a ser executada quando  funo  chamada por outra fonte
Private aDados		:= {}			// Clone do aDadosTMK
Private aAutoCab	:= {}			// Cabealho da rotina automtico
Private aAutoItens	:= {}			// Itens da rotina automtica

aDados := AClone( aDadosTMK ) 

aCores := {{"AB1_STATUS=='A'",'ENABLE' },{"AB1_STATUS=='E'",'DISABLE' }}

If	xAutoCab <> Nil .AND. xAutoItens <> NIL
	Private lAt300Auto := .T.

	aAutoCab  := xAutoCab
	aAutoItens:= xAutoItens

	aEval(aAutoItens,{|x| aEval(x,{|y,z| If( y[1] == AllTrim("AB2_ITEM"), y[3] := ".T.", )})})

	MBrowseAuto(nOpcAuto,Aclone(aAutoCab),"AB1")
Else

	//Ŀ
	// Verifica a existencia de Filtros na mBrowse                  
	//
	DbSelectArea("AB1")
	AB1->(DbSetOrder(1)) //AB1_FILIAL+AB1_NRCHAM
	If (ExistBlock("AT300FIL"))
		cAt300Fil := ExecBlock("AT300FIL",.F.,.F.)
		If ( ValType(cAt300Fil) == "C" ) .AND. !Empty(cAt300Fil)
			cFiltraAB1 := cAt300Fil
		EndIf
		bFiltraBrw 	:= {|| FilBrowse("AB1",@aIndexAB1,@cFiltraAB1) }
		Eval(bFiltraBrw)
	EndIf
   
	//Ŀ
	// Ponto de Entrada para alterar cores do Browse do Cadastro    
	//
	If ExistBlock("AT30COR")
		aCoresNew := ExecBlock("AT30COR",.F.,.F.,aCores)
		If ValType( aCoresNew ) == "A"
			aCores := aClone(aCoresNew)
		EndIf
	Endif

   
    If ValType( cRotina ) == "C"
   		//Ŀ
		// Faz tratamento para chamada por outra rotina             
		//
		If !Empty( nScan := AScan( aRotina, { |x| x[2] == cRotina } ) ) 
			cRoda := cRotina + "( 'AB1', AB1->( Recno() ), " + Str(nScan,2) + If(ValType(aDados)=="A",",,aDados)",")") 
			xRet  := Eval( { || &( cRoda ) } ) 
		EndIf 
	Else    
		mBrowse( 6, 1,22,75,"AB1",,,,,,aCores)
	EndIf 
EndIf
DbSelectArea("AB1")
DbSetOrder(1)

Return( xRet ) 

/*/

Ŀ
Funo    MenuDef    Autor  Conrado Q. Gomes       Data  08.12.06 
Ĵ
Descrio  Definio do aRotina (Menu funcional)                      
Ĵ
Sintaxe    MenuDef()                                                  
Ĵ
Parametros                                                            
Ĵ
 Uso       TECA300                                                    
ٱ


/*/
Static Function MenuDef()
	//Ŀ
	// Define Array contendo as Rotinas a executar do programa      
	// ----------- Elementos contidos por dimensao ------------     
	// 1. Nome a aparecer no cabecalho                              
	// 2. Nome da Rotina associada                                  
	// 3. Usado pela rotina                                         
	// 4. Tipo de Transao a ser efetuada                          
	//    1 - Pesquisa e Posiciona em um Banco de Dados             
	//    2 - Simplesmente Mostra os Campos                         
	//    3 - Inclui registros no Bancos de Dados                   
	//    4 - Altera o registro corrente                            
	//    5 - Remove o registro corrente do Banco de Dados          
	//
	Local aRotina := { 	{ STR0001	,"AxPesqui" 	,0	,1	,0	,.F.	}	,;	//"Pesquisar"
						{ STR0002	,"At300Visua"	,0	,2	,0	,.T.	}	,;	//"Visualizar"
						{ STR0003	,"At300Inclu"	,0	,3	,0	,.T.	}	,;	//"Incluir"
						{ STR0004	,"At300Alter"	,0	,4	,0	,.T.	}	,;	//"Alterar"
						{ STR0005	,"At300Exclu"	,0	,5	,0	,.T.	}	,;	//"Excluir"
						{ STR0006	,"At300Efet" 	,0	,4	,0	,.T.	}	,;	//"eFetivar"
						{ STR0054	,"At300Leg" 	,0	,2	,0	,.T.	}	}	//"Legenda" 
Return(aRotina)

/*/

Ŀ
Funo    At300Inclu Autor Eduardo Riera           Data  21.09.98 
Ĵ
Descrio  Rotina de Inclusao dos Chamados Tecnicos                   
Ĵ
Sintaxe    ExpL1 := At300Inclu(ExpC1,ExpN1,ExpN2)                     
Ĵ
Retorno    ExpL1 -> Concluiu a operacao                               
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       TECA300                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
27/12/2006 Conrado Q.    Bops 115746: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


/*/

Function At300Inclu(cAlias,nReg,nOpc,aX,aDadosTMK)

Local aRet      := { .F., "" }		// Retorno da funo de gravao    
Local cConteudo := ""				// Contedo do campo de memria
Local oDlg		:= Nil				// Objeto do dilogo exibido
Local oSay		:= Nil				// Objeto do say exibido
Local uCampo	:= Nil				// Nome do campo
Local oGetD		:= Nil				// Objeto do getdados exibido
Local lTmk		:= ( ValType( aDadosTMK ) == "A" )	// Se houve campos passados pelo TMK
Local lRetorno	:= .F.				// Se o usurio confirmou a incluso e a gravao ocorreu com sucesso
Local nOpcA		:= 0				// Se 1 o usurio pressionou OK se 0 o usurio pressionou cancelar
Local nScan		:= 0 				// Utilizado para localizar a posio de um determinado campo
Local aObjects	:= {}				// Array com os objetos exibidos
Local aPosObj	:= {} 				// Array com as posies dos objetos exibidos
Local aSizeAut	:= {}				// Array com os tamanhos automticos
Local aPosGet	:= {}				// Posio do objeto Get
Local nSaveSX8	:= GetSX8Len()		// Nmero gerado para identificao do registro

Private aTela	:= {}				// Array da tela
Private aGets	:= {}				// Array dos gets
Private aHeader := {}				// Cabealho do GetDados
Private aCols   := {}				// Itens do GetDados
Private INCLUI  := .T.  			// Informa que  incluso
Private oGetDUS	:= Nil				// Backup do objeto oGetD

If ExistBlock("AT300INC")
	Execblock("AT300INC",.F.,.F.)
Endif

//Ŀ
// Cria Variaveis de Memoria da Enchoice                
//
DbSelectArea("SX3")
DbSetOrder(1)
DbSeek("AB1")
While ( !Eof() .AND.(SX3->X3_ARQUIVO == "AB1") )
	uCampo := SX3->X3_CAMPO

	//Ŀ
	// Faz tratamento para inicializar campos passados pelo TMK 
	//
	If lTmk 
		If !Empty( nScan := AScan( aDadosTMK, { |x| AllTrim( x[1] ) == AllTrim( uCampo ) } ) )  	
			cConteudo := aDadosTMK[ nScan, 2 ] 
		Else
	 		cConteudo := CriaVar( uCampo ) 
		EndIf            	
	Else	 
	    If uCampo == "AB1_NRCHAM"
    		cConteudo :=GetNumAB1()
    	Else
 			cConteudo := CriaVar( uCampo )
	 	EndIf 
	EndIf 		

	//Ŀ
	// Faz a declaracao da variavel como private (nao remover)  
	//   
	SetPrvt( Trim(uCampo) )
	M->&(uCampo) := cConteudo 
		
	DbSelectArea("SX3")
	dbSkip()
End

//Ŀ
//Montagem aHeader, aCols
//
If Len(aHeader) == 0 .AND. Len(aCols) == 0
	FillGetDados(	nOpc			,"AB2"		,1				,/*cSeek*/		,;
					/*{||cWhile}*/	,{|| .T. }	,/*aNoFields*/	,/*aYesFields*/	,; 
					/*lOnlyYes*/	,/*cQuery*/	,/*bMontCols*/	,.T.			)
Endif

aCols[1][GdFieldPos("AB2_ITEM")] := "01"

If Type("lAt300Auto")=="U" .OR. !lAt300Auto
	//Ŀ
	//Monta tela de entrada                                                   
	//
	
	//Ŀ
	// Carrega definicoes de objetos para calculo automatico                  
	//
	aSizeAut := MsAdvSize() 
	aObjects := {} 
	aAdd( aObjects, { 315,  70, .T., .T. } )
	aAdd( aObjects, { 100, 100, .T., .T. } )
	aAdd( aObjects, { 100,  14, .T., .F. } )
	
	aInfo := { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 } 
	
	aPosObj := MsObjSize( aInfo, aObjects ) 
	
	//Ŀ
	//Monta tela de entrada                                                   
	//
	DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSizeAut[7],0 TO aSizeAut[6],aSizeAut[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME 
	
	oEnch := MsMGet():New( cAlias, nReg, nOpc, , , , , aPosObj[1], , 3 , , , , , , .T. )
	
	oGetd:=MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"At300LinOk","At300TudOk","+AB2_ITEM",.T.,,,,NUMITENS)
	oGetd:oBrowse:bChange := {|| At300Rodape(),.T.}
	
	nLinSay  := aPosObj[ 3,1 ] 
	nColSay  := aPosObj[ 3,2 ] 
	
	aPosGet := MsObjGetPos(aSizeAut[3]-aSizeAut[1],310,;
				{{005,060,075,130,145,200,230,285}} )
   
	aCtrRodape := {} 

	@ nLinSay ,aPosGet[1,1] SAY STR0008			SIZE 055,007 PIXEL	//"Contrato: "
	@ nLinSay ,aPosGet[1,2] SAY oSay PROMPT ""		 		SIZE 015,007 PIXEL
	aAdd( aCtrRodape, { "R-CONT", oSay } ) 	
	@ nLinSay ,aPosGet[1,3] SAY STR0009			SIZE 055,007 PIXEL	//"Garantia: "
	@ nLinSay ,aPosGet[1,4] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
	aAdd( aCtrRodape, { "R-GARA", oSay } ) 		
	@ nLinSay ,aPosGet[1,5] SAY STR0010			SIZE 055,007 PIXEL	//"Preventiva:"
	@ nLinSay ,aPosGet[1,6] SAY oSay PROMPT ""	 			SIZE 030,007 PIXEL
	aAdd( aCtrRodape, { "R-PREV", oSay } ) 			
	@ nLinSay  + 8,aPosGet[1,1] SAY STR0011			SIZE 055,007 PIXEL	//"Chamado Tcnico:"
	@ nLinSay  + 8,aPosGet[1,2] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
	aAdd( aCtrRodape, { "R-CHAM", oSay } ) 				
	@ nLinSay  + 8,aPosGet[1,3] SAY STR0012			SIZE 055,007 PIXEL	//"Oramento:"
	@ nLinSay  + 8,aPosGet[1,4] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
	aAdd( aCtrRodape, { "R-ORCA", oSay } ) 					
	@ nLinSay  + 8,aPosGet[1,5] SAY STR0013			SIZE 055,007 PIXEL	//"Ordem Servio:"
	@ nLinSay  + 8,aPosGet[1,6] SAY oSay PROMPT ""		 		SIZE 015,007 PIXEL
	aAdd( aCtrRodape, { "R-OSRV", oSay } ) 						
	@ nLinSay ,aPosGet[1,7] SAY STR0014			SIZE 055,007 PIXEL	//"Obsolescncia:"
	@ nLinSay ,aPosGet[1,8] SAY oSay PROMPT "" 				SIZE 015,007 PIXEL
	aAdd( aCtrRodape, { "R-OBSO", oSay } ) 							
	@ nLinSay  + 8,aPosGet[1,7] SAY STR0015			SIZE 055,007 PIXEL	//"              "
	@ nLinSay  + 8,aPosGet[1,8] SAY oSay PROMPT ""				SIZE 015,007 PIXEL
	aAdd( aCtrRodape, { "R-MENS", oSay } ) 							
	                
	oGetDUS := oGetD 
	
	ACTIVATE MSDIALOG oDlg ;
	  ON INIT At300Bar(oDlg,;
	  {||nOpcA:=1,If(Obrigatorio(aGets,aTela).AND.oGetd:TudoOk(),oDlg:End(),nOpcA:=0)},;
	  {||nOpcA:=0,If(At300VldUs( nOpca ),oDlg:End(),)}, nOpc, oGetD, @oEnch ) VALID At300VldUs( nOpca )
Else
	If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)}) .AND.;
		MsGetDAuto(aAutoItens,"At300LinOk",{|| At300TudOk() .AND. At300VldUs(1)},aAutoCab,aRotina[nOpc][4])
		nOpcA := 1
	EndIf
EndIf

If ( nOpcA == 1 )
	Begin Transaction
		aRet := At300Grava(1)  
		If ( aRet[1] )
			EvalTrigger()
			While ( GetSX8Len() > nSaveSx8 )
				ConfirmSx8()
			End
			lRetorno := .T.
		Else			
			While ( GetSX8Len() > nSaveSx8 )
				RollBackSx8()
			End
		EndIf
	End Transaction
Else	
	While ( GetSX8Len() > nSaveSx8 )
		RollBackSx8()
	End
EndIf

DbSelectArea( cAlias )
Return( { lRetorno, aRet[2] } ) 


/*/

Ŀ
Funo    At300Visua Autor Eduardo Riera           Data  23.09.98 
Ĵ
Descrio  Rotina de Visualizacao dos Chamados Tecnicos               
Ĵ
Sintaxe    At300Visua(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       TECA300                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
27/12/2006 Conrado Q.    Bops 115746: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


/*/
Function At300Visua(cAlias,nReg,nOpc)

Local oDlg		:= Nil				// Objeto do dilogo exibido
Local oSay		:= Nil				// Objeto do say exibido
Local oGetD		:= Nil				// Objeto do getdados exibido
Local nUsado	:= 0				// Quantidade de campos usados no aHeader
Local nCntFor	:= 0				// Contador
Local aArea		:= GetArea()		// Salva a area atual
Local aObjects	:= {} 				// Array com os objetos exibidos
Local aPosObj	:= {} 				// Array com as posies dos objetos exibidos
Local aSizeAut	:= {}				// Array com os tamanhos automticos
Local aPosGet	:= {}				// Posio do objeto Get
Local cSeek		:= ""				// Seek para montagem da aCols
Local cWhile	:= ""				// While para montagem da aHeader

Private aTela	:= {}				// Array da tela
Private aGets	:= {}				// Array dos gets
Private aHeader := {}				// Cabealho do GetDados
Private aCols   := {} 				// Itens do GetDados
Private INCLUI  := .F.				// Informa que no  incluso

If ExistBlock("AT300VIS")
	Execblock("AT300VIS",.F.,.F.)
Endif

//Ŀ
// Cria Variaveis de Memoria da Enchoice                
//     
RegToMemory( "AB1", .F. ) 

//Ŀ
//Inicializa as variaveis Virtuais do Programa                            
//
DbSelectArea("SA1")
DbSetOrder(1)
DbSeek(xFilial("SA1")+M->AB1_CODCLI+M->AB1_LOJA)
M->AB1_NOMCLI := SA1->A1_NOME

//Ŀ
//Montagem aHeader, aCols
//
cSeek	:= xFilial("AB2")+M->AB1_NRCHAM
cWhile	:= "AB2->AB2_FILIAL+AB2->AB2_NRCHAM"

If Len(aHeader) == 0 .AND. Len(aCols) == 0
	FillGetDados(	nOpc			,"AB2"		,1				,cSeek			,;
					{|| &cWhile }	,{|| .T. }	,/*aNoFields*/	,/*aYesFields*/	,; 
					/*lOnlyYes*/	,/*cQuery*/	,/*bMontCols*/	,/*lEmpty*/		)
Endif
                        
aSizeAut := MsAdvSize() 
aObjects := {} 
aAdd( aObjects, { 315,  70, .T., .T. } )
aAdd( aObjects, { 100, 100, .T., .T. } )
aAdd( aObjects, { 100,  14, .T., .F. } )

aInfo := { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 } 

aPosObj := MsObjSize( aInfo, aObjects ) 

//Ŀ
//Monta tela de entrada                                                   
//
DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSizeAut[7],0 TO aSizeAut[6],aSizeAut[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME 

EnChoice( cAlias, nReg, nOpc, , , , , aPosObj[1], , 3 , , , , , , .T. )

M->AB1_NOMCLI := SA1->A1_NOME

oGetd:=MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"At300LinOk","At300TudOk","+AB2_ITEM",.F.)
oGetd:oBrowse:bChange := {|| At300Rodape(),.T.}

nLinSay  := aPosObj[ 3,1 ] 
nColSay  := aPosObj[ 3,2 ] 

aPosGet := MsObjGetPos(aSizeAut[3]-aSizeAut[1],310,;
			{{005,060,075,130,145,200,230,285}} )

aCtrRodape := {} 

@ nLinSay ,aPosGet[1,1] SAY STR0008			SIZE 055,007 PIXEL	//"Contrato: "
@ nLinSay ,aPosGet[1,2] SAY oSay PROMPT ""		 		SIZE 015,007 PIXEL
aAdd( aCtrRodape, { "R-CONT", oSay } ) 	
@ nLinSay ,aPosGet[1,3] SAY STR0009			SIZE 055,007 PIXEL	//"Garantia: "
@ nLinSay ,aPosGet[1,4] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
aAdd( aCtrRodape, { "R-GARA", oSay } ) 		
@ nLinSay ,aPosGet[1,5] SAY STR0010			SIZE 055,007 PIXEL	//"Preventiva:"
@ nLinSay ,aPosGet[1,6] SAY oSay PROMPT ""	 			SIZE 030,007 PIXEL
aAdd( aCtrRodape, { "R-PREV", oSay } ) 			
@ nLinSay  + 8,aPosGet[1,1] SAY STR0011			SIZE 055,007 PIXEL	//"Chamado Tcnico:"
@ nLinSay  + 8,aPosGet[1,2] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
aAdd( aCtrRodape, { "R-CHAM", oSay } ) 				
@ nLinSay  + 8,aPosGet[1,3] SAY STR0012			SIZE 055,007 PIXEL	//"Oramento:"
@ nLinSay  + 8,aPosGet[1,4] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
aAdd( aCtrRodape, { "R-ORCA", oSay } ) 					
@ nLinSay  + 8,aPosGet[1,5] SAY STR0013			SIZE 055,007 PIXEL	//"Ordem Servio:"
@ nLinSay  + 8,aPosGet[1,6] SAY oSay PROMPT ""		 		SIZE 015,007 PIXEL
aAdd( aCtrRodape, { "R-OSRV", oSay } ) 						
@ nLinSay ,aPosGet[1,7] SAY STR0014			SIZE 055,007 PIXEL	//"Obsolescncia:"
@ nLinSay ,aPosGet[1,8] SAY oSay PROMPT "" 				SIZE 015,007 PIXEL
aAdd( aCtrRodape, { "R-OBSO", oSay } ) 							
@ nLinSay  + 8,aPosGet[1,7] SAY STR0015			SIZE 055,007 PIXEL	//"              "
@ nLinSay  + 8,aPosGet[1,8] SAY oSay PROMPT ""				SIZE 015,007 PIXEL
aAdd( aCtrRodape, { "R-MENS", oSay } ) 							

At300Rodape(aCols[1][aScan(aHeader,{|x|AllTrim(x[2])=="AB2_CODPRO"})],aCols[1][aScan(aHeader,{|x|AllTrim(x[2])=="AB2_NUMSER"})])
ACTIVATE MSDIALOG oDlg ;
  ON INIT At300Bar(oDlg,{||oDlg:End()},{||oDlg:End()},nOpc)

DbSelectArea( aArea[1] )
DbSetOrder(aArea[2])
DbGoTo(aArea[3])
Return .T.

/*/

Ŀ
Funo    At300Alter Autor Eduardo Riera           Data  23.09.98 
Ĵ
Descrio  Rotina de Alteracao dos Chamados Tecnicos                  
Ĵ
Sintaxe    ExpL1 := At300Alter(ExpC1,ExpN1,ExpN2)                     
Ĵ
Retorno    ExpL1 -> Concluiu a operacao                               
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       TECA300                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
27/12/2006 Conrado Q.    Bops 115746: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
17/07/2007 Conrado Q.    Bops 128851: Analisa o retorno do P.E.      
                         AT300Alt.                                   
ٱ


/*/
Function At300Alter(cAlias,nReg,nOpc)
                                
Local aRet			:= {}			// Retorno da funo de gravao
Local oDlg			:= Nil			// Objeto do dilogo exibido
Local oSay			:= Nil			// Objeto do say exibido
Local oGetD			:= Nil			// Objeto do getdados exibido
Local nOpcA			:= 0			// Se 1 o usurio pressionou OK se 0 o usurio pressionou cancelar
Local lRetorno		:= .F.			// Se o usurio confirmou a alterao e a gravao ocorreu com sucesso
Local lRollBackSX8	:= .F. 			// Se  para devolver o nmero gerado para identificao do registro
Local aObjects		:= {} 			// Array com os objetos exibidos
Local aPosObj		:= {} 			// Array com as posies dos objetos exibidos
Local aSizeAut		:= {}			// Array com os tamanhos automticos
Local aPosGet		:= {}			// Posio do objeto Get
Local nSaveSX8		:= GetSX8Len()	// Nmero gerado para identificao do registro
Local cSeek			:= ""			// Seek para montagem da aCols
Local cWhile		:= ""			// While para montagem da aHeader
Local aTravas		:= {}			// Campos que foram travados
Local lTravas		:= .T.			// Se todos os campos foram travados com sucesso
Local lAltera		:= .T.			// Se poder ocorrer a alterao ou no.
Local lRet			:= .T.			// Retorno do P.E. AT300ALT

Private aTela	:= {}				// Array da tela
Private aGets	:= {}				// Array dos gets
Private aHeader := {}				// Cabealho do GetDados
Private aCols   := {}				// Itens do GetDados
Private INCLUI  := .F.				// Informa que no  incluso
Private oGetDUS := Nil				// Backup do objeto oGetD

If ExistBlock("AT300ALT")
	lRet := Execblock("AT300ALT",.F.,.F.)
	If ValType( lRet ) == "L"
		lAltera := lRet
	EndIf
Endif

//Ŀ
//Trava os registros necessarios                                          
//
If !AtTravaReg("AB1", aTravas)
	lTravas := .F.
Endif

//Ŀ
// Cria Variaveis de Memoria da Enchoice                
//
RegToMemory( "AB1", .F. ) 

//Ŀ
//Inicializa as variaveis Virtuais do Programa                            
//
DbSelectArea("SA1")
DbSetOrder(1)
DbSeek(xFilial("SA1")+M->AB1_CODCLI+M->AB1_LOJA)
M->AB1_NOMCLI := SA1->A1_NOME

If Len(aHeader) == 0 .AND. Len(aCols) == 0 .AND. lTravas
	//Ŀ
	//Montagem aHeader, aCols
	//
	cSeek	:= xFilial("AB2")+M->AB1_NRCHAM
	cWhile	:= "AB2->AB2_FILIAL+AB2->AB2_NRCHAM"
	
	If !FillGetDados(	nOpc			,"AB2"		,1				,cSeek			,;
						{|| &cWhile }	,{|| .T. }	,/*aNoFields*/	,/*aYesFields*/	,; 
						/*lOnlyYes*/	,/*cQuery*/	,/*bMontCols*/	,/*lEmpty*/		,;
						/*aHeaderAux*/	,/*aColsAux*/	,/*bAfterCols*/	,{|| AtTravaReg("AB2", aTravas) .AND. At300Verif(nOpc) }	)
		lTravas := .F.
	Endif
Endif

If ( lTravas .AND. lAltera )

	If Empty(aCols[1][GdFieldPos("AB2_ITEM")])
		aCols[1][GdFieldPos("AB2_ITEM")] := "01"
	Endif

	If Type("lAt300Auto")=="U" .OR. !lAt300Auto

		//Ŀ
		//Monta tela de entrada                                                   
		//
		                 
		aSizeAut := MsAdvSize() 
		aObjects := {} 
		aAdd( aObjects, { 315,  70, .T., .T. } )
		aAdd( aObjects, { 100, 100, .T., .T. } )
		aAdd( aObjects, { 100,  14, .T., .F. } )
		
		aInfo := { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 } 
		
		aPosObj := MsObjSize( aInfo, aObjects ) 
		
		//Ŀ
		//Monta tela de entrada                                                   
		//
		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSizeAut[7],0 TO aSizeAut[6],aSizeAut[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME 
		
		EnChoice( cAlias, nReg, nOpc, , , , , aPosObj[1], , 3 , , , , , , .T. )
		
		M->AB1_NOMCLI := SA1->A1_NOME
		
		oGetd:=MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"At300LinOk","At300TudOk","+AB2_ITEM",.T.,,,,NUMITENS,"At300FldOk",/*cSuperDel*/,/*uPar*/,"At300DelOk")
		oGetd:oBrowse:bChange := {|| At300Rodape(,,oGetd),.T.}
		
		nLinSay  := aPosObj[ 3,1 ] 
		nColSay  := aPosObj[ 3,2 ] 
		                      
		aPosGet := MsObjGetPos(aSizeAut[3]-aSizeAut[1],315,;
				{{005,060,075,130,145,200,230,285}} )

		aCtrRodape := {} 
	
		@ nLinSay ,aPosGet[1,1] SAY STR0008			SIZE 055,007 PIXEL	//"Contrato: "
		@ nLinSay ,aPosGet[1,2] SAY oSay PROMPT ""		 		SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-CONT", oSay } ) 	
		@ nLinSay ,aPosGet[1,3] SAY STR0009			SIZE 055,007 PIXEL	//"Garantia: "
		@ nLinSay ,aPosGet[1,4] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-GARA", oSay } ) 		
		@ nLinSay ,aPosGet[1,5] SAY STR0010			SIZE 055,007 PIXEL	//"Preventiva:"
		@ nLinSay ,aPosGet[1,6] SAY oSay PROMPT ""	 			SIZE 030,007 PIXEL
		aAdd( aCtrRodape, { "R-PREV", oSay } ) 			
		@ nLinSay  + 8,aPosGet[1,1] SAY STR0011			SIZE 055,007 PIXEL	//"Chamado Tcnico:"
		@ nLinSay  + 8,aPosGet[1,2] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-CHAM", oSay } ) 				
		@ nLinSay  + 8,aPosGet[1,3] SAY STR0012			SIZE 055,007 PIXEL	//"Oramento:"
		@ nLinSay  + 8,aPosGet[1,4] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-ORCA", oSay } ) 					
		@ nLinSay  + 8,aPosGet[1,5] SAY STR0013			SIZE 055,007 PIXEL	//"Ordem Servio:"
		@ nLinSay  + 8,aPosGet[1,6] SAY oSay PROMPT ""		 		SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-OSRV", oSay } ) 						
		@ nLinSay ,aPosGet[1,7] SAY STR0014			SIZE 055,007 PIXEL	//"Obsolescncia:"
		@ nLinSay ,aPosGet[1,8] SAY oSay PROMPT "" 				SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-OBSO", oSay } ) 							
		@ nLinSay  + 8,aPosGet[1,7] SAY STR0015			SIZE 055,007 PIXEL	//"              "
		@ nLinSay  + 8,aPosGet[1,8] SAY oSay PROMPT ""				SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-MENS", oSay } ) 							
			
		At300Rodape(aCols[1][aScan(aHeader,{|x|AllTrim(x[2])=="AB2_CODPRO"})],aCols[1][aScan(aHeader,{|x|AllTrim(x[2])=="AB2_NUMSER"})],oGetd)
		
		oGetDUS := oGetD
		
		ACTIVATE MSDIALOG oDlg ;
		   ON INIT At300Bar(oDlg,;
			{||nOpcA:=1,if(oGetd:TudoOk(),If(!obrigatorio(aGets,aTela),nOpcA := 0,oDlg:End()),nOpcA := 0)},;
			{||nOpcA:=0,If(At300VldUs( nOpca ),oDlg:End(),)}, nOpc ) VALID At300VldUs( nOpca )
	Else
		If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)}) .AND.;
			MsGetDAuto(aAutoItens,"At300LinOk",{|| At300TudOk() .AND. At300VldUs(1)},aAutoCab,aRotina[nOpc][4])
			nOpcA := 1
		EndIf
	EndIf
	
	If ( nOpcA == 1 )
		Begin Transaction
			aRet := aT300Grava(2)
			If ( aRet[1] )
				EvalTrigger()
				While ( GetSX8Len() > nSaveSx8 )
					ConfirmSx8()
				End
				lRetorno := .T. 
			Else
				lRollBackSX8 := .T. 					
			EndIf
		End Transaction
	Else 			
		lRollBackSX8 := .T. 	
	EndIf
Else	
	lRollBackSX8 := .T. 		
EndIf 

If lRollBackSX8
	While ( GetSX8Len() > nSaveSx8 )
		RollBackSx8()
	End
EndIf 

//Ŀ
//Efetua o destravamento dos registros travados.
//
AtDestravaReg( aTravas )

DbSelectArea( cAlias )
DbSetOrder(1)
Return( lRetorno ) 

/*/

Ŀ
Funo    At300Exclu Autor Eduardo Riera           Data  23.09.98 
Ĵ
Descrio  Rotina de Exclusao dos Chamados Tecnicos                   
Ĵ
Sintaxe    ExpL1 := At300Exclu(ExpC1,ExpN1,ExpN2)                     
Ĵ
Retorno    ExpL1 -> Concluiu a operacao                               
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       TECA300                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
27/12/2006 Conrado Q.    Bops 115746: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
17/07/2007 Conrado Q.    Bops 128851: Analisa o retorno do P.E.      
                         AT300Exc.                                   
ٱ


/*/
Function At300Exclu(cAlias,nReg,nOpc)

Local oDlg		:= Nil			// Objeto do dilogo exibido
Local oSay		:= Nil			// Objeto do say exibido
Local oGetD		:= Nil			// Objeto do getdados exibido
Local nOpcA		:= 0			// Se 1 o usurio pressionou OK se 0 o usurio pressionou cancelar
Local aObjects	:= {} 			// Array com os objetos exibidos
Local aPosObj	:= {} 			// Array com as posies dos objetos exibidos
Local aSizeAut	:= {}			// Array com os tamanhos automticos
Local aPosGet	:= {}			// Posio do objeto Get
Local lRetorno	:= .F.			// Se o usurio confirmou a alterao e a gravao ocorreu com sucesso
Local nSaveSX8	:= GetSX8Len()	// Nmero gerado para identificao do registro
Local cSeek		:= ""			// Seek para montagem da aCols
Local cWhile	:= ""			// While para montagem da aHeader
Local aTravas	:= {}			// Campos que foram travados
Local lTravas	:= .T.			// Se todos os campos foram travados com sucesso
Local lExclui	:= .T.			// Se poder ocorrer a excluso ou no
Local lRet		:= .T.			// Retorno do P.E. AT300EXC.

Private aTela	:= {}			// Array da tela
Private aGets	:= {}			// Array dos gets
Private aHeader := {}			// Cabealho do GetDados
Private aCols   := {}			// Itens do GetDados
Private INCLUI  := .F.			// Informa que no  incluso

If ExistBlock("AT300EXC")
	lRet := Execblock("AT300EXC",.F.,.F.)
	If ValType( lRet ) == "L"
		lExclui := lRet
	EndIf
Endif

//Ŀ
//Trava os registros necessarios                                          
//
If !AtTravaReg( "AB1", aTravas )
	lTravas := .F.
EndIf
//Ŀ
// Cria Variaveis de Memoria da Enchoice                
//
RegToMemory( "AB1", .F. ) 

//Ŀ
//Inicializa as variaveis Virtuais do Programa                            
//
DbSelectArea("SA1")
DbSetOrder(1)
DbSeek(xFilial("SA1")+M->AB1_CODCLI+M->AB1_LOJA)
M->AB1_NOMCLI := SA1->A1_NOME

If Len(aHeader) == 0 .AND. Len(aCols) == 0 .AND. lTravas
	//Ŀ
	//Montagem aHeader, aCols
	//
	cSeek	:= xFilial("AB2")+M->AB1_NRCHAM
	cWhile	:= "AB2->AB2_FILIAL+AB2->AB2_NRCHAM"
	
	If !FillGetDados(	nOpc			,"AB2"		,1				,cSeek			,;
						{|| &cWhile }	,{|| .T. }	,/*aNoFields*/	,/*aYesFields*/	,; 
						/*lOnlyYes*/	,/*cQuery*/	,/*bMontCols*/	,/*lEmpty*/		,;
						/*aHeaderAux*/	,/*aColsAux*/	,/*bAfterCols*/	,{|| AtTravaReg("AB2", aTravas) .AND. At300Verif(nOpc) }	)
		lTravas := .F.
	Endif
Endif

If ( lTravas .AND. lExclui )
	If Type("lAt300Auto")=="U" .OR. !lAt300Auto

		//Ŀ
		//Monta tela de entrada                                                   
		//
		                 
		aSizeAut := MsAdvSize() 
		aObjects := {} 
		aAdd( aObjects, { 315,  70, .T., .T. } )
		aAdd( aObjects, { 100, 100, .T., .T. } )
		aAdd( aObjects, { 100,  14, .T., .F. } )
		
		aInfo := { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 } 
		
		aPosObj := MsObjSize( aInfo, aObjects ) 
		
		//Ŀ
		//Monta tela de entrada                                                   
		//
		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSizeAut[7],0 TO aSizeAut[6],aSizeAut[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME 
		
		EnChoice( cAlias, nReg, nOpc, , , , , aPosObj[1], , 3 , , , , , , .T. )
		
		M->AB1_NOMCLI := SA1->A1_NOME
		
		oGetd:=MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"At300LinOk","At300TudOk","+AB2_ITEM",.F.)
		oGetd:oBrowse:bChange := {|| At300Rodape(),.T.}
		
		nLinSay  := aPosObj[ 3,1 ] 
		nColSay  := aPosObj[ 3,2 ] 
	
		aPosGet := MsObjGetPos(aSizeAut[3]-aSizeAut[1],315,;
				{{005,060,075,130,145,200,230,285}} )

		aCtrRodape := {} 
	
		@ nLinSay ,aPosGet[1,1] SAY STR0008			SIZE 055,007 PIXEL	//"Contrato: "
		@ nLinSay ,aPosGet[1,2] SAY oSay PROMPT ""		 		SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-CONT", oSay } ) 	
		@ nLinSay ,aPosGet[1,3] SAY STR0009			SIZE 055,007 PIXEL	//"Garantia: "
		@ nLinSay ,aPosGet[1,4] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-GARA", oSay } ) 		
		@ nLinSay ,aPosGet[1,5] SAY STR0010			SIZE 055,007 PIXEL	//"Preventiva:"
		@ nLinSay ,aPosGet[1,6] SAY oSay PROMPT ""	 			SIZE 030,007 PIXEL
		aAdd( aCtrRodape, { "R-PREV", oSay } ) 			
		@ nLinSay  + 8,aPosGet[1,1] SAY STR0011			SIZE 055,007 PIXEL	//"Chamado Tcnico:"
		@ nLinSay  + 8,aPosGet[1,2] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-CHAM", oSay } ) 				
		@ nLinSay  + 8,aPosGet[1,3] SAY STR0012			SIZE 055,007 PIXEL	//"Oramento:"
		@ nLinSay  + 8,aPosGet[1,4] SAY oSay PROMPT ""	 			SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-ORCA", oSay } ) 					
		@ nLinSay  + 8,aPosGet[1,5] SAY STR0013			SIZE 055,007 PIXEL	//"Ordem Servio:"
		@ nLinSay  + 8,aPosGet[1,6] SAY oSay PROMPT ""		 		SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-OSRV", oSay } ) 						
		@ nLinSay ,aPosGet[1,7] SAY STR0014			SIZE 055,007 PIXEL	//"Obsolescncia:"
		@ nLinSay ,aPosGet[1,8] SAY oSay PROMPT "" 				SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-OBSO", oSay } ) 							
		@ nLinSay  + 8,aPosGet[1,7] SAY STR0015			SIZE 055,007 PIXEL	//"              "
		@ nLinSay  + 8,aPosGet[1,8] SAY oSay PROMPT ""				SIZE 015,007 PIXEL
		aAdd( aCtrRodape, { "R-MENS", oSay } ) 							
			
		At300Rodape(aCols[1][aScan(aHeader,{|x|AllTrim(x[2])=="AB2_CODPRO"})],aCols[1][aScan(aHeader,{|x|AllTrim(x[2])=="AB2_NUMSER"})])
		ACTIVATE MSDIALOG oDlg ;
		   ON INIT At300Bar(oDlg,;
			{||nOpcA:=1,if(oGetd:TudoOk(),If(!obrigatorio(aGets,aTela),nOpcA := 0,oDlg:End()),nOpcA := 0)},;
			{||oDlg:End()},nOpc)
	Else
		If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)}) .AND.;
			MsGetDAuto(aAutoItens,"At300LinOk",{|| At300TudOk()},aAutoCab,aRotina[nOpc][4])
			nOpcA := 1
		EndIf
	EndIf
	If ( nOpcA == 1 )
		Begin Transaction
			aT300Grava(3)
			EvalTrigger()
		End Transaction
		While ( GetSX8Len() > nSaveSx8 )
			ConfirmSx8()
		End           
		lRetorno := .T. 
	Else
		While ( GetSX8Len() > nSaveSx8 )
			RollBackSx8()
		End
	EndIf
Else
	While ( GetSX8Len() > nSaveSx8 )
		RollBackSx8()
	End
EndIf 	
	
//Ŀ
//Efetua o destravamento dos registros travados.
//
AtDestravaReg( aTravas )

DbSelectArea( cAlias )
DbSetOrder(1)
Return( lRetorno ) 

/*/


Ŀ
Funcao    At300Efet  Autor  Eduardo Riera          Data  02.10.98 
Ĵ
Descrio  Efetiva Chamados Tecnicos                                  
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At300Efet(cAlias,nReg,nOpc)

Local aSavRot 	:= aClone(aRotina)			// aRotina da janela anterior
Local cQuery  	:= ""						// Query
Local cArqInd 	:= CriaTrab(,.F.)			// Arquivo temporrio de trabalho
Local cMarca	:= GetMark()				// Marcao
Local nIndex	:= 0						// ndice do AB1
Local lAT300Efe	:= ExistBlock("AT300Efe")	// Se existe ou no o P.E. AT300Efe
Local aAreaAB1	:= AB1->(GetArea())
Private cFiltroAB1 := ""

aRotina := { 	{ STR0016,"At300Visua",0,2},;	//"Visual   "
				{ STR0017,"At300GrvOr",0,4},;	//"Oramento"	
				{ STR0018,"At300GrvOs",0,4},;	//"ord.Servio"
				{ STR0039,"At300GrvHd",0,4} }	//"Help Desk"
					
//Ŀ
//P.E. para alterao dos botes exibidos na efetivao da O.S.
//
If lAT300Efe
	ExecBlock("AT300Efe",.F.,.F.)
EndIf
					
//Ŀ
// Parametros                                                             
//                                                                        
// MV_PAR01 - Cliente de                                                  
// MV_PAR02 - Cliente ate                                                 
// MV_PAR03 - Emissao de                                                  
// MV_PAR04 - Emissao ate                                                 
// MV_PAR05 - Chamado de                                                  
// MV_PAR06 - Chamado ate                                                 
//
If ( Pergunte("ATA300",.T.) )
	cQuery += "AB1_FILIAL=='"+xFilial("AB1")+"'.AND."
	cQuery += "AB1_STATUS=='A'.AND."
	cQuery += "AB1_CODCLI>='"+MV_PAR01+"'.AND."
	cQuery += "AB1_CODCLI<='"+MV_PAR02+"'.AND."
	cQuery += "Dtos(AB1_EMISSA)>='"+Dtos(MV_PAR03)+"'.AND."
	cQuery += "Dtos(AB1_EMISSA)<='"+Dtos(MV_PAR04)+"'.AND."
	cQuery += "AB1_NRCHAM>='"+MV_PAR05+"'.AND."
	cQuery += "AB1_NRCHAM<='"+MV_PAR06+"'"
	DbSelectArea("AB1")
	DbSetOrder(1)
	IndRegua("AB1",cArqInd,IndexKey(),,cQuery)
	nIndex := RetIndex("AB1")
	#IFNDEF TOP
		dbSetIndex(cArqInd+OrdBagExt())
	#ENDIF
	cFiltroAB1 := AB1->(DbFilter())
	DbGoTop()
	DbSetOrder(nIndex+1)
	If ( !Eof() .AND. !Bof() )
		MarkBrow("AB1","AB1_OK",,,,cMarca)
	Else
		Help(" ",1,"REGNOIS")
	EndIf
	DbSelectArea("AB1")
	RetIndex("AB1")
	dbClearFilter()
	Ferase(cArqInd+OrdBagExt())
EndIf
//Ŀ
//Retorna as Situacao de Entrada                                          
//
aRotina := aClone(aSavRot)
AB1->(DbCloseArea())
DBSelectArea("AB1")
RestArea(aAreaAB1)
Return(.T.)


/*

Ŀ
Funo    At300Bar   Autor  Eduardo Riera          Data  21.09.98 
Ĵ
Descrio  Mostra a EnchoiceBar na tela                               
Ĵ
 Uso       TECA300                                                    
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL. 					  
Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO					  
Ĵ
Cleber M.     27/10/0587808  Alterada a chamada da rotina de Base   
                             Instalada 							  
Conrado Q.    23/10/06111294Quando for visualizacao do system tracke 
                            nao exibe o botao "System Tracker"       
Hanna C.      |30/03/07|9.12  Bops 118469 -Alterado o nome dos Bitmaps
        	             |      definidos pela Engenharia p/ Protheus 10
ٱ


*/
Static Function At300Bar(	oDlg	,bOk	,bCancel	,nOpc,;
	   						oGetD	,oEnch )

Local lTECA300   	:= AtIsRotina("ATC010CON").OR.AtIsRotina("ATC020CON")		// Indica se pertence a rotina TECA300
Local aButtons   	:= { {"SUGESTAO" ,{|| At300bFaq()}, STR0029, STR0029} }	// "F.A.Q." 
Local aUsButtons 	:= {}														// Array de botoes de usuario
Local aAcesso	 	:= {.T., .T., .T.}											// Permisses de visualizao dos botes
Local aAT300ACE		:= {}														// Permisses retornadas do ponto de entrada AT300ACE

If ExistBlock( "AT300ACE" )
	If ValType( aAT300ACE := ExecBlock( "AT300ACE", .F., .F. ) ) == "A"
		aAcesso := aAT300ACE
	EndIf
EndIf

If !lTeca300
	If aAcesso[1]
		aAdd(aButtons,{"PRODUT2"   ,{|| At300BPro()}, STR0026, STR0041})  //"Histrico do Equipamento..."
	EndIf
	If aAcesso[2]
		aAdd(aButtons,{"POSCLI"    ,{|| At300BCli()}, STR0027, STR0042})  //"Histrico do Cliente..."
	EndIf
	If aAcesso[3]
		aAdd(aButtons,{"NOTE"      ,{|| At300BInst()  }, STR0028, STR0043})  //"Cliente x Equipamento..."
	EndIf

	If nOpc == 3 	
		aAdd(aButtons,{"bmpincluir",{|| At300Carga( oGetD, @oEnch )}, STR0038, STR0044 }) // "Carrega equipamento"
	EndIf 	

	If nOpc == 2 .AND. !AtIsRotina("AT300TRACK") 	
		aAdd(aButtons,{"bmpord1",{|| At300Track()}, STR0040, STR0045 }) // "System Tracker"
	EndIf 	
	
	aAdd(aButtons,{"IMPRESSAO" ,{|| TECR300(M->AB1_NRCHAM)}, STR0030, STR0046}) //"Impresso do Chamado Gravado"
	
EndIf
          
//Ŀ
// Adiciona botoes do usuario na EnchoiceBar                              
//

If ExistBlock( "AT300BUT" ) 
	If ValType( aUsButtons := ExecBlock( "AT300BUT", .F., .F. ) ) == "A"
		AEval( aUsButtons, { |x| aAdd( aButtons, x ) } ) 	 	
	EndIf 	
EndIf 	

Return (EnchoiceBar(oDlg,bOK,bcancel,,aButtons))


/*

Ŀ
Funo    At300BInst Autor  Cleber Martinez        Data  27.10.05 
Ĵ
Descrio  Chama a rotina de Base Instalada                           
Ĵ
 Uso       TECA300                                                    
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL. 					  
Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO					  
Ĵ
Conrado Q.    14/07/0710     -BOPS 129711: Adicionado controle de   
                            acesso a base instalada atravs da       
                            manuteno do chamado tcnico.           
ٱ


*/
Static Function At300BInst()

Local nBack		:= 0	// Backup da variavel de indice n
Local aHeadBack	:= {}	// Variavel de backup do aHeader
Local aColsBack	:= {}	// Variavel de backup do aCols

//Ŀ
//Acesso: "Acessa Base Instalada no Cad. Tcnic".
//
If VerSenha(157)
	//Ŀ
	// Guarda os valores originais 
	//
	nBack		:= n
	aHeadBack	:= AClone( aHeader )
	aColsBack	:= AClone( aCols )
	
	//Ŀ
	// Faz a chamada da rotina de Base Instalada			
	//
	TECA040()
	
	//Ŀ
	// Restaura os dados originais   
	//
	aHeader		:= AClone( aHeadBack )
	aCols		:= AClone( aColsBack )
	n			:= nBack
Else
	Help(" ",1,"AT300NOACE")
EndIf

Return .T.

/*/


Ŀ
Funcao    At300VlCli Autor  Eduardo Riera          Data  22.09.98 
Ĵ
Descrio  Validacao do Cliente                                       
Ĵ
Retorno    Logico                                                     
Ĵ
Parametros Nenhum                                                     
                                                                      
ٱ


/*/
Function At300VlCli()

Local lRetorno := .F.
Local aArea       := { Alias() , IndexOrd() , RecNo() }
Local cCampo      := ReadVar()
Local cSeekAA3    := ""
Local cQuery      := ""
Local cAliasQry   := ""
Local uConteudo   := &(ReadVar())
Local nCountAA3   := 0 
Local nRecnoAA3   := 0 

//Ŀ
// Verifica se o atendimento foi incluido pelo telemarketing              
//
If Empty( M->AB1_NUMTMK ) 		
	Do Case
		Case ( "AB1_CODCLI"$cCampo )
			
				If ( SA1->A1_COD==uConteudo )
					uConteudo += SA1->A1_LOJA
				ElseIf !Empty(M->AB1_LOJA)
					uConteudo += M->AB1_LOJA
				EndIf
				DbSelectArea("SA1")
				DbSetOrder(1)
				If ( DbSeek(xFilial("SA1")+uConteudo) )
					If !Empty(M->AB1_LOJA)
						M->AB1_NOMCLI := SA1->A1_NOME
					EndIf
					lRetorno := .T.
					lRetorno := RegistroOk("SA1")
				Else
					Help(" ",1,"REGNOIS")
				EndIf
				
		Case ( "AB1_LOJA"$cCampo )
			DbSelectArea("SA1")
			DbSetOrder(1)
			If ( DbSeek(xFilial("SA1")+M->AB1_CODCLI+uConteudo) )
				M->AB1_NOMCLI := SA1->A1_NOME
				lRetorno := .T.
				lRetorno := RegistroOk("SA1")
			Else
				Help(" ",1,"REGNOIS")
			EndIf
	EndCase
Else 
	lRet := .F. 
	Help( " ", 1, "AT300CLITMK" ) 		
EndIf 
           
If lRetorno 
	If Type("lAt300Auto")=="U" .OR. !lAt300Auto

		//Ŀ
		// Rotina para preenchimento automatico da base instalada                 
		//
		If Len( aCols ) == 1
		
			#IFDEF TOP
	
				cAliasQry := GetNextAlias() 		
				cQuery    := ""                            
				cQuery += "SELECT COUNT(*) TOTAL FROM " + RetSqlName( "AA3" ) + " " 
				cQuery += "WHERE " 
				cQuery += "AA3_FILIAL='" + xFilial( "AA3" ) + "' AND " 
				cQuery += "AA3_CODCLI='" + SA1->A1_COD      + "' AND " 
				cQuery += "AA3_LOJA='"   + SA1->A1_LOJA     + "' AND " 
				cQuery += "D_E_L_E_T_=' '" 
		
				cQuery := ChangeQuery( cQuery ) 
				
				dbUseArea( .t., "TOPCONN", TcGenQry( ,,cQuery ), cAliasQry, .F., .T. )
				
				TcSetField( cAliasQry, "TOTAL", "N", 8, 0 ) 
				
				nCountAA3 := ( cAliasQry )->TOTAL
				
				//Ŀ
				// Verifica se o cliente possui um unico registro na base instalada       
				//
				If nCountAA3 == 1
					( cAliasQry )->( dbCloseArea() ) 
					
					cAliasQry := GetNextAlias() 		
					cQuery    := ""                            
					
					cQuery += "SELECT R_E_C_N_O_ AA3RECNO FROM " + RetSqlName( "AA3" ) + " " 
					cQuery += "WHERE " 
					cQuery += "AA3_FILIAL='" + xFilial( "AA3" ) + "' AND " 
					cQuery += "AA3_CODCLI='" + SA1->A1_COD      + "' AND " 
					cQuery += "AA3_LOJA='"   + SA1->A1_LOJA     + "' AND " 
					cQuery += "D_E_L_E_T_=' '" 
			
					cQuery := ChangeQuery( cQuery ) 
					
					dbUseArea( .t., "TOPCONN", TcGenQry( ,,cQuery ), cAliasQry, .F., .T. )
					
					TcSetField( cAliasQry, "AA3RECNO", "N", 8, 0 ) 
					
					If !Eof() 
						nRecnoAA3 := ( cAliasQry )->AA3RECNO  
					EndIf   
					
				EndIf					
		
				( cAliasQry )->( dbCloseArea() ) 
				DbSelectArea( "AA3" ) 			
		
			#ELSE 
			
				//Ŀ
				// Verifica se o cliente possui um unico registro na base instalada       
				//
				nCountAA3 := 0 
				cSeekAA3  := xFilial( "AA3" ) + SA1->A1_COD + SA1->A1_LOJA 
				AA3->( DbSetOrder( 1 ) ) 
				If AA3->( DbSeek( cSeekAA3 ) ) 
					nRecNoAA3 := AA3->( Recno() ) 
					While !AA3->( Eof() ) .AND. AA3->AA3_FILIAL + AA3->AA3_CODCLI + AA3->AA3_LOJA == cSeekAA3
						nCountAA3++
						If nCountAA3 > 1 
							Exit								
						EndIf 																					
						AA3->( dbSkip() ) 										
					End 	
				EndIf 	
				
		   #ENDIF 
																	
			If nCountAA3 == 1   
				//Ŀ
				// Alimenta automaticamente o browse                                      
				//
				AA3->( DbGoTo( nRecnoAA3 ) )
				If At300Eqpto( { "AB2_CODPRO", AA3->AA3_CODPRO } ) 
					GDFieldPut( "AB2_CODPRO", AA3->AA3_CODPRO ) 
					GDFieldPut( "AB2_NUMSER", AA3->AA3_NUMSER ) 
					oGetDUS:oBrowse:Refresh() 				
				EndIf 			
  			Else
				AA3->( DbGoTo( nRecnoAA3 ) )
				GDFieldPut( "AB2_CODPRO", AA3->AA3_CODPRO ) 
				GDFieldPut( "AB2_NUMSER", AA3->AA3_NUMSER ) 
				oGetDUS:oBrowse:Refresh() 				
			EndIf 					
		EndIf
	EndIf 				
EndIf

If ( aArea[1] <> "SA1" )
	DbSelectArea(aArea[1])
	DbSetOrder(aArea[2])
	DbGoTo(aArea[3])
EndIf
Return(lRetorno)


/*/


Ŀ
Funo    At300Eqpto Autor  Eduardo Riera          Data  22.09.98 
Ĵ
Descrio  Valida a amarracao Produto X Equipamento                   
Ĵ
Sintaxe    Void At300Eqpto()                                          
Ĵ
 Uso       TECA300                                                    
ٱ


/*/
Function At300Eqpto( aConteudo )

Local lRetorno    := .F.
Local lTeca310    := AtIsRotina( "AT310INCLU" ) 
Local cCampo      
Local uConteudo   
Local nPosProd    := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRO" })
Local aArea       := GetArea()

If ValType( aConteudo ) == "A"
	cCampo    := aConteudo[ 1 ]
	uConteudo := aConteudo[ 2 ]                    
Else
	cCampo    := ReadVar()
	uConteudo := &(ReadVar())
EndIf

If !lTeca310
	At300Rodape(AA3->AA3_CODPRO,AA3->AA3_NUMSER)
EndIf 	

If !Empty(M->AB1_LOJA)	
	Do Case
		Case ( "AB2_CODPRO"$cCampo )
			DbSelectArea("AA3")
			DbSetOrder(1)
			If ( DbSeek(xFilial("AA3")+M->AB1_CODCLI+M->AB1_LOJA+uConteudo) )
				lRetorno := .T.
			Else
				Help(" ",1,"REGNOIS")
			EndIf
		Case ( "AB2_NUMSER"$cCampo )
			DbSelectArea("AA3")
			DbSetOrder(1)
			If ( DbSeek(xFilial("AA3")+M->AB1_CODCLI+M->AB1_LOJA+aCols[n][nPosProd]+uConteudo) )
				lRetorno := .T.
			Else
				Help(" ",1,"REGNOIS")
			EndIf 
			If !lTeca310		
				At300Rodape(AA3->AA3_CODPRO,AA3->AA3_NUMSER)
			EndIf 	
	EndCase
EndIf
If ( !lRetorno )       
	If !lTeca310		
		At300Rodape()
	EndIf 	
EndIf

RestArea( aArea ) 

Return(lRetorno)


/*/


Ŀ
Funcao    At300LinOk Autor  Eduardo Riera          Data  23.09.98 
Ĵ
Descrio  Valicao da LinhaOk                                         
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
 15/02/07  Cleber M.	 Bops 115746: Alteracao para validar tambem  
			 				 a primeira linha do aCols.	          	   
 21/05/07  Conrado Q.    -Bops 125499: Incluso do PE AT300LLK para  
                         ser utilizado em validaes adicionais.     
ٱ


/*/

Function At300LinOk()

Local nUsado   := Len(aHeader)
Local lRetorno := .T.
Local nPosProd := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRO" })
Local nPosNSer := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_NUMSER" })
Local nPosPrb  := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRB" })
Local nCntFor  := 0

If ( Len(aCols)>=1 .OR. !Empty(aCols[n][nPosProd] ) )
	If !aCols[n][nUsado+1] 
		If (  Empty(aCols[n][nPosProd]) .OR.;
				Empty(aCols[n][nPosNser]) .OR.;
				Empty(aCols[n][nPosPrb]) )
			Help(" ",1,"AT300LIN01")
			lRetorno := .F.
		EndIf
		If ( lRetorno )
			For nCntFor := 1 To Len(aCols)
				If (  aCols[n][nPosProd]+aCols[n][nPosNSer]+aCols[n][nPosPrb]==;
						aCols[nCntFor][nPosProd]+aCols[nCntFor][nPosNSer]+aCols[nCntFor][nPosPrb] .AND.;
						n <> nCntFor .AND. !aCols[nCntFor][nUsado+1] )
					Help(" ",1,"AT300LIN02")
					lRetorno := .F.
				EndIf
			Next nCntFor
		EndIf
		If ( lRetorno )
			DbSelectArea("AA3")
			DbSetOrder(1)
			If ( !DbSeek(xFilial("AA3")+M->AB1_CODCLI+M->AB1_LOJA+aCols[n][nPosProd]+aCols[n][nPosNSer]) )
				Help(" ",1,"AT300LIN03")
				lRetorno := .F.
			EndIf
		EndIf
	Else
		//Ŀ
		// Chama o ponto para validar a exclusao da linha           
		//
		If lRetorno
			If ExistBlock( "AT300LDL" ) 	
				lRetorno := ExecBlock( "AT300LDL", .F., .F. ) 
			EndIf 
		EndIf 
	EndIf	
EndIf   

//Ŀ
// Validacao do Usuario                                         
//
If ExistBlock( "AT300LLK" ) 
   lRetorno := ExecBlock( "AT300LLK", .F., .F., { lRetorno } ) 
EndIf 	   
Return(lRetorno)

/*/


Ŀ
Funcao    At300TudOk Autor  Eduardo Riera          Data  23.09.98 
Ĵ
Descrio  Valicao da TudoOk                                          
Ĵ
Sintaxe    ExpL1 := At300TudOk()                                      
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    ExpL1 -> Validacao                                         
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
 26/04/07  Conrado Q.    Bops 124928: Adicionado PE AT300TDD e       
                         AT300TDA para a validao dos campos.       
ٱ


/*/

Function At300TudOk()

Local lRetorno := .T.
Local nPosPrd  := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRO"})
Local nPosnSer := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_NUMSER"})
Local nUsado   := Len(aHeader)
Local nCntFor  := 0 
For nCntFor := 1 To Len(aCols)
	If ( lRetorno .AND. !aCols[nCntFor][nUsado+1] )
		DbSelectArea("AA3")
		DbSetOrder(1)
		If ( !DbSeek(xFilial("AA3")+M->AB1_CODCLI+M->AB1_LOJA+aCols[nCntFor][nPosPrd]+aCols[nCntFor][nPosNSer]) )
			Help(" ",1,"AT300TUDOK")
			lRetorno := .F.
		EndIf
	EndIf
Next nCntFor

//Ŀ
// Faz a chamada do ponto de entrada 
//
If INCLUI
	If lRetorno .AND. ExistBlock( "AT300TDD" ) 
		lRetorno := ExecBlock( "AT300TDD", .F., .F., { lRetorno } )
	EndIf 
Else	
	If lRetorno .AND. ExistBlock( "AT300TDA" ) 
		lRetorno := ExecBlock( "AT300TDA", .F., .F., { lRetorno } )
	EndIf 
EndIf  

If INCLUI .And. AB1->(DbSeek(xFilial("AB1")+M->AB1_NRCHAM))      
	Help(" ",1,"NODELETA",,STR0060,2,0) //Cdigo do chamado tcnico j gravado.
	lRetorno := .F. 
EndIf

Return(lRetorno)

/*/


Ŀ
Funcao    At300Grava Autor  Eduardo Riera          Data  22.09.98 
Ĵ
Descrio  Efetua a Gravacao dos Chamados Tecnicos                    
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpN1 -> Operacao : 1-Inclusao/2-Alteracao/3-Exclusao      
           ExpN2 -> Tipo de inclusao na fila de Help Desk             
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
19/07/2006 Cleber M.     Bops 102765: Alteracao para gravar o campo  
                         AB1_ATEND em maiusculas, devido ao filtro   
                         dos relatorios serem somente em maiusculas. 
10/01/2007 Conrado Q.    Bops 115749: Montagem do aCols adaptada para
                         utilizao do Walk-Thru.                    
17/01/2007 Conrado Q.    Bops 115748: Montagem do aCols adaptada para
                         utilizao do Walk-Thru.                    
ٱ


/*/

Function At300Grava(nOpcao,nTipoHD)

Local aArea      := GetArea() 
Local aAreaAb1   := AB1->( GetArea() ) 
Local aAreaAb2   := AB2->( GetArea() )
Local aColsAB2   := AClone( aCols ) 
Local aHeaderAB2 := AClone( aHeader ) 
Local aOrcamento := {}
Local aOs        := {}            
Local aCpoQNC 	 := {}    						   			// Array com Campos  que  sero preenchidos na FNC
Local aRetQNC 	 := {}    									// Array retorno com dados a serem gravados na FNC

Local bCampo     := {|x| FieldName(x) }

Local cSequen    := ""
Local cPrxSeq    := ""
Local cPriori    := ""
Local cNumHDE    := ""
Local cMemo      := ""
Local cNumOrc    := ""
Local cNumOS     := ""
Local cTipoAnt   := "0"
Local cTipoAB4   := ""
Local cTipoAB7   := ""
Local cCodUsr    := ""
Local cPrxTec    := ""
Local cHrVisit   := "" 
Local cDesOco    := ""     									// Descricao da Ocorrencia

Local dDtVisit   := Ctod("")

Local lStatus    := .T.
Local lGravou    := .F.
Local lFoundAB1  := .F. 
Local lFoundAB4  := .F.
Local lFoundAB7  := .F.
Local lCria      := .F.           
Local lAtuABL    := .F. 
//Ŀ
// Variaveis usadas na Integracao com Controle de Nao-Conformidades 
//     
Local lGravaFNC  := .F. 									// Define se ira ser aberta uma FNC 
Local lDelFNC    := .T. 									// Indica se a FNC pode ser deletada

Local nCntFor    := 0
Local nCntFor2   := 0
Local nPosProd   := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRO" })
Local nPosItem   := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_ITEM"})
Local nPosMemo 	 := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_MEMO2"})	//Posio do campo AB2_MEMO2 no aHeader.
Local nPMemoAB7	 := 0 				
Local nUsado     := Len(aHeader)
Local nPosCampo  := 0 
Local nOpcOs     := 0 
Local nOpcOrc    := 0                          
Local nPosAhead  := 0       
Local nRecnoAB1  := 0 

Local uCampo     := ""   

Private aColsAB4     := {}
Private aColsAB5     := {}
Private aHeaderAB4   := {}
Private aHeaderAB5   := {}
Private aColsAB7     := {}
Private aColsAB8     := {}
Private aHeaderAB7   := {}
Private aHeaderAB8   := {}       

nTipoHD := If( ValType( nTipoHD ) == "N", nTipoHD, 1 ) 

Do Case
	Case nOpcao <> 3
		aT400Monta()
		aT450Monta()  

		//Ŀ
		// Verifica se existe um item valido no acols            
		//
		lGravou := !Empty( Ascan( aCols, { |x| !x[nUsado+1] .AND. !Empty(x[nPosProd]) } ) )
		
		DbSelectArea("SA1")
		DbSetOrder(1)
		DbSeek(xFilial("SA1")+M->AB1_CODCLI+M->AB1_LOJA)
		
		DbSelectArea("AB1")
		DbSetOrder(1)
		DbSeek(xFilial("AB1")+M->AB1_NRCHAM)
		
		lFoundAB1 := AB1->( Found() ) 
		
		If lFoundAB1 
			nRecnoAB1 := AB1->( Recno() ) 
		EndIf 	

		//Ŀ
		// Grava arquivo AB1 (Cabecalho da Chamado Tecnico)      
		//
		If ( lGravou )
			RecLock("AB1",!Found())
			For nCntFor := 1 To FCount()
				If ( "FILIAL"$Field(nCntFor) )
					AB1->(FieldPut(nCntFor,xFilial("AB1")))
				Else
					AB1->(FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor))))
				EndIf
			Next nCntFor
            
			AB1->AB1_ATEND	:= Upper(M->AB1_ATEND)
			AB1->AB1_REGIAO := SA1->A1_REGIAO
			If ( Empty(AB1->AB1_HORAF) )
				AB1->AB1_HORAF  := Time()
			EndIf
			
			nRecnoAB1 := AB1->( Recno() ) 
			
			AB1->( FKCommit() ) 
			aAreaAb1 := AB1->( GetArea() )
		EndIf 	
		
		//Ŀ
		//Grava os Itens do Chamado Tecnico                                       
		//
		DbSelectArea("AB2")
		For nCntFor := 1 To Len(aCols)
			If ( !aCols[nCntFor][nUsado+1] .AND. !Empty(aCols[nCntFor][nPosProd]) )
				DbSelectArea("AB2")
				DbSetOrder(1)
				If ( DbSeek(xFilial("AB2")+M->AB1_NRCHAM+aCols[nCntFor][nPosItem]) )
					RecLock("AB2",.F.)
					cTipoAnt := AB2->AB2_TIPO
				Else
					RecLock("AB2",.T.)
					cTipoAnt := "0"
				EndIf
				For nCntFor2 := 1 To nUsado
					If ( aHeader[nCntFor2][10] <> "V" )
						AB2->(FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2]))
						//Ŀ
						//Caso  Haja   integracao  com  o  modulo QNC devera ser 
						//habilitada a  gravacao  dos dados  se  o canpo GeraFNC 
						//estiver  igual a "S".                                  
						//
						If ( AllTrim(aHeader[nCntFor2][2])=="AB2_CODPRB" )
							//Ŀ
							//Caso a opcao  Gera FNC estiver  igual a  nao e  o campo  
							//NumFNC  estiver preenchido nao  geraremos  a FNC         
							//
                            If AtVerOcor(AB2->AB2_CODPRB)
	                            If !Empty(AllTrim(AB2->AB2_CODFNC))
									lGravaFNC := .F.
								Else
								 	If AB2->AB2_TIPO == "1" // Na tela de Chamado so sera gerada para o chamado
								   		lGravaFNC := .T.
								  	Else
										lGravaFNC := .F.
								  	EndIf
								EndIf
						  	Else
								lGravaFNC := .F.
	     					EndIf
						EndIf
					Else
						If ( AllTrim(aHeader[nCntFor2][2])=="AB2_MEMO2" )
							cMemo := aCols[nCntFor][nCntFor2]
						EndIf
					EndIf
				Next nCntFor2              
				
				//Ŀ
				// Grava os campos fixos                                    
				//
				DbSelectArea("AA3")
				DbSetOrder(1)
				DbSeek(xFilial("AA3")+M->AB1_CODCLI+M->AB1_LOJA+AB2->AB2_CODPRO+AB2->AB2_NUMSER)
				AB2->AB2_FILIAL   := xFilial("AB2")
				AB2->AB2_NRCHAM   := M->AB1_NRCHAM
				AB2->AB2_STATUS   := If(AB2->AB2_TIPO=="1","A","E")
				AB2->AB2_CODFAB   := AA3->AA3_CODFAB
				AB2->AB2_LOJAFA   := AA3->AA3_LOJAFA
				AB2->AB2_EMISSA   := M->AB1_EMISSA
				AB2->AB2_CODCLI	:= M->AB1_CODCLI
				AB2->AB2_LOJA		:= M->AB1_LOJA
				If ( Empty(AB2->AB2_TIPO) )
					AB2->AB2_TIPO := "1"
				EndIf
				If ( AB2->AB2_TIPO == "1" )
					AB2->AB2_BXHORA := ""
					AB2->AB2_BXDATA := Ctod("")
				Else
					AB2->AB2_BXHORA := Time()
					AB2->AB2_BXDATA := dDataBase
				EndIf
				If ( Empty(AB2->AB2_CLASSI) )
					AB2->AB2_CLASSI := "001"
				EndIf

			 	If nOpcao == 1 	//Inclusao
			  		If !Empty( GDFieldGet("AB2_MEMO2") )
			  			MSMM(NIL,TamSx3("AB2_MEMO2")[1],NIL,cMemo,1,NIL,NIL,"AB2","AB2_MEMO")
			     	EndIf
			 	Else
			  		If Empty(AB2->AB2_MEMO)  	// Inclusao
			    		MSMM(NIL,TamSx3("AB2_MEMO2")[1],NIL,cMemo,1,NIL,NIL,"AB2","AB2_MEMO")
			      	Else                       	// Alteracao
			      		MSMM(AB2->AB2_MEMO,TamSx3("AB2_MEMO2")[1],NIL,cMemo,1,NIL,NIL,"AB2","AB2_MEMO")
			        EndIf
			 	EndIf
							
				MsUnLock()
				AB2->( FKCommit() ) 
				
				If ( lStatus .AND. AB2->AB2_STATUS=="A" )
					lStatus := .F.
				EndIf  
				
				//Ŀ
				// Realiza integracao com o ambiente Controle de Nao-Conformidades 
				//				
				If lGravaFNC 
					If Empty(AllTrim(AB2->AB2_CODFNC))
						aCpoQNC := {}
						cDesOco := ""
						aAdd(aCpoQNC,{"QI2_TPFIC" 	,"1"})
						aAdd(aCpoQNC,{"QI2_ORIGEM"	,"TEC"})
						aAdd(aCpoQNC,{"QI2_DESCR"	,STR0047+AllTrim(AB2->AB2_NRCHAM)+" - "+AB2->AB2_ITEM}) //"CHAMADO - ITEM: "
						cDesOco := Posicione("AAG",1,xFilial("AAG") + AB2->AB2_CODPRB,"AAG_DESCRI")
					    If !Empty(AllTrim(cDesOco))
							cDesOco := STR0048+AB2->AB2_CODPRB+CHR(13)+CHR(10)+" -> "+cDesOco // "Ocorrencia: "
							If !EMPTY(Alltrim(cMemo))
								cDesOco += CHR(13)+CHR(10)+STR0049+CHR(13)+CHR(10)+cMemo // "Comentarios: "
							EndIf
						Else
							If !EMPTY(Alltrim(cMemo))
								cDesOco := STR0049+CHR(13)+CHR(10)+cMemo // "Comentarios: "
							EndIf						
						EndIf						
						aAdd(aCpoQNC,{"QI2_MEMO1", cDesOco}) 														
						aAdd(aCpoQNC,{"QI2_CODCLI"	, AB2->AB2_CODCLI})
						aAdd(aCpoQNC,{"QI2_LOJCLI"	, AB2->AB2_LOJA})
						aAdd(aCpoQNC,{"QI2_CODPRO"	, AB2->AB2_CODPRO})	 
						//Campos especificos da integracao
						aAdd(aCpoQNC,{"QI2_NRCHAM"  , AB2->AB2_NRCHAM})  // Numero do Chamado
						aAdd(aCpoQNC,{"QI2_NUMSER"  , AB2->AB2_NUMSER})  // Numero de Serie do Produto
						aAdd(aCpoQNC,{"QI2_ITEMCH"  , AB2->AB2_ITEM})    // Item do Chamado
 				
						aRetQNC := QNCGERA(1,aCpoQNC)
						//Ŀ
						// Grava o Codigo+Revisao da NC no Chamado					 	 
						//
						RecLock("AB2",.F.)
						AB2->AB2_CODFNC := aRetQNC[2] //Codigo da Nao-conformidade
						AB2->AB2_FNCREV := aRetQNC[3] //Revisao da Nao-conformidade
				 		MsUnLock()
						AB2->( FKCommit() ) 
					EndIf
					lGravaFNC := .F. //Forco a variavel
				EndIf				
				 				
				
				//Ŀ
				// Orcamento                                           
				//
				If ( AB2->AB2_TIPO == "2" )
					DbSelectArea("AB4")
					DbSetOrder(2)
					If ( DbSeek(xFilial("AB4")+AB2->AB2_NRCHAM+AB2->AB2_ITEM) )
						cNumOrc := AB4->AB4_NUMORC
						lFoundAB4 := .T.
						cTipoAB4  := AB4->AB4_TIPO 
					Else
						lFoundAB4 := .F. 	
					EndIf     

					lCria := .T. 													
				
					//Ŀ
					// Caso o item do AB4 exista e possua tipo diferente de Orcamento, nao altera 
					//
					If lFoundAB4 .AND. cTipoAB4 <> "1"                
						lCria := .F.
					EndIf
					
					If lCria                    
						aAdd(aColsAB4,Array(Len(aHeaderAB4)+1))
						For nCntFor2 := 1 To Len(aHeaderAB4)
	
							nPosAhead := aScan(aHeader,{|x| SubStr(AllTrim(x[2]),4)==;
														SubStr(AllTrim(aHeaderAB4[nCntFor2][2]),4)} )
														
						
							If ( nPosAhead<>0 .AND. AllTrim(aHeaderAB4[nCntFor2][2])<>"AB4_TIPO" )
								If AB2->(FieldPos(aHeader[nPosAhead][2])) > 0
									aColsAB4[Len(aColsAB4)][nCntFor2] := AB2->(FieldGet(FieldPos(aHeader[nPosAhead][2])))
								ElseIf AllTrim(aHeader[nPosAhead][2]) == 'AB2_MEMO2' 
								    If  IsInCallStack("AT300ALTER")
									     aColsAB4[Len(aColsAB4)][nCntFor2] := MSMM(AB4->AB4_MEMO)
									else
										 aColsAB4[Len(aColsAB4)][nCntFor2] := MSMM(AB2->AB2_MEMO)	 
									Endif
								EndIf
							Else
								If !IsHeadRec(aHeaderAb4[nCntFor2][2]) .AND. !IsHeadAlias(aHeaderAb4[nCntFor2][2])
									aColsAB4[Len(aColsAb4)][nCntFor2] := CriaVar(aHeaderAb4[nCntFor2][2])
								Endif
							Endif                
							
						Next nCntFor2
						aColsAB4[Len(aColsAb4)][Len(aHeaderAB4)+1] := .F.
						aAdd(aOrcamento, AB2->AB2_NRCHAM+AB2->AB2_ITEM )
					EndIf 	
						
				Else
					//Ŀ
					// Marca p/Excluir o item do Orcamento                 
					//
					If ( cTipoAnt=="2" )
						DbSelectArea("AB4")
						DbSetOrder(2)
						If ( DbSeek(xFilial("AB4")+AB2->AB2_NRCHAM+AB2->AB2_ITEM) )
							cNumOrc := AB4->AB4_NUMORC
						EndIf
						aAdd(aColsAB4,Array(Len(aHeaderAB4)+1))
						For nCntFor2 := 1 To Len(aHeaderAB4)
							nPosAhead := aScan(aHeader,{|x| SubStr(AllTrim(x[2]),4)==;
														SubStr(AllTrim(aHeaderAB4[nCntFor2][2]),4)} )
							If ( nPosAhead<>0 .AND. AllTrim(aHeaderAB4[nCntFor2][2])<>"AB4_TIPO" )
								If !Empty( nPosCampo := AB2->( FieldPos(aHeader[nPosAhead][2] ) ) ) 
						  			aColsAB4[Len(aColsAB4)][nCntFor2] := AB2->(FieldGet( nPosCampo ) )
						  		EndIf	
							Else
								If !IsHeadRec(aHeaderAb4[nCntFor2][2]) .AND. !IsHeadAlias(aHeaderAb4[nCntFor2][2])
									aColsAB4[Len(aColsAb4)][nCntFor2] := CriaVar(aHeaderAb4[nCntFor2][2])
								Endif
							Endif
						Next nCntFor2
						aColsAB4[Len(aColsAb4)][Len(aHeaderAB4)+1] := .T.
						aAdd(aOrcamento,AB2->AB2_NRCHAM+AB2->AB2_ITEM)
					EndIf
				EndIf
				//Ŀ
				// Ordem de Servico                                    
				//
				If ( AB2->AB2_TIPO == "3" )
					DbSelectArea("AB7")
					DbSetOrder(2)
					
					If ( DbSeek(xFilial("AB7")+AB2->AB2_NRCHAM+AB2->AB2_ITEM) )
						cNumOs    := AB7->AB7_NUMOS
						lFoundAB7 := .T.
						cTipoAB7  := AB7->AB7_TIPO 
					Else
						lFoundAB7 := .F. 	
					EndIf                        
					
					lCria := .T. 													
				
					//Ŀ
					// Caso o item do AB7 exista e possua tipo diferente de OS, nao altera 
					//
					If lFoundAB7 .AND. cTipoAB7 <> "1"                
						lCria := .F.
					EndIf
					
					If lCria 
						aAdd(aColsAB7,Array(Len(aHeaderAB7)+1))
						nPMemoAB7 := aScan(aHeaderAB7,{|x| AllTrim(x[2])=="AB7_MEMO2"})
						For nCntFor2 := 1 To Len(aHeaderAB7)
						
							nPosAhead := aScan(aHeader,{|x| SubStr(AllTrim(x[2]),4)==;
									SubStr(AllTrim(aHeaderAB7[nCntFor2][2]),4)} )
							
							If nCntFor2 == nPosMemo	//Alimenta o campo memo observao.
								aColsAB7[Len(aColsAB7)][nPMemoAB7] := MSMM(AB2->AB2_MEMO)
							EndIf
							
							If ( nPosAhead<>0 .AND. AllTrim(aHeaderAB7[nCntFor2][2])<>"AB7_TIPO" )                   
							
								If !Empty( nPosCampo := AB2->( FieldPos(aHeader[nPosAhead][2] ) ) ) 
									aColsAB7[Len(aColsAB7)][nCntFor2] := AB2->(FieldGet( nPosCampo ))
								EndIf 	
							Else
								If IsHeadRec(aHeaderAb7[nCntFor2][2])
									aColsAB7[Len(aColsAb7)][nCntFor2] := 0
								Elseif IsHeadAlias(aHeaderAb7[nCntFor2][2])
									aColsAB7[Len(aColsAb7)][nCntFor2] := "AB7"
								Else
									aColsAB7[Len(aColsAb7)][nCntFor2] := CriaVar(aHeaderAb7[nCntFor2][2])
								Endif
							Endif
								
						Next nCntFor2
						aColsAB7[Len(aColsAB7)][Len(aHeaderAB7)+1] := .F.
						aAdd(aOS,AB2->AB2_NRCHAM+AB2->AB2_ITEM)
					EndIf 	
						
				Else
					//Ŀ
					// Marca p/Excluir o item da OS.                       
					//
					If ( cTipoAnt=="3" )
						DbSelectArea("AB7")
						DbSetOrder(2)
						If ( DbSeek(xFilial("AB7")+AB2->AB2_NRCHAM+AB2->AB2_ITEM) )
							cNumOS := AB7->AB7_NUMOS
						EndIf
						aAdd(aColsAB7,Array(Len(aHeaderAB7)+1))
						nPMemoAB7 := aScan(aHeaderAB7,{|x| AllTrim(x[2])=="AB7_MEMO2"})
						For nCntFor2 := 1 To Len(aHeaderAB7)
							nPosAhead := aScan(aHeader,{|x| SubStr(AllTrim(x[2]),4)==;
													SubStr(AllTrim(aHeaderAB7[nCntFor2][2]),4)} )
							
							If nCntFor2 == nPosMemo	//Alimenta o campo memo observao.
								aColsAB7[Len(aColsAB7)][nPMemoAB7] := MSMM(AB2->AB2_MEMO)
							EndIf
													
							If ( nPosAhead<>0 .AND. AllTrim(aHeaderAB7[nCntFor2][2])<>"AB7_TIPO" )
								If !Empty( nPosCampo := AB2->( FieldPos(aHeader[nPosAhead][2] ) ) )
									aColsAB7[Len(aColsAB7)][nCntFor2] := AB2->(FieldGet( nPosCampo ))
								EndIf 	
							Else
								If IsHeadRec(aHeaderAb7[nCntFor2][2])
									aColsAB7[Len(aColsAb7)][nCntFor2] := 0
								Elseif IsHeadAlias(aHeaderAb7[nCntFor2][2])
									aColsAB7[Len(aColsAb7)][nCntFor2] := "AB7"
								Else
									aColsAB7[Len(aColsAb7)][nCntFor2] := CriaVar(aHeaderAb7[nCntFor2][2])
								Endif
							EndIf
						Next nCntFor2
						aColsAB7[Len(aColsAB7)][Len(aHeaderAB7)+1] := .T. //Deletar
						aAdd(aOS,AB2->AB2_NRCHAM+AB2->AB2_ITEM)
					EndIf
				EndIf
            
				cNumHde := AB2->AB2_NUMHDE 
				lAtuABL := .F. 

				//Ŀ
				// Cria a sequencia na fila de Help desk               
				//
				If ( AB2->AB2_TIPO == "6" )
					If !ABL->(DbSeek(xFilial("ABL")+AB2->AB2_NRCHAM+AB2->AB2_ITEM))
					
						lAtuABL := .T. 
					    
						If nTipoHD == 2 
							cPriori := "000" 
							If Empty(cCodUsr)
								cCodUsr := RetCodUsr() 
							EndIf
							      
							AA1->( DbSetOrder( 4 ) ) 
							If AA1->( DbSeek( xFilial( "AA1" ) + cCodUsr ) ) 
								cPrxTec := AA1->AA1_CODTEC 								                                 																
							EndIf 
						Else	
							cPriori := CriaVar( "ABL_PRIORI" )  
						EndIf								
							
						cPrxSeq := CriaVar( "ABL_PRXSEQ" ) 
						cSequen := GetSXENum( "ABL", "ABL_SEQUEN" )  
						
						DbSelectArea( "ABL" ) 
						RecLock( "ABL", .T. ) 
						ABL->ABL_FILIAL  := xFilial( "ABL" ) 
						ABL->ABL_NRCHAM  := AB2->AB2_NRCHAM + AB2->AB2_ITEM 
						ABL->ABL_SEQUEN  := cSequen 
						ABL->ABL_DTINCL  := dDataBase
						ABL->ABL_HREMIS  := Left( Time(), 5 ) 
						ABL->ABL_SITUAC  := "1"
						ABL->ABL_PRIORI  := cPriori 
						ABL->ABL_PRXSEQ  := cPrxSeq 
						ABL->ABL_REAVAL  := "1" // Avalia na fila 
						ABL->ABL_REAMOT  := "1" // Motivo : Chamado 
						
						If !Empty( cPrxTec ) 
							ABL->ABL_PRXTEC := cPrxTec 
						EndIf 							
						
						ABL->( MsUnlock() ) 						
						
						cNumHDE := ABL->ABL_SEQUEN 
													
					EndIf 
				Else
					//Ŀ
					// Marca p/Excluir o item do Help Desk                 
					//
					If ( cTipoAnt=="6" )
						If ABL->(DbSeek(xFilial("ABL")+AB2->AB2_NRCHAM+AB2->AB2_ITEM))
							lAtuABL := .T. 
							RecLock( "ABL", .F., .T. ) 
							ABL->( dbDelete() ) 																																	
							ABL->( MsUnlock() ) 
							cNumHDE := CriaVar( "AB2_NUMHDE", .F. ) 
						EndIf 					
					EndIf
				EndIf
                  
				ABL->( FKCommit() ) 

				//Ŀ
				// Atualiza a amarracao com o chamado                  
				//
				
				If lAtuABL
					AB2->( DbSetOrder( 1 ) ) 
					If AB2->( DbSeek( xFilial("AB2") + ABL->ABL_NRCHAM ) )
						RecLock("AB2")
						AB2->AB2_NUMHDE := cNumHDE 
						AB2->( MsUnlock() ) 
					EndIf
				EndIf 	
					
			Else
			
				lDelFNC := .T.
				
				DbSelectArea("AB2")
				DbSetOrder(1)
				If ( DbSeek(xFilial("AB2")+M->AB1_NRCHAM+aCols[nCntFor][nPosItem]) )
					
					If !EMPTY(AB2->AB2_CODFNC)                        .AND.; 	// Tem FNC
			  	   		AB2->AB2_TIPO == "1"                           .AND.; 	// Chamado Tecnico
			       		QNCVERI(AB2->AB2_CODFNC,AB2->AB2_FNCREV,"TEC") 			// Tem Plano de Acao ou esta baixada			  	   
							lDelFNC := .F.       // Impede a exclusao da FNCs e do Chadmado Tecnico
				  	EndIf
					
					If lDelFNC
					
						//Ŀ
						// Deleta a FNC relacionada ao Item                    
						//
						If !EMPTY(AB2->AB2_CODFNC)  .AND.; 	// Tem FNC
					    	AB2->AB2_TIPO == "1"                           
								At300DFNC(.T., nCntFor, nPosItem, @aCols)
						EndIf

						//Ŀ
						// Deleta o Item do Orcamento                          
						//
						If ( AB2->AB2_TIPO == "2" )
							DbSelectArea("AB4")
							DbSetOrder(2)
							If ( DbSeek(xFilial("AB4")+AB2->AB2_NRCHAM+AB2->AB2_ITEM) )
								cNumOrc := AB4->AB4_NUMORC
							EndIf
							aAdd(aColsAB4,Array(Len(aHeaderAB4)+1))
							For nCntFor2 := 1 To Len(aHeaderAB4)
								nPosAhead := aScan(aHeader,{|x| SubStr(AllTrim(x[2]),4)==;
															SubStr(AllTrim(aHeaderAB4[nCntFor2][2]),4)} )
								If ( nPosAhead<>0 .AND. AllTrim(aHeaderAB4[nCntFor2][2])<>"AB4_TIPO" )
									If !Empty( nPosCampo := AB2->( FieldPos(aHeader[nPosAhead][2] ) ) )
										aColsAB4[Len(aColsAB4)][nCntFor2] := AB2->(FieldGet( nPosCampo ))
									EndIf 	
								Else
									If !IsHeadRec(aHeaderAb4[nCntFor2][2]) .AND. !IsHeadAlias(aHeaderAb4[nCntFor2][2])
										aColsAB4[Len(aColsAb4)][nCntFor2] := CriaVar(aHeaderAb4[nCntFor2][2])
									Endif
								EndIf
							Next nCntFor2
							aColsAB4[Len(aColsAb4)][Len(aHeaderAB4)+1] := .T. //Deletar
							aAdd(aOrcamento,AB2->AB2_NRCHAM+AB2->AB2_ITEM)
						EndIf
						//Ŀ
						// Deleta o Item da Ordem de Servico                   
						//
						If ( AB2->AB2_TIPO == "3" )
							DbSelectArea("AB7")
							DbSetOrder(2)
							If ( DbSeek(xFilial("AB7")+AB2->AB2_NRCHAM+AB2->AB2_ITEM) )
								cNumOS := AB7->AB7_NUMOS
							EndIf
							aAdd(aColsAB7,Array(Len(aHeaderAB7)+1))
							For nCntFor2 := 1 To Len(aHeaderAB7)
								nPosAhead := aScan(aHeader,{|x| SubStr(AllTrim(x[2]),4)==;
														SubStr(AllTrim(aHeaderAB7[nCntFor2][2]),4)} )
								If ( nPosAhead<>0 .AND. AllTrim(aHeaderAB7[nCntFor2][2])<>"AB7_TIPO" )
								    If !Empty( nPosCampo := AB2->( FieldPos(aHeader[nPosAhead][2]) ) )
										aColsAB7[Len(aColsAB7)][nCntFor2] := AB2->(FieldGet( nPosCampo ))
									EndIf 	
								Else
									If IsHeadRec(aHeaderAb7[nCntFor2][2])
										aColsAB7[Len(aColsAb7)][nCntFor2] := AB7->(RecNo())
									Elseif IsHeadAlias(aHeaderAb7[nCntFor2][2])
										aColsAB7[Len(aColsAb7)][nCntFor2] := "AB7"
									Else
										If !IsHeadRec(aHeaderAb7[nCntFor2][2]) .AND. !IsHeadAlias(aHeaderAb7[nCntFor2][2])
											aColsAB7[Len(aColsAb7)][nCntFor2] := CriaVar(aHeaderAb7[nCntFor2][2])
										Endif
									Endif
								EndIf
							Next nCntFor2
							aColsAB7[Len(aColsAB7)][Len(aHeaderAB7)+1] := .T. //Deletar
							aAdd(aOs,AB2->AB2_NRCHAM+AB2->AB2_ITEM)
						EndIf
						
						//Ŀ
						// Deleta a Item da Fila de Held Desk                  
						//
						If ( AB2->AB2_TIPO == "6" )
							ABL->( DbSetOrder( 2 ) ) 		
							If ABL->( DbSeek(xFilial("ABL")+AB2->AB2_NRCHAM+AB2->AB2_ITEM) )
								Reclock( "ABL", .F. )
								ABL->( dbDelete() ) 
								ABL->( MsUnlock() ) 					
							EndIf
						EndIf 
						
						//Ŀ
						// Deleta o Item do Chamado Tecnico                    
						//
						MSMM(AB2->AB2_MEMO,,,,2)
						RecLock("AB2")
						dbDelete()
						
						AB2->( FKCommit() ) 
					Else 
						MSGInfo(STR0053) // "Nao e possivel executar a exclusao do item pois existe uma FNC Relacionada com Plano de Acao em Execucao "
					EndIF
				EndIf
			EndIf
		Next nCntFor
		
		If lGravou 
		
			//Ŀ
			// Gravacao de informacoes adicionais no AB1           
			// e criacao das entidades vinculadas ( orcam./OS/HD)  			
			//
		
			AB1->( MsGoto( nRecnoAB1 ) ) 

			//Ŀ
			// Grava o status                                      
			//
			AB1->AB1_STATUS := If(lStatus,"E","A")  
			AB1->( MsUnLock() ) 
			
			//Ŀ
			// Orcamento                                           
			//
			If ( Len(aColsAB4) > 0 )
				If ( Empty(cNumOrc) )
					DbSelectArea("AB3")
					For nCntFor := 1 To FCount()
						uCampo := FieldName(nCntFor)
						M->&(uCampo) := CriaVar(uCampo,.T.)
					Next nCntFor 	
					M->AB3_CODCLI := AB1->AB1_CODCLI
					M->AB3_LOJA   := AB1->AB1_LOJA
				Else
					DbSelectArea("AB3")
					DbSetOrder(1)
					DbSeek(xFilial("AB3")+cNumOrc)
					For nCntFor := 1 To FCount()
						uCampo := FieldName(nCntFor)
						M->&(uCampo) := AB3->(FieldGet(nCntFor))
					Next nCntFor 	
				EndIf
            If ( Empty(M->AB3_CONPAG) )
					DbSelectArea("SA1")
					DbSetOrder(1)
					DbSeek(xFilial("SA1")+M->AB3_CODCLI+M->AB3_LOJA)
					M->AB3_CONPAG := SA1->A1_COND
				EndIf
				aHeader  := aClone(aHeaderAB4)
				aCols    := aClone(aColsAB4)
				DbSelectArea("AB3")
				DbSetOrder(1)
				nOpcOrc := If( DbSeek(xFilial("AB3")+M->AB3_NUMORC), 2, 1 ) 
				At400Grava(nOpcOrc,aOrcamento)
			EndIf
			//Ŀ
			// Ordem de Servico                                    
			//
			If ( Len(aColsAB7) > 0 )
				If ( Empty(cNumOs) )
					DbSelectArea("AB6")
					AB6->(dbSetOrder(1))
					For nCntFor := 1 To FCount()
						uCampo := FieldName(nCntFor)
						If uCampo == "AB6_NUMOS"                       
							cNumOS := CriaVar(uCampo,.T.)
							While AB6->(DbSeek(xFilial("AB6")+cNumOS)) 
								ConfirmSX8()
								cNumOS := GetSXENum("AB6","AB6_NUMOS")
							EndDo                                     
							M->&(uCampo) := cNumOS
						Else
							M->&(uCampo) := CriaVar(uCampo,.T.)
						EndIf 
					Next nCntFor	
					M->AB6_CODCLI := AB1->AB1_CODCLI
					M->AB6_LOJA   := AB1->AB1_LOJA
				Else
					DbSelectArea("AB6")
					DbSetOrder(1)
					DbSeek(xFilial("AB6")+cNumOS)
					For nCntFor := 1 To FCount()
						uCampo := FieldName(nCntFor)
						M->&(uCampo) := AB6->(FieldGet(nCntFor))
					Next nCntFor
				EndIf
				If ( Empty(M->AB6_CONPAG) )
					DbSelectArea("SA1")
					DbSetOrder(1)
					DbSeek(xFilial("SA1")+M->AB6_CODCLI+M->AB6_LOJA)
					M->AB6_CONPAG := SA1->A1_COND
				EndIf
				aHeader  := aClone(aHeaderAB7)
				aCols    := aClone(aColsAB7)
				DbSelectArea("AB6")
				DbSetOrder(1)
				nOpcOs := If( DbSeek(xFilial("AB6")+M->AB6_NUMOS), 2, 1 ) 
				At450Grava(nOpcOs,aOS)
				If ( SuperGetMv("MV_ITMPSTD") )
					DbSelectArea("ABB")
					DbSetOrder(3)
					If ( DbSeek(xFilial("ABB")+M->AB6_NUMOS) )
						While ( !Eof() .AND. xFilial("ABB") == ABB->ABB_FILIAL .AND.;
													M->AB6_NUMOS	== ABB->ABB_NUMOS )
							dDtVisit := If(Empty(dDtVisit),ABB->ABB_DTINI,Min(dDtVisit,ABB->ABB_DTINI))
							If ( dDtVisit == ABB->ABB_DTINI )
								cHrVisit := If(Empty(cHrVisit),ABB->ABB_HRINI,If(cHrVisit>ABB->ABB_HRINI,ABB->ABB_HRINI,cHrVisit))
							EndIf
							DbSelectArea("ABB")
							dbSkip()
						End
					EndIf
				EndIf
			EndIf
		
		Else
			If lFoundAB1 .AND. lDelFNC
			
				//Ŀ
				// Caso o chamado nao possua itens validos, exclui     			
				//
				AB1->( MsGoto( nRecnoAB1 ) ) 
			
				//Ŀ
				// Deleta o Orcamento                                  
				//
				DbSelectArea("AB4")
				DbSetOrder(2)
				If ( DbSeek(xFilial("AB4")+AB1->AB1_NRCHAM) )
					DbSelectArea("AB3")
					DbSetOrder(1)
					DbSeek(xFilial("AB3")+AB4->AB4_NUMORC)
	               At400Grava(3,aOrcamento)
				EndIf
				//Ŀ
				// Deleta a Ordem de Servico                           
				//
				DbSelectArea("AB7")
				DbSetOrder(2)
				If ( DbSeek(xFilial("AB7")+AB1->AB1_NRCHAM) )
					DbSelectArea("AB6")
					DbSetOrder(1)
					DbSeek(xFilial("AB6")+AB7->AB7_NUMOS)
	               At450Grava(3,aOS)
				EndIf
				//Ŀ
				// Deleta o Chamado Tecnico                            
				//
				RecLock("AB1")
				dbDelete()
				
			EndIf
		
		EndIf 	
		
	OtherWise
		
	  	lDelFNC := .T.
		

		//Ŀ
		//Identifico se existe alguma FNC que impessa da delecao do Chamado Tecnico   
		//em caso afirmativo no deleto o Cadastro.                                   
		//
		DbSelectArea("AB2")
		DbSetOrder(1)
		If DbSeek(xFilial("AB2")+M->AB1_NRCHAM)
			While !Eof() .AND. xFilial("AB2")+M->AB1_NRCHAM == xFilial("AB2")+AB2->AB2_NRCHAM   
			  	If !EMPTY(AB2->AB2_CODFNC)                        .AND.; 	// Tem FNC
			  	   AB2->AB2_TIPO == "1"                           .AND.; 	// Chamado Tecnico
			       QNCVERI(AB2->AB2_CODFNC,AB2->AB2_FNCREV,"TEC") 			// Tem Plano de Acao ou esta baixada			  	   
					lDelFNC := .F.       // Impede a exclusao da FNCs e do Chadmado Tecnico
			  	EndIf
			  	DbSkip()
			End
		EndIF
			
		If lDelFNC
			//Ŀ
			// Deletar FNCs                                        
			//
			DbSelectArea("AB2")
			DbSetOrder(1)
			If DbSeek(xFilial("AB2")+M->AB1_NRCHAM)		    
	   			While !Eof() .AND. xFilial("AB2")+M->AB1_NRCHAM == xFilial("AB2")+AB2->AB2_NRCHAM   
				  	If !EMPTY(AB2->AB2_CODFNC)                        .AND.; 	// Tem FNC
				  	   AB2->AB2_TIPO == "1"                           
						At300DFNC()
				  	EndIf
				  	AB2->(DbSkip())
				End
			EndIf 
			//Ŀ
			// Deletar Orcamento                                   
			//
			DbSelectArea("AB4")
			DbSetOrder(2)
			If ( DbSeek(xFilial("AB4")+AB1->AB1_NRCHAM) )
				DbSelectArea("AB3")
				DbSetOrder(1)
				DbSeek(xFilial("AB3")+AB4->AB4_NUMORC)
				At400Grava(3,aOrcamento)
			EndIf
			//Ŀ
			// Deletar Ordem de Servico                            
			//
			DbSelectArea("AB7")
			DbSetOrder(2)
			If ( DbSeek(xFilial("AB7")+AB1->AB1_NRCHAM) )
				DbSelectArea("AB6")
				DbSetOrder(1)
				DbSeek(xFilial("AB6")+AB7->AB7_NUMOS)
				At450Grava(3,aOs)
			EndIf                                                
			
			DbSelectArea("AB2")
			DbSetOrder(1)
			If DbSeek(xFilial("AB2")+M->AB1_NRCHAM)
				While ( !Eof() .AND. xFilial("AB2") == AB2->AB2_FILIAL .AND.;
											M->AB1_NRCHAM  == AB2->AB2_NRCHAM )
											
					//Ŀ
					// Exclui o item da fila de Help Desk                  
					//
					If AB2->AB2_TIPO == "6"
						If ABL->(DbSeek(xFilial("ABL")+AB2->AB2_NRCHAM+AB2->AB2_ITEM))
							RecLock( "ABL", .F., .T. ) 
							ABL->( DbDelete() ) 																																	
							ABL->( MsUnlock() ) 
						EndIf 					
					EndIf
											
					MSMM(AB2->AB2_MEMO,,,,2)
					RecLock("AB2")
					DbDelete()
					DbSelectArea("AB2")
					DbSkip()
				End
				AB2->( FKCommit() ) 	
			EndIf	
		
			//Ŀ
			// Deleta Chamado Tecnico                              
			//
			DbSelectArea("AB1")
			RecLock("AB1")
			DbDelete()
		Else
			MsgInfo(STR0050) // "Nao e possivel executar a exclusao do registro - Existem FNCs com Plano de Acao em Execucao"
		EndIf			
EndCase
DbSelectArea("AB1")
If ( !Empty(dDtVisit) .AND. SuperGetMv("MV_ITMPSTD") .AND.;
		( AtIsRotina("AT300INCLU") .OR. AtIsRotina("AT300ALTER")) )
	MsgInfo(PadR(STR0035+Dtoc(dDtVisit),20)+Chr(10)+Chr(13)+STR0036+cHrVisit,STR0037) //"Data: "###"Hora:"###"Previso de Atendimento: "
EndIf                  

//Ŀ
//Restaura o aCols e o aHeader antes do ponto de entrada                  
//
aHeader := AClone( aHeaderAB2 ) 
aCols   := AClone( aColsAB2 ) 

If ExistBlock("AT300GRV")
	Execblock("AT300GRV",.F.,.F.)
Endif

//Ŀ
//Restaura a Entrada da Rotina                                            
//

RestArea( aAreaAB1 )
RestArea( aAreaAB2 )
RestArea( aArea ) 

Return( { lGravou, M->AB1_NRCHAM } )

/*/


Ŀ
Funcao    At300GrvOr Autor  Eduardo Riera          Data  02.10.98 
Ĵ
Descrio  Gera o Orcamento                                           
Ĵ
Retorno    Void                                                       
Ĵ
Parametros Void                                                       
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At300GrvOr()

Processa({|| At300Proc(1) })
CloseBrowse()
Return(.T.)

/*/


Ŀ
Funcao    At300GrvOs Autor  Eduardo Riera          Data  02.10.98 
Ĵ
Descrio  Gera a Ordem de Servico                                    
Ĵ
Retorno    Void                                                       
Ĵ
Parametros Void                                                       
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At300GrvOs()

Processa({|| At300Proc(2) })
CloseBrowse()
Return(.T.)

/*


Ŀ
Funcao    At300GrvHd Autor  Sergio Silveira        Data 25/09/2001
Ĵ
Descrio  Gera o item de Help Desk                                   
Ĵ
Retorno    .T.                                                        
Ĵ
Parametros Void                                                       
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function At300GrvHd()

Processa({|| At300Proc(3) })
CloseBrowse()
Return(.T.)

/*/


Ŀ
Funcao    At300Proc  Autor  Eduardo Riera          Data  02.10.98 
Ĵ
Descrio  Processamento da Efetivacao de Orcamentos e Os             
Ĵ
Retorno    Void                                                       
Ĵ
Parametros ExpC1 : 1 - Orcamento / 2 - OS / 3 - Help Desk             
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
17/01/2007 Conrado Q.    Bops 115748: Montagem do aCols adaptada para
                         utilizao do Walk-Thru.                    
ٱ


/*/
Static Function At300Proc(nTipo)

Local nCntFor 			:= 0
Local uCampo			:= ""
Local lTravas			:= .T.
Local aTravas			:= {}
Local nUsado			:= 0
Local nPosItem			:= 0
Local aSavaHeader		:= {}
Local aTpStatus      := { "2", "3", "6" } 
Local nSaveSX8			:= GetSX8Len()
Local lAt300Val	:= ExistBlock("AT300Val")	
Local lRet := .T. 
Private aCols			:= {}
Private aHeader		:= {}

//Ŀ
//Monta aHeader                                                           
//
DbSelectArea("SX3")
DbSetOrder(1)
DbSeek("AB2")
While ( !Eof() .AND. (SX3->X3_ARQUIVO == "AB2") )
	If ( X3Uso(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL )
		nUsado++
		aAdd(aHeader,{ AllTrim(X3Titulo()),;
							SX3->X3_CAMPO,;
							SX3->X3_PICTURE,;
							SX3->X3_TAMANHO,;
							SX3->X3_DECIMAL,;
							SX3->X3_VALID,;
							SX3->X3_USADO,;
							SX3->X3_TIPO,;
							SX3->X3_ARQUIVO,;
							SX3->X3_CONTEXT } )
		If ( AllTrim(SX3->X3_CAMPO) == "AB2_ITEM" )
			nPosItem := nUsado
		EndIF
	EndIf
	DbSelectArea("SX3")
	dbSkip()
End
aSavAheader := aClone(aHeader)
//Ŀ
//Processamento da MarkBrowse                                             
//
DbSelectArea("AB1")
AB1->(DbSetFilter({|| &cFiltroAB1}, cFiltroAB1))
DbGoTop() //IndRegua()
ProcRegua(LastRec())
While ( !Eof() )
	
	If lAt300Val
		lRet := ExecBlock("AT300Val",.F.,.F.,{ nTipo ,AB1->AB1_NRCHAM,IsMark("AB1_OK",ThisMark(),ThisInv())})
	EndIf

	If ( IsMark("AB1_OK",ThisMark(),ThisInv()) .AND. SoftLock("AB1") .And. lRet)
		lTravas	:= .T.
		aTravas	:= {}
		aCols		:= {}
		aHeader	:= aClone(aSavAheader)
		//Ŀ
		// Cria Variaveis de Memoria da Enchoice                
		//
		DbSelectArea("AB1")
		aAdd(aTravas , { Alias() , RecNo() })
		For nCntFor := 1 To FCount()
			uCampo := FieldName(nCntFor)
         M->&(uCampo) := AB1->(FieldGet(FieldPos(uCampo)))
		Next nCntFor
		//Ŀ
		// Monta Acols                                          
		//
	    DbSelectArea("AB2")
		DbSetOrder(1)
		DbSeek(xFilial("AB2")+M->AB1_NRCHAM)
		While ( !Eof() .AND. xFilial("AB2") == AB2->AB2_FILIAL .AND.;
									M->AB1_NRCHAM  == AB2->AB2_NRCHAM )
			aAdd(aCols,Array(nUsado+1))
			For nCntFor := 1 To nUsado
				If ( aHeader[nCntFor][10] <> "V" )
					aCols[Len(aCols)][nCntFor] := AB2->(FieldGet(FieldPos(aHeader[nCntFor,2])))
					If ( AllTrim(aHeader[nCntFor][2]) == "AB2_TIPO" )
						If ( AB2->AB2_TIPO=="1" )
							aCols[Len(aCols)][nCntFor] := aTpStatus[ nTipo ] 
						EndIf
					EndIf
	            Else
          			If IsHeadRec(aHeader[nCntFor][2])
						aCols[Len(aCols)][nCntFor] := AB2->(Recno())
					Elseif IsHeadAlias(aHeader[nCntFor][2])
						aCols[Len(aCols)][nCntFor] := "AB2"
					Else
						aCols[Len(aCols)][nCntFor] := CriaVar(aHeader[nCntFor][2])
					Endif
    	        EndIf
			Next nCntFor
			aCols[Len(aCols)][nUsado+1] := .F.
			If ( SoftLock("AB2") .AND. lTravas )
				aAdd(aTravas, { Alias() , RecNo() })
			Else
				lTravas := .F.
			EndIf
			DbSelectArea("AB2")
			dbSkip()
		End
		If ( Len(aCols) == 0 )
			aAdd(aCols,Array(nUsado))
			For nCntFor := 1 To nUsado
       			If IsHeadRec(aHeader[nCntFor,2])
					aCols[1][nCntFor] := AB2->(Recno())
				Elseif IsHeadAlias(aHeader[nCntFor,2])
					aCols[1][nCntFor] := "AB2"
				Else
					aCols[1][nCntFor] := CriaVar(aHeader[nCntFor,2])
				Endif
			Next nCntFor
			aCols[Len(aCols)][nUsado+1] := .F.
      EndIf
		Begin Transaction
			at300Grava(2)
			While ( GetSX8Len() > nSaveSx8 )
				ConfirmSx8()
			End
		End Transaction
		For nCntFor := 1 To Len(aTravas)
			DbSelectArea(aTravas[nCntFor][1])
			DbGoTo(aTravas[nCntFor][2])
			MsUnLock()
		Next nCntFor
	EndIf
	DbSelectArea("AB1")
	dbSkip()
	IncProc()
End
Return(.T.)

/*/


Ŀ
Funcao    At300BCli  Autor  Eduardo Riera          Data  24.09.98 
Ĵ
Descrio  Demonstra o Historico de Clientes                          
Ĵ
Retorno                                                               
Ĵ
Parametros                                                            
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At300BCli()

Local aArea     := GetArea()
Local lConsulta := .T. 

DbSelectArea("SA1")
DbSetOrder(1)
If ( DbSeek(xFilial("SA1")+M->AB1_CODCLI+M->AB1_LOJA) )
	If GetNewPar( "MV_ATHISPA", 2 ) == 1 
		lConsulta := Pergunte("ATC010",.T.)
	EndIf 	
	If lConsulta 
		AtC010con(Alias(),RecNo(),2)
	EndIf 	
Else
	Help(" ",1,"AT300BCLI")
EndIf

RestArea( aArea ) 

Return() 

/*/


Ŀ
Funcao    At300BPro  Autor  Eduardo Riera          Data  24.09.98 
Ĵ
Descrio  Demonstra o Historico de Equipamentos                      
Ĵ
Retorno                                                               
Ĵ
Parametros                                                            
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At300BPro()

Local aArea      := GetArea()
Local nPosProd   := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRO" })
Local nPosNser   := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_NUMSER" })
Local lConsulta  := .T. 

DbSelectArea("AA3")
DbSetOrder(1)
If ( DbSeek(xFilial("AA3")+M->AB1_CODCLI+M->AB1_LOJA+aCols[n][nPosProd]+aCols[n][nPosNser]) )
	If GetNewPar( "MV_ATHISPA", 2 ) == 1 
		lConsulta := Pergunte("ATC020",.T.)
	EndIf 	
	
	If lConsulta 
		AtC020con(Alias(),RecNo(),2)
	EndIf 	
Else
	Help(" ",1,"AT300BPRO") // Informe o cliente, Produto e numero de serie
EndIf

RestArea( aArea ) 

Return() 


/*/


Ŀ
Funcao    At300BFaq  Autor  Eduardo Riera          Data  24.09.98 
Ĵ
Descrio  Consulta ao FAQ                                            
Ĵ
Retorno                                                               
Ĵ
Parametros                                                            
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At300BFAQ()

Local aArea    := { Alias() , IndexOrd() , RecNo() }
Local nPosProd := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRO" })
Local nPosPrb  := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRB" })
Local cPrbIni  := aCols[n][nPosPrb]
Local cPrbFim  := If(Empty(aCols[n][nPosPrb]),Repl(Chr(255),Len(cPrbIni)),aCols[n][nPosPrb])

AtC030Faq(cPrbIni,cPrbFim,aCols[n][nPosProd],aCols[n][nPosProd])

DbSelectArea(aArea[1])
DbSetOrder(aArea[2])
DbGoTo(aArea[3])

Return

/*/


Ŀ
Funcao    At300Rodap Autor  Eduardo Riera          Data  22.10.98 
Ĵ
Descrio  Rotina de Atualizacao de Rodape                            
Ĵ
Retorno    ExpL1 : Logico                                             
Ĵ
Parametros ExpC1 : Produto                                            
           ExpC2 : Nr.Serie                                           
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function At300Rodape(cProduto,cNumSer,oGetd)

Local aSimNao	:= {STR0033,STR0034}	//"Sim"###"No"
Local nPosPro	:= aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRO"})
Local nPosNSe	:= aScan(aHeader,{|x| AllTrim(x[2])=="AB2_NUMSER"})
Local nPosPrb := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_CODPRB"})
Local nPosDesc:= aScan(aHeader,{|x| AllTrim(x[2])=="AB2_DESCRI"})
Local cCodFab	:= ""
Local cLojaFa	:= ""
Local cCodcli	:= M->AB1_CODCLI
Local cLoja  	:= M->AB1_LOJA
Local aArea  	:= GetArea()
Local lLogico
Local aColor 	:= { CLR_HBLUE,CLR_HRED }
Local nCntFor	:= 0

Local oDlg   


If Type("lAt300Auto")=="U" .OR. !lAt300Auto
	If ALTERA
		If Empty(aCols[n][nPosPrb]) .And. !Empty(aCols[n][nPosDesc])
			aCols[n][nPosDesc] := "" 
			oGetd:oBrowse:Refresh()
		EndIf
	EndIf
	//Ŀ
	//Pesquisa a janela correta                                               
	//
	oDlg   	:= GetWndDefaut()
	If ( oDlg <> Nil )
		
		cProduto := If(cProduto==Nil,aCols[n][nPosPro],cProduto)
		cNumSer  := If(cNumSer ==Nil,aCols[n][nPosNSe],cNumSer)
		
		If( Empty(cProduto) )
			aColor := { CLR_BLACK , CLR_BLACK }
			aSimNao:= { "___","___" }
		EndIf
		
		DbSelectArea("AA3")
		DbSetOrder(1)
		DbSeek(xFilial("AA3")+cCodCli+cLoja+cProduto+cNumSer)
		cCodFab := AA3->AA3_CODFAB
		cLojaFa := AA3->AA3_LOJAFA
		
		For nCntFor := 1 To Len( aCtrRodape ) 
		
			oControl := aCtrRodape[ nCntFor, 2 ] 
			
			Do Case
				Case aCtrRodape[ nCntFor, 1 ] == "R-CONT"
					lLogico := AtIsCtrMan(cCodFab,cLojaFa,cProduto,cNumSer)
					oControl:SetColor(aColor[If(lLogico,1,2)],oControl:nClrPane)
					oControl:SetText(aSimNao[If(lLogico,1,2)])
				Case aCtrRodape[ nCntFor, 1 ]  == "R-GARA"
					lLogico := AtIsGar(cCodFab,cLojaFa,cProduto,cNumSer)
					oControl:SetColor(aColor[If(lLogico,1,2)],oControl:nClrPane)
					oControl:SetText(aSimNao[If(lLogico,1,2)])
				Case aCtrRodape[ nCntFor, 1 ]  == "R-PREV"
					lLogico := AtIsCtrPre(cCodFab,cLojaFa,cProduto,cNumSer)
					oControl:SetColor(aColor[If(!lLogico,1,2)],oControl:nClrPane)
					oControl:SetText(aSimNao[If(lLogico,1,2)]+" - "+StrZero(AtIsNumPre(cCodFab,cLojaFa,cProduto,cNumSer),3))
				Case aCtrRodape[ nCntFor, 1 ]  == "R-CHAM"
					lLogico := AtIsChamado(cCodCli,cLoja)
					oControl:SetColor(aColor[If(!lLogico,1,2)],oControl:nClrPane)	
					oControl:SetText(aSimNao[If(lLogico,1,2)])
				Case aCtrRodape[ nCntFor, 1 ]  == "R-ORCA"
					lLogico := AtIsOrc(cCodCli,cLoja)
					oControl:SetColor(aColor[If(!lLogico,1,2)],oControl:nClrPane)
					oControl:SetText(aSimNao[If(lLogico,1,2)])
				Case aCtrRodape[ nCntFor, 1 ]  == "R-OSRV"
					lLogico := AtIsOS(cCodCli,cLoja)
					oControl:SetColor(aColor[If(!lLogico,1,2)],oControl:nClrPane)
					oControl:SetText(aSimNao[If(lLogico,1,2)])
				Case aCtrRodape[ nCntFor, 1 ]  == "R-OBSO"
					lLogico := AtIsObsol(cCodFab,cLojaFa,cProduto,cNumSer)
					oControl:SetColor(aColor[If(!lLogico,1,2)],oControl:nClrPane)
					oControl:SetText(aSimNao[If(lLogico,1,2)])
			EndCase
		Next nCntFor
	EndIf
EndIf

RestArea( aArea ) 
	
Return(.T.)

/*/


Ŀ
Funcao    AtBofAA3   Autor Eduardo Riera           Data 21.06.1999
Ĵ
Descrio Funcao para definicao do Topo no F3 / Produto-Equipamento   
Ĵ
Retorno   ExpC1: String de definicao do Topo                          
Ĵ
ParametrosNenhum                                                      
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function AtBofAA3()

Local cFiltro	:= ""

If ( AA3->(IndexOrd())<6 )
	cFiltro := xFilial("AA3")+SA1->A1_COD+SA1->A1_LOJA
Else
	cFiltro := xFilial("AA3")
EndIf

Return(cFiltro)

/*/


Ŀ
Funcao    AtEofAA3   Autor Eduardo Riera           Data 21.06.1999
Ĵ
Descrio Funcao para definicao do Final no F3 / Produto-Equipamento  
Ĵ
Retorno   ExpC1: String de definicao do Final                         
Ĵ
ParametrosNenhum                                                      
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function AtEofAA3()

Local cFiltro	:= ""                

If ( AA3->(IndexOrd())<6 )
	cFiltro := xFilial("AA3")+SA1->A1_COD+SA1->A1_LOJA
Else
	cFiltro := xFilial("AA3")
EndIf

Return(cFiltro)

/*/


Ŀ
Funcao    At300Carga Autor  Sergio Silveira        Data 28/06/2000
Ĵ
Descrio  Carrega o equipamento posicionado no AA3 para o atendimento
Ĵ
Sintaxe    At300Carga( ExpO1, oEnch )                                 
Ĵ
Parametros ExpO1 -> Objeto GetDados                                   
           ExpO2 -> Objeto Enchoice                                   
Ĵ
Retorno    Nil                                                        
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
11/06/2007Conrado Q Gomes-BOPS 127131: Adio do ponto de entrada    
                         AT300CAR.                                   
ٱ


/*/

Function At300Carga( oGetD, oEnch )  
Local lAT300CAR := ExistBlock("AT300CAR")	// Validao da existncia do ponto de entrada AT300CAR

//Ŀ
//Executa o ponto de entrada AT300CAR.
//
If lAT300CAR
	ExecBlock("AT300CAR")
EndIf

 At300LastB(oGetD, oEnch)
 
If ( Empty( M->AB1_CODCLI ) .AND. Empty( M->AB1_LOJA ) ) .OR. ;
	 ( M->AB1_CODCLI == AA3->AA3_CODCLI .AND. M->AB1_LOJA == AA3->AA3_LOJA ) 

	M->AB1_CODCLI := AA3->AA3_CODCLI
	M->AB1_LOJA   := AA3->AA3_LOJA 
           
	If At300Eqpto( { "AB2_CODPRO", AA3->AA3_CODPRO } ) 
		GDFieldPut( "AB2_CODPRO", AA3->AA3_CODPRO ) 
		GDFieldPut( "AB2_NUMSER", AA3->AA3_NUMSER ) 
	EndIf 			

	oGetD:oBrowse:Refresh() 
	oEnch:EnchRefreshAll() 

Else 
	Help( " ", 1, "AT300CLIDF" ) // O cliente do atendimento nao eh o mesmo do eqto. 
EndIf	

Return( Nil ) 

/*


Ŀ
Funcao    At300VldUs Autor  Sergio Silveira        Data 12/03/2001
Ĵ
Descrio  Tratamento da confirmacao / nao confirmacao da inclusao    
           ou alteracao                                               
Ĵ
Sintaxe    ExpL1 := At300VldUs( ExpN1 )                               
Ĵ
Parametros ExpN1 -> Opcao : 1 -> Confirma / 0 -> Nao Confirma         
Ĵ
Retorno    ExpL1 -> Validacao                                         
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function At300VldUs( nOpca ) 

Local lRet := .T.                

//Ŀ
// Faz a chamada do ponto passando nOpca como parametro 
//

If INCLUI
	If ExistBlock( "AT300VLD" ) 
		lRet := ExecBlock( "AT300VLD", .F., .F., { nOpca } ) 	
	EndIf 
Else	
	If ExistBlock( "AT300VLA" ) 
		lRet := ExecBlock( "AT300VLA", .F., .F., { nOpca } ) 	
	EndIf 
EndIf 
		
Return( lRet ) 


/*


Ŀ
Funcao    At300Track Autor  Sergio Silveira        Data 09/01/2002
Ĵ
Descrio  Faz o tratamento da chamada do System Tracker              
Ĵ
Retorno    .T.                                                        
Ĵ
Parametros Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Static Function At300Track() 

Local aEnt     := {}
Local cChamado := M->AB1_NRCHAM                                     
Local nPosItem := GDFieldPos( "AB2_ITEM" ) 
Local nLoop    := 0 

//Ŀ
// Carrega os itens para rastreamento          
//
For nLoop := 1 To Len( aCols ) 
	aAdd( aEnt, { "AB2", cChamado + aCols[ nLoop, nPosItem ] } ) 
Next nLoop 

MaTrkShow( aEnt ) 
           
Return( .T. ) 
/*


Ŀ
Funcao    AtVerOcor  Autor  Cicero Cruz                      Data  19/01/06 
Ĵ
Descricao  Verifica se a Ocorrencia escolhida gera FNC ou Nao                   
Ĵ
Uso        FIELD SERVICE                                                        
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                                   
Ĵ
Cicero C. 19/01/068.11  -Incluida a Integracao com o Controle de Nao-Conformi-
          89415         dades                                                 
ٱ


*/
Function AtVerOcor(cAcao)
Local lRet := .F. 															// Indica se a Ocorrencia  ira gerar FNC
Local cGerFNC := Posicione("AAG",1,xFilial("AAG") + cAcao,"AAG_GERFNC") 	// Resgata o conteudo do campo AAG_GERFNC

If cGerFNC == "1"
	lRet := .T.
EndIf
Return lRet

/*


Ŀ
Funcao    At300DFNC  Autor  Cicero Cruz                      Data  19/01/06 
Ĵ
Descricao  Deleta as FNC criadas                                                
Ĵ
Uso        FIELD SERVICE - Excluso de Chamado Tecnico                          
Ĵ
Analista   Data/Bops/Ver Manutencao Efetuada                                   
Ĵ
Cicero C. 19/01/068.11  -Incluida a Integracao com o Controle de Nao-Conformi-
          89415         dades                                                 
ٱ


*/
Function At300DFNC (lItem, nLinha, nPosItem, aCols)
Local aArea      := GetArea()          // Salvo as posicoes  dos registros
Default lItem    := .F.					// Deleta so o item do acols
Default nLinha	 := 0 					// Posicao da linha no aCols
Default nPosItem := 0					// Posicao na linha do aCols

DbSelectArea("AB2")
DbSetOrder(1)
If DbSeek(xFilial("AB2")+M->AB1_NRCHAM+IF(lItem,aCols[nLinha][nPosItem],""))
	DbSelectArea("QI2")
	DbSetOrder(2)
	While !AB2->(Eof()) .AND. xFilial("AB2")+M->AB1_NRCHAM == xFilial("AB2")+AB2->AB2_NRCHAM   .AND. IF(lItem,aCols[nLinha][nPosItem] == AB2->AB2_ITEM,.T.)
  		If !EMPTY(AB2->AB2_CODFNC) .AND.; 					// Tem FNC
	  		AB2->AB2_TIPO == "1"         					// Chamado Tecnico
		    If DbSeek(xFilial("QI2")+AB2->AB2_CODFNC+AB2->AB2_FNCREV)
		   		DbSelectArea("QI2")
                // Prevencao Auditorias
				RecLock("QI2",.F.)    
				cVar := ""
				If Empty(QI2->QI2_COMEN)	// Inclusao	  
					MSMM(,TamSx3("QI2_MEMO2")[1],,STR0051+UPPER(QA_AmbDet( Nil, "SIGATEC", 4 ))+STR0052,1,,,"QI2","QI2_COMEN") // " ** FICHA DE NAO CONFORMIDADE CANCELADA PELO"###" ** - Motivo: Chamado Excluido"
				Else						// Alteracao
					MSMM(QI2->QI2_COMEN,TamSx3("QI2_MEMO2")[1],,STR0051+UPPER(QA_AmbDet( Nil, "SIGATEC", 4 ))+STR0052,1,,,"QI2","QI2_COMEN") // " ** FICHA DE NAO CONFORMIDADE CANCELADA PELO "###" ** - Motivo: Chamado Excluido"
				Endif
				MsUnLock()				
			EndIf
		    If DbSeek(xFilial("QI2")+AB2->AB2_CODFNC+AB2->AB2_FNCREV)
		    	Begin Transaction
			   		DbSelectArea("QI2")
				    // Deleto o Registro
					RecLock("QI2",.F.,.T.)
			   		DbDelete()
					MsUnLock()
				End Transaction  
			EndIf
		EndIf
		AB2->(DbSkip())
	End
EndIf          
RestArea(aArea)
Return Nil


/*


Ŀ
Program    At300Leg  Autor  Cleber Martinez        Data 12/04/2006
Ĵ
Descrio  Exibe a legenda do Chamado Tecnico                         
Ĵ
Retorno    Nil                                                        
Ĵ
Parametros Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


*/

Function At300Leg() 
Local aCoresNew := {}
Local aCores    := {{"ENABLE",STR0056},;// "Encerrado"
						   {"DISABLE",STR0057}}// "Encerrado"

//Ŀ
// Ponto de Entrada para alterar cores da legenda    
//
If ExistBlock("AT30LEG")
	aCoresNew := ExecBlock("AT30LEG",.F.,.F.,aCores)
	If ValType( aCoresNew ) == "A"
		aCores := aClone(aCoresNew)
	EndIf
Endif

BrwLegenda( cCadastro,  STR0055 , aCores ) //"Status"

Return( Nil ) 
           
/*


Ŀ
Program   At300Verif Autor  Conrado Q. Gomes       Data 27/12/2006
Ĵ
Descrio  Verifica se o item pode ser adicionado ao aCols            
Ĵ
Retorno    Verdadeiro ou Falso, onde: .T. - Pode, .F. - No pode      
Ĵ
Parametros nOpc - Opo da janela                                     
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


*/
Static Function At300Verif(nOpc)
	//Ŀ
	// Aqui eh verificado se o item esta amarrado a alguma OS ou Orcamento que
	// foi baixado, ou help Desk alocado.                                     
	// Quando isto acontece a alteracao nao eh permitida.                      
	//
	If nOpc != 4 //alterar
		DbSelectArea("AB4")
		DbSetOrder(1)
		If ( !Empty(AB2->AB2_NUMORC) .AND. DbSeek(xFilial("AB4")+AB2->AB2_NUMORC) )
			If ( AB4->AB4_TIPO <> "1" )			
				Help(" ",1,"AT300TPORC")			
				DbSelectArea("AB2")
				Return(.F.)
			EndIf
		EndIf
	
		DbSelectArea("AB7")
		DbSetOrder(1)
		If ( !Empty(AB2->AB2_NUMOS) .AND. DbSeek(xFilial("AB7")+AB2->AB2_NUMOS) )
	      If ( AB7->AB7_TIPO <> "1" )
				Help(" ",1,"AT300TIPOS")
				DbSelectArea("AB2")
				Return(.F.)
			EndIf
		EndIf
	EndIf
	ABL->( DbSetOrder( 2 ) ) 		
	If ABL->( DbSeek(xFilial("ABL")+AB2->AB2_NRCHAM+AB2->AB2_ITEM) )
      If ( ABL->ABL_SITUAC<>"1" )
			Help(" ",1,"AT300TIPHD")
			DbSelectArea("AB2")
			Return(.F.)
		EndIf
	EndIf
	
	If ( nOpc == 5 )
		//Ŀ
		//Verifica se ha algum item alocado que foi sacramentado                  
		//
		DbSelectArea("ABB")
		DbSetOrder(3)
		If ( AB7->(Found()) .AND. DbSeek(xFilial("ABB")+AB7->AB7_NUMOS) )
			If ( ABB->ABB_SACRA == "S" )
				Help(" ",1,"AT300SACRA")
				DbSelectArea("AB2")
				Return(.F.)
			EndIf
		EndIf
	Endif
	DbSelectArea("AB2")
Return(.T.)

/*/


Ŀ
Program   GetNumAB1  Autor Vendas e CRM            Data  02/08/13 
Ĵ
Descrio Inicializa o Numero de Chamado Tcnico                      
Ĵ
Retorno   Numero do Chamado Tcnico                                   
ٱ


/*/
Static Function GetNumAB1()
Local aArea		:= GetArea()
Local aAreaAB1	:= AB1->(GetArea())
Local cNum		:= GetSx8Num("AB1","AB1_NRCHAM")
Local nSaveSX8 := GetSX8Len()

dbSelectArea("AB1")
dbSetOrder(1)
While AB1->(DbSeek(xFilial("AB1")+cNum))
	While ( GetSX8Len() > nSaveSX8 )
		ConfirmSX8()
	EndDo
	cNum := GetSx8Num("AB1","AB1_NRCHAM")
EndDo

RestArea(aAreaAB1)
RestArea(aArea)
Return(cNum)

/*/{Protheus.doc} At300LastB
Atribui a grid a ultima base de atendimento criada para o cliente
@author Vendas e CRM
@since 06/10/2014
@version 1.0
/*/
Function At300LastB(oGetD, oEnch)
Local cAliasQry := ""
Local cQuery    := ""
Local nRecnoAA3 := 0

If Len( aCols ) == 1	.AND. !Empty( M->AB1_CODCLI ) .AND. !Empty( M->AB1_LOJA )

	cAliasQry := GetNextAlias() 		

	//Ŀ
	// Verifica se o cliente possui um unico registro na base instalada       
	//
	
	cAliasQry := GetNextAlias() 		
	cQuery    := ""                            
	
	cQuery += "SELECT R_E_C_N_O_ AA3RECNO FROM " + RetSqlName( "AA3" ) + " " 
	cQuery += "WHERE " 
	cQuery += "AA3_FILIAL='" + xFilial( "AA3" ) + "' AND " 
	cQuery += "AA3_CODCLI='" + M->AB1_CODCLI     + "' AND " 
	cQuery += "AA3_LOJA='"   + M->AB1_LOJA    + "' AND " 
	cQuery += "D_E_L_E_T_=' ' "
	cQuery += "ORDER BY R_E_C_N_O_ DESC" 

	cQuery := ChangeQuery( cQuery ) 
	
	dbUseArea( .t., "TOPCONN", TcGenQry( ,,cQuery ), cAliasQry, .F., .T. )
	
	TcSetField( cAliasQry, "AA3RECNO", "N", 8, 0 ) 
	
	If !Eof() 
		nRecnoAA3 := ( cAliasQry )->AA3RECNO  
	EndIf  							

	( cAliasQry )->( dbCloseArea() ) 
	
	If nRecnoAA3 > 0
		DbSelectArea( "AA3" ) 	
		AA3->( DbGoTo( nRecnoAA3 ) )
		If At300Eqpto( { "AB2_CODPRO", AA3->AA3_CODPRO } ) 
			GDFieldPut( "AB2_CODPRO", AA3->AA3_CODPRO ) 
			GDFieldPut( "AB2_NUMSER", AA3->AA3_NUMSER ) 
			oGetDUS:oBrowse:Refresh() 	
		EndIf
	EndIf
EndIf	
	
Return		
	
/*/{Protheus.doc} At300FldOk
Pr-valid da alterao
@author Mateus Boiani
@since 21/05/2018
@version 1.0
/*/	
Function At300FldOk()
Local lRet := .T.
Local nPosRecn
Local nPosTipo
Local nRecno := 0

If TYPE("aHeader") == 'A' .AND. TYPE("aCols") == 'A' .AND. TYPE("n") == 'N'

	nPosRecn := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_REC_WT" })
	nPosTipo := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_TIPO" })
	
	nRecno := AB2->(RECNO())
	AB2->(DbGoTo(aCols[n][nPosRecn]))
	
	If aCols[n][nPosTipo] == '2' //Oramento
		DbSelectArea("AB4")
		DbSetOrder(1)
		
		If !Empty(AB2->AB2_NUMORC) .AND. DbSeek(xFilial("AB4")+AB2->AB2_NUMORC)
			If ( AB4->AB4_TIPO <> "1" )			
				Help(" ",1,"AT300TPORC")
				lRet := .F.
			EndIf
		EndIf
	EndIf
	
	If aCols[n][nPosTipo] == '3' //O.S.
		DbSelectArea("AB7")
		DbSetOrder(1)
		If ( !Empty(AB2->AB2_NUMOS) .AND. DbSeek(xFilial("AB7")+AB2->AB2_NUMOS) )
	      If ( AB7->AB7_TIPO <> "1" )
				Help(" ",1,"AT300TIPOS") // 
				lRet := .F.
			EndIf
		EndIf
	EndIf
	
	DbSelectArea("AB2")
	AB2->(DbGoTo(nRecno))
EndIf

Return lRet

/*/{Protheus.doc} At300DelOk
Pr-valid na excluso
@author Mateus Boiani
@since 21/05/2018
@version 1.0
/*/
Function At300DelOk()
Local lRet := .T.
Local nPosRecn
Local nPosTipo
Local nRecno := 0

If TYPE("aHeader") == 'A' .AND. TYPE("aCols") == 'A' .AND. TYPE("n") == 'N'

	nPosRecn := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_REC_WT" })
	nPosTipo := aScan(aHeader,{|x| AllTrim(x[2])=="AB2_TIPO" })
	
	nRecno := AB2->(RECNO())
	AB2->(DbGoTo(aCols[n][nPosRecn]))
	
	If aCols[n][nPosTipo] == '2' //Oramento
		DbSelectArea("AB4")
		DbSetOrder(1)
		If !Empty(AB2->AB2_NUMORC) .AND. DbSeek(xFilial("AB4")+AB2->AB2_NUMORC)
			If ( AB4->AB4_TIPO <> "1" )
				lRet := .F.
			EndIf
		EndIf
	EndIf
	
	If aCols[n][nPosTipo] == '3' //O.S.
		DbSelectArea("AB7")
		DbSetOrder(1)
		If ( !Empty(AB2->AB2_NUMOS) .AND. DbSeek(xFilial("AB7")+AB2->AB2_NUMOS) )
			If ( AB7->AB7_TIPO <> "1" )
				lRet := .F.
			EndIf
		EndIf
	EndIf
	
	DbSelectArea("AB2")
	AB2->(DbGoTo(nRecno))
EndIf

Return lRet
