#INCLUDE "PROTHEUS.CH"
#INCLUDE "LOCXNF.CH"
#include 'fwmvcdef.ch'
//Define's
#DEFINE MAX_GETD   400
//Constante com a descricao do remito
#Define DESCREM	 GetDescRem()
#Define _RMCONS 	"A"
//Tipos de validacao de parametros
#Define SpEmpty	   1
#Define SpValor	   2
#Define SpLenArray 3
#Define Sp2String  4
#Define Sp4String  5
#Define SpValType  6
//Numero maximo de pontos de entrada
#Define SnMaxPE    78
//Parametro aAtualiza
#Define SlCtbilOL  1
#Define SlAtuEstq  2
#Define SlAtuFina  3
#Define SlAtuImp   4
#Define SlAtuLF    5
#Define SlConsist  6
#Define SnMaxAtua  6
//Parametro aFin
#Define SnMoedaFin 1
#Define ScNatureza 2
#Define SnMaxFin   2
//Parametro aPergs
#Define SlAmarraca 1 //Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
#Define SlGerCtbil 2 //Lancamentos On-Line?
#Define SlVerCtbil 3 //Mostra Lanç.Contab ?
#Define SlAglutina 4 //Aglut Lançamentos  ?
#Define SlCtbEmiss 5 //Contabiliza por    ? Emissao/Data Base
#Define SnMaxPergs 6
//Array aPosicionou
#Define lSF4 		1
#Define lSB1 		2
#Define lSAx 		3
#Define lSC5 		4
#Define lSC6 		5
#Define lSC9		6
#Define lSC7		7
#Define lSD2		8
#Define lSD1		9
#Define nRecSD2	10
#Define nRecSD1	11
#Define nRecSF1	12
#Define lSF1		13
#Define lDAK		14
#Define nMaxPos 	14
//Array aCfgNf
#Define SnTipo      1
#Define ScCliFor    2
#Define SlFormProp  3
#Define SAliasHead  4
#Define SAliasCols  5
#Define ScOpEstoq   6
#Define ScAliasFin  7
#Define ScEspecie   8
#Define ScOpFin     9
#Define ScTipoDoc  10
#Define SaAtualiza 11
#Define SaLancPadC 12
#Define SaLancPadI 13
#Define SaBotoes   14
#Define SaTeclas   15
#Define SaPergs    16
#Define SaPE	   17
#Define SlRemito   18
#Define ScDescri   19
#Define ScDescGer  20
#Define SlPedido   21
#Define SbF12	   22
#Define SaCposGD   23
#Define SlConFrDp  24
#Define ScFilRot   25
#Define SaCposBr   26
#Define SaLancPCO  27
#Define SnMaxCfg   27
//Controle de Notas Fiscais em outras estacoes
Static cMayUse,__aCodLocs
Static aSX7_Total
Static lFolios := .T.
Static lHashPTG :=  cPaisLoc=="PTG" .And. SF1->(ColumnPos("F1_HASH")) > 0   .And. SF2->(ColumnPos("F2_HASH")) > 0  .And.  SF2->(ColumnPos("F2_VERHASH")) > 0
/*³Programador ³Data    ³ BOPS     ³ Motivo da Alteracao ³±±
±±³Ivan Gomez  ³18/10/17³DMICNS-335³Se realiza replica de Issue DMICNS-132 ³±±
Funcao    Mata467n     Autor Leandro C.G. Data 14.03.2002
Descri‡…o Chamada da Nota de Saida Manual e de Benefiamento a Cliente
xAutoCab	- Array do Cabecalho
xAutoItens	- Array dos Itens
nOpcAuto	- Opcao da Rotina: 3-Inclusao | 5-Exclusao /*/
Function Mata467n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo,xCartaPorte)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)//Funcao Origem
Private aLlaveOrg := {}
Default nTipo   := 0
DEFAULT lSeek	:=	.T.
nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)
If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
EndIf
If nTipo == 0
	If Pergunte("MT467N",.T.)
		If MV_PAR01 == 1
			nTipo := 1	// Normal
		ElseIf MV_PAR01 == 2
			nTipo := 11	// Benefici
		ElseIf MV_PAR01 == 3 .And. cPaisLoc == "EQU"
			nTipo := 17 //N de Venta
		ElseIf MV_PAR01 == 3 .And. cPaisLoc == "AUS"
			nTipo := 18 //RCTI
		ElseIf MV_PAR01 == 3 .And. cPaisLoc $ "MEX|PER"
			nTipo := 19 //Adiantamento
		ElseIf MV_PAR01 == 4 .And. cPaisLoc  $ "MEX" //jgr
			nTipo := 21 //Traslado
		EndIf
	EndIf
EndIf
If nTipo > 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper,,xCartaPorte)
Endif
SetKey(VK_F4	,{|| Nil })
SetKey(VK_F5	,{|| Nil })
SetKey(VK_F6	,{|| Nil })
SetKey(VK_F7	,{|| Nil })
SetKey(VK_F8	,{|| Nil })
SetKey(VK_F9	,{|| Nil })
SetKey(VK_F10	,{|| Nil })
SetKey(VK_F11	,{|| Nil })
SetKey(VK_F12	,{|| Nil })
Return
/*/
±±³Funcao    ³Mata462n    ³ Autor ³Bruno Sobieski  ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito  Saida Manual e de Benefiamento a Cliente ³±±
/*/
Function Mata462n(xAutoCab,xAutoItens,nOpcAuto,lSeek)
Local nTipo		:= 0
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
DEFAULT lSeek	:=	.T.

nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)
If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
	If nTipo == 0
		If Pergunte("MT467N",.T.)
			If MV_PAR01 == 1
				nTipo	:=	50
			ElseIf MV_PAR01 == 2
				nTipo	:=	52
			EndIf
		EndIf
	Endif
Else
	If Pergunte("MT467N",.T.)
		If MV_PAR01 == 1
			LocxNf(50)
		ElseIf MV_PAR01 == 2
			LocxNf(52)
		Else
			Alert(STR0280)
		EndIf
	EndIf
Endif
If nTipo > 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek)
Endif
SetKey(VK_F4	,{|| Nil })
SetKey(VK_F5	,{|| Nil })
SetKey(VK_F6	,{|| Nil })
SetKey(VK_F7	,{|| Nil })
SetKey(VK_F8	,{|| Nil })
SetKey(VK_F9	,{|| Nil })
SetKey(VK_F10	,{|| Nil })
SetKey(VK_F11	,{|| Nil })
SetKey(VK_F12	,{|| Nil })
Return
/*/
±±³Funcao ³Mata462dn ³ Autor ³Bruno Sobieski ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito de devolucao  (Faturamento)    ³±±
/*/
Function Mata462dn()
If Pergunte('MT462D',.T.)
	If mv_par01 == 1
		LocxNf(51)
	Else
		LocxNf(53)
	Endif
Endif
Return
/*/
±±³Funcao    ³Mata462R    ³ Autor ³Bruno Sobieski ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito de retorno simbolico (Faturamento)  ³±±
/*/
Function Mata462R(xAutoCab,xAutoItens,nOpcAuto,lSeek)
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
DEFAULT lSeek	:=	.T.

LocxNf(63,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek)
Return
/*/
±±³Funcao    ³Mata462TN   ³ Autor ³Guilherme C. Leal    ³ Data ³ 20020918 ³±±
±±³Descri‡…o ³Rotina de remitos de Transferencia. ³±±
/*/
Function Mata462TN()
If Pergunte('REMT10',.T.)
	If mv_par01 == 1
		LocxNf(64)	// Entrada
	Else
		LocxNf(54)	// Saida
	Endif
Endif
Return
/*³Funcao    ³Mata102dn   ³ Autor ³Bruno Sobieski ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito de devolucao  (Compras)   ³*/
Function Mata102dn(xAutoCab,xAutoItens,nOpcAuto,lSeek)
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem

DEFAULT lSeek	:=	.T.

LocxNf(61,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek)
Return

/*³Funcao    ³Mata101n    ³ Autor ³Leandro C.G. ³ Data ³14.03.2002³±±
±±³Descri‡…o ³Chamada da Nota de Entrada Manual ³*/
Function Mata101n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo,xRatEvEz)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
Private lDocSp	:= .F.
Private aValor := {}
Private lValor := .F.
Private lAutoFact	:= .F.
Private aAutofac:={0}
DEFAULT lSeek	:=	.T.
DEFAULT nTipo	:= 0

nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)
If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
	If nTipo == 0
		If Pergunte("MT101N",.T.)
			If MV_PAR01 == 1
				nTipo := 10
			ElseIf MV_PAR01 == 2
				nTipo := 12
			ElseIf MV_PAR01 == 3
				nTipo := 13
			ElseIf MV_PAR01 == 4
				nTipo := 14
			ElseIf MV_PAR01 == 5 // THJRBP
				nTipo := 20
			EndIf
		EndIf
	EndIf
Else
	If nTipo == 0
		If Pergunte("MT101N",.T.)
			If MV_PAR01 == 1
				nTipo := 10
			ElseIf MV_PAR01 == 2
				nTipo := 12
			ElseIf MV_PAR01 == 3
				nTipo := 13
			ElseIf MV_PAR01 == 4
				nTipo := 14
			ElseIf MV_PAR01 == 5 // THJRBP PERU y //MEXICO
				IF cPaisLoc == 'COL'
					nTipo := 10 //Doc. Soporte
					lDocSp := .T.
				ElseIF cPaisLoc== "PAR"
					nTipo := 10 // factura normal
					lAutoFact:=.T.
					aAutofac:={5}
				Else
					nTipo := 20 //Adiantamento
				EndIf
			EndIf
		EndIf
	Endif
EndIf
If nTipo > 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper,xRatEvEz)
Endif
SetKey(VK_F4	,{|| Nil })
SetKey(VK_F5	,{|| Nil })
SetKey(VK_F6	,{|| Nil })
SetKey(VK_F7	,{|| Nil })
SetKey(VK_F8	,{|| Nil })
SetKey(VK_F9	,{|| Nil })
SetKey(VK_F10	,{|| Nil })
SetKey(VK_F11	,{|| Nil })
SetKey(VK_F12	,{|| Nil })
Return
/*
±±³Funcao    ³Mata102n    ³ Autor ³Bruno Sobieski       ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada da Remito entrada Manual e de Benefiamento a Cliente³±±
*/
Function Mata102n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
DEFAULT lSeek	:=	.T.
Default nTipo		:= 0

nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)

If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
	If nTipo == 0
		If Pergunte("MT102N",.T.)
			If MV_PAR01 == 1
				nTipo	:=	60
			Else
				nTipo	:=	62
			EndIf
		EndIf
	Endif
Else
	If nTipo == 0
		If Pergunte("MT102N",.T.)
			If MV_PAR01 == 1
				LocxNf(60)
			Else
				LocxNf(62)
			EndIf
		EndIf
	EndIf
Endif
If nTipo > 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper)
Endif
SetKey(VK_F4	,{|| Nil })
SetKey(VK_F5	,{|| Nil })
SetKey(VK_F6	,{|| Nil })
SetKey(VK_F7	,{|| Nil })
SetKey(VK_F8	,{|| Nil })
SetKey(VK_F9	,{|| Nil })
SetKey(VK_F10	,{|| Nil })
SetKey(VK_F11	,{|| Nil })
SetKey(VK_F12	,{|| Nil })
Return
/*
±±³Funcao    ³Mata465n    ³ Autor ³Leandro C.G.³ Data ³14.03.2002³±±
±±³Descri‡…o ³Chamada da Nota de Debito e Credito ao Cliente ³±±
*/
Function Mata465n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
Public aDocOrig := {}
Default nTipo   := 0
DEFAULT lSeek	:=	.T.
nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)
If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
	If nTipo == 0
		If Pergunte("MT465N",.T.)
			Do Case
				Case MV_PAR01 == 1 .AND. MV_PAR02 == 1//NDC|
					nTipo := 2
				Case MV_PAR01 == 2 .AND. MV_PAR02 == 2//NCE³
					nTipo := 3
				Case MV_PAR01 == 1 .AND. MV_PAR02 == 2//NCC³
					nTipo := 4
				Case MV_PAR01 == 2 .AND. MV_PAR02 == 1//NDE³
					nTipo := 5
			EndCase
		EndIf
	EndIf
Else
	If nTipo == 0
	If Pergunte("MT465N",.T.)
		Do Case
			Case MV_PAR01 == 1 .AND. MV_PAR02 == 1//NDC|
				nTipo := 2
			Case MV_PAR01 == 2 .AND. MV_PAR02 == 2//NCE³
				nTipo := 3
			Case MV_PAR01 == 1 .AND. MV_PAR02 == 2//NCC³
				nTipo := 4
			Case MV_PAR01 == 2 .AND. MV_PAR02 == 1//NDE³
				nTipo := 5
		EndCase
		If MV_PAR01 <> 1 //Leandro Prado - 10/03/2014
			lFolios := .F.
		EndIf
	EndIf
	EndIf
EndIf
//³Chamando programas de Notas Fiscais³
If nTipo <> 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper)
EndIf
Return
/*
±±³Funcao    ³Mata466n    ³ Autor ³Leandro C.G.³ Data ³14.03.2002³±±
±±³Descri‡…o ³Chamada da Nota de Debito e Credito ao Fornecedor³±±
*/
Function Mata466n(xAutoCab,xAutoItens,nOpcAuto,lSeek,nTipoOper,nTipo)
Local nPosTipo	:= 0
Local lNfAuto 	:= ( ValType(xAutoCab) == "A"  .AND. ValType(xAutoItens) == "A" )
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
Public aDocOrig := {}
Default nTipo   := 0
DEFAULT lSeek	:=	.T.
nOpcAuto := If(nOpcAuto==NIL,3,nOpcAuto)

If lNfAuto
	nPosTipo:= Ascan(xAutoCab,{|aCab| aCab[1] == "F1_TIPODOC" .OR. aCab[1] == "F2_TIPODOC"})
	nTipo	:= Val(xAutoCab[nPosTipo,2])
	If nTipo == 0
		If  Pergunte("MT466N",.T.)
			Do Case
				Case MV_PAR01 == 1 .AND. MV_PAR02 == 1//NCI
					nTipo := 6
				Case MV_PAR01 == 2 .AND. MV_PAR02 == 2//³NCP
					nTipo := 7 //SD2
				Case MV_PAR01 == 1 .AND. MV_PAR02 == 2//³NDI
					nTipo := 8 //SD1
				Case MV_PAR01 == 2 .AND. MV_PAR02 == 1//³NDP
					nTipo := 9
			EndCase
		EndIf
	EndIf

	If nTipo == 7 .or. nTipo == 9
		lFolios := .F.
	EndIf
Else
	If nTipo == 0
	If  Pergunte("MT466N",.T.)
		Do Case
			Case MV_PAR01 == 1 .AND. MV_PAR02 == 1//NCI³
				nTipo := 6
			Case MV_PAR01 == 2 .AND. MV_PAR02 == 2//³NCP³
				nTipo := 7
			Case MV_PAR01 == 1 .AND. MV_PAR02 == 2//³NDI³
				nTipo := 8
			Case MV_PAR01 == 2 .AND. MV_PAR02 == 1//³NDP³
				nTipo := 9
			Case cPaisLoc == 'COL' .and. FINDFUNCTION( 'LxObtTpCol' )
				nTipo := LxObtTpCol( MV_PAR01,  MV_PAR02) //Nota Ajuste Locxcol
		EndCase
		If MV_PAR01 <> 1
			lFolios := .F.
		EndIf
	EndIf
	EndIf
Endif
If PCount() >= 2 .AND. cModulo == "EIC"
	LocxNCPEic(xAutoCab,xAutoItens,nOpcAuto)
	Return
EndIf
//³Chamando programas de Notas Fiscais³
If nTipo <> 0
	LocxNf(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek,nTipoOper)
EndIf
Return nTipo
/*
±±³Funcao    ³Mata463N    ³ Autor ³Bruno Sobieski   ³ Data ³27.05.2002³±±
±±³Descri‡…o ³Chamada do recibo de servicos(compras)³±±
*/
Function Mata463N(xAutoCab,xAutoItens,nOpcAuto,lSeek)
Local cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
DEFAULT lSeek	:=	.T.

LocxNf(15,xAutoCab,xAutoItens,nOpcAuto,cFunName,lSeek)
Return
/*
±±³Fun‡…o    ³ LOCXNF   ³ Autor ³ Guilherme/Leandro C. G.³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Notas Fiscais  ³±±
*/
Function LOCXNF(nTipo,xAutoCab,xAutoItens,nOpcAuto,cFuncName,lSeek,nTipoOper,xRatEvEz,xCartaPorte)
Local cMsgCFD   := ""
//Local FilD1D2   := ""
Local cLocxFil  := ""
Local cNotaTip  := "3,5"
Local cRetPe    := ""
//Local cAlias    := ""
//Local cCamposAd := ""
Local aPerg := {'MATXNF',.T.}
Local aRetPE  	:= {}
Local nX	  	:= 0					//Variavel de controle de LOOP
Local lCtbInTran:= .T.
Local aPergs			:=	{}	//Array com o conteudo das perguntas feitas na tela de NF
/*	[SlAmarraca 1]-Incluir Amarracao  ? (Cli.xProd.) ou (For.xProd.)
	[SlGerCtbil 2]-lanç. On-Line?
	[SlVerCtbil 3]-Mostra Lanç.Contab ?
	[SlAglutina 4]-Aglut Lançamentos  ?
	[SlQbraAliq 5]-Quebra do Rodapé   ? Por Alíquota/Por Imposto
   	[SlCtbEmiss 6]-Contabiliza por    ? Emissao/Data Base
*/
Local cFilSQL:='' //gsa
Local nTipoRem := 0
Local lLocxPdv  := ExistBlock("LOCXPDV")
Local cPdvFijo := ''
local nXy := 0
Local lfina998 := IsInCallStack("FINA998")
Private nVlTit := 0
Private oMultNat := NIL
Private aIndD1D2:=	{} //Array necessario para a funcao FilBrowse
Private aCfgNF	:=	{}	//Array com todas as configuracoes da NF
Private oModelAct := Nil
/*	[SnTipo]	- codigo do tipo de NF
  	[ScEspecie]	- codigo da especie da NF
    [ScCliFor]	- indica se e cliente("C") ou fornecedor("F")
	[SlFormProp]- indica se e formulario proprio(0) ou nao(1)
	[SAliasHead]- arquivo de cabecalho da nota
	[SAliasCols]- arquivo de itens da nota
	[ScOpEstoq]	- indica se soma ou subtrai o estoque
	[ScAliasFin]- arquivo financeiro a atualizar
	[ScOpFin]	- indica sinal para movimentacao financeira
	[ScTipoDoc]	- tipo de documento {N- ;C- ;D-	;B)
	[SaAtualiza]- array com as permissoes para efetuar movimentacoes
	[SaLancPadC]- Array contendo o numero dos lancamentos padrao referentes a Cabecalho
	[SaLancPadI]- Array contendo o numero dos lancamentos padrao referentes a Itens
    [SaBotoes]	- Array com os botoes da tela, quando for tela
    [SaTeclas]	- Array com as funcoes chamadas por tecla te atalho e todas as respectivas teclas
	[SaPergs]	- Array com as perguntas efetuadas na entrada da NF (aPergs)
    [SaPE]		- Array com todos os pontos de entrada em suas devidas posicoes, de acordo com o tipo de Nota
    [SlRemito]	- Define se se trata de um remito
    [ScDescri]	- Descricao do documentro
    [SaCposBr]	- Campos que serao exibidos no Browse
*/
Private aPE	:= Array(SnMaxPE,2)	//Array com os pontos de entrada
/*	[1]- No inicio da rotina da tela que cria a EnchoiceBar
	[2]- Antes de comecar a montagem da tela, aCols e aHeader
	[3]- Apos o Ponto de entrada anterior
	[4]- No inicio da Rotina de Gravacao
	[5]- Apos gravacao do Livro Fiscal
	[6]- Permite alterar o valor da duplicata
	[7]- Integracao com o Celerina, depois de gravar a NF
	[8]- Apos gravacao do arquivo de cabecalho da Nota e todas as atualizacoes referentes a este arquivo
	[9]- Apos gravacao do arquivo de cabecalho da Nota e antes das atualizacoes referentes a este arquivo
	[10]- Apos atualizacoes do arquivo SB2
	[11]- Apos a gravacao da NF fora da transacao
	[12]- Na atualizacao do arquivo SC9
	[13]- Retorna a quantidade da segunda unidade de medida
	[14]- Apos a gravacao do SD1 e todas as atualizacoes referentes a este arquivo
	[15]- Apos a gravacao do SD1
	[16]- Apos as validacoes da rotina TudOk
	[17]- Apos as validacoes de cada item (LinOk)
	[18]- Apos a gravacao do arquivo financeiro
	[19]- Tecla F4 - Pedidos de Compra em Aberto
	[20]- Permite alterar a condicao de pagamento
	[21]- Altera os vencimentos da duplicata
	[22]- Deixa alterar a data inicial da condicao de pagamento
	[23]- Alteracao do numero e prefixos do aqruivo financeiro
	[24]- Apos confirmar o numero da NF
	[25]- Apos a geracao das comissoes
' Sempre que for incluido um ponto de entrada sera preciso alterar o "Define" no inicio do fonte de nome "SnMaxPE" '*/
//³Variaveis utilizadas para serem utilizadas como referencia nos pontos de entrada³
Private cEspecie 	:= "" //Especie da NF
Private nNFTipo  	:= 0  //Tipo da NF Numerica  (1,2,3,4,5,6,7,8,9,....)
Private cNFTipo	 	:= "" //Tipo da NF caractere ("N|D|C|B..."
Private cCadastro	:= FunDesc()
Private lCliente	:=.T.
Private nMoedaNf
Private cTASARTF    := 0.000
Private cNatFin
Private aRotina		:=	{}
Private aCores		:=	{}
Private bFilBrw		:=	{|| }
Private aDupl		:={}
Private aRegsLock	:={}
Private cEspecDoc   := Space(3)
Private bDoRefresh	:= {|| NIL}
Private lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)    //Integracao SIGAEIC
Private lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) //Integracao SIGAEIC - Financeiro
Private lFacImport	:= .F.
Private l103Class	:= .F.
Private lAnulaSF3   := .F.  //Determina se anula ou exclui o registro no Livro Fiscal(MaFisAtuSF3)
Private lFiLD1D2    := GetMv('MV_FLTD1D2')
//³Uso para comprovantes fiscais digitais³
Private aGerarCFD := {}
Private lGerarCFD := .F.
//³Variaveis da Rotina Automatica     ³
Private aAutoCab	:= IIf(xAutoCab==NIL,{},xAutoCab)  			//Array do Cabecalho
Private aAutoItens	:= IIf(xAutoItens==NIL,{},xAutoItens)		//Array dos Itens
Private aRatEvEz	:= IIf(xRatEvEz==NIL,{},xRatEvEz)		//Array dos Itens miltinaturaleza
Private cFunName	:= IIf(cFuncName==NIL .Or. Empty(cFuncName),Upper(Alltrim(FunName())),cFuncName)	//Funcao Origem
Private lLocxAuto	:= ( ValType(xAutoCab) == "A" .AND. ValType(xAutoItens) == "A" )
Private l103Auto	:= lLocxAuto	// Compatibilidade com as rotinas do MATA103()
Private lAtuFor		:= .F.
Private cPathXML	:= "", _cArq:="", _cRFC:="", _cRFCRec:="", _cUUID:=""
If cPaisLoc == "GUA"
	Private cMotivo     := Space(6)
	Private lGeraNCC    := .F.
	Private aDadosSF2   := {}
	Private aDadosSD2   := {}
	Private cNumResol   := Space(TamSX3("FQ_RESOLUC")[1])
EndIf
Private aTrocaF3	:= {}
PRIVATE aMemoSDE    := {}
PRIVATE aNotasTrf	:= {}
If funname() != "FINA100"
	PRIVATE aImpIB2		:= {}
EndIf
PRIVATE aImpCCO		:= {}
PRIVATE aImpSFC		:= {}
PRIVATE aImpSFF		:= {}
PRIVATE aImpSFH		:= {}
PRIVATE aImpLivr	:= {}
PRIVATE aTesMXF		:= {}
PRIVATE cUltCpo		:= ""
If !(cPaisLoc=="ARG" .and. (funname() $ "FINA846|FINA935|FISA828" .Or. lfina998) )
	Private cLocxNFPV	:= "" //- Armazenara o número do PV p/ argentina
EndIf
Private cIdPVArg	:= "" //- Armazenara o id do PV p/ argentina
Private lActFjRm	:= .F.
Private cFactApoc   := ""
Private cCompOnL    := SuperGetMV("MV_NCCONL",.F.,"")
Private cCFDUso     := Alltrim(GetMv("MV_CFDUSO", .T., "1"))
Private lFilPV:=.T.
Private aTESPedC    := {}
If cPaisLoc =='EQU' .and. nTipo == 1
	Private cFormCrbo   := "" //Forma de Cobro EQU
EndIf
Private aCartaPorte	:= IIf(xCartaPorte==NIL,{},xCartaPorte)  			//Array de Carta Porte

Default nTipo 	 	:= 1
If cPaisLoc=="ARG"   .And.  !(FunName() $ ("FINA846|FINA935|FISA828") .Or. lfina998)
		cLocxNFPV	:= Space(Tamsx3("F1_PV")[1])
EndIf
nOpcAuto := IIf(nOpcAuto == NIL,3,nOpcAuto)//3-Inclusao | 5-Exclusao
If lIntegracao .AND. nTipo==10
	IF !ChkFile("SWN",.F.)
		HELP(" ",1,"SWNEmUso")
		Return(.F.)
	Endif
Endif
If ( Type("lLocxAuto") <> "U" .AND. lLocxAuto ) .and. nOpcAuto == 3 .and. cPaisLoc == "ARG"
	If Len(xAutoCab[1]) > 0
		cUltCpo := nRetOrdem(Iif(Substring(xAutoCab[1][1],1,2)=="F1","SF1","SF2"))
	Endif
EndIf
SX3->(dbSetOrder(1))
//³Chama o grupo de Perguntas e acerta o array de perguntas O tipo da variavel aPergunta estah sendo modificado para que a funcao Pergunte nao
//restaure a pergunta anterior
If Type("aPergunta")=="A"
	aPergunta  := NIL
EndIf
//³PE de para adicionar grupos de perguntas ³
If ExistBlock('LOCXPERG')
	aPerg := Execblock('LOCXPERG',.F.,.F.,nTipo)
EndIf
//³PE de para adicionar Tipos de Nota  nas perguntas ³
If ExistBlock('LOCXOKPG')
	cRetPe := Execblock('LOCXOKPG',.F.,.F.,{cNotaTip})
	If VALTYPE(cNotaTip) == "C"
		cNotaTip:=cRetPe
	EndIf
EndIf
//³Chama o grupo de Perguntas e acerta o array de perguntas³
aPerg := If(AllTrim(Str(nTipo,2))$cNotaTip,{'MATXNF',.T.},{'MTXRED',.T.})

If lLocxAuto
	Pergunte(aPerg[1],.F.)
Else
	If !Pergunte(aPerg[1],aPerg[2])
		Return .F.
	Endif
EndIf
//Opción de compensación OnLine
If Valtype(cCompOnL) == "U" .Or. Empty(cCompOnL) .Or. !(cCompOnL $ "1|2|3")
	If cPaisLoc == "MEX" .And. cCFDUso <> "0"
		cCompOnL := "1" //Fact. Electrónica y compensa en línea
	ElseIf cPaisLoc $ "CHI|COL|EQU|PER|BOL|PAR"
		cCompOnL := "2" //Fact. Electrónica y NO compensa en línea (por tiempo de espera en retorno de estatus de timbrado)
	Else
		cCompOnL := "3" //NO Fact. Electrónica y compensa en línea
	EndIf
EndIf
LoadPergs(aPerg,@aPergs)
//Leandro Prado - 21/02/2014 - Controle de Ponto de Venda
lFilPV:=.T.
If (cPaisLoc == "ARG") .and. ExistBlock("DESAPV")
	lFilPV:=.F.
EndIf
If (cPaisLoc == "ARG") .AND.lFilPV .And. ( ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA462N|MATA462DN|MATA462TN|MATA102DN|FINA096|MATA462R") .or. (FUNNAME() == "FINA074" .Or. (FUNNAME() == "FINA095" .And. nTipo <> 9)))
	nTipoRem := MV_PAR01
	If (lFolios .and. !(cFunName== "MATA462DN"))  .or. (cFunName== "MATA462DN" .and. ntipo<>53 )
		If lLocxPdv
			cPdvFijo := ExecBlock("LOCXPDV",.F.,.F.,{cFunName, ntipo})
			MV_PAR01 := cPdvFijo
		Endif
		If Empty(cPdvFijo)
			If !Pergunte("PVXARG",.T.)
				Return .F.
			Endif
		Endif
 		cLocxNFPV := MV_PAR01
 		cIdPVArg := POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
 		If !F083ExtSFP(MV_PAR01, .T.)
 			Return .F.
 		EndIf
 		If cFunName == "MATA462N"
 			MV_PAR01 := nTipoRem
 		EndIf
 	EndIf
EndIf
If aPerg[1] == "MTXRED"
	AAdd(aPergs,.F.)
Endif
//³Monta array de configuracao da NF ³
aCfgNF := MontaCfgNf(nTipo,aPergs,.T.)
If Empty(aCfgNF)
	Return .F.
EndIf
//Nao e permitido utilizar lanç On-Line com TTS ativado (c/ excecoes)
If ( aCfgNf[SaPergs][SlGerCtbil] .And. __TTSInUse .And. !cPaisLoc $ "PTG|ARG|MEX|BOL|CHI|URU|COL|RUS|PER|VEN|PAR|EUA|EQU|" )
	// Verifica se contabilizacao pode ser executada dentro da transacao
	If cPaisLoc == "PER"
		lCtbInTran := IIf(CTBINTRAN(1,aCfgNf[SaPergs][SlVerCtbil]),.T.,.F.)
	EndIf
	If ( cPaisLoc <> "PER" .Or. (cPaisLoc == "PER" .And. !lCtbInTran) )
		HELP(" ",1,"460TTSLANC")
		Return .F.
	EndIf
Endif
//³Incilializa variaveis privates³
NFSetPrv(aCfgNF)
cCadastro:= aCfgNF[ScDescGer]
cEspecDoc  := aCfgNF[ScEspecie]
//³Acertando o F12.                    ³
If cPaisLoc == "ARG" .And. ( Subs(cFunName,1,3) $ "PMS" .Or. cFunName $ "MATA462N|MATA521B|" .Or. funname() == "ARGREMELET")
	SetKey(VK_F12, Nil)
Else
	SetKey(VK_F12, aCfgNF[SbF12])
EndIf
//³Acertando arrauy dos PE³
aPE	      := aClone(aCfgNF[SaPE])
//³ PE para adicao de campos memo do usuario       ³
cPe	:= LocxPE(73)
If !Empty(cPE)
	If Valtype(	aMemUser := ExecBlock( cPE, .F., .F. ) ) == "A"
		aEval( aMemUser, { |x| aAdd( aMemoSDE, x ) } )
	EndIf
EndIf
//³Monta aRotina, Browse e configracoes da tela³
aRotina := MenuDef()
nX	:=	Iif((cPaisLoc == "RUS"), Len(aRotina)+1, 4)
If lIntegracao .AND. '10' $ aCfgNf[ScFilRot]
	AAdd(aRotina,{ OemToAnsi(STR0161),"LocxDlgNF(aCfgNF,4,bFilBrw)", 0 , 4,0,NIL}) //"Classificar"
	nX++
Endif
//Nao permitir a exclusao dos docs. emitidos de acordo com a SAT - Loc. Guatemala// Nao permitir exclusao de notas fiscais Loc. Rep. Dom.
If IIf(cPaisLoc == "DOM" .AND. (aCfgNF[SAliasHead] == "SF2" .OR. aCfgNf[ScEspecie] $ "NCC"),.F.,.T.) .And. IIf(cPaisLoc == "GUA",aCfgNF[SnTipo] >= 50,.T.) .And. IIf(cPaisLoc == "MEX",IIf( ( (cFunName $ "MATA467N/MATA465N") .And. (SuperGetMV("MV_BORRFAT",,.T.)) ) .Or. ( !(cFunName $ "MATA467N/MATA465N") ),.T.,.F.),.T.)
	If !(cFunName $ "MATA103CG/MATA103CF/MATA462G")
		AAdd(aRotina,{ OemToAnsi(STR0025	) 	,"LocxDlgNF(aCfgNF,"+STR(nX,1)+",bFilBrw)", 0 , 5,0,NIL}) //"Excluir"
	   nX++
	EndIf
	If  cPaisLoc == "ARG"
		If  cFunName == "MATA462N"
			AAdd(aRotina,{ OemToAnsi(STR0189) 	,"LocxAnula(aCfgNF,"+STR(nX,1)+",bFilBrw)" , 0 , 5,0,NIL}) //"Anular"
			nX++
		EndIf
	Endif
EndIf
If aCfgNf[SlFormProp] .AND.  !aCfgNf[ScEspecie] $ "RFN|RFD|RFB|RET|RCB|RCD" .AND. ;
   IIf(Trim(aCfgNf[ScEspecie])=="NF" .AND. aCfgNf[SnTipo]==11,.F.,.T.)
	AAdd(aRotina,{ OemToAnsi(STR0189	) 	,"LocxAnula(aCfgNF,"+STR(nX,1)+",bFilBrw)" , 0 , 5,0,NIL}) //"Cancelar"
	nX++
EndIf
//#PORTUGAL#
/*If (cPaisLoc == "PTG") .and. ( cFunName == "MATA462N")
   AAdd(aRotina,{ OemToAnsi(STR0318),"MATR662B()",0,5,0,NIL}) //"Imprimir"
	nX++
EndIf*/
If (cPaisLoc == "RUS") .and. ( cFunName == "MATA462N")
	aAdd(aRotina,{STR0391, "RU05R02()", 0, 7, 0, NIL}) //print report M-15
	nX++
EndIf
If cPaisLoc == "MEX" //Accciones
	LXMexAcc(@aRotina)
EndIf
If cPaisLoc == "RUS"  .And. (cFunName$ "MATA101N")
	aAdd(aRotina,{STR0389,"RU02R01()", 0, 6, 0, Nil})
	aAdd(aRotina,{STR0386,"RU02R02()", 0, 7, 0, Nil})//print report M-7
	aAdd(aRotina,{STR0388,"RU02R03()", 0, 8, 0, Nil})//print report TORG-1
	aAdd(aRotina,{STR0390,"RU02R04()", 0, 9, 0, Nil})//print report TORG-2
EndIf
//³Gera faturas eletronicas³
lGerarCFD := .F.
aGerarCFD := {}
If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
	If !(cPaisLoc $ "PTG|ANG")
		aGerarCFD := CFDVerific()
	Else
		aGerarCFD := {"0"}
	Endif
	If cCompOnL == "1" //Fact. Electrónica y compensación Online
		If Empty(aGerarCFD[2])
			lGerarCFD := .T.
			If aCfgNF[SAliasHead] == "SF2"
				If cFunName $ "MATA467N|MATA465N" .And. (nNFTipo == 1 .Or. nNFTipo == 2 .Or. nNFTipo == 21)
					AAdd(aRotina,{OemToAnsi(STR0247),"CFDGerXML(SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE)",0,2,0,NIL})
				EndIf
				If cFunName == "MATA467N" .And. (nNFTipo == 1 .Or. nNFTipo == 21) .and. FindFunction("LxCartaPor") .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0
					AAdd(aRotina,{OemToAnsi(STR0438),"LxCartaPor('SF2',SF2->F2_FILIAL,SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_ESPECIE,SF2->F2_TPCOMPL=='S',.T.)",0,2,0,NIL}) //"Carta Porte"
				EndIf
			Else
				If cFunName $ "MATA465N" .And. nNFTipo == 4
					AAdd(aRotina,{OemToAnsi(STR0247),"CFDGerXML(SF1->F1_ESPECIE,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE)",0,2,0,NIL})
				EndIf
			EndIf
		Else
		    If !lLocxAuto
				cMsgCFD := ""
				For nX := 1 To Len(aGerarCFD[2])
					cMsgCFD += aGerarCFD[2][nX][2] + CRLF
				Next
				MsgAlert(cMsgCFD,STR0248)
			Endif
		Endif
	Else
		lGerarCFD := .F.
	Endif
Endif
If cPaisLoc == "PAR" .and. cFunName == "MATA467N" .and. aGerarCFD[1] <> "0"
	AAdd(aRotina,{OemToAnsi(STR0427),"M486PAGOS(SF2->F2_ESPECIE, SF2->F2_DOC, SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_COND, SF2->F2_VALBRUT,4)",0,2,0,NIL}) //"Registro Pagos"
EndIf
If !lFiLD1D2.OR. Alltrim(Str(nTipo))$"1|10|50|60|11|12|13|14|17|18|19|20|21"
	AAdd(aRotina,{ OemToAnsi(STR0017)   ,"LocxLegenda()",0 , 2,0,.F.} )
	If aCfgNF[SAliasHead] == "SF2"
		AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"01"'	, 'DISABLE'})		// NF Normal
		If cPaisLoc == "EQU"
			AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"17"', 'BR_BRANCO'})	// Nota de Venta
		ElseIf cPaisLoc == "AUS"
			AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"18"', 'BR_BRANCO'})	// RCTI
		ElseIf cPaisLoc  $ "MEX|PER"
			If cPaisLoc == "MEX"
				AAdd(aCores,{ 	'F2_TIPO	==	"N" 	.AND. F2_TIPODOC	==	"21"', 'BR_VERDE'})	 // Traslado - México
			Else
				AAdd(aCores,{ 	'F2_TIPO	==	"A" 	.AND. F2_TIPODOC	==	"19"', 'BR_BRANCO'}) // Adiantamento
			EndIf
		EndIf
		AAdd(aCores,{  'F2_TIPO	==	"C"	.AND. F2_TIPODOC	$	"02/03"'		, 'BR_PINK'})		// NF de Compl. Preco/Frete
		AAdd(aCores,{  'F2_TIPO	==	"B"	'										, 'BR_CINZA'})		// NF de Beneficiamento
		AAdd(aCores,{  'F2_TIPO	==	"D"	.AND. F2_TIPODOC	$	"06/07"' 		, 'BR_AMARELO'}) 	// NF de Devolucao
		AAdd(aCores,{  'F2_TIPO	==	"D"	.AND. F2_TIPODOC	==	"61"' 			, 'BR_AZUL'})		// Remito de devolucao
		AAdd(aCores,{  'F2_TIPO	==	"N"	.AND. F2_TIPODOC	==	"50"' 			, 'BR_MARROM'})		// Remito
		AAdd(aCores,{  'F2_TIPO	==	"B"	.AND. F2_TIPODOC	==	"54"'    		, 'BR_PRETO'}) 		// Remito transf.
	ElseIf aCfgNF[SAliasHead] == "SF1" .And. SuperGetMV("MV_CONFFIS",.F.,"N") == "S" .And. cFunName $ "MATA102N|MATA462DN|MATA101N|MATA466N"
		If lIntegracao
			AAdd(aCores,{'Empty(F1_STATUS) .AND. !Empty(F1_TIPO_NF)'																,'BR_VERDE'})		// NF Importacao (nao classificada)
			AAdd(aCores,{'F1_STATUS=="A" .AND. !Empty(F1_TIPO_NF)'																	,'BR_PRETO'})	    // NF Importacao (classificada)
		Endif
		AAdd(aCores,{  '((F1_STATCON $ "1|4") .OR. EMPTY(F1_STATCON)) .And. F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"10"   '	, 'DISABLE'})		// NF Normal
		AAdd(aCores,{  '((F1_STATCON $ "1|4") .OR. EMPTY(F1_STATCON)) .And. F1_TIPO	==	"C"	.AND. F1_TIPODOC	$	"08/09"'	, 'BR_PINK'})		// NF Compl. Preco
		AAdd(aCores,{  'F1_TIPO	==	"B"	.AND. F1_TIPODOC	<>	"63"   '																, 'BR_CINZA'})		// NF Beneficiamento
		AAdd(aCores,{  'F1_TIPO	==	"D"	.AND. F1_TIPODOC	$	"04/05"'    															, 'BR_AMARELO'})	// NF Devolucao
		AAdd(aCores,{  '((F1_STATCON $ "1|4") .OR. EMPTY(F1_STATCON)) .And. F1_TIPO	==	"D"	.AND. F1_TIPODOC	$	"51/53"'	, 'BR_AZUL'})		// Remito devolucao
		AAdd(aCores,{  '((F1_STATCON $ "1|4") .OR. EMPTY(F1_STATCON)) .And. F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"60"   '	, 'BR_MARROM'})	// Remito
		AAdd(aCores,{  'F1_TIPO	==	"C"	.AND. F1_TIPODOC	$	"13/14"'																, 'BR_LARANJA'})	// Desp.Importacao
		AAdd(aCores,{  'F1_TIPO	==	"B"	.AND. F1_TIPODOC	==	"63"   '																, 'BR_BRANCO'})	// NF de Ret.Simbolico
		AAdd(aCores,{  'F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"64"   '																, 'BR_PRETO'})	    // Remito Transferencia
		AAdd(aCores,{  '!(F1_STATCON $ "1|4") .AND. !EMPTY(F1_STATCON)'																, 'BR_VIOLETA'})  // NF Bloq. para Conferencia
		If cPaisLoc $ "|MEX|PER|"
			AAdd(aCores,{ 	'F1_TIPO	==	"A" 	.AND. F1_TIPODOC	==	"20"'															, 'BR_BRANCO'})	// Adiantamento
        Endif
	ElseIf aCfgNF[SAliasHead] == "SF1"
		If lIntegracao
			AAdd(aCores,{'Empty(F1_STATUS) .AND. !Empty(F1_TIPO_NF)','BR_VERDE'})				// NF Importacao (nao classificada)
			AAdd(aCores,{'F1_STATUS=="A" .AND. !Empty(F1_TIPO_NF)','BR_PRETO'})	    			// NF Importacao (classificada)
		Endif
		AAdd(aCores,{  'F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"10"   '	, 'DISABLE'})		// NF Normal
		AAdd(aCores,{  'F1_TIPO	==	"C"	.AND. F1_TIPODOC	$	"08/09"'	, 'BR_PINK'})		// NF Compl. Preco
		AAdd(aCores,{  'F1_TIPO	==	"B"	.AND. F1_TIPODOC	<>	"63"   '	, 'BR_CINZA'})		// NF Beneficiamento
		AAdd(aCores,{  'F1_TIPO	==	"D"	.AND. F1_TIPODOC	$	"04/05"'    , 'BR_AMARELO'})	// NF Devolucao
		AAdd(aCores,{  'F1_TIPO	==	"D"	.AND. F1_TIPODOC	$	"51/53"'	, 'BR_AZUL'})		// Remito devolucao
		AAdd(aCores,{  'F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"60"   '	, 'BR_MARROM'})	    // Remito
		AAdd(aCores,{  'F1_TIPO	==	"C"	.AND. F1_TIPODOC	$	"13/14"'	, 'BR_LARANJA'})	// Desp.Importacao
		AAdd(aCores,{  'F1_TIPO	==	"B"	.AND. F1_TIPODOC	==	"63"   '	, 'BR_BRANCO'})	    // NF de Ret.Simbolico
		AAdd(aCores,{  'F1_TIPO	==	"N"	.AND. F1_TIPODOC	==	"64"   '	, 'BR_PRETO'})	    // Remito Transferencia
		If cPaisLoc $ "|MEX|PER|"
			AAdd(aCores,{ 	'F1_TIPO	==	"A" 	.AND. F1_TIPODOC	==	"20"', 'BR_BRANCO'})	// Adiantamento
        	Endif
		//#PORTUGAL#
		/*If cPaisLoc=="PTG"
			If cFunName$"MATA103CG/MATA103CF/MATA462G"
				aCores:={}
			EndIf
		EndIf*/
	EndIf
EndIf
//#PORTUGAL#
/*If cPaisLoc=="PTG"
	If !lFiLD1D2.OR. Alltrim(Str(nTipo))$"10$65$55"
		If cFuncname$"MATA103CG|MATA462G"
			AAdd(aRotina,{ OemToAnsi(STR0017)   ,"LocxLegenda()",0 , 2,0,.F.} )
			AAdd(aCores,{'TIPO == 0' , 'ENABLE'})   // Normal
			AAdd(aCores,{'TIPO == 1' , 'DISABLE'})  // Canceladas
		EndIf
		If cFuncname$"MATA103CF"
			AAdd(aCores,{'TIPO == 0' , 'ENABLE'})   // Normal
			AAdd(aCores,{'TIPO == 1' , 'DISABLE'})  // Canceladas
		EndIf
	EndIf
EndIf*/
aAdd(aRotina,{STR0349,"CTBC662"	, 0 , 2 , 0 , NIL})  // "Tracker Contábil"
If ExistBlock("MT462MNU")
	ExecBlock("MT462MNU",.F.,.F.)
EndIf
//PE adicionar Status a Legenda LOCXPE63
aCores:=LocxLegCor(1,aCfgNF[SAliasHead],aCores)
//#PORTUGAL#
/*If cPaisLoc=="PTG"
	If cFunName$"MATA103CG/MATA103CF/MATA462G"
		If cFunName$"MATA103CG/MATA103CF"
			cCamposAd:="F1_TIPODOC+"
			cAlias:=MontaTabEspBrow("SF1","SF1", aCfgNF[SaCposBr],{1}, cCamposAd, aParamGer)
		Else
			cCamposAd:="F2_TIPODOC+"
			cAlias:=MontaTabEspBrow("SF2","SF2", aCfgNF[SaCposBr],{1}, cCamposAd, aParamGer)
		EndIf
		aCfgNF[SAliasHead]:=cAlias
	EndIf
EndIf*/
// Rotina Automatica
If ( Type("lLocxAuto") <> "U" .AND. lLocxAuto )
	If cPaisLoc == "EUA" .And. FindFunction("LxCanNFEUA") //Ajuste para corregir el cancelamiento de NF via execauto
		LxCanNFEUA(nOpcAuto, cFunName, @lAnulaSF3, aAutoCab, aCfgNF[SAliasHead], lSeek)
	Else
		If (nOpcAuto == 6 .And. (cFunName $ "MATA467N")) ; //6-Cancelar/Anular (via execauto)
		.Or. (cPaisLoc $ "PER|MEX" .And. nOpcAuto == 6 .And. cFunName $ "MATA465N") //Anulación vía execauto para NDC y NCC
			nOpcAuto  := 5			//5-Exclusão
			lAnulaSF3 := .T.		//Determina se anula ou exclui o registro no Livro Fiscal
		EndIf
		MBrowseAuto(nOpcAuto,Aclone(aAutoCab),aCfgNF[SAliasHead],lSeek)
		If ((cFunName $ "MATA467N") .And. nOpcAuto == 5 .And. lAnulaSF3) ;
		.Or. (cPaisLoc $ "PER|MEX" .And. (cFunName $ "MATA465N") .And. nOpcAuto == 5 .And. lAnulaSF3)
			lAnulaSF3 := .F.
		EndIf
	EndIf
Else
	If lFiLD1D2
		//#PORTUGAL#
		/*If cPaisLoc=="PTG"
			If cFunName$"MATA103CG/MATA103CF"
		        cFilD1D2 := PrefixoCpo("SF1")+"_TIPODOC $ '"+aCfgNF[ScFilRot]+"/08/04'"
 		 	ElseIf cFunName$"MATA462G"
		        cFilD1D2 := PrefixoCpo("SF2")+"_TIPODOC $ '" + aCfgNF[ScFilRot] + "'"
		 	Else
			 	cFilD1D2 := PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC $ '" + aCfgNF[ScFilRot] + "'"
			 	cFilSQL :=PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC IN ('" + STRTRAN (aCfgNF[ScFilRot] , "/" , "','" ,1,len(aCfgNF[ScFilRot]) ) + "')" //GSA
		 	EndIf
		Else*/
	        cFilD1D2 := PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC $ '" + aCfgNF[ScFilRot] + "'"
	        cFilSQL :=PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC IN ('" + STRTRAN (aCfgNF[ScFilRot] , "/" , "','" ,1,len(aCfgNF[ScFilRot]) ) + "')" //GSA
	 	//EndIf
		If ExistBlock("LOCXFILT")
			cLocxFil := ExecBlock("LOCXFILT",.F.,.F.,{PrefixoCpo(aCfgNF[SAliasHead]),aCfgNF[ScFilRot],cFilD1D2} )
			If ( ValType(cLocxFil) == "C" ) .And. !Empty(cLocxFil)
				cFilD1D2 += IIf(Empty(cFilD1D2),"",".And.")+cLocxFil
			EndIf
		EndIf
		lFilPV:=.T.
		If (cPaisLoc == "ARG") .and. ExistBlock("DESAPV")
			lFilPV:=.F.
		EndIf
		If (cPaisLoc == "ARG") .And. lFilPV  .And. ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA462N|MATA462DN|MATA462R") .And. lFolios // Leandro Prado - 21/02/2014 - Controle de Ponto de Venda.
			cFilD1D2 += IIf(Empty(cFilD1D2),"",".And. " ) + PrefixoCpo(aCfgNF[SAliasHead]) + "_PV $ '" + cLocxNFPV + "'"
        EndIf
       	if cPaisLoc <> "ARG" .AND. !AllTrim(cFunName)$"MATA101N/MATA102N/MATA462N/MATA462DN/MATA465N/MATA467N/MATA466N" .and. !(cPaisLoc == "RUS" .AND. AllTrim(cFunName)$"MATA466N/MATA467N")
       		bFilBrw	:=	{|| FilBrowse(aCfgNF[SAliasHead],@aIndD1D2,@cFilD1D2)}
       		Eval(bFilBrw)
       	endif
	Endif
	If nTipoOper <> Nil
		nRotina := aScan(aRotina, {|x| x[4] == nTipoOper})
		If nRotina > 0
			// executa qualquer rotina
			&(aRotina[nRotina][2])
		EndIf
	Else
		cPE := LOCXPE(61)	//³PE para adicionar campos no browse ³
        If !Empty(cPE)
			aRetPE:= ExecBlock(cPE,.F.,.F.,{IIF(ValType(cFuncName)=="C",cFunName,""),nOpcAuto,nTipo,aCfgNF[SAliasHead],aCfgNF[SaCposBr]})
			If ValType(aRetPE) == "A"
				aCfgNF[SaCposBr]  := aClone(aRetPE)
			EndIf
        EndIf
        // Consulta Padrao
        If FunName()=="MATA465N"
	    	aTrocaF3:= AltConPad("F1_FORNECE","SA1")
        EndIf
        If FunName()=="MATA466N"
	        aTrocaF3:= AltConPad("F2_CLIENTE","SA2")
	  	EndIf
	  	If cFunName $ "MATA101N/MATA465N|MATA466N" .and. cPaisLoc == "ARG" .or. !EMPTY(cLocxNFPV)  .or. (!lFilPV .and. cPaisLoc == "ARG") .Or. (cPaisLoc == "RUS" .And. cFunName $ "MATA466N/MATA467N")
			oObj := FwMBrowse():New()
			If PrefixoCpo(aCfgNF[SAliasHead]) == "F1"
				oObj:SetAlias("SF1")
			Else
				oObj:SetAlias("SF2")
			EndiF
			For nXy:=1 To Len(aCores)
				oObj:addLegend(aCores[nXy][1],aCores[nXy][2])
			Next nXy
			If PrefixoCpo(aCfgNF[SAliasHead]) == "F1"
				if Empty(cLocxNFPV)
					oObj:addFilter("Filtro Padron","SF1->"+cFilD1D2,.T.,.T.,,.T.)
				Else
					oObj:addFilter("Filtro Padron","SF1->("+cFilD1D2+") ",.T.,.T.,,.T.)
				EndIf
			Else
				if Empty(cLocxNFPV)
					oObj:addFilter("Filtro Padron","SF2->"+cFilD1D2,.T.,.T.,,.T.)
				Else
					oObj:addFilter("Filtro Padron","SF2->("+cFilD1D2+") ",.T.,.T.,,.T.)
				EndIf
			EndiF
			oObj:Activate()
	  	Else
	  	    If cFunName $ "MATA101N/MATA102N/MATA465N/MATA462N/MATA462DN/MATA467N/MATA466N"
	  	    	mBrowse(6,1,22,75,aCfgNF[SAliasHead],aCfgNF[SaCposBr],,,,,aCores,,,,,,,,cFilSQL)
	  	    Else
	  	    	mBrowse(6,1,22,75,aCfgNF[SAliasHead],aCfgNF[SaCposBr],,,,,aCores)
	  		EndIf
		EndIf
	Endif
	If lFiLD1D2
		If cPaisLoc <> "ARG" .AND. !cFunName$"MATA103CG/MATA103CF/MATA462G/MATA101N/MATA102N/MATA465N/MATA462N/MATA462DN"
			EndFilBrw(aCfgNF[SAliasHead],@aIndD1D2)
		EndIf
	Endif
Endif
SetKey(VK_F12	,{|| Nil })
Return .T.
/*³ ³LocxDlgNF  Monta a Dialog para as Notas Fiscais                          ³
Parametros
a__CfgNf - Array com todas as configuracoes da NF, conteudo na declaracao da variavel,
 __nOpcx - Opcao do arotina
	(2)	- Visualizar
	(3)	- Incluir
	(4)	- Excluir */
Function LocxDlgNF(a__CfgNf,__nOpcx,bFilBrowse)
//Local aAreaF1 		:= {}
Local cHawb			:= ""
Local lOutrasNF		:= .F.
Local nX 			:= 0			//Flag para Loop's
Local aArea			:= { Alias() , IndexOrd() , RecNo() } //Area da entrada da rotina
Local aCposNF		:=	{}			//Campos do cabecalho da NF, que serao utilizados
Local aObjsNF		:=	{}			//Array contendo os objetos que devem ser criados na tela com seus devidos comando de criacao
Local aUsObjNF      := {}
Local cFunOk        := NIL
Local cLinOk        := NIL
Local nOpca			:=	aRotina[__nOpcx][4]
Local aCposRodape	:=	{}			//Array com dados e configuracoes do Rodape
Local aMoedas 		:= 	{}			//Array com as moedas em uso
Local cVld 			:= ""			//String coma validacao de campos do SX3 mais as validacoes manuais
//Local cValBrut   	:= ""
Local cCont      	:= ""
Local cAliasGrid 	:= ""
Local cWhileGrid 	:= ""
Local cSeekGrid  	:= ""
Local cSerSXBa      := "01"
Local cSerSXB       := "01"
Local nIndGrid   	:= 1
Local cCondIf    	:= NIL
Local aParCols   	:= {}
Local aOpcTeclas  	:= {}
Local aUsButtons 	:= {}
Local cOnInit     	:= ""
Local nItens     		:= GetMV("MV_NUMITEN")
//Local nAuxItens  	:= 0
//Local aTiposNF    	:= NIL
Local cFieldOk    	:= "NFFldOk()"
Local bSavF12		:=	SetKey(VK_F12)
Local cFunCanc
Local aBotoes		:= {}
//Local aTeclas		:= {}
Local aCposExt  	:= NIL
Local cWhen     	:= NIL
Local nPos			:=	0
Local cAgente   	:= GetNewPar("MV_AGENTE", "   ")
Local aEspecies		:= {{'SF2 /SF2N/SF2B','MATA467N/MATA462N'},;
							 {'SF2C/SF1D','MATA465N'},;
							 {'SF1C'	 ,'MATA466N/MATA101N'},;
							 {'SF2D'	 ,'MATA466N'},;
							 {'SF1 /SF1N/SF1B','MATA101N/MATA102N/MATA463N'}}
Local aSizeAut		:= MsAdvSize(,.F.,200)
Local aObjects		:= {}
Local aInfo		 	:= { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 }
Local aPosObj	    :=	{}
Local aCoordGD   	:= {060,002,130,317}	//Array com as coordenadas da GetDados
Local aCordW    	:= Nil
Local aPosFold		:=	{132,002,315,074}
Local lChange		:= GetMV("MV_GETNREM")
Local lVer116  		:= .T.
Local lRetOrigem    := .T.
Local lSeqEspecie   := SuperGetMV("MV_SEQESPE",,.F.)
Local aOrdItem		:= {}
Local xRet
Local lCodBar		:= .F.
Local dDatRet       := MVUlmes()
Local cMsgCFD       := ""
Local lContrFol     :=	.F.
//Local cAliasAtual   := ""
//Local nRecnoAtual   := 0
// Passagens aereas - Bolivia
Local lPassag 	:= 	cPaisLoc == "BOL" .And. GetNewPar("MV_PASSBOL",.F.)
Local lTipComp  :=  cPaisLoc == "BOL"
//Local cMsgPTG   := ""
//Local cAliasCab := ""
//Local cAliasIte := ""
Local aCposPE	:={}
Local cFilSF1	:= xFilial("SF1")
Local cFilSF2	:= xFilial("SF2")
Local lEditImp  := GetNewPar( "MV_EDITIMP", .F. )
Local cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
Local cDescSai	:= GetNewPar('MV_DESCSAI','1')
Local dDataBloq	:= GetNewPar("MV_ATFBLQM",CTOD("")) //Data de Bloqueio da Movimentação - MV_ATFBLQM
Local lRet			:= .T.
Local dDataRef	:= CTOD("  /  /  ")
//Local cSFx := "", cSFT := ""
Local cPE33 := LocxPE(33)
Local lLxWhen := .T.
Local cTabla := ""
Local cNtabla:=""
Local nTamPSE5   := TamSX3('E5_PARCELA')[1]
//Local nTamTSE5   := TamSX3('E5_TIPO')[1]
Local lRTSPAR:= .F. //RTS PARAGUAY
Local aBkpCfgInc := {}
Local lBkpCfgInc := .F.
Local lfina998  := IsInCallStack("FINA998")
//Variaveis para identificação do cliente Equ
Private cNomeCli  := ""
Private cDoctoId  := ""
Private cFunName	:= IIf(Type("cFunName")=="U" .Or. Empty(cFunName) .Or. cFunName==NIL,Upper(Alltrim(ProcName())),cFunName)
Private lInclui   	:= (nOpca==3)
Private lDeleta   	:= (nOpca==5)
Private lVisualiza  := (nOpca==2)
Private aHGastos	:= {}	//utilizados pela locxgastos
Private aCGastos	:= {}	//inclusao das despesas na nota de frete
Private aGeraCFD	:= {}
Private _nTotOper_  := 0	//contem o total de operacoes efetuadas com um cliente/fornecedor em um determinado periodo
Private _aValItem_  := 0	//contem os valores unitarios dos itens da fatura
Private aRecnoSE1 	:= {}	// Array com os Titulos de Adiantamento recebidos do financeiro para a Nota Atual.
Private lLeSDE		:= .T.
Private aImp1 := {}
Private lSerie2 := (((SF2->(FieldPos("F2_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (a__CfgNf[ScEspecie]$"NCE|NCP")) .or. (cPaisLoc == "COL" .and. aCfgNf[SAliasHead] == "SF2" ) ); // Determina o uso do campo F2_SERIE2 para o Peru
						.Or. ((SF1->(FieldPos("F1_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (Trim(a__CfgNf[ScEspecie])$"NF|NDP|NDE") .And. !a__CfgNf[SlFormProp])
Private aOPBenef	:= ""
Private lSerOri := .F.
Private aItemsPCO	:= {}
If Type('lDocSp') == "U"
	Private lDocSp := .F.
EndIf
If Type('lAutoFact') == "U"
	Private lAutoFact := .F.
EndIf
oModelAct := Nil
lBkpCfgInc := (cPaisLoc$"MEX" .And. !lInclui .And. !Empty(aCfgNf))
aBkpCfgInc := IIf(lBkpCfgInc,aClone(aCfgNf),{})
If cPaisLoc $ "MEX|PER|COL|EQU" .And. SuperGetMV("MV_PCOINTE",.F., "2") == "1"
	If Len(aCfgNf[SaLancPCO]) > 0
		PcoIniLan(aCfgNf[SaLancPCO][1]) //Inicia lanzamiento de PCO
	EndIf
Endif
If cPaisLoc == "MEX" .And. (AllTrim(FunName()) $ "MATA101N|MATA102N")
	nMoedaNF := 1
Endif
If cPaisLoc $ "ARG|CHI|BOL|PAR|URU" .And. (AllTrim(FunName()) $ "MATA101N|MATA102N|MATA102DN")
	LocxAtuMoeda(,,.t.)
Endif
If cPaisloc $ "PER|COL"
	lSerOri := ((a__CfgNf[ScEspecie]$"NCE|NCP"); // Determina o uso do campo F2_SERORI para o Peru
						.Or. ((Trim(a__CfgNf[ScEspecie]))$"NF|NDP|NDE|RCN") .And. !a__CfgNf[SlFormProp])
EndIf
If (cPaisLoc == "RUS")
	If (( __nOpcX == 5 ) .Or. ( __nOpcX == 6 )) ;
		.And. (&(aCfgNf[SAliasHead] + "->" + PrefixoCpo(aCfgNf[SAliasHead])+"_STATUSR") == "2")
		Help("",1,"LocxDlgNF",,STR0383,1,0)	// "Delete VAT Invoice linked to this record first."
		Return .F.
	EndIf
EndIf
If Type("lAtuFor") == "U"
	lAtuFor := .F.
EndIf
If !IsMemVar("cEspecie")
	Private &("cEspecie") := ""
EndIf
If __nOpcx == 3 .And. dDatRet>=dDataBase
	Help( " ", 1, "FECHTO" )
	Return(.F.)
EndIf
If (cPaisLoc == "ARG" .And. (cFunName == "MATA465N" .Or. cFunName == "MATA466N"))
	aDocOrig := {}
EndIf

// Controle de Folios - Bolivia
If cPaisLoc == "DOM" // Republica Dominicana
	lContrFol := GetNewPar("MV_CTRLFOL",.T.)
	If (!lContrFol) .AND. __nOpcx == 3
		MsgAlert(STR0285) //"Atencao o parametro MV_CTRLFOL para Controle de Folios esta desativado!"
	EndIf
ElseIf cPaisLoc <> "ARG"
	lContrFol     := cPaisLoc $ "BOL|URU" .And. AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720" ;
	                 .And. GetNewPar("MV_CTRLFOL",.F.)
Else
	lContrFol := AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720|MATA462AN" .And. GetNewPar("MV_CTRLFOL",.F.)
EndIf
If Type("lIntegracao")!= "L"
	lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)
Endif
If Type("lEICFinanc")!= "L"
	lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.)
Endif
If Type("lFacImport")!= "L"
	lFacImport	:=	.F.
Endif
Private l103Class 	:= (lIntegracao .AND. nOpca==4 )
//|Atencao: Para o Ambiente Portugal, esta parte do codigo faz a alteracao dos alias      |
//|das tabelas, em funcao da visualizacao poder ser realizada atraves do SX3 ou através   |
//|da tabela espelho que existe somente no banco de dados. No Final da Rotina, os alias   |
//|originais são restaurados.|
//#PORTUGAL#
/*If cPaisloc == "PTG"
	If cFunName$"MATA103CG/MATA103CF/MATA462G"
		cAliasAtual := Alias()
	    nRecnoAtual :=(cAliasAtual)->REGISTRO
		cAliasCab   := Iif(cFunName=="MATA462G","SF2","SF1")
		cAliasIte   := Iif(cFunName=="MATA462G","SD2","SD1")
	    If (cAliasAtual)->TIPO == 0   // Tabela normal, existe no SX3
	    	FechaTable({cAliasCab,cAliasIte,RetSqlName(cAliasCab)+"_CANC",RetSqlName(cAliasIte)+"_CANC",cAliasCab+"CURRENT",cAliasIte+"CURRENT"})
    		DbSelectArea(cAliasCab)
			MsGoto(nRecnoAtual)
	   		DbSelectArea(cAliasIte)
	   	Else   // Tabela espelho - nao existe no SX3
	    	FechaTable({cAliasCab,cAliasIte,RetSqlName(cAliasCab)+"_CANC",RetSqlName(cAliasIte)+"_CANC",cAliasCab+"CURRENT",cAliasIte+"CURRENT"})
	   	    DbSelectArea(cAliasCab)
		    DbSelectArea(cAliasIte)
		    AbreTabelaEspelho(cAliasCab,RetSqlName(cAliasCab)+"_CANC")
		    AbreTabelaEspelho(cAliasIte,RetSqlName(cAliasIte)+"_CANC")
			dbChangeAlias(cAliasCab,cAliasCab+"CURRENT")
			dbChangeAlias(cAliasIte,cAliasIte+"CURRENT")
			dbChangeAlias(RetSqlName(cAliasCab)+"_CANC",cAliasCab)
			dbChangeAlias(RetSqlName(cAliasIte)+"_CANC",cAliasIte)
			DbSelectArea(cAliasCab)
			MsGoto(nRecnoAtual)
		EndIf
	ENDIF
ENDIF*/
If !lInclui
	//#PORTUGAL#
	/*If cPaisLoc=="PTG"
		If cFunName$"MATA103CG/MATA103CF/MATA462G"
			aCfgNF := MontaCfgNf(Val(&(aCfgNf[SAliasHead]+"->"+PrefixoCpo(cAliasCab)+ "_TIPODOC")) ,aCfgNF[SaPergs],.T.)
		Else
			aCfgNF := MontaCfgNf(Val(&(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead]) + "_TIPODOC")) ,aCfgNF[SaPergs],.T.)
		EndIf
	Else*/
		aCfgNF := MontaCfgNf(Val(&(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead]) + "_TIPODOC")) ,aCfgNF[SaPergs],.T.)
	//Endif

	NFSetPrv(aCfgNF)
Endif
//³Redimensionar objetos quando a definicao eh maior o igual a 800x600³
If Type("oMainWnd")!= "U" .And. oMainWnd:nClientWidth >= 800
	AAdd( aObjects, { 0,   100, .T., .F. } )
	AAdd( aObjects, { 100, 100, .T., .T. } )
	AAdd( aObjects, { 0,    75, .T., .F. } )
	aPosObj 	:= MsObjSize( aInfo, aObjects )
	aCordW    	:= {aSizeAut[7],0,aSizeAut[6],aSizeAut[5]}
	aCoordGD	:= {aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4]+3} //Array com as coordenadas da GetDados
	aPosFold	:=	{aPosObj[3,1],aPosObj[3,2],315,074}
Endif
//³Parametro que analisa condicao para alteracao da serie da nota.³
If cPaisLoc $ "ARG|MEX"
	Private lAltSerie 	:= If(cPaisLoc == "ARG",SuperGetMV("MV_ALTSER",,.T.),SuperGetMV("MV_ALTTSR",,.T.))
	Private lFuncAtual	:= AllTrim(FunName()) $ If(cPaisLoc == "ARG","MATA101N|MATA465N|MATA466N|MATA467N","MATA462TN")
EndIf
SetKey(VK_F12,{|| Nil })
lLocxAuto  := IIf(Type("lLocxAuto") != "U",lLocxAuto,.F.)
cP1:=PrefixoCpo(aCfgNf[ScCliFor])   + "_"
cP2:=PrefixoCpo(aCfgNf[ScAliasFin]) + "_"
cP3:=PrefixoCpo(aCfgNf[SAliasHead]) + "_"
cP4:=PrefixoCpo(aCfgNf[SAliasCols]) + "_"
//#PORTUGAL#
/*If cPaisLoc$"PTG"
	If cFunName$"MATA103CG/MATA103CF/MATA462G"
		cP3:=PrefixoCpo(cAliasCab)+"_"
		cP4:=PrefixoCpo(cAliasIte)+"_"
	EndIf
EndIf*/
Private aCposNo		:=	{}
Private aCpos		:=	{}
Private aRecSE2     := {}
Private aRecSE1     := {}
Private aRecsSF1 := IIf(Type("lLocxAuto") != "U" .And. lLocxAuto, iif(Type("aRecsSF1") = "U",{},aRecsSF1),{})
Private aAmarrAFN   := {}
Private aCols     	:= {}
Private aHeader   	:= {}
Private aRatCC    	:= {}
If (cPaisLoc <> "RUS" .Or. Type("cCadastro") == "U" .Or. Empty(cCadastro))
	Private cCadastro 	:= FunDesc()
EndIf
Private aHeadSEV    := {}
Private aColsSEV    := {}
Private lContSEV    := iif(cPaisLoc <> "BRA" ,.T.,.F.)
Private lReajuste	:= .T.
Private lConsLoja	:= .T.
Private lCarteira	:= .T.
Private nMoedaCor	:= 1
Private cA100For 	:= ""
Private cLoja    	:= ""
Private dDEmissao	:= dDatabase
Private aCposTela 	:= Array(3) // 1- Campos  2- Conteudo 3-Flag que indica se deve ser totalizado. Neste caso, entende-se que na pos. 2, existe o campo (ou formula) a serem totalizados.
Private aRatAFN 	:= {} //Int.c/PMS
Private aHdrAFN 	:= {} //Int.c/PMS (Cab. da aRatAFN)
Private aRatAFS 	:= {} //Int.c/PMS
Private aHdrAFS 	:= {} //Int.c/PMS (Cab. da aRatAFN)
Private nTaxa		:= 1
Private aLivro		:= {}
Private aDescontos	:= {}
Private aImpVarSD2	:= {0,0,0,0,0,{},""}
Private aImpVarDup	:= {}
Private aGetBook	:= {}
Private cA467Cli  	:= ""
Private cNitCC		:= ""
Private lRatValor 	:= .F.
Private nTotPeso  	:= 0
Private nBsFrete1 	:= 0
Private nValNeg   	:= 0
Private nTotMerc  	:= 0
Private nTotServ  	:= 0
Private nValDesp  	:= 0
Private nSeguro   	:= 0
Private nValFrete 	:= 0
Private nValDesc  	:= 0
Private aImpS     	:= {}
Private cVenda    	:= "NORMAL"
Private cNFiscal  	:= ""
Private cSerie    	:= ""
Private l103Visual	:= !lInclui .AND. !l103Class
Private aRecSF3	  	:= {}
Private cTipo       := ""
Private aRecnos		:=	{}
Private cTipoRet    := AllTrim(Str(GetMv('MV_TIPORET')))
Private lLibImp     := GetNewPar("MV_LIBIMP","S") == "S"	// Utiliza liberacao de NF import.
Private lBloqImp    := .F.
Private lUsaCor		:= .F.
Private lCFiscal    := .F.
Private	nValNTrib	:=	0
Private	nValTara	:=	0
Private aImp		:= {}
Private cHead       := ""
Private cHeadun     := ""
Private lMetImpEdi	:=.F. // usada edicion de impuestos (FISA081 FISA0084)
If nOpca==5 .And. cPaisloc=="ARG" .And. (ALLTRIM(a__CfgNf[8])=="NDC".Or. ALLTRIM(a__CfgNf[8])=="NCC" )
cTabla:= a__CfgNf[4]
cNtabla:= RIGHT(cTabla,1)
	If  funname() <> "FINA935" .And.    SEL->(ColumnPos("EL_TIPAGR")) >0	.and. SEL->(ColumnPos("EL_DOCPOS"))>0 .and. &(cTabla)->(ColumnPos("F"+cNtabla+"_RECPOS")) >0  .and.  &(cTabla)->(ColumnPos("F"+cNtabla+"_IVAPOS")) >0 .and. SE1->(ColumnPos("E1_RECGR")) >0
		If !Empty(&(cTabla+"->F"+cNtabla+"_RECPOS")) .And. !Empty(&(cTabla+"->F"+cNtabla+"_IVAPOS"))
			MsgAlert(STR0419,STR0418)
			Return .F.
		EndIF
	EndIf
EndIf
If  nOpca==5 .And. cPaisloc=="ARG" .And. Alltrim(Funname()) == "MATA101N" .And. ALLTRIM(a__CfgNf[8])=="NF" .And. a__CfgNf[4] == "SF1"
	DbSelectArea("SE5")
	SE5->(DbSetOrder(7))
	If SE5->(MsSeek(xFilial("SE5")+ SF1->F1_SERIE + SF1->F1_DOC + SPACE(nTamPSE5))) //E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
		While !SE5->(Eof()) .And. (AllTrim(SE5->E5_CLIFOR) == AllTrim(SF1->F1_FORNECE) .And. AllTrim(SE5->E5_LOJA) == AllTrim(SF1->F1_LOJA))
		If  Alltrim(SE5->E5_ORIGEM) == "FINA100" .And. Alltrim(SF1->F1_DOC) == Alltrim(SE5->E5_NUMERO) .And. Alltrim(SF1->F1_SERIE) == Alltrim(SE5->E5_PREFIXO)
			Aviso(STR0018,OemToAnsi( STR0134 ),{STR0021})
			Return .F.
		EndIf
			DBSkip()
		EndDo
	EndIf
Endif
If ( Type("cFunName") == "C" ) .AND. ( cFunName == "MATA467N")
	Static cMTabPrc := "" // Var.p/validacao da tab.preco
Endif
If GetMv("MV_REMMAN")=="N" .AND. aCfgNF[SnTipo] == 50
	Aviso( STR0018,OemToAnsi( STR0118 ) + DESCREM + OemToAnsi( STR0119) + Chr(10) + Chr(13) + OemToAnsi(STR0120  ) ,{STR0021}) //"ATENCAO"###"Para incluir "###" manualmente inicialize o parametro MV_REMMAN com 'S' "###" ou Use Geracao Automatica" ###"OK"
	Return .F.
Endif
//Verifica se existe bloqueio contábil
If !(Empty(SF1->F1_EMISSAO)) .And. a__CfgNf[4] <> "SF2"
	dDataRef := SF1->F1_EMISSAO
ElseIf !(Empty(SF2->F2_EMISSAO)) .And. a__CfgNf[4] == "SF2"
	dDataRef := SF2->F2_EMISSAO
EndIf
If cPaisLoc == "ARG" .and. (Type("CRELEASERP") == "C" .and. Val(Substr(CRELEASERP,6,3)) < 23)
	UpdValImp()
EndIf
If lDeleta .And. cPaisLoc == "CHI" .AND.(IIf(a__CfgNf[4]== "SF1",SF1->(ColumnPos('F1_FLFTEX'))>0 .And. SF1->F1_FLFTEX == "6",SF2->(ColumnPos('F2_FLFTEX '))>0 .And. SF2->F2_FLFTEX == "6"))
	Alert(STR0402) // Nota fiscal autorizadas nao pode ser excluida
	Return .F.
ElseIf !(Empty(dDataRef)) .And. lDeleta
	If lRet := (CtbValiDt(Nil,dDataRef,/*.T.*/ ,Nil ,Nil ,{"COM001"}/*,"Data de apuração bloqueada pelo calendário contábil."*/))
		If (!Empty(dDataBloq) .AND. (dDataRef <= dDataBloq))
			Help(" ",1,"ATFCTBBLQ") //P: Processo bloqueado pelo Calendário Contábil ou parâmetro de bloqueio nesta data ou período. S: Caso possível altere a data de referência do processo, verifique o parâmetro ou contate o responsável pelo Módulo Contábil.)
			Return .F.
		EndIf
	End
	If !lRet
		Return .F.
	EndIf
EndIf
If lRet .And. lDeleta .And. cPaisLoc == "ARG" .AND. IIf(a__CfgNf[4]== "SF1",SF1->(ColumnPos("F1_CC"))>0 .And. !Empty(SF1->F1_CC),SF2->(ColumnPos('F2_CC '))>0 .And. !Empty(SF2->F2_CC))
	IF a__CfgNf[4] =="SF1"   .AND.  !MVerifCC(a__CfgNf[4],SF1->F1_ESPECIE,SF1->F1_SERIE,SF1->F1_DOC,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_CC)
		Return .F.
	ElseIF a__CfgNf[4] =="SF2"  .and.  !MVerifCC(a__CfgNf[4],SF2->F2_ESPECIE,SF2->F2_SERIE,SF2->F2_DOC,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_CC)
		Return .F.
	EndIf
EndIf
//Limpa Filtro criado pela função FilBrowse
SF1->(dbClearFilter())
If nOpca <> 3
	If	!(&(aCfgNF[SAliasHead] +'->'+ cP3+"TIPODOC") $ aCfgNF[ScFilRot])
		If nOpca == 5
			Help(" ",1,"LOCXNF0001",,&(aCfgNF[SAliasHead]+'->'+cP3+"ESPECIE")+"--->"+aEspecies[Ascan(aEspecies,{|x| aCfgNF[SAliasHead]+&(aCfgNF[SAliasHead]+'->'+cP3+"TIPO")$x[1]})][2],3,1)
		Else
			Help(" ",1,"LOCXNF0002",,&(aCfgNF[SAliasHead]+'->'+cP3+"ESPECIE")+"--->"+aEspecies[Ascan(aEspecies,{|x| aCfgNF[SAliasHead]+&(aCfgNF[SAliasHead]+'->'+cP3+"TIPO")$x[1]})][2],3,1)
		Endif
		Return .F.
	Endif
	lFacImport:= (aCfgNf[SAliasHead]=="SF1") .AND. AllTrim(SF1->F1_TIPO_NF) $ "123456789AB"
	If lIntegracao .AND. !lFacImport .AND. l103Class
		Aviso(STR0018,OemToAnsi(STR0158),{STR0021})
		Return .F.
	EndIf
	If lIntegracao .AND. (aCfgNF[SnTipo]==10 .OR. aCfgNF[SnTipo]==13 .OR. aCfgNF[SnTipo]==60) .AND. lFacImport
		SD1->(MsSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
		If Empty(SD1->D1_TES)
			If nOpca == 5			//Nao permitir desclassificar notas de import. ainda nao classificadas.
				Aviso(STR0201,STR0149+" "+Alltrim(SF1->F1_DOC)+" "+STR0150,{STR0021})
				Return .F.
			ElseIf nOpca == 4 .AND. SD1->D1_EMISSAO>dDataBase
				Help("",1,"A100DATAM")
				Return .F.
			Endif
		Else
			If nOpca == 4 //Nao permitir classificar notas de import. ja classificadas.
				Help("",1,"NFCLAS")
				Return .F.
			ElseIf nOpca == 5
				If GetNewPar("MV_CUSTIMP","1") <> "1" .And. SF1->F1_TIPO_NF $ "58"  //Para ambientes com atualizacao de custos / estoque atraves de remito,
					aAreaSF1 := SF1->(GetArea())	//nao permitir desclassificar nota FOB(ou CIF) se existirem notas de outros tipos
					DbSetOrder(5)
					cHawb := SF1->F1_HAWB
					SF1->(dbSeek(cFilSF1+cHawb+"6",.T.))
					lOutrasNF:=.F.
					While !Eof() .AND. SF1->F1_FILIAL == cFilSF1 .AND. ;
						SF1->F1_HAWB == cHawb .AND. !lOutrasNF
						If SF1->F1_TIPO_NF $ "679A"
							lOutrasNF := .T.
						EndIf
						DbSkip()
					End
					RestArea(aAreaSF1)
					If lOutrasNF
						Aviso(STR0018,STR0192,{STR0021})
						Return .F.
					EndIf
				Endif
			Endif
		Endif
		//Se Processo de Importação ja estiver encerrado não permitir movtos.
		DbSelectArea("SW6")
		DbSetOrder(1)
		If nOpca <> 2
			If MsSeek(xFilial("SW6")+SF1->F1_HAWB)
				If !Empty(SW6->W6_DT_ENCE)
					Aviso(STR0018,STR0192,{STR0021})	// "Proceso encerrado!"
					Return .F.
				EndIf
			EndIf
		Endif
	EndIf
    If cPaisLoc == "GUA" .AND. lDeleta .AND. aCfgNf[ScCliFor] == "SA1"
       If !lAnulaSF3
          Aviso(STR0097,STR0226+chr(13)+STR0227,{STR0235})
          Return .F.
       Else
          If aCfgNF[SAliasHead] == "SF2"
             SD2->(DbSetOrder(3))
		     SD2->(MsSeek(xFilial("SD2")+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA))
		     lRetOrigem  := SD2->D2_ORIGLAN != "LO"
          EndIf
          If !lRetOrigem
             Aviso(STR0097,STR0231,{STR0235})
             Return .F.
          EndIf
       EndIf
    EndIf
    // O tratamento abaixo esta desconsiderado momentaneamente para Portugal Por conceito uma fatura não podera ser excluida
    //#PORTUGAL#
	/*If cPaisLoc == "PTG" .And. lHashPTG .And. !(STR(aCfgNF[SnTipo],2)$"10|13|50|65|55|61") .And. !lVisualiza
         cPe    :=  LocxPE(50)
         If !Empty(cPE)
            lHashPTG := ExecBlock(cPE,.F.,.F.)
         Endif
         If lHashPTG
            If aCfgNf[SAliasHead] == "SF2"
                cDOC := SF2->F2_DOC
                cSER := SF2->F2_SERIE
            ElseIf aCfgNf[SAliasHead] == "SF1"
                cDOC := SF1->F1_DOC
                cSER := SF1->F1_SERIE
            EndIf

         EndIf
    EndIf*/
Else
	If !FisChkDt(dDatabase)
		Return
	Endif
EndIf
If cpaisLoc=="ARG" .and.  !aCfgNf[SlRemito] .AND. aCfgNF[SlFormProp] .And. lDeleta
	If  aCfgNf[SAliasHead]=="SF1" .AND. SF1->(FieldPos('F1_EMCAEE'))   >0 .AND. SF1->(FieldPos('F1_CAEE')) >0 .and.;
		(!Empty(SF1->F1_EMCAEE) .Or. !Empty(SF1->F1_CAEE))
		Aviso(STR0018,STR0361,{"OK"}) //"ATENCAO"##"Documento já transmitido. Exclusão nao permitida"
		Return .F.
	ElseIf  aCfgNf[SAliasHead]=="SF2" .AND. SF2->(FieldPos('F2_EMCAEE'))   >0 .AND. SF2->(FieldPos('F2_CAEE')) >0 .and.;
		(!Empty(SF2->F2_EMCAEE) .Or. !Empty(SF2->F2_CAEE))
		Aviso(STR0018,STR0361,{"OK"}) //"ATENCAO"##"Documento já transmitido. Exclusão nao permitida"
		Return .F.
	EndIf
EndIf
If cPaisLoc <> "BRA" .AND. lLibImp .AND. lFacImport .AND. l103Class
	If SF1->F1_TIPO_NF == "5"
		lBloqImp	:=	.T.
	Endif
Endif
Private aBKPCfgNF		:=	AClone(a__CfgNf)
If Type("aPE") <> "A"
	Private aPE	    := Array(SnMaxPE,2)
Endif
If Type("nMoedaNf")!= "N"
	nMoedaNf := 1
EndIf
aCfgNf 		:= AClone(a__CfgNf)
If Type("bFunAuto")!="B"
	bFunAuto := {|| NIL }
EndIf
For nX	:=	1 To MoedFin()
	If (!Empty(GetMV("MV_MOEDA"+Alltrim(STR(nX)))))
		AAdd(aMoedas,Alltrim(STR(nX))+"="+GetMV("MV_MOEDA"+Alltrim(STR(nX))))
	Else
		Exit
	Endif
Next
cPe	:=	LocxPE(1)
If !Empty(cPE)
	If ValType(aUsButtons := ExecBlock(cPe, .F., .F.) ) == "A"
		AEval( aUsButtons, { |x| AAdd( aCfgNf[SaBotoes], x ) } )
	EndIf
EndIf
cPe	:=	LocxPE(2)
If !Empty(cPe)
	xRet  := Execblock(cPE,.F.,.F.,nOpca)
	If ValType(xRet) == "L"
	   If !xRet
	      Return .F.
	   EndIf
	EndIf
EndIf
cPe	:=	LocxPE(3)
If !Empty(cPE)
	__cExpF4 := ExecBlock(cPE,.F.,.F.)
EndIf
bDoRefresh  := {|| NIL }
bRefresh    := {|| Iif(Type("bDoRefresh") <> "B",{|| Nil},Eval(bDoRefresh))}
bListRefresh:= {|| (MaFisToCols(aHeader,aCols,,"MT100")),Iif(!lLocxAuto,(oLstSF3:Refresh(),oLstImp:Refresh()),Nil)}
bGDRefresh  := {|| NIL}
cTipo := aCfgNF[ScTipoDoc]
If Type("lGerarCFD") != "L"
	lGerarCFD := .F.
	aGerarCFD := {}
	If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
		aGerarCFD := CFDVerific()
		If aGerarCFD[1] <> "0"
			If Empty(aGerarCFD[2])
				lGerarCFD := .T.
			Else
	    		If !Empty(aGerarCFD[2]) .AND. !lLocxAuto
					cMsgCFD := ""
					For nX := 1 To Len(aGerarCFD[2])
						cMsgCFD += aGerarCFD[2][nX][2] + CRLF
					Next
					MsgAlert(cMsgCFD,STR0248)
				Endif
			Endif
		Else
			lGerarCFD := .F.
		Endif
	Endif
Endif
//Utilizacao do numero correlativo de compras
lUsaCor:=.F.
lUsaCor:=CORR_USO()
lUsaCor:=lUsaCor .AND. Strzero(aCfgNF[SnTipo],2)$"07|09|10|12|13|14|22|23"  //ncp|ndp|nf|benef|import|frete|Nota Ajuste NCP|Nota Ajuste NDP
cSerSXBa  := IIf(aCfgNf[ScEspecie]$"NCC|NCI","CHB",IIf(aCfgNf[ScEspecie]$"NDC|NDI","CHD",Iif(Substr(aCfgNf[ScEspecie],1,2)=="RF","CHE","01")))
cSerSXB   := IIf(lSeqEspecie,IIf(AllTrim(aCfgNf[ScEspecie])=="NF","CHA",cSerSXBa),"01")
DbSelectArea("SX3")
DbSetOrder(2)
If  (cPaisLoc == "ARG") .And. aCfgNf[SlFormProp] .And. ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA462N|MATA462DN|MATA462R|MATA462TN|MATA102DN|OMSA320") .And. lFolios // Leandro Prado - 21/02/2014 - Controle de Ponto de Venda.
	If ExistBlock("DESAPV")
		cLocxNFPV :=Execblock("DESAPV",.F.,.F.,)
		cIdPVArg := POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
	EndIf
EndIf
Do Case
	Case aCfgNf[SAliasHead]=="SF1"
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. !aCfgNF[SlFormProp] .AND. SX3->(MsSeek('F1_CODBAR'))
			cVld := LocX3Valid("F1_CODBAR")
			cVld+= IIf(!Empty(cVld),".AND.","") + "LocxchkCB(M->F1_CODBAR,.T.,M->F1_ESPECIE)"
			AAdd(aCposNF,{,"F1_CODBAR",,,,cVld,,,,,,,,,,,"!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")"})
			lCodBar:=.T.
		Else
			lCodBar:=.F.
		Endif
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. ;
           IIf(Type("lFiscal")#"U",lFiscal,.F.)
			SX3->(MsSeek("F1_ECF"))
			cVld := "LocXVal('F1_ECF')"
			cVld += Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. ","")+SX3->X3_VLDUSER,"")
			AAdd(aCposNF,{X3Titulo(),"F1_ECF",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,"lCFiscal := Iif(M->F1_ECF<>'1',.F.,.T.)",SX3->X3_F3})
		EndIF
		If aCfgNf[ScCliFor]=="SA1"
			SX3->(MsSeek("F2_CLIENTE"))
			cWhen	:=	Iif(lCodBar,"Empty(M->F1_CODBAR)"+IIf(Empty(SX3->X3_WHEN),"",".AND."+SX3->X3_WHEN),"")
			cVld:=LocX3Valid("F2_CLIENTE")
			cVld+=IIf(!Empty(cVld)," .AND. ","") + "Posicione('" + aCfgNF[ScCliFor] + "',1,xFilial('" + aCfgNF[ScCliFor] + "')+M->F1_FORNECE,'" + cP1 + "COD') == M->F1_FORNECE"
			cVld+=IIf(!Empty(cVld)," .AND. ","") + "SetVar('F1_FORNECE')"+" .AND. LxA103VFold('NF_CODCLIFOR',M->F1_FORNECE)"
			bVld	:=	{}
			If cPaisLoc != "RUS"
				cWhen	:=	IIf(Empty(SX3->X3_WHEN),cWhen,SX3->X3_WHEN+".AND."+cWhen)
			Else
				cX3When	:= AllTrim(GetSX3Cache("F1_FORNECE", "X3_WHEN"))
				cX3F3	:= AllTrim(GetSX3Cache("F2_CNTID", "X3_F3"))
				cWhen	:= IIf(Empty(cX3When),cWhen,Iif(!EMPTY(cWhen),cX3When+".AND."+cWhen,cX3When))
				SX3->(MsSeek("F2_CLIENTE"))
			EndIf
			AAdd(aCposNF,{X3Titulo(),"F1_FORNECE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,cWhen})
		Else
			SX3->(MsSeek("F1_FORNECE"))
			//Inclui os campos que sao exclusivos do remito de transf..
			If aCfgNf[SlRemito] .AND. lInclui .AND. aCfgNf[SnTipo] == 64
				AAdd(aCposNF,{STR0177,'F1_FILORIG',"@!",LEN(SM0->M0_CODFIL),,"NfTrfOri(M->F1_FILORIG)",,'C',,,,,,,,'SM0'})
  	      	cWhen := ".F."
			Else
				cWhen	:=	Iif(lCodBar,"Empty(M->F1_CODBAR)"+IIf(Empty(SX3->X3_WHEN),"",".AND."+SX3->X3_WHEN),"")
 	        EndIf
			cVld:=LocX3Valid("F1_FORNECE")
			cVld+=IIf(!Empty(cVld)," .AND. ","") + "Posicione('" + aCfgNF[ScCliFor] + "',1,xFilial('" + aCfgNF[ScCliFor] + "')+&(__ReadVar),'" + cP1 + "COD') == &(__ReadVar)"
			cVld+=IIf(!Empty(cVld)," .AND. ","") + "SetVar('F1_FORNECE')"+" .AND. LxA103VFold('NF_CODCLIFOR',M->F1_FORNECE)"
			cVld+=IIf(!Empty(cVld)," .And. ","") + " AtuCliFor()"
			If cPaisLoc  $ "MEX|PER" .AND. lLxWhen
				cWhen	:=	"LxWhenAdt()"+IIf(Empty(cWhen),"",".AND.")+cWhen
			ElseIf cPaisLoc == "RUS"
				cWhen	:=	IIf(Empty(SX3->X3_WHEN),cWhen,Iif(!EMPTY(cWhen),SX3->X3_WHEN+".AND."+cWhen,SX3->X3_WHEN))
				cX3F3	:= AllTrim(GetSX3Cache("F1_CNTID", "X3_F3"))
				SX3->(MsSeek("F1_FORNECE"))
			EndIf
			AAdd(aCposNF,{,"F1_FORNECE",,,,cVld,,,,,,,,,,,"!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")" + Iif(!Empty(cWhen),".AND.","") + cWhen})
		Endif
		cVld := LocX3Valid("F1_LOJA")
		cVld+=IIf(!Empty(cVld)," .AND. ","") + "ExistCpo('"+ aCfgNf[ScCliFor]+"',M->F1_FORNECE+M->F1_LOJA)"
		cVld += IIf(!Empty(cVld)," .AND. ","") + "SetVar('F1_LOJA')"+" .AND. LxA103VFold('NF_LOJA',M->F1_LOJA)"
		If aCfgNf[ScCliFor]=="SA1"
			cVld += IIf(!Empty(cVld)," .AND. ","") + "LocXVal('F1_LOJA')"+".AND. AtuCliFor()"
	    Else
			cVld += IIf(!Empty(cVld)," .AND. ","") + "LocXVal('F1_LOJA')"+".AND. VldForLoja('SA2') " + ".AND. AtuCliFor()"
	    EndIf
		cWhen	:=	Iif(lCodBar,"Empty(M->F1_CODBAR)"+IIf(Empty(SX3->X3_WHEN),"",".AND."+SX3->X3_WHEN),"")
		If cPaisLoc  $ "MEX|PER" .AND. lLxWhen
			cWhen	:=	"LxWhenAdt()"+IIf(Empty(cWhen),"",".AND.")+cWhen
		ElseIf cPaisLoc == "RUS"
			SX3->(MsSeek("F1_LOJA"))
			cWhen	:= IIf(Empty(SX3->X3_WHEN),cWhen,Iif(!EMPTY(cWhen),SX3->X3_WHEN+".AND."+cWhen,SX3->X3_WHEN))
		EndIf
		AAdd(aCposNF,{,"F1_LOJA",,,,cVld,,,,,,,,,,,"!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")" + Iif(!Empty(cWhen),".AND.","") + cWhen})
		SX3->(MsSeek(cP1+"NOME"))
		AAdd(aCposNF,{X3Titulo(),"cNome",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, SX3->X3_ARQUIVO, SX3->X3_CONTEXT,"Posicione('"+ aCfgNf[ScCliFor]+"',1,xFilial('"+ aCfgNf[ScCliFor]+"')+M->F1_FORNECE+M->F1_LOJA,cP1+ 'NOME')",,,,,,".F."})
		SX3->(MsSeek(cP1+"NUMTIM"))
		AAdd(aCposNF,{,"F1_NUMTIM"})
		cVld:=LocX3Valid("F1_SERIE")
		If lCodBar
			cVld+=IIf(!Empty(cVld)," .AND. ","") +"LocxSERIE('SF1',M->F1_CODBAR,M->F1_SERIE)"
		Endif
		cVld+=IIf(!Empty(cVld)," .AND. ","") +"AtuNumIt()"
		cVld+=IIf(!Empty(cVld)," .AND. ","") +"LocXVal('F1_SERIE')"
		cVld+=IIf(!Empty(cVld)," .AND. ","") +  "LocxValNum()"
        //³Para Portugal nao deve permitir incluir uma NF quando para a serie informada existir documento ³
        //³gerado com data igual ou superior a data de emissao(database) da nova NF.                      ³
        //#PORTUGAL#
		/*If (cPaisLoc == "PTG" .and. lHashPTG) .and. aCfgNf[SlFormProp]
            cVld+=IIf(!Empty(cVld)," .AND. ","") +  "Iif(!Empty(&(ReadVar())),VldCtrForm(AllTrim(&(ReadVar())),M->F1_ESPECIE,@M->F1_DOC,1),.T.)"
        EndIf*/
		If cPaisLoc=="VEN" .And.  SF1->(ColumnPos("F1_FORMLIB")) > 0 .And. aCfgNf[SlFormProp]
		 	cVld+=IIf(!Empty(cVld)," .AND. "," ") +"FormLibre()"
		EndIf
		//³Para o Peru pode-se utilizar o campo especifico para serie com 4 digitos caso nao utilizem formulario proprio.  ³
        If (cPaisLoc $ "PER|COL|" .And. lSerOri) .OR. (cPaisLoc == "PAR")
			AAdd(aCposNF,{,"F1_SERIE2"})
		Endif
        If cPaisLoc $ "PER|" .And. lSerOri
			AAdd(aCposNF,{,"F1_SERORI",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],cSerSXB,),".F."})
		EndIf
        If cPaisLoc == "ARG"
			If aCfgNf[SlFormProp] .AND. !aCfgNf[SlRemito] .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
				cWhen := "M->F1_ECF <> '1'"
			Else
				cWhen := "!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")"+ " .AND. Iif(lFuncAtual,Iif(lAltSerie,.T.,Iif(!Empty(M->F1_SERIE),.F.,.T.)),.T.)"
			EndIf
			// Leandro Prado - 19/02/2014 -Para argentina foi implementado o controle de ponto de venda.
	         If ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA101N|MATA462N|MATA462DN|MATA462TN|FINA074|FINA084|MATA462R|FINA846|FINA935|OMSA320") .Or. lfina998
				If aCfgNf[SlFormProp]
					AAdd(aCposNF,{,"F1_PV",,,,,,,,,"'"+cLocxNFPV+"'",,,,,,".F."})
					cVld+= IIf(!Empty(cVld)," .AND. ","") +  "LNF2VldSer()" //Add o valid para ver se a série é valida para o PV.
				EndIf
				cVld+= IIf(!Empty(cVld)," .AND. ","") +  "GrvRG1415()" //Add o valid para preencher o F1_RG1415
				AAdd(aCposNF,{,"F1_SERIE",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],"X501PV",),cWhen})
			Else
				AAdd(aCposNF,{,"F1_SERIE",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],"01",),cWhen})
			EndIf
       ElseIf cPaisLoc == "MEX" .And. lFuncAtual
			cWhen := "!(l103Visual .Or. l103Class .Or. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")"+ " .And. Iif(lAltSerie,.T.,Iif(!Empty(M->F1_SERIE),.F.,.T.))"
			AAdd(aCposNF,{,"F1_SERIE",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],cSerSXB,),cWhen})
		Else
			AAdd(aCposNF,{,"F1_SERIE",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],cSerSXB,),Iif((cPaisLoc == "PER") .and. lSerie2,".F.","!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")")})
		EndIf
		cVld:=LocX3Valid("F1_DOC")
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. !aCfgNF[SlFormProp]   // Trazer o ultimo numero de CAI e vencto - somente para bases TOP e dif. de AS400
				cVld+=IIf(!Empty(cVld)," .AND. ","") + "AutNumCai(M->F1_ESPECIE)"
		EndIf
		cVld+=IIf(!Empty(cVld)," .AND. ","") + "AtuNumIt()"
		If ( Type("lLocxAuto") == "U" .OR. !lLocxAuto )
			cVld+=IIf(!Empty(cVld)," .AND. ","") + "EnablePanel()"
		Endif
		cVld+=IIf(!Empty(cVld)," .AND. ","") +  "LocXVal('F1_DOC')"
	    cVld+=IIf(!Empty(cVld)," .AND. ","") +  "LocxValNum()"
	    If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
	    	cWhen := If(lInclui.AND.aCfgNf[SlFormProp],"Substr(cAcesso,50,1)=='S' .AND. M->F1_ECF <> '1'","!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")")+" .AND. "+ IIf(aCfgNF[SnTipo]== 60 .OR. aCfgNF[SnTipo]== 62,IIf(lChange,".T.",".F."),".T.")
	    Else
 			cWhen := If(lInclui.AND.aCfgNf[SlFormProp],"Substr(cAcesso,50,1)=='S'","!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")")+" .AND. "+ IIf(aCfgNF[SnTipo]== 60 .OR. aCfgNF[SnTipo]== 62,IIf(lChange,".T.",".F."),".T.")
	    EndIf
	    If cPaisLoc == "ARG"
	    	cVld    +=  Iif(!Empty(cVld)," .AND. ","") +  "GrvRG1415()"
	    EndIf
		AAdd(aCposNF,{,"F1_DOC",,,,cVld,,,,,,,,,,,cWhen})
		If cPaisLoc == "ARG"
			If ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA101N|MATA462N|MATA462DN|MATA462TN|FINA074|FINA084|MATA462R|FINA846|FINA935|FINA096")  .Or. lfina998
				AAdd(aCposNF,{,"F1_RG1415",,,,,,,,,,,,,,,".T."})
				If SF1->(ColumnPos("F1_CC")) > 0
					AAdd(aCposNF,{,"F1_CC"    ,,,,Iif(cFunName $"MATA101N",".T.","VldCC(M->F1_FORNECE,M->F1_LOJA,M->F1_CC,M->F1_RG1415)"),,,,,,,,,,Iif(cFunName $"MATA101N","","FVS"),Iif(aCfgNf[SlFormProp],".F.",".T.")})
				Endif
			Endif
		Endif
		//³ Grava o campo F1_HAWB com o numero do Processo de import. para o Compras Internacional para rotina automatica na LocxGen.           ³
		If lLocxAuto .And. SuperGetMv("MV_COMPINT") == .T. .And. SuperGetMv("MV_EASY") == "N"
			AAdd(aCposNF,{,"F1_HAWB",,,,,,,,,,,,,,,"!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")" })
        EndIf
		//campos referentes ao certificado e numero de aprovacao - comprovantes fiscais digitais
		If lGerarCFD
			AAdd(aCposNF,{,"F1_APROFOL",,,,,,,,,,,,,,,".F."})
			AAdd(aCposNF,{,"F1_CERTFOL",,,,,,,,,,,,,,,".F."})
		Endif
		If aCfgNf[SlFormProp]
			If lContrFol .And. cPaisLoc <> "ARG"
				AAdd(aCposNF,{,"F1_NUMAUT",,,,,,,,,,,,,,,".F."}) //Numero de Autorizacao
				AAdd(aCposNF,{,"F1_CODCTR",,,,,,,,,,,,,,,".F."}) //Codigo de Controle
			Endif
			If lPassag
				AAdd(aCposNF,{,"F1_COMPANH",,,,,,,,,,,,,,,".F."}) //Codigo da companhia aerea
				AAdd(aCposNF,{,"F1_LOJCOMP",,,,,,,,,,,,,,,".F."}) //Loja da companhia aerea
				AAdd(aCposNF,{,"F1_PASSAGE",,,,,,,,,,,,,,,".F."}) //Numero da passagem
				AAdd(aCposNF,{,"F1_DTPASSA",,,,,,,,,,,,,,,".F."}) //Data da passagem
			Endif
			If lTipComp
				AAdd(aCposNF,{,"F1_TIPCOMP",,,,,,,,,,,,,,,".T."}) //Tipo da companhia
			Endif
		Else
			If lContrFol .And. cPaisLoc <> "ARG"
				AAdd(aCposNF,{,"F1_NUMAUT"})
				AAdd(aCposNF,{,"F1_CODCTR"})
			Endif
			If lPassag
				AAdd(aCposNF,{,"F1_COMPANH"})
				AAdd(aCposNF,{,"F1_LOJCOMP"})
				AAdd(aCposNF,{,"F1_PASSAGE"})
				AAdd(aCposNF,{,"F1_DTPASSA"})
			Endif
			If lTipComp
				AAdd(aCposNF,{,"F1_TIPCOMP"})
			Endif
		Endif
		// Forma Libre - Venezuela
		If cPaisLoc=="VEN" .And. SF1->(ColumnPos("F1_FORMLIB")) > 0
			If aCfgNf[SlFormProp]
				AAdd(aCposNF,{,"F1_FORMLIB",,,,cVld,,,,,,,,,,,".F."})
			Else
				AAdd(aCposNF,{,"F1_FORMLIB",,,,cVld,,,,,,,,,,,".T."})
			EndIf
		EndIf
		cVld:=LocX3Valid("F1_NATUREZ")
		cVld+=IIf(!Empty(cVld)," .AND. "," ") +"LocXVal('F1_NATUREZ')"
		If cPaisLoc $ "VEN|URU|DOM"
			cVld += IIf(!Empty(cVld)," .AND. "," ") + "LxA103VFold('NF_NATUREZA',M->F1_NATUREZ)"
		EndIf
		If cPaisLoc == "MEX"
			if !( StrZero(aCfgNf[SnTipo],2)  $ "|20|" )
				AAdd(aCposNF,{,"F1_NATUREZ",,,,cVld,,,,,,,,,,"SED","!(l103Visual .OR. l103Class)"})
			endif
		Else
			AAdd(aCposNF,{,"F1_NATUREZ",,,,cVld,,,,,,,,,,"SED","!(l103Visual .OR. l103Class)"})
		EndIf
		//Estados Unidos
		If cPaisLoc == 'EUA' .and. Trim(aCfgNf[ScEspecie]) $ "NCC|NF"
			IF SF1->(ColumnPos( "F1_CODMUN" )) > 0
				SX3->(MsSeek("F1_CODMUN"))
				cVld := LocX3Valid("F1_CODMUN")
				AAdd(aCposNF,{X3Titulo(),"F1_CODMUN",	SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			EndIF
			If SF1->(ColumnPos( "F1_EST" )) > 0
				SX3->(MsSeek("F1_EST"))
				cVld := LocX3Valid("F1_EST")
				AAdd(aCposNF,{X3Titulo(),"F1_EST",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,".F."})
			EndIf
			If SF1->(ColumnPos( "F1_PROVENT" )) > 0
				SX3->(MsSeek("F1_PROVENT"))
				cVld := LocX3Valid("F1_PROVENT")
				AAdd(aCposNF,{X3Titulo(),"F1_PROVENT",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			EndIf
			If SF1->(ColumnPos( "F1_ZONGEO" )) > 0
				SX3->(MsSeek("F1_ZONGEO"))
				cVld := LocX3Valid("F1_ZONGEO")
				AAdd(aCposNF,{X3Titulo(),"F1_ZONGEO",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,".F."})
			EndIf
			If Trim(aCfgNf[ScEspecie]) $ "NCC"
				If SF1->(ColumnPos( "F1_TPACTIV" ) ) > 0
					SX3->(MsSeek("F1_TPACTIV"))
					cVld := LocX3Valid("F1_TPACTIV")
					AAdd(aCposNF,{X3Titulo(),"F1_TPACTIV",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,})
				EndIf
			EndIf
		EndIf
		AAdd(aCposNF,{,"F1_ESPECIE",,,,,,,,,IIF(lInclui,"aCfgNf[" + AllTrim(Str(ScEspecie)) + "]",),,,,,,".F."})
		cVld:= "(SetVar('F1_EMISSAO')"+" .AND. !aCfgNf["+AllTrim(Str(SlFormProp)+ "] "+ Iif(cPaisLoc=="RUS" .And. aCfgNf[ScEspecie] $ 'NCC/NDP', ".Or. .T.)"," .OR. M->F1_EMISSAO == dDataBase)"))
		cVld+=" .And. "+"LocXVal('F1_EMISSAO')" + If(cPaisLoc == "ARG"," .and. LocEmisPro() ","")
		If cPaisLoc == "RUS" .And. aCfgNf[SnTipo] >= 2 .And. aCfgNf[SnTipo] <= 5
			AAdd(aCposNF,{,"F1_EMISSAO",,,,cVld,,,,,,,,,,,"!(l103Visual .OR. l103Class ) "})
		Else
			AAdd(aCposNF,{,"F1_EMISSAO",,,,cVld,,,,,,,,,,,"!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+") .AND. "+ IIf(aCfgNf[SlFormProp]== .T.,'.F.','.T.')})
		EndIf
		If ! aCfgNf[SlFormProp]
			AAdd(aCposNF,{,"F1_DTDIGIT",,,,,,,,,,,,,,"",".F."})
		EndIf
		cWhen	:=	SX3->X3_WHEN
		If cPaisLoc  $ "MEX|PER" .AND. lLxWhen
			cWhen := " LxWhenAdt()"+IIf(Empty(cWhen),cWhen,".AND."+cWhen)
		EndIf
		If cPaisLoc == 'RUS'
			SX3->(MsSeek("F1_MOEDA"))
			cWhen	:=	SX3->X3_WHEN
	        AAdd(aCposNF,{X3Titulo(),"F1_MOEDA",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,,SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,"LocXVal('F1_MOEDA')",SX3->X3_F3,IIf(Empty(cWhen),"",Alltrim(cWhen) + " .And. ") + "!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")"})
			SX3->(MsSeek("F1_CONUNI"))
			AAdd(aCposNF,{,"F1_CONUNI",,SX3->X3_TAMANHO,,,,,,,,,,,"Pertence('12')",,SX3->X3_WHEN ,,,.T.,{STR0135,STR0136},    ,{|| M->F1_CONUNI := '2' } } ) //'1=Sim'###'2=Nao'
		    SX3->(MsSeek("CTO_SIMB"))
	  	    AAdd(aCposNF,{,"CTO_SIMB",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,"Posicione('CTO', 1, xFilial('CTO')+StrZero(SF1->F1_MOEDA, TamSX3('CTO_MOEDA')[1]),'CTO_SIMB')",SX3->X3_USADO,SX3->X3_TIPO, SX3->X3_ARQUIVO, SX3->X3_CONTEXT,"Posicione('CTO', 1, xFilial('CTO')+StrZero(M->F1_MOEDA, TamSX3('CTO_MOEDA')[1]),'CTO_SIMB')",,,,,,".F."})
	    	cVld:=LocX3Valid("F1_TXMOEDA")
	    	cVld+=IIf(!Empty(cVld)," .AND. "," ") + "LocXVal('F1_TXMOEDA')"
	        cWhen	:=	SX3->X3_WHEN
            AAdd(aCposNF,{,"F1_TXMOEDA",,,,cVld,,,,,,,,,,,"!(l103Visual .OR. l103Class)"+ Iif(!Empty(cWhen),".AND.","") + cWhen})
            AAdd(aCposNF,{,"F1_CNORSUP",,,,,,,,,,,,,"Pertence('12')",,,,,.T.,{STR0399,STR0398},    ,{|| M->F1_CNORSUP := '1' } } ) //'1=Vendor'###'2=Other'
            AAdd(aCposNF,{,"F1_CNEEBUY",,,,,,,,,,,,,"Pertence('12')",,,,,.T.,{STR0397,STR0398},    ,{|| M->F1_CNEEBUY := '1' } } ) //'1=Byuer'###'2=Other'
            SX3->(MsSeek("F1_CNORCOD"))
			cVld	:=	LocX3Valid("F1_CNORCOD")
			cWhen	:=	SX3->X3_WHEN
            AAdd(aCposNF,{,"F1_CNORCOD",,,,cVld,,,,,,,,,,SX3->X3_F3,cWhen})
			SX3->(MsSeek("F1_CNEECOD"))
			cVld	:=	LocX3Valid("F1_CNEECOD")
			cWhen	:=	SX3->X3_WHEN
            AAdd(aCposNF,{,"F1_CNEECOD",,,,cVld,,,,,,,,,,SX3->X3_F3,cWhen})
			SX3->(MsSeek("F1_CNORBR"))
            cVld	:=	LocX3Valid("F1_CNORBR")
			cWhen	:=	SX3->X3_WHEN
         	AAdd(aCposNF,{,"F1_CNORBR",,SX3->X3_TAMANHO,,cVld,,,,,,,,,,,cWhen})//when cant be false, execauto at UCLD cant fill the field
			SX3->(MsSeek("F1_CNEEBR"))
            cVld	:=	LocX3Valid("F1_CNEEBR")
			cWhen	:=	SX3->X3_WHEN
         	AAdd(aCposNF,{,"F1_CNEEBR",,SX3->X3_TAMANHO,,cVld,,,,,,,,,,,cWhen})//when cant be false, execauto at UCLD cant fill the field
			SX3->(MsSeek("F1_CNTID"))
	        AAdd(aCposNF,{X3Titulo(),"F1_CNTID",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,"LocXVal('F1_CNTID')",SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,"RUXXTS05()"})
			SX3->(MsSeek("F1_F5QUID"))
	        AAdd(aCposNF,{X3Titulo(),"F1_F5QUID",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,,,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,"RUXXTS05()"})
			SX3->(MsSeek("F1_F5QDESC"))
	        AAdd(aCposNF,{X3Titulo(),"F1_F5QDESC",SX3->X3_PICTURE,60,SX3->X3_DECIMAL,,SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,"RUXXTS05()"})
		Else
			AAdd(aCposNF,{,"F1_MOEDA"  ,,,,"LocXVal('F1_MOEDA')",,,,,,,,,IIf(cPaisLoc=="MEX","","LocXVal('F1_MOEDA')"),,"!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")"+ Iif(!Empty(cWhen),".AND.","") + cWhen,,,.T.,aMoedas,{|x| x:nAt}})
			cVld:=LocX3Valid("F1_TXMOEDA")
			cVld+=IIf(!Empty(cVld)," .AND. "," ") + "LocXVal('F1_TXMOEDA')"
			cWhen	:=	SX3->X3_WHEN
			If cPaisLoc  $ "MEX|PER" .AND. lLxWhen
				cWhen := " LxWhenAdt()"+IIf(Empty(cWhen),cWhen,".AND."+cWhen)
			EndIf
			AAdd(aCposNF,{,"F1_TXMOEDA",,,,cVld,,,,,,,,,,,"!(l103Visual .OR. l103Class)"+ Iif(!Empty(cWhen),".AND.","") + cWhen})
		EndIf
		//Inclui os campo define se a devolucao devera gerar pedido de venda
		If aCfgNf[ScTipoDoc] == "D" .AND. aCfgNf[SnTipo] <> 63
			If !ExistBlock("MT46205")
				AAdd(aCposNF,{,"F1_GERAPED"  ,,,,,,,,,,,,,"Pertence('12')",,"(!l103Class)",,,.T.,{STR0135,STR0136},,{|| M->F1_GERAPED := '2' } } ) //'1=Sim'###'2=Nao'
			Endif
		Endif
		//Inclui os campos que sao exclusivos do remito.
		If aCfgNf[SlRemito]
			If aCfgNf[ScTipoDoc] == "D"
				nAprovar	:=	GETMV("MV_APRVDEV",.F.,1)
				AAdd(aCposNF,{STR0137,"F1_APRVDEV",,1,,"Pertence('12')",,"C",,,,,,,,,If(nAprovar == 2,'.T.','.F.'),,,.T.,{STR0135,STR0136},,{|| M->F1_APRVDEV := If(nAprovar==3,'1','2')} } ) //'Aprov. Dev. ?'###'1=Sim'###'2=Nao'
			Endif
		Endif
		//Inclui o vendedor para as devolucoes/complementos de venda.
		If aCfgNf[SnTipo]>1 .AND. aCfgNf[SnTipo]<6 .AND.;
		   cPaisLoc $ cAuxPaisL .AND. !aCfgNf[SlRemito]
			SX3->(MsSeek("F1_VEND1"))
			AAdd(aCposNF,{X3Titulo(),"F1_VEND1",,,,LocX3Valid("F1_VEND1"),,,,,,,,,,"SA3","!(l103Visual .OR. l103Class)"})
		Endif
		If lUsaCor  //numero correlativo
		    If cPaisLoc == "CHI"
		    	AAdd(aCposNF,{,"F1_NUMCOR",,,,"CORR_VERIF(M->F1_DTDIGIT,M->F1_NUMCOR,.T.,M->F1_RECHON)",,,,,})
		    Else
				AAdd(aCposNF,{,"F1_NUMCOR",,,,"CORR_VERIF(M->F1_DTDIGIT,M->F1_NUMCOR,.T.)",,,,,})
		    EndIf
		EndIf
		//Exibe o campo para que seja informado o valor da retencao de SUSS...
		If cPaisLoc == "ARG" .AND. SubStr(cAgente,6,1) == "S" .AND. aCfgNF[SnTipo] == 10
			cVld :=	LocX3Valid("F1_VALSUSS")
			AAdd(aCposNF,{X3Titulo(),"F1_VALSUSS",SX3->X3_PICTURE,SX3->X3_TAMANHO,	SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		EndIf
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. !aCfgNF[SlFormProp]
   			SX3->(MsSeek("F1_VENCAI"))
			cWhen:=	Iif(lCodBar,"Empty(M->F1_CODBAR)"+IIf(Empty(SX3->X3_WHEN),"",".AND."+SX3->X3_WHEN),"")
			cVld :=	LocX3Valid("F1_VENCAI")
			cVld+=IIf(!Empty(cVld)," .AND. "," ") + "VenctoCAI(M->F1_EMISSAO,M->F1_VENCAI)"
			AAdd(aCposNF,{X3Titulo(),"F1_VENCAI",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,cWhen})
   			SX3->(MsSeek("F1_CAI"))
			cWhen:=	Iif(lCodBar,"Empty(M->F1_CODBAR)"+IIf(Empty(SX3->X3_WHEN),"",".AND."+SX3->X3_WHEN),"")
			cVld :=	LocX3Valid("F1_CAI")
			If aCfgNf[ScCliFor]=="SA2" .And. TamSX3("F1_CAI")[1] == 15
				nTipDc:=Iif(aCfgNF[SnTipo]=10,1,Iif(aCfgNF[SnTipo]=7,3,2))
				cVld+=IIf(!Empty(cVld)," .AND. "," ") + " VldCAIE(alltrim(SA2->A2_CGC),Alltrim(M->F1_SERIE),nTipDc,Subs(Alltrim(M->F1_DOC),1,4),M->F1_CAI,M->F1_VENCAI)"  // (cCGC,ctipo,cPtVenda,cNum,dVencto)
			EndIf
			AAdd(aCposNF,{X3Titulo(),"F1_CAI",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3, cWhen})
			SX3->(MsSeek("F1_QTDEFOL"))
			cVld :=	LocX3Valid("F1_QTDEFOL")
			AAdd(aCposNF,{X3Titulo(),"F1_QTDEFOL",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
  		EndIf
		// %Base Calculo
		If cPaisLoc == "COL" .AND. StrZero(aCfgNf[SnTipo],2)  $ "10"
			SX3->(MsSeek("F1_TASARFT"))
			AAdd(aCposNF,{X3Titulo(),"F1_TASARFT",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,"LocXVal('F1_TASARFT')",SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		EndIf
		If cPaisLoc == "ARG"
			SX3->(MsSeek("F1_PROVENT"))
			cVld := LocX3Valid("F1_PROVENT")
			cVld := 'LocProvEnt()' + If(Empty(cVld),""," .And. " + cVld)
			AAdd(aCposNF,{X3Titulo(),"F1_PROVENT",	SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			If  aCfgNF[SnTipo] >= 6 .aND. aCfgNF[SnTipo] <= 10
				SX3->(MsSeek("F1_ZONGEO"))
				If Found() .AND. X3Uso(SX3->X3_USADO)
					cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
					AAdd(aCposNF,{X3Titulo(),"F1_ZONGEO",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				Endif
				SX3->(MsSeek("F1_CONCOBR"))
				If Found() .AND. X3Uso(SX3->X3_USADO)
					cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
					AAdd(aCposNF,{X3Titulo(),"F1_CONCOBR",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				Endif
				SX3->(MsSeek("F1_IMPNOCF"))
				If Found() .AND. X3Uso(SX3->X3_USADO)
					cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
					AAdd(aCposNF,{X3Titulo(),"F1_IMPNOCF",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				Endif
			Endif

			If  aCfgNF[SnTipo] == 4
				SX3->(MsSeek("F1_FEFIDDE"))
				If Found() .AND. X3Uso(SX3->X3_USADO)
					cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
					AAdd(aCposNF,{X3Titulo(),"F1_FEFIDDE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				Endif

				SX3->(MsSeek("F1_FEFIHTA"))
				If Found() .AND. X3Uso(SX3->X3_USADO)
					cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
					AAdd(aCposNF,{X3Titulo(),"F1_FEFIHTA",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				Endif
			Endif
			SX3->(MsSeek("F1_TPNFEXP"))
			If Found() .And. X3Uso(SX3->X3_USADO)
				cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .And. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
				AAdd(aCposNF,{X3Titulo(),"F1_TPNFEXP",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			Endif
  		EndIf
		//Campo para informar o Imposto do Selo e Liberacao de import. (Somente Portugal)
		//#PORTUGAL#
		/*If cPaisLoc == "PTG"
			SX3->(MsSeek("F1_IMPSELO"))
			cVld :=	LocX3Valid("F1_IMPSELO")
			AAdd(aCposNF,{X3Titulo(),"F1_IMPSELO",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,"!(l103Visual .OR. l103Class)"})

			SX3->(MsSeek("F1_LIQIMP"))
			cVld :=	LocX3Valid("F1_LIQIMP")
			AAdd(aCposNF,{X3Titulo(),"F1_LIQIMP",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN + ".AND.!(l103Visual .OR. l103Class)"})

			//Iva Adquirente
			If SF1->(FieldPos("F1_IVAADQ"))>0
				If AllTrim(cEspecie)$"NF|NDP|NCI|GDN"
					SX3->(MsSeek("F1_IVAADQ"))
					cVld :=	LocX3Valid("F1_IVAADQ")
					AAdd(aCposNF,{X3Titulo(),"F1_IVAADQ",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,"!(l103Visual .OR. l103Class)"})
				EndIf
			EndIf
		EndIf*/
		// Campos referentes ao correlativo
		If  UsaSeqCor()
			SX3->(MsSeek("F1_DIACTB"))
			cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
			AAdd(aCposNF,{X3Titulo(),"F1_DIACTB",SX3->X3_PICTURE,SX3->X3_TAMANHO,	SX3->X3_DECIMAL, cVld, SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		EndIf
		//Campo para informar NF eletronica (Somente Argentina)
		If cPaisLoc == "ARG"
			SX3->(MsSeek("F1_TPVENT"))
			cVld :=	LocX3Valid("F1_TPVENT")
			AAdd(aCposNF,{X3Titulo(),"F1_TPVENT",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			SX3->(MsSeek("F1_FECDSE"))
			cVld :=	LocX3Valid("F1_FECDSE")
			AAdd(aCposNF,{X3Titulo(),"F1_FECDSE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			SX3->(MsSeek("F1_FECHSE"))
			cVld :=	LocX3Valid("F1_FECHSE")
			AAdd(aCposNF,{X3Titulo(),"F1_FECHSE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		EndIf
		If cPaisLoc == "PAR" .AND. (AllTrim(FunName())=="MATA101N")
			SX3->(MsSeek("F1_AUTOFAC"))
			AAdd(aCposNF,{X3Titulo(),"F1_AUTOFAC",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid("F1_AUTOFAC"),SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,IIF(__nOpcx==3,IIF(lAutoFact,"1","2"),SF1->F1_AUTOFAC),,,,,SX3->X3_F3,".F."})
			nPos := Ascan(aCposNF,{ |x| UPPER(x[2]) == AllTrim("F1_SERIE") } )
			IF nPos<>0
				aCposNF[nPos,16]:=IIF(lAutoFact .And. aCfgNf[SnTipo] == 10,"SERNF","")
			ENDIF
			nPos := Ascan(aCposNF,{ |x| UPPER(x[2]) == AllTrim("F1_SERIE2") } )
			IF nPos<>0
				SX3->(MsSeek("F1_SERIE2"))
				aCposNF[nPos]:={X3Titulo(),"F1_SERIE2",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, LocX3VALID(),SX3->X3_USADO,SX3->X3_TIPO, SX3->X3_ARQUIVO, SX3->X3_CONTEXT,,,,,,,".F."}
			ENDIF
		Endif
		If cPaisLoc == "PAR" .AND. ((AllTrim(FunName())=="MATA466N") .OR. (AllTrim(FunName())=="MATA101N") .OR. IsBlind())
			If SF1->(FieldPos("F1_DOCEL"))>0
				If AllTrim(cEspecie)$"NDP|NF"
					SX3->(MsSeek("F1_DOCEL"))
					AAdd(aCposNF,{X3Titulo(),"F1_DOCEL",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid("F1_DOCEL"),SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,IIF(__nOpcx==3,"2",SF1->F1_DOCEL),,,,,SX3->X3_F3,IIF(lAutoFact,".F.",".T.")})
				EndIf
			ENDIF
		Endif
		If cPaisLoc == "PAR" .And. StrZero(aCfgNf[SnTipo],2) == "10" .And. SF1->(ColumnPos("F1_TIPNOTA")) > 0
			SX3->(MsSeek("F1_TIPNOTA"))
			cVld := IIF(FindFunction("ValTpDocPer"),"ValTpDocPer()",LocX3Valid("F1_TIPNOTA"))
			AAdd(aCposNF,{X3Titulo(),"F1_TIPNOTA",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid("F1_TIPNOTA"),SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		//Peru: campo Tipo de Comprovante
		If cPaisLoc == "PER" .And. StrZero(aCfgNf[SnTipo],2)$"04|05|08|09|10|12|13|14|19"
			SX3->(MsSeek("F1_TPDOC"))
			cVld := IIF(FindFunction("ValTpDocPer"),"ValTpDocPer()",LocX3Valid("F1_TPDOC"))
			AAdd(aCposNF,{X3Titulo(),"F1_TPDOC",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		If (cPaisLoc == "PER") .and. (AllTrim(FunName()) == "MATA101N")
			AAdd(aCposNF,{,"F1_IMPRP"})
		EndIf
		//Peru: campo Tipo de Renda - tabela 31 - Sunat
		If cPaisLoc == "PER" .And. StrZero(aCfgNf[SnTipo],2)$"06|07|08|09|10|12|13|14|20" .And. SF1->(FieldPos("F1_TPRENTA")) > 0
			SX3->(MsSeek("F1_TPRENTA"))
			cVld := IIF(FindFunction("ValTpDocPer"),"ValTpDocPer()",LocX3Valid("F1_TPRENTA"))
			AAdd(aCposNF,{,"F1_TPRENTA"})
		Endif
		 // CAEE
		If cPaisLoc == "ARG" .AND. StrZero(aCfgNf[SnTipo],2)  $ "06|07|08|09|10"
			SX3->(MsSeek("F1_CAE"))
			AAdd(aCposNF,{X3Titulo(),"F1_CAE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid("F1_CAE"),SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
			SX3->(MsSeek("F1_VCTOCAE"))
			AAdd(aCposNF,{X3Titulo(),"F1_VCTOCAE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid("F1_VCTOCAE"),SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		EndIf
		If Empty(cPE33)	.AND. StrZero(aCfgNf[SnTipo],2) == "10"	.AND. cPaisLoc == "ARG"
			If SX3->(MsSeek("F1_NUMDES")) .AND. X3Uso(SX3->X3_USADO)
				cVld :=	LocX3Valid("F1_NUMDES")
				AAdd(aCposNF,{X3Titulo(),"F1_NUMDES",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			EndIf
		EndIf
		If cPaisLoc $ "EQU|VEN" .And. StrZero(aCfgNf[SnTipo],2)$"01|03|05|07|09|10|11|12|13|14"
			SX3->(MsSeek("F1_NUMAUT"))
			AAdd(aCposNF,{X3Titulo(),"F1_NUMAUT",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
		EndIf
		If cPaisLoc $ "EQU|CHI|PER|COL" .And. StrZero(aCfgNf[SnTipo],2)$"10|02|04|01|09|51" 	//Campos para transferencia electronica a signature
			IF StrZero(aCfgNf[SnTipo],2)$"02|04"
				SX3->(MsSeek("F1_MOTIVO"))
				AAdd(aCposNF,{X3Titulo(),"F1_MOTIVO",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
				If cPaisLoc $ "CHI|COL|PER"
					SX3->(MsSeek("F1_TIPREF"))
					AAdd(aCposNF,{X3Titulo(),"F1_TIPREF",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
				EndIf
			EndIf
			If cPaisLoc == "EQU"
				If FindFunction("LxCposEqu")
					LxCposEqu(@aCposNF, cFunName, aCfgNf)
				EndIf
			EndIf
			If cPaisLoc $ "PER|COL"
				IF StrZero(aCfgNf[SnTipo],2)$"02|04"
					SX3->(MsSeek("F1_SERIE2"))
					AAdd(aCposNF,{X3Titulo(),"F1_SERIE2",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
					If cPaisLoc == "COL" .And. !Empty(SuperGetMV("MV_PROVFE",,""))
						SX3->(MsSeek("F1_TIPOPE"))
						AAdd(aCposNF,{X3Titulo(),"F1_TIPOPE",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
					EndIf
				EndIf
			EndIf
		EndIf
		If cPaisLoc == "PAR" .and. StrZero(aCfgNf[SnTipo],2)$"04"
			SX3->(MsSeek("F1_TIPREF"))
			AAdd(aCposNF,{X3Titulo(),"F1_TIPREF",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
		EndIf
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. aCfgNF[SlFormProp]
			SX3->(MsSeek("F1_EMCAEE"))
			AAdd(aCposNF,{X3Titulo(),"F1_EMCAEE",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,".F."})
		    SX3->(MsSeek("F1_CAEE"))
			AAdd(aCposNF,{X3Titulo(),"F1_CAEE",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,".F."})
		EndIf
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND.  aCfgNF[SlFormProp]
			SX3->(MsSeek("F1_IDIOMA"))
			cVld := LocX3Valid("F1_IDIOMA")
			AAdd(aCposNF,{X3Titulo(),"F1_IDIOMA",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND.  aCfgNF[SlFormProp]
			SX3->(MsSeek("F1_INCOTER"))
			cVld := LocX3Valid("F1_INCOTER")
			AAdd(aCposNF,{X3Titulo(),"F1_INCOTER",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,X3_TIPO, "SF1", SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. aCfgNF[SlFormProp] .And. !Strzero(aCfgNF[SnTipo],2)$"02|04"
			SX3->(MsSeek("F1_PERMISS"))
			cVld := LocX3Valid("F1_PERMISS")
			AAdd(aCposNF,{X3Titulo(),"F1_PERMISS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, SX3->X3_USADO,SX3->X3_TIPO, "SF1", X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. aCfgNF[SlFormProp]
			SX3->(MsSeek("F1_PAISENT"))
			cVld := LocX3Valid("F1_PAISENT")
			AAdd(aCposNF,{X3Titulo(),"F1_PAISENT",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, SX3->X3_USADO,X3_TIPO, "SF1", SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. aCfgNF[SlFormProp]
			SX3->(MsSeek("F1_NFEXPOR"))
			cVld := LocX3Valid("F1_NFEXPOR")
			AAdd(aCposNF,{X3Titulo(),"F1_NFEXPOR",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, SX3->X3_USADO,SX3->X3_TIPO, "SF1", SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		If cPaisLoc == "ARG"
			SX3->(MsSeek("F1_ADIC5"))
			cVld :=	LocX3Valid("F1_ADIC5")
			AAdd(aCposNF,{X3Titulo(),"F1_ADIC5",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})

			SX3->(MsSeek("F1_ADIC61"))
			cVld :=	LocX3Valid("F1_ADIC61")
			AAdd(aCposNF,{X3Titulo(),"F1_ADIC61",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})

			SX3->(MsSeek("F1_ADIC62"))
			cVld :=	LocX3Valid("F1_ADIC62")
			AAdd(aCposNF,{X3Titulo(),"F1_ADIC62",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})

			SX3->(MsSeek("F1_ADIC7"))
			cVld :=	LocX3Valid("F1_ADIC7")
			AAdd(aCposNF,{X3Titulo(),"F1_ADIC7",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		EndIf
		If cPaisLoc == "CHI" .AND. !aCfgNf[SlRemito] .AND.  !aCfgNF[SlFormProp]
			SX3->(MsSeek('F1_RECHON'))
			cVld := LocX3Valid('F1_RECHON')+" .AND. CORR_VERIF(M->F1_DTDIGIT,M->F1_NUMCOR,.T.,M->F1_RECHON)"
			AAdd(aCposNF,{X3Titulo(),'F1_RECHON',SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		// Campo de Observação e NCF na nota de credito/debito da Loc. Rep. Dom.
		If cPaisLoc == "DOM"
			If Trim(aCfgNf[ScEspecie]) $ "NCC"
				AAdd(aCposNF,{,"F1_NCF",,,,,,,,,,,,,,,})
				AAdd(aCposNF,{,"F1_OBS",,,,,,"M",,,,,,,,,})
			EndIf
		EndIf
		//Campo de Observação na nota de crédito/debito Australia
		If cPaisLoc == "AUS" .AND. Trim(aCfgNf[ScEspecie]) $ "NCC|NDE"
			AAdd(aCposNF,{,"F1_OBS",,,,,,"M",,,,,,,,,})
		EndIf
		//Indica se a nota de entrada e recibo ou nao
		If cPaisLoc == "BOL"
			LxCposBol(@aCposNF, aCfgNf[SAliasHead])
			If !aCfgNf[SlRemito] .And. !aCfgNF[SlFormProp]
				SX3->(MsSeek("F1_RECIBO"))
				cVld := LocX3Valid("F1_RECIBO")
				AAdd(aCposNF,{X3Titulo(),"F1_RECIBO",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
			EndIf
		EndIf
		If cPaisLoc == "ARG" .And. aCfgNf[SAliasHead] == "SF1" .And. (Alltrim(aCfgNf[ScEspecie]) $ "NF|NDP") .And. SF1->(ColumnPos("F1_MODCONS")) >0 .And. SF1->(ColumnPos("F1_CODAUT")) >0 .and. SF1->(ColumnPos("F1_VALCONS")) >0
			SX3->(MsSeek("F1_MODCONS"))
			cVld := LocX3Valid("F1_CODAUT")
			AAdd(aCposNF,{X3Titulo(),"F1_MODCONS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			SX3->(MsSeek("F1_CODAUT"))
			cVld :=	LocX3Valid("F1_CODAUT")
			AAdd(aCposNF,{X3Titulo(),"F1_CODAUT",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			SX3->(MsSeek("F1_VALCONS"))
			cVld := "Afipcons()"
			AAdd(aCposNF,{X3Titulo(),"F1_VALCONS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		Endif
		If cPaisLoc == "ARG" .And. aCfgNf[SAliasHead] == "SF1" .And. SF1->(ColumnPos("F1_TPAJUS")) >0 .And. (Alltrim(aCfgNf[ScEspecie]) $ "NCC|NCI|NDP")
			SX3->(MsSeek("F1_TPAJUS"))
			cVld := LocX3Valid("F1_TPAJUS")
			AAdd(aCposNF,{X3Titulo(),"F1_TPAJUS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		Endif
		If cPaisLoc == "ARG" .And. aCfgNf[SAliasHead] == "SF1" .And. SF1->(ColumnPos("F1_RECPOS")) >0 .And. (Alltrim(aCfgNf[ScEspecie]) $ "NCC")
			SX3->(MsSeek("F1_RECPOS"))
			cVld := LocX3Valid("F1_RECPOS")
			AAdd(aCposNF,{X3Titulo(),"F1_RECPOS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		Endif
		If cPaisLoc == "ARG" .And. aCfgNf[SAliasHead] == "SF1" .And. SF1->(ColumnPos("F1_IVAPOS")) >0 .And. (Alltrim(aCfgNf[ScEspecie]) $ "NCC")
			SX3->(MsSeek("F1_IVAPOS"))
			cVld := LocX3Valid("F1_IVAPOS")
			AAdd(aCposNF,{X3Titulo(),"F1_IVAPOS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF1",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		Endif
		If !(lInclui)
			cNFiscal	:=	SF1->F1_DOC
			cSerie		:=	SF1->F1_SERIE
			nTaxa		:=	SF1->F1_TXMOEDA
			nMoedaNF	:=	SF1->F1_MOEDA
		Endif
	Case aCfgNf[SAliasHead]=="SF2"
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. !aCfgNF[SlFormProp]  .AND. SX3->(MsSeek('F2_CODBAR'))
			cVld := LocX3Valid("F2_CODBAR")
			cVld+= IIf(!Empty(cVld),".AND.","") + "LocxchkCB(M->F2_CODBAR,.T.,M->F2_ESPECIE)"
			AAdd(aCposNF,{,"F2_CODBAR",,,,cVld,,,,,,,,,,,"!(l103Visual .OR. l103Class .OR. " + IIF(aCfgNf[SnTipo] == 64,'.T.','.F.')+")"})
			lCodBar:=.T.
		Else
			lCodBar:=.F.
		Endif
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. ;
           IIf(Type("lFiscal")#"U",lFiscal,.F.)
			SX3->(MsSeek("F2_ECF"))
			cVld := "LocXVal('F2_ECF')"
			cVld += Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. ","")+SX3->X3_VLDUSER,"")
			AAdd(aCposNF,{X3Titulo(),"F2_ECF",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,, "lCFiscal := Iif(M->F2_ECF<>'S',.F.,.T.)",SX3->X3_F3})
		EndIF
		If aCfgNf[ScCliFor]=="SA1"
			SX3->(MsSeek("F2_CLIENTE"))
			cWhen:=	Iif(lCodBar,"Empty(M->F2_CODBAR)"+IIf(Empty(SX3->X3_WHEN),"",".AND."+SX3->X3_WHEN),"")
			cVld:=LocX3Valid("F2_CLIENTE")
			cVld+=IIf(!Empty(cVld)," .AND. ","") + "Posicione('" + aCfgNF[ScCliFor] + "',1,xFilial('" + aCfgNF[ScCliFor] + "')+M->F2_CLIENTE,'" + cP1 + "COD') == M->F2_CLIENTE"
			cVld+=If(!Empty(cVld)," .AND. "," ")+"LxA103VFold('NF_CODCLIFOR',M->F2_CLIENTE)"
			If cPaisLoc  $ "MEX|PER" .AND. lLxWhen
				cWhen	:=	"LxWhenAdt()"+IIf(Empty(cWhen),"",".AND.")+cWhen
			ElseIf cPaisLoc == "RUS"
				cWhen	:= IIf(Empty(SX3->X3_WHEN),cWhen,Iif(!EMPTY(cWhen),SX3->X3_WHEN+".AND."+cWhen,SX3->X3_WHEN))
				cX3F3	:= AllTrim(GetSX3Cache("F2_CNTID", "X3_F3"))
				SX3->(MsSeek("F2_CLIENTE"))
			EndIf
			AAdd(aCposNF,{,"F2_CLIENTE",,,,cVld,,,,,,,,,,,cWhen})
		Else
			SX3->(MsSeek("F1_FORNECE"))
			//Inclui os campos que sao exclusivos do remito de transf..
			If aCfgNf[SlRemito].AND. lInclui .AND. aCfgNf[SnTipo] == 54
				cVld:="NfFilDest(M->F2_FILDEST) .AND. NFGrpDep(M->F2_CLIENTE,M->F2_LOJA) .AND. LocXVal('F2_LOJA')"
				AAdd(aCposNF,{STR0174,'F2_FILDEST',"@!",LEN(SM0->M0_CODFIL),,cVld,,'C',,,,,,,,'SM0'})
    	      	cWhen := ".F."
			Else
				cWhen	:=	Iif(lCodBar,"Empty(M->F2_CODBAR)"+IIf(Empty(SX3->X3_WHEN),"",".AND."+SX3->X3_WHEN),"")
	        EndIf
			cVld:=LocX3Valid("F1_FORNECE")
			cVld+=IIf(!Empty(cVld)," .AND. ","") + "Posicione('" + aCfgNF[ScCliFor] + "',1,xFilial('" + aCfgNF[ScCliFor] + "')+&(__ReadVar),'" + cP1 + "COD') == &(__ReadVar)"
			cVld+=If(!Empty(cVld)," .AND. "," ")+"LxA103VFold('NF_CODCLIFOR',M->F2_CLIENTE)"
			If cPaisLoc == "RUS"
				cX3When	:=  AllTrim(GetSX3Cache("F2_CLIENTE", "X3_WHEN"))
				cX3F3	:=	AllTrim(GetSX3Cache("F1_CNTID", "X3_F3"))
				cWhen	:= IIf(Empty(cX3When),cWhen,Iif(!EMPTY(cWhen),cX3When+".AND."+cWhen,cX3When))
			EndIf
			SX3->(MsSeek("F1_FORNECE"))
			AAdd(aCposNF,{X3Titulo(),"F2_CLIENTE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,cWhen})
		EndIf
		cVld:=LocX3Valid("F2_LOJA")
		cVld+=IIf(!Empty(cVld)," .AND. ","")  + "ExistCpo('"+ aCfgNf[ScCliFor]+"',M->F2_CLIENTE+M->F2_LOJA)"
		cVld+=IIf(!Empty(cVld)," .And. ","") + "AtuCliFor()"
		cVld+=If(!Empty(cVld)," .And. "," ")+"LxA103VFold('NF_LOJA',M->F2_LOJA)"
		cVld+=IIf(!Empty(cVld)," .And. ","") + "LocXVal('F2_LOJA')"
		If StrZero(aCfgNf[SnTipo],2) $ "06|07|61|22"
			cVld+=IIf(!Empty(cVld)," .And. ","")  + "If(Empty(M->F2_CLIENTE),.T.,ExistCpo('"+ aCfgNf[ScCliFor]+"',M->F2_CLIENTE+M->F2_LOJA))"
		EndIf
		If aCfgNf[SlRemito] .AND. aCfgNf[SnTipo] == 54
			cVld+=IIf(!Empty(cVld)," .AND. ","") + "NFGrpDep(M->F2_CLIENTE,M->F2_LOJA)"
		EndIf
		If cPaisLoc  $ "MEX|PER" .AND. lLxWhen
			cWhen	:=	"LxWhenAdt()"+IIf(Empty(cWhen),"",".AND.")+cWhen
		ElseIf cPaisLoc == "RUS"
			SX3->(MsSeek("F2_LOJA"))
			cWhen	:= IIf(Empty(SX3->X3_WHEN),cWhen,Iif(!EMPTY(cWhen),SX3->X3_WHEN+".AND."+cWhen,SX3->X3_WHEN))
		EndIf
		AAdd(aCposNF,{,"F2_LOJA",,,,cVld,,,,,,,,,,,cWhen})
		SX3->(MsSeek(cP1+"NOME"))
		AAdd(aCposNF,{X3Titulo(),"cNome",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3VALID(),SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT,"Posicione('"+ aCfgNf[ScCliFor]+"',1,xFilial('"+ aCfgNf[ScCliFor]+"')+M->F2_CLIENTE+M->F2_LOJA,cP1+'NOME')",,,,,,".F."})
		AAdd(aCposNF,{,"F2_NUMTIM"})
		//³Para o Peru pode-se utilizar o campo especifico para serie com 4 digitos caso se tratar de Notas de Credito(NCE/NCP) que nao utilizem formulario proprio. ³
        If cPaisLoc $ "PER|COL|" .And. lSerOri
			AAdd(aCposNF,{,"F2_SERIE2"})
		Endif
        If cPaisLoc $ "PER|" .And. lSerOri
			AAdd(aCposNF,{,"F2_SERORI",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],cSerSXB,),".F."})
		EndIf
		cVld:=LocX3Valid("F2_SERIE")
		If lCodBar
			cVld+=IIf(!Empty(cVld)," .AND. ","") +"LocxSERIE('SF2',M->F2_CODBAR,M->F2_SERIE)"
		Endif
		cVld+=IIf(!Empty(cVld)," .AND. "," ") +"LocXVal('F2_SERIE')"
        cVld+=IIf(!Empty(cVld)," .AND. ","") +  "LocxValNum()"
        //³Para Portugal nao deve permitir incluir uma NF quando para a serie informada existir documento ³
        //³gerado com data igual ou superior a data de emissao(database) da nova NF.                      ³
        //#PORTUGAL#
		/*If cPaisLoc == "PTG" .and. lHashPTG .and. aCfgNf[SlFormProp]
            cVld+=IIf(!Empty(cVld)," .AND. ","") +  "Iif(!Empty(&(ReadVar())),VldSerTipo(AllTrim(&(ReadVar())),M->F2_ESPECIE) .and. VldCtrForm(AllTrim(&(ReadVar())),M->F2_ESPECIE,@M->F2_DOC,1),.T.)"
        EndIf*/
        If cPaisLoc=="VEN" .And.  SF2->(ColumnPos("F2_FORMLIB")) > 0   .And. aCfgNf[SlFormProp]
        	cVld+=IIf(!Empty(cVld)," .AND. "," ") +"FormLibre()"
        EndIf
		cWhen := ""
        If cPaisLoc == "ARG"
			If aCfgNf[SlFormProp] .AND. !aCfgNf[SlRemito] .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
				cWhen := "M->F2_ECF <> 'S'"
			Else
				cWhen := "!l103Visual .AND. Iif(lFuncAtual,Iif(lAltSerie,.T.,Iif(!Empty(M->F2_SERIE),.F.,.T.)),.T.)"
			EndIf
			// Leandro Prado - 19/02/2014 -Para argentina foi implementado o controle de ponto de venda.
			If ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA462N|MATA462DN|FINA096|MATA462TN|MATA462R|OMSA320") .or. (FUNNAME() $  "FINA095|FINA074|FINA084|FINA846|FINA935") .Or. lfina998
				If aCfgNf[SlFormProp]
					AAdd(aCposNF,{,"F2_PV",,,,,,,,,"'"+cLocxNFPV+"'",,,,,,".F."})
					cVld+= IIf(!Empty(cVld)," .AND. ","") +  "LNF2VldSer()" //Add o valid para ver se a série é valida para o PV.
				EndIf
				cVld+= IIf(!Empty(cVld)," .AND. ","") +  "GrvRG1415()" //Add o valid para preencher o F1_RG1415
				AAdd(aCposNF,{,"F2_SERIE",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],"X501PV",),cWhen})
			Else
				AAdd(aCposNF,{,"F2_SERIE",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],"01",),cWhen})
			EndIf
        ElseIf cPaisLoc == "MEX" .And. lFuncAtual
			cWhen := "!l103Visual .And. Iif(lAltSerie,.T.,Iif(!Empty(M->F2_SERIE),.F.,.T.))"
			AAdd(aCposNF,{,"F2_SERIE",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],cSerSXB,),cWhen})
		ElseIf cPaisLoc == "CHI" .And. lVer116 .And. AllTrim(aCfgNf[ScEspecie]) $ "NCP"
			cVld+=IIf(!Empty(cVld)," .AND. ","") +"VldNumCor(M->F2_SERIE)"
			AAdd(aCposNF,{,"F2_SERIE",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],cSerSXB,"SDV")})
		Else
			AAdd(aCposNF,{,"F2_SERIE",,,,cVld,,,,,,,,,,IIf(aCfgNf[SlFormProp],cSerSXB,),Iif((cPaisLoc == "PER") .and. lSerie2,".F.",)})
		EndIf
		If cPaisLoc == "PER" .And. StrZero(aCfgNf[SnTipo],2)$"01|02|03|06|07|11|15|19|50"
			SX3->(MsSeek("F2_TPDOC"))
			AAdd(aCposNF,{X3Titulo(),"F2_TPDOC",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid("F2_TPDOC"),SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		//Peru: campo Tipo de Renda - tabela 31 - Sunat
		If cPaisLoc == "PER" .And. StrZero(aCfgNf[SnTipo],2)$"06|07|08|09|10|12|13|14|20" .And. SF2->(FieldPos("F2_TPRENTA")) > 0
			SX3->(MsSeek("F2_TPRENTA"))
			cVld := IIF(FindFunction("ValTpDocPer"),"ValTpDocPer()",LocX3Valid("F2_TPRENTA"))
			AAdd(aCposNF,{,"F2_TPRENTA"})
		Endif
		cVld	:=	LocX3Valid("F2_DOC")
		cVld	+=	IIf(!Empty(cVld)," .AND. ","") + "AtuNumIt()"
		If ( Type("lLocxAuto") == "U" .OR. !lLocxAuto )
			cVld+=IIf(!Empty(cVld)," .AND. ","") + "EnablePanel()"
		Endif
		cVld	+=	IIf(!Empty(cVld)," .AND. ","")+ " LocXVal('F2_DOC')"
		cVld	+=	IIf(!Empty(cVld)," .AND. ","") +  "LocxValNum()"
   	    If aCfgNf[ScCliFor]=="SA2" .And. cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. !aCfgNF[SlFormProp]
	    		cVld+=IIf(!Empty(cVld)," .AND. ","") + "AutNumCai(M->F2_ESPECIE)"
	    EndIf
	    If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
	    	cWhen := If(lInclui.AND.aCfgNf[SlFormProp],"Substr(cAcesso,50,1)=='S' .AND. M->F2_ECF <> 'S'",)
        ElseIf cPaisLoc == "MEX" .And. lFuncAtual
 			cWhen := If(lInclui.And.aCfgNf[SlFormProp],"Substr(cAcesso,50,1)=='S' .And. Iif(lFuncAtual,Iif(lAltSerie,.T.,Iif(!Empty(M->F2_DOC),.F.,.T.)),.T.)","Iif(lFuncAtual,Iif(lAltSerie,.T.,Iif(!Empty(M->F2_DOC),.F.,.T.)),.T.)")
	    Else
 			cWhen := If(lInclui.AND.aCfgNf[SlFormProp],"Substr(cAcesso,50,1)=='S'",)
	    EndIf
		If cPaisLoc == "ARG"
	    	cVld    +=  Iif(!Empty(cVld)," .AND. ","") +  "GrvRG1415()"
	    EndIf
		AAdd(aCposNF,{,"F2_DOC",,,,cVld,,,,,,,,,,,cWhen})
		If cPaisLoc == "ARG"
			If ( cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA462N|MATA462DN|FINA096|MATA462TN|MATA462R") .or. (FUNNAME() $  "FINA095|FINA074|FINA084|FINA846|FINA935")  .Or. lfina998
				AAdd(aCposNF,{,"F2_RG1415",,,,,,,,,,,,,,,".T."})
				If SF2->(ColumnPos("F2_CC")) > 0
					AAdd(aCposNF,{,"F2_CC",,,,"VldCC(M->F2_CLIENTE,M->F2_LOJA,M->F2_CC,M->F2_RG1415)",,,,,,,,,,Iif(cFunName $"MATA467N","","FVS"),Iif(aCfgNf[SlFormProp],".F.",".T.")})
				Endif
			Endif
		Endif
		//campos referentes ao certificado e numero de aprovacao - comprovantes fiscais digitais
		If lGerarCFD
			AAdd(aCposNF,{,"F2_APROFOL",,,,,,,,,,,,,,,".F."})
			AAdd(aCposNF,{,"F2_CERTFOL",,,,,,,,,,,,,,,".F."})
		Endif
		If aCfgNf[SlFormProp]
			If lContrFol .And. cPaisLoc <> "ARG"
				AAdd(aCposNF,{,"F2_NUMAUT",,,,,,,,,,,,,,,".F."}) //Numero de Autorizacao
				AAdd(aCposNF,{,"F2_CODCTR",,,,,,,,,,,,,,,".F."}) //Codigo de Controle
				AAdd(aCposNF,{,"F2_LIMEMIS",,,,,,,,,,,,,,,".F."}) //Data Limite de Emissao
			Endif
			If lTipComp
		   		AAdd(aCposNF,{,"F2_TIPCOMP",,,,,,,,,,,,,,,".T."})
			Endif
		Else
			If lContrFol .And. cPaisLoc <> "ARG"
				AAdd(aCposNF,{,"F2_NUMAUT"})
				AAdd(aCposNF,{,"F2_CODCTR"})
				AAdd(aCposNF,{,"F2_LIMEMIS"})
			Endif
			If lTipComp
				AAdd(aCposNF,{,"F2_TIPCOMP"})
			Endif
		Endif
		// Forma Libre - Venezuela
		If  cPaisLoc=="VEN" .And.  SF2->(ColumnPos("F2_FORMLIB")) > 0
			If aCfgNf[SlFormProp]
				AAdd(aCposNF,{,"F2_FORMLIB",,,,cVld,,,,,,,,,,,".F."})
			Else
				AAdd(aCposNF,{,"F2_FORMLIB",,,,cVld,,,,,,,,,,,".T."})
			EndIf
		EndIf
		If cPaisLoc $ "VEN|URU|DOM"
			AAdd(aCposNF,{,"F2_NATUREZ",,,,"LxA103VFold('NF_NATUREZA',M->F2_NATUREZ)",,,,,,,,,,"SED"})
		ElseIf cPaisLoc <> "MEX"
			AAdd(aCposNF,{,"F2_NATUREZ",,,,,,,,,,,,,,"SED"})
		EndIf
		//Inclui os campos que sao exclusivos do remito de transf..
		If aCfgNf[SlRemito].AND. lInclui .AND. aCfgNf[SnTipo] == 54
			aCposExt := CposToHead({'D2_LOCDEST','D2_TESENT'})
			aSize(aCposExt[1],12)
			aSize(aCposExt[2],12)
			aCposExt[1][12] := 16  // Def.ord.campo
			aCposExt[2][12] := 10  // Def.ord.campo
			cVld := LocX3VALID('D2_TESENT')
			If !Empty(cVld)
				cVld := "(" + cVld + ") .AND. "
			EndIf
			cVld += "NFVldTES()"
			aCposExt[2][06] := cVld
			cVld := LocX3VALID('F2_GRPDEP')
			If !Empty(cVld)
				cVld := "(" + cVld + ") .AND. "
			EndIf
			cVld += "NFVldDep()"
			AAdd(aCposNF,{,"F2_GRPDEP",,,,cVld})
			If !cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
				AAdd(aCposNF,{STR0172,"F2_TIPORET",,1,,"Pertence('1|2| ')",,"C",,,,,.T.,,,,"cTipoRet=='3'",,,.T.,{' ',STR0170,STR0171},,{|| IIf(cTipoRet=='3',' ',cTipoRet) } } ) //
			Else
				cVld := LocX3VALID("F2_TIPORET")
				If !Empty(cVld)
					cVld := "Pertence('1|2| ')"
				EndIf
				AAdd(aCposNF,{,"F2_TIPORET",,,,cVld,,,,,,,,,,,})
			EndIf
		Endif
		AAdd(aCposNF,{,"F2_ESPECIE",,,,,,,,,IIf(lInclui,"aCfgNf[" + AllTrim(Str(ScEspecie)) + "]",),,,,,"",".F."})
		cVld:= "(SetVar('F2_EMISSAO')"+" .And. !aCfgNf["+AllTrim(Str(SlFormProp)+ "] .Or. M->F2_EMISSAO == dDataBase)")
		cVld+=" .And. "+"LocXVal('F2_EMISSAO')" + IIf(cPaisLoc == "ARG"," .and. LocEmisPro() ","")
		AAdd(aCposNF,{,"F2_EMISSAO",,,,cVld,,,,,,,,,,,IIf(aCfgNf[SlFormProp]== .T.,'.F.','.T.')})
		If  cPaisloc $ "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN" .AND. ( Type("cFunName") == "C" ) .AND. ( cFunName == "MATA467N" )
			AAdd(aCposNF,{,"F2_TABELA",,,,,,,,,,,,,,"DA0",".T."})
		EndIf
		If cPaisLoc <> "RUS" .And. (!lInclui .Or. lUsaCor) .And. ! aCfgNf[SlFormProp]
			AAdd(aCposNF,{,"F2_DTDIGIT",,,,,,,,,If(lInclui,"dDatabase",),,,,,"",".F."})
		EndIf
		//Vendedores soh em faturam.
		If aCfgNf[ScCliFor]=="SA1"
			For nX := 1 to Fa440CntVen()
				cVld := LocX3VALID("F2_VEND"+AllTrim(Str(nX)))
				If !Empty(cVld)
					cVld := "(" + cVld + ") .AND. "
				EndIf
				cVld += "NFComisTot(" + AllTrim(Str(nX)) + ")"
				AAdd(aCposNF,{,"F2_VEND"+AllTrim(Str(nX)),,,,cVld})
			Next nX
		Endif
		SX3->(MsSeek("F2_MOEDA"))
		cWhen	:=	SX3->X3_WHEN
		If cPaisLoc == "RUS"
		    SX3->(MsSeek("F2_DTSAIDA"))
		    cVld	:=	LocX3Valid("F2_DTSAIDA")
		    cVld	+= Iif(Empty(cVld),"LocXVal('F2_DTSAIDA')","")
		    AAdd(aCposNF,{,"F2_DTSAIDA",,SX3->X3_TAMANHO,,cVld,,,,,,,,,"LocXVal('F2_DTSAIDA')"})
	        SX3->(MsSeek("F2_MOEDA"))
		    cWhen	:=	SX3->X3_WHEN
	        AAdd(aCposNF,{X3Titulo(),"F2_MOEDA",SX3->X3_PICTURE,SX3->X3_TAMANHO+2,SX3->X3_DECIMAL,,SX3->X3_USADO,SX3->X3_TIPO,"SF2",SX3->X3_CONTEXT,,,,,"LocXVal('F2_MOEDA')",SX3->X3_F3,cWhen})
         	SX3->(MsSeek("F2_TXMOEDA"))
			cWhen	:=	AllTrim(SX3->X3_WHEN)
			/* This function should be here, because it is in the x3_when of the F2_MOEDA field, but we cannot completely inherit the contents of the x3_when of the F2_MOEDA field. */
			cWhen 	+= Iif("RUXXTS05()" $ cWhen,"",Iif(!EMPTY(AllTrim(cWhen)),".AND.RUXXTS05()","RUXXTS05()"))
		    cVld	:=	LocX3Valid("F2_TXMOEDA")
		    cVld	+=	IIf(!Empty(cVld)," .AND. "," ") + "LocXVal('F2_TXMOEDA')"
	        AAdd(aCposNF,{,"F2_TXMOEDA",,,,cVld,,,,,,,,,,,cWhen})
			cVld	:=	LocX3Valid("F2_REFTAXA")
	        cVld	+=	IIf(!Empty(cVld)," .AND. "," ") + "LocXVal('F2_REFTAXA')"
	        AAdd(aCposNF,{,"F2_REFTAXA",,,,cVld})
		    SX3->(MsSeek("CTO_SIMB"))
	  	    AAdd(aCposNF,{X3Titulo(),"CTO_SIMB",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,"Posicione('CTO', 1, xFilial('CTO')+StrZero(SF2->F2_MOEDA, TamSX3('CTO_MOEDA')[1]),'CTO_SIMB')",SX3->X3_USADO,SX3->X3_TIPO, SX3->X3_ARQUIVO, SX3->X3_CONTEXT,"Posicione('CTO', 1, xFilial('CTO')+StrZero(M->F2_MOEDA, TamSX3('CTO_MOEDA')[1]),'CTO_SIMB')",,,,,,".F."})
			SX3->(MsSeek("F2_CONUNI"))
			AAdd(aCposNF,{,"F2_CONUNI",,SX3->X3_TAMANHO,,,,,,,,,,,"Pertence('12')",,"RUXXTS05().AND.EMPTY(M->F2_CNTID)",,,.T.,{STR0135,STR0136},    ,{|| M->F2_CONUNI := '2' } } ) //'1=Sim'###'2=Nao'
            AAdd(aCposNF,{,"F2_CNORVEN",,,,,,,,,,,,,"Pertence('12')",,,,,.T.,{STR0399,STR0398},    ,{|| M->F2_CNORVEN := '1' } } ) //'1=Vendor'###'2=Other'
            AAdd(aCposNF,{,"F2_CNEECLI",,,,,,,,,,,,,"Pertence('12')",,,,,.T.,{STR0397,STR0398},    ,{|| M->F2_CNEECLI := '1' } } ) //'1=Buyer'###'2=Other'
            SX3->(MsSeek("F2_CNORCOD"))
			cVld	:=	LocX3Valid("F2_CNORCOD")
			cWhen	:=	SX3->X3_WHEN
            AAdd(aCposNF,{,"F2_CNORCOD",,,,cVld,,,,,,,,,,SX3->X3_F3,cWhen})
			SX3->(MsSeek("F2_CNEECOD"))
			cVld	:=	LocX3Valid("F2_CNEECOD")
			cWhen	:=	SX3->X3_WHEN
            AAdd(aCposNF,{,"F2_CNEECOD",,,,cVld,,,,,,,,,,SX3->X3_F3,cWhen})
			SX3->(MsSeek("F2_CNORBR"))
         	cVld	:=	LocX3Valid("F2_CNORBR")
			cWhen	:=	SX3->X3_WHEN
         	AAdd(aCposNF,{,"F2_CNORBR",,SX3->X3_TAMANHO,,cVld,,,,,,,,,,,cWhen})//when cant be false, execauto at UCLD cant fill the field
			SX3->(MsSeek("F2_CNEEBR"))
            cVld	:=	LocX3Valid("F2_CNEEBR")
			cWhen	:=	SX3->X3_WHEN
         	AAdd(aCposNF,{,"F2_CNEEBR",,SX3->X3_TAMANHO,,cVld,,,,,,,,,,,cWhen})//when cant be false, execauto at UCLD cant fill the field
			SX3->(MsSeek("F2_CNTID"))
	        AAdd(aCposNF,{X3Titulo(),"F2_CNTID",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,,SX3->X3_USADO,SX3->X3_TIPO,"SF2",SX3->X3_CONTEXT,,,,,"LocXVal('F2_CNTID')",SX3->X3_F3,"RUXXTS05()"})
			SX3->(MsSeek("F2_F5QUID"))
	        AAdd(aCposNF,{X3Titulo(),"F2_F5QUID",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,,,SX3->X3_TIPO,"SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,"RUXXTS05()"})
			SX3->(MsSeek("F2_F5QDESC"))
	        AAdd(aCposNF,{X3Titulo(),"F2_F5QDESC",SX3->X3_PICTURE,60,SX3->X3_DECIMAL,,SX3->X3_USADO,SX3->X3_TIPO,"SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,"RUXXTS05()"})
		Else
			If cPaisLoc  $ "MEX|PER" .AND. lLxWhen
				cWhen	:=	"LxWhenAdt()"+IIf(Empty(cWhen),cWhen,".AND."+cWhen)
			EndIf
			AAdd(aCposNF,{,"F2_MOEDA"  ,,,,"LocXVal('F2_MOEDA')",,,,,,,,,"LocXVal('F2_MOEDA')",,cWhen,,,.T.,aMoedas,{|x| x:nAt}})
			SX3->(MsSeek("F2_TXMOEDA"))
			cVld	:=	LocX3Valid("F2_TXMOEDA")
			cVld	+=	IIf(!Empty(cVld)," .AND. "," ") + "LocXVal('F2_TXMOEDA')"
			cWhen	:=	SX3->X3_WHEN
			If cPaisLoc  $ "MEX|PER" .AND. lLxWhen
				cWhen	:=	"LxWhenAdt()"+IIf(Empty(cWhen),cWhen,".AND."+cWhen)
			EndIf
			AAdd(aCposNF,{,"F2_TXMOEDA",,,,cVld,,,,,,,,,,,cWhen})
		EndIf
		If lUsaCor  //numero correlativo
			AAdd(aCposNF,{,"F2_NUMCOR",,,,"CORR_VERIF(M->F2_DTDIGIT,M->F2_NUMCOR,.T.,'2',M->F2_ESPECIE)",,,,,})
		EndIf
		If cPaisLoc == "ARG" .AND. SubStr(cAgente,6,1) == "S" .AND. aCfgNF[SnTipo] == 7 .And. SF2->(ColumnPos("F2_VALSUSS")) > 0
			cVld := LocX3Valid("F2_VALSUSS")
			AAdd(aCposNF,{X3Titulo(), "F2_VALSUSS", SX3->X3_PICTURE, SX3->X3_TAMANHO, SX3->X3_DECIMAL, cVld, SX3->X3_USADO, SX3->X3_TIPO, "SF2", SX3->X3_CONTEXT, , , , , , SX3->X3_F3})
		EndIf
		//Inclui os campos que sao exclusivos do remito.
		If aCfgNf[SlRemito] .AND. aCfgNf[ScTipoDoc] == "N"
			AAdd(aCposNF,{,"F2_TIPOREM"} )
			cAuxPaisL := "ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|HAI|MEX|PAD|PAN|PAR|PER|POR|SAL|TRI|URU|VEN"
			If cPaisLoc $ cAuxPaisL
				AAdd(aCposNF,{,"F2_LIQPROD"} )
			EndIf
			If SF2->(ColumnPos("F2_VEHICL")) > 0
				AAdd(aCposNF, {, "F2_VEHICL", , , , "F2VerVehi(M->F2_VEHICL, F2_ACOPLA, ReadVar())"})
			EndIf
			If SF2->(ColumnPos("F2_ACOPLA")) > 0
				AAdd(aCposNF, {, "F2_ACOPLA", , , , "F2VerVehi(M->F2_VEHICL, F2_ACOPLA, ReadVar())", , , , , })
			EndIf
		Endif
        //#PORTUGAL#
		/*If cPaisLoc == "PTG" .and. lHashPTG .and. ( ( cEspecie$"RFN|GRN") .or. ( cFunName == "MATA467N" ))
            SF2->(ColumnPos("F1_HASH")) > 0
            If SF2->(ColumnPos("F2_TRANSP")) > 0
                AAdd(aCposNF,{,"F2_TRANSP"} )
            EndIf
            If SF2->(ColumnPos("F2_CHAPA")) > 0
                AAdd(aCposNF,{,"F2_CHAPA"} )
            EndIf
            If SF2->(ColumnPos("F2_LOCCARG")) > 0
                AAdd(aCposNF,{,"F2_LOCCARG"} )
            EndIf
            If SF2->(ColumnPos("F2_MUNCARG")) > 0
                AAdd(aCposNF,{,"F2_MUNCARG"} )
            EndIf
            If SF2->(ColumnPos("F2_CEPCARG")) > 0
                AAdd(aCposNF,{,"F2_CEPCARG"} )
            EndIf
            If SF2->(ColumnPos("F2_PAISCAR")) > 0
                AAdd(aCposNF,{,"F2_PAISCAR"} )
            EndIf
            If SF2->(ColumnPos("F2_LOCDESC")) > 0
                AAdd(aCposNF,{,"F2_LOCDESC"} )
            EndIf
            If SF2->(ColumnPos("F2_MUNDESC")) > 0
                AAdd(aCposNF,{,"F2_MUNDESC"} )
            EndIf
            If SF2->(ColumnPos("F2_CEPDESC")) > 0
                AAdd(aCposNF,{,"F2_CEPDESC"} )
            EndIf
            If SF2->(ColumnPos("F2_PAISDES")) > 0
                AAdd(aCposNF,{,"F2_PAISDES"} )
            EndIf
            If SF2->(ColumnPos("F2_DTSAIDA")) > 0
                AAdd(aCposNF,{,"F2_DTSAIDA"} )
            EndIf
            If SF2->(ColumnPos("F2_HORA")) > 0
                AAdd(aCposNF,{,"F2_HORA"} )
            EndIf
		EndIf*/
		If cPaisLoc == "PAR" .and.  ( cEspecie$"RFN|RTS")
			IF SF2->(ColumnPos("F2_TRANSP")) > 0
                AAdd(aCposNF,{,"F2_TRANSP"} )
            EndIf
			IF SF2->(ColumnPos("F2_VEICULO")) > 0
                AAdd(aCposNF,{,"F2_VEICULO"} )
            EndIf
			IF SF2->(ColumnPos("F2_FECDSE")) > 0
				AAdd(aCposNF,{,"F2_FECDSE"} )
			ENDIF
			IF SF2->(ColumnPos("F2_FECHSE")) > 0
				AAdd(aCposNF,{,"F2_FECHSE"} )
			ENDIF

			IF SF2->(ColumnPos("F2_INCOTER")) > 0
				AAdd(aCposNF,{,"F2_INCOTER"} )
			ENDIF

			IF SF2->(ColumnPos("F2_TPRESFL")) > 0
				AAdd(aCposNF,{,"F2_TPRESFL"} )
			ENDIF
		ENDIF
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. !aCfgNF[SlFormProp]
			SX3->(MsSeek("F2_VENCAI"))
			cWhen:=	Iif(lCodBar,"Empty(M->F2_CODBAR)"+IIf(Empty(SX3->X3_WHEN),"",".AND."+SX3->X3_WHEN),"")
			cVld :=	LocX3Valid("F2_VENCAI")
			If aCfgNf[ScCliFor]=="SA2"
				cVld+=IIf(!Empty(cVld)," .AND. "," ") + "VenctoCAI(M->F2_EMISSAO,M->F2_VENCAI)"
			EndIf
			AAdd(aCposNF,{X3Titulo(),"F2_VENCAI",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,cWhen})

			SX3->(MsSeek("F2_CAI"))
			cWhen:=	Iif(lCodBar,"Empty(M->F2_CODBAR)"+IIf(Empty(SX3->X3_WHEN),"",".AND."+SX3->X3_WHEN),"")
			cVld :=	LocX3Valid("F2_CAI")
			If aCfgNf[ScCliFor]=="SA2" .And. TamSX3("F2_CAI")[1] == 15
				nTipDc:=Iif(aCfgNF[SnTipo]=10,1,Iif(aCfgNF[SnTipo]=7,3,2))
				cVld+=IIf(!Empty(cVld)," .AND. "," ") + " VldCAIE(alltrim(SA2->A2_CGC),Alltrim(M->F2_SERIE),nTipDc, Subs(Alltrim(M->F2_DOC),1,4),M->F2_CAI,M->F2_VENCAI)"  // (cCGC,ctipo,cPtVenda,cNum,dVencto)
			EndIf
			AAdd(aCposNF,{X3Titulo(),"F2_CAI",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,cWhen})
			cVld :=	LocX3Valid("F2_QTDEFOL")
			AAdd(aCposNF,{X3Titulo(),"F2_QTDEFOL",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
  		EndIf
		If cPaisLoc == "EUA" .And. FindFunction("fCposNFEua")
			fCposNFEua(@aCposNF, cFunName, aCfgNF[SAliasHead], Trim(aCfgNf[ScEspecie]))
		EndIf
		IIf(cPaisLoc == "BOL" .And. aCfgNF[SAliasHead] =="SF2", LxCposBol(@aCposNF,aCfgNf[SAliasHead]),)
		//Exibe o campo p/que seja informada Provincia de entrega ou prest. do servico
		If cPaisLoc == "ARG" .And. aCfgNF[SAliasHead] =="SF2"
			SX3->(MsSeek("F2_PROVENT"))
			cVld := LocX3Valid("F2_PROVENT")
			cVld := 'LocProvEnt()' + If(Empty(cVld),""," .And. " + cVld)
			AAdd(aCposNF,{X3Titulo(),"F2_PROVENT",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO,"SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		Endif
		If  cPaisLoc == "ARG" .AND. aCfgNF[SnTipo] >= 6 .AND. aCfgNF[SnTipo] <= 10
			SX3->(MsSeek("F2_ZONGEO"))
			If Found() .AND. X3Uso(SX3->X3_USADO)
				cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
				AAdd(aCposNF,{X3Titulo(),"F2_ZONGEO",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			Endif
			SX3->(MsSeek("F2_CONCOBR"))
			If Found() .AND. X3Uso(SX3->X3_USADO)
				cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
				AAdd(aCposNF,{X3Titulo(),"F2_CONCOBR",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			Endif
			SX3->(MsSeek("F2_TPNFEXP"))
			If Found() .And. X3Uso(SX3->X3_USADO)
				cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .And. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
				AAdd(aCposNF,{X3Titulo(),"F2_TPNFEXP",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, X3_USADO,X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			EndIf
			SX3->(MsSeek("F2_IMPNOCF"))
			If Found() .AND. X3Uso(SX3->X3_USADO)
				cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
				AAdd(aCposNF,{X3Titulo(),"F2_IMPNOCF",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			Endif
			SX3->(MsSeek("F2_CAE"))  // CAEE
			AAdd(aCposNF,{X3Titulo(),"F2_CAE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid("F2_CAE"),SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
			SX3->(MsSeek("F2_VCTOCAE"))
			AAdd(aCposNF,{X3Titulo(),"F2_VCTOCAE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid("F2_VCTOCAE"),SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN})
		Endif
		If  cPaisLoc == "ARG" .AND. aCfgNF[SnTipo] == 2
			SX3->(MsSeek("F2_FEFIDDE"))
				If Found() .AND. X3Uso(SX3->X3_USADO)
					cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
					AAdd(aCposNF,{X3Titulo(),"F2_FEFIDDE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				Endif

				SX3->(MsSeek("F2_FEFIHTA"))
				If Found() .AND. X3Uso(SX3->X3_USADO)
					cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
					AAdd(aCposNF,{X3Titulo(),"F2_FEFIHTA",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				Endif
		Endif
		// Campos referentes a base Portugal (util.p/contabilizacao)
		//#PORTUGAL#
		/*If cPaisLoc == "PTG"
			SX3->(MsSeek("F2_DECLEXP"))
			cVld :=	LocX3Valid("F2_DECLEXP")
			AAdd(aCposNF,{X3Titulo(),"F2_DECLEXP",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,SX3->X3_WHEN + ".AND. !(l103Visual .OR. l103Class)"})
			//Iva Adquirente
			If SF2->(FieldPos("F2_IVAADQ"))>0
				If AllTrim(cEspecie)$"NCP|NDI"
					SX3->(MsSeek("F2_IVAADQ"))
					cVld :=	LocX3Valid("F2_IVAADQ")
					AAdd(aCposNF,{X3Titulo(),"F2_IVAADQ",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3,"!(l103Visual .OR. l103Class)"})
				EndIf
			EndIf
		EndIf*/
		// Campos referentes ao correlativo
		If ( UsaSeqCor() ) .AND. SX3->(MsSeek("F2_DIACTB")) .AND. X3Uso(SX3->X3_USADO)
			cVld := Iif(!Empty(SX3->X3_VALID),SX3->X3_VALID,"")+Iif(!Empty(SX3->X3_VLDUSER),Iif(!Empty(SX3->X3_VALID)," .AND. "+SX3->X3_VLDUSER,SX3->X3_VLDUSER),"")
			AAdd(aCposNF,{X3Titulo(),"F2_DIACTB",SX3->X3_PICTURE,SX3->X3_TAMANHO,	SX3->X3_DECIMAL, cVld, SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		EndIf
		//Campo para informar NF eletronica (Somente Argentina)
		If cPaisLoc == "ARG"
	    	SX3->(MsSeek("F2_TPVENT"))
			cVld :=	LocX3Valid("F2_TPVENT")
			AAdd(aCposNF,{X3Titulo(),"F2_TPVENT",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			SX3->(MsSeek("F2_FECDSE"))
			cVld :=	LocX3Valid("F2_FECDSE")
			AAdd(aCposNF,{X3Titulo(),"F2_FECDSE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			SX3->(MsSeek("F2_FECHSE"))
			cVld :=	LocX3Valid("F2_FECHSE")
			AAdd(aCposNF,{X3Titulo(),"F2_FECHSE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			SX3->(MsSeek("F2_TRANSP"))
			cVld :=	LocX3Valid("F2_TRANSP")
			AAdd(aCposNF,{X3Titulo(),"F2_TRANSP",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
		EndIf
		If cPaisLoc <> "RUS"
			AAdd(aCposNF,{,"F2_REFMOED"  ,,,,"LocXVal('F2_REFMOED')",,,,,,,,,"LocXVal('F2_REFMOED')",,,,,.T.,aMoedas,{|x| x:nAt}})
			cVld	:=	LocX3Valid("F2_REFTAXA")
			cVld	+=	IIf(!Empty(cVld)," .AND. "," ") + "LocXVal('F2_REFTAXA')"
			AAdd(aCposNF,{,"F2_REFTAXA",,,,cVld})
		EndIf
		If cPaisLoc == "PAR" .And. StrZero(aCfgNf[SnTipo],2) == "01" .And. SF2->(ColumnPos("F2_TIPNOTA")) > 0
			SX3->(MsSeek("F2_TIPNOTA"))
			cVld := IIF(FindFunction("ValTpDocPer"),"ValTpDocPer()",LocX3Valid("F2_TIPNOTA"))
			AAdd(aCposNF,{,"F2_TIPNOTA"})
		Endif
		If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. aCfgNF[SlFormProp]
			SX3->(MsSeek("F2_EMCAEE"))
			AAdd(aCposNF,{X3Titulo(),"F2_EMCAEE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,".F."})
		    SX3->(MsSeek("F2_CAEE"))
			AAdd(aCposNF,{X3Titulo(),"F2_CAEE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,".F."})
		EndIf
		If cPaisLoc == "EQU"
			If FindFunction("LxCposEqu")
				LxCposEqu(@aCposNF, cFunName, aCfgNf)
			EndIf
		EndIF
		If cPaisLoc=="PAR" .and. StrZero(aCfgNf[SnTipo],2)=="54" //Remision entre sucursales RTS
		  lRTSPAR:=.T.
		ENDIF
		If cPaisLoc $ "CHI|PER|COL|EQU|PAR" .and. StrZero(aCfgNf[SnTipo],2)$"10|02|04|01|50|19" .OR. lRTSPAR 	//Campos para transferencia electronica a signature
			If cPaisLoc $ "PER|COL|PAR|"
				If 	StrZero(aCfgNf[SnTipo],2)$"02|01|50|" .OR. lRTSPAR .Or. (cPaisLoc == "PER" .And. StrZero(aCfgNf[SnTipo],2) == "19")
					SX3->(MsSeek("F2_SERIE2"))
					AAdd(aCposNF,{X3Titulo(),"F2_SERIE2",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
				EndIF
				If cPaisLoc $ "COL|PER|PAR" .And. StrZero(aCfgNf[SnTipo],2)$"02"
					SX3->(MsSeek("F2_TIPREF"))
					AAdd(aCposNF,{X3Titulo(),"F2_TIPREF",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
				EndIF
				If cPaisLoc $ "PER|PAR" .and. StrZero(aCfgNf[SnTipo],2)$"01|50|19" .OR. lRTSPAR
					If cPaisLoc == "PER" .And. StrZero(aCfgNf[SnTipo],2) <> "19"
						SX3->(MsSeek("F2_NUMORC"))
						AAdd(aCposNF,{X3Titulo(),"F2_NUMORC",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
					EndIf
					SX3->(MsSeek("F2_TIPONF"))
					AAdd(aCposNF,{X3Titulo(),"F2_TIPONF",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
				EndIF
				If cPaisLoc == "COL" .and. StrZero(aCfgNf[SnTipo],2) == "01"
					If SF2->(ColumnPos( "F2_UUIDREL" )) > 0 .And. !Empty(GetMV("MV_PROVFE",,""))
						SX3->(MsSeek("F2_UUIDREL"))
						AAdd(aCposNF,{X3Titulo(),"F2_UUIDREL",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3VALID(),SX3->X3_USADO,SX3->X3_TIPO,"SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
					EndIf
				EndIf
			EndIf
			If StrZero(aCfgNf[SnTipo],2)$"01" .and. cPaisLoc $ "CHI"
				SX3->(MsSeek("F2_MODVEN"))
				AAdd(aCposNF,{X3Titulo(),"F2_MODVEN",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
			EndIf
			If 	StrZero(aCfgNf[SnTipo],2)$"02"
				If cPaisLoc == "CHI"
					SX3->(MsSeek("F2_TIPREF"))
					AAdd(aCposNF,{X3Titulo(),"F2_TIPREF",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
					SX3->(MsSeek("F2_ESPREF"))
					AAdd(aCposNF,{X3Titulo(),"F2_ESPREF",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
				EndIF
				SX3->(MsSeek("F2_NFREF"))
				AAdd(aCposNF,{X3Titulo(),"F2_NFREF",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
				SX3->(MsSeek("F2_SERREF"))
				AAdd(aCposNF,{X3Titulo(),"F2_SERREF",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
			EndIf
			If StrZero(aCfgNf[SnTipo],2)$"02|04"
				SX3->(MsSeek("F2_MOTIVO"))
				AAdd(aCposNF,{X3Titulo(),"F2_MOTIVO",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
			EndIF
			If cPaisLoc == "PAR"
				If StrZero(aCfgNf[SnTipo],2)$"50|54"
					SX3->(MsSeek("F2_MOTEMIR"))
					AAdd(aCposNF,{X3Titulo(),"F2_MOTEMIR",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
				EndIf
				If StrZero(aCfgNf[SnTipo],2)$"01"
					SX3->(MsSeek("F2_TPTRANS"))
					AAdd(aCposNF,{X3Titulo(),"F2_TPTRANS",	X3_PICTURE,	X3_TAMANHO,	X3_DECIMAL, LocX3VALID(), X3_USADO,X3_TIPO, X3_ARQUIVO, X3_CONTEXT,,,,,,,})
				EndIf
			EndIF
		EndIf
		If cPaisLoc == "VEN" .and. StrZero(aCfgNf[SnTipo],2) $ "03|07"
			SX3->(MsSeek("F2_NUMAUT"))
			AAdd(aCposNF,{X3Titulo(),"F2_NUMAUT",X3_PICTURE,X3_TAMANHO,X3_DECIMAL,LocX3VALID(),X3_USADO,X3_TIPO,X3_ARQUIVO,X3_CONTEXT,,,,,,,})
		EndIf
		// Campo Observacao Rep. Dom. e Australia
		If cPaisLoc $ "DOM|AUS" .AND. StrZero(aCfgNf[SnTipo],2) $ "02|03"
			AAdd(aCposNF,{,"F2_OBS",,,,,,"M",,,,,,,,,})
		EndIf
		If cPaisLoc == "COS"
			AAdd(aCposNF,{,"F2_OBS",,,,,,"M",,,,,,,,,})
		EndIf
			If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND.  aCfgNF[SlFormProp]
				SX3->(MsSeek("F2_IDIOMA"))
				cVld := LocX3Valid("F2_IDIOMA")
				AAdd(aCposNF,{X3Titulo(),"F2_IDIOMA",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, X3_USADO,X3_TIPO, "SF2", X3_CONTEXT,,,,,,X3_F3})
			Endif
			If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND.  aCfgNF[SlFormProp]
				SX3->(MsSeek("F2_INCOTER"))
				cVld := LocX3Valid("F2_INCOTER")
				AAdd(aCposNF,{X3Titulo(),"F2_INCOTER",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, X3_USADO,X3_TIPO, "SF2", X3_CONTEXT,,,,,,X3_F3})
			Endif
			If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. aCfgNF[SlFormProp] .And. !Strzero(aCfgNF[SnTipo],2)$"02|04"
				SX3->(MsSeek("F2_PERMISS"))
				cVld := LocX3Valid("F2_PERMISS")
				AAdd(aCposNF,{X3Titulo(),"F2_PERMISS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, X3_USADO,X3_TIPO, "SF2", X3_CONTEXT,,,,,,X3_F3})
			Endif
			If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. aCfgNF[SlFormProp]
				SX3->(MsSeek("F2_PAISENT"))
				cVld := LocX3Valid("F2_PAISENT")
				AAdd(aCposNF,{X3Titulo(),"F2_PAISENT",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, X3_USADO,X3_TIPO, "SF2", X3_CONTEXT,,,,,,X3_F3})
			Endif
			If cPaisLoc == "ARG" .AND. !aCfgNf[SlRemito] .AND. aCfgNF[SlFormProp] .AND. SF2->(FieldPos('F2_NFEXPOR')) >0
				SX3->(MsSeek("F2_NFEXPOR"))
				cVld := LocX3Valid("F2_NFEXPOR")
				AAdd(aCposNF,{X3Titulo(),"F2_NFEXPOR",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld, X3_USADO,X3_TIPO, "SF2", X3_CONTEXT,,,,,,X3_F3})
			Endif
			If cPaisLoc == "ARG"
				SX3->(MsSeek("F2_ADIC5"))
				cVld :=	LocX3Valid("F2_ADIC5")
				AAdd(aCposNF,{X3Titulo(),"F2_ADIC5",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				SX3->(MsSeek("F2_ADIC61"))
				cVld :=	LocX3Valid("F2_ADIC61")
				AAdd(aCposNF,{X3Titulo(),"F2_ADIC61",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				SX3->(MsSeek("F2_ADIC62"))
				cVld :=	LocX3Valid("F2_ADIC62")
				AAdd(aCposNF,{X3Titulo(),"F2_ADIC62",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				SX3->(MsSeek("F2_ADIC7"))
				cVld :=	LocX3Valid("F2_ADIC7")
				AAdd(aCposNF,{X3Titulo(),"F2_ADIC7",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				If SF2->(ColumnPos( "F2_CANJE" )) > 0
					SX3->(MsSeek("F2_CANJE"))
					cVld :=	LocX3Valid("F2_CANJE")
					AAdd(aCposNF,{X3Titulo(),"F2_CANJE",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				EndIf
			EndIf
			If cPaisLoc == "ARG" .AND. SF2->(ColumnPos('F2_MODCONS')) > 0 .AND. SF2->(ColumnPos('F2_CODAUT')) > 0 .And. SF2->(ColumnPos('F2_VALCONS')) > 0 .and. aCfgNf[SAliasHead] == "SF2" .And. (Alltrim(aCfgNf[ScEspecie]) $ "NCP")
				SX3->(MsSeek("F2_MODCONS"))
				cVld :=	LocX3Valid("F2_MODCONS")
				aAdd(aCposNF,{X3Titulo(),"F2_MODCONS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				SX3->(MsSeek("F2_CODAUT"))
				cVld :=	LocX3Valid("F2_CODAUT")
				AAdd(aCposNF,{X3Titulo(),"F2_CODAUT",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
				SX3->(MsSeek("F2_VALCONS"))
				cVld :=	"Afipcons()"
				AAdd(aCposNF,{X3Titulo(),"F2_VALCONS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			Endif
			If cPaisLoc == "ARG" .And. aCfgNf[SAliasHead] == "SF2" .And. SF2->(ColumnPos("F2_TPAJUS")) >0 .And. (Alltrim(aCfgNf[ScEspecie]) $ "NDC|NCP|NDI")
				SX3->(MsSeek("F2_TPAJUS"))
				cVld := LocX3Valid("F2_TPAJUS")
				AAdd(aCposNF,{X3Titulo(),"F2_TPAJUS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			Endif
			If cPaisLoc == "ARG" .And. aCfgNf[SAliasHead] == "SF2" .And. SF2->(ColumnPos("F2_RECPOS")) >0 .And. (Alltrim(aCfgNf[ScEspecie]) $ "NDC")
				SX3->(MsSeek("F2_RECPOS"))
				cVld := LocX3Valid("F2_RECPOS")
				AAdd(aCposNF,{X3Titulo(),"F2_RECPOS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			Endif
			If cPaisLoc == "ARG" .And. aCfgNf[SAliasHead] == "SF2" .And. SF2->(ColumnPos("F2_IVAPOS")) >0 .And. (Alltrim(aCfgNf[ScEspecie]) $ "NDC")
				SX3->(MsSeek("F2_IVAPOS"))
				cVld := LocX3Valid("F2_IVAPOS")
				AAdd(aCposNF,{X3Titulo(),"F2_IVAPOS",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL, cVld,SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,,,,,,SX3->X3_F3})
			Endif
			If cPaisLoc == "PAR" .And. aCfgNf[SAliasHead] == "SF2" .AND. (AllTrim(FunName())=="MATA466N" .OR. IsBlind())
				If SF2->(FieldPos("F2_DOCEL"))>0
					If  (Alltrim(aCfgNf[ScEspecie]) == "NCP")
						SX3->(MsSeek("F2_DOCEL"))
						AAdd(aCposNF,{X3Titulo(),"F2_DOCEL",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid("F2_DOCEL"),SX3->X3_USADO,SX3->X3_TIPO, "SF2",SX3->X3_CONTEXT,IIF(__nOpcx==3,"2",SF2->F2_DOCEL),,,,,SX3->X3_F3,".T."})
					ENDIF
				ENDIF
			ENDIF
			If !(lInclui)
				cNFiscal	:=	SF2->F2_DOC
				cSerie 		:=	SF2->F2_SERIE
				nTaxa		:=	SF2->F2_TXMOEDA
				nMoedaNF	:=	SF2->F2_MOEDA
			Endif
	OtherWise
		aCfgNF	:=	aClone(aBKPCfgNF)
		NFSetPrv(aCfgNF)
		SetKey(VK_F12,bSavF12)
		Return .F.
EndCase
cFldConf := IIF(LocxVlCon(lDeleta),",'"+ STR0352 + "'" ,"") //"Conferência Física"
aPosFold[3] := aSizeAut[3]
AAdd(aObjsNF,{"oFldRodape","TFolder():New("+Str(aPosFold[1])+","+Str(aPosFold[2])+",{'" + STR0026 + "','" + STR0027 + "','" + STR0028 + "','" + STR0029 + "','" + STR0030  + "','" + STR0031 + "'" + IIf(aCfgNF[SnTipo] == 10, ",'" + STR0130 + "'","") + cFldConf + "},{'HEADER'},,,,,.T.,.F.,"+Str(aPosFold[3])+","+Str(aPosFold[4])+",)",1}) //'Totais'###'Inf. Fornec./Cliente'###'Despesas'###'Duplicatas'###'Livros Fiscais'###'Impostos'###'Caixinha'###'Conferência Física'
AAdd(aObjsNF,{"aoSbx"     ,"Array(8)",1})
AAdd(aObjsNF,{"aoSbx[1]"  ,"TScrollBox():New(oFldRodape:aDialogs[1], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"Aux"       ,"aoSbx[1]:Disable()",1})
AAdd(aObjsNF,{"oBSomaItens","TotalQtd(aoSbx[1],{04,203,270,37})" ,1})//Browse de totalizacao
AAdd(aObjsNF,{"aoSbx[2]"  ,"TScrollBox():New(oFldRodape:aDialogs[2], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"aoSbx[3]"  ,"TScrollBox():New(oFldRodape:aDialogs[3], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"aoSbx[4]"  ,"TScrollBox():New(oFldRodape:aDialogs[4], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"aoSbx[5]"  ,"TScrollBox():New(oFldRodape:aDialogs[5], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
AAdd(aObjsNF,{"aoSbx[6]"  ,"TScrollBox():New(oFldRodape:aDialogs[6], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
If aCfgNF[SnTipo] == 10
	AAdd(aObjsNF,{"aoSbx[7]"  ,"TScrollBox():New(oFldRodape:aDialogs[7], 000,000,61,313,.T.,.T.,.F.)",1})
	If LocxVlCon(lDeleta)
		AAdd(aObjsNF,{"aoSbx[8]"  ,"TScrollBox():New(oFldRodape:aDialogs[8], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
	Endif
Else
	If LocxVlCon(lDeleta)
		AAdd(aObjsNF,{"aoSbx[7]"  ,"TScrollBox():New(oFldRodape:aDialogs[7], 000,000,61,"+Str(aPosFold[3]-10)+",.T.,.T.,.F.)",1})
	Endif
EndIf
AAdd(aObjsNF,{"oLine1"	   ,"TGroup():New(43,4,44,"+Str(aPosFold[3]-16)+",'',aoSbx[1],,,.T.)",1})
AAdd(aObjsNF,{"oLine2"	   ,"TGroup():New(43,4,44,"+Str(aPosFold[3]-16)+",'',aoSbx[3],,,.T.)",1})

//³Aarray de configuracoes do Rodape³
//#PORTUGAL#
//If cPaisLoc <> "PTG"
	AAdd(aCposRodape,{,cP3+"DESPESA",,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_DESPESA')" ,),,,"aoSbx[1]",,,".F.",005,040})
	AAdd(aCposRodape,{,cP3+"DESCONT",,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_DESCONTO')",),,,"aoSbx[1]",,,".F.",005,140})
	AAdd(aCposRodape,{,cP3+"FRETE"  ,,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_FRETE')"   ,),,,"aoSbx[1]",,,".F.",018,040})
	AAdd(aCposRodape,{,cP3+"SEGURO" ,,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_SEGURO')"  ,),,,"aoSbx[1]",,,".F.",018,140})
	If cPaisLoc $ "MEX|PER"
		AAdd(aCposRodape,{,cP3+"VALADI"  ,,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_ADIANT')"   ,),,,"aoSbx[1]",,,".F.",031,040}) //Adiantamento
	EndIf
	If cPaisLoc == "ARG" .And. cTipo == "D" .And. GetNewPar('MV_DESCSAI','1') =='2' .And. ALLTRIM(SF1->F1_ESPECIE) $ "RFD"
		AAdd(aCposRodape,{,cP3+"VALMERC",,12,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_VALMERC')" ,IIf(cDescSai=='2' .And. aCfgNF[SAliasHead]=="SF1",IIF (INCLUI, "MaFisRet(,'NF_VALMERC')+MaFisRet(,'NF_DESCONTO')","SF1->F1_VALMERC + SF1->F1_DESCONT"), ) ),,,"aoSbx[1]",,,".F.",031,140})
	else
		AAdd(aCposRodape,{,cP3+"VALMERC",,12,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_VALMERC')" ,IIf(cDescSai=='2' .And. aCfgNF[SAliasHead]=="SF2",IIF (INCLUI, "MaFisRet(,'NF_VALMERC')+MaFisRet(,'NF_DESCONTO')","SF2->F2_VALMERC + SF2->F2_DESCONT"), ) ),,,"aoSbx[1]",,,".F.",031,140})
	EndIF
	If cPaisLoc == "CHI"
		AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. lVisualiza .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"Round(MaFisRet(,'NF_TOTAL'),"+"MsDecimais( IIf(Type('nMoedaNF')=='N',nMoedaNF,1) )"+")"   ,),,,"aoSbx[1]",,,".F.",047,140})
	ElseIf cPaisLoc == "ARG"
		AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. (aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_TOTAL')" ,),,,"aoSbx[1]",,,".F.",047,140})
	ElseIf cPaisLoc $ "MEX|COL|PER"
		If cFunName $ "MATA101N|MATA102N|MATA466N|MATA462DN|MATA465N"
			AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. lVisualiza .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),IIf((aCfgNf[SAliasHead] == "SF1" .And. aCfgNf[SAliasCols] == "SD1") .And. cDescSai=='1' .and. !(cFunName $ "MATA101N|MATA466N") .and. !(aCfgNf[ScEspecie]$"NCC|RFD")	, "MaFisRet(,'NF_TOTAL')+MaFisRet(,'NF_DESCONTO')", IIf(lVisualiza, "", "MaFisRet(,'NF_TOTAL')")),),,,"aoSbx[1]",,,".F.",047,140})
		Else
			AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. lVisualiza .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),IIf((aCfgNf[SAliasHead] == "SF1" .And. aCfgNf[SAliasCols] == "SD1") .And. cDescSai=='1' .and. !(aCfgNf[ScEspecie]$"NCC"), "MaFisRet(,'NF_TOTAL')+MaFisRet(,'NF_DESCONTO')", IIf(lVisualiza, "", "MaFisRet(,'NF_TOTAL')")),),,,"aoSbx[1]",,,".F.",047,140})
		EndIf
	ElseIf cPaisLoc $ "PAR|BOL|URU"
		AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. (aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_TOTAL')" ,),,,"aoSbx[1]",,,".F.",047,140})
	Else
		AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR. lVisualiza .OR.(aCfgNF[SAliasHead] == "SF1" .AND. Empty(&(aCfgNF[SAliasHead] + "->" + cP3 + "STATUS"))), IIf((aCfgNf[SAliasHead] == "SF1" .And. aCfgNf[SAliasCols] == "SD1") .And. cDescSai == '1' .and. !(aCfgNf[ScEspecie] $ "NCC") .And. !(FunName() $ "MATA101N|MATA466N"), "MaFisRet(,'NF_TOTAL')+MaFisRet(,'NF_DESCONTO')", "MaFisRet(,'NF_TOTAL')"),),,,"aoSbx[1]",,,".F.",047,140})
	EndIf
	If cPaisLoc	== "RUS"
		AAdd(aCposRodape,{,cP3+"VLMERCM",,16,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_VALMERC_C1')" ,IIf(cDescSai=='2' .And. aCfgNF[SAliasHead]=="SF2",IIF (INCLUI, "MaFisRet(,'NF_VALMERC_C1')+MaFisRet(,'NF_DESCONTO')","SF2->F2_VALMERC_C1 + SF2->F2_DESCONT"), ) ),,,"aoSbx[1]",,,".F.",047,440})
		AAdd(aCposRodape,{,cP3+"BSIMP1M",,16,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_BASEIV1_C1')" ,),,,"aoSbx[1]",,,".F.",047,570})
		AAdd(aCposRodape,{,cP3+"VLIMP1M",,16,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_VALIV1_C1')" ,),,,"aoSbx[1]",,,".F.",047,700})
		AAdd(aCposRodape,{,cP3+"VLBRUTM",,16,,,,,,,IIf(lInclui .OR. l103Class .OR. (aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_TOTAL_C1')" ,),,,"aoSbx[1]",,,".F.",047,830})
	EndIf
//#PORTUGAL#
/*Else
	AAdd(aCposRodape,{,cP3+"DESCONT",,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_DESCONTO')",),,,"aoSbx[1]",,,".F.",005,040})
	AAdd(aCposRodape,{,cP3+"DESPESA",,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_DESPESA')" ,),,,"aoSbx[1]",,,".F.",005,140})
	AAdd(aCposRodape,{,cP3+"DESNTRB",,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_DESNTRB')" ,),,,"aoSbx[1]",,,".F.",018,040})
	AAdd(aCposRodape,{,cP3+"FRETE"  ,,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_FRETE')"   ,),,,"aoSbx[1]",,,".F.",018,140})
	AAdd(aCposRodape,{,cP3+"TARA"   ,,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_TARA')"    ,),,,"aoSbx[1]",,,".F.",031,040})
	AAdd(aCposRodape,{,cP3+"SEGURO" ,,12,,,,,,,IIf(lInclui,"MaFisRet(,'NF_SEGURO')"  ,),,,"aoSbx[1]",,,".F.",031,140})
	AAdd(aCposRodape,{,cP3+"VALMERC",,12,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_VALMERC')" ,),,,"aoSbx[1]",,,".F.",047,040})
	AAdd(aCposRodape,{,cP3+"VALBRUT",,12,,,,,,,IIf(lInclui .OR. l103Class .OR.(aCfgNF[SAliasHead]=="SF1" .AND.Empty(&(aCfgNF[SAliasHead] +"->"+cP3+"STATUS"))),"MaFisRet(,'NF_TOTAL')"   ,),,,"aoSbx[1]",,,".F.",047,140})
Endif*/
SX3->(dbSetOrder(2))
SX3->(MsSeek(Right(aCfgNF[SAliasCols],2)+"_QUANT"))
AAdd(aCposRodape,{RetTitle("B1_QTDACUM"),"nTotQtIte",PesqPict("SD1","D1_QUANT"),SX3->X3_TAMANHO,SX3->X3_DECIMAL,,,SX3->X3_TIPO,SX3->X3_ARQUIVO,,,,,"aoSbx[1]",,,".F.",047,253,,,,{||0}}) //Get do total de itens
//³Inf.Fornec./Cliente ³
If cPaisLoc == "RUS"
	cCont := "Posicione('" + aCfgNf[ScCliFor] + "',1,xFilial('" + aCfgNf[ScCliFor] + "') + M->" + IIf(aCfgNf[SAliasHead]=="SF2","F2_CLIENTE","F1_FORNECE") + " + M->" + cP3 + "LOJA,'"
	AAdd(aCposRodape,{,cP1+"NREDUZ"   ,,59,,,,,,,cCont + cP1 + "NREDUZ')"  ,,,"aoSbx[2]",,,".F.",005,040})
	AAdd(aCposRodape,{,cP1+"TEL"    ,,14,,,,,,,cCont + cP1 + "TEL')"   ,,,"aoSbx[2]",,,".F.",031,040})
	AAdd(aCposRodape,{,cP1+"PRICOM" ,,07,,,,,,,cCont + cP1 + "PRICOM')",,,"aoSbx[2]",,,".F.",044,150})
	AAdd(aCposRodape,{,cP1+"ULTCOM" ,,07,,,,,,,cCont + cP1 + "ULTCOM')",,,"aoSbx[2]",,,".F.",044,263})
	AAdd(aCposRodape,{,cP1+"EST"    ,,10,,,,,,,cCont + cP1 + "EST')"   ,,,"aoSbx[2]",,,".F.",005,375})
	If aCfgNf[ScCliFor] == 'SA2' .Or. aCfgNf[ScCliFor] == 'SA1'
		If aCfgNf[ScCliFor] == 'SA2'
			AAdd(aCposRodape,{,cP1+"KPP"    ,,10,,,,,,,cCont + cP1 + "KPP')"   ,,,"aoSbx[2]",,,".F.",031,263})
			AAdd(aCposRodape,{STR0395,cP1+"HEAD"    ,,10,,,,,,,"RUXXTS01('HEAD',cP1)" ,,,"aoSbx[2]",,,".F.",018,375})
			AAdd(aCposRodape,{STR0396,cP1+"HEADUN"    ,,10,,,,,,,"RUXXTS01('HEADUN',cP1)" ,,,"aoSbx[2]",,,".F.",031,375})
		Else // SA1
			AAdd(aCposRodape,{,cP1+"INSCGAN"    ,,10,,,,,,,cCont + cP1 + "INSCGAN')"   ,,,"aoSbx[2]",,,".F.",031,263})
			AAdd(aCposRodape,{STR0395,"AI0_HEAD"    ,,10,,,,,,,"RUXXTS01('HEAD',cP1)" ,,,"aoSbx[2]",,,".F.",018,375})
			AAdd(aCposRodape,{STR0396,"AI0_HEADUN"    ,,10,,,,,,,"RUXXTS01('HEADUN',cP1)" ,,,"aoSbx[2]",,,".F.",031,375})
		EndIf
		AAdd(aCposRodape,{STR0392,"AGA_END"    ,,60,,,,,,,"RUXXTS03('2',cP1,aCfgNf[2])" ,,,"aoSbx[2]",,,".F.",005,470})
		AAdd(aCposRodape,{STR0393,"AGA_END"    ,,60,,,,,,,"RUXXTS03('0',cP1,aCfgNf[2])" ,,,"aoSbx[2]",,,".F.",018,470})
		AAdd(aCposRodape,{,cP1+"CODZON"    ,,14,,,,,,,cCont + cP1 + "CODZON')"   ,,,"aoSbx[2]",,,".F.",031,150})
		AAdd(aCposRodape,{STR0394,cP1+"NREDUZ"    ,,59,,,,,,,"RUXXTS02(cP1,aCfgNf[2])" ,,,"aoSbx[2]",,,".F.",018,040})
	Else
		AAdd(aCposRodape,{,cP1+"CGC"    ,,14,,,,,,,cCont + cP1 + "CGC')"   ,,,"aoSbx[2]",,,".F.",018,235})
		AAdd(aCposRodape,{,cP1+"END"    ,,31,,,,,,,cCont + cP1 + "END')"   ,,,"aoSbx[2]",,,".F.",031,235})
	EndIf
Else
	cCont := "Posicione('" + aCfgNf[ScCliFor] + "',1,xFilial('" + aCfgNf[ScCliFor] + "') + M->" + IIf(aCfgNf[SAliasHead]=="SF2","F2_CLIENTE","F1_FORNECE") + " + M->" + cP3 + "LOJA,'"
	AAdd(aCposRodape,{,cP1+"NOME"   ,,31,,,,,,,cCont + cP1 + "NOME')"  ,,,"aoSbx[2]",,,".F.",005,040})
	AAdd(aCposRodape,{,cP1+"TEL"    ,,14,,,,,,,cCont + cP1 + "TEL')"   ,,,"aoSbx[2]",,,".F.",005,235})
	AAdd(aCposRodape,{,cP1+"PRICOM" ,,07,,,,,,,cCont + cP1 + "PRICOM')",,,"aoSbx[2]",,,".F.",018,040})
	AAdd(aCposRodape,{,cP1+"ULTCOM" ,,07,,,,,,,cCont + cP1 + "ULTCOM')",,,"aoSbx[2]",,,".F.",018,136})
	AAdd(aCposRodape,{,cP1+"CGC"    ,,14,,,,,,,cCont + cP1 + "CGC')"   ,,,"aoSbx[2]",,,".F.",018,235})
	AAdd(aCposRodape,{,cP1+"END"    ,,31,,,,,,,cCont + cP1 + "END')"   ,,,"aoSbx[2]",,,".F.",031,040})
	AAdd(aCposRodape,{,cP1+"EST"    ,,10,,,,,,,cCont + cP1 + "EST')"   ,,,"aoSbx[2]",,,".F.",031,235})
EndIf
If aCfgNf[ScCliFor] ==	'SA1'
	AAdd(aObjsNF	 ,{"oBtnFin"	   ,"TButton():New(43,36,'"+STR0144+"',aoSbx[2],{|| LocxFc010() },48,12,,,,.T.,,,,{||!Empty("+aCfgNf[ScCliFor]+"->"+cP1+"NOME)} )",1})
Else
	AAdd(aObjsNF	 ,{"oBtnFin"	   ,"TButton():New(43,36,'"+STR0144+"',aoSbx[2],{|| A103TOFC030(IIf('"+cTipo+"'$'DB','S','E')) },48,12,,,,.T.,,,,{|| !Empty("+aCfgNf[ScCliFor]+"->"+cP1+"NOME)})",1})
Endif
//³Folder de Desp.Acessorias ³Permete os campos de Desp.Acessorias sejam preenchidos caso nao seja Fat.Frete ou Despesa
//#PORTUGAL#
//If cPaisLoc <> "PTG"
	AAdd(aCposRodape,{,cP3+"DESPESA",,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_DESPESA' ,M->"+cP3+"DESPESA)",,,,,IIf(lInclui,"MaFisRet(,'NF_DESPESA')",),,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),005,045,,,If(lInclui,&("{|| M->"+cP3+"DESPESA := MaFisRet(,'NF_DESPESA')}"),)})
	AAdd(aCposRodape,{,cP3+"DESCONT",,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_DESCONTO',M->"+cP3+"DESCONT)",,,,,IIf(lInclui,"MaFisRet(,'NF_DESCONTO')",),,,"aoSbx[3]",,,,005,200,,,If(lInclui,&("{|| M->"+cP3+"DESCONT := MaFisRet(,'NF_DESCONTO')}"),)})
	AAdd(aCposRodape,{,cP3+"FRETE"  ,,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_FRETE'   ,M->"+cP3+"FRETE)"  ,,,,,IIf(lInclui,"MaFisRet(,'NF_FRETE')"   ,),,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),018,045,,,If(lInclui,&("{|| M->"+cP3+"FRETE := MaFisRet(,'NF_FRETE')}"),)})
	AAdd(aCposRodape,{,cP3+"SEGURO" ,,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_SEGURO'  ,M->"+cP3+"SEGURO)" ,,,,,IIf(lInclui,"MaFisRet(,'NF_SEGURO')"  ,),,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),018,200,,,If(lInclui,&("{|| M->"+cP3+"SEGURO := MaFisRet(,'NF_SEGURO')}"),)})
//#PORTUGAL#
/*Else
	AAdd(aCposRodape,{,cP3+"DESCONT",,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_DESCONTO',M->"+cP3+"DESCONT)",,,,,IIf(lInclui,"MaFisRet(,'NF_DESCONTO')",),,,"aoSbx[3]",,,,005,045,,,If(lInclui,&("{|| M->"+cP3+"DESCONT := MaFisRet(,'NF_DESCONTO')}"),)})
	AAdd(aCposRodape,{,cP3+"DESPESA",,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_DESPESA' ,M->"+cP3+"DESPESA)",,,,,IIf(lInclui,"MaFisRet(,'NF_DESPESA')",),,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),005,200,,,If(lInclui,&("{|| M->"+cP3+"DESPESA := MaFisRet(,'NF_DESPESA')}"),)})
	AAdd(aCposRodape,{,cP3+"DESNTRB",,12,,"LxA103VFold('NF_DESNTRB' ,M->"+cP3+"DESNTRB)",,,,,,,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),018,045})
	AAdd(aCposRodape,{,cP3+"FRETE"  ,,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_FRETE'   ,M->"+cP3+"FRETE)"  ,,,,,IIf(lInclui,"MaFisRet(,'NF_FRETE')"   ,),,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),018,200,,,If(lInclui,&("{|| M->"+cP3+"FRETE := MaFisRet(,'NF_FRETE')}"),)})
	AAdd(aCposRodape,{,cP3+"SEGURO" ,,12,,"(Vazio().OR.Positivo()).AND.LxA103VFold('NF_SEGURO'  ,M->"+cP3+"SEGURO)" ,,,,,IIf(lInclui,"MaFisRet(,'NF_SEGURO')"  ,),,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),031,045,,,If(lInclui,&("{|| M->"+cP3+"SEGURO := MaFisRet(,'NF_SEGURO')}"),)})
	AAdd(aCposRodape,{,cP3+"TARA"   ,,12,,"LxA103VFold('NF_TARA'    ,M->"+cP3+"TARA)"   ,,,,,,,,"aoSbx[3]",,,Iif(aCfgNF[SlConFrDp][1].OR.aCfgNF[SlConFrDp][2],".F.",".T."),031,200})
Endif*/
SX3->(MsSeek(cP3+"VALBRUT"))
//#PORTUGAL#
//If cPaisLoc <> "PTG"
	cTotFolder3:="M->"+cP3+"FRETE"+"+"+"M->"+cP3+"SEGURO"+"+"+"M->"+cP3+"DESPESA"
//#PORTUGAL#
/*Else
	cTotFolder3:="M->"+cP3+"FRETE"+"+"+"M->"+cP3+"SEGURO"+"+"+"M->"+cP3+"DESPESA"+"+"+"M->"+cP3+"DESNTRB"+"+"+"M->"+cP3+"TARA"
Endif*/
AAdd(aCposRodape,{STR0032,"nTOTDesp",SX3->X3_PICTURE,12,SX3->X3_DECIMAL,LocX3VALID(),SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT,cTotFolder3,,,"aoSbx[3]",,,".F.",047,200}) //"Total"
//³Dados Financeiros³
cCondicao := CriaVar(cP3+"COND")
cNatureza := CriaVar(cP3+"NATUREZ")
If !Empty(aCfgNf[ScOpFin])
	AAdd(aObjsNF,{"xAux"	,"IIF(l103Visual,AtuDadosFin('" + aCfgNf[ScAliasFin] + "','" + aCfgNf[SAliasHead] + "'),)",3 })
Endif
If l103Class
	AAdd(aObjsNF,{"oLstFin"	,"LxA103Financ(@cCondicao,aoSbx[4],lEICFinanc,aRecSE2,215,!lEICFinanc,aRecSE1,"+If(lInclui,".T.",".F.")+",'"+aCfgNf[ScAliasFin]+"')" ,1})
Else
	AAdd(aObjsNF,{"oLstFin"	,"LxA103Financ(@cCondicao,aoSbx[4],l103Visual,aRecSE2,215,!l103Visual,aRecSE1,"+If(lInclui,".T.",".F.")+",'"+aCfgNf[ScAliasFin]+"')" ,1})
Endif
If lLocxAuto
	//³Estes dois campos são os unicos montados em outra função, e com nome de        ³
	//³variável ao invés de nopme de CAMPO, por isto que a aAutoCab deve ser adaptada ³
	//³para guardar os valores nas variáveis cCondicao e cNaturez.                    ³
	//³Se mudar esta validação, também deve mudar a a chamada a ela na LxA103Financ() ³
	cNatureza	:=	""
	Aadd(aCposRodape,{'',"cCondicao",,,,"Vazio().OR.(LxA103Cond(cCondicao) .AND.CheckSX3('F1_COND') .AND. Eval({|| LxA103Dupl(MaFisRet(,'NF_BASEDUP'),nMoedaCor,dDEmissao,cCondicao,,,,,,,@M->cNatureza),.T.}))"})
	Aadd(aCposRodape,{'',"cNatureza",,,,"Vazio().OR.(ExistCpo('SED') .AND. LxA103VFold('NF_NATUREZA',&(ReadVar())))"})
	nPos	:=	Ascan(aAutoCab,{|x| Alltrim(x[1]) == cP3+"COND" } )
	If nPos > 0
		aAutoCab[nPos][1]	:=	"cCondicao"
	Endif
	//Russia - ULCD we need keep the same Naturez form original document for credit and debit invoice || manter a mesma natureza do F2_NATUREZ, para nota de crédito via ExecAuto
	If !(cPaisLoc=='RUS' .and. FunName() $ 'MATA467N|MATA465N|RU05D01')
	nPos	:=	Ascan(aAutoCab,{|x| x[1] == cP3+"NATUREZ" } )
		If nPos > 0
			IF (FwIsInCallStack("MATA143") .and. cPaisLoc == "CHI") .or. (cPaisLoc == "URU")
				Aadd(aAutoCab,{aAutoCab[nPos][1],aAutoCab[nPos][2],})
				aAutoCab[nPos][1]	:=	"cNatureza"
			Else
				aAutoCab[nPos][1]	:=	"cNatureza"
			EndIF
		Endif
	Endif
Endif
// Folder de Livros Fiscais
AAdd(aObjsNF,{"oLstSF3"	,"MaFisBrwLivro(aoSbx[5],{003,005,"+Str(aPosFold[3]-15)+",55},.T.,Nil,l103Visual)",1})
aImp := MaFisRelImp('MT100',{aCfgNf[SAliasHead],aCfgNf[SAliasCols]})
aImp1 := MaFisRelImp('MT100',{aCfgNf[SAliasHead],aCfgNf[SAliasCols]})
AAdd(aObjsNF,{"Aux"    ,"MaFisIni('      ','  ',IIf('"+aCfgNf[ScCliFor]+"'=='SA1','C','F'),cTipo,Nil,aImp,,.F.,,,'"+StrZero(aCfgNF[SnTipo],2)+"','"+IIf(cPaisLoc == "RUS",aCfgNF[ScEspecie],"")+"')",3})
// Folder de Impostos
AAdd(aObjsNF,{"oLstImp"	,"MaFisRodape(2,aoSbx[6],,{003,005,"+Str(aPosFold[3]-15)+",55},{|| (MaFisToCols(aHeader,aCols,,'"+iif(aCfgNf[SAliasHead]=="SF2","MT460","MT100")+"')),Eval(bRefresh),Eval(bGdRefresh)},"+If(lInclui,".F.",".T.")+",,,,,,,,,,,,," + Iif( lEditImp .and. INCLUI .and. !aCfgNf[SlFormProp] .and. AllTrim( aCfgNf[ScEspecie] ) $ 'NF|NCP|NDP|NDE|NCE', ".T.", ".F." ) + ")",1})
cAliasGrid:= aCfgNf[SAliasCols]
cWhileGrid:= "!" + aCfgNf[SAliasCols] + "->(EOF()) .AND. " + aCfgNf[SAliasCols] + "->" + cP4 + "FILIAL==XFilial('" + aCfgNf[SAliasCols] + "') .AND. !Empty(M->" + cP3 + "DOC) .AND. " + aCfgNf[SAliasCols] + "->" + cP4 + "DOC==M->" + cP3 + "DOC .AND. " + aCfgNf[SAliasCols] + "->" + cP4 + "SERIE==M->" + cP3 + "SERIE .AND. " + aCfgNf[SAliasCols] + "->" + IIF(cP4=="D1_","D1_FORNECE","D2_CLIENTE")+"==M->" + IIF(cP3=="F1_","F1_FORNECE","F2_CLIENTE")+" .AND. " + aCfgNf[SAliasCols] + "->" + cP4 + "LOJA==M->" + cP3 + "LOJA"
cSeekGrid := "xFilial('" + aCfgNf[SAliasCols] + "')+M->" + cP3 + "DOC+M->" + cP3 + "SERIE+M->" + IIF(cP3=="F1_","F1_FORNECE","F2_CLIENTE")+"+M->" + cP3 + "LOJA"
nIndGrid  := If(aCfgNf[SAliasHead]=="SF2",3,1)
// Conferência Física
If LocxVlCon(lDeleta) .And. aCfgNF[SAliasHead] == "SF1"
	If aCfgNF[SnTipo] == 10
		AAdd(aObjsNF,{"oLstFin"	,"LocxConf(aoSbx[8])" ,1})
	Else
		AAdd(aObjsNF,{"oLstFin"	,"LocxConf(aoSbx[7])" ,1})
	Endif
Endif
//³Dados do Caixinha³
If aCfgNF[SnTipo] == 10
	SX3->(DbSetOrder(2))
	SEU->(MsSeek("|||",.F.))
	SX3->(MsSeek("EU_CAIXA"))
	AAdd(aCposRodape,{X3Titulo(),"cCxCaixa",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_CAIXA") }  })
	SX3->(MsSeek("EU_VALOR"))
	If (cPaisLoc == "ARG" .OR. cPaisLoc == "BOL") .And. ALLTRIM(cEspecie) == "NF" .And. ALLTRIM(cFunName) == "MATA101N"
		cVld := "Vazio().OR.Positivo()"
	Else
		cVld := "Vazio().OR.Positivo() .AND. Fa560Valor(nCxValor,cCxCaixa,.F.)"
	EndIf
	If cPaisLoc == "CHI"
		AAdd(aCposRodape,{X3Titulo(),"nCxValor",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,,SX3->X3_TIPO,,,"nCxValor := Round(MaFisRet(,'NF_TOTAL'),"+"MsDecimais( IIf(Type('nMoedaNF')=='N',nMoedaNF,1) )"+")",,,"aoSbx[7]",,SX3->X3_F3,".F.",,,,,,{|| CriaVar("EU_VALOR") }  })
	Else
		AAdd(aCposRodape,{X3Titulo(),"nCxValor",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,cVld,,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_VALOR") }  })
	Endif
	SX3->(MsSeek("EU_BENEF"))
	AAdd(aCposRodape,{X3Titulo(),"cCxBenef",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_BENEF") }  })
	SX3->(MsSeek("EU_HISTOR"))
	AAdd(aCposRodape,{X3Titulo(),"cCxHistor",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_HISTOR") }  })
	SX3->(MsSeek("EU_NROADIA"))
	AAdd(aCposRodape,{X3Titulo(),"cCxAdian",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_NROADIA") }  })
	If SX3->(MsSeek("EU_NRREND"))
		AAdd(aCposRodape,{X3Titulo(),"cCxRendic",SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,LocX3Valid(),,SX3->X3_TIPO,,,,,,"aoSbx[7]",,SX3->X3_F3,,,,,,,{|| CriaVar("EU_NRREND") }  })
	Endif
EndIf
If ExistBlock("NFCPOSRODPE")
	For nX:=1 To len(aCposRodape)
		AAdd(aCposPE,{aCposRodape[nX][2],aCposRodape[nX][17]})
	Next
	aCposPE  := ExecBlock("NFCPOSRODPE",.F.,.F.,{aCposPE})
	If ValType(aCposPE) == "A" .AND. len(aCposRodape) == len(aCposPE) //NAO ESQUECE DE COLCOAR PRA ALTERAR SO PRA SIM, NAO DEIXA VLOTAR
		For nX:=1 To len(aCposRodape)
			aCposRodape[nX][17] := IiF(ValType(aCposPE[nX][2])=="C" .AND. aCposPE[nX][2]==".F.",".F.",aCposRodape[nX][17])
		Next
	EndIf
EndIf
//Tira os cpos amarracao c/pedido se o tipo de nota nao puder ser amarrado com o pedido
If !aCfgNf[SlPedido]
	aCposNo	:=	{'D1_ITEMPC','D1_PEDIDO','D2_ITEMPV','D2_PEDIDO' }
Endif
//Inclui os campos que sao exclusivos do remito.
If aCfgNf[SlRemito]
	aCpos  	:=	{'D2_GERANF','D2_LOCDEST','D2_AGREG'}
	Aadd(aCposNo,"D2_REMITO")
	Aadd(aCposNo,"D2_ITEMREM")
	Aadd(aCposNo,"D2_SERIREM")
	Aadd(aCposNo,"D1_REMITO")
	Aadd(aCposNo,"D1_ITEMREM")
	Aadd(aCposNo,"D1_SERIREM")
Endif
//Inclui os campos de integracao com o PMS
If IntePMS()
	AAdd(aCpos,'D2_PROJPMS')
	If aCfgNF[SnTipo]<>7 .AND. aCfgNF[SnTipo]<>22 .AND. aCfgNF[SnTipo]<>8
		AAdd(aCpos,'D2_EDTPMS')
	Else
		AAdd(aCposNo,'D2_EDTPMS')
	Endif
	AAdd(aCpos,'D2_TASKPMS')
Endif
If aCfgNf[SAliasCols] $ "SD1|SD2"
	If aCfgNf[SAliasCols] == "SD1"
		cCondIf := (aCfgNf[SAliasCols]+"->"+cP4+"FORMUL")+" == SF1->F1_FORMUL .AND. "
		cCondIf := cCondIf+(aCfgNf[SAliasCols]+"->"+cP4+"ESPECIE")+" == SF1->F1_ESPECIE"
	Else
		cCondIf := (aCfgNf[SAliasCols]+"->"+cP4+"FORMUL")+" == SF2->F2_FORMUL .AND. "
		cCondIf := cCondIf+(aCfgNf[SAliasCols]+"->"+cP4+"ESPECIE")+" == SF2->F2_ESPECIE"
	Endif
Endif
aParCols  := {cAliasGrid,cWhileGrid,cCondIf,,,cSeekGrid,nIndGrid,,aCposNo,aCposExt,{,"MT103PN"}}
If cPaisLoc == "MEX"  //Agregar campos MEX (Folio Fiscal, Timbre y Fecha)
	fCposNf2(@aCposNF, cFunName, aCfgNF[SAliasHead])
Endif
If cPaisLoc == "DOM".And. FindFunction("fCposF2Dom")//Agrega campos República Dominicana (Tipo de Comprobante Fiscal)
	fCposF2Dom(@aCposNF, cFunName)
EndIf
If cPaisLoc == "PER" //Agrega campos a encabezado para NF Peru
	fCposNfPer(@aCposNF, cFunName, aCfgNF[SAliasHead])
EndIf
If cPaisLoc == "COL" //Agrega campos a encabezado para NF Colombia
	LxCposCol(@aCposNF, cFunName, aCfgNF[SAliasHead])
EndIf
//Pto de Entrada para adicionar campo
cPe	:=	LocxPE(33)
If !Empty(cPE)
	aCposNF	:=	ExecBlock(cPe,.F.,.F.,{aCposNF,aCfgNF[SnTipo]})
Else  //PE: Adicionar campo (S3)
	If __lPyme .And. ExistBlock( "LOCXS333" , .F. , .T. )
    	aCposNF :=	Execblock( "LOCXS333" , .F. , .F. , {aCposNF,aCfgNF[SnTipo]} )
	EndIf
Endif
If lInclui
	If !lLocxAuto
		cOnInit := "SetValItem({{'"+Right(aCfgNF[SAliasCols],2)+"_COD','AtuContQt()'},{'"+ Right(aCfgNF[SAliasCols],2)+ "_QUANT','Positivo() .And. AtuContQt()'},{'"+ Right(aCfgNF[SAliasCols],2)+ "_QTSEGUM','Positivo() .And. AtuContQt()'}},1)"
		If lUsaCor
			If aCfgNF[SAliasHead] == "SF1" .And. cPaisLoc <> "CHI"
				cOnInit += ",M->F1_NUMCOR:=CORR_PROX(M->F1_DTDIGIT)"
			ElseIf aCfgNF[SAliasHead] == "SF2" .And. cPaisLoc <> "CHI"
				cOnInit += ",M->F2_NUMCOR:=CORR_PROX(M->F2_DTDIGIT)"
			Endif
	    Endif
		cLinok  := "PrepLinOk()"
		cFunOk  := "PrepGravaNf(aCfgNf["+AllTrim(Str(SnTipo))+"],__aCpTela)"
		cTudoOk := "PrepTudoOk(" + Alltrim(Str(aCfgNf[SnTipo])) + ",__aCpTela)"
	   	cFunCanc:= 'MsUnLockAll()'
	Else
		cFunOk  := "PrepGravaNf(aCfgNf["+AllTrim(Str(SnTipo))+"],__aCpTela)"
		cFunCanc:= 'MsUnLockAll()'
		cLinOk  := NIL
		cTudoOk := NIL
	EndIf
ElseIf lDeleta
	cOnInit 	:= "(InicializaFis(aHeader,aCols,'" + aCfgNf[SAliasHead] + "','" + aCfgNf[SAliasCols] + "','" + aCfgNf[ScCliFor] + "','" + aCfgNf[ScTipoDoc] + "',,.T.))"
	cOnInit     +=	",NFSetImps('"+aCfgNf[SAliasCols]+"')"
	If Type("lLocxAuto") <> "L"  .OR. !lLocxAuto
		cOnInit     +=	",AtuLoadQt()"
	Endif
	cOnInit 	:= IIf((Type("lLocxAuto") <> "U" .AND. lLocxAuto),cOnInit,"MsAguarde({|| " + cOnInit + "})")
	lMostraCtb 	:= aCfgNf[SaPergs][SlVerCtbil]
	lAglCtb    	:= aCfgNf[SaPergs][SlAglutina]
	lContab    	:= aCfgNf[SaPergs][SlGerCtbil]
	lCarteira  	:= .T.
	cFunCanc	:=	'DbUnLockAll()'
	cFunOk	    :=	Iif(StrZero(aCfgNf[SnTipo],2)$'01/11/50/52',"lCarteira:=LocxChePed('"+aCfgNf[SAliasHead]+"'," + aCfgNf[SAliasHead] + "->(Recno())),","")
	If !lLocxAuto .Or. (FunName() $ "MATA447" .And. GetRemoteType() <> -1)
		cFunOk 	+= "LocxDelNf('" + aCfgNf[SAliasHead] + "'," + aCfgNf[SAliasHead] + "->(Recno()),lMostraCtb,lAglCtb,lContab,lCarteira,.T.)"
	Else
		cFunOk 	+= "LocxDelNf('" + aCfgNf[SAliasHead] + "'," + aCfgNf[SAliasHead] + "->(Recno()),(Funname() $ 'FISA817' .And. lMostraCtb),lAglCtb,lContab,lCarteira,.F.,.F.)"
	Endif
	cTudoOk 	:= NIL
ElseIf l103Class
	cOnInit := "(InicializaFis(aHeader,aCols,'" + aCfgNf[SAliasHead] + "','" + aCfgNf[SAliasCols] + "','" + aCfgNf[ScCliFor] + "','" + aCfgNf[ScTipoDoc] + "',.T.))"
	cOnInit := "MsAguarde({|| " + cOnInit + "})"
	cOnInit +=	",AtuLoadQt()"
	If lUsaCor
		If aCfgNF[SAliasHead] == "SF1" .And. cPaisLoc <> "CHI"
			cOnInit += ",M->F1_NUMCOR:=CORR_PROX(M->F1_DTDIGIT)"
		ElseIf aCfgNF[SAliasHead] == "SF2" .And. cPaisLoc <> "CHI"
			cOnInit += ",M->F2_NUMCOR:=CORR_PROX(M->F2_DTDIGIT)"
		Endif
    Endif
	cFunOk  := "PrepGravaNf(aCfgNf["+AllTrim(Str(SnTipo))+"],__aCpTela)"
	cTudoOk := "PrepTudoOk(" + Alltrim(Str(aCfgNf[SnTipo])) + ",__aCpTela)"   // validacao
	cLinOk	:= "PrepLinOk()"
Else
	If lFacImport
		cOnInit := "(InicializaFis(aHeader,aCols,'" + aCfgNf[SAliasHead] + "','" + aCfgNf[SAliasCols] + "','" + aCfgNf[ScCliFor] + "','" + aCfgNf[ScTipoDoc] + "',.T.))"
		cOnInit +=	",NFSetImps('"+aCfgNf[SAliasCols]+"')"
	Else
		cOnInit := "(InicializaFis(aHeader,aCols,'" + aCfgNf[SAliasHead] + "','" + aCfgNf[SAliasCols] + "','" + aCfgNf[ScCliFor] + "','" + aCfgNf[ScTipoDoc] + "',,.T.))"
		cOnInit +=	",NFSetImps('"+aCfgNf[SAliasCols]+"')"
	Endif
	cOnInit     +=	",AtuLoadQt()"
	cOnInit 	:= "MsAguarde({|| " + cOnInit + "})"
	cFunOk  	:= NIL
	cTudoOk 	:= NIL
EndIf
AAdd(aObjsNF,{"oFldRodape:bChange","{|| ModxAtuObj(.F.) .AND. oGetDados:oBrowse:SetFocus() }",1})
//³Quando for remito nao mostrar os folders de Duplicatas, impostos e livros fiscais³
If lFacImport .AND. !lInclui
	If aCfgNf[SlRemito]
		AAdd(aObjsNF,{"oFldRodape:bSetOption","{|nNewOption| Iif(nNewOption >3,MsgAlert('"+STR0106+" '),Nil),nNewOption <4}",1})
	Else
		AAdd(aObjsNF,{"oFldRodape:bSetOption","{|nNewOption| If(nNewOption==3 .OR. nNewOption==7,MsgAlert('"+STR0106+" '),Nil),(nNewOption<>7 .AND. nNewOption <> 3)}",1})
	Endif
Else
	If aCfgNf[SlRemito] .AND. cPaisLoc <> "RUS"
		AAdd(aObjsNF,{"oFldRodape:bSetOption","{|nNewOption| Iif(nNewOption >3,MsgAlert('"+STR0106+" '),Nil),nNewOption <4}",1})
	ElseIf Empty(aCfgNf[ScOpFin])
		AAdd(aObjsNF,{"oFldRodape:bSetOption","{|nNewOption| Iif(nNewOption ==4 ,MsgAlert('"+STR0106+" '),Nil),nNewOption <> 4 }",1})
	Endif
Endif
cOnInit 	:= "EVAL(bFunAuto)" + If(Empty(cOnInit),"",",") + cOnInit
aOpcTeclas 	:= ChkTeclas(aCfgNf[SaTeclas],nOpca)
aBotoes 	:= ChkButtons(aCfgNf[SaBotoes],nOpca)
AAdd(aOrditem,PrefixoCpo(aCfgNf[5]) + "_ITEM")
__aCodLocs	:= {}
//PE: Manipular Array com os objetos que devem ser criados na tela com seus devidos comando de criacao
cPe	:=	LocxPE(48)
If !Empty(cPE)
	aUsObjNF :=	ExecBlock(cPe,.F.,.F.,{aObjsNF})
	If ValType(aUsObjNF) == "A"
	   aObjsNF := aUsObjNF
	Endif
Endif
If cPaisLoc == "COL" .And. FINDFUNCTION( "lxVlTitulo" ) .And. (lDocSp .Or. aCfgNF[SnTipo] == 22 .Or. aCfgNF[SnTipo]== 23) //Docto Soporte //Nota Crédito //Nota Débito
	cCadastro:= lxVlTitulo(lDocSp, aCfgNF[SnTipo], cCadastro ) //obtiene el titulo del documento
Endif
LocxMod(,aCposNF,,aCposRodape,aParCols,,cCadastro,aCordW,.T.,aCoordGD,,nOpca,cFieldOk,cLinOk,cTudoOk,cFunOk,cFunCanc,If(lInclui,"+" + cP4 + "ITEM",),aCfgNF[SaCposGD],IIf(aCfgNf[SlFormProp],nItens,MAX_GETD),!(lVisualiza .OR. lDeleta),aBotoes,aOpcTeclas,aObjsNF," LxA103Del().AND. AtuContQt()",cOnInit,,,aOrditem)

If cPaisLoc == "EQU"  .and. FunName() == "MATA467N" .and. aCfgNF[SAliasHead] == "SF2" .and. Alltrim(SF2->F2_ESPECIE) =="NF" .and.  FindFunction("MAT488END") .and. SF2->(FieldPos("F2_TPDOC")) > 0 .and.  Len(aLlaveOrg) > 0
	MAT488END() //limpia variables y tabla temporal de reembolsos.
Endif
If cPaisLoc == "MEX" //.And. SF2->(ColumnPos("F2_TPCOMPL")) > 0 .And. cFunName == "MATA467N" .And. (nNFTipo == 1 .Or. nNFTipo == 21)
	oModelAct := Nil
EndIf

For nX:=1 To Len(__aCodLocs)
	UnLockByName(__aCodLocs[nX],.T.,!Empty(cFilSF2),.T.)
	UnLockByName(__aCodLocs[nX],.T.,!Empty(cFilSF1),.T.)
Next
__aCodLocs	:= {}
If MaFisFound()
	MaFisEnd()
EndIf
If Type("aImpIB2")== "A"
	aImpIB2:={}
EndIf
//Geracao da NCC para cancelamento de NF - Loc. Guatemala
If cPaisLoc == "GUA" .AND. lDeleta .AND. lGeraNCC .AND. Len(aDadosSF2) > 0
   If !LocxGerNCC()
      Return (.F.)
   EndIf
EndIf
//Quando Recebimento de Meio Magnetico nao restaura area para nao desposicionar do documento gerado
If AllTrim(FunName()) <> "LOJA470"
	dbSelectArea(aArea[1])
	dbSetOrder(aArea[2])
	MsGoto(aArea[3])
EndIf
If bFilBrowse <> Nil
	Eval(bFilBrowse)
Endif
aCfgNF	:=	AClone(IIf(lBkpCfgInc, aBkpCfgInc, aBKPCfgNF))
NFSetPrv(aCfgNF)
SetKey(VK_F12,bSavF12)
//|Atencao: Para o Ambiente Portugal, esta parte do codigo fecha os alias de tabelas      |
//|existentes na SX3 e espelhos que existem somente no banco de dados					  |
//#PORTUGAL#
//If ( cPaisLoc == "PTG" )  .and. lHashPTG .and. ( cFunName$"MATA103CG/MATA103CF/MATA462G/MATA467C/MTA462CAN/MTA462DCAN/MTA462RSC" )
//    FechaTable({/*aCfgNF[SAliasHead],aCfgNF[SAliasCols],*/RetSqlName(aCfgNF[SAliasHead])+"_CANC",RetSqlName(aCfgNF[SAliasCols])+"_CANC",aCfgNF[SAliasHead]+"CURRENT",aCfgNF[SAliasCols]+"CURRENT"})
//EndIf
If (Valtype("cFactApoc") <> "U", cFactApoc := "", "")
Return
/*³Fun‡…o    ³ EnablePanel   ³ Autor ³ Guilherme C. Leal ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Habilita os paineis do rodape.       ³*/
Function EnablePanel()
aoSbx[1]:Enable()
aoSbx[1]:Refresh()
oLstFin:Enable()
oLstFin:Refresh()
oLstImp:Enable()
oLstImp:Refresh()
Return .T.
/*³Fun‡…o    ³ NFCalcImp     ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Inicializa variaveis necessárias para calculo dos impostos.        ³*/
Function NFCalcImp()
Local nPosDesc:=0
nPosDesc:=AScan(aHeader,{|x| Upper(Alltrim(x[2]))$"D1_VALDESC|D2_DESCON"})
If nPosDesc>0
	AEval(aCols,{|x| AAdd(aDescontos,x[nPosDesc])})
Endif
If aCfgNf[SAliasHead]=="SF2"
	cA467Cli  :=M->&("M->F2_CLIENTE")
Else
	cA467Cli  :=M->&("M->F1_FORNECE")
EndIf
cNitCC:=""
lRatValor :=.F.
nTotMerc  :=M->&(cP3+"VALMERC")
nValDesp  :=M->&(cP3+"DESPESA")
nSeguro   :=M->&(cP3+"SEGURO")
nValFrete :=M->&(cP3+"FRETE")
nValDesc  :=M->&(cP3+"DESCONT")
aImpS     := {}
cEspecie  :=M->&(cP3+"ESPECIE")
cVenda    := "NORMAL"
cNFiscal  :=M->&(cP3+"DOC")
cSerie    :=M->&(cP3+"SERIE")
nTaxa		:=	M->&(cP3+"TXMOEDA")
nMoedaNF	:=	M->&(cP3+"MOEDA")
If Empty(cEspecie)
	cEspecie  :=   Alltrim(aCfgNf[ScEspecie])
	M->&(cP3+"ESPECIE"):= cEspecie
EndIf
//#PORTUGAL#
/*If cPaisLoc == "PTG"
	nValNTrib	:=	M->&(cP3+"DESNTRB")
	nValTara	:=	M->&(cP3+"TARA")
Endif*/
Return
/*³Fun‡…o    ³ PrepTudoOk    ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Prepara todas as informações necessárias para a chamada da TudoOk. ³*/
Function PrepTudoOk(nTipoNf,aGetsTela)
Local aCpos := {}, nX := 0
Local aCposTela:=Array(3) //Dados do cabecalho de uma NF
private ldupli := .T.
If Type("cCxCaixa") == "U"
	cCxCaixa	:= ""
EndIf
/*	[1] - campos do cabecalho
	[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
	[3] - indica se o campo e totalizador (Default .F.)
	Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
    e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado*/
//Si hay un valor para caja chica, calcula que sean válidos los campos.
If !Empty(cCxCaixa)
	If !Fa560Valor(nCxValor,cCxCaixa,.F.,cCxAdian,cCxRendic)
		Return .F.
	EndIf
EndIf
aCposTela[1]:={};	aCposTela[2]:={};	aCposTela[3]:={}
For nX := 1 TO Len(aGetsTela)
	If Ascan(aCpos,{|x| x[1] == aGetsTela[nX][1]})==0
		Aadd(aCpos,aGetsTela[nX])
	Endif
Next
aGetsTela:=aClone(aCpos)
//Carrega campos e conteudos dos objetos da tela para o array aCposTela desconsiderando os campos que nao fazem parte do cabecalho da NF
AEVal(aGetsTela,{|x| IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[1],x[1]),),IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[2],x[2]),) })
//Busca os campos que possuem um conteudo padrao/automatico na gravacao da NF, de acordo com a nota e inclui os campos e seus respectivos conteudos no array aCposTela
aAux 			:= CposAutoNf(aCfgNf[SAliasHead],aCfgNf[ScCliFor],aCfgNf[SlFormProp],aCposTela[1],{aCposTela[2]},aCfgNf[ScTipoDoc])
aCposTela[1] 	:= aClone(aAux[1])
aCposTela[2] 	:= aClone(aAux[2][1])
//³Chamada da funcao de consistencia TUDOK³
Return NfTudOk(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCposTela,HeaderCpos(),aCols,Len(aCols),aCfgNf[ScTipoDoc],aCfgNf[SlFormProp],aGetsTela)
/*³Fun‡…o    ³ PrepGravaNf   ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Prepara informacoes e chama a gravacao da nf.                      ³*/
Function PrepGravaNf(nTipoNf,aGetsTela,bExecute)
//Local nX 		:= 0
//Local cMsgCFD	:= ""
Local aFin		:= Array(SnMaxFin) //Dados especificos para gravacao do financeiro
/*	[SnMoedaFin]	- Moeda a ser gravada no financeiro
	[ScNatureza]	- Naturaza da operacao financeira*/
Local aCfgOri 	:={}
Local aCposTela := Array(3)	//Dados do cabecalho da Nota
/*	[1] - campos do cabecalho
	[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
	[3] - indica se o campo e totalizador (.T./.F.)
	Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
	e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado,
	pois a formula de um campo totalizador e rodada sempre ao gravar os itens */
Local lRetPE	:= .T.
Local lContinua	:= .T.
Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1" //Integracao com o módulo ACD
Local lImprime	:= .F.
Local cCompNc	:= SuperGetMV("MV_COMPNC", .F., "3")//Indica qdo comp. a NCC-NDE 1-Sempre compensa,2-Nunca3-Pergunta
Local lGenXML	:= .T.
DEFAULT	bExecute	:=	{|| Nil	}
//³Ponto de Entrada para manipular aCols³
cPe	:=	LocxPE(60)
If !Empty(cPE)
	If ValType(lRetPE := ExecBlock(cPE,.F.,.F.) ) == "L"
		lContinua := lRetPE
	Endif
EndIf
aCposTela[1]:= {}
aCposTela[2]:= {}
//³Preparando o parametro dos dados financ.³
aFin[SnMoedaFin] := nMoedaCor
aFin[ScNatureza] := cNatureza
If cPaisloc $ "BOL" .And. (Type("cFunName")<>"U" .and. cFunName $'FINA087A|FINA085A|FINA074|FINA084')
	aDupl:={}
EndIf
//³Busca campos e conteudos para compor o array aCposTela, dos objetos da Tela, retirando os campos que nao
//³fazem parte do arquivo de cabecalho da NF que sera gravada
AEVal(aGetsTela,{|x| IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[1],x[1]),),IIf(cP3==Left(x[1],At("_",x[1])),AAdd(aCposTela[2],x[2]),) })
//³Chamada da funcao de gravacao da NF que retorna .T. ou .F.³
lRetGravacao:=.F.
If lContinua .And. ( Type("lLocxAuto") <> "U" .And. lLocxAuto )
	lRetGravacao := GravaNfGeral(aCposTela,aCols,HeaderCpos(),nTipoNf,aCfgNf[SaPergs],aRatCC,.f.,aClone(aFin),aRecsSF1,aDupl,,aGetsTela)
ElseIf lContinua
	MsAguarde( {|| lRetGravacao := GravaNfGeral(aCposTela,aCols,HeaderCpos(),nTipoNf,aCfgNf[SaPergs],aRatCC,.T.,aClone(aFin),aRecsSF1,aDupl,,aGetsTela)},,STR0033,) //"Gravando Registros..."
Endif
If lRetGravacao .And. lContinua
	If aCfgNf[SlRemito] .AND. aCfgNf[SnTipo] == 54 .AND. Type("M->F2_TIPORET")=='C' .AND. M->F2_TIPORET == '1'
		aCfgOri := AClone(aCfgNF)
		If !GerTrfRet(SF2->(Recno()),M->F2_FILDEST)
			Aviso(STR0018,STR0183,{STR0021}) // "Nao foi possivel gerar documento de retorno, a entrada devera ser feita manualmente."
		EndIf
		aCfgNf := AClone(aCfgOri)
		NFSetPrv(aCfgNF)
	EndIf
	//Integracao com o módulo ACD
	If lIntAcd
		If SF1->F1_TIPODOC $ "51*53" .And. SuperGetMv("MV_IMPIP",.F.,"3") == "2" .Or. ;
		SF1->F1_TIPODOC $ "60" .And. ((SA2->A2_IMPIP == "2") .Or. (SA2->A2_IMPIP $ "03 " .And. SuperGetMv("MV_IMPIP",.F.,"3") == "2" ))
			ACDI10NF(SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA,.T.,lLocxAuto)
		ElseIf SF1->F1_TIPODOC $ "08*09*10" .And. ((SA2->A2_IMPIP == "2") .Or. (SA2->A2_IMPIP $ "03 " .And. SuperGetMv("MV_IMPIP",.F.,"3") == "2" ))
			SD1->(DbSetOrder(1))
			If SD1->(dbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
				While SD1->(!EOF()) .And.;
				xFilial('SD1')	== SD1->D1_FILIAL 	.And. ;
				SD1->D1_DOC     	== SF1->F1_DOC    		.And. ;
				SD1->D1_SERIE   	== SF1->F1_SERIE  	.And. ;
				SD1->D1_FORNECE 	== SF1->F1_FORNECE 	.And. ;
				SD1->D1_LOJA    	== SF1->F1_LOJA
					If Empty(SD1->D1_REMITO)
						lImprime := .T.
						Exit
					EndIf
					SD1->(dbSkip())
				End
				If lImprime
					ACDI10NF(SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA,.T.,lLocxAuto)
				EndIf
			EndIf
		EndIf
	EndIf
	//Geracao Fat.Eletronicas
	If Type("lGerarCFD") != "L" .And. FunName() <> "MATA466N"
		lGerarCFD := .F.
		aGerarCFD := {}
		If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
			aGerarCFD := CFDVerific()
			If aGerarCFD[1] <> "0"
				If Empty(aGerarCFD[2])
					lGerarCFD := .T.
				Endif
			Else
				lGerarCFD := .F.
			Endif
		Endif
	Endif
	// LLama pantalla de Pagos
	If  cPaisLoc == "PAR" .and. aCfgNf[SnTipo] == 1  .and. aCfgNF[SAliasHead] == "SF2" .and. aGerarCFD[1] <> "0" .and. SE4->E4_BXTITAV == "1"
		M486PAGOS(SF2->F2_ESPECIE, SF2->F2_DOC, SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_COND,SF2->F2_VALBRUT,4)
	EndIf
	If (aCfgNf[SnTipo] == 4 .OR. aCfgNf[SnTipo] == 5) .And. aCfgNf[ScEspecie] $ MV_CRNEG .And. lGerarCFD .And. cCompOnL == "1"
		lGenXML := .T.
		If cPaisLoc == "MEX"
			lGenXML := !Empty(SF1->F1_UUID)
		EndIf
		If lGenXML
			If cCompNc	== "3" .AND. MsgYesNo(STR0035,STR0036) //"Deseja fazer agora a compensacao do titulo gerado?"###"Compensacao de titulos"
				Fina087a("","",{})
		    ElseIf cCompNc	== "1"
				If SuperGetMV("MV_FINCTMD",.T.,1) == 1
					Fina087a("","",{})
				Else
					SetFunName("FINA846")
					FINA840()
					SetFunName(cFunName)
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
// WMS Integration - Service Order Generation.
If cPaisLoc == "RUS"
	If SuperGetMV("MV_WMSNEW",.F.,.F.) .and. lContinua .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE=="S" .And. FindFunction("WmsIntMI") .And. IntWMS()
		aArea := GetArea()
			WmsIntMI()
		RestArea(aArea)
	EndIf
ELSE
//Integração WMS - Geração Ordem de Serviço
	If lContinua .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE=="S" .And. FindFunction("WmsIntMI") .And. IntWMS()
		WmsIntMI()
	EndIf
EndIf
//Libera Lock de Pedidos Bloqueados
If !lRetGravacao .and. Type("aRegsLock")<>"U"
	maDestrava(aRegsLock)
EndIf
Return lRetGravacao
/*³Fun‡…o    ³ SetVar        ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Seta valor de algumas variaveis que sao utilizadas posteriormente. ³*/
Function SetVar(cVar)
Do Case
	Case cVar == "F1_FORNECE"
		If cA100For != M->F1_FORNECE
			cA100For	:= M->F1_FORNECE
			lAtuFor	:= .T.
		Else
			lAtuFor := .F.
		EndIf
	Case cVar == "F1_EMISSAO"
		dDEmissao:=M->F1_EMISSAO
	Case cVar == "F2_EMISSAO"
		dDEmissao:=M->F2_EMISSAO
	Case cVar == "F1_LOJA"
		cLoja    := M->F1_LOJA
		If !Empty(M->F1_FORNECE)
		   cA100For := M->F1_FORNECE
		EndIf
EndCase
Return(.T.)
/*³Fun‡…o    ³ PrepLinOk     ³ Autor ³ Guilherme C. Leal      ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Habilita os paineis do rodape.  ³*/
Function PrepLinOk()
Local aAux := {} 	//Carrega os campos referentes aos itens da Nota que possuem conteudos padrao
//Altera foco para validacao da multinatureza
If Type("oGetDados")=="O"
	oGetDados:oBrowse:SetFocus()
EndIf
//Carregando os campos que possuem conteudos padrao com os campos que ja estavam declarados no aHeader³e armazenados no aCols
aAux := CposAutoNf(aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[SlFormProp],HeaderCpos(),aCols,aCfgNf[ScTipoDoc],n)
//Chamada da funcao de consistencias LINOK
Return NfLinOk(aCfgNf[SAliasCols],aAux[1],aCfgNf[ScCliFor],aAux[2],aCfgNf[ScTipoDoc],n,aCfgNf[SlFormProp])
/*
ºPrograma  ³GRAVANFGERAL ºLenadro C.G. ³Microsiga  º Data ³  09/10/01   º
ºDesc.     ³ Efetua a atuaizacao de todos os arquivos que devem ser     ¹
º          ³atualizados na gravacao de todos os tipos de notas fiscais. º*/
/*Parametros
aCabNotaOri - dados do cabecalho da Nota
[1] - campos do cabecalho
[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
[3] - indica se o campo e totalizador (Default .F.)
 Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
 e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado
aCpItensOri - campos dos itens (posicoes [2] do aHeader - usar funcao HeaderCpos)
aCitensOri  - conteudo dos itens da NF (aCols) * o conteudo de cada campo pode ser uma formula
nTipo    - tipo de NF
aPergs	- Array com o conteudo das perguntas feitas na tela de NF
	[SlAmarraca 1]-Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
	[SlGerCtbil 2]-lanç. On-Line?
	[SlVerCtbil 3]-Mostra Lanç.Contab ?
	[SlAglutina 4]-Aglut Lançamentos  ?
	[SlQbraAliq 5]-Quebra do Rodapé   ? Por Alíquota    /  Por Imposto
	[SlCtbEmiss 6]-Contabiliza por    ? Emissao         /  Data Base
aRatCC	- array com os itens de rateios por centro de custo de todos os itens da NF
	[1] - Numero do Item da NF (D1/D2_ITEM)
	[2] - Itens de Rateios por centro de custo para este item (dados que serao gravados no arquivo SDE)
lTela - Indica se a funcao foi chamada da tela ou nao
aFin - Parametro com os dados especificos de gravacao do financeiro
	[SnMoedaFin]-Numero da moeda de gravacao do financeiro
	[ScNatureza]-Natureza da operacao financeira
aRecsSF1 - Parametro com os registros das notas de entrada originais (usado nas notas de conhecimento de frete e despesas de import..
aDupl - Detalhe dos dados que devem ser gerados no financeiro
cNota - ?
aGetsTela - Vetor com todos os campos DIGITAVEIS da tela da Factura, utilizado para acessar informacoes complementares das folders da tela
*/
Function GravaNfGeral(aCabNotaOri,aCitensOri,aCpItensOri,nTipo,aPergs,aRatCC,lTela,aFin,aRecsSF1,aDupl,cNota,aGetsTela)
Local cAproFol	:= ""
Local cCertFol	:= ""
Local nI,nX     //flag's para loop's
Local cProd		:= "" //armazena codigo de produto
Local cLocal	:= "" //armazena almoxarifado
Local nQuant	:= 0  //armazena qtde do item da nota
Local aRecnoI	:= {} //array que guarda o numero dos registros de itens gravados e a pos. de cada registro na get dados
Local nRecnoC	:= 0  //Guarda o numero do registro de cabecalho gravado
Local aCusto	:= NIL //se necessario armazena valor de custos especiais para passar para rotina de saldos e custos
Local aAux		:= {} //Array auxiliar
Local nPos		:= 0  //pos. de um dado na pos. de um array
Local cPrefC	:= "" //Prefixo do Arquivo de Cabecalho
Local aLdel		:= {} //Numero das linhas do aCols que estao excluidas
Local aSavaCols	:= {} //Guarda o aCols original antes de retirar os itens deletados
Local aGeraPv	:= {} //Array indicando se cada item deve ou nao gerar pedido de venda quando for uma devolucao de venda
Local nValor	:= 0  //Valor referente ao valor base das duplicatas
Local aCitens	:= aClone(aCitensOri) 	//Conteudo dos itens da NF (aCols) * o conteudo de cada campo pode ser uma formula
Local aPars		:= {} //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lGeraPed	:=	.F.
Local aCpItens	:= aClone(aCpItensOri)	//Campos dos itens (posicoes [2] do aHeader - usar funcao HeaderCpos)
Local aCabNota	:= aClone(aCabNotaOri)	//Cabecalho da Nota
/*
[1] - campos do cabecalho
[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
[3] - indica se o campo e totalizador (Default .F.)
Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado
*/
Local aPosicionou 	:= Array(nMaxPos)	//Array com a indicacao dos arquivos que estao posicionados
/*
[lSF4]-Indica se foi posicionado SF4 (TES)
[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
[lSAx]-Indica se foi posicionado SA1 OU SA2 (CLIENTE OU FORN.)
[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
*/
Local aCpTotal	:= {}  //Array que acumula o nome dos campo de cabecalho que devem ser totalizados na gravacao dos itens
Local lRet		:= .T. //Retorno da funcao. Indica incosistencia da funcao
Local aFormTot	:= {}  //Array com a formula do conteudo para os campos totalizadores
/*
[1] - aCabNota
[2] - aCitens
[3]	- aCpItens
Obedece a devolucao da rotina ConsisNf
*/
Local cFilOri := cFilAnt
Local nNF:= 0
Local cCompNc	:= GetNewPar("MV_COMPNC","3")//Indica qdo comp. a NCC-NDE 1-Sempre compensa,2-Nunca3-Pergunta
Local aRecCols := {}
Local xRet                              //Retorno do PE LocxPE24
Local cChSF3:="",cCorrelat:="",aSF3:={},aAreaAnt:={},aAreaASD1:={},aAreaASD2:={},aAreaASF4:={},aAreaASF9:={}
Local nY := 0
Local cNomePE := ""
Local cNumAut		:= ""
Local cCodCtr		:= ""
Local aRetCF	:= {}
Local aDados 	:= {"","","","","",0}
Local cKey		:= ""
// Controle de Folios
Local lContrFol     := .f.
// Passagens aereas - Bolivia
Local lPassag 	:= 	cPaisLoc == "BOL" .And. GetNewPar("MV_PASSBOL",.F.)
Local lTipComp  :=	cPaisLoc == "BOL"
Local cTipCom		:= ""
Local cRecibo       := ""
Local cCompan		:= ""
Local cLojComp		:= ""
Local cPassage		:= ""
Local cCompSF3      := ""
Local dDtPassag		:= cToD("//")
Local cHash         := "" // Inicializada para todos ambientes, porem utilizada somente para ambientes de Portugal
Local cBaseATF 		:= ""
Local nV       		:= 0
Local lIntNtCRDB    := SuperGetMV( "MV_ATFNCRD", .F., .F. )	//Parâmetro de ativação do ajuste de valor do bem.
Local cTipoRem		:= ""
Local nPosRateio	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_RATEIO"	} )
Local nPosRemito	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_REMITO"	} )
Local nPosItemRem	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_ITEMREM"	} )
Local nPNfOri		:= aScan(aHeader,{|x| AllTrim(Subs(x[2],4)) $ "NFORI"})
Local nPSerOri	:= aScan(aHeader,{|x| AllTrim(Subs(x[2],4)) $ "SERIORI"})
Local cDocMan       := ""
Local cSerMan       := ""
Local dEmiMan       := cToD("//")
Local lDISTMOV	:= SuperGetMV("MV_DISTMOV",.F.,.F.)
Local aDigEnd	:= {}
Local lVer116	:= .T.
Local cCndplim:= SuperGetmv("MV_CNDPLIM",.F.,"1")
Local cFilSD2	:= xFilial("SD2")
Local cFilSD3	:= xFilial("SD3")
Local cFilSDB	:= xFilial("SDB")
Local cFilSF1	:= xFilial("SF1")
Local cFilSF2	:= xFilial("SF2")
Local cFilSF4	:= xFilial("SF4")
Local cFilSF9	:= xFilial("SF9")
Local cFilSWD	:= xFilial("SWD")
Local cFilSWN	:= xFilial("SWN")
Local cFilSWW	:= xFilial("SWW")
Local lITEMSWN	:= .F.
Local lDOCSWN		:= .F.
Local lBENSATF	:= .F.
Local eJ       := 0
Local eK       := 0
Local aCalCod  := {}
Local nLenCon  := 0
Local cFormLib:=""
Local lFormLib:=.F.
Local cNumb		:= ""
Local cLvroRetC  := SuperGetMV("MV_LVRORIC",,"") //Número de libro para ret. de IVA al 0% (Ecuador)
Local lGenXML   := .T.
Local cCFDUso   := Alltrim(GetMv("MV_CFDUSO", .T., "1"))
Local cFunName  :=  FunName()

If cPaisLoc <> "ARG"
	lContrFol     :=  cPaisLoc $ "BOL"	.And. AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720|MATA143" ;
	                  .And. GetNewPar("MV_CTRLFOL",.F.)
Else
	lContrFol     := AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720|MATA462R" .And. GetNewPar("MV_CTRLFOL",.F.)
EndIf
aCfgNf 				:= {}   			//Array com todas as config. da NF, ver conteudo na funcao LOCXNF
//Variaveis utilizadas para serem utilizadas como referencia nos PE
Private nNFTipo  := 0			//Tipo da NF Numerica  (1,2,3,4,5,6,7,8,9,....)
Private cNFTipo	 := ""			//Tipo da NF caractere ("N|D|C|B..."
Private aRecIMP	:=	{}
Private lInclui   := .T.
Private nTotDup		:= 0
Private a100CliFor  := ""
Private aPE			:= Array(SnMaxPE,2)
lLocxAuto 			:=	Iif(Type("lLocxAuto") <> "U", lLocxAuto, .F. )
Default aPergs      := {}
Default aRatCC		:= {}
Default aFin 		:= {}
Default lTela		:= .F.
Default aRecsSF1 	:= {}
Default aDupl    	:= {}
DEFAULT cNota		:=	cNFiscal
Default aGetsTela   := {}
Default __aCodLocs	:= {}
If ValType('nTaxa') == 'U'
	Private 	nTaxa
Endif
If ValType('nMoedaNF') == 'U'
	Private 	nMoedaNF
Endif
If ValType('cNFiscal') == 'U'
	Private 	cNFiscal
Endif
If ValType('cSerie') == 'U'
	Private 	cSerie
Endif
If ValType('cEspecie') == 'U'
	Private	cEspecie
Endif
If ( Type("l103Auto") == "U" )
	Private l103Auto:= lLocxAuto
EndIf
If Type('aRecnoSE1') == 'U'
	Private	aRecnoSE1:={}
Endif
If !IsMemVar("lGerarCFD")
	Private lGerarCFD:= .F.
EndIf
If !IsMemVar("cPathXML")
    Private cPathXML := ""
EndIf
If Type('lDocSp') == 'U'
	Private	lDocSp := .F.
Endif
If Type('lAutoFact') == "U"
	Private lAutoFact := .F.
EndIf
Private laRatEvEz := (Type ("aRatEvEz") <> "U" .AND. aRatEvEz <> Nil)//contenido para multi naturaleza
Private lMultNat  := SuperGetMv("MV_MULNATP") // multiples modalidades Ctas/Pagar
Private lProrrCC  := SuperGetMv("MV_MULNATS") //porrateo CC
/*³Verificacao/definicao das variaveis utilizadas para distinguir NF de import.a das das demais.                                    ³*/
lFacImport	:=	If(Type("lFacImport")	<>"L",.F.	,lFacImport)
l103Class	:=	If(Type("l103Class")	<>"L",.F.	,l103Class)
l103Visual	:=	If(Type("l103Visual")	<>"L",.F.	,l103Visual)
aRatAFN 	:=	If(Type("aRatAFN")		<>"A",{}	,aRatAFN)	 //Variavel private utilizada na itegracao com o PMS
lUsaCor		:=	If(Type("lUsaCor")		<>"L",.F.	,lUsaCor)	 //Utilizacao do correlativo de compras
If FunName() == "MATA101N" .And. lInclui .And. aCols[n][nPosRateio] == "1";
			.And. !Empty(aCols[n][nPosRemito]) .And. !Empty(aCols[n][nPosItemRem]) .And. lLeSDE .And. Len(aRatCC) == 0
	aRatCC := BuscaSDE()[3]
EndIf
//³Montando array com todas as configuracoes da NF que sera gravada, utilizadas durante toda a
//³gravacao. Cada pos. desse array servira como flag para atualizacao de arquivos e processos
aCfgNf  := MontaCfgNf(nTipo,aPergs,lTela)
//³Montando array de pontos de entrada³
aPE	   := aClone(aCfgNf[SaPE])
//³Ponto de Entrada para numeracao da NF³
cPe	:=	LocxPE(24)
If !Empty(cPE)
	xRet  := ExecBlock(cPE,.F.,.F.,{"1",Nil})
	If ValType(xRet) == "L"
	   If !xRet
	      Return .F.
	   EndIf
	EndIf
EndIf
//Geracao Fat.Eletronicas
If Type("lGerarCFD") != "L"
	lGerarCFD := .F.
	aGerarCFD := {}
	If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
		aGerarCFD := CFDVerific()
		If aGerarCFD[1] <> "0"
			If Empty(aGerarCFD[2])
				lGerarCFD := .T.
			Else
	    		If !Empty(aGerarCFD[2]) .AND. !lLocxAuto
					cMsgCFD := ""
					For nX := 1 To Len(aGerarCFD[2])
						cMsgCFD += aGerarCFD[2][nX][2] + CRLF
					Next
					MsgAlert(cMsgCFD,STR0248)
				Endif
			Endif
		Else
			lGerarCFD := .F.
		Endif
	Endif
Endif
If Type("cCompOnL") != "L"
	cCompOnL := SuperGetMV("MV_NCCONL",.F.,"")
EndIf
//Opción de compensación OnLine
If Valtype(cCompOnL) == "U" .Or. Empty(cCompOnL) .Or. !(cCompOnL $ "1|2|3")
	If cPaisLoc == "MEX" .And. cCFDUso <> "0"
		cCompOnL := "1" //Fact. Electrónica y compensa en línea
	ElseIf cPaisLoc $ "CHI|COL|EQU|PER|BOL|PAR"
		cCompOnL := "2" //Fact. Electrónica y NO compensa en línea (por tiempo de espera en retorno de estatus de timbrado)
	Else
		cCompOnL := "3" //NO Fact. Electrónica y compensa en línea
	EndIf
EndIf
//³Iniciando Trasacoes³
begin transaction
	//³Consistindo param.³
	Aadd(aPars, {"nTipo"	,nTipo		,SpValor	,1	,65})
	Aadd(aPars, {"aCitens"	,aCitens	,SpEmpty		   })
	Aadd(aPars, {"aCpItens"	,aCitens	,SpEmpty		   })
	Aadd(aPars, {"aCabNota",aCabNota	,SpLenArray	,2	,3 })
	Aadd(aPars, {"aCabNota",aCabNota[1]	,SpEmpty		   })
	Aadd(aPars, {"aCabNota",aCabNota[2]	,SpEmpty		   })
	lRet := LocxParam("GRAVANFGERAL",aPars)
	//³Verifica Natureza Financeira a ser utilizada no titulo quando NF gerada por Despacho³
	CheckNat()
	//³Ponto de entrada antes de iniciar a gravacao da NF³
	cPe	:=	LocxPE(4)
	If lRet .AND. !Empty(cPE)
		ExecBlock(cPE,.F.,.F.)
	Endif
	If lRet .And. Type("cCondicao") <> "U"
		If aCfgNf[SAliasHead] == "SF2" .And. Alltrim(aCfgNf[ScEspecie]) == "NF"
			dbSelectArea("SE4")
			dbSetOrder(1)
			If SE4->(MsSeek(xFilial("SE4") + cCondicao))
				If M->F2_VALMERC > SE4->E4_SUPER .AND. SE4->E4_SUPER <> 0 .And. cCndplim=="1"
				    Help(" ","1","LJLIMSUPER")
					lRet := .F.
				ElseIf M->F2_VALMERC < SE4->E4_INFER .AND. SE4->E4_INFER <> 0 .And. cCndplim=="1"
					Help(" ","1","LJLIMINFER")
					lRet := .F.
				 EndIf
			EndIf
		 EndIf
	EndIf
	If lRet
		//³Acertando parametro aCitens e aFin³
		Aeval(aCitens, { |x,y| Asize(aCitens[y],Len(aCpItens)+1), If(Empty(x[Len(x)]),x[Len(x)]:=.F.,) })
		Asize(aFin, SnMaxFin)
		lRet    := !Empty(aCfgNf)
		nNF		:= Ascan(aCabNotaOri[1],PrefixoCpo(aCfgNf[SAliasHead])+ "_DOC")
		cNFiscal := cNota
		If nNF > 0 .AND. aCabNota[2][nNF] <> cNFiscal
			aCabNota[2][nNF]   	:= cNFiscal
			aCabNotaOri[2][nNF]	:= cNFiscal
		EndIf
	Endif
	If lRet
		//³Iniciando Fiscal, se necessario                      ³
		//³Se for sem tela, os dados das linhas e do cabecalho  ³
		//³teme que vir com os dados fiscais necesarios para o  ³
		//³calculo de impostos preenchidos.                     ³
		If !MaFisFound()
			InicializaFis(MontaHeader(aCpItens),aCItens,aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[ScTipoDoc],.T.)
		Endif
		//³Inicializa as variaveis do CABECALHO DA NF³
		AEVAL(aCabNota[1],{|x,y| &("M->"+x) :=	Nil})
		nNFTipo  := aCfgNf[SnTipo]
		cNFTipo	:= aCfgNf[ScTipoDoc]
		cEspecie := aCfgNf[ScEspecie]
		cPrefC	:= aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])
		//³Se nao houver aCols declarado ou estiver em branco, preenche um novo aCols³
		If 	(	Type("aCols") == "U"  .OR.;
			Empty(aCols) 			   .OR.;
			Len(aCols) != Len(aCitens))
			aCols   := aCitensOri
			aHeader := MontaHeader(aCpItensOri)
		EndIf
		//³Retira os itens deletados do aCols e trabalha apenas com os itens validos.       ³
		//³E necessaria esta alteracao dentro desta rotina pois as atualizacoes referentes  ³
		//³aos itens da NF sao feitas depois da gravacao dos itens e a partir de entao      ³
		//³a rotina se baseia no proprio arquivo gravado sendo preciso que o aCols contenha ³
		//³apenas as informacoes gravadas para que nao exista nenhum problema com futuras gravacoes  ³
		aSavaCols 	:= aClone(aCols)
		Aeval(aCitens	, { |x,y| IIf( x[Len(x)], Aadd(aLdel,y), ) })
		For nX	:= Len(aLdel) TO 1 STEP -1
			Adel(aCitens,aLdel[nX])
		Next
		ASize(aCItens,Len(aCItens)-Len(aLdel))
		//³Acerta preenchimento de campos de valore automaticos/padrao de cabecalho³
		aAux 		:= CposAutoNf(aCfgNf[SAliasHead],aCfgNf[ScCliFor],aCfgNf[SlFormProp],aCabNotaOri[1],{aCabNotaOri[2]},aCfgNf[ScTipoDoc])
		aCabNota[1]	:= aAux[1]
		aCabNota[2]	:= aAux[2][1]
		//³Inicializa variaveis privates necesarias em outras rotinas padrao do sistema. ³
		If aCfgNF[SAliasHead] == "SF1"
			nTaxa		:=	M->F1_TXMOEDA
			nMoedaNF	:=	M->F1_MOEDA
			cNFiscal  	:=  M->F1_DOC
			cSerie    	:=	M->F1_SERIE
		Else
			nTaxa		:=	M->F2_TXMOEDA
			nMoedaNF	:=	M->F2_MOEDA
			cNFiscal  	:=	M->F2_DOC
			cSerie    	:=	M->F2_SERIE
		EndIf
		//³Acerta preenchimento de campos de valore automaticos/padrao de itens    ³
		aAux 		:= CposAutoNf(aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[SlFormProp],aCpItensOri,aCitensOri,aCfgNf[ScTipoDoc])
		aCpItens	:= aAux[1]
		aCitens	:= aAux[2]
		//³Ponto de entrada para incluir campos customizados no cabeçalho da nota  ³
		cPe	:= LocxPE(72)
		If !Empty(cPe) .And. ValType(aCabNota)=="A" .And. Type("aAutoCab")=="A"
			aRetPe72:=ExecBlock(cPE,.F.,.F.,{aCabNota,aAutoCab})
			If ValType(aRetPe72) == "A" .and. len(aRetPe72)>0
				aCabNota:=aRetPe72
			EndIf
		Endif
		//³Acertando parametro aCabNota³
		Asize(aCabNota, 3)
		aCabNota[3] := IIf(Empty(aCabNota[3]) .OR. ValType(aCabNota[3]) != "A", {}, aCabNota[3])
		Asize(aCabNota[3], Len(aCabNota[1]))
		Aeval(aCabNota[3], {|x,y| If(x==NIL,aCabNota[3][y]:=.F.,)})
		//³Efetua a consistencia de todos os campos que devem ser gravados tanto no cabecalho como nos itens da NF³
		//³A rotina de consistencia adiciona formulas para campos que devem ser gravados, nao foram passados mas possuem   ³
		//³um conteudo padrao. Isso faz com as posicoes incluidas com uma formula nos array's de conteudos sejam um array  ³
		//³de duas posicoes. A primeira e a formula e a segunda e o indicador de que e uma formula						       ³
		If aCfgNf[SaAtualiza][SlConsist]
			If !ConsisteNf(aCfgNf,aCabNota,aCitens,aCpItens,lTela)
				Alert(STR0034)
				lRet := .F.
			EndIf
		EndIf
	    //#PORTUGAL#
		/*If cPaisLoc == "PTG" .And. lHashPTG .And. aCfgNF[SlFormProp]
	        cPe :=  LocxPE(50)
	        If lRet .And. !Empty(cPE)
	            lHashPTG := ExecBlock(cPE,.F.,.F.)
	        Endif
	        If lHashPTG
	            If aCfgNf[SAliasHead] == "SF2"
	                nPosDOC := aScan(aCabNota[1],{|x| Alltrim(x) == "F2_DOC"})
	                nPosSER := aScan(aCabNota[1],{|x| Alltrim(x) == "F2_SERIE"})
	            ElseIf aCfgNf[SAliasHead] == "SF1"
	                nPosDOC := aScan(aCabNota[1],{|x| Alltrim(x) == "F1_DOC"})
	                nPosSER := aScan(aCabNota[1],{|x| Alltrim(x) == "F1_SERIE"})
	            EndIf
	            cHash := VldNumPTG(aCabNota[2][nPosDOC],aCabNota[2][nPosSER])
	            If Empty(cHash)
	                Aviso("ATENCAO","Numero ANTERIOR da NF ("+aCabNota[2][nPosDOC]+"/"+ aCabNota[2][nPosSER]+"), não existe. Por favor, verifique!",{"OK"})
	                lRet := .F.
	            EndIf
	        EndIf
	    EndIf*/
		If lRet
			//Processa a gravacao do ID do cabecalho para garantir a integridade referencial antes de gravar os itens
	        nRecnoC := GravaCabNF(aCabNota,aCfgNf[SAliasHead],.T.,cHash)
			//Verifica todos os campos que devem ser totalizados³
			AEval(aCabNota[3], { |x,y| If(aCabNota[3][y],AADD(aCpTotal, aCabNota[1][y]),),If(aCabNota[3][y],AADD(aFormTot, aCabNota[2][y]),) })
			//³Guarda o tipo de remito definido no cabecalho para atualizacao dos itens ³
			If aCfgNf[SAliasHead]=="SF2"
				cTipoRem := aCabNota[2][aScan(aCabNota[1],"F2_TIPOREM")]
			EndIf
			//Grava os itens da NF a partir dos param. aCitens e aCpItens e armazena o numero
			//de cada registro gravado no array aRecnoI como tambem efetua o calculo dos campos totalizadores
			aAux    := GravaItensNF(aCitens,aCpItens,aCfgNf[SAliasCols],{aCpTotal,aFormTot},aCfgNf[ScCliFor],aCfgNf[ScTipoDoc],cTipoRem)
			aRecnoI := aAux[1]
			aRecCols:= aAux[4]
			If aRecnoI == NIL
				lRet := .F.
			EndIf
			If cPaisLoc == "RUS" .AND. aCfgNF[SAliasHead] == "SF1"
				AADD(aCabNota[1], "F1_F5QUID")
				AADD(aCabNota[2], M->F1_F5QUID)
				AADD(aCabNota[3], .F.)
			ElseIf cPaisLoc == "RUS" .AND. aCfgNF[SAliasHead] == "SF2"
				AADD(aCabNota[1], "F2_F5QUID")
				AADD(aCabNota[2], M->F2_F5QUID)
				AADD(aCabNota[3], .F.)
			EndIf
			If lRet
				//³Verifica os campos totalizadores e inclui os mesmo no array de cabecalho³
				nI := 0
				For nI := 1 to len(aAux[2])
					nPos := Ascan(aCabNota[1], aAux[2][nI])
					If nPos > 0
						aCabNota[2][nPos] := aAux[3][nI]
					Else
						AADD(aCabNota[1], aAux[2][nI])
						AADD(aCabNota[2], aAux[3][nI])
					EndIf
				Next nI
				//³Grava cabecalho da NF a partir do parametro aCabNota e armazena numero do registro gravado³
			    (aCfgNf[SAliasHead])->(MsGoto( nRecnoC))  // garante que se posiciona no Id do cabecalho ja gravado
				nRecnoC := GravaCabNF(aCabNota,aCfgNf[SAliasHead],.F.)
				If aCfgNF[SAliasHead] == "SF2" .And. nPNfOri > 0 .And. nPSerOri > 0
					RecLock("SF2",.F.)
					SF2->F2_NFORI := acols [1][nPNfOri] //Doc Orig
					SF2->F2_SERIORI	:= aCols [1][nPSerOri]	//Serie Doc. Orig
					MsUnLock()
				ElseIf aCfgNF[SAliasHead] == "SF1" .And. nPNfOri > 0 .And. nPSerOri > 0
					RecLock("SF1",.F.)
					SF1->F1_NFORIG := acols [1][nPNfOri] //Doc Orig
					SF1->F1_SERORIG	:= aCols [1][nPSerOri]	//Serie Doc. Orig
					MsUnLock()
				EndIf
				If nRecnoC <= 0
					lRet := .F.
				EndIf
				If lRet
					//³Posicionando todos os arquivos que devem ser utilizados na atualizacao de processos a paritr ³
					//³do cabecalho da NF. Nao devem ser efetuados "Seek's" em nenhum arquivo a nao ser 	³
					//³dentro desta rotina ou na rotina PosicionaI, nao sendo estritamente necessario	 			³
					PosicionaC(aCfgNf[SAliasHead],nRecnoC,aCfgNf[ScCliFor])
					//³Verifica se e necessario inicializar as variaveis referentes ao tratamento de impostos³
					If !MaFisFound()
						If !InicializaFis(MontaHeader(aCpItens),aCItens,aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[ScTipoDoc])
							lRet := .F.
						EndIf
					EndIf
					If lRet
						//³Verifica se algum item deve gerar pedido de venda, de acordo com o campo virtual D1_GERAPV³
						//³somente quando for devolucao de venda. Isto se faz necessario pelo fato de que este campo ³
						//³nao existe no arquivo e o aCitens ou aCols nao e utilizado dentro da funcao VarreItNf	 ³
						If aCfgNf[SAliasCols] == "SD1" .AND. aCfgNf[ScTipoDoc] == "D"
							nPos := aScan(aCpItens, "D1_GERAPV")
							If nPos > 0
								Aeval(aCitens, { |x,y| Aadd( aGeraPv, IIf(x[nPos]=="S",.T.,.F.) ) })
							EndIf
						EndIf
						//³Efetua todas as atualizacoes referentes aos itens da NF. Varre todos os itens e efetua³
						//³todas as atualizacoes necessarias para cada um												  ³
						If !l103Class
							If !VarreItNf(aClone(aCfgNf),aClone(aRecnoI),nRecnoC,aClone(aRatCC),aClone(aGeraPv),aRecsSF1,@aDigEnd)
								lRet := .F.
							EndIf
						Else
							If aCfgNf[SAliasCols] == "SD1" .AND. ( Empty(SF1->F1_TIPO_NF) .OR. (SF1->F1_TIPO_NF == "5" .AND. GetNewPar("MV_CUSTIMP","1") $ "1|2") )
								If !VarreItNf(aClone(aCfgNf),aClone(aRecnoI),nRecnoC,aClone(aRatCC),aClone(aGeraPv),aRecsSF1,@aDigEnd)
									lRet := .F.
								EndIf
							EndIf
						EndIf
						If ( ( aCfgNf[SnTipo] == 54 .AND. M->F2_TIPORET == '2' ) .OR. aCfgNf[SnTipo] == 64 )
							For nI := 1 To Len(aRecnoI)
								If  aCfgNf[SnTipo] == 64
									cFilAnt := M->F1_FILORIG
								EndIf
								lRet := GerSD3Trf(aCfgNf[SAliasCols],aRecnoI[nI,1],IIf(aCfgNf[SnTipo] == 54,1,2),cFilOri)
								If  aCfgNf[SnTipo] == 64
									cFilAnt := cFilOri
								EndIf
							Next nI
						EndIf
						//³ Efetua a Atualizacao da Assistencia Tecnica Somente para os paises localizados
						//³ Obs.: A Geração quando o item não utiliza localização é feita na função GravaItensNF()
						For nI := 1 To Len(aRecnoI)
							If aCfgNf[SAliasCols]=="SD2" .AND. (cPaisLoc $ "ARG|PAR|URU|CHI|MEX|EUA|POR|BOL")
								SD2->(MsGoTo(aRecnoI[nI,1]))
								If ( SF4->F4_ATUTEC=="S" )
									If ( Localiza(SD2->D2_COD) )
										dbSelectArea("SDB")
										dbSetOrder(1)
										If ( MsSeek(cFilSDB+SD2->D2_COD+SD2->D2_LOCAL+SD2->D2_NUMSEQ+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA) )
											dbEval({|| 	AtTrfEqpto(SD2->D2_CODFAB,SD2->D2_LOJAFA,SD2->D2_COD,SDB->DB_NUMSERI,SD2->D2_CLIENTE,SD2->D2_LOJA) },;
											   		{|| !Empty(SDB->DB_NUMSERI)},;
													{|| 	xFilial("SDB")	==	SDB->DB_FILIAL .And.;
														SD2->D2_COD		==	SDB->DB_PRODUTO .And.;
														SD2->D2_LOCAL  == SDB->DB_LOCAL .And.;
														SD2->D2_NUMSEQ == SDB->DB_NUMSEQ .And.;
														SD2->D2_DOC		== SDB->DB_DOC .And.;
														SD2->D2_SERIE	== SDB->DB_SERIE .And.;
														SD2->D2_CLIENTE== SDB->DB_CLIFOR .And.;
														SD2->D2_LOJA	== SDB->DB_LOJA },,,.T.)
										EndIf
									EndIf
								EndIf
							EndIf
						Next
						//³Efetua a Atualização da Assistência Técnica Somente para os países localizados
						//³Quando é uma conduce de devolução ou invoice de crédito Trata tanto quando tem localização como também quando não tem localização
						For nI := 1 To Len(aRecnoI)
							If aCfgNf[SAliasCols]=="SD1" .AND. (cPaisLoc $ "ARG|PAR|URU|CHI|MEX|EUA|POR|BOL")
								//³ Estorno da transf. da base instalada - Field Service     ³
								If (SF4->F4_ESTOQUE == "S" .And. SF4->F4_ATUTEC == "S")
									SD1->(MsGoTo(aRecnoI[nI,1]))
									SD2->(DbSetOrder(3))
									If SD2->(MsSeek( cFilSD2 + SD1->D1_NFORI + SD1->D1_SERIORI + SD1->D1_FORNECE + SD1->D1_LOJA + SD1->D1_COD + SD1->D1_ITEMORI ))
										//³Verifica se a nota veio de um remito/conduce.³
										If !Empty(SD2->D2_REMITO)
											//³Localiza a conduce dela, pois o movimento de distribuição (SDB) é a dona do movimento.³
											If SD2->(MSSeek(cFilSD2+SD2->D2_REMITO+SD2->D2_SERIREM+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMREM))
												MaEstNfAA3()
											EndIf
										Else
											MaEstNfAA3()
										EndIf
									EndIf
								EndIf
							EndIf
						Next
						//³Libera Faturas de import.  ³
						If lRet .AND. aCfgNf[SAliasCols] == "SD1"
							If !Empty(SF1->F1_HAWB)
								If lBloqImp
								   BloqFatImp()
								EndIf
							EndIf
			            EndIf
						If lRet
							//³Grava Impostos³
							If aCfgNf[SaAtualiza][SlAtuImp] .AND. (!l103Class .OR. (SF1->F1_TIPO_NF=="9" .AND. SuperGetMV("MV_DESPSD1",,"N")=="S"))
								If !GravaImposto(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aClone(aCpItens),aClone(aCitens),aCfgNf[ScTipoDoc],nRecnoC,aRecCols,.F.)
									lRet := .F.
								EndIf
							EndIf
							If lRet
								//³Acerta livro Fiscal³
								If aCfgNf[SaAtualiza][SlAtuLF]
									MaFisAtuSF3(1,IIf(aCfgNf[SAliasHead]=="SF1","E","S"),nRecnoC,aCfgNf[SAliasHead])
									SF3->(MsUnLock())
			                        //#PORTUGAL#
									/*If cPaisLoc == "PTG" .And. lHashPTG
			                           aAreaAnt:=GetArea()
			                           DbSelectArea("SF3")
			                           aSF3:=GetArea()
			                           DbSetOrder(4) // F3_FILIAL+F3_CLIEFOR+F3_LOJA+F3_NFISCAL+F3_SERIE
			                           cChSF3:=xFilial("SF3")
			                           cCorrelat:=IF(aCfgNf[SAliasHead]=="SF1","F1_FORNECE","F2_CLIENTE")
			                           cChSF3+=&cCorrelat
			                           cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA"
			                           cChSF3+=&cCorrelat
			                           cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC"
			                           cChSF3+=&cCorrelat
			                           cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE"
			                           cChSF3+=&cCorrelat
			                           cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOCMAN"
			                           cDocMan:=&cCorrelat
			                           cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERMAN"
			                           cSerMan:=&cCorrelat
			                           cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_EMIMAN"
			                           dEmiMan:=&cCorrelat
			                           cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_HASH"
			                           cCorrelat:=&cCorrelat
			                           cCorlatHr:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_HORA"
			                           cCorlatHr:=&cCorlatHr
			                           DbSeek(cChSF3)
						               While !SF3->(EOF()) .AND. F3_FILIAL+F3_CLIEFOR+F3_LOJA+F3_NFISCAL+F3_SERIE==cChSF3 .And. F3_FORMUL == "S"
						               	  RecLock("SF3",.F.)
			                              Replace F3_HASH With cCorrelat
			                              Replace F3_HORA With cCorlatHr
			                              Replace F3_VERHASH With "1"
			                              If SF3->(FieldPos("F3_DOCMAN")) > 0
			                                 Replace F3_DOCMAN With cDocMan
			                              EndIf
			                              If SF3->(FieldPos("F3_SERMAN")) > 0
			                                 Replace F3_SERMAN With cSerMan
			                              EndIf
			                              If SF3->(FieldPos("F3_EMIMAN")) > 0
			                                 Replace F3_EMIMAN With dEmiMan
			                              EndIf
			                              MsUnlock()
			                              DbSkip()
			                           End
			                           RestArea(aSF3)
			                           RestArea(aAreaAnt)
			                        EndIf*/
									//Leandro Prado - 06/03/2014 - Controle de Ponto de venda para argentina
									If (cPaisLoc == "ARG")
										ArgGeraLF(lFolios,aCfgNF)
									EndIf
									If lUsaCor     //atualiza o numero correlativo
										aAreaAnt:=GetArea()
										DbSelectArea("SF3")
										aSF3:=GetArea()
										DbSetOrder(1)
										cChSF3:=xFilial("SF3")
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DTDIGIT"
										cChSF3+=DTOS(&cCorrelat)
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC"
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE"
										cChSF3+=&cCorrelat
										cCorrelat:=IF(aCfgNf[SAliasHead]=="SF1","F1_FORNECE","F2_CLIENTE")
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA"
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_NUMCOR"
										cCorrelat:=&cCorrelat
										dbSeek(cChSF3)
										While !SF3->(EOF()) .AND. F3_FILIAL+DTOS(F3_ENTRADA)+F3_NFISCAL+F3_SERIE+F3_CLIEFOR+F3_LOJA==cChSF3
											RecLock("SF3",.F.)
											Replace F3_NUMCOR With cCorrelat
											MsUnlock()
											DbSkip()
										End
										RestArea(aSF3)
										RestArea(aAreaAnt)
									Endif
									If lGerarCFD .And. !(cPaisLoc $ "COL|PAR")		//Comprovante fiscal digital
										aAreaAnt:=GetArea()
										DbSelectArea("SF3")
										aSF3:=GetArea()
										DbSetOrder(1)
										cChSF3:=xFilial("SF3")
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DTDIGIT"
										cChSF3+=DTOS(&cCorrelat)
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC"
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE"
										cChSF3+=&cCorrelat
										cCorrelat:=IF(aCfgNf[SAliasHead]=="SF1","F1_FORNECE","F2_CLIENTE")
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA"
										cChSF3+=&cCorrelat
										cAproFol:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_APROFOL"
										cCertFol:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_CERTFOL"
										MsSeek(cChSF3)
										While !SF3->(EOF()) .AND. F3_FILIAL+DTOS(F3_ENTRADA)+F3_NFISCAL+F3_SERIE+F3_CLIEFOR+F3_LOJA==cChSF3
											RecLock("SF3",.F.)
											Replace F3_APROFOL With &(cAproFol)
											Replace F3_CERTFOL With &(cCertFol)
											MsUnlock()
											DbSkip()
										End
										RestArea(aSF3)
										RestArea(aAreaAnt)
									Endif
									//³Ponto de Entrada apos gravacao do livro fiscal³
									If cPaisLoc == 'EUA'
										cPe	:= SF3ZONFIS(aCfgNf, cFunname)
									EndIf

									cPe	:= LocxPE(5)
									
									If !Empty(cPE)
										ExecBlock(cPE,.F.,.F.)
									EndIf
									//³Controle de Folios  ³
									If lContrFol .And. (!cPaisLoc $'ARG|EQU|VEN|PER|DOM')
										aAreaAnt:=GetArea()
										DbSelectArea("SF3")
										aSF3:=GetArea()
										DbSetOrder(1)
										cChSF3:=xFilial("SF3")
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DTDIGIT"
										cChSF3+=DTOS(&cCorrelat)
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC"
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE"
										cChSF3+=&cCorrelat
										cCorrelat:=IF(aCfgNf[SAliasHead]=="SF1","F1_FORNECE","F2_CLIENTE")
										cChSF3+=&cCorrelat
										cCorrelat:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA"
										cChSF3+=&cCorrelat
										cNumAut :=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_NUMAUT"
										cCodCtr:=aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_CODCTR"
										MsSeek(cChSF3)
										While !SF3->(EOF()) .AND. F3_FILIAL+DTOS(F3_ENTRADA)+F3_NFISCAL+F3_SERIE+F3_CLIEFOR+F3_LOJA==cChSF3
											RecLock("SF3",.F.)
											Replace F3_NUMAUT  With &(cNumAut)
											Replace F3_CODCTR With &(cCodCtr)
											MsUnlock()
											DbSkip()
										End
										RestArea(aSF3)
										RestArea(aAreaAnt)
										//³Gera Numero de Autorizacao e Codigo de Controle ³
										aDados[1] := &(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")
										aDados[2] := &(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_ESPECIE")
										aDados[3] := &(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC")
										If aCfgNF[SAliasHead] == "SF2"
											If Alltrim(aDados[2])$"NDI/NCP"
												aDados[4] := Posicione("SA2",1,xFilial("SA2")+SF2->F2_CLIENTE+SF2->F2_LOJA,"A2_CGC")
											Else
												aDados[4] := Posicione("SA1",1,xFilial("SA1")+SF2->F2_CLIENTE+SF2->F2_LOJA,"A1_CGC")
											Endif
											aDados[5] := DtoS(SF2->F2_EMISSAO)
											aDados[6] := IIf(Alltrim(SF2->F2_ESPECIE)=="NF",Round(SF2->F2_VALBRUT,0),SF2->F2_VALBRUT)
										Else
											If Alltrim(aDados[2])$"NDE/NCC"
												aDados[4] := Posicione("SA1",1,xFilial("SA1")+SF1->F1_FORNECE+SF1->F1_LOJA,"A1_CGC")
											Else
												aDados[4] := Posicione("SA2",1,xFilial("SA2")+SF1->F1_FORNECE+SF1->F1_LOJA,"A2_CGC")
											Endif
											aDados[5] := DtoS(SF1->F1_EMISSAO)
											aDados[6] := IIf(Alltrim(SF1->F1_ESPECIE)=="NF",Round(SF1->F1_VALBRUT,0),SF1->F1_VALBRUT)
										Endif
										aRetCF := RetCF(aDados)
										//³Grava Numero de Autorizacao e Codigo de Controle³
										//³Tabelas: SF1 e/ou SF2 e SF3                     ³
										If !Empty(aRetCF[1])
											If aCfgNF[SAliasHead] == "SF2"
												RecLock("SF2",.F.)
												SF2->F2_NUMAUT	:= aRetCF[1]	//Numero de Autorizacao
												SF2->F2_CODCTR	:= aRetCF[2]	//Codigo de Controle
												SF2->F2_LIMEMIS	:= aRetCF[3]	//Data Limite de Emisao
												MsUnLock()
												cKey := xFilial("SF3")+SF2->(DtoS(F2_DTDIGIT)+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA)
											Else
												RecLock("SF1",.F.)
												SF1->F1_NUMAUT	:= aRetCF[1]	//Numero de Autorizacao
												SF1->F1_CODCTR	:= aRetCF[2]	//Codigo de Controle
												If cPaisLoc == "BOL" .and. cFunName $ "MATA143"
												 	GrvSF1Bol()
												Else
													If Empty(aRetCF[2]).AND. !Empty(M->F1_CODCTR)
													  	SF1->F1_CODCTR := M->F1_CODCTR
													EndIf
													If !Empty(M->F1_NUMAUT)
														SF1->F1_NUMAUT := M->F1_NUMAUT
													EndIf
												EndIf
												MsUnLock()
												cKey := xFilial("SF3")+SF1->(DtoS(F1_DTDIGIT)+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA)
											Endif
										Else
											If aCfgNF[SAliasHead] == "SF2"
												aRetCF[1] := SF2->F2_NUMAUT		//Numero de Autorizacao
												aRetCF[2] := SF2->F2_CODCTR		//Codigo de Controle
												aRetCF[3] := SF2->F2_LIMEMIS	//Data Limite de Emisao
												cKey := xFilial("SF3")+SF2->(DtoS(F2_DTDIGIT)+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA)
											Else
												If cPaisLoc == "BOL" .and. cFunName $ "MATA143"
													GrvSF1Bol()
												Else
													aRetCF[1] := SF1->F1_NUMAUT		//Numero de Autorizacao
													aRetCF[2] := SF1->F1_CODCTR		//Codigo de Controle
												Endif
												cKey := xFilial("SF3")+SF1->(DtoS(F1_DTDIGIT)+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA)
											EndIf
										Endif
										If !(cPaisLoc $ 'BOL')
											aAreaAnt:= GetArea()
											aSF3	:= SF3->(GetArea())
											dbSelectArea("SF3")
											dbSetOrder(1)
											If MsSeek(cKey)
												While !SF3->(EOF()) .AND. SF3->(F3_FILIAL+DTOS(F3_ENTRADA)+F3_NFISCAL+F3_SERIE+F3_CLIEFOR+F3_LOJA) == cKey
													RecLock("SF3",.F.)
													SF3->F3_NUMAUT := aRetCF[1]		//Numero de Autorizacao
													SF3->F3_CODCTR := aRetCF[2]		//Codigo de Controle
													If aCfgNF[SAliasHead] == "SF1"
														If Empty(aRetCF[2]).AND. !Empty(M->F1_CODCTR)
															SF3->F3_CODCTR := M->F1_CODCTR
														EndIf
														If !Empty(M->F1_NUMAUT)
															SF3->F3_NUMAUT := M->F1_NUMAUT
														EndIf
													EndIf
													MsUnlock()
													dbSkip()
												Enddo
											Endif
											RestArea(aSF3)
											RestArea(aAreaAnt)
										EndIf
									Endif
									/*Actualización SF3 - País Bolivia*/
									If cPaisLoc == "BOL"
										LxGrvLFBol(aCfgNF, aRetCF, lContrFol, cKey, cFunname)
									EndIf
								EndIf
								// Controle de Honorarios Chile
								If cPaisLoc == "CHI"
									LxGrvLFChi(aCfgNf[SAliasHead]) //Actualiza SF3
								Endif
								//³Verifica se e necessario inicializar as variaveis referentes a gravacao de impostos³
								If !MaFisFound()
									If !InicializaFis(MontaHeader(aCpItens),aCItens,aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[ScTipoDoc])
										lRet := .F.
									EndIf
								EndIf
								If cPaisLoc == "EUA" .AND. lLocxAuto .AND. lMultNat.AND. lProrrCC .AND. laRatEvEz // rutina automatica multinaturaleza y prorrateo de centros de costo EUA
									Multiauto(@aColsSEV,@aHeadSEV,"SE2","SEV") //Obtiene estructura encabezado y detalle para SEV
									If !FinSEVAut(aRatEvEz,@aColsSEV,@aHeadSEV) // valida valores SEV y SEZ y asigna a tabla temporal
										 lRet := .F.
									Endif
								EndIf
								If lRet
									If If(lFacImport,!lEICFinanc,.T.)
										//³Atualiza Financeiro - Comissoes³
										If !Empty(aCfgNf[ScEspecie]) .AND. !Empty(aCfgNf[ScOpFin]) .AND. aCfgNf[SaAtualiza][SlAtuFina]
											a100CliFor := &(cPrefC+IIf(aCfgNf[SAliasHead]=="SF1","_FORNECE","_CLIENTE"))
											nValor 	   := MaFisRet(,"NF_BASEDUP")
											//³Ponto de Entrada que permite alterar o valor total da Nota para base de calculos das duplicatas³
											cPe	:=	LocxPE(6)
											If !Empty(cPE)
												nValor := ExecBlock(cPe,.F.,.F.)
												If nValor <> MaFisRet(,"NF_BASEDUP")
													MaFisAlt(cPe,nValor)
												EndIf
											EndIf
											//Quando houver adiantamento vinculado devera gerar financeiro
											If nValor>0 .OR. (cPaisLoc  $ "MEX|PER" .AND. MaFisRet(,"NF_ADIANT") > 0) //jgr
												GravaFina(aCfgNf[SAliasHead],aCfgNf[ScAliasFin],aDupl,aCfgNf[ScEspecie],aCfgNf[ScOpFin],aCfgNf[ScTipoDoc],aFin,aRecnoI,aRecnoSE1)
											EndIf
										EndIf
									Endif
								EndIf //lRet
								//Efetua a atualizacao do Ativo Imobilizado - (SN1-SN2-SN3)
								If lRet
									If aCfgNf[SnTipo] == 10 .Or. aCfgNf[SnTipo] == 60	//Apenas doc. entrada
										nI := 0
										nV := 0
										lBENSATF := .T.
										aAreaASD1:=SD1->(GetArea())
										aAreaASF4:=SF4->(GetArea())
										aAreaASF9:=SF9->(GetArea())
										For nI := 1 to Len(aRecnoI)
											SD1->(MsGoTo(aRecnoI[nI,1]))
											SF9->(DbSetOrder(1))
											SF9->(MsSeek(cFilSF9+SD1->D1_CODCIAP))
											SF4->(DbSetOrder(1))
											SF4->(MsSeek(cFilSF4+SD1->D1_TES))
											If SF4->F4_ATUATF == "S"
												If Type("inclui") == "U"
													inclui := .T.	//Private utilizada na funcao abaixo que e do padrao
												EndIf
												If Type("altera") == "U"
													altera := .F.  //Private utilizada na funcao abaixo que e do padrao
												EndIf
												cBaseATF := ""
												If lBENSATF .And. SF4->F4_BENSATF == "1" .And. SD1->D1_QUANT >= 1
													If cPaisLoc == "PER"
														Private aCampos    := {}
														Private aBkpHeader := {}
														Private aBkpAcols  := {}
													EndIf
													For nV := 1 To Int(SD1->D1_QUANT)
														//#Brasil#
														//If cPaisLoc == "BRA"
															//a103GrvAtf(1,@cBaseATF,StrZero(nV,Len(SN1->N1_ITEM)),SD1->D1_CODCIAP,IIf(SF4->F4_CIAP=="S".AND.SD1->D1_VALICM>0.AND.SF4->F4_CREDICM=="S",SF9->F9_VALICMS,0))
														//Else
															If !lActFjRm
																a103GrvAtf(1,@cBaseATF,StrZero(nV,Len(SN1->N1_ITEM)),"",0,,,aRatCC)
																If cPaisloc	== "RUS"
																	cNumb+=cBaseATF +", "
																	cBaseATF := ""
																EndIF
															Endif
														//EndIf
													Next
												Else
													//#Brasil#
													//If cPaisLoc == "BRA"
														//a103GrvAtf(1,@cBaseATF,StrZero(nI,Len(SN1->N1_ITEM)),SD1->D1_CODCIAP,IIf(SF4->F4_CIAP=="S".AND.SD1->D1_VALICM>0.AND.SF4->F4_CREDICM=="S",SF9->F9_VALICMS,0))
													//Else
														If !lActFjRm
															a103GrvAtf(1,@cBaseATF,StrZero(nI,Len(SN1->N1_ITEM)),"",0,,,aRatCC)
															If cPaisLoc == "RUS"
																cNumb+=cBaseATF +", "
															EndIf
														EndIf
													//EndIf
												Endif
											EndIf
											Next nI
											RestArea(aAreaASD1)
											RestArea(aAreaASF4)
											RestArea(aAreaASF9)
											//Ajuste de valor do bem por nota de crédito (Baixa)
										ElseIf AllTrim(cEspecie) $ "NCP|NDI" .And. lIntNtCRDB
											aAreaASD2:=SD2->(GetArea())
											aAreaASF4:=SF4->(GetArea())
											For nI := 1 To Len(aRecnoI)
												SD2->(MsGoTo(aRecnoI[nI,1]))
												SF4->(DbSetOrder(1))
												SF4->(MsSeek(cFilSF4+SD2->D2_TES))
												If SF4->F4_ATUATF == "S"
													lRet := a103GrvAtf( 100 )
												EndIf
											Next nI
											RestArea(aAreaASF4)
											RestArea(aAreaASD2)
											//Ajuste de valor do bem por nota de débito (Incorporação)
										ElseIf AllTrim(cEspecie) $ "NDP|NCI" .And. lIntNtCRDB
											aAreaASD1:=SD1->(GetArea())
											aAreaASF4:=SF4->(GetArea())
											cBaseATF := ""
											For nI := 1 To Len(aRecnoI)
												SD1->(MsGoTo(aRecnoI[nI,1]))
												SF4->(DbSetOrder(1))
												SF4->(MsSeek(cFilSF4+SD1->D1_TES))
												If SF4->F4_ATUATF == "S"
													lRet := a103GrvAtf( 101, @cBaseATF,,,"",0,, aRatCC )
												EndIf
											Next nI
											RestArea(aAreaASF4)
											RestArea(aAreaASD1)
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		If lInclui .And. aCfgNF[SAliasHead] == "SF1" .And. !("NC" $ SF1->F1_ESPECIE)
			If cPaisLoc $ "VEN|COS"
				aDadSFE:={}
				If cPaisloc $ "VEN"
					If (SF1->F1_VALIMP2+SF1->F1_VALIMP3+SF1->F1_VALIMP4)>0 .OR. SF1->F1_VALIMP6>0
				   		Aadd(aDadSFE,{.F.,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE})
				   		FGrvCrt(1,aDadSFE)
				   	EndIf
			   	Else
			   		If cPaisloc == "COS"
				   	    If SF1->F1_VALIMP5 >0 ///retencao de IR
							Aadd(aDadSFE,{.F.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RIR",0,0,0,SF1->F1_ESPECIE})
				   			GrvRetSFE(1,aDadSFE,.F.,.T.)
				   		EndIf
				   	EndIf
			   	EndIf
			 EndIf
		Endif
		If lInclui .And. aCfgNF[SAliasHead] == "SF2" .And. ("NCP" $ SF2->F2_ESPECIE)
			If cPaisLoc $ "VEN"
				aDadSFE:={}
				If (SF2->F2_VALIMP2+SF2->F2_VALIMP3+SF2->F2_VALIMP4)>0 .OR. SF2->F2_VALIMP6>0
				   	Aadd(aDadSFE,{.F.,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE})
				   	FGrvCrt(2,aDadSFE)
			   	Endif
			EndIf
		Endif
		If lRet .And. cPaisLoc == "EQU"
			lRet := LxGrvNfEqu(lInclui, aCfgNF, nNFTipo, cDoctoId, cNomeCli, IIf(Type('aLlaveOrg') <> 'U', aLlaveOrg, {}), IIf(Type("cFunName")<>"U", cFunName, Funname()))
		EndIf
		If lRet .And. cPaisLoc == "CHI"
			lRet := LxGrvNfChi(aCfgNF, lInclui)
		EndIf
		//factura de entrada para Mexico y actualiza nuevo folio fiscal
		If cPaisLoc == "MEX"
			xGrvCabMex(aCfgNF, nNFTipo, cPathXML, IIf(Type("cFunName")<>"U", cFunName, ""))
		EndIf
		//Notas Fiscais NF, RCTI, NC e ND conforme regra LxVldLim precisam de identificacao
		If cPaisLoc == "URU"
			GravaNFGURU(aCfgNF, lInclui)
		EndIf
		If cPaisLoc=="ARG" .And. Alltrim(cEspecie) $ "NF|NCP|NDP" .and. !aCfgNf[SlFormProp] .and. SF1->(ColumnPos("F1_CC")) > 0 .and. SF2->(ColumnPos("F2_CC")) > 0
			If !Empty(SF1->F1_CC) .OR. !Empty(SF2->F2_CC)
				GRAVACC(aCfgNf[ScCliFor],aCfgNF[SAliasHead],cEspecie)
			EndIf
		EndIf
		If cPaisLoc == "ARG" .AND. GetMV("MV_EASY")=="S" .AND. Alltrim(cEspecie) == "NCP"
			lQtdZero  := .T.
			aCusto    := {}
			aCM       := {}
			cTesEIC   := ""
			nTxCusEIC := 0.00
			aImposto  := {}
			nPosSWN   := 0
			lITEMSWN  := .T.
			lDOCSWN	  := .T.
			DbSelectArea("SWN")
			DbSetOrder(2)
			If dbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
			   While !Eof() .AND.;
			   	  WN_FILIAL == cFilSWN .AND.;
				  WN_DOC == SF2->F2_DOC .AND.;
				  WN_SERIE == SF2->F2_SERIE
				  SD2->(DbSetOrder(3))
				  SD2->(dbSeek(cFilSD2+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA))
				  If WN_TIPO_NF == "N"
				     // Gravar no SD3 a 'DE8' para o Produto
				     RecLock('SD3',.T.)
				     Replace D3_FILIAL  With cFilSD3
					 Replace D3_COD	   With SWN->WN_PRODUTO
					 Replace D3_GRUPO   With SB1->B1_GRUPO
					 Replace D3_TIPO    With SB1->B1_TIPO
					 Replace D3_LOCAL   With SWN->WN_LOCAL
					 Replace D3_UM	   With SB1->B1_UM
					 Replace D3_CONTA   With SB1->B1_CONTA
					 Replace D3_DOC	   With SWN->WN_DOC
					 Replace D3_QUANT   With 0.00
					 Replace D3_CF	   With 'RE8' 	//-- Identifica Movimentacao com Origem no SIGAEIC
					 Replace D3_TM	   With '999'
					 Replace D3_USUARIO With SubStr(cUsuario,7,15)
					 Replace D3_NUMSEQ  With SD2->D2_NUMSEQ
					 Replace D3_EMISSAO With dDataBase
					 Replace D3_CHAVE   With 'E9' 	//-- N„o Alterar !!!
					 Replace D3_QTSEGUM With SWN->WN_QTSEGUM
					 Replace D3_SEGUM   With SB1->B1_SEGUM
					 Replace D3_IDENT   With ""		//cNumSeqD1  //-- Diferencia as Movimentacoes
					 If lDOCSWN
						Replace D3_DOCSWN  With SWN->WN_PO_NUM
					 EndIf
					 If lITEMSWN
						Replace D3_ITEMSWN With SWN->WN_ITEM
					 EndIf
					 MsUnLock()
			         aCusto := {SWN->WN_VALOR,0,0,0,0}
					 SWW->(DbSetOrder(1))
					 If SWW->(MsSeek(cFilSWW+SF2->F2_DOC+SF2->F2_SERIE))
						While ! SWW->(EOF()).AND.SWW->WW_FILIAL==cFilSWW .AND.;
						    SWW->WW_NF_COMP == SF2->F2_DOC     .AND.;
					       	SWW->WW_SE_NFC  == SF2->F2_SERIE
							SWD->(DbSetOrder(3))
				       		If SWD->(MsSeek(cFilSWD+Left(SWW->WW_DESPESA,3)+SWW->WW_NF_COMP+SWW->WW_HAWB))
				       		   cTesEIC   := SWD->WD_TES
							   nTxCusEIC := SWD->WD_TX_MOE
				       		   Exit
				       		EndIf
				       		SWW->(DbSkip())
						End
					 EndIf
					 aImpostos := TesImpInf(cTesEIC) //O tes é o mesmo para todos os itens do SWN
					 For nY:=1 to Len(aImpostos)
					 	nPosSWN :=SWN->(FieldPos("WN_"+Substr(aImpostos[nY][2],4)))
						If nPosSWN > 0
							If ( aImpostos[nY][3]+aImpostos[nY][5] == "SN" )
								aCusto[1][1]+= SWN->(FieldGet(nPosSWN))
							ElseIf ( aImpostos[nY][3]+aImpostos[nY][5] == "NS" )
								aCusto[1][1]-= SWN->(FieldGet(nPosSWN))
							EndIf
						Endif
					 Next nY
					 aCM := AClone(aCusto)
					 For nI := 1 To Len(aCusto)
					 	cMoeda := Str(nI,1)
						If nI > 1 .AND. !Empty(GetMV("MV_MOEDA"+cMoeda))
						    If Empty(nTxCusEic)
						    	nTxCusEic := RecMoeda(dDataBase,nI)
						    EndIf
						    aCM[nI] := aCM[1]/nTxCusEic
						EndIf
					 Next nI
					 aCusto := GravaCusD3(aCM,,,,lQtdZero)
					 B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,.T.)
				EndIf
				DbSelectArea("SWN")
				DbSkip()
			   End
			EndIf
		EndIf
		If lFacImport .AND. l103Class   //Geracao de remisiones para notas de import.
		    DbSelectArea("SF1")
		    LocXGerRem(,@aRecIMP)
		Endif
		//PE para integracao com Celerina
		cPe	:=	LocxPE(7)
		If lRet .AND. !Empty(cPE)
			ExecBlock(cPE,.F.,.F.)
		EndIf
		//PE apos a gravacao de cabecalho da nota a apos as atualizacoes gerais
		cPe	:=	LocxPE(8,@cNomePE)
		//Para a localizacao Mexico, sera processada a funcao do ponto de entrada SF2460I no padrao.
		If cPaisLoc == "MEX" .AND. Substr(cPrefC,1,3) == "SF2"
			RcFatMex()
		Endif
		If lRet .AND. !Empty(cPE)
			ExecBlock(cPE,.F.,.F.)
		EndIf
		If cPaisLoc == "EUA"
			LxGrvNfEUA(aCfgNf, aCitens, cEspecie, cFunName)
		EndIf
		//Acerta a numeracao da NF
		If lRet
			If aCfgNf[SlFormProp] .OR. (cPaisLoc == "COL" .AND. (lDocSp .OR. aCfgNF[SnTipo] == 22 .OR. aCfgNF[SnTipo] == 23 ) .AND. cFunName $ "MATA101N|MATA466N"  )
				If cPaisLoc <> "EUA"
					lRet := AtuNumNF(&(cPrefC+"_DOC"),&(cPrefC+"_SERIE"),aCfgNf[ScTipoDoc],aCfgNf[ScCliFor])
				EndIf
				If lRet .And.  cPaisLoc=="VEN" .And.    SF1->(ColumnPos("F1_FORMLIB")) > 0 .and.  SF2->(ColumnPos("F2_FORMLIB")) > 0
					nMumAt:= AtuNumFL(&(cPrefC+"_FORMLIB"))
					If nMumAt<> &(cPrefC+"_FORMLIB")
						If aCfgNF[SAliasHead] == "SF2"
							SF2->(RecLock("SF2",.F.))
							SF2->F2_FORMLIB:= nMumAt
							SF2->(MsUnlock())
						Else
							SF1->(RecLock("SF1",.F.))
							SF1->F1_FORMLIB:= nMumAt
							SF1->(MsUnlock())
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		If FwIsInCallStack("MATA101N") // Factura de Entrada
			aRetInt := FwIntegDef("MATA101N")	//-- Invoice
			If Valtype(aRetInt) == "A"
				If Len(aRetInt) == 2
					If !aRetInt[1]
						If Empty(AllTrim(aRetInt[2]))
							cMsgRet := "Verificar problema no Monitor EAI"
						Else
							cMsgRet := AllTrim(aRetInt[2])
						Endif
						Aviso("Atenção",cMsgRet,{"Ok"},3)
						lRet:= .F.
					Endif
				Endif
			EndIf
		EndIf
		If FwIsInCallStack("MATA466n") // Nota de Debito/Credito
			aRetInt := FwIntegDef("MATA466n")	//-- Invoice
			If Valtype(aRetInt) == "A"
				If Len(aRetInt) == 2
					If !aRetInt[1]
						If Empty(AllTrim(aRetInt[2]))
							cMsgRet := "Verificar problema no Monitor EAI"
						Else
							cMsgRet := AllTrim(aRetInt[2])
						Endif
						Aviso("Atenção",cMsgRet,{"Ok"},3)
						lRet:= .F.
					Endif
				Endif
			EndIf
		EndIf
	If lRet
		If cPaisLoc == "MEX" .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0 .And. SF2->F2_TPCOMPL == "S" .And. (cFunName == "MATA467N" .Or. FWIsInCallStack("MATA467N"))
			xCartPorte(oModelAct, cFunName, lLocxAuto, aCartaPorte, @lRet)
		EndIf
		If FunName() <> "MATA466N" .And. lGerarCFD .And. lRet
			If aCfgNF[SAliasHead] == "SF2"
				lGenXML := CFDGerXML(SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE,(aGerarCFD[1] == "1" .AND. !lLocxAuto),!lLocxAuto)
			Else
				lGenXML := CFDGerXML(SF1->F1_ESPECIE,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE,(aGerarCFD[1] == "1" .AND. !lLocxAuto),!lLocxAuto) .and. cFunName == "MATA465N"
			EndIf
			If lGenXML
				cPe	:=	LocxPE(67)
				If !Empty(cPE)
					ExecBlock(cPE,.F.,.F.)
				Else
					If __lPyme .And. ExistBlock( "LOCXS367" , .F. , .T. )
						Execblock( "LOCXS367" , .F. , .F. )
					EndIf
				EndIf
			EndIf
		Endif
	Endif
	If cPaisLoc == "BOL" .and. Type("aGerarCFD") == "A" .and. Len(aGerarCFD) > 0 .and. aGerarCFD[1] <> "0" .and. FindFunction("FACTONBOL")
		FACTONBOL(aCfgNF[SAliasHead])
	EndIf
	//Finalizando Transacao
	If !lRet
		DisarmTransaction()
	EndIf

End transaction

If lRet
	/*Chamar Função DigLot [Permite endereçar manualmente os itens da NF]*/
	IF (lVer116 .AND. lDistMov .And. Len(aDigEnd) > 0).and. (nTipo = 10 .Or. nTipo = 60)
   		A103DigEnd(aDigEnd)
	endif
EndIf
If  (cPaisLoc == "PAR"  .AND. cFunName =="MATA101N" .AND. lAutoFact )
	 AtuNumNF(&(cPrefC+"_DOC"),&(cPrefC+"_SERIE"),aCfgNf[ScTipoDoc],aCfgNf[ScCliFor])
ENDIF
//Destrava todos os registros que possam estar eventualmente travados.
MsUnlockAll()
//³Tratamento a ser considerado para o Peru quanto utilizar conceito de Serie-2 ³
If cPaisLoc=="PER"
	GrvSer2Per(cPrefC)
EndIf
 If !aCfgNF[SlRemito] .And.   cPaisLoc=="VEN" .And.    SF1->(ColumnPos("F1_FORMLIB")) > 0  .and.  SF2->(ColumnPos("F2_FORMLIB")) > 0 .and. SF3->(ColumnPos("F3_FORMLIB")) > 0
	If cPrefC=="SF1->F1"
		cCompSF3:=SF1->(F1_FILIAL+F1_FORNECE+F1_LOJA+F1_DOC+F1_SERIE)
	Else
		cCompSF3:=SF2->(F2_FILIAL+F2_CLIENTE+F2_LOJA+F2_DOC+F2_SERIE)
	EndIf
	DbSelectArea("SF3")
	SF3->(DbGotop())
	DbSetOrder(4)
	DbSeek(cCompSF3)
	Do While !Eof() .And. SF3->(F3_FILIAL+F3_CLIEFOR+F3_LOJA+F3_NFISCAL+F3_SERIE)==cCompSF3
		RecLock("SF3",.F.)
		SF3->F3_FORMLIB := &(cPrefC+"_FORMLIB")
		MsUnLock()
		DbSkip()
	EndDo
EndIf
//Contabilizacao
//A contabilizacao pode ser desabilitada atraves do parametro aAtualiza, caso nao seja, obedece
//a configuracao das perguntas no parametro aPergs
If lRet .AND. aCfgNf[SaAtualiza][SlCtbilOL] .AND. aCfgNf[SaPergs][SlGerCtbil]
	If cPaisLoc == "MEX"
		xGenXmlMex(lGerarCFD, cPrefC)
	EndIf
	If ValType(apergs) <> "A" .Or. (ValType(apergs) == "A" .And. len(Apergs) < Len(aCfgNf[SaPergs]))
		Apergs:=aCfgNf[SaPergs]
	EndIf
	IF aCfgNf[SlRemito] .AND. (aCfgNf[SnTipo] == 54 .or. aCfgNf[SnTipo] == 64) .AND. ValType("M->F2_TIPORET")=="C" .AND. M->F2_TIPORET == "1"
		CtbilNF(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecnoC,aRecnoI,aCfgNf[SaLancPadC],aCfgNf[SaLancPadI],aCfgNf[SaPergs][SlVerCtbil],aCfgNf[SaPergs][SlAglutina])
	Else
		CtbilNF(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecnoC,aRecnoI,aCfgNf[SaLancPadC],aCfgNf[SaLancPadI],aPergs[SlVerCtbil],aPergs[SlAglutina])
	Endif
EndIf
//³PCO	³
If lRet .And. !(cPaisLoc $ "MEX|COL|PER|EQU")
	PcoLancto(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecnoC,aRecnoI,aCfgNf[SaLancPCO][1],aCfgNf[SaLancPCO][2],aCfgNf[SaLancPCO][4],aCfgNf[SaLancPCO][3], .T./*lInclui*/, .F./*lDeleta*/)
EndIf
//³Chamada da funcao de compensacao financeira quando for NCC e NDE³
If lRet .AND. (aCfgNf[SnTipo] == 4 .OR. aCfgNf[SnTipo] == 5) .AND. aCfgNf[ScEspecie] $ MV_CRNEG .AND. lTela .And. cCompOnL == "3"
	If cCompNc	== "1"
		CompensaNCC(aCfgNf[SAliasCols],aCfgNf[ScEspecie],aCfgNf[SaPergs])
	ElseIf cCompNc	== "3" .And. MsgYesNo(STR0035,STR0036) //"Deseja fazer agora a compensacao do titulo gerado?"###"Compensacao de titulos"
		If SuperGetMV("MV_FINCTMD",.T.,1) == 1
			Fina087a("","",{})
		Else
			SetFunName("FINA846")
				FINA840()
			SetFunName(cFunName)
		EndIf
	EndIf
EndIf
//³Se for utilizado o GetSXENum() confirma o numero.
If __lSX8
	ConfirmSX8()
Endif
//³Verifica se deve finalizar as variaveis de gravacao de impostos³
If !lTela .AND. MaFisFound() .and. (!aCfgNF[SlRemito] .or. (cPaisloc =="CHI" .and. funname() == "MATA468N" .and. aCfgNF[SlRemito] .and. aCfgNF[ScEspecie] == "RET" ))
	MaFisEnd()
Endif
//³Ponto de entrada apos todas as gravacoes e apos fechamento da transacao³
cPe	:=	LocxPE(11,@cNomePE)
If cPaisLoc == "EUA"
	GFinTrsEUA()
Endif
//³Para a localizacao Mexico, sera processada a funcao do ponto de entrada MT100AGR no padrao³
If cPaisLoc == "MEX" .AND. Substr(cPrefC,1,3) == "SF1"
	PgComMex()
Endif
If lRet .AND. !Empty(cPE)
	ExecBlock(cPE,.F.,.F.)
EndIf
//³Verifica se deve chamar a rotina de geracao de pedidos.
If	lRet	.AND. lTela 	.AND.	aCfgNf[ScTipoDoc] $ 'BD'	.AND.	aCfgNf[SAliasHead] == 'SF1'
	nPos := AScan(aCabNota[1],{|x| x=='F1_GERAPED' })
	If nPos > 0
		If ValType(aCabNota[2][nPos]) == "A"
			lGeraPed := (&(aCabNota[2][nPos][1]) == "1")
		Else
			lGeraPed := (aCabNota[2][nPos] == "1")
		EndIf
	EndIf
	If lGeraPed
		Processa({|| lRet := LocxGrvPed()},STR0121) //'Gerando informacao de pedidos...'
	Endif
EndIf
//Llamada de metricas
If lRet .and. FINDFUNCTION( "LOCXMETGRV" )
	LOCXMETGRV(IIf(Type("cFunName")=="U",Upper(Alltrim(FunName())),cFunName), aCfgNf[ScEspecie] )
EndIf
//³Restaura aCols original
aCols := aClone(aSavaCols)
For nX:=1 To Len(__aCodLocs)
	UnLockByName(__aCodLocs[nX],.T.,!Empty(cFilSF2),.T.)
	UnLockByName(__aCodLocs[nX],.T.,!Empty(cFilSF1),.T.)
Next
__aCodLocs	:= {}

/*(09/04/18): Message about created FA*/
If cPaisLoc=="RUS" .AND. !Empty(cNumb)
	RU01MSG(cNumb, , )
EndIF
//Métrica para contabilizar cantidad de Carta Porte registradas por mes.
If cPaisLoc == "MEX" .And. lRet .And. FindFunction("LxMetCarP") .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0 .And. SF2->F2_TPCOMPL == "S" ;
	.And. cFunName == "MATA467N" .And. SF2->F2_TIPODOC $ "01|21"
	LxMetCarP(cFunName)
EndIf
If cPaisLoc == "EQU" .and.  cFunName == "MATA467N" .and. lRet .and. aCfgNF[SAliasHead] == "SF2" .and. Alltrim(SF2->F2_ESPECIE) =="NF" .and. FindFunction("LxMetReem") .and. SF2->(FieldPos("F2_TPDOC")) > 0 .and. SF2->(FieldPos("F2_TPVENT")) > 0 .and. SF2->(FieldPos("F2_TIPOPE")) > 0
	If SF2->F2_TPDOC == PadR("01",TamSX3("F2_TPDOC")[1]) .and. SF2->F2_TPVENT == "1" .and. SF2->F2_TIPOPE == PadR("41",TamSX3("F2_TIPOPE")[1])
 		LxMetReem(cFunName) //Métrica
	Endif
Endif
//Registro de eventos para visualizacion en EventViewer
If lRet .And. cPaisLoc $ "COL" .And. cFunName == "MATA101N" .And. aCfgNf[SnTipo] == 10 .And. FindFunction("LxEventIn")
	LxEventIn(aCabNota)
EndIf
Return(lRet)

/*ºPrograma  ³GRAVAITENSNF ºLenadro C.G. ³Microsiga  º Data ³  09/10/01   º±±
±±ºDesc.     ³ Efetua gravacao de todos os itens de Notas Fiscais         º±±
param.
aCitensOri  - conteudo dos itens
aCpItensOri - campos dos itens
cAlias		- nome do arquivo(Alias) de itens da nota
cAliasCF	- Alias do cliente ou fornec. (SA1/SA2)
aTotaliz 	- informacoes sobre os campos que devem ser totalizados
			[1] - array com o nome dos campo de cabecalho que devem ser totalizados
			[2] - array com a formula para totalizar cada um dos campos
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipRem     - Tipo de Remito que esta sendo gerado
Obs.: Pode ser passado tanto o conteudo propriamente dito quanto uma formula para o conteudo no array aCittens, mas
quando for uma formula, mudar a pos. de conteudo para que seja um array de duas posicoes onde a formula esta na
primeira e na seguna alguma expressao booleana para execucao da formula
Retorno
aRet - retorno da funcao
 [1] - aRecnoI
 [2] - aCpTotal
 [3] - aTotal*/
Function GravaItensNF(aCitensOri,aCpItensOri,cAlias,aTotaliz,cAliasCF,cTipDoc,cTipRem)
Local nI,nX,cI :=StrZero(0,TamSX3(If(cAlias=="SD2",'D2_','D1_')+'ITEM')[1])	//flag's para loop's
Local aArea    := {}   //guarda config. de arquivo
Local aRecnoI  := {}   //acumula o numero dos registros que foram gravados sequencialmente
Local lForm	   := .F.  //Indica se a linha atual do array aCitens possui algum conteudo que seja formula
Local aRet 	   := array(4) //Array com o conteudo do retorno da funcao
Local lRet 	   := .T.  //Retorno da funcao. Indica incosistencia da funcao
Local aPars	   := {}   //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local aCitens  := aClone(aCitensOri)
Local aCpItens := aClone(aCpItensOri)
Local nPosItem := 0
Local nPosCod  := 0
Local cItemOri := ""
//Local cAux     := ""
Local aRecTmp  := {}
//Local nDeleted := 0
Local nPosAFN  := 0
Local nPosRatCC:= 0
//Local lVer116  := .T.
//Local lDISTMOV := SuperGetMV("MV_DISTMOV",.F.,.F.)
Local nRecD1   := 0
Local cFilSD1		:= xFilial("SD1")
//Local cFilSFB		:= xFilial("SFB")
Local lRemDevo	:= GetNewPar("MV_REMDEVO",.F.)
Local cDescSai	:= GetNewPar('MV_DESCSAI','1')
Local nT_PRCVEN	:= TamSX3("D2_PRCVEN")[2]
//Local nT_VUNIT	:= TamSX3("D1_VUNIT")[2]
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local aTmpQ := {}
Local nX1 := 0
Local cUserLG := ""
Local oArrayTes := Tes_Impuesto():New()
DEFAULT cTipRem := ""
aRatCC := If(Type("aRatCC")	<>"A", {}, aRatCC)
Asize(aTotaliz, 3)
aTotaliz[3] := IIf(Empty(aTotaliz[3]) .OR. ValType(aTotaliz[3]) != "A", {}, aTotaliz[3])
Asize(aTotaliz[3], Len(aTotaliz[1]))
Asize(aTotaliz[2], Len(aTotaliz[1]))
Aeval(aTotaliz[2], { |x,y| If(x==NIL,aTotaliz[2][y]:="0",) })
Afill(aTotaliz[3], 0)
//³Consiste passagem de param.³
Aadd(aPars, {"aCitens"	, aCitens	, SpEmpty					} )
Aadd(aPars, {"aCpItens"	, aCpItens	, SpEmpty					} )
Aadd(aPars, {"cAlias"	, cAlias	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
lRet := LocxParam("GRAVAITENSNF", aPars)
If lRet //(1)
	aArea  := GetArea()
	//³Iniciando Fiscal, se necessario ³
	If !MaFisFound()
		InicializaFis(MontaHeader(aCpItens),aCitens,IIf(cAlias=="SD1","SF1","SF2"),cAlias,cAliasCF,cTipDoc)
	Endif
	//³Grava Itens e acumula totais³
	DBSelectArea(cAlias)
	nI := 0
	nPosItem := Ascan(aCpItens,{|x| Alltrim(x)=="D1_ITEM"})
	nPosCod := Ascan(aCpItens,{|x| Alltrim(x)=="D1_COD"})
	If lUsaNewKey
		nPosSERIE:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_SERIE"})
		nPosEMISS:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_EMISSAO"})
		nPosESPEC:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_ESPECIE"})
		nPosSDOC := Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_SDOC"})
		nPosSEORI:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_SERIORI"})
		nPosSDOCO:= Ascan(aCpItens,{|x| Alltrim(x)==PrefixoCpo(cAlias)+"_SDOCORI"})
	Endif
	If l103Class
		For nI := 1 To Len(aCItens)
			SD1->(MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aCitens[nI][nPosCod]+aCitens[nI][nPosItem]))
		   	Aadd(aRecnoI,{SD1->(Recno()),ni})
	 	Next nI
	Endif
	//O item eh recalculado e regravado, portanto tem que ser flagueado com um diferencial ('X') frente, para poder ser substituido
	//pelo codigo de item definitivo
	If IntePms()
		For nPosAFN := 1 To Len(aRatAFN)
			aRatAFN[nPosAFN,1] := 'X'+aRatAFN[nPosAFN,1]
		Next
	Endif
	For nPosRatCC := 1 To Len(aRatCC)
		aRatCC[nPosRatCC,1] := 'X'+aRatCC[nPosRatCC,1]
	Next
	For nI := 1 to Len(aCitens)
		//³Verifica se a linha nao esta deletada³
		If aCitens[nI][Len(aCitens[nI])]
			If !l103Class
				AADD(aRecnoI,{0,ni})
			Endif
			Loop
		EndIf
		//³Consiste qtde de campos e conteudos passados³
		If Len(aCitens[nI]) != Len(aCpItens)+1
			Alert(cAlias+" ; FUNCTION:'GRAVAITENSNF'")
			RestArea(aArea)
			lRet := .F.
		EndIf
		If lRet //(2)
			//³Se posuir algum campo que seja formula, carrega o conteudo dos campos em variaveis de memoria³
			lForm := .F.
			Aeval(aCitens[nI], { |x| If(ValType(x)=="A",lForm:=.T.,) })
	    	IIf(lForm, 	Aeval(aCpItens, { |x,y| If(x!=NIL,{ || &("M->"+x):=CriaVar(x),&("M->"+x):=If(ValType(aCitens[nI][y])!="A",aCitens[nI][y],NIL)},) }), )
			//³Trava Registro³
			If l103Class
				(cAlias)->(MsGoto(aRecnoI[nI,1]))
				RecLock(cAlias,.F.)
			Else
				RecLock(cAlias,.T.)
				If cAlias=="SD2" .And. SD2->(Fieldpos("D2_USERLGI")) > 0
					cUserLG := D2_USERLGI
				EndIf
			Endif
			//³Varrendo todos os campos para cada item³
			nX := 0
			For nX := 1 to Len(aCpItens)
				//³Verifica a existencia do campo no arquivo³
				If &(cAlias+"->"+"(FieldPos('"+aCpItens[nX]+"')) <> 0")
					//³Verifica se deve executar formula ou ja e o conteudo. O que define isso e o caracteristica da pos. do array ³
					//³de dados. Se for um array, o mesmo deve conter duas posicoes e a segunda pos. indica se e formula ou nao.   ³
					//³Se a segunda pos. deste array for .T., executa-se entao a formula que deve estar contida na primeira pos.³
					//³do array 																									  ³
					If !l103Class
						If ValType(aCitens[nI][nX]) == "A"
							If Len(aCitens[nI][nX]) >= 2 .AND. !Empty(aCitens[nI][nX][2]) .AND. aCitens[nI][nX][2]
								Replace &(aCpItens[nX]) With ExecFormula(aCitens[nI][nX][1],,)
							EndIf
						Else
							If lUsaNewKey
								If nX<>nPosSERIE .AND. nX<>nPosSDOC .AND. nX<>nPosSEORI .AND. nX<>nPosSDOCO
									Replace &(aCpItens[nX]) With aCitens[nI][nX]
								ElseIf nX==nPosSERIE
									SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIE",aCitens[nI][nPosEMISS],aCitens[nI][nPosESPEC],aCitens[nI][nPosSERIE])
								ElseIf nX==nPosSEORI
									If !(empty(aCitens[nI][nPosSEORI]))
										SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIORI",,,,aCitens[nI][nPosSEORI])
									EndIf
								EndIf
							Else
								Replace &(aCpItens[nX]) With aCitens[nI][nX]
							Endif
						EndIf
					Else
						If lUsaNewKey
			  				If aCfgNf[SaCposGD]<> Nil .AND. (Ascan(aCfgNf[SaCposGD],{|x| x==Alltrim(aCpItens[nX])})> 0)
								If nX<>nPosSERIE .AND. nX<>nPosSDOC .AND. nX<>nPosSEORI .AND. nX<>nPosSDOCO
									Replace &(aCpItens[nX]) With aCitens[nI][nX]
								ElseIf nX==nPosSERIE
									SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIE",aCitens[nI][nPosEMISS],aCitens[nI][nPosESPEC],aCitens[nI][nPosSERIE])
								ElseIf nX==nPosSEORI
									If !(empty(aCitens[nI][nPosSEORI]))
										SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIORI",,,,aCitens[nI][nPosSEORI])
									EndIf
								Endif
							EndIf
						Else
			  				If aCfgNf[SaCposGD]<> Nil .AND. (Ascan(aCfgNf[SaCposGD],{|x| x==Alltrim(aCpItens[nX])})> 0)
								Replace &(aCpItens[nX]) With aCitens[nI][nX]
							EndIf
						Endif
					EndIf
				EndIf
			Next nX
  			cI	:=	Soma1(cI,Len(cI))
  			cItemOri	:= &(PrefixoCpo(aCfgNF[SAliasCols])+"_ITEM")
  			Replace &(PrefixoCpo(aCfgNF[SAliasCols])+"_ITEM") With cI
			If cAlias == "SD2" .AND. cDescSai == '2'
	     		SD2->D2_TOTAL := SD2->D2_TOTAL - SD2->D2_DESCON
				//#Brasil#
				//If cPaisLoc <> "BRA"
					SD2->D2_PRCVEN := Round(SD2->D2_TOTAL / SD2->D2_QUANT, nT_PRCVEN)
				//Else
					//SD2->D2_PRCVEN := NoRound(SD2->D2_TOTAL/SD2->D2_QUANT, nT_PRCVEN)
				//EndIf
			EndIf
			If cPaisLoc == "ARG"
	     		ArgActItem(cAlias, aCfgNf[ScTipoDoc], cDescSai, @oArrayTes)
			EndIf
			//³Compatibiliza conteudo do campo D2_TIPOREM com tipo selecionado no cabecalho
			If cAlias=="SD2" .AND. !Empty(cTipRem)
  				SD2->D2_TIPOREM := cTipRem
			EndIf
			If cAlias=="SD2" .AND. !Empty(cUserLG)
  				SD2->D2_USERLGI := cUserLG
			EndIf
			//³ Efetua a Atualizacao da Assistencia Tecnica Somente para os paises localizados
			//³ Obs.: A Geração quando o item utiliza localização é feita após a geração do SDB na função GravaNfGeral()
			If cAlias=="SD2" .AND. (cPaisLoc $ "ARG|PAR|URU|CHI|MEX|EUA|POR|BOL")
				If ( SF4->F4_ATUTEC=="S" )
					If ( !Empty(SD2->D2_NUMSERI) )
						AtTrfEqpto(SD2->D2_CODFAB,SD2->D2_LOJAFA,SD2->D2_COD,SD2->D2_NUMSERI,SD2->D2_CLIENTE,SD2->D2_LOJA)
					EndIf
				EndIf
			EndIf
			If cAlias=="SD1" .AND. l103Class
				SD1->D1_DTDIGIT	:= dDataBase
			Endif
			//³ Na inclusao de uma devolucao de remito de entrada, atualiza a qtde.³
			//³ a classificar do remito de entrada.
			If cAlias == "SD2" .AND. SD2->D2_TIPO == "D" .AND. SD2->D2_TIPODOC == "61" .AND.;
				Alltrim(SD2->D2_ESPECIE) == "RCD" .AND. !l103Class
				SD1->(dbSetOrder(1))
				If SD1->(MsSeek(cFilSD1+SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMORI))
					SD1->(RecLock("SD1",.F.))
					//³ Quando o parametro MV_REMDEVO estiver criado no SX6 com o conteudo .T. ³
					//³ a gravacao do D1_QTDACLA sera adiada quando a inclusao do remito de    ³
					//³ devolucao baixar a qtde do remito original. Isto                 ³
					//³ possibilitara que o remito original possa ser vinculado posteriormente ³
					//³ a fatura de entrada mesmo estando seu saldo totalmente consumido pelo  ³
					//³ remito de devolucao.
					If !lRemDevo
						SD1->D1_QTDACLA := SD1->D1_QTDACLA - SD2->D2_QUANT
                    EndIf
					SD1->(MsUnLock())
				EndIf
			EndIf
			//³ Estorna classificação dos remitos
			If !aCfgNF[SlRemito] .And. cAlias == "SD2" .AND. SD2->D2_TIPO == "D" .AND. SD2->D2_TIPODOC == "07" .AND.;
				Alltrim(SD2->D2_ESPECIE) == "NCP" .AND. !l103Class
				nRecD1 := SD1->(Recno())
				cChaveItem	:=	cFilSD1+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMREM
				aCusto		:=	{SD1->D1_CUSTO/SD1->D1_QUANT,SD1->D1_CUSTO2/SD1->D1_QUANT,SD1->D1_CUSTO3/SD1->D1_QUANT,SD1->D1_CUSTO4/SD1->D1_QUANT,SD1->D1_CUSTO5/SD1->D1_QUANT}
				nQtdItem	:=	SD1->D1_QUANT
				If !Empty(SD1->D1_REMITO) .And. SD1->(MsSeek(cChaveItem))
					If !(cPaisLoc $ "ARG|URU|CHI|BOL|PAR")
						NFAtuSD1(nQtdItem,-1,aCusto)
						SD1->(MsGoTo(nRecD1))
					EndIf
				EndIf
				// Retorna o alias selecionado para SD2 para atualizar os Recnos corretos na sequencia do processo
				DBSelectArea("SD2")
			EndIf
			//³Destrava Registro³
			MsUnlock()
			//Acerta no AFN com o o item que realmente foi gravado
			If IntePms()
				nPosAFN := Ascan(aRatAFN,{|x| x[1] == 'X'+cItemOri})
				If nPosAFN > 0
					aRatAFN[nPosAFN,1] := cI
				Endif
			Endif
			//Acerta no Rat.CC com o o item que realmente foi gravado
			nPosRatCC := Ascan(aRatCC,{|x| x[1] == 'X'+cItemOri})
			If nPosRatCC > 0
				aRatCC[nPosRatCC,1] := cI
			Endif
			//³Acumula o numero dos registros gravados³
			If !l103Class
				AADD(aRecnoI,{Recno(),ni})
			Endif
		Else
			Loop
		EndIf
	Next nI
	If lRet
		//³Calculando campos que devem ser totalizados³
		If !Empty(aTotaliz)
			Aeval(aTotaliz[2], { |x,y| aTotaliz[3][y]:=IIf(!Empty(x),ExecTotal(x,aCpItensOri,aCitens),0) })
		EndIf
		//³Acertando conteudo de retorno³
		aRecTmp := aClone(aRecnoI)
		aRet[4] := aRecnoI
		aRet[2] := aTotaliz[1]
		aRet[3] := aTotaliz[3]
		aTmpQ:={}
		for nX1 := 1 to Len(aRecTmp)
			If Valtype(aRecTmp[nX1]) == "A" .and. aRecTmp[nX1,1] >0
				aAdd(aTmpQ,aRecTmp[nX1])
			EndIf
		Next nX1
		aRet[1] := aTmpQ //aRecTmp
		//Devolve a pos. do array com o conteudo original, sem 0. Foi adicionada 0 qdo o item for apagado.
		//Essa alteracao refletira na funcao grava imposto. (Eval que chama a MaFisWrite)
	EndIf
	If lRet .and. FINDFUNCTION( "LOCXMET" )
		LocxMet(IIf(Type("cFunName")=="U",Upper(Alltrim(FunName())),cFunName),Val(cI),,,.T.,"A")
	EndIf
EndIf
//³Devolvendo configuracoes de arquivo³
RestArea(aArea)
Return(aRet)
/*ºPrograma  ³GRAVACABNF   ºLenadro C.G. ³Microsiga  º Data ³  09/10/01   º±±
±±ºDesc.     ³ Efetua gravacao do cabecalho de Notas Fiscais              º±±
param.
aCabNotaOri - cabecalho da Nota
		   [1] - campos do cabecalho
		   [2] - conteudo dos campos do cabecalho * pode ser uma formula inclusive quando for um totalizador
		   [3] - indica se o campo e totalizador (Default .F.)
cAlias   - nome do arquivo(Alias) de itens da nota
Obs.: Pode ser passado tanto o conteudo propriamente dito quanto uma formula para o conteudo no array aCabNota[2], mas
quando for uma formula, mudar a pos. de conteudo para que seja um array de duas posicoes onde a formula esta na
primeira e na seguna alguma expressao booleana para execucao da formula
*/
Function GravaCabNF(aCabNotaOri,cAlias,lID,cHash)
Local nI,nX					//flag's para loop's
Local aArea    := {}		//guarda config. de arquivo
Local nRecnoC  := 0			//armazena o numero do registro gravado
Local aPars	   := {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lForm    := .F.		//Flag que indica se algum conteudo de cabecalho e uma formula
Local lRet 	   := .T.		//Retorno da funcao. Indica incosistencia da funcao
Local aCabNota := aClone(aCabNotaOri)
Local nPosCor  := 0
Local cCpoCor  := ''
Local cSeek    := ''
Local lConfere := .F.
Local nPosRem := aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_REMITO"})
Local nPosRemS:= aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_SERIREM" })
Local nPosTes := aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_TES" })
Local nPosForn:= aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_FORNECE" })
Local nPosLoja:= aScan(aHeader, {|x| UPPER(AllTrim(x[2])) == "D1_LOJA" })
Local nPosCorDat:=0,nPosCorSer:=0,nPosCorEsp:=0,nPosCorFor:=0,nPosCorLoj:=0 //cPosCorDoc:=0,
//Local cInvoiceDate := ""     // AAAA-MM-DD
//Local cInvDateMan  := ""
//Local cSystemEntryDate := "" // AAAA-MM-DDTHH:MM:SS
//Local cInvoceNo    := ""     // código interno do documento SERIE / DOCUMENTO
//Local cGrossTotal  := ""     // Valor total
Local lContFol  := AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720" .And. GetNewPar("MV_CTRLFOL",.F.)
Local nPosHon   := 0
Local lConfFis		:= SuperGetMV("MV_CONFFIS",.F.,"N") == "S"
Local lRemDiv		:= SuperGetMV("MV_REMDIV",.F.,.F.)
Local aAreaSF1		:= {}
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local nPosEMISS:=0
Local nPosSERIE:=0
Local nPosESPEC:=0
Local nPosSDOC :=0
Local nPosSERIE2:=0
//Local cCpSer2:=""
Local cIdCorr	:= ""
//Local nValcot	  := 0
//Local aAreaSB5	:= {}
//Local lSb5 := .F.
//Local nZ := 0
//Local cCpo := ""
//Local nPosSerie := 0
//Local nPosEspec := 0

If Type('lDocSp') == "U"
	Private lDocSp := .F.
EndIf
If Type('lAutoFact') == "U"
	Private lAutoFact := .F.
EndIf
Default cHash           := ""  // (So Portugal) Hash (campo do documento anterior na mesma série, vazio quando se tratar do primeiro documento da série ou do exercício)
Aadd(aPars, {"aCabNota"	,aCabNota		,SpLenArray		,2		,3		} )
Aadd(aPars, {"aCabNota",aCabNota[1]		,SpEmpty						} )
Aadd(aPars, {"aCabNota",aCabNota[2]		,SpEmpty						} )
Aadd(aPars, {"aCabNota",cAlias			,Sp2String		,"SF1"	,"SF2"	} )
lRet := LocxParam("GRAVACABNF",aPars)
Aeval(aCabNota[1], { |x,y| IIf(Empty(aCabNota[3][y]),aCabNota[3][y]:=.F.,) })
If lRet //(1)
	//³Salvando configuracoes do arquivo³
	aArea  := GetArea()
	nPosHon:=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_RECHON")
	If nPosHon >0  .And. 	aCabNota[2][nPosHon]=="1"
	   	 lUsaCor:=.F.
	EndIf
	//³Se posuir algum campo que seja formula, carrega o conteudo dos campos em variaveis de memoria
	lForm := .F.
	Aeval(aCabNota[2], { |x| If(ValType(x)=="A",lForm:=.T.,) })
	IIf(lForm, 	Aeval(aCabNota[1], { |x,y| If(x!=NIL,{ || &("M->"+x):=CriaVar(x),&("M->"+x):=If(ValType(aCabNota[2][y])!="A",aCabNota[2][y],NIL)},) }), )
	If lUsaNewKey //Projeto Chave Unica - Tiago Silva
		If cPaisLoc == "PER"
			CposSerPer(cAlias, @aCabNota, @nPosSERIE, @nPosSERIE2)
		Else
			nPosSERIE:=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_SERIE")
		Endif
		nPosESPEC:=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_ESPECIE")
		nPosEMISS:=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_EMISSAO")
		nPosSDOC :=Ascan(aCabNota[1],PrefixoCpo(cAlias)+"_SDOC")
	Endif
	If lUsaCor .AND. lID //grava o numero correlativo
		cCpoCor:=PrefixoCpo(cAlias)
		nPosCor:=Ascan(aCabNota[1],cCpoCor+"_NUMCOR")
		If nPosCor>0
			nPosCorDat:=Ascan(aCabNota[1],cCpoCor+"_DTDIGIT")
			If nPosCorDat==0
				nPosCorDat:=Ascan(aCabNota[1],cCpoCor+"_EMISSAO")
			Endif
			nPosCorDoc:=Ascan(aCabNota[1],cCpoCor+"_DOC")
			nPosCorSer:=Ascan(aCabNota[1],cCpoCor+"_SERIE")
			nPosCorEsp:=Ascan(aCabNota[1],cCpoCor+"_ESPECIE")
			nPosCorFor:=Ascan(aCabNota[1],cCpoCor+If(cCpoCor="F1","_FORNECE","_CLIENTE"))
			nPosCorLoj:=Ascan(aCabNota[1],cCpoCor+"_LOJA")
			cIdCorr:=Iif(lUsaNewKey,SerieNfId(cAlias,4,PrefixoCpo(cAlias)+"_SERIE",aCabNota[2][nPosCorDat],aCabNota[2][nPosCorEsp],aCabNota[2][nPosCorSer]),aCabNota[2][nPosCorSer])
			aCabNota[2][nPosCor]:=CORR_GRAVA(If(nPosCorDat>0,aCabNota[2][nPosCorDat],dDataBase),;
												aCabNota[2][nPosCor],;
												If(nPosCorDoc>0,aCabNota[2][nPosCorDoc],""),;
												If(nPosCorSer>0,cIdCorr,""),; //If(nPosCorSer>0,aCabNota[2][nPosCorSer],"") //Chave Unica
												If(nPosCorEsp>0,aCabNota[2][nPosCorEsp],""),;
												If(nPosCorFor>0,aCabNota[2][nPosCorFor],""),;
												If(nPosCorLoj>0,aCabNota[2][nPosCorLoj],""))
		Endif
	Endif

	If cPaisLoc == "ARG"
		LOCXCabNf2(@aCabNota,@aCabNotaOri,SAliasHead,aCfgNf)
	EndIf

	//³Grava cabecalho³
	DBSelectArea(cAlias)
	RecLock(cAlias,!l103Class .AND. lID)
	nI := 0
	IF (cPaisloc== "PAR")
		xGrvCabPAR(FunName(), @aCabNota, cAlias)
	ENDIF
	For nI := 1 to Len(aCabNota[1])
		//³Verifica existencia do campo³
		If &(cAlias+"->"+"(FieldPos('"+aCabNota[1][nI]+"')) <> 0")
			//³Verifica se e formula ou conteudo propriamente dito. O que define isso e a caracteristica da pos. do	³
			//³array de conetudo. Se for um array, a segunda pos. do mesmo deve indicar se e uma formula ou nao.	³
			//³Se for .T. executa formula do conteudo da pos. [1]
			If ValType(aCabNota[2][nI]) == "A"
				If Len(aCabNota[2][nI]) >= 2 .AND. !Empty(aCabNota[2][nI][1]) .AND. aCabNota[2][nI][2]
					Replace &(aCabNota[1][nI]) With ExecFormula(aCabNota[2][nI][1],,)
				EndIf
			ElseIf 	(PrefixoCpo(cAlias)+"_NUMCOR" == aCabNota[1][nI] .AND. lID ) .OR. PrefixoCpo(cAlias)+"_NUMCOR" <> aCabNota[1][nI]
				If lUsaNewKey
					If nI<>nPosSERIE .AND. nI<>nPosSDOC
						If cPaisLoc == "COL"
							xGrvCabCOL(aCabNota, nI)
						else
							Replace &(aCabNota[1][nI]) With aCabNota[2][nI]
						endif
					ElseIf nI==nPosSERIE
						SerieNfId(cAlias,1,PrefixoCpo(cAlias)+"_SERIE",aCabNota[2][nPosEMISS],aCabNota[2][nPosESPEC],aCabNota[2][nPosSERIE])
					EndIf
				Else
					If cPaisLoc == "COL"
						xGrvCabCOL(aCabNota, nI)
					else
						Replace &(aCabNota[1][nI]) With aCabNota[2][nI]
					endif
				Endif
			EndIf
		EndIf
	Next nI
	If cAlias=="SF1"
	   If l103Class
		  SF1->F1_RECBMTO := SF1->F1_DTDIGIT
		  SF1->F1_DTDIGIT := dDataBase
		  SF1->F1_FORMUL  := IIF(aCfgNF[SlFormProp],"S",IIF(SF1->F1_FORMUL=="N","N"," "))
		  If !Empty(SF1->F1_HAWB)
	  			SWN->(DbSetOrder(2))
				If SWN->(MsSeek(xFilial("SWN")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
					If SF1->F1_TIPO_NF $ '58'
                    	SW9->(dbSetOrder(1))
                 		SW9->(DbSeek(xFilial("SW9")+SF1->F1_DOC+Space(Len(SW9->W9_INVOICE)-Len(SF1->F1_DOC))+SF1->F1_FORNECE))
						SF1->F1_EMISSAO := SW9->W9_DT_EMIS
					ElseIf SF1->F1_TIPO_NF $ '67'
                        SW6->(dbSetOrder(1))
                        SW6->(MsSeek(xFilial("SW6")+SF1->F1_HAWB))
						SF1->F1_EMISSAO := SW6->W6_DTREG_D
					ElseIf SF1->F1_TIPO_NF $ '9A'
			        	//-- Posiciona Despesas/Gastos da import.
			        	SWD->(DbSetOrder(1))
			            SWD->(DbSeek(cSeek:=xFilial("SWD")+SWN->WN_HAWB))
						Do While SWD->(!Eof()) .AND. cSeek == SWD->WD_FILIAL+SWD->WD_HAWB
						    If SWD->WD_DOCTO == SWN->WN_DOC .AND. SWD->WD_SE_DOC == SWN->WN_SERIE
						    	Exit
						    EndIf
							SWD->(dbSkip())
						EndDo
						SF1->F1_EMISSAO := If( Empty(SWD->WD_DT_EMIS),SWD->WD_DES_ADI,SWD->WD_DT_EMIS)
					EndIf
                EndIf
		  EndIf
	   EndIf
	   IF cPaisLoc == "COL" .And. (lDocSp .Or. aCfgNF[SnTipo] == 23) .And. FINDFUNCTION( 'lxModDocSp' ) //Doc. Soporte - Nota Ajuste NDP
	   		lxModDocSp(cAlias, lDocSp,aCfgNF[SnTipo] )
	   Endif
       If cPaisLoc == "GUA" .AND. SF1->(FieldPos("F1_MOTIVO")) > 0 .AND. aCfgNf[ScTipoDoc] == "D" .AND. aCfgNF[SnTipo] < 10 //Nao deve considerar as Notas de envio(remitos)
		  SF1->F1_MOTIVO  := cMotivo
	   EndIf
       //#PORTUGAL#
	   /*If cPaisLoc == "PTG" .And. lHashPTG .And. FindFunction("FWSignText") .And. aCfgNF[SlFormProp] .And. !(Str(aCfgNF[1],2)$"50") .and. !Empty(cHash)//Exceto Remito
            If  ( SF1->(FieldPos("F1_EMIMAN")) > 0 ) .and. ( !Empty(SF1->F1_EMIMAN) )
                cInvDateMan := StrZero(Year(SF1->F1_EMIMAN),4)+"-"+StrZero(Month(SF1->F1_EMIMAN),2)+"-"+StrZero(Day(SF1->F1_EMIMAN),2)
            EndIf
           cInvoiceDate  := StrZero(Year(SF1->F1_EMISSAO),4)+"-"+StrZero(Month(SF1->F1_EMISSAO),2)+"-"+StrZero(Day(SF1->F1_EMISSAO),2)
           cSystemEntryDate := cInvoiceDate+"T"+SF1->F1_HORA
           cInvoceNo         := IIF(Left(SF1->F1_ESPECIE,2)$"FT/ND/NC/VD/TV/TD/AA/DA/RP/RE/CS/LD/RA",Left(SF1->F1_ESPECIE,2),"FT")+" "+SF1->F1_SERIE+"/"+SF1->F1_DOC
           cGrossTotal      := AllTrim(Str(xMoeda(SF1->F1_VALBRUT,SF1->F1_MOEDA,1,SF1->F1_EMISSAO,1,SF1->F1_TXMOEDA),TamSX3("F1_VALBRUT")[1],TamSX3("F1_VALBRUT")[2]))
           cHash := IIf(cHash=="INICIAL","",cHash)
           SF1->F1_HASH    := FWSignText(IIF(!Empty(cInvDateMan),cInvDateMan,cInvoiceDate)+";"+cSystemEntryDate+";"+cInvoceNo+";"+cGrossTotal+";"+cHash)
           SF1->F1_VERHASH := "1"
            If SF1->(FieldPos("F1_USRINC")) > 0
               SF1->F1_USRINC:= cUserName
            EndIf
       EndIf*/
	   //Grava total do adiantamento Mexico
	   If cPaisLoc $ "MEX|PER"
	     If MafisRet(,"NF_ADIANT") > 0
	   		SF1->F1_VALADI := MafisRet(,"NF_ADIANT")
	     EndIf
	   EndIf
	   If cPaisLoc == "ARG" .And. cTipo == "D" .And. GetNewPar('MV_DESCSAI','1') =='2' .And. ALLTRIM(SF1->F1_ESPECIE) $ "RFD"
	   		SF1->F1_VALMERC -= SF1->F1_DESCONT
	   EndIf
	Endif
	If cAlias=="SF2"
	   If GetNewPar('MV_DESCSAI','1') =='2'
		  SF2->F2_VALMERC -= SF2->F2_DESCONT
	   EndIf
       If cPaisLoc == "GUA" .AND. SF2->(FieldPos("F2_MOTIVO")) > 0 .AND. aCfgNf[ScTipoDoc] == "D" .AND. aCfgNF[SnTipo] < 10   //Nao deve considerar as Notas de envio(remitos)
		  SF2->F2_MOTIVO  := cMotivo
	   EndIf
	   If aCfgNf[ScCliFor] == "SA1" .AND. (aCfgNf[SnTipo] == 1 .OR. aCfgNf[SnTipo] == 50)
		   SF2->F2_REGIAO := Posicione("SA1",1,xFilial("SA1")+SF2->F2_CLIENTE+SF2->F2_LOJA,"A1_REGIAO")
       Endif
       //#PORTUGAL#
	   /*If cPaisLoc == "PTG" .And. lHashPTG .And. FindFunction("FWSignText") .And. aCfgNF[SlFormProp] .and. !Empty(cHash)
            If  ( SF2->(FieldPos("F2_EMIMAN")) > 0 ) .and. ( !Empty(SF2->F2_EMIMAN) )
                cInvDateMan := StrZero(Year(SF2->F2_EMIMAN),4)+"-"+StrZero(Month(SF2->F2_EMIMAN),2)+"-"+StrZero(Day(SF2->F2_EMIMAN),2)
            EndIf
           cInvoiceDate := StrZero(Year(SF2->F2_EMISSAO),4)+"-"+StrZero(Month(SF2->F2_EMISSAO),2)+"-"+StrZero(Day(SF2->F2_EMISSAO),2)
           cSystemEntryDate := cInvoiceDate+"T"+SF2->F2_HORA
           cInvoceNo        := IIF(Left(SF2->F2_ESPECIE,2)$"FT/ND/NC/VD/TV/TD/AA/DA/RP/RE/CS/LD/RA",Left(SF2->F2_ESPECIE,2),"FT")+" "+SF2->F2_SERIE+"/"+SF2->F2_DOC
           cGrossTotal      := AllTrim(Str(xMoeda(SF2->F2_VALBRUT,SF2->F2_MOEDA,1,SF2->F2_EMISSAO,1,SF2->F2_TXMOEDA),TamSX3("F2_VALBRUT")[1],TamSX3("F2_VALBRUT")[2]))
           cHash := IIf(cHash=="INICIAL","",cHash)
           SF2->F2_HASH     := FWSignText(IIF(!Empty(cInvDateMan),cInvDateMan,cInvoiceDate)+";"+cSystemEntryDate+";"+cInvoceNo+";"+cGrossTotal+";"+cHash)
           SF2->F2_VERHASH  := "1"
            If SF2->(FieldPos("F2_USRINC")) > 0
               SF2->F2_USRINC:= cUserName
            EndIf
       EndIf*/
	   IF cPaisLoc == "COL" .And.  aCfgNF[SnTipo] == 22 .And. FINDFUNCTION( 'lxModDocSp' ) //Nota Ajuste NCP
	   		lxModDocSp(cAlias, lDocSp,aCfgNF[SnTipo] )
	   Endif
	   If cPaisLoc == "ARG"
	   		ArgActSF2(lContFol,@aCols,aHeader)
	   EndIf
	   //Grava total do adiantamento Mexico
	   If cPaisLoc $ "MEX|PER"
	   		If MafisRet(,"NF_ADIANT") > 0
	   			SF2->F2_VALADI := MafisRet(,"NF_ADIANT")
	   		EndIf
	   EndIf
	Endif
	If cPaisLoc == "EQU"
		LxGrvCabEq(cAlias, IIf(Type('cFormCrbo') <> 'U', cFormCrbo, ""))
	EndIf
	//Integraçao com o modulo ACD
	//Gera conferencia quando documento possui TES com controle de estoque
	If lConfFis .And. cAlias=="SF1"
		If SF1->F1_TIPODOC $ "51*53*60"
			SF4->(DbSelectArea("SF4"))
			SF4->(DbSetOrder(1))
			For nX := 1 to Len(aCols)
				If !aCols[nx][Len(aHeader)+1]
					If !Empty(aCols[nX][nPosTes])
						SF4->(MsSeek(xFilial("SF4")+aCols[nX][nPosTes]))
						If SF4->F4_ESTOQUE == "S"
			            	lConfere := .T.
			            	Exit
		    	    	EndIf
	    	   		EndIf
	           	EndIf
			Next
		ElseIf SF1->F1_TIPODOC $ "08*09*10"
			SF4->(DbSelectArea("SF4"))
			SF4->(DbSetOrder(1))
			For nX := 1 to Len(aCols)
				If !aCols[nx][Len(aHeader)+1]
					If !Empty(aCols[nX][nPosTes]) .And. Empty(aCols[nX][nPosRem])
						SF4->(MsSeek(xFilial("SF4")+aCols[nX][nPosTes]))
						If SF4->F4_ESTOQUE == "S"
			            	lConfere := .T.
			            	Exit
		    	    	EndIf
	    	   		EndIf
	           	EndIf
			Next
		EndIf
		If lConfere
			SF1->F1_STATCON := "0"
		EndIf
	EndIf
	MsUnlock()
	//³Guarda numero do registro³
	nRecnoC := Recno()
EndIf //lRet (1)
//Se Factura estiver vinculada a remito com divergencia, altera F1_STATCON para 4
If lConfFis .And. lRemDiv .And. cAlias=="SF1" .And. !lConfere .And. SF1->F1_TIPODOC == "10"
	aAreaSF1 := SF1->(GetArea())
	SF1->(dbSetOrder(1))
	For nX := 1 to Len(aCols)
		If !Empty(aCols[nX][nPosRem])
			If SF1->(MsSeek(xFilial("SF1")+aCols[nX][nPosRem]+aCols[nX][nPosRemS]+	aCols[nX][nPosForn]+aCols[nX][nPosLoja])) .And. SF1->F1_STATCON == "2"
				RestArea(aAreaSF1)
				RecLock("SF1", .F.)
					SF1->F1_STATCON := "4"
				MsUnlock()
			EndIf
		EndIf
	Next nX
EndIf
//³Ponto de Entrada apos gravacao dos campos de cabecalho³
cPe	:=	LocxPE(9)
If lRet .AND. !Empty(cPE) .AND. !lID
	ExecBlock(cPE,.F.,.F.)
EndIf
//³Devolvendo configuracoes do arquivo³
RestArea(aArea)
Return(nRecnoC)
/*ºPrograma  ³CONSISTECAMPOS ºLeandro C.G. ³Microsiga º Data ³  09/10/01  º±±
±±ºDesc.     ³ Verifica existencia de campos em um arquivo retornando os  º±±
±±º			 ³ campos que nao existem                                     º±±
param.
aCpos    - campos que devem ser consistidos
cAlias   - arquivo(Alias) em que os campos devem existir
lDevolve - Indica se deve retornar os campos nao existente ou nao (padrao .F.)
Obs.: se nao retornar os campos devolve .T. quando existirem todos os campos e .F. se algum campo nao existir
*/
Function ConsisteCampos(aCpos,cAlias,lDevolve)
Local nI   		   				//flag's para loop's
Local aArea      := GetArea()
Local aAreaSX3   := GetArea("SX3")
Local lRet       := .F.		//Devolucao da funcao
Local aNExist    := {} 		//Array que armazena todos os campos nao existentes. Pode ser devolvida como parametro se "lDevolve == .T."
Local aAux       := {}
Default lDevolve := .F.

//³Verifica existencia do Alias passado por parametro
If cAlias == NIL
	lRet := .F.
EndIf
If cAlias == NIL .OR. !ExisteAlias(cAlias)
	lRet := .F.
EndIf

If lRet //(1)
	//³Verifica existencia de cada campo passado como parametro para o Alias³
	DBSelectArea("SX3")
	DBSetOrder(2)
	Default aCpos := {}
	nI   := 0
	For nI := 1 to Len(aCpos)
		aAux := ExisteCampo(aCpos[nI],.T.) //Devolve duas posicoes [1]-indica existencia do campo [2]-indica status do campo(vide "ExisteCampo")
		//³Quando aAux[1] == .F. significa que o campo nao e valido                   ³
		//³Quando aAux[2] == 1, significa que o campo e virtual. Neste caso e feita a ³
		//³consistencia da existencia do campo no arquivo, atraves do FieldPos
		If 	!aAux[1]
			If !lDevolve
				RestArea(aAreaSX3)
				RestArea(aArea)
				lRet := .F.
				Loop
			EndIf
			AADD(aNExist,aCpos[nI])
		EndIf
	Next nI
EndIf //lRet (1)
RestArea(aAreaSX3)
RestArea(aArea)
//³Devolve campos que nao existem se houverem ou simplesmente indica ³
//³inconsistencia dos campos passadosÙ
Return(IIf(lDevolve, IIf(lRet,aNExist,{}), lRet))
/*ºPrograma  ³GravaCusNF     ºLeandro C.G. ³Microsiga º Data ³  15/10/01   º±±
±±ºDesc.     ³ Grava o valor de custo total de um item de uma NF		   º±±
±±º          ³nas cinco moedas, atualizando SD1 ou SD2					   º±±
cAlias   - Alias que deve ser gravado (SD1/SD2) (obrigt)
aCusto   - Custo a ser atualizado nas cinco moedas
*/
Function GravaCusNF(cAlias, aCusto)
Local cPrefixo := ""		//Prefixo do Alias (cAlias)
Local lRet 	   := .T.		//Retorno da funcao. Indica incosistencia da funcao
Local aArea    := {}		//Guarda config. atuais de arquivos
Local aPars	   := {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nI	   := 0

//³Consistindo param.
Aadd(aPars, {"cAlias"	, cAlias	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"aCusto"	, aCusto	, SpEmpty					} )
Aadd(aPars, {"aCusto"	, aCusto[1]	, SpEmpty					} )
lRet := LocxParam("GRAVACUSNF",aPars)

ASIZE(aCusto, 5)
aArea  := GetArea()
If lRet //(1)
	//³Atualizando valor de custo³
	cPrefixo := PrefixoCpo(cAlias)
    RecLock(cAlias,.F.)
	Replace &( cPrefixo + "_CUSTO" )	With &( AllTrim(Str(aCusto[1])) )
	nI := 0
	For nI := 2 to Len(aCusto)
		Replace &( cPrefixo + "_CUSTO" + AllTrim(Str(nI)) )		With &( AllTrim(Str(aCusto[nI])) )
	Next nI
	Replace &( cPrefixo + "_CUSORI" )	With &( AllTrim(Str(aCusto[1])) )
	MsUnlock()
    If GetNewPar("MV_NGMNTES","N") == "S"
       NGSD1100I()
    EndIf
EndIf //lRet (1)
Return(lRet)
/*ºPrograma  ³ESTQNOTA       ºLeandro C.G. ³Microsiga º Data ³  19/10/01   º±±
±±ºDesc.     ³ Efetua o controle de todas as atualizacoes referentes ao    º±±
±±º          ³estoque que sao necessarias na gravacao de uma NF  param:	   º±±
cAliasC		-	Alias de cabecalho de NF
cAliasI		- 	Alias de Itens de NF
cAliasCF	- 	Indica se e cliente ou fornec. (SA1-Cliente ; SA2-Fornec.)
cSinal 		- 	Indica se a movimentacao deve somar ou subtrair o estoque (+/-)
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
nRecnoC		- 	Numero do registro referente ao cabecalho da NF
aCusto		- 	Custo referente ao item da atualizacao de estoque em todas as moedas utilizadas
aPosicionou	- 	Array com a indicacao dos arquivos que estao posicionados posicionados
				[lSF4]-Indica se foi posicionado SF4 (TES)
				[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
				[lSAx]-Indica se foi posicionado SA1 OU SA2 (CLIENTE OU FORN.)
				[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
				[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
				[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
				[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
lGeraPv		-	Indica se deve gerar pedido de venda sobre a NF, valido apenas para notas de devolucao (Default .F.)
Obs.: Esta rotina parte do principio que o registro de cabecalho e itens da NF ja estao posicionados no registro correto
*/
Function EstqNota(cAliasC,cAliasI,cSinal,cTipDoc,cAliasCF,nRecnoC,aCusto,aPosicionou,lGeraPv,aRecsSF1)
//³Variaveis Locais
Local nI//,nX														 	//Flag's para Loop's
//Local cPrefC      := cAliasC + "->" + PrefixoCpo(cAliasC)			//Prefixo do Alias de cabcalho (F1;F2)
Local cPrefI      := cAliasI + "->" + PrefixoCpo(cAliasI)  			//Prefixo do Alias de Itens (D1;D2)
Local cCliFor     := IIf(cAliasI=="SD1", "_FORNECE", "_CLIENTE")  	//Indica se e cliente ou fornec.
//Local cPreco      := IIf(cAliasI=="SD1", "_VUNIT", "_PRCVEN")  	//Indica se e cliente ou fornec.
//Local nQtdMoeda   := 5												//qtde utilizada de moedas
//Local aCusTot     := array(nQtdMoeda)								//Custo total em todas as moedas
Local lRet		  := .T.											//Retorno da funcao. Indica incosistencia da funcao
Local lEnviaCQ	  := .F.											//Indica se o item foi ou nao enviado ao controle de qualidade
Local aPars	   	  := {}												//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local cChave	  := ""
//Local nRecBD	  := 0
Local nQtdDist	  := 0
Local lRastro	  := .F.
Local cLoteSDA	  := ""
Local cFilSDB		:= xFilial("SDB")
Local aNfOrig     := array(7)		//array com o conteudo dos campos utilizados para chave de busca da nota de origem
/*  [1]- _FILIAL
  	[2]- _DOC
	[3]- _SERIE
	[4]- _FORNECE;_CLIENTE
	[5]- _LOJA
	[6]- _COD
	[7]- _ITEM*/
//Local aDados     := array(15)		//Conteudo dos campos que serao gravados no SB6
/*
	[1] - Sequencia Identificadora (NUMSEQ quando for "Poder3 == R" e IDENTB6 quando for "Poder3 == D"
	[2]	 - Codigo do Produto
	[3]	 - Local - Almoxarifado
	[4]	 - Preco unitario do produto
	[5]	 - qtde da Movimentacao na unidade de medida 1
	[6]	 - Unidade de medida 1
	[7]	 - qtde da Movimentacao na unidade de medida 2
	[8]	 - Unidade de medida 2
	[9]	 - Codigo do Cliente ou Fornec.
	[10] - Codigo da loja do cliente ou Fornec.
	[11] - Numero da NF
	[12] - Serie da NF
	[13] - Data de Emissao da NF
	[14] - Data de lanç da NF
	[15] - Codigo do TES
*/

//Local cFilOri
Private cTipo 	 := cTipDoc			//Utiizada na funcao LxA103SB2 e precisava ser declarada
Private aPedPV	 := array(1)		//aray com conteudo para geracao de pedidos de venda a partir de uma nota de devolucao
/*
	[x][1] - serie da nota de origem (D1_SERIORI)
	[x][2] - numero da nota de origem (D1_NFORI)
	[x][3] - item da Nota de Origem (D1_ITEMORI)
	[x][4] - fornec. (D1_FORNECE)
	[x][5] - loja (D1_LOJA)
	[x][6] - qtde atual (D1_QUANT)
	[x][7] - Registro atual (Recno)
*/
Default lGeraPv  := .F.
Default aRecsSF1 := {}

//³Consistindo param.
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String	, "SF1"	, "SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cSinal"	, cSinal	, Sp2String	, "+"	, "-"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	,"SA1"	, "SA2"	} )
Aadd(aPars, {"nRecnoC"	, nRecnoC	, SpEmpty					} )
Aadd(aPars, {"aCusto"	, aCusto	, SpEmpty					} )
If aCfgNf[SlConFrDp][1].OR.aCfgNf[SlConFrDp][2]
	Aadd(aPars, {"aRecsSF1"	, aRecsSF1	, SpEmpty	} )
Endif
lRet := LocxParam("ESTQNOTA", aPars)
If lRet
	//³Definindo valores padrao³
	Asize(aPosicionou, nMaxPos)
	nI := 0
	For nI := 1 to nMaxPos
		aPosicionou[nI] := IIf(aPosicionou[nI]==NIL, .F., aPosicionou[nI])
	Next nI
	If lRet
		//³Montando array com dados para localizar uma possivel NF de Origem
		aNfOrig := { &(cPrefI+"_FILIAL")	, &(cPrefI+"_NFORI")	, &(cPrefI+"_SERIORI")	, &(cPrefI+cClifor)	,;
		&(cPrefI+"_LOJA")		, &(cPrefI+"_COD")		, &(cPrefI+"_ITEMORI") 	}
		If lRet //(3)
			//³ Atualiza SB6 - Poder de Terceiros
			If SF4->F4_PODER3 $ "R|D"
				MaAtuSB6(cAliasI,IIf(cAliasI=="SD1",1,3))
			EndIf
			//³Ponto de Entrada apos atualizacoes do SB2³
			cPe	:=	LocxPE(10)
			If !Empty(cPE)
				ExecBlock(cPE,.F.,.F.)
			EndIf
			If lRet
				//³Tratamento do Controle de Qualidade³
				lEnviaCQ := TrataCQ(cAliasI,SF4->F4_CODIGO,SF4->F4_PODER3,cTipDoc,aRecsSF1)
				//³Atualiza SB2 - Saldos Fisico e financeiro  e Rastreabilidade³
				If cAliasI == "SD1"  //Chama rotina do padrao
					B2AtuComD1(&(cSinal + "1"))
				Else
					B2AtuComD2({SD2->D2_CUSTO1,SD2->D2_CUSTO2,SD2->D2_CUSTO3,SD2->D2_CUSTO4,SD2->D2_CUSTO5},;
						&(cSinal + "1"),If(aPosicionou[lSC9],{ {SD2->D2_PEDIDO,SD2->D2_ITEMPV,SD2->D2_SEQUEN,SD2->D2_QUANT,SD2->D2_QTSEGUM} },),aPosicionou[lSC9])

					//Atualização Estoque WMS
					If aPosicionou[lSC9] .And. FindFunction("WmsFatMI")
						lRet := WmsFatMI(SD2->D2_PEDIDO, SD2->D2_ITEMPV, SD2->D2_SEQUEN, SD2->D2_COD)
					EndIf

					If lRet
						If(FindFunction("AtuLotEnd"),AtuLotEnd(),.F.) // Atualiza Lote e Endereco do Remito
						//³Gera o Servico no DCF - INTEGRACAO COM O WMS	 ³
						If  GetMV('MV_INTDL') == 'S' .AND. !Empty(SD2->D2_SERVIC) .AND. cAliasI == "SD2"
							CriaDCF('SD2')
						EndIf
					EndIf
				EndIf
				If lRet
					//³ Envia o Produto em questao para o CQ (Materiais ou Celerina)
					If lEnviaCQ
						LxA103AtuQuali(SD1->D1_COD, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_ITEM, cTipDoc, .T., 1, aRecsSF1)
					EndIf
					//³ Gera Req. RE5 vinculada a NF Entrada ( Apr. OP )
					If cAliasI == "SD1"
						LxA103GerRE5(lEnviaCQ)
					EndIf
					//³Tratamento exclusivo para Notas de Devolucao³
					If cTipDoc == "D"
						//³Atualiza NF de Origem
						AtuNfOri(cAliasI,aNfOrig)
						//³Verifica se deve gerar pedido de venda
						If cAliasI == "SD1"  .AND. lGeraPv
							aPedPv[1] := { SD1->D1_SERIORI,SD1->D1_NFORI,SD1->D1_ITEMORI,SD1->D1_FORNECE+SD1->D1_LOJA,SD1->D1_QUANT,SD1->(Recno()) }
							a103GrvPV(1,aPedPv)
						EndIf
					EndIf
					//³Tratamento exclusivo para Notas de Retorno
					If aCfgNf[SnTipo] == 63
						//³Atualiza NF de Origem
						AtuNfOri(cAliasI,aNfOrig)
						//³Faz a distribuicao automatica
						If Localiza(SD1->D1_COD).AND. Alltrim(SF1->F1_PEDVEND) == "AUTO"
							nQtdDist	:=	SD1->D1_QUANT
							SD2->(DBSetOrder(3))
							If SD2->(MSSeek(aNfOrig[1]+aNfOrig[2]+aNfOrig[3]+aNfOrig[4]+aNfOrig[5]+aNfOrig[6]+aNfOrig[7]))
								cChave	:=	SD2->(D2_COD+D2_LOCAL+D2_NUMSEQ+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA)
								SDA->(DbSetOrder(1))
								SDA->(MsSeek(xFilial("SDA")+cChave))
								cLoteSDA	:=	SDA->DA_LOTECTL
								lRastro	:=	Rastro(SDA->DA_PRODUTO)
								SDB->(DbSetOrder(1))
								SDB->(MsSeek(xFilial("SDB")+cChave))
								While nQtdDist > 0 .AND. !SDB->(EOF()) .AND. cFilSDB == SDB->DB_FILIAL .AND. cChave == ;
									SDB->(DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA)
									If lRastro .AND. !(cLoteSDA==SDB->DB_LOTECTL)
										SDB->(dbSkip())
										Loop
									EndIf
									nRecDb	:=	SDB->(Recno())
									A100Distri(SD1->D1_COD, SD1->D1_LOCAL, SD1->D1_NUMSEQ, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SDB->DB_LOCALIZ, SDB->DB_NUMSERI, Min(SDB->DB_QUANT,nQtdDist), SDB->DB_LOTECTL, SDB->DB_NUMLOTE )
									nQtdDist	-=	Min(SDB->DB_QUANT,nQtdDist)
									SDB->(MsGoTo(nRecDb))
									SDB->(DbSkip())
								End
							Endif
						Endif
					Endif
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
Return(lRet)
/*ºPrograma  ³PosicionaC     ºLeandro C.G. ³Microsiga º Data ³  22/10/01   º±±
±±ºDesc.     ³ Posiciona arquivos utilizados na atualizacao da NF 		   º±±
±±º			 ³a partir do cabcalho da NF						   		   º±±
param.
cAliasC		- Alias de cabecalho da NF (SF1;SF2)
nRecnoC		- Numero do Registro de cabecalho da NF
cAliasCF	- Indica se deve posicionar Cliente ou Fornec. (SA1;SA2)
*/
Function PosicionaC(cAliasC,nRecnoC,cAliasCF)
Local cPrefC  := cAliasC + "->" + PrefixoCpo(cAliasC)			//Prefixo do Alias do cabecalho de NF
Local cCliFor := IIf(cAliasC=="SF2", "_CLIENTE", "_FORNECE")	//Campo de cliente ou fornec. de acordo com o arquivo de Nota
Local lRet 	  := .T.											//Retorno da funcao. Indica incosistencia da funcao
Local aPars   := {}												//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//³Consistindo param.³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String	, "SF1"	, "SF2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
Aadd(aPars, {"nRecnoC"	, nRecnoC	, SpEmpty					} )
lRet := LocxParam("POSICIONAC",aPars)
If lRet //(1)
	//³Posicionando arquivos³
	&( cAliasC  + "->(MSGoto(" + AllTrim(Str(nRecnoC)) + "))" ) //Cabecalho da Nota
	&( cAliasCF + "->(DBSetOrder(1))" )							 //Cliente ou fornec.
	&( cAliasCF + "->(MSSeek('" + xFilial(cAliasCF) + &(cPrefc+cCliFor) + &(cPrefC+"_LOJA") + "', .F.))" )
EndIf //lRet (1)
Return
/*ºPrograma  ³PosicionaI     ºLeandro C.G. ³Microsiga º Data ³  22/10/01   º±±
±±ºDesc.     ³ Posiciona arquivos utilizados na atualizacao da NF		   º±±
±±º			 ³a partir dos itens da NF						   	   		   º±±
param.
cAliasI	- Indica o Alias de Itens da NF
cAliasCF	- Indica se e cliente ou fornec. (SA1-CLIENTE / SA2-FORN.)
*/
Function PosicionaI(cAliasI,cAliasCF)
Local cPrefI  := ""							//Prefixo do Alias de Itens de Notas Fiscais
Local cPrefCF := ""    						//Prefixo do Alias de Cliente ou Fornec.
Local cCliFor := ""						    //Guarda nome do campo de cliente (_CLIENTE) ou (_FORN.) conforme o necessario
Local lRet 	  := .T.						//Retorno da funcao. Indica incosistencia da funcao
//Local cAliasR := ""							//Indica o Alias de Remito (SCN/SCM) utilizado de acordo com o tipo de NF
Local aPars   := {}						    //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local aSeek   := Array(nMaxPos)			    //Array com indicacao dos arquivos que foram posicionados
Local aArea	  := GetArea()
Local aAreaI  := (cAliasI)->(GetArea())
Local aAreaSF1
/*
	[lSF4]-Indica se foi posicionado SF4 (TES)
	[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
	[lSAx]-Indica se foi poscionado SA1 OU SA2 (CLIENTE OU FORN.)
	[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
	[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
	[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
	[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
	[lSD1]-Indica se foi posicionado SD1 (REMITO DE COMPRA)
	[lSD2]-Indica se foi posicionado SD2 (REMITO DE VENDA)
	[nRecSD1]-Indica o recno do SD1 se posicionado
	[nRecSD2]-Indica o recno do SD2 se posicionado */

//³Consistindo param.
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
lRet := LocxParam("POSICIONAI",aPars)

If lRet //(1)
	//³Definindo valores padrao³
	cPrefI  := cAliasI  + "->" + PrefixoCpo(cAliasI)
	cPrefCF := cAliasCF + "->" + PrefixoCpo(cAliasCF)
	cCliFor := IIf(cAliasI=="SD1","_FORNECE","_CLIENTE")
	Afill(aSeek, .T.)
	If SF4->(EOF().OR.BOF()) .OR. SF4->F4_FILIAL+SF4->F4_CODIGO != xFilial("SF4")+&(cPrefI+"_TES")
		SF4->( DBSetOrder(1) )
		aSeek[lSF4] := SF4->(MSSeek(xFilial("SF4")+&(cPrefI+"_TES"), .F.))
	EndIf
	If SB1->(EOF().OR.BOF()) .OR. SB1->B1_FILIAL+SB1->B1_COD != xFilial("SB1")+&(cPrefI+"_COD")
		SB1->( DBSetOrder(1) )
		aSeek[lSB1] := SB1->(MSSeek(xFilial("SB1")+&(cPrefi+"_COD"), .F.))
	EndIf
	If (cAliasCF)->(EOF().OR.BOF()) .OR. &(cPrefCF+"_FILIAL")+&(cPrefCF+"_COD")+&(cPrefCF+"_LOJA") != xFilial(cAliasCF)+&(cPrefI+cClifor)+&(cPrefI+"_LOJA")
		&( cAliasCF + "->( DBSetOrder(1) )" )
		aSeek[lSAx] := &( cAliasCF + "->( MSSeek('" + xFilial(cAliasCF) + &(cPrefI+cClifor) + &(cPrefI+"_LOJA") + "', .F.) )" )
	EndIf
	//³Arquivos so utilizados quando o arquivo de Notas for SD2
	If cAliasI == "SD2"
		//³PEDIDOS DE VENDA (SC5)
		If Empty(SD2->D2_PEDIDO)
			aSeek[lSC5] := .F.
		ElseIf SC5->(EOF().OR.BOF()) .OR. SC5->C5_FILIAL+SC5->C5_NUM != xFilial("SC5")+SD2->D2_PEDIDO
			SC5->(DBSetOrder(1))
			aSeek[lSC5] := SC5->(MSSeek(xFilial("SC5")+SD2->D2_PEDIDO, .F.))
		EndIf
		//³ITENS DE PEDIDOS DE VENDA (SC6)
		If Empty(SD2->D2_PEDIDO)
			aSeek[lSC6] := .F.
		ElseIf SC6->(EOF().OR.BOF()) .OR. SC6->C6_FILIAL+SC6->C6_NUM+SC6->C6_ITEM+SC6->C6_PRODUTO != xFilial("SC6")+SD2->D2_PEDIDO+SD2->D2_ITEMPV+SD2->D2_COD
	    	SC6->(DBSetOrder(1))
	    	aSeek[lSC6] := SC6->(MSSeek(xFilial("SC6")+SD2->D2_PEDIDO+SD2->D2_ITEMPV+SD2->D2_COD, .F.))
	 	EndIf
		//³PEDIDOS LIBERADOS (SC9)
		If Empty(SD2->D2_PEDIDO)
			aSeek[lSC9] := .F.
		ElseIf SC9->(EOF().OR.BOF()) .OR. SC9->C9_FILIAL+SC9->C9_CLIENTE+SC9->C9_LOJA+SC9->C9_PEDIDO+SC9->C9_ITEM+SC9->C9_SEQUEN+SC9->C9_PRODUTO != xFilial("SC9")+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_PEDIDO+SD2->D2_ITEMPV+SD2->D2_SEQUEN+SD2->D2_COD
			SC9->(DBSetOrder(1))
			aSeek[lSC9] := SC9->(MSSeek(xFilial("SC9")+SD2->D2_PEDIDO+SD2->D2_ITEMPV+SD2->D2_SEQUEN+SD2->D2_COD, .F.))
		EndIf
		//³CARGAS (DAK)
		If Empty(SF2->F2_CARGA)
			aSeek[lDAK] := .F.
		ElseIf (DAK->(EOF().OR.BOF()) .OR. DAK->(DAK_FILIAL+DAK_COD+DAK_SEQCAR) != xFilial("DAK")+SF2->(F2_CARGA+F2_SEQCAR))
			DAK->(DBSetOrder(1))
			aSeek[lDAK] := DAK->(MSSeek(xFilial("DAK")+SF2->(F2_CARGA+F2_SEQCAR), .F.))
		EndIf
		//³REMITOS³
		SD2->(DbSetOrder(3))
		aSeek[lSD2] 	:= SD2->(MSSeek(xFilial("SD2")+SD2->D2_REMITO+SD2->D2_SERIREM+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMREM))
		aSeek[nRecSD2]	:=	If(aSeek[lSD2],SD2->(Recno()),0)
		//³Acerta indicador de posicionamento de arquivos que nao foram posicionados³
		aSeek[lSC7] 	:= .F.
		aSeek[lSD1] 	:= .F.
		aSeek[nRecSD1]	:=	0
		aSeek[lSF1] 	:= .F.
		aSeek[nRecSF1]	:=	0
	//³Arquivos so utilizados quando o arquivo de Notas for SD2³
	ElseIf cAliasI == "SD1"
		//³PEDIDOS DE COMPRA (SC7)³
		If SC7->(EOF().OR.BOF()) .OR. SC7->C7_FILENT+SC7->C7_NUM+SC7->C7_ITEM != xFilEnt(xFilial("SC7"))+SD1->D1_PEDIDO+SD1->D1_ITEMPC
	    	SC7->(DBSetOrder(14))
	    	aSeek[lSC7] := SC7->(MSSeek(xFilEnt(xFilial("SC7"))+SD1->D1_PEDIDO+SD1->D1_ITEMPC, .F.))
		EndIf
		//³REMITOS³
		SD1->(DbSetOrder(1))
		aSeek[lSD1] 	:= SD1->(MSSeek(xFilial("SD1")+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMREM))
		aSeek[nRecSD1]	:=	If(aSeek[lSD1],SD1->(Recno()),0)

 		aAreaSF1  := SF1->(GetArea())
		SF1->(DbSetOrder(3))
		aSeek[lSF1] 	:= SF1->(MSSeek(xFilial("SF1")+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO))
		aSeek[nRecSF1]	:=	If(aSeek[lSF1],SF1->(Recno()),0)
		RestArea(aAreaSF1)
		//³Acerta indicador de posicionamento de arquivos que nao foram posicionados³
		aSeek[lSC5] 	:= .F.
		aSeek[lSC6] 	:= .F.
		aSeek[lSC9] 	:= .F.
		aSeek[lSD2] 	:= .F.
		aSeek[nRecSD2]	:=	0
	EndIf
	RestArea(aAreaI)
	RestArea(aArea)
EndIf //lRet (1)
Return(IIf(lRet,aSeek,NIL))
/*ºPrograma  ³AtuNfOri       ºLeandro C.G. ³Microsiga º Data ³  19/10/01   º±±
±±ºDesc.     ³ Atualiza dados de um item de uma NF de Origem no   		   º±±
±±º			 ³momento da devolucao										   º±±
param.
cAlias		- Alias do item da Nota de Devolucao
aNfOrig 	- array com o conteudo dos campos utilizados para chave de busca da nota de origem
          	As posicoes deste array se referem aos seguintes campos :
		  	[1]-D1_FILIAL
		  	[2]-D1_DOC
		  	[3]-D1_SERIE
		  	[4]-D1_FORNECE
		  	[5]-D1_LOJA
		  	[6]-D1_COD
		  	[7]-D1_ITEM
Obs.: Considera que a Nota de Devolucao esta posicionada no registro correto */
Static Function AtuNfOri(cAlias,aNfOrig)
Local cAOri    := ""			//Alias da Nota Original
Local cPref    := ""			//Prefixo do Alias atual
Local cPrefOri := ""			//Prefixo do Alias da Nota Original
Local aArea    := GetArea()		//Guarda area atual
Local lRet 	   := .T.			//Retorno da funcao. Indica incosistencia da funcao
Local aPars	   := {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local cPesquisa := ""			// utilizada na pesquisa da nota pra atualizar a quantidade devolvida na noa correta

ASIZE(aNfOrig, 7)
//³Consistindo param. ³
Aadd(aPars, {"cAlias"	, cAlias, Sp2String		,"SD1"	,"SD2"	} )
lRet := LocxParam("ATUNFORI",aPars)

If lRet //(1)
	//³Atribuindo valores padrao³
	cAOri    := IIf(cAlias=="SD1", "SD2", "SD1") 		//Inverte o Alias
	cPref    := cAlias + "->" + PrefixoCpo(cAlias)
	cPrefOri := cAOri  + "->" + PrefixoCpo(cAOri)
	//³Posiciona Nota Original³
	&( cAOri + "->(DBSetOrder(" + IIf(cAOri=="SD1","1","3") + "))" )
	// devolução de protuto Loja
	// Pelo loja tem que usar o cliente de origem da SF2 pois se vendar para cliente padrão e devolver para outro cliente
	// a devolução tem que ser realizada no item da nota de origem
	If IsInCallStack("LOJA720")
		cPesquisa := cAOri + "->(MSSeek('" + aNfOrig[1]+aNfOrig[2]+aNfOrig[3]+SF2->F2_CLIENTE+SF2->F2_LOJA+aNfOrig[6]+aNfOrig[7] + "',	.F.))"
	Else
		cPesquisa := cAOri + "->(MSSeek('" + aNfOrig[1]+aNfOrig[2]+aNfOrig[3]+aNfOrig[4]+aNfOrig[5]+aNfOrig[6]+aNfOrig[7] + "',	.F.))"
	EndIf
	If &(cPesquisa)
		//³Atualizando dados³
		RecLock(cAOri, .F.)
		Replace &( cPrefOri + "_QTDEDEV" ) With &( cPrefOri + "_QTDEDEV + " + cPref + "_QUANT" )
		Replace &( cPrefOri + "_VALDEV" )  With &( cPrefOri + "_VALDEV + "  + cPref + "_TOTAL" )
		MsUnlock()
		//³Sao atualizados tambem os campos QTDEDEV e VALDEV das notas ou remitos associados³
		//³a nota ou remito original aqui posicionado.                                      ³
		//³Isso garante que futuras notas de credito ou remitos de devolucao considerem o   ³
		//³saldo a devolver corretamente.                                                   ³
		If "MATA102" $ Funname() .OR. "MATA462" $ Funname()
			// Pesquisa pela nota gerada pelo remito original
			DBSelectArea(cAOri)
			DBSetOrder(If(cAOri=="SD1",10,9))
			If MsSeek(aNfOrig[1]+aNfOrig[4]+aNfOrig[5]+aNfOrig[3]+aNfOrig[2]+aNfOrig[7], .F.)
				RecLock(cAOri, .F.)
				Replace &( cPrefOri + "_QTDEDEV" ) With &( cPrefOri + "_QTDEDEV + " + cPref + "_QUANT" )
				Replace &( cPrefOri + "_VALDEV" )  With &( cPrefOri + "_VALDEV + "  + cPref + "_TOTAL" )
				MsUnlock()
			EndIf
		Elseif "MATA465" $ Funname() .OR. "MATA466" $ Funname()
			// Pesquisa, se houver, o remito vinculado aa nota original
			If !Empty( &( cPrefOri + "_REMITO" )+&( cPrefOri + "_SERIREM" ) )
				DBSelectArea(cAOri)
				DBSetOrder(If(cAOri=="SD1",1,3))
				If MsSeek(aNfOrig[1]+&( cPrefOri + "_REMITO" )+&( cPrefOri + "_SERIREM" )+aNfOrig[4]+aNfOrig[5]+aNfOrig[6]+&( cPrefOri + "_ITEMREM" ), .F.)
					RecLock(cAOri, .F.)
					Replace &( cPrefOri + "_QTDEDEV" ) With &( cPrefOri + "_QTDEDEV + " + cPref + "_QUANT" )
					Replace &( cPrefOri + "_VALDEV" )  With &( cPrefOri + "_VALDEV + "  + cPref + "_TOTAL" )
					MsUnlock()
				EndIf
			EndIf
		EndIf
	EndIf
	//³Reposiciona area atual³
	RestArea(aArea)
EndIf //lRet (1)
Return(lRet)
/*ºPrograma  ³TrataCQ        ºLeandro C.G. ³Microsiga º Data ³  19/10/01   º±±
±±ºDesc.     ³ Atualiza dados de um item de uma NF de Origem no  		   º±±
±±º			 ³momento da devolucao										   º±±
param.
cAlias		- Alias da NF
cTes		- Tes utilizado na NF
cPoder3		- Indica qual a movimentacao de poder de terceiros (R-Remessa / D-Devolucao)
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
aRecSF1Ori  - Registros referentes as Notas Originais quando for uma Nota de Complemento ou de Frete

.:Devolve como resultado a variavel lEnviaCQ que diz se o produto foi enviado ao controle de qualidade.
Isto so ira ocorrer quando se tratar de uma de Entrada não de uma Devolucao */
Function TrataCQ(cAlias,cTes,cPoder3,cTipDoc,aRecSF1Ori)
Local cLocal 	:= ""
Local lEnviaCQ 	:= .F.
//³Verifica que tipo de arquivo de nota esta sendo gravado para saber se e uma entrada ou uma saida
//³ Verifica se o Produto em questao sera enviado ao CQ
//³ Atualiza o almoxarifado dos aqruivos do Items da NF e de Poder de 3os, gravando no ³
//³campo D1_LOCAL E B6_LOCAL o almoxarifado referente ao Controle de Qualidade
If cAlias == "SD1"
	If Empty(SD1->D1_REMITO)
		If 	LxA103ChkQuali(SD1->D1_COD, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_ITEM, cTipDoc, NIL) .AND.;
 			LxA103PreQuali(SD1->D1_COD, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_ITEM, SD1->D1_TES, .T.,@cLocal)

			lEnviaCQ := .T.
		EndIf
	EndIf
//³Nota de Saida  ³Esta parte da rotina foi retirada do fonte MATA461
ElseIf SF2->F2_TIPO == "D" .AND. cAlias == "SD2"
	//³Posiciona Nota de origem se houver³
	SD1->(dbSetOrder(1))
	If SD1->(MSSeek(xFilial("SD1")+SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM, .F.))
		//³Baixa do CQ
		If !Empty(SD1->D1_NUMCQ)
			MaCQ2SD2()
		EndIf
		//³ Atualiza lotes
		If Rastro(SD2->D2_COD) .AND. SF4->F4_ESTOQUE == "S" .AND. !(SF2->F2_TIPO) $ "CIP"
			RecLock("SD1",.F.)
			SD1->D1_NUMLOTE := SD2->D2_NUMLOTE
			SD1->D1_LOTECTL := SD2->D2_LOTECTL
			SD1->D1_DTVALID := SD2->D2_DTVALID
			MsUnLock()
		EndIf
	EndIf
EndIf
Return(lEnviaCQ)
/*³Fun‡…o    ³Amarracao ³±±
±±³Descri‡…o ³Atualiza amarracao de Cliente    X Produto ; (SA7)          ³±±
±±³			 ³						Fornec. X Produto ; (SA5)      	      ³±±
±±³			 ³ 						Fornec. X Grupo     (SAD)		  	  ³±±
param.
cPreco		- Preco unitario de amarracao 	 (obrigt qdo lInd1 ou lInd2 igual a .T.)
dEmissao 	- Data de emissao para amarracao (obrigt qdo lInd1 ou lInd2 igual a .T.)
lInd1		- Indica se deve ser feita amarracao de CLIENTEXPRODUTO    (Default .F.)
lInd2		- Indica se deve ser feita amarracao de FORNECEDORXPRODUTO (Default .F.)
lInd3		- Indica se deve ser feita amarracao de FORNECEDORXGRUPO   (Default .F.)
Obs.:Considera que os registros de Produto e Cliente ou Fornec. ja estao posicionados no registro correto */
Function Amarracao(cPreco,dEmissao,lInd1,lInd2,lInd3)
Local lAtuaSa7 := .F.	//Indica inclusao de registro no arquivo SA7 (CLIENTEXPRODUTO)
Local cAux,cAux1			//Auxiliares para carecteres
Local nAux,nAux1			//Auxiliares para numericos
Local lRet := .T.			//Retorno da funcao. Indica incosistencia da funcao
Local aPars := {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nI,nX				//Flag's para Loop's
Default lInd1 := .F.
Default lInd2 := .F.
Default lInd3 := .F.
//³Consistindo param.³
If lInd1 .OR. lInd2
	Aadd(aPars, {"cPreco"	, cPreco	, SpEmpty	} )
	Aadd(aPars, {"dEmissao"	, dEmissao	, SpEmpty	} )
	lRet := LocxParam("AMARRACAO",aPars)
EndIf
If lRet //(1)
	//³Atualiza amarracao de CLIENTE X PRODUTO³
	If lInd1
		//³Verifica se já existe amarracao³
		SA7->(dbSetOrder(1))
		If !SA7->(MsSeek(xFilial("SA7")+SA1->A1_COD+SA1->A1_LOJA+SB1->B1_COD))
			//³Cria novo registro de amarracao³
			lAtuaSa7 := .T.
			Reclock("SA7",.T.)
			Replace A7_FILIAL  With xFilial("SA7")
			Replace A7_PRODUTO With SB1->B1_COD
			Replace A7_CLIENTE With SA1->A1_COD
			Replace A7_LOJA    With SA1->A1_LOJA
			Replace A7_PRECO01 With cPreco
			Replace A7_DTREF01 With dEmissao
			MsUnlock()
		Else
			//³Atualiza registro ja existente³
			nI := 0
			Reclock("SA7",.F.)
			For nI := 1 TO 12
				cAux := StrZero(nI,2)
				If Empty(A7_DTREF&cAux)
					lAtuaSa7 := .T.
					Replace A7_PRECO&cAux With cPreco
					Replace A7_DTREF&cAux With dEmissao
					MsUnlock()
					Exit
				EndIf
			Next nI
			//³Se necessario acerta valores dos ultimos 12 precos³
			If !(lAtuaSa7)
				nI := 0
				Reclock("SA7")
				For nI := 1 To 11
					nAux1 := nI + 1
					cAux  := StrZero(nI,2)
					cAux1 := StrZero(nAux1,2)
					Replace A7_PRECO&cAux With A7_PRECO&cAux1
					Replace A7_DTREF&cAux With A7_DTREF&cAux1
				Next nI
				Replace A7_PRECO12  With cPreco
				Replace A7_DTREF12  With dEmissao
				MsUnlock()
			EndIf
		EndIf
	EndIf
	//³Atualiza amarracao FORNECEDOR X PRODUTO³
	If lInd2
		SA5->(dbSetOrder(1))
		If !SA5->(MSSeek(xFilial("SA5")+SA2->A2_COD+SA2->A2_LOJA+SB1->B1_COD))
			RecLock("SA5",.T.)
			Replace A5_FILIAL  With xFilial("SA5")	,;
					A5_FORNECE With SA2->A2_COD		,;
					A5_LOJA    With SA2->A2_LOJA	,;
					A5_NOMEFOR With SA2->A2_NOME	,;
					A5_PRODUTO With SB1->B1_COD		,;
					A5_NOMPROD With SB1->B1_DESC
		EndIf
	EndIf
	//³Atualiza amarracao FORNECEDOR X GRUPO³
	If lInd3
		//³Posiciona arquivo de tabelas³
		SBM->(DBSetOrder(1))
		SBM->(MSSeek(xFilial("SBM")+SB1->B1_GRUPO))
		//³Verifica se existe o grupo e se ainda nao existe registro de amarracao³
       If !Empty(SB1->B1_GRUPO)
			SAD->(DBSetOrder(1))
			If !SAD->(MSSeek(xFilial("SAD")+SA2->A2_COD+SA2->A2_LOJA+SB1->B1_GRUPO))
				RecLock("SAD",.T.)
				Replace     AD_FILIAL   With xFilial("SAD")	,;
							AD_FORNECE  With SA2->A2_COD	,;
							AD_LOJA     With SA2->A2_LOJA	,;
							AD_NOMEFOR  With SA2->A2_NOME	,;
							AD_GRUPO    With SB1->B1_GRUPO	,;
							AD_NOMGRUP  With SBM->BM_DESC
			EndIf
		EndIf
	EndIf
EndIf //lRet (1)
Return(lRet)
/*³Fun‡…o    ³ExisteCampo ³ Autor ³ Leandro C. G.         ³ Data ³29/10/2001³±±
±±³Descri‡…o ³Verifica existencia de um campo qualquer param:               ³±±
cCampo		- Campo que sera procurado
lVirtual    - Considera(.T.) ou nao considera(.F.) campo virtual como campo existente (default .T.)
lForaUso	- Considera(.T.) ou nao considera(.F.) campo fora de uso como campo existente (default .T.)
lSemNivel	- Considera(.T.) ou nao considera(.F.) campo sem nivel como campo existente (default .T.)
Retorno
aRet		- array de duas posicoes com a validacao e o status do campo em relacao ao SX3
			(1) - lRet
			(2) - nRet */
Function ExisteCampo(cCampo,lVirtual,lForaUso,lSemNivel)
Local   aArea     := GetArea()
Local   aSX3	  := GetArea("SX3")
Local   lRet      := .T.				//Indica validacao do campo (.T./.F.)
Local   nRet      := 0
	/*De acordo com o numero, indica caracteristica do campo do SX3
		(0) - EXISTENTE
		(1) - NAO ENCONTRADO DO SX3
		(2) - CAMPO VIRTUAL
		(3) - CAMPO FORA DE USO
		(4) - NIVEL INSUFICIENTE
	*/
Local   aRet      := Array(2)			//(1)-lRet / (2)-nRet
Default cCampo    := ""
Default lVirtual  := .T.
Default lForaUso  := .T.
Default lSemNivel := .T.

aRet[1] := lRet
aRet[2] := nRet

DBSelectArea("SX3")
DBSetOrder(2)
If MSSeek(cCampo, .F.)
	lRet := IIf(!lVirtual.AND.SX3->X3_CONTEXT=="V",.F.,.T.)
	nRet := IIf(SX3->X3_CONTEXT=="V",2,0)
	If !(Substr(cCampo,4,6) $ "BASIMP*ALQIMP*VALIMP")
		lRet := IIf(lRet.AND.!lForaUso,IIf(!X3uso(SX3->X3_USADO),.F.,.T.),lRet)
		nRet := IIf(!X3uso(SX3->X3_USADO),3,nRet)
		lRet := IIf(lRet.AND.!lSemNivel,IIf(cNivel<SX3->X3_NIVEL,.F.,.T.),lRet)
		nRet := IIf(cNivel<SX3->X3_NIVEL,4,nRet)
	Endif
Else
	nRet := 1
	lRet := .F.
EndIf

aRet[1] := lRet
aRet[2] := nRet

RestArea(aArea)
RestArea(aSX3)
Return(aRet)
/*
±±³Fun‡…o    ³ExisteAlias ³ Autor ³ Leandro C. G.         ³ Data ³29/10/2001³±±
±±³Descri‡…o ³Verifica existencia de um Alias qualquer                      ³±±
param:   cAlias		- Alias que sera procurado */
Function ExisteAlias(cAlias)
Local   aArea	:= GetArea("SX2")
Local   lRet    := .T.
Default cAlias  := ""

SX2->(DBSetOrder(1))
lRet := IIf(!SX2->(MSSeek(cAlias, .F.)), .F., .T.)
RestArea(aArea)
Return(lRet)
/*³Fun‡…o    ³PrecoMarkup ³ ±±
±±³Descri‡…o ³Efetua a atualizacao do Preco de Venda de um produto com base ³±±
±±³          ³no Markup 	param:						                    ³±±
cProd		- Produto que deve ser atualizado
nQuant		- Qtde da movimentacao do produto
nCusto		- Custo total da movimentacao na moeda1
cGrupo		- Codigo do Grupo do Produto */
Function PrecoMarkup(cProd,nQuant,nCusto,cGrupo)
Local lRet 	 := .T.			//Retorno da funcao. Indica incosistencia da funcao
Local aPars  := {}				//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//³Consistindo param.
Aadd(aPars, {"cProd"	, cProd		, SpEmpty		} )
Aadd(aPars, {"nQuant"	, nQuant	, SpEmpty		} )
Aadd(aPars, {"nCusto"	, nCusto	, SpEmpty		} )
lRet := LocxParam("PRECOMARKUP",aPars)

If lRet //(1)
	//³Atualizacao do Preco de Venda com base no Markup
	DBSelectArea("SBM")
	DBSetOrder(1)
	If MSSeek(xFilial("SBM")+cGrupo, .F.)
		If SBM->BM_MARKUP > 0 .AND. !Empty(SBM->BM_PRECO)
			If SBM->BM_PRECO > "1"
				DBSelectArea("SB5")
				DBSetOrder(1)
				If FieldPos("B5_PRV"+SBM->BM_PRECO)<>0 .AND. MSSeek(xFilial("SB5")+cProd, .F.)
					RecLock("SB5")
					FieldPut(FieldPos("B5_PRV"+SBM->BM_PRECO),nCusto*SBM->BM_MARKUP/nQuant)
					MsUnlock()
				EndIf
			Else
				RecLock("SB1")
				SB1->B1_PRV1 := nCusto*SBM->BM_MARKUP/nQuant
				MsUnLock()
			EndIf
		EndIf
	EndIf
EndIf //(1)
Return(lRet)
/*³Fun‡…o    ³AtuSA2Nf    ³ Autor ³ Leandro C. G.         ³ Data ³31/10/2001³±±
±±³Descri‡…o ³Efetua todas as atualizacoes necessarias no arquivo de 		³±±
±±³          ³fornec. (SA2)		param:						 				³±±
cAliasC		- Alias de cabecalho de NF
cAliasI		- Alias de Itens de NF
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipAtu     - Indica se e uma atualizacao pelo cabecalho da nota ou pelos itens
			  "C" - Cabecalho ; "I" - Itens
Obs.: Considera que os arquivos de NF e Fornec. estao posicionados no registro correto */
Function AtuSA2Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)
Local nMCompra := 0							//Valor da maior compra
Local lRet 	   := .T.						//Retorno da funcao. Indica incosistencia da funcao
Local aPars	   := {}						//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//³Consistindo paramteros³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cTipAtu"	, cTipAtu	, Sp2String		,"C"	,"I"	} )
lRet := LocxParam("ATUSA2NF",aPars)
If lRet //(1)
	//³Atualizacoes de cabecalho
	If cTipAtu == "C"
		//³Verifica valor da maior compra do fornec.³
		If cAliasC == "SF1" .AND. cTipDoc == "N"
			nMCompra := xMoeda(SF1->F1_VALBRUT,SF1->F1_MOEDA,Val(GetMv("MV_MCUSTO")),SF1->F1_DTDIGIT)
			If SA2->A2_MCOMPRA < nMCompra
				RecLock("SA2",.F.)
				Replace A2_MCOMPRA With nMCompra
				Replace A2_MNOTA   With Max(SA2->A2_MNOTA,nMCompra)
				MsUnlock()
			EndIf
		EndIf
	EndIf
EndIf //lRet (1)
Return(lRet)
/*³Fun‡…o    ³AtuSA1Nf    ³ Autor ³ Leandro C. G.         ³ Data ³31/10/2001³±±
±±³Descri‡…o ³Efetua todas as atualizacoes necessarias no arquivo de 		³±±
±±³          ³Clientes (SA1)												³±±
±±³ Uso      ³ ESTQNOTA  			param:								    ³±±
cAliasC		- Alias de cabecalho de NF
cAliasI		- Alias de Itens de NF
cTipDoc 	- Tipo de documento, utilizado para identificar se e uma devolucao
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipAtu     - Indica se e uma atualizacao pelo cabecalho da nota ou pelos itens
			  "C" - Cabecalho ; "I" - Itens
lPosicSC5	- Indica que foi posicionado o arquivo SC5 (pedidos de venda)
lPosicSC9	- Indica que foi posicionado o arquivo SC9 (itens de pedidos liberados)
Obs.: Considera que os arquivos de NF, TES e Clientes estao posicionados no registro correto */
Function AtuSA1Nf(cAliasC,cAliasI,cTipDoc,cTipAtu,lPosicSC5,lPosicSC9,nSinal)
Local lRet 	      := .T.	//Retorno da funcao. Indica incosistencia da funcao
Local aPars	   	  := {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nMCusto     := 0
Default lPosicSC5 := .F.
Default lPosicSC9 := .F.
Default nSinal		:=	1

//³Consistindo paramteros³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cTipAtu"	, cTipAtu	, Sp2String		,"C"	,"I"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty						} )
Aadd(aPars, {"nSinal"	, nSinal		, SpEmpty					} )
lRet := LocxParam("ATUSA1NF",aPars)
If lRet //(1)
	//³Atualizacoes de cabecalho da Nota cTipAtu == "C"³
	If cTipAtu == "C"
		//³Atualizando saldo de pedidos liberados³
		If !cTipDoc $ "DB" .AND. lPosicSC5 .AND. lPosicSC9 .AND. SF4->F4_DUPLIC == "S"
			Reclock("SA1",.F.)
			nMCusto := If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			Replace A1_SALPEDL With A1_SALPEDL - (xMoeda(SC9->C9_PRCVEN*SC9->C9_QTDLIB, SC5->C5_MOEDA, nMCusto, SC9->C9_DATALIB) * nSinal)
			MsUnlock("SA1")
		EndIf
	EndIf
EndIf //lRet (1)
Return(lRet)
/*
±±³Fun‡…o    ³AtuSB1Nf    ³ Autor ³ Leandro C. G.         ³ Data ³31/10/2001³±±
±±³Descri‡…o ³Efetua todas as atualizacoes necessarias no arquivo de 		³±±
±±³          ³Produtos (SB1)	param:										³±±
cAliasC		- Alias de cabecalho de NF
cAliasI		- Alias de Itens de NF
cTipDoc 	- Tipo de documento, utilizado para identificar se e uma devolucao
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipAtu     - Indica se e uma atualizacao pelo cabecalho da nota ou pelos itens
			  "C" - Cabecalho ; "I" - Itens
Obs.: Considera que os arquivos de NF, TES e Produtos estao posicionados no registro correto
*/
Function AtuSB1Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)
Local   lRet 	    := .T.						//Retorno da funcao. Indica incosistencia da funcao
Local 	aPars	    := {}						//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local   aArea	    := {}
Local   cAuxPaisL   := "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"

//³Consistindo paramteros
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty						} )
Aadd(aPars, {"cTipAtu"	, cTipAtu	, Sp2String		,"C"	,"I"	} )
lRet := LocxParam("ATUSB1NF",aPars)
If lRet //(1)
	//³Atualizacoes de Itens da Nota cTipAtu == "I"³
	If cTipAtu == "I"
		//³Atualiza ultimo preco de compra³
		If 	cAliasC=="SF1" .AND. cTipDoc=="N" .AND. SF4->F4_UPRC=="S" .AND. SF1->F1_EMISSAO >= RetFldProd(SB1->B1_COD,"B1_UCOM")
			If RetArqProd(SB1->B1_COD)
				RecLock("SB1",.F.)
				Replace B1_UCOM With SF1->F1_EMISSAO
				Replace B1_UPRC With xMoeda(SD1->D1_VUNIT,SF1->F1_MOEDA,1,dDataBase,,SF1->F1_TXMOEDA)
				MsUnlock()
			Else
				aArea := GetArea()
				RecLock("SBZ",.F.)
				Replace BZ_UCOM With SF1->F1_EMISSAO
				Replace BZ_UPRC With xMoeda(SD1->D1_VUNIT,SF1->F1_MOEDA,1,dDataBase,,SF1->F1_TXMOEDA)
				MsUnlock()
				RestArea(aArea)
			Endif
			RecLock("SB1",.F.)
			If cPaisLoc $ cAuxPaisL
				Replace B1_UMOEC With SF1->F1_MOEDA
				Replace B1_UVLRC With SD1->D1_VUNIT
			EndIf
			MsUnlock()
		EndIf
	EndIf
EndIf //lRet (1)
Return(lRet)
/*
±±³Fun‡…o    ³AtuarqNf    ³ Autor ³ Leandro C. G.         ³ Data ³05/11/2001³±±
±±³Descri‡…o ³Efetua atualizacoes necessarias em todos os arquivos que devem³±±
±±³          ³ser gravados em uma gravacao de Notas Fiscais					³±±
±±³ Uso      ³ ESTQNOTA  	param:										    ³±±
cAliasC		- Alias de cabecalho de NF
cAliasI		- Alias de Itens de NF
cTipDoc 	- Tipo de documento, utilizado para identificar se e uma devolucao
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cTipAtu     - Indica se a funcao foi chamada na gravacao do cabecalho da nota ou do item
			  "C" - Cabecalho ; "I" - Item
aPosicionou	- 	Array com a indicacao dos arquivos que estao posicionados posicionados
				[lSF4]-Indica se foi posicionado SF4 (TES) ... obrigatoria
				[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
				[lSAx]-Indica se foi posicionado SA1 OU SA2 (CLIENTE OU FORN.)
				[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
				[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
				[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
				[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
aCusto		- valor do custo referente ao item em todas as moedas utilizadas
aRateio		- array com os itens de rateio por centro de custo referente ao item atual (dados a atualizar no arquivo SDE)
			[x][1] - numero do item (XX_ITEM)
			[x][2] - dados a serem atualizados
aPergs		- Array com o conteudo das perguntas feitas na tela de NF
			[SlAmarraca 1]	-   Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
			[SlGerCtbil 2]	-   lanç. On-Line?
			[SlVerCtbil 3]	- 	Mostra Lanç.Contab ?
			[SlAglutina 4]	-	Aglut Lançamentos  ?
			[SlQbraAliq 5]	-	Quebra do Rodapé   ? Por Alíquota    /  Por Imposto
			[SlCtbEmiss 6]	-	Contabiliza por    ? Emissao         /  Data Base
aAtualiza 	- Define atualizacoes a serem feitas .T./.F. (quando .F. prevalece sobre o TES) - Default .T.
			   [SlCtbilOL]  - contabilzar On-line
			   [SlAtuEstq]  - atualizar estoque
			   [SlAtuFina]  - atualizar financeiro
			   [SlAtuImp]   - gravar impostos
			   [SlAtuLF]    - atualizar livros fiscais
			   [SlConsist]  - efetuar as rotinas de consistencia
			   [SlCusto]	- efetuar atualizacao do custo
nItem		- Numero do Item que esta sendo atualizado, quando a atualizacao for a partir da gravacao do item da Nota
Obs.: Considera que todos os arquivos de envolvidos com as atualizacoes estao posicionados em seus registros corretos
*/
Function AtuArqNf(cAliasC,cAliasI,cAliasCF,cTipDoc,cTipAtu,aPosicionou,nItem,aCusto,aRateio,aPergs,aAtualiza)
//Local nI,nX														//Flag's para Loop's
Local aArea    := GetArea()										//Salva area de trabalho
Local cPrefI   := ""											//Prefixo do Alias de itens da NF
Local cPreco   := IIf(cAliasI=="SD1", "_VUNIT", "_PRCVEN")  	//Indica se e cliente ou fornec.
Local lRet 	   := .T.											//Retorno da funcao. Indica incosistencia da funcao
Local aPars	   := {}											//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//Local nV       := 0
//Local cBaseATF := ""
Local aAreaSC7 := {}
Local aAreaSD1 := {}

//³Consistindo paramteros³
Aadd(aPars		, {"cAliasC"	, cAliasC	, Sp2String	, "SF1"	, "SF2"	} )
Aadd(aPars		, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars		, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
Aadd(aPars		, {"cTipAtu"	, cTipAtu	, Sp2String	, "C"	, "I"	} )
Aadd(aPars		, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
If cTipAtu == "I"
	Aadd(aPars	, {"nItem"	, nItem	, SpEmpty							} )
EndIf
lRet := LocxParam("ATUARQNF",aPars)

//³Valores padrao³
cPrefI 			  := cAliasI + "->" + PrefixoCpo(cAliasI)
Default aCusto	  := {}
Default aRateio	  := {}
Default aPergs    := {}
Default aAtualiza := {}

If lRet //(1)
	//³Atualizacoes efetuadas quando a rotina for chamada pela gravacao de um item da NF ³
	If cTipAtu == "I"
		//³Atualizacoes relacionadas exclusivamente ao arquivo SD1/SF1³
		If cAliasI == "SD1"
			//³Atualizacao do preco de venda com base no Markup³
			If aPosicionou[lSF4] .AND. SF4->F4_UPRC == "S" .AND. aPosicionou[lSB1]
				If !PrecoMarkup(SD1->D1_COD,SD1->D1_QUANT,SD1->D1_CUSTO,SB1->B1_GRUPO)
					lRet := .F.
				EndIf
			EndIf
			If lRet //(2)
				//³Atualizacoes referentes ao Arquivo de Pedidos de Compra³
				If  aPosicionou[lSC7]
					LxA103SC7(1)
				EndIf
				//³Atualiza Rateios por Centro de Custo³
				If !Empty(aRateio) .AND. aScan(aRateio, { |x| x[1] == &(cPrefI+"_ITEM") } ) > 0
					NfRateioCC(aRateio,1,aCusto,nItem)
				EndIf
				//³ Grava os dados referentes ao CIAP SF9 ³
				LxA103SF9(1)
				//³EXECUTAR CHAMADA DE FUNCAO p/ integracao com sistema de Distribuicao - NAO REMOVER ³
				If GetMV("MV_FATDIST") == "S" // Apenas quando utilizado pelo modulo de Distribuicao
					DS100SD1I()
				EndIf
				//³Integracao TMS  ³
				If IntTMS() .And. ( (Type("aRatVei") == "A" .And. Len(aRatVei) > 0) .Or. (Type("aRatFro") == "A" .And. Len(aRatFro) > 0) )
					//³Verifica se o Item da NF foi rateado por Veiculo/Viagem ou por Frota    ³
				    If Type("aRatVei") == "A" .And. aScan(aRatVei,{|x| x[1] == SD1->D1_ITEM}) > 0
					    A103GrvSDG(aRatVei,"V")
					ElseIf Type("aRatFro") == "A" .AND. aScan(aRatFro,{|x| x[1] == SD1->D1_ITEM}) > 0
						A103GrvSDG(aRatFro,"F")
					EndIf
				EndIf
				//³ Integracao com o modulo de Projetos ³
				If IntePms()
					//³Atualiza os arquivos de Gerenciamento de Projetos - SIGAPMS - 1:Inclusao³
					PmsWriteNF(1,"SD1")
				EndIf
			EndIf //lRet (2)
		//³Atualizacoes relacionadas exclusivamente ao arquivo SD2/SF2³
	   ElseIf cAliasI == "SD2" .AND. lRet
			//³Atualizacao dos Itens de Pedido de Vendas (SC6)³
			If aPosicionou[lSC6]
				//³Atualizando Itens de PEDIDOS de venda (SC6)³
				RecLock("SC6",.F.)
				MaAvalSC6("SC6",5,,,,,,,,,"SD2",aCfgNF[SlRemito])
				//³Ponto de Entrada na atualizacao do SC6³
				cPe	:=	LocxPE(12)
				If !Empty(cPE)
					Execblock(cPE,.F.,.F.)
				EndIf
				MsUnlock()
			EndIf
			//³Atualizacao do Pedido de Vendas (SC5)³
			If aPosicionou[lSC5] .AND. SC5->C5_NOTA != SD2->D2_DOC
				MaAvalSC5("SC5",5,,,,,,,,SD2->D2_PEDIDO)
			EndIf
			//³Atualiza Rateios por Centro de Custo³
			If !Empty(aRateio) .AND. aScan(aRateio, { |x| x[1] == &(cPrefI+"_ITEM") } ) > 0
				NCRateioCC(aRateio,1,aCusto,nItem)
			EndIf
			//³Atualizacao dos Itens de Pedido de Vendas Liberados (SC9)³
			If aPosicionou[lSC9]
				//³Atualizando Itens de PEDIDOS de venda Liberados (SC9)³
				RecLock("SC9",.F.)
				MaAvalSC9("SC9",11,,,,,,,,aCfgNF[SlRemito])
				MsUnlock("SC9")
			EndIf
			//³Atualizacao do Arquivo de demandas (SB3)³
			If cTipDoc <> "B"
				AtuSB3Nf()
			EndIf
			//³ Integracao com o modulo de Projetos
			If IntePms()
				//³Atualiza os arquivos de gerenciamento de Projetos
				If Type("aHdrAFS") == "A" .and. Type("aRatAFS") == "A"
					SF4->(PmsWriteD2(1,"SD2",,@aHdrAFS, @aRatAFS))
				else
					SF4->(PmsWriteD2(1,"SD2"))
				EndIf
			Endif
			//³ Actualiza cantidad entregada en el pedido de compra por inclusion de remito de devolucion (SC7)
			If cPaisLoc == "ARG" .And. FunName() $ "MATA102DN|MATA466N"
				aAreaSD1 := SD1->(GetArea())
				dbSelectArea("SD1")
				SD1->(DbSetOrder(1)) //D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
				If SD1->(MsSeek(xFilial("SD1") + SD2->(D2_NFORI + D2_SERIORI + D2_CLIENTE + D2_LOJA + D2_COD + D2_ITEMORI)))
					dbSelectArea("SC7")
					aAreaSC7 := SC7->(GetArea())
					SC7->(DbSetOrder(1)) //C7_FILIAL+C7_NUM+C7_ITEM+C7_SEQUEN
					If SC7->(MsSeek(xFilial("SC7")+SD1->D1_PEDIDO+SD1->D1_ITEMPC))
						If (SC7->C7_QUANT-SC7->C7_QUJE) >= 0 .And. SD2->D2_QUANT > 0 .And. SD2->D2_QUANT <= SC7->C7_QUJE
							RecLock("SC7",.F.)
							Replace C7_QUJE With (SC7->C7_QUJE - SD2->D2_QUANT)
							MsUnlock()
						Endif
					EndIf
					RestArea(aAreaSC7)
				EndIf
				RestArea(aAreaSD1)
			EndIf
		EndIf
		If lRet //(3)//³Atualizacoes Gerais³
			If &(cAliasI+"->(FieldPos('"+PrefixoCpo(cAliasI)+"_REMITO'))<>0") .AND. !Empty(&(cPrefI+"_REMITO"))
				//³Atualizacao de Remitos (SD1/SD2) ³
				If !aCfgNF[SlRemito].AND. (aPosicionou[lSD1] .OR. aPosicionou[lSD2])
					AtuREMNF(aPosicionou)
				EndIf
			EndIf
			//³Amarracao de CLIENTEXPRODUTO / FORNECEDORXPRODUTO / FORNECEDORXGRUPO³
			If !Amarracao( &(cPrefI+cPreco), &(cPrefI+"_EMISSAO"), (cAliasCF=="SA1" .AND. aPergs[SlAmarraca]), (cAliasCF=="SA2" .AND. aPergs[SlAmarraca]), (cAliasCF=="SA2" .AND. aPergs[SlAmarraca]) )
				lRet := .F.
			EndIf
			//³Atualizacao de Cargas e Transportes³
			If aPosicionou[lDAK] .AND. aPosicionou[lSC9] .AND. !Empty(SC9->C9_CARGA)
				OsAvalDAK("SC9",7,,,aCfgNF[SlRemito])
			EndIf
		EndIf //lRet (3)
	EndIf
	//³Atualizacoes que podem ocorrer tanto na gravacao dos itens quanto na gravacao de cabecalho³
	If lRet //(4)
		//³Cadastro de Produtos³
		If aPosicionou[lSB1]
			AtuSB1Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)
		EndIf
		//³Arquivo de Cliente ou Fornec. ³
		If cAliasCF == "SA1"
			AtuSA1Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)		//CLIENTE
		Else
			AtuSA2Nf(cAliasC,cAliasI,cTipDoc,cTipAtu)		//FORN.
		EndIf
	EndIf //(4)
EndIf //lRet (1)
RestArea(aArea)
Return lRet
/*
±±³Fun‡…o    ³AtuSB3Nf    ³ Autor ³ Leandro C. G.         ³ Data ³07/11/2001³±±
±±³Descri‡…o ³Atualiza arquivo de Demandas a partir da NF 	   	 		    ³±±
±±³ Uso      ³ ATUARQNF  												    ³±±
Obs.: Considera que o arquivo de NF esta posicionado no registro correto
*/
Function AtuSB3Nf()
//³Atualizando Arquivo de demandas (SB3)³
SB3->(DBSetOrder(1))
RecLock("SB3", !SB3->(MSSeek(xFilial("SB3")+SD2->D2_COD, .F.)))
SB3->B3_FILIAL := xFilial("SB3")
SB3->B3_COD    := SD2->D2_COD
SB3->B3_MES    := SD2->D2_EMISSAO
&( "SB3->B3_Q" + StrZero(Month(SD2->D2_EMISSAO), 2) + " " + IIf(SD2->D2_TES<="500","-","+") + "= SD2->D2_QUANT" )
MsUnlock("SB3")
Return(.T.)

/*
±±³Fun‡…o    ³AtuRemNf    ³ ±±
±±³Descri‡…o ³Atualiza arquivo de Remito de Venda ou compra a partir da NF  ³±±
±±³ Uso      ³ ATUARQNF  													³±±
*/
Function AtuREMNf(aPosicionou)
Local nQuant		:= 0
Local aArea			:=	GetArea()
Local aAreaI
Local aCusto		:=	{}
If aPosicionou[lSD2]
	aAreaI	:=	SD2->(GetArea())
	nQuant	:=	SD2->D2_QUANT
	SD2->(MsGoTo(aPosicionou[nRecSD2]))

	//³Atualizando SD2³
	RecLock("SD2", .F.)
	SD2->D2_QTDEFAT += nQuant
	SD2->D2_QTDAFAT := SD2->D2_QUANT - SD2->D2_QTDEFAT
	MsUnLock()

	RestArea(aAreaI)
ElseIf aPosicionou[lSD1]
	aCusto	:=	{SD1->D1_CUSTO/SD1->D1_QUANT,SD1->D1_CUSTO2/SD1->D1_QUANT,SD1->D1_CUSTO3/SD1->D1_QUANT,SD1->D1_CUSTO4/SD1->D1_QUANT,SD1->D1_CUSTO5/SD1->D1_QUANT}
	aAreaI	:=	SD1->(GetArea())
	nQuant	:=	SD1->D1_QUANT
	SD1->(MsGoTo(aPosicionou[nRecSD1]))

	//³Atualizando SD1 - Remito³
	NfAtuSD1(nQuant,1,aCusto)
	RestArea(aAreaI)
Endif
RestArea(aArea)
Return .T.

/*
±±³Fun‡…o    ³VarreItNf
±±³Descri‡…o ³Varre os itens da NF que esta sendo gravada e efetua		    ³±±
±±³			 ³todas as atualizacoes necessarias						       	³±±
param.
aCfgNf	-	Array com todas as config. da NF
			[SnTipo]		- codigo do tipo de NF
			[ScEspecie]		- codigo da especie da NF
    		[ScCliFor]		- indica se e cliente("C") ou fornec.("F")
			[SlFormProp]	- indica se e formulario proprio(0) ou nao(1)
			[SAliasHead]	- arquivo de cabecalho da nota
			[SAliasCols]	- arquivo de itens da nota
			[ScOpEstoq]		- indica se soma ou subtrai o estoque
			[ScAliasFin]	- arquivo financeiro a atualizar
			[ScOpFin]		- indica sinal para movimentacao financeira
			[ScTipoDoc]		- tipo de documento {N- ;C- ;D-	;B)
			[SaAtualiza]	- array com as permissoes para efetuar movimentacoes
			[SaLancPadC]	- Array com o numero dos lanç. padrao referentes a Cabecalho
			[SaLancPadI]	- Array com o numero dos lanç. padrao referentes a Itens
       	[SaBotoes]		- Array com os botoes da tela, quando for tela
			[SaTeclas]		- Array com as funcoes chamadas por tecla te atalho e todas as respectivas teclas
			[SaPergs]		- Array com as perguntas efetuadas na entrada da NF (aPergs)
			[SaPE]			- Array com todos os pontos de entrada em suas devidas posicoes, de acordo com o tipo de Nota
			[SlRemito]		- Define se se trata de um remito
aRecnoI 	-	Array que guarda o numero dos registros de itens gravados
nRecnoC 	-	Guarda o numero do registro de cabecalho gravado
aRatCC		- array com os itens de rateios por centro de custo de todos os itens da NF
			[x][1] - Numero do Item da NF (D1/D2_ITEM)
			[x][2] - Itens de Rateios por centro de custo para este item (dados que serao gravados no ar
aGeraPv		- array indicando se cada item deve ou nao gerar pedido de venda quando for uma devolucao de venda
*/
Function VarreItNf(aCfgNf,aRecnoI,nRecnoC,aRatCC,aGeraPv,aRecsSF1, aDigEnd)
Local aArea			:= GetArea()
Local aAreaSA2      := SA2->(GetArea())
Local lRemInt       := SuperGetMv("MV_REMINT",.F.,.F.)
Local lEIC          := Iif(SuperGetMv("MV_EASY",.F.,"N")=="S",.T.,.F.)
Local nI//,nX								//Flag's para loop's
Local nCt           := 0
Local aCusto 		:= {}				//Array com os custos do item
//Local nPos			:= 0				//Posição qualquer de um array
Local lRet			:= .T.				//Indica inconsistencia da Rotina
Local cAliasI		:= aCfgNf[SAliasCols]
Local aAreaSD2  	:= {}
Local aPars	   		:= {}				//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lVer116  		:= .T.
Local lDISTMOV 		:= SuperGetMV("MV_DISTMOV",.F.,.F.)
Local aPosicionou 	:= array(nMaxPos)	//Array com a indicacao dos arquivos que estao posicionados posicionados
/*	[lSF4]-Indica se foi posicionado SF4 (TES)
	[lSB1]-Indica se foi posicionado SB1 (PRODUTO)
	[lSAx]-Indica se foi posicionado SA1 OU SA2 (CLIENTE OU FORN.)
	[lSC5]-Indica se foi posicionado SC5 (PEDIDOS DE VENDA)
	[lSC6]-Indica se foi posicionado SC6 (ITENS DE PEDIDOS DE VENDA)
	[lSC9]-Indica se foi posicionado SC9 (PEDIDOS DE VENDA LIBERADOS)
	[lSC7]-Indica se foi posicionado SC7 (PEDIDOS DE COMPRA)
*/
Local nRecno		:= 0
//Local lPrNFBen 		:= SuperGetMV("MV_PRNFBEN",.F.,.F.)
Local cFilSD2		:= xFilial("SD2")
Local nTotRecnoI := Len(aRecnoI)
Local  aAreaAt:= {}
//Local nCantFA := 0
//Local nTotlFA := 0
Local lActQta := FindFunction("LxMxPFact") .And. SD2->(ColumnPos("D2_DESGR1")) > 0  .And. SD2->(ColumnPos("D2_DESGR2")) > 0

//³Consistindo param
Aadd(aPars, {"aCfgNf"	, aCfgNf	, SpEmpty				} )
Aadd(aPars, {"aRecnoI"	, aRecnoI	, SpEmpty				} )
Aadd(aPars, {"nRecnoC"	, nRecnoC	, SpEmpty				} )
lRet := LocxParam("VARREITNF",aPars)
If lRet //(1)
	//³Valores Padrao³
	cPref := aCfgNf[SAliasCols] + "->" + PrefixoCpo(aCfgNf[SAliasCols])
	Asize(aGeraPv, Len(aRecnoI))
	Aeval(aGeraPv, {|x,y| IIf(Empty(x),aGeraPv[y]:=.F.,)} )
	//³Varrendo todos os itens
	nI := 0
	For nI := 1 to nTotRecnoI
		nRecno := SF1->(RecNo())
 		If nCt==0
			If aCfgNf[SAliasHead] == "SF1" .AND. aCfgNf[SnTipo] == 13
				A119Grava(.F.,nRecnoC,aRecsSF1,,aAmarrAFN)
				nCt++
			EndIf
			If aCfgNf[SAliasHead] == "SF1" .AND. aCfgNf[SnTipo] == 14
				A116Grava(.F.,nRecnoC,aRecsSF1,,aAmarrAFN)
				nCt++
			EndIf
		SF1->(MsGoTo(nRecno))
		EndIf
		//³Verifica validade do numero do registro atual e posiciona o arquivo de itens
		If aRecnoI[nI,1] == NIL .OR. aRecnoI[nI,1] <= 0
			Loop
		Else
			DBSelectArea(aCfgNf[SAliasCols])
			MSGoto(aRecnoI[nI,1])
		EndIf
		If cAliasI == "SD1"
			//³ Tratamento para Remitos Internos
			If lRemInt
			  	If (SD1->D1_TIPO_NF $ '5' .AND. SD1->D1_TIPODOC $ '10') .OR. ;
				  	(!Empty(SD1->D1_REMITO) .And. !lEIC) .OR. SD1->D1_TIPO_NF $ '6789AB'
					Loop
				EndIf
			EndIf
		EndIf
		//³Posicionando todos os arquivos que devem ser utilizados na atualizacao de processos a partir ³
		//³de um item da NF. Nao devem ser efetuados "Seek's" em nenhum arquivo a nao ser 	    ³
		//³dentro desta rotina ou na rotina PosicionaC, nao sendo estritamente necessario
		aPosicionou := PosicionaI(aCfgNf[SAliasCols],aCfgNf[ScCliFor])
		If aPosicionou == NIL
			lRet := .F.
		EndIf
		If lRet //(2)
			//³PE para alterar qtde na segunda unidade de medida³
			cPe	:=	LocxPE(13)
			If !Empty(cPE) .AND. aCfgNf[SAliasCols] == 'SD2'
				nQtd2UM := Execblock(cPE,.F.,.F.,SC9->(Recno()))
				If cAliasI == "SD2" .AND. !Empty(nQtd2UM) .AND. nQtd2UM > 0
					RecLock("SD2",.F.)
					SD2->D2_QTSEGUM := nQtd2UM
					MsUnlock()
				EndIf
			EndIf
			//³Grava o custo do Item da NF e devolve os valores gravados em todas as moedas³
			aCusto := NfGravaCusto(aCfgNf[SAliasCols],aCfgNf[ScTipoDoc],aRecnoi[nI,2])
	  		If Empty(&(aCfgNf[SAliasCols]+"->"+PrefixoCpo(aCfgNf[SAliasCols])+"_REMITO"))
				//³Efetua todas as atualizacoes referentes ao Estoque³
				If aPosicionou[lSF4] .AND. SF4->F4_ESTOQUE == "S" .AND. aCfgNf[SaAtualiza][SlAtuEstq]
					If !EstqNota(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScOpEstoq],aCfgNf[ScTipoDoc],aCfgNf[ScCliFor],nRecnoC,aCusto,aPosicionou,aGeraPv[nI],aRecsSF1)
						lRet := .F.
					EndIf
				ElseIf aPosicionou[lSF4] .AND. SF4->F4_ESTOQUE == "N"
					If SF4->F4_PODER3 $ "R|D"
						//³ Atualiza SB6 - Poder de Terceiros
						MaAtuSB6(cAliasI,If(cAliasI=="SD1",1,3))
					Else
						aAreaSD2 := SD2->(GetArea())
						If cPaisLoc $ "ARG|CHI|URU|PAR"
    						 aAreaAt:=GetArea()
    						DbSelectArea("SD2")
    						SD2->(DbSetOrder(3))
						EndIf
						If aCfgNF[SnTipo]== 21 .And. cPaisLoc $ "MEX" .And. lActQta
							xItNFMex(cFilSD2)
						Else
							If SD2->( MsSeek(cFilSD2+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMORI) )
								RecLock("SD2",.F.)
								Replace SD2->D2_QTDEDEV With SD2->D2_QTDEDEV + SD1->D1_QUANT
								Replace SD2->D2_VALDEV  With SD2->D2_VALDEV  + SD1->D1_TOTAL
								MsUnlock("SD2")
							EndIf
						EndIF

						If cPaisLoc $ "ARG|CHI|URU|PAR"
							RestArea(aAreaAt)
						EndIf
						RestArea(aAreaSD2)
					EndIf
				EndIf
			Endif
			If lRet //(3)
				//³Efetua atualizacao de todos os arquivos necessarios, na gravacao de um item de uma NF
				If !AtuArqNf(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCfgNf[ScTipoDoc],"I",aPosicionou,nI,aCusto,aRatCC,aCfgNf[SaPergs],aCfgNf[SaAtualiza])
					lRet := .F.
				EndIf
				//³Ponto de Entrada apos as atualizacoes de cada item³
				DBSelectArea(aCfgNf[SAliasCols])
				cPe	:=	LocxPE(14)
				If lRet .AND. !Empty(cPE)
					ExecBlock(cPE,.F.,.F.,{nI})
				Endif
				//³ Disparar Rdmakes para Tratamento especifico. ³
				cPe	:=	LocxPE(15)
				If !Empty(cPE)
					ExecBlock(cPE,.F.,.F., { SD1->D1_REMITO, SD1->D1_ITEMREM, SD1->D1_DOC, SD1->D1_SERIE, nI })
				EndIf
			EndIf //lRet (3)
		EndIf //lRet (2)
		//Diglot
		IF lVer116 .AND. lDistMov .and. Localiza(SD1->D1_COD) .And. SF4->F4_ESTOQUE == 'S' .AND. Empty(SD1->D1_REMITO)
				aADD(aDigEnd,{;
								SD1->D1_ITEM,;
								SD1->D1_COD,;
								SD1->D1_LOCAL,;
								SD1->D1_LOTECTL,;
								SD1->D1_NUMLOTE,;
								SD1->D1_DTVALID,;
								SD1->D1_QUANT,;
								SD1->D1_NUMSEQ,;
								SD1->D1_DOC,;
								SD1->D1_SERIE,;
								SD1->D1_FORNECE,;
								SD1->D1_LOJA,;
								.F.;
							 })
		EndIf
	Next nI
	//³Fim da varredura dos itens da NF ³
	//³Quando for uma Nota de despesas de Importacao monta um array com o numero dos registros de todas   ³
	//³as Notas Originais e cria os registros de amarracao da Notas Atuais com as de origem no arquivo SF8³
	If nCt == 0
		If aCfgNf[SAliasHead] == "SF1" .AND. aCfgNf[SnTipo] == 13
			A119Grava(.F.,nRecnoC,aRecsSF1,,aAmarrAFN)
		EndIf
	EndIf
	//³Quando for uma Nota de conhecimento de frete monta um array com o numero dos registros de todas    ³
	//³as Notas Originais e cria os registros de amarracao da Notas Atuais com as de origem no arquivo SF8³
	If nCt == 0
		If aCfgNf[SAliasHead] == "SF1" .AND. aCfgNf[SnTipo] == 14
			A116Grava(.F.,nRecnoC,aRecsSF1,,aAmarrAFN)
		EndIf
	EndIf
	//³Grava OP's da NF retorno Benef.³
	If lRet .And. Type("aOPBenef") == "A" .And. !Empty(aOPBenef)
		lRet := (MTIncluiPR(aOPBenef))
	EndIf
EndIf //lRet (1)
RestArea(aAreaSA2)
RestArea(aArea)
Return(lRet)
/*
±±³Fun‡…o    ³MontaCfgNf  ³ Autor ³ Leandro C. G.         ³ Data ³09/11/2001³±±
±±³Descri‡…o ³Monta array com todas as confg da NF de acordo c/Tipo param.  ³±±
nTipo    - tipo de NF
aPergs	- Array com o conteudo das perguntas feitas na tela de NF
		[SlAmarraca 1]	-   Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
		[SlGerCtbil 2]	-   lanç. On-Line?
		[SlVerCtbil 3]	- 	Mostra Lanç.Contab ?
		[SlAglutina 4]	-	Aglut Lançamentos  ?
		[SlQbraAliq 5]	-	Quebra do Rodapé   ? Por Alíquota    /  Por Imposto
		[SlCtbEmiss 6]	-	Contabiliza por    ? Emissao         /  Data Base
*/
Function MontaCfgNf(nTipo,aPergs,lTela)
//Local nI,nX								//Flag's para loop's
Local lRet		:= .T.					//Indica consistencia da funcao
//Local cTipDoc	:= ""					//Indica se a Nota e de Devolucao ou Complemento quando for Debito ou Credito
Local aCfg 		:= {}   				//Array com todas as config. da NF
/*
	[SnTipo]		- codigo do tipo de NF
	[ScCliFor]		- indica se e cliente("C") ou fornec.("F")
	[SlFormProp]	- indica se e formulario proprio(0) ou nao(1)
	[SAliasHead]	- arquivo de cabecalho da nota
	[SAliasCols]	- arquivo de itens da nota
	[ScOpEstoq]		- indica se soma ou subtrai o estoque
	[ScAliasFin]	- arquivo financeiro a atualizar
	[ScOpFin]		- indica sinal para movimentacao financeira
	[ScTipoDoc]		- tipo de documento {N- ;C- ;D-	;B)
	[SaAtualiza]	- array com as permissoes para efetuar movimentacoes
	[SaLancPadC]	- Array com o numero dos lanç. padrao referentes a Cabecalho
	[SaLancPadI]	- Array com o numero dos lanç. padrao referentes a Itens
	[SaBotoes]		- Array com os botoes da tela, quando for tela
	[SaTeclas]		- Array com as funcoes chamadas por tecla te atalho e todas as respectivas teclas
	[SaPergs]		- Array com as perguntas efetuadas na entrada da NF (aPergs)
	[SaPE]			- Array com todos os pontos de entrada em suas devidas posicoes, de acordo com o tipo de Nota
	[SlRemito]		- Define se se trata de um remito
	[SlPedido]  	- Define se o tipo de nota tem amarração com com pedido de compras/vendas

*/
Local aLpC		:= {}					//Array com o numero dos lanç. padrao referentes a Cabecalho
Local aLpI		:= {}					//Array com o numero dos lanç. padrao referentes a Itens
Local aPE       := Array(SnMaxPE,2)		//Array com os pontos de entrada de acordo com o tipo da Nota
Local aPars	    := {}					//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local aBotoes   := AClone(CarregaBotoes(nTipo))
Local aTeclas   := AClone(CarregaTeclas(nTipo))
Local aAtualiza := AClone(CarregaAtualiza(nTipo,lTela))
Local aPcoLanc  := aClone(PcoCarregaLancto(nTipo))
Local bF12	 	:=	{|| Nil }
Local aCposGD   :=Nil
Local cFunName	:= IIf(Type("cFunName")=="U" .Or. Empty(cFunName) .Or. cFunName==NIL,Upper(Alltrim(ProcName())),cFunName)//IIf(Type("cFunName")=="U",Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem  IIf(Type(cFunName)==nil,Upper(Alltrim(ProcName())),cFunName)	//Funcao Origem
Local cTitView as character
LocaL bF12Mex	:= {|| Nil }

If Type("lDocSp") == "U"
	Private lDocSp := .F.
EndIf
If Type("l103Class")!= "L"
	Private l103Class	:=	.F.
EndIf
If Type('lAutoFact') == "U"
	Private lAutoFact := .F.
EndIf
If Type('aAutofac') == "U"
	Private aAutofac:={0}
EndIf
If Type("lIntegracao")!= "L"
	lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)
Endif
//³Consistindo param.³
Aadd(aPars, {"nTipo", nTipo	, SpValor,1	,65	})
lRet := LocxParam("MONTACFGNF",aPars)

If lRet //(1)
	//³Carregando lanç. padrao de acordo com o tipo da NF ³
	aAux := CarregaLanc(nTipo)
	aLpC := aAux[1]
	aLpI := aAux[2]
	//³Carregando todos os pontos de entrada de acordo com o tipo de Nota³
	aPE := MontaPE(nTipo)
	If cPaisLoc == "MEX" .And. (nTipo==1 .Or. nTipo==11 .Or. nTipo==19 .Or. nTipo==21)
		bF12Mex := {|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(IIf(MV_PAR01==1,1,IIf(MV_PAR01==2,11,IIf(MV_PAR01==3,19,21))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
	EndIf
	Do Case
		Case nTipo==1
			//mata467
			bF12	:=	{|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			If cPaisLoc=='MEX'
				bF12 := bF12Mex
	 			aCfg := {1,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew(MVNOTAFIS),"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0112+STR0142,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"01/11/21", NIL, aPcoLanc} //GSA040118
	 		Else
		 		aCfg := {1,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew(MVNOTAFIS),"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0112+STR0142,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"01/11", NIL, aPcoLanc}
	 		EndIf
		Case nTipo==2
			//mata465
			aCfg := {2,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew("NDC")	 	,"+","C",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0124,STR0124,.F.,bF12,aCposGD,{.F.,.F.},"02", NIL, aPcoLanc}
		Case nTipo==3
			//mata465
			aCfg := {3,"SA1",.F.,"SF2","SD2","-","SE1",GetSESNew("NCE")	 	,"+","C",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0113+STR0115,STR0113+STR0115,.F.,bF12,aCposGD,{.F.,.F.},"03", NIL, aPcoLanc}
		Case nTipo==4
			//mata465
			aCfg := {4,"SA1",.T.,"SF1","SD1","+","SE1",GetSESNew("NCC")	 	,"-","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0113,STR0113,.F.,bF12,aCposGD,{.F.,.F.},"04", NIL, aPcoLanc}
		Case nTipo==5
			//mata465
			aCfg := {5,"SA1",.F.,"SF1","SD1","+","SE1",GetSESNew("NDE")	 	,"-","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0117,STR0117,.F.,bF12,aCposGD,{.F.,.F.},"05", NIL, aPcoLanc}
		Case nTipo==6
			//mata466
			aCfg := {6,"SA2",.T.,"SF2","SD2","-","SE2",GetSESNew("NDI")	 	,"-","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0116,STR0116,.F.,bF12,aCposGD,{.F.,.F.},"06", NIL, aPcoLanc}
		Case nTipo==7
			//mata466
			aCfg := {7,"SA2",.F.,"SF2","SD2","-","SE2",GetSESNew("NCP")	 	,"-","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0113,STR0113,.F.,bF12,aCposGD,{.F.,.F.},"07", NIL, aPcoLanc}
		Case nTipo==8
			//mata466
			aCfg := {8,"SA2",.T.,"SF1","SD1","+","SE2",GetSESNew("NCI")	 	,"+","C",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0113+STR0114,STR0113+STR0114,.F.,bF12,aCposGD,{.F.,.F.},"08", NIL, aPcoLanc}
		Case nTipo==9
			//mata466
			aCfg := {9,"SA2",.F.,"SF1","SD1","+","SE2",GetSESNew("NDP")  	,"+","C",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0124,STR0124,.F.,bF12,aCposGD,{.F.,.F.},"09", NIL, aPcoLanc}
		Case nTipo==10
			//mata101 / mata103cf
			If !cFunName$"MATA103CF" .and. cPaisLoc == "PER"
				bF12	:=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,Iif(mv_par01==4,14,20)))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			Else
				bF12	:=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif((MV_PAR01 == 1) .or. (cPaisLoc == "PAR" .AND. MV_PAR01 ==5),10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,14))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF),IIF ((cPaisLoc == "PAR" .AND. FindFunction("autoFactPar")), aAutofac[1]:=autoFactPar(MV_PAR01,@lAutoFact),"")  }
			EndIf
			If lIntegracao .AND. l103Class
				aCposGD	:=	{"D1_TES","D1_CF","D1_CONTA","D1_CC","D1_ITEMCTA","D1_CLVL"}
			Endif
			//(05/04/2018): Edit title if it call for View Invoice from Fixed asset
			If	(cPaisloc=="RUS") .AND. IsInCallStack("ATFA012PIN")
				cTitView := STR0141
			Else
				cTitView	:= IIF(!cFunName$"MATA103CF",STR0141+STR0142,STR0302)
			EndIf
			aCfg 	:= {10,"SA2",.F.,"SF1","SD1","+","SE2",MVNOTAFIS,"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,IIF(!cFunName$"MATA103CF",STR0141+STR0142,STR0302),IIF(!cFunName$"MATA103CF",STR0141,STR0302),.T.,bF12,aCposGD,{.F.,.F.},"10/12/13/14", NIL, aPcoLanc}
			IIf(cPaisLoc == "COL" .AND. lDocSp, aCfg[20] :=  aCfg[20] + " - " + STR0448,) //"Documento Soporte"
		//Beneficiamento
		Case nTipo == 11
			//Mata467
			bF12	:=	{|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			If cPaisLoc=='MEX'
				bF12 := bF12Mex
				aCfg := {11,"SA2",.T.,"SF2","SD2"	,"-",""	,MVNOTAFIS				,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)		,aClone(aPE),.F.,STR0112+STR0111,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"01/11/21", NIL, aPcoLanc}
			ELSE
				aCfg := {11,"SA2",.T.,"SF2","SD2"	,"-",""	,MVNOTAFIS				,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)		,aClone(aPE),.F.,STR0112+STR0111,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"01/11", NIL, aPcoLanc}
			ENDIF
		Case nTipo == 12
			//Mata101
			bF12	:=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif((MV_PAR01 == 1) .or. (cPaisLoc == "PAR" .AND. MV_PAR01 ==5),10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,14))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF),IIF ((cPaisLoc == "PAR" .AND. FindFunction("autoFactPar")), aAutofac[1]:=autoFactPar(MV_PAR01,@lAutoFact),"") }
			aCfg 	:= {12,"SA1",.F.,"SF1","SD1"	,"+",""	,MVNOTAFIS				,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)		,aClone(aPE),.F.,STR0141+STR0111,STR0141,.T.,bF12,aCposGD,{.F.,.F.},"10/12/13/14", NIL, aPcoLanc}
		Case nTipo	==	13
			//MATA119
			bF12	:=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif((MV_PAR01 == 1) .or. (cPaisLoc == "PAR" .AND. MV_PAR01 ==5),10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,14))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF),IIF ((cPaisLoc == "PAR" .AND. FindFunction("autoFactPar")), aAutofac[1]:=autoFactPar(MV_PAR01,@lAutoFact),"") }
			aCposGD	:=	{"D1_VUNIT","D1_TOTAL","D1_CONTA","D1_CC","D1_CF","D1_TES","D1_ITEMCTA","D1_CLVL","D1_CONCEPT"}
			aCfg 	:= {13,"SA2",.F.,"SF1","SD1","+","SE2",MVNOTAFIS				,"+","C",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0141+STR0140,STR0141,.T.,bF12,aCposGD,{.F.,.T.},"10/12/13/14", NIL, aPcoLanc}
		Case nTipo	==	14
			//MATA116
			bF12	:=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif((MV_PAR01 == 1) .or. (cPaisLoc == "PAR" .AND. MV_PAR01 ==5),10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,14))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF),IIF ((cPaisLoc == "PAR" .AND. FindFunction("autoFactPar")), aAutofac[1]:=autoFactPar(MV_PAR01,@lAutoFact),"") }
			aCposGD	:=	{"D1_VUNIT","D1_TOTAL","D1_CONTA","D1_CC","D1_CF","D1_TES","D1_ITEMCTA","D1_CLVL"}
			aCfg 	:= {14,"SA2",.F.,"SF1","SD1","+","SE2",MVNOTAFIS				,"+","C",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0141+STR0164,STR0141,.T.,bF12,aCposGD,{.T.,.F.},"10/12/13/14", NIL, aPcoLanc}
		Case nTipo == 15
			//mata463
			aCfg 	:= {15,"SA2",.F.,"SF1","SD1","+","SE2",'REC'		,"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,STR0225,STR0225,.T.,,aCposGD,{.F.,.F.},"15", NIL, aPcoLanc}
		Case nTipo == 17 //Nota de Venta - Especifico EQUADOR
			bF12	:=	{|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg	:= {nTipo,"SA1",.T.,"SF2","SD2","-","SE1","NV ","+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0271,STR0271,.F.,bF12,aCposGD,{.F.,.F.},"17", NIL, aPcoLanc} // "Nota de venta"
		Case nTipo == 18 //RCTI - Especifico Australia
			bF12	:=	{|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg	:=  {nTipo,"SA1",.F.,"SF2","SD2","-","SE1","RTI","+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0322,STR0322,.F.,bF12,aCposGD,{.F.,.F.},"18", NIL, aPcoLanc} // "RCTI"
		Case nTipo == 19 .and. cPaisLoc $ "|MEX|PER|" //Adiantamento - Especifico Mexico
			//mata467
			bF12	:=	IIf(cPaisLoc == "MEX",bF12Mex,{|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,1,11),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) })
 			aCfg := {nTipo,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew(MVNOTAFIS),"+","A",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0112+" "+STR0264,STR0112,.F.,bF12,aCposGD,{.F.,.F.},"19", NIL, aPcoLanc}	//Adiantamento
	     //Remitos (facturacion)
	   	Case nTipo == 20 .and. cPaisLoc $ "|MEX|PER|" //Adiantamento - para Mexico y Peru
			//mata101n
			if cPaisLoc == "MEX"
				bF12 :=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,Iif(mv_par01==4,14,19)))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
				aCfg := {nTipo,"SA2",.F.,"SF1","SD1","-","SE2",GetSESNew(MVNOTAFIS),"+","A",aAtualiza,aLpC,aLpI,aBotoes,aTeclas,AClone(aPergs),aClone(aPE),.F.,STR0141+" - "+STR0264,STR0141,.F.,bF12,aCposGD,{.F.,.F.},"20", NIL, aPcoLanc}	//Adiantamento
			else
				bF12 :=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,10,IIf(MV_PAR01 == 2,12,Iif(mv_par01==3,13,Iif(mv_par01==4,14,19)))),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
 				aCfg := {nTipo,"SA2",.F.,"SF1","SD1","-","SE2",GetSESNew(MVNOTAFIS),"+","A",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,IIF(!cFunName$"MATA103CF",STR0141+" "+STR0264,STR0302),IIF(!cFunName$"MATA103CF",STR0141,STR0302),.F.,bF12,aCposGD,{.F.,.F.},"20", NIL, aPcoLanc}	//Adiantamento
			endif
		Case nTipo == 21 .and. cPaisLoc == "MEX" //TRASLADOS
			//mata467
			bF12 :=	bF12Mex
			aCfg := {nTipo,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew(MVNOTAFIS),"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE)	,.F.,STR0112+" ("+ STR0385 +")",STR0112+" ("+ STR0385 +")",.F.,bF12,aCposGD,{.F.,.F.},"01/11/21", NIL, aPcoLanc} //"Factura de salida "//Traslado
		Case cPaisLoc == "COL" .AND. (nTipo == 22 .OR. nTipo == 23) .AND. FINDFUNCTION( 'lxEstrcCol' ) //Nota Ajuste NCP -NDP 
			//mata466
			aCfg :=  lxEstrcCol(nTipo,aAtualiza, aLpC,aLpI,aBotoes,aTeclas,aPergs, aPE,bF12,aCposGD,aPcoLanc)
		Case nTipo == 50
			//Mata462
			bF12	:=	{|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,50,52),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			If cPaisLoc == "EUA"
				aCfg := {50,"SA1",.T.,"SF2","SD2","-","SE1"	,GetSESNew('RFN')		,"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0142,DESCREM,.F.,bF12,aCposGD,{.F.,.F.},"50", NIL, aPcoLanc}
			Else
				aCfg := {50,"SA1",.T.,"SF2","SD2","-",""	,GetSESNew('RFN')		,"","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0142,DESCREM,.F.,IIf(cPaisLoc <> "ARG", bF12, ""),aCposGD,{.F.,.F.},"50", NIL, aPcoLanc}
			EndIf
		Case nTipo == 51
			//Mata462D Proprio
			bF12	:=	{|| Pergunte("MT462D",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,51,53),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg := {51,"SA1",.T.,"SF1","SD1","+",""	,GetSESNew("RFD")		,"","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0105,DESCREM+STR0105,.F.,bF12,aCposGD,{.F.,.F.},"51/53", NIL, aPcoLanc}
		Case nTipo == 52
			//Mata462
			bF12	:=	{|| Pergunte("MT467N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,50,52),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
 			aCfg := {52,"SA2",.T.,"SF2","SD2","-",""	,GetSESNew('RFB')		,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0111,DESCREM,.F.,IIf(cPaisLoc <> "ARG", bF12, ""),aCposGD,{.F.,.F.},"52", NIL, aPcoLanc}
		Case nTipo == 53
			//Mata462 Doc nao proprio
			bF12	:=	{|| Pergunte("MT462D",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,51,53),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg := {53,"SA1",.F.,"SF1","SD1","+",""	,GetSESNew("RFD")		,"","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0105+STR0115,DESCREM+STR0105,.F.,bF12,aCposGD,{.F.,.F.},"51/53", NIL, aPcoLanc}
		Case nTipo == 54 // Remito de transf. Saida
			//Mata462
 			aCfg := {54,"SA2",.T.,"SF2","SD2","-",""	,GetSESNew('RTS')		,"","B",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0166,DESCREM,.F.,,aCposGD,{.F.,.F.},"54", NIL, aPcoLanc}
 		Case nTipo==55	// Guia de Remessa - Portugal
     		bF12 := {|| Pergunte("MT462G",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,55,55),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg := {55,"SA1",.T.,"SF2","SD2","-","SE1",GetSESNew("GRN"),"+","N",aAtualiza,aLpC,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,IIF(!cFunName$"MATA462G",DESCREM+STR0309,STR0297),IIF(!cFunName$"MATA462G",DESCREM+STR0309,STR0297),.T.,bF12,aCposGD,{.F.,.F.},"55", NIL, aPcoLanc}
        //Remitos (Compras)
		Case nTipo == 60
			//Mata102
			bF12	:=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,60,62),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg 	:= {60,"SA2",.F.,"SF1","SD1","+",""	,GetSESNew('RCN')		,"","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0310,DESCREM,.T.,bF12,aCposGD,{.F.,.F.}	,"60/62", NIL, aPcoLanc}
		Case nTipo == 61
			//Mata102
			aCfg := {61,"SA2",.T.,"SF2","SD2","-",""	,GetSESNew('RCD')		,"","D",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0105,DESCREM+STR0105,.F.,bF12,aCposGD,{.F.,.F.},"61", NIL, aPcoLanc}
		Case nTipo == 62
			//Mata102
			bF12	:=	{|| Pergunte("MT101N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,60,62),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
			aCfg := {62,"SA1",.F.,"SF1","SD1","+",""	,GetSESNew("RCB")		,"","B",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0111,DESCREM,.F.,bF12,aCposGD,{.F.,.F.},"60/62", NIL, aPcoLanc}
		Case nTipo == 63
			//Retorno SIMBOLICO
			aCfg := {63,"SA1",.T.,"SF1","SD1","+",""	,GetSESNew("RET")		,"","B",aAtualiza	,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0145,DESCREM+STR0145,.F.,bF12,aCposGD,{.F.,.F.},"63", NIL, aPcoLanc}
		Case nTipo == 64
			aCposGD	:=	{"D1_LOCAL","D1_VUNIT","D1_TOTAL","D1_CONTA","D1_CC","D1_CF","D1_TES","D1_ITEMCTA","D1_CLVL"}
 			If GetNewPar("MV_ALTQTRT","N")=="S"
 				AAdd(aCposGD,"D1_QUANT")
 			EndIf
			aCfg 	:= {64,"SA2",.F.,"SF1","SD1","+",""	,GetSESNew('RTE'),"","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.T.,DESCREM+STR0167,DESCREM,.T.,,aCposGD,{.F.,.F.}	,"64", NIL, aPcoLanc}
		Case nTipo==65
			//mata103n e mata103cg
			If !cFunName$"MATA103CG"
	     		bF12	:=	{|| Pergunte("MT103N",.T.),aCfgNF := MontaCfgNf(Iif(MV_PAR01 == 1,65,65),aCfgNF[SaPergs],.T.),NFSetPrv(aCfgNF) }
	  		EndIf
			If lIntegracao .AND. l103Class
				aCposGD	:=	{"D1_TES","D1_CF","D1_CONTA","D1_CC","D1_ITEMCTA","D1_CLVL"}
			Endif
			aCfg 	:= {65,"SA2",.F.,"SF1","SD1","+","SE2",GetSESNew("GDN"),"+","N",aAtualiza,aLpC	,aLpI,aBotoes,aTeclas,AClone(aPergs)	,aClone(aPE),.F.,IIF(!cFunName$"MATA103CG",DESCREM+STR0309,STR0297),IIF(!cFunName$"MATA103CG",DESCREM+STR0309,STR0297),.T.,bF12,aCposGD,{.F.,.F.},"65", NIL, aPcoLanc}
	EndCase

	//Monta Array com os campos e os titulos que devem ser exibidos na mBrowse
	aCfg[SaCposBr] := MontCabBrow(aCfg)
EndIf //lRet (1)
IF cPaisLoc=="PAR" .AND. cFunName$"MATA101N"
		IIF(aAutofac[1]==5,lAutoFact:=.T.,lAutoFact:=.F.)
ENDIF
Return aCfg

/*
±±³Fun‡…o    ³ConsisteNf  ³ Autor ³ Leandro C. G.         ³ Data ³12/11/2001³±±
±±³Descri‡…o ³Efetua todas as consistencias necessarias para a gravacao de  ³±±
±±³			 ³uma NF                									             ³±±
±±³ Uso      ³ GRAVANFGERAL												          ³±±
aCabNotaOri - cabecalho da Nota
 [1] - campos do cabecalho
 [2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
 [3] - indica se o campo e totalizador (Default .F.)
aCpItensOri - campos dos itens (devem obedecer a sequencia do aHeader)
aCitensOri  - conteudo dos itens da NF (devem odebecer a sequencia do aCols) * o conteudo de cada campo pode ser uma formula
aCfgNf  	- array com todas as configuracoes da NF
 [SnTipo]		- codigo do tipo de NF
 [ScEspecie]	- codigo da especie da NF
 [ScCliFor]	- indica se e cliente("C") ou fornec.("F")
 [SlFormProp]	- indica se e formulario proprio(0) ou nao(1)
 [SAliasHead]	- arquivo de cabecalho da nota
 [SAliasCols]	- arquivo de itens da nota
 [ScOpEstoq]	- indica se soma ou subtrai o estoque
 [ScAliasFin]	- arquivo financeiro a atualizar
 [ScOpFin]		- indica sinal para movimentacao financeira
 [ScTipoDoc]	- tipo de documento {N- ;C- ;D-	;B)
 [SaAtualiza]	- array com as permissoes para efetuar movimentacoes
 [SaLancPadC]	- Array com o numero dos lanç. padrao referentes a Cabecalho
 [SaLancPadI]	- Array com o numero dos lanç. padrao referentes a Itens
*/

Function ConsisteNf(aCfgNf,aCabNotaOri,aCitensOri,aCpItensOri,lTela)
Local nI  					//Flag's para Loop's
Local cCpMoeda     := ""	//nome do campo de moeda no array de cabecalho
Local nPosMoeda    := 0		//pos. do campo de moeda no array de cabecalho
Local lRet		   := .T.	//Indica consistencia da funcao
Local aCitens      := aClone(aCitensOri)
Local aCpItens     := aClone(aCpItensOri)
Local aCabNota     := aClone(aCabNotaOri)
Private inclui    := .T.	//indica que e inclusao de dados (ExistChav())
Private n					//linha atual do acols
Private nMoedaCor := 1
Private aHeader   := IIf(Type("aHeader")=="U",{},aHeader)
Private aNfItem	  := IIf(Type("aNfItem")=="U",{},aNfItem)
Private aNfCab	  := IIf(Type("aNfCab")=="U",{},aNfCab)

Default lTela := .T.

//³Verificando moeda corrente³
cCpMoeda  := PrefixoCpo(aCfgNf[SAliasHead])+"_MOEDA"
nPosMoeda := Ascan(aCabNota[1], AllTrim(cCpMoeda))
nMoedaCor := IIf(nPosMoeda>0,aCabNota[2][nPosMoeda],1)
//³Acertando parametro aCabNota³
Asize(aCabNota, 3)
aCabNota[3] := IIf(Empty(aCabNota[3]) .OR. ValType(aCabNota[3]) != "A", {}, aCabNota[3])
Asize(aCabNota[3], Len(aCabNota[1]))
nI := 0
For nI := 1 to Len(aCabNota[1])
aCabNota[3][nI] := IIf(Empty(aCabNota[3][nI]), .F., aCabNota[3][nI])
Next nI

If SuperGetMV("MV_MULNATP") == .T. .And. FunName() == "MATA143"
	lContSEV:= .T.
EndIf

//³Consistencias especiais que dependendem dos dados de gravacao de cada nota.Dentro desta rotina estao as consistencias ³
//³do TudOk e LinOk
If !NfTudOk(aCfgNf[SAliasHead],aCfgNf[SAliasCols],aCfgNf[ScCliFor],aCabNotaOri,aCpItensOri,aCitensOri,,aCfgNf[ScTipoDoc],aCfgNf[SlFormProp],,lTela)
	lRet := .F.
EndIf

If ! lLocxAuto
	If lRet //lRet (1)
		//³Verificando moeda corrente³
		cCpMoeda  := PrefixoCpo(aCfgNf[SAliasHead])+"_MOEDA"
		nPosMoeda := Ascan(aCabNota[1], AllTrim(cCpMoeda))
		nMoedaCor := IIf(nPosMoeda>0,aCabNota[2][nPosMoeda],1)
		//³Executando a validacao do conteudo dos campos atraves do SX3³
		If !ConsisteSX3(aCabNota[1],aCabNota[2],aCabNota[3],aCpItens,aCitens)
			lRet := .F.
		EndIf
	EndIf //(1)
EndIf
Return(lRet)

/*
±±³Fun‡…o    ³CposObrig   ³ Autor ³ Leandro C. G.         ³ Data ³27/11/2001³±±
±±³Descri‡…o ³Verifica todos os campos obrigatorios de um arquivo de acordo ³±±
±±³			 ³como as configuracoes do SX3  					      		³±±
±±³ Uso      ³ GENERICA              										³±±
param.
cAlias	- Alias que se deseja saber o campos obrigatoios.
aCampos  - Campos que se deseja saber se sao obrigatorios.
*/
Function CposObrig(cAlias,aCampos)
Local aCpObrig		:= {}				//Array que guarda os campos obrigatorios
Local aArea			:= GetArea()
DEFAULT aCampos	:=	{}

DBSelectArea("SX3")
DBSetOrder(1)
If MSSeek(cAlias+"01", .F.)
	While !Eof() .AND. X3_ARQUIVO == cAlias
		If  X3OBRIGAT(X3_CAMPO) .AND. (Len(aCampos) == 0 .OR. Ascan(aCampos,{|x| Alltrim(x)==X3_CAMPO}) >0)
			AADD(aCpObrig, X3_CAMPO)
		EndIf
		DBSkip()
	End
EndIf
RestArea(aArea)
Return(aCpObrig)

/*
±±³Fun‡…o    ³CposObrigNf ³ Autor ³ Leandro C. G.         ³ Data ³27/11/2001³±±
±±³Descri‡…o ³Verifica todos os campos obrigatorios de um arquivo na 		³±±
±±³			 ³gravacao de uma NF		  									³±±
±±³ Uso      ³ CONSISTENF  												    ³±±
param.
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
aObrigSX3	- Campos que sao obrigatorios de acordo com SX3
cAlias		- Alias que se deseja saber o campos obrigatoios
*/
Function CposObrigNf(cAlias,cTipDoc,aObrigSX3,aCampos)
Local aCpObrig := {}			//Array que guarda os campos obrigatorios
Local lRet	   := .T.			//Indica consistencia da funcao
//Local cFunName := IIf(Type("cFunName")=="U",Upper(Alltrim(FunName())),cFunName)
Local nPos

//³Consistencias³
Default cTipDoc   := ""
Default aObrigSX3 := IIf(!Empty(cAlias), CposObrig(cAlias,aCampos), {})
If Empty(cAlias)
	lRet := .F.
EndIf
cPe	:=	LocxPE(30)
If !Empty(cPE)
	aObrigSX3	:=	ExecBlock(cPe,.F.,.F.,{aObrigSX3,aCfgNF[SnTipo]})
Endif

aCpObrig := aClone(aObrigSX3)
If lRet //lRet (1)
	Do Case
		//SF1 - Cabecalho de Entrada
		Case cAlias == "SF1"
			IIf(Ascan(aObrigSX3, "F1_FORNECE")<=0.AND.ExisteCampo("F1_FORNECE",.T.)[1]	, AADD(aCpObrig, "F1_FORNECE")	,)
			IIf(Ascan(aObrigSX3, "F1_LOJA")<=0	.AND.ExisteCampo("F1_LOJA",.T.)[1]			, AADD(aCpObrig, "F1_LOJA")	,)
			IIf(Ascan(aObrigSX3, "F1_DOC")<=0.AND.ExisteCampo("F1_DOC",.T.)[1]				, AADD(aCpObrig, "F1_DOC")		,)
			IIf(Ascan(aObrigSX3, "F1_EMISSAO")<=0.AND.ExisteCampo("F1_EMISSAO",.T.)[1]	, AADD(aCpObrig, "F1_EMISSAO") ,)
			IIf(Ascan(aObrigSX3, "F1_DTDIGIT")<=0.AND.ExisteCampo("F1_DTDIGIT",.T.)[1]	, AADD(aCpObrig, "F1_DTDIGIT") ,)
			IIf(Ascan(aObrigSX3, "F1_MOEDA")<=0.AND.ExisteCampo("F1_MOEDA",.T.)[1]			, AADD(aCpObrig, "F1_MOEDA"	)	,)
			IIf(Ascan(aObrigSX3, "F1_TXMOEDA")<=0.AND.ExisteCampo("F1_TXMOEDA",.T.)[1]	, AADD(aCpObrig, "F1_TXMOEDA") ,)
			IIf(Ascan(aObrigSX3, "F1_TIPO")<=0.AND.ExisteCampo("F1_TIPO",.T.)[1]			, AADD(aCpObrig, "F1_TIPO")	,)
			IIf(Ascan(aObrigSX3, "F1_FORMUL")<=0.AND.ExisteCampo("F1_FORMUL",.T.)[1]		, AADD(aCpObrig, "F1_FORMUL")  ,)
			IIf(Ascan(aObrigSX3, "F1_ESPECIE")<=0.AND.ExisteCampo("F1_ESPECIE",.T.)[1]	, AADD(aCpObrig, "F1_ESPECIE") ,)
			IIf(Ascan(aObrigSX3, "F1_TIPODOC")<=0.AND.ExisteCampo("F1_TIPODOC",.T.)[1]	, AADD(aCpObrig, "F1_TIPODOC")	,)
			If (nPos := Ascan(aCpObrig, "F1_COND"))> 0
				ADel(aCpObrig,nPos)
				aSize(aCpObrig,Len(aCpObrig)-1)
			Endif
		//SD1 - Itens de Entrada
		Case cAlias == "SD1"
			IIf(Ascan(aObrigSX3, "D1_COD")<=0.AND.ExisteCampo("D1_COD",.T.)[1]			, AADD(aCpObrig, "D1_COD")	  ,)
			IIf(Ascan(aObrigSX3, "D1_UM")<=0.AND.ExisteCampo("D1_UM",.T.)[1]				, AADD(aCpObrig, "D1_UM") ,)
			If !aCfgNF[SlRemito]
				IIf(Ascan(aObrigSX3, "D1_VUNIT")<=0.AND.ExisteCampo("D1_VUNIT",.T.)[1]		, AADD(aCpObrig, "D1_VUNIT"	),)
				IIf(Ascan(aObrigSX3, "D1_TOTAL")<=0.AND.ExisteCampo("D1_VUNIT",.T.)[1]		, AADD(aCpObrig, "D1_VUNIT"	),)
			Endif
			IIf(Ascan(aObrigSX3, "D1_TES")<=0.AND.ExisteCampo("D1_TES",.T.)[1]			, AADD(aCpObrig, "D1_TES")	,)
			IIf(Ascan(aObrigSX3, "D1_LOCAL")<=0.AND.ExisteCampo("D1_LOCAL",.T.)[1]		, AADD(aCpObrig, "D1_LOCAL"	),)
			IIf(Ascan(aObrigSX3, "D1_CF")<=0.AND.ExisteCampo("D1_CF",.T.)[1]			, AADD(aCpObrig, "D1_CF")	,)
		//SF2 - Cabecalho de Saida
		Case cAlias == "SF2"
			IIf(Ascan(aObrigSX3, "F2_TIPO")<=0.AND.ExisteCampo("F2_TIPO",.T.)[1]			, AADD(aCpObrig, "F2_TIPO")	,)
			IIf(Ascan(aObrigSX3, "F2_DOC")<=0.AND.ExisteCampo("F2_DOC",.T.)[1]		  	, AADD(aCpObrig, "F2_DOC") 	,)
			IIf(Ascan(aObrigSX3, "F2_CLIENTE")<=0.AND.ExisteCampo("F2_CLIENTE",.T.)[1]	, AADD(aCpObrig, "F2_CLIENTE")	,)
			IIf(Ascan(aObrigSX3, "F2_LOJA")<=0.AND.ExisteCampo("F2_LOJA",.T.)[1]			, AADD(aCpObrig, "F2_LOJA")	,)
			IIf(Ascan(aObrigSX3, "F2_COND")<=0.AND.ExisteCampo("F2_COND",.T.)[1]			, AADD(aCpObrig, "F2_COND")	,)
			IIf(Ascan(aObrigSX3, "F2_EMISSAO")<=0.AND.ExisteCampo("F2_EMISSAO",.T.)[1]	, AADD(aCpObrig, "F2_EMISSAO")	,)
			IIf(Ascan(aObrigSX3, "F2_ESPECIE")<=0.AND.ExisteCampo("F2_ESPECIE",.T.)[1]	, AADD(aCpObrig, "F2_ESPECIE")	,)
			IIf(Ascan(aObrigSX3, "F2_MOEDA")<=0.AND.ExisteCampo("F2_MOEDA",.T.)[1]	  	, AADD(aCpObrig, "F2_MOEDA") 	,)
			IIf(Ascan(aObrigSX3, "F2_TXMOEDA")<=0.AND.ExisteCampo("F2_TXMOEDA",.T.)[1]	, AADD(aCpObrig, "F2_TXMOEDA")	,)
			IIf(Ascan(aObrigSX3, "F2_TIPODOC")<=0.AND.ExisteCampo("F2_TIPODOC",.T.)[1]	, AADD(aCpObrig, "F2_TIPODOC")	,)
			If (nPos := Ascan(aCpObrig, "F2_COND"))> 0
				ADel(aCpObrig,nPos)
				aSize(aCpObrig,Len(aCpObrig)-1)
			Endif
		//SD2 - Itens de Saida
		Case cAlias == "SD2"
			If !aCfgNF[SlRemito]
				IIf(Ascan(aObrigSX3, "D2_PRCVEN")	<=0	.AND.ExisteCampo("D2_PRCVEN",.T.)[1]	, AADD(aCpObrig, "D2_PRCVEN")	,)
				IIf(Ascan(aObrigSX3, "D2_TOTAL") 	<=0	.AND.ExisteCampo("D2_TOTAL",.T.)[1]	, AADD(aCpObrig, "D2_TOTAL")	,)
			Endif
			IIf(Ascan(aObrigSX3, "D2_GERANF") 	<=0	.AND.ExisteCampo("D2_GERANF",.T.)[1]	, AADD(aCpObrig, "D2_GERANF")	,)
			IIf(Ascan(aObrigSX3, "D2_NUMSEQ")	<=0	.AND.ExisteCampo("D2_NUMSEQ",.T.)[1]	, AADD(aCpObrig, "D2_NUMSEQ")	,)
			IIf(Ascan(aObrigSX3, "D2_COD")		<=0	.AND.ExisteCampo("D2_COD",.T.)[1]		, AADD(aCpObrig, "D2_COD")		,)
			IIf(Ascan(aObrigSX3, "D2_UM")			<=0	.AND.ExisteCampo("D2_UM",.T.)[1]		, AADD(aCpObrig, "D2_UM")		,)
			IIf(Ascan(aObrigSX3, "D2_CF")			<=0	.AND.ExisteCampo("D2_CF",.T.)[1]		, AADD(aCpObrig, "D2_CF")		,)
			IIf(Ascan(aObrigSX3, "D2_TES")		<=0	.AND.ExisteCampo("D2_TES",.T.)[1]		, AADD(aCpObrig, "D2_TES")		,)
			If aCfgNf[SlRemito] .AND. aCfgNf[SnTipo] == 54 .AND. Type("M->F2_TIPORET")=='C' .AND. (M->F2_TIPORET == '1') .AND. Ascan(aObrigSX3, "D2_LOCDEST")		<=0	.AND.ExisteCampo("D2_LOCDEST",.T.)[1]
				AADD(aCpObrig, "D2_LOCDEST")
			EndIf
			If aCfgNf[SlRemito] .AND. aCfgNf[SnTipo] == 54 .AND. Type("M->F2_TIPORET")=='C' .AND. M->F2_TIPORET == '1' .AND. Ascan(aObrigSX3, "D2_TESENT")		<=0	.AND.ExisteCampo("D2_TESENT",.T.)[1]
				AADD(aCpObrig, "D2_TESENT")
			EndIf
	EndCase
EndIf //(1)
Return aCpObrig

/*
±±³Fun‡…o    ³CposAutogNf ³ Autor ³ Leandro C. G.         ³ Data ³27/11/2001³±±
±±³Descri‡…o ³Verifica todos os campos que possuem um conteudo padrao e 	³±±
±±³			 ³devolve tanto o campo como o conteudo padrao					³±±
±±³ Uso      ³ CONSISTENF  												    ³±±
param.
cAlias		- Alias de onde devem ser buscados os campos e valores padrao (obrgit)
lFormP  	- Indica e formulario proprio ou nao
cAliasCF	- Alias do cliente (SA1) ou fornec. (SA2) (obrigt)
aCposOri	- Campos do Alias em questao que estao sendo considerados
aDadosOri	- Conteudo dos campos do array aCposOri (deve ser bidimensional)
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
nLinha		- se o array aDadosOri possuir mais que uma linha e so deve ser tartada uma linha especifica, passa-se o numnero da linha atraves deste parametro.
			Se for nulo ou 0, considera todas as linhas
Retorno
aRet		- Array com campos e conteudos inclusive os contedos padrao para o arquivo
		  [1] - nome dos campos incluindo os campos automaticos
		  [2] - conteudo dos campos incluindo o dos campos automaticos
*/
Function CposAutoNf(cAlias,cAliasCF,lFormP,aCposOri,aDadosOri,cTipDoc,nLinha)

Local nI,nX,cI						//Flag para Loop
Local aPars	   		:= {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nSavn			:= IIf(Type("n")=="N",n,0)
Local aRet			:= array(2)		//Array com os campos e os conteudos
/*									[1] - campos (aCpAuto)
									[2] - conteudos (aCpad) */
Private aCpos		:= IIf(!Empty(aCposOri),aClone(aCposOri),NIL)		//Campos referentes aos itens (aHeader)
Private aDados		:= IIf(!Empty(aDadosOri),aClone(aDadosOri),NIL)	//Conteudo dos itens
Private aCpAuto		:= {}			//Array com os campos que possuem um conteudo padrao/default
Private aCpad		:= {}			//Array com o conteudo dos campos

//³Consistindo param.³
Aadd(aPars, {"cAlias"	,cAlias		,Sp4String	, "SF1"	,"SF2"	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cAliasCF"	,cAliasCF	,Sp2String	, "SA1"	,"SA2"					} )
Aadd(aPars, {"cTipDoc"	,cTipDoc	,SpEmpty									} )
Aadd(aPars, {"aCpos"	,aCpos		,SpEmpty									} )
Aadd(aPars, {"aDados"	,aDados		,SpEmpty									} )
Aadd(aPars, {"lFormP"	,lFormP		,SpEmpty									} )
If !LocxParam("",aPars,.F.)
	Return({aCposOri,aDadosOri})
EndIf

Default nLinha := 0

//³Montagem de todos os campos obrigatorios e seu respectivo conteudo, de acordo com o arquivo³
Do Case
	//³SF1 - Cabecalho de Entrada³
	Case cAlias == "SF1"
		If ExisteCampo("F1_FORMUL",.T.)[1]
			AADD(aCpAuto, "F1_FORMUL")
			AADD(aCpad	, IIf(aCfgNf[SlFormProp],"S","N"))
		EndIf
		If ExisteCampo("F1_STATUS",.T.)[1]
			AADD(aCpAuto, "F1_STATUS")
			AADD(aCpad	, "A")
		EndIf
		If ExisteCampo("F1_RECBMTO",.T.)[1]
			AADD(aCpAuto, "F1_RECBMTO")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("F1_DTDIGIT",.T.)[1]
			AADD(aCpAuto, "F1_DTDIGIT")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("F1_EMISSAO",.T.)[1]
			AADD(aCpAuto, "F1_EMISSAO")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("F1_EST",.T.)[1]
			AADD(aCpAuto, "F1_EST")
			AADD(aCpad	, {'Posicione("'+cAliasCF+'",1,xFilial("'+cAliasCF+'")+M->F1_FORNECE+M->F1_LOJA,PrefixoCpo("'+cAliasCF+'")+"_EST")',.T.})
		EndIf
		If ExisteCampo("F1_TIPO",.T.)[1]
			AADD(aCpAuto, "F1_TIPO")
			AADD(aCpad	, cTipDoc)
		EndIf
		If ExisteCampo("F1_FILIAL",.T.)[1]
			AADD(aCpAuto, "F1_FILIAL")
			AADD(aCpad	, xFilial('SF1'))
		EndIf
		If ExisteCampo("F1_DUPL",.T.)[1]
			AADD(aCpAuto, "F1_DUPL")
			AADD(aCpad	, {"IIf(MaFisRet(,'NF_BASEDUP')>0,M->F1_DOC,'')",.T.})
		Endif
		If ExisteCampo("F1_MOEDA",.T.)[1]
			AADD(aCpAuto, "F1_MOEDA")
			AADD(aCpad	, 1)
		EndIf
		If ExisteCampo("F1_TXMOEDA",.T.)[1]
			AADD(aCpAuto, "F1_TXMOEDA")
			AADD(aCpad	, {"IIF(M->F1_MOEDA==1,0,RecMoeda(dDataBase,M->F1_MOEDA))",.T.})
		EndIf
		If ExisteCampo("F1_COND",.T.)[1]
			AADD(aCpAuto, "F1_COND")
			AADD(aCpad	, {"IIf(Type('cCondicao')=='C',cCondicao,NIL)",.T.})
		EndIf
		If ExisteCampo("F1_TIPODOC",.T.)[1]
			AADD(aCpAuto, "F1_TIPODOC")
			AADD(aCpad	, StrZero(aCfgNF[SnTipo],2))
		EndIf
		If ExisteCampo("F1_ESPECIE",.T.)[1]
			AADD(aCpAuto, "F1_ESPECIE")
			AADD(aCpad	, aCfgNF[ScEspecie])
		EndIf
		If ExisteCampo("F1_TIPO",.T.)[1]
			AADD(aCpAuto, "F1_TIPO")
			AADD(aCpad	, aCfgNF[ScTipoDoc])
		EndIf
		If ExisteCampo("F1_ORIGLAN",.T.)[1]
			AADD(aCpAuto, "F1_ORIGLAN")
			AADD(aCpad	, IIf(aCfgNF[SlConFrDp][1],"F ",Iif(aCfgNF[SlConFrDp][2]," D","")))
		EndIf
		If ExisteCampo("F1_DESPESA",.T.)[1]
			AADD(aCpAuto, "F1_DESPESA")
			AADD(aCpad	, {"MaFisRet(,'NF_DESPESA')",.T.})
		EndIf
		If ExisteCampo("F1_DESCONT",.T.)[1]
			AADD(aCpAuto, "F1_DESCONT")
			AADD(aCpad	, {"MaFisRet(,'NF_DESCONTO')",.T.})
		EndIf
		If ExisteCampo("F1_FRETE",.T.)[1]
			AADD(aCpAuto, "F1_FRETE")
			AADD(aCpad	, {"MaFisRet(,'NF_FRETE')",.T.})
		EndIf
		If ExisteCampo("F1_SEGURO",.T.)[1]
			AADD(aCpAuto, "F1_SEGURO")
			AADD(aCpad	, {"MaFisRet(,'NF_SEGURO')",.T.})
		EndIf
		If ExisteCampo("F1_VALMERC",.T.)[1]
			AADD(aCpAuto, "F1_VALMERC")
			AADD(aCpad	, {"MaFisRet(,'NF_VALMERC')",.T.})
		EndIf
		If ExisteCampo("F1_VALBRUT",.T.)[1]
			AADD(aCpAuto, "F1_VALBRUT")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_TOTAL')",.T.},0))
		EndIf
		//#PORTUGAL#
		/*If cPaisLoc == "PTG"
			If ExisteCampo("F1_DESNTRB",.T.)[1]
				AADD(aCpAuto, "F1_DESNTRB")
				AADD(aCpad	, {"MaFisRet(,'NF_DESNTRB')",.T.})
			EndIf
			If ExisteCampo("F1_TARA",.T.)[1]
				AADD(aCpAuto, "F1_TARA")
				AADD(aCpad	, {"MaFisRet(,'NF_TARA')",.T.})
			EndIf
		Endif*/
		If aCfgNF[ScTipoDoc]  == "D"
			If ExisteCampo("F1_GERAPED",.T.)[1]
				AADD(aCpAuto, "F1_GERAPED")
				If ExistBlock('MT46205')
					AADD(aCpad	, { "If(ExecBlock('MT46205',.F.,.F.),'1','2')",.T. })
				Else
					AADD(aCpad	, "2" )
				Endif
			EndIf
		Endif
		If aCfgNF[SnTipo]  == 63 //Retorno de beneficiamento
			If ExisteCampo("F1_GERAPED",.T.)[1]
				AADD(aCpAuto, "F1_GERAPED")
				AADD(aCpad	, "1" )
			EndIf
		Endif
		If ExisteCampo("F1_HORA",.T.)[1]
			AADD(aCpAuto, "F1_HORA")
			If ExistBlock( "LXHORANFIS" )
				AADD(aCpad	, { "ExecBlock('LXHORANFIS',.F.,.F.)",.T. })
			Else
				AADD(aCpad	, {"Substr(GetRmtTime(),1,8)",.T.})
			EndIf
		EndIf
		If ExisteCampo("F1_SECSRI",.T.)[1]
			AADD(aCpAuto, "F1_SECSRI")
			AADD(aCpad	, {"1",.T.})
		EndIf
		If lUsaCor			//Numero correlativo de compras
			If ExisteCampo("F1_NUMCOR",.T.)[1]
				AADD(aCpAuto, "F1_NUMCOR")
				AADD(aCpad	, {"M->F1_NUMCOR",.T.})
			Endif
		Endif
	//³SD1 - Itens de Entrada³
	Case cAlias == "SD1"
		If ExisteCampo("D1_DOC",.T.)[1]
			AADD(aCpAuto, "D1_DOC")
			AADD(aCpad	, {"M->F1_DOC", .T.})
		EndIf
		If ExisteCampo("D1_FORMUL",.T.)[1]
			AADD(aCpAuto, "D1_FORMUL")
			AADD(aCpad	, IIf(aCfgNf[SlFormProp],"S","N"))
		EndIf
		If ExisteCampo("D1_TIPO",.T.)[1]
			AADD(aCpAuto, "D1_TIPO")
			AADD(aCpad	, cTipDoc)
		EndIf
		If ExisteCampo("D1_ESPECIE",.T.)[1]
			AADD(aCpAuto, "D1_ESPECIE")
			AADD(aCpad	, aCfgNF[ScEspecie])
		EndIf
		If ExisteCampo("D1_DTDIGIT",.T.)[1]
			AADD(aCpAuto, "D1_DTDIGIT")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("D1_EMISSAO",.T.)[1]
			AADD(aCpAuto, "D1_EMISSAO")
			AADD(aCpad	, {"M->F1_EMISSAO", .T.})
		EndIf
		If ExisteCampo("D1_SERIE",.T.)[1]
			AADD(aCpAuto, "D1_SERIE")
			AADD(aCpad	, {"M->F1_SERIE", .T.})
		EndIf
		If ExisteCampo("D1_LOJA",.T.)[1]
			AADD(aCpAuto, "D1_LOJA")
			AADD(aCpad	, {"M->F1_LOJA", .T.})
		EndIf
		If ExisteCampo("D1_FORNECE",.T.)[1]
			AADD(aCpAuto, "D1_FORNECE")
			AADD(aCpad	, {"M->F1_FORNECE", .T.})
		EndIf
		If ExisteCampo("D1_FILIAL",.T.)[1]
			AADD(aCpAuto, "D1_FILIAL")
			AADD(aCpad	, xFilial('SD1'))
		EndIf
		If ExisteCampo("D1_UM",.T.)[1]
	    	AADD(aCpAuto, "D1_UM")
    		AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D1_COD,'B1_UM')",.T.})
  		EndIf
		If ExisteCampo("D1_SEGUM",.T.)[1]
			AADD(aCpAuto, "D1_SEGUM")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D1_COD,'B1_SEGUM')",.T.})
		EndIf
		If ExisteCampo("D1_GRUPO",.T.)[1]
			AADD(aCpAuto, "D1_GRUPO")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D1_COD,'B1_GRUPO')",.T.})
		EndIf
		If ExisteCampo("D1_TP",.T.)[1]
			AADD(aCpAuto, "D1_TP")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D1_COD,'B1_TIPO')",.T.})
		EndIf
		If ExisteCampo("D1_NUMSEQ",.T.)[1]
			AADD(aCpAuto, "D1_NUMSEQ")
			AADD(aCpad	, {"ProxNum()",.T.})
		EndIf
		If ExisteCampo("D1_CF",.T.)[1] .AND.cPaisLoc <> "BRA"
			AADD(aCpAuto, "D1_CF")
			AADD(aCpad	, {"Posicione('SF4',1,xFilial('SF4')+M->D1_TES,'F4_CF')",.T.})
		EndIf
		If ExisteCampo("D1_IDENTB6",.T.)[1]
			AADD(aCpAuto, "D1_IDENTB6")
			AADD(aCpad	, {"BuscaIdentB6('SD1')",.T.})
		EndIf
		If ExisteCampo("D1_RATEIO",.T.)[1]
			AADD(aCpAuto, "D1_RATEIO")
			AADD(aCpad	, "")
		EndIf
		If ExisteCampo("D1_TIPODOC",.T.)[1]
			AADD(aCpAuto, "D1_TIPODOC")
			AADD(aCpad	, StrZero(aCfgNF[SnTipo],2))
		EndIf
		If ExisteCampo("D1_QTDACLA",.T.)[1]
			AADD(aCpAuto, "D1_QTDACLA")
			//#PORTUGAL#
			//If cPaisLoc<>"PTG"
				AADD(aCpad	, If(aCfgNF[SlRemito],{"M->D1_QUANT",.T.},0))
			/*Else
			    //No ambiente Portugal, para gravar o D1_QTDACLA, e necessario, fazer esta alteracao, pois para ativar
			    //a Guia de Remessa com as abas: Impostos, Duplicadas e Livros fiscais e necessario configurar o aCfgNF[SlRemito]
				If aCfgNF[SnTipo]==65
					AADD(aCpad	, {"M->D1_QUANT",.T.})
				Else
					AADD(aCpad	, If(aCfgNF[SlRemito],{"M->D1_QUANT",.T.},0))
				EndIf
			EndIf*/
		EndIf
		If ExisteCampo("D1_ORIGLAN",.T.)[1]
			AADD(aCpAuto, "D1_ORIGLAN")
			AADD(aCpad	, IIf(aCfgNF[SlConFrDp][1],"FR",Iif(aCfgNF[SlConFrDp][2],"DP","")))
		EndIf
		If ExisteCampo("D1_NUMDESP",.T.)[1]
			AADD(aCpAuto, "D1_NUMDESP")
			AADD(aCpad	, {Iif(Type("M->F1_NUMDES")=="C","M->F1_NUMDES",""),.T.})
		EndIf
		If ExisteCampo("D1_ORIGEM",.T.)[1]
			AADD(aCpAuto, "D1_ORIGEM")
			AADD(aCpad	, {Iif(Type("M->F1_ORIGEM")=="C","M->F1_ORIGEM",""),.T.})
		EndIf
		If ExisteCampo("D1_REVISAO",.T.)[1]
			 AADD(aCpAuto, "D1_REVISAO")
			 AADD(aCpad , "")
		EndIf
		If (cPaisLoc == "RUS")
			// Campos referentes ao imposto
			lFim := .F.
			cI 	 := "0"
			While !lFim
				cI	:=	Soma1(cI)
				If 		ExisteCampo("D1_BASIMP"+cI,.T.)[1] .AND.	;
				   		ExisteCampo("D1_VALIMP"+cI,.T.)[1] .AND.	;
				   		ExisteCampo("D1_ALQIMP"+cI,.T.)[1]
					Aadd(aCpAuto, "D1_BASIMP"+cI )
					Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_BASEIV"+cI+"'),0)",.T.},0))
					Aadd(aCpAuto, "D1_VALIMP"+cI )
					Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_VALIV"+cI+"'),0)",.T.},0))
					Aadd(aCpAuto, "D1_ALQIMP"+cI )
					Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_ALIQIV"+cI+"'),0)",.T.},0))
				Else
					lFim := .T.
				EndIf
			End
		Endif
		If cPaisLoc == "RUS"
			If ExisteCampo("D1_BSIMP1M",.T.)[1]
				Aadd(aCpAuto, "D1_BSIMP1M" )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_BASEIV1_C1'),0)",.T.},0))
			EndIf
			If ExisteCampo("D1_VLIMP1M",.T.)[1]
				Aadd(aCpAuto, "D1_VLIMP1M" )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_VALIV1_C1'),0)",.T.},0))
			EndIf
		EndIf
	//³SF2 - Cabecalho de Saida³
	Case cAlias == "SF2"
		If ExisteCampo("F2_FILIAL",.T.)[1]
			AADD(aCpAuto, "F2_FILIAL")
			AADD(aCpad	, xFilial('SF2'))
		EndIf
		If ExisteCampo("F2_FORMUL",.T.)[1]
			AADD(aCpAuto, "F2_FORMUL")
			AADD(aCpad	, IIf(aCfgNf[SlFormProp],"S","N"))
		EndIf
		If ExisteCampo("F2_TIPO",.T.)[1]
			AADD(aCpAuto, "F2_TIPO")
			AADD(aCpad	, cTipDoc)
		EndIf
		If ExisteCampo("F2_DTDIGIT",.T.)[1]
			AADD(aCpAuto, "F2_DTDIGIT")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("F2_EST",.T.)[1]
			AADD(aCpAuto, "F2_EST")
			AADD(aCpad	, {'Posicione("'+cAliasCF+'",1,xFilial("'+cAliasCF+'")+M->F2_CLIENTE+M->F2_LOJA,PrefixoCpo("'+cAliasCF+'")+"_EST")',.T.})
		EndIf
		If !Empty(aCfgNF[ScOpFin])
			AADD(aCpAuto, "F2_DUPL")
			AADD(aCpad	, {"M->F2_DOC",.T.})
		Endif
		If ExisteCampo("F2_HORA",.T.)[1]
			AADD(aCpAuto, "F2_HORA")
			If ExistBlock( "LXHORANFIS" )
				AADD(aCpad	, { "ExecBlock('LXHORANFIS',.F.,.F.)",.T. })
			Else
				AADD(aCpad	, {"SubStr(GetRmtTime(),1,8)",.T.})
			EndIf
		EndIf
		If 	ExisteCampo("F2_TIPOCLI",.T.)[1] .AND. cAliasCF == "SA1"
			AADD(aCpAuto, "F2_TIPOCLI")
			AADD(aCpad	, {"Posicione('SA1',1,xFilial('SA1')+M->F2_CLIENTE+M->F2_LOJA,'A1_TIPO')",.T.})
		EndIf
		If ExisteCampo("F2_MOEDA",.T.)[1]
			AADD(aCpAuto, "F2_MOEDA")
			AADD(aCpad	, 1)
		EndIf
		If ExisteCampo("F2_TXMOEDA",.T.)[1]
			AADD(aCpAuto, "F2_TXMOEDA")
			AADD(aCpad	, {"IIF(M->F2_MOEDA==1,0,RecMoeda(dDataBase,M->F2_MOEDA))",.T.})
		EndIf
		If ExisteCampo("F2_COND",.T.)[1]
			AADD(aCpAuto, "F2_COND")
			AADD(aCpad	, {"IIf(Type('cCondicao')=='C',cCondicao,NIL)",.T.})
		EndIf
		If ExisteCampo("F2_TIPODOC",.T.)[1]
			AADD(aCpAuto, "F2_TIPODOC")
			AADD(aCpad	, StrZero(aCfgNF[SnTipo],2))
		EndIf
		If ExisteCampo("F2_ESPECIE",.T.)[1]
			AADD(aCpAuto, "F2_ESPECIE")
			AADD(aCpad	, aCfgNF[ScEspecie])
		EndIf
		If ExisteCampo("F2_TIPO",.T.)[1]
			AADD(aCpAuto, "F2_TIPO")
			AADD(aCpad	, aCfgNF[ScTipoDoc])
		EndIf
		If ExisteCampo("F2_DESPESA",.T.)[1]
			AADD(aCpAuto, "F2_DESPESA")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_DESPESA')",.T.},0))
		EndIf
		If ExisteCampo("F2_DESCONT",.T.)[1]
			AADD(aCpAuto, "F2_DESCONT")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_DESCONTO')",.T.},0))
		EndIf
		If ExisteCampo("F2_FRETE",.T.)[1]
			AADD(aCpAuto, "F2_FRETE")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_FRETE')",.T.},0))
		EndIf
		If ExisteCampo("F2_SEGURO",.T.)[1]
			AADD(aCpAuto, "F2_SEGURO")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_SEGURO')",.T.},0))
		EndIf
		If ExisteCampo("F2_VALMERC",.T.)[1]
			AADD(aCpAuto, "F2_VALMERC")
			AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_VALMERC')",.T.},0))
		EndIf
		//#PORTUGAL#
		/*If cPaisLoc == "PTG"
			If ExisteCampo("F2_DESNTRB",.T.)[1]
				AADD(aCpAuto, "F2_DESNTRB")
				AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_DESNTRB')",.T.},0))
			EndIf
			If ExisteCampo("F2_TARA",.T.)[1]
				AADD(aCpAuto, "F2_TARA")
				AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_TARA')",.T.},0))
			EndIf
		Endif*/
		If ExisteCampo("F2_VALBRUT",.T.)[1]
			AADD(aCpAuto, "F2_VALBRUT")
			AADD(aCpad	,Iif(MaFisFound(), {"MaFisRet(,'NF_TOTAL')",.T.},0))
		EndIf
		If cPaisLoc == "RUS"
			If ExisteCampo("F2_VLMERCM",.T.)[1]
				AADD(aCpAuto, "F2_VLMERCM")
				AADD(aCpad	, Iif(MaFisFound(),{"MaFisRet(,'NF_VALMERC_C1')",.T.},0))
			EndIf
			If ExisteCampo("F2_VLBRUTM",.T.)[1]
				AADD(aCpAuto, "F2_VLBRUTM")
				AADD(aCpad	,Iif(MaFisFound(), {"MaFisRet(,'NF_TOTAL_C1')",.T.},0))
			EndIf
		EndIf
		If ExisteCampo("F2_TIPOREM",.T.)[1]
			AADD(aCpAuto, "F2_TIPOREM")
			If aCfgNF[SnTipo] == 54
				AADD(aCpad	, '6')
			Else
				AADD(aCpad	, '0')
			EndIf
		EndIf
		If ExisteCampo("F2_TIPORET",.T.)[1]
			AADD(aCpAuto, "F2_TIPORET")
			AADD(aCpad	, AllTrim(Str(GetMv('MV_TIPORET'))))
		EndIf
		If ExisteCampo("F2_SECSRI",.T.)[1]
			AADD(aCpAuto, "F2_SECSRI")
			AADD(aCpad	, {'1',.T.})
		EndIf
	//³SD2 - Itens de Saida³
	Case cAlias == "SD2"
		If ExisteCampo("D2_DOC",.T.)[1]
			AADD(aCpAuto, "D2_DOC")
			AADD(aCpad	, {"M->F2_DOC", .T.})
		EndIf
		If ExisteCampo("D2_NUMSEQ",.T.)[1]
			AADD(aCpAuto, "D2_NUMSEQ")
			AADD(aCpad	, {"ProxNum()", .T.})
		EndIf
		If ExisteCampo("D2_FORMUL",.T.)[1]
			AADD(aCpAuto, "D2_FORMUL")
			AADD(aCpad	, IIf(aCfgNf[SlFormProp],"S","N"))
		EndIf
		If ExisteCampo("D2_ESPECIE",.T.)[1]
			AADD(aCpAuto, "D2_ESPECIE")
			AADD(aCpad	, aCfgNF[ScEspecie])
		EndIf
		If ExisteCampo("D2_TIPO",.T.)[1]
			AADD(aCpAuto, "D2_TIPO")
			AADD(aCpad	, cTipDoc)
		EndIf
		If ExisteCampo("D2_DTDIGIT",.T.)[1]
			AADD(aCpAuto, "D2_DTDIGIT")
			AADD(aCpad	, dDataBase)
		EndIf
		If ExisteCampo("D2_EMISSAO",.T.)[1]
			AADD(aCpAuto, "D2_EMISSAO")
			AADD(aCpad	, {"M->F2_EMISSAO", .T.})
		EndIf
		If ExisteCampo("D2_SERIE",.T.)[1]
			AADD(aCpAuto, "D2_SERIE")
			AADD(aCpad	, {"M->F2_SERIE", .T.})
		EndIf
		If ExisteCampo("D2_LOJA",.T.)[1]
			AADD(aCpAuto, "D2_LOJA")
			AADD(aCpad	, {"M->F2_LOJA", .T.})
		EndIf
		If ExisteCampo("D2_CLIENTE",.T.)[1]
			AADD(aCpAuto, "D2_CLIENTE")
			AADD(aCpad	, {"M->F2_CLIENTE", .T.})
		EndIf
		If ExisteCampo("D2_FILIAL",.T.)[1]
			AADD(aCpAuto, "D2_FILIAL")
			AADD(aCpad	, {'xFilial("SD2")',.T.})
		EndIf
		If ExisteCampo("D2_UM",.T.)[1]
		  	AADD(aCpAuto, "D2_UM")
    		AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_UM')",.T.})
  		EndIf
		If ExisteCampo("D2_SEGUM",.T.)[1]
			AADD(aCpAuto, "D2_SEGUM")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_SEGUM')",.T.})
		EndIf
		If ExisteCampo("D2_GRUPO",.T.)[1]
			AADD(aCpAuto, "D2_GRUPO")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_GRUPO')",.T.})
		EndIf
		If ExisteCampo("D2_TP",.T.)[1]
			AADD(aCpAuto, "D2_TP")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_TIPO')",.T.})
		EndIf
		If ExisteCampo("D2_PRUNIT",.T.)[1]
			AADD(aCpAuto, "D2_PRUNIT")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_PRV1')",.T.})
		EndIf
 		If ExisteCampo("D2_CF",.T.)[1]	.AND. cPaisLoc <> "BRA"
			AADD(aCpAuto, "D2_CF")
			AADD(aCpad	, {"Posicione('SF4',1,xFilial('SF4')+M->D2_TES,'F4_CF')",.T.})
		EndIf
		If ExisteCampo("D2_IDENTB6",.T.)[1]
			AADD(aCpAuto, "D2_IDENTB6")
			AADD(aCpad	, {"BuscaIdentB6('SD2')",.T.})
		EndIf
		If ExisteCampo("D2_CONTA",.T.)[1]
			AADD(aCpAuto, "D2_CONTA")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_CONTA')",.T.})
		EndIf
		If ExisteCampo("D2_EST",.T.)[1]
			AADD(aCpAuto, "D2_EST")
			AADD(aCpad	, {'Posicione("'+cAliasCF+'",1,xFilial("'+cAliasCF+'")+M->F2_CLIENTE+M->F2_LOJA,PrefixoCpo("'+cAliasCF+'")+"_EST")',.T.})
		EndIf
		If ExisteCampo("D2_PESO",.T.)[1]
			AADD(aCpAuto, "D2_PESO")
			AADD(aCpad	, {"Posicione('SB1',1,xFilial('SB1')+M->D2_COD,'B1_PESO')",.T.})
		EndIf
		If ExisteCampo("D2_TPDCENV",.T.)[1]
			AADD(aCpAuto, "D2_TPDCENV")
			AADD(aCpad	, " " )
		Endif
		If ExisteCampo("D2_TIPODOC",.T.)[1]
			AADD(aCpAuto, "D2_TIPODOC")
			AADD(aCpad	, StrZero(aCfgNF[SnTipo],2))
		EndIf
		If ExisteCampo("D2_GERANF",.T.)[1]
			AADD(aCpAuto, "D2_GERANF" )
			If aCfgNf[SlRemito] .AND. aCfgNf[ScTipoDoc] == "N" .AND. ExisteCampo("D2_QTDAFAT",.T.)[1]
				AADD(aCpad	, {'Iif(Posicione("'+cAliasCF+'",1,xFilial("'+cAliasCF+'")+M->F2_CLIENTE+M->F2_LOJA,PrefixoCpo("'+cAliasCF+'")+"_CONFREM")=="1","N","S")',.T.}  )
			Else
				AADD(aCpad	, "N" )
			Endif
		Endif
		If ExisteCampo("D2_REVISAO",.T.)[1]
			 AADD(aCpAuto, "D2_REVISAO")
			 AADD(aCpad , "")
		EndIf
		If (aCfgNf[SlRemito] .AND. aCfgNf[ScTipoDoc] == "N" .AND. ExisteCampo("D2_QTDAFAT",.T.)[1]) .OR. aCfgNf[SnTipo]==54
			AADD(aCpAuto, "D2_QTDAFAT")
		    If aCfgNf[SnTipo]==54
				AADD(aCpad	, {"M->D2_QUANT",.T.})
			Else
				AADD(aCpad	, {"Iif( M->D2_GERANF<>'N'.AND. Posicione('SA1',1,xFilial('SA1')+M->F2_CLIENTE+M->F2_LOJA,'A1_CONFREM')#'1',M->D2_QUANT,0)",.T.})
			EndIf
		EndIf
		If aCfgNf[SlRemito] .AND. aCfgNf[ScTipoDoc] == "N" .AND. ExisteCampo("D2_TIPOREM",.T.)[1]
			AADD(aCpAuto, "D2_TIPOREM")
			If aCfgNF[SnTipo] == 54
				AADD(aCpad	, '6')
			Else
				AADD(aCpad	, '0')
			EndIf
		Endif
		// Campos de comissoes
		For nI := 1 to Fa440CntVen()
			If ExisteCampo("D2_COMIS"+AllTrim(Str(nI)),.T.)[1]
				Aadd(aCpAuto, "D2_COMIS"+AllTrim(Str(nI)) )
				Aadd(aCpad	, {"NfComis("+AllTrim(Str(nI))+")",.T.})
			EndIf
		Next nI
		// Campos referentes ao imposto
		lFim := .F.
		cI 	 := "0"
		While !lFim
			cI	:=	Soma1(cI)
			If 		ExisteCampo("D2_BASIMP"+cI,.T.)[1] .AND.	;
			   		ExisteCampo("D2_VALIMP"+cI,.T.)[1] .AND.	;
			   		ExisteCampo("D2_ALQIMP"+cI,.T.)[1]
				Aadd(aCpAuto, "D2_BASIMP"+cI )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_BASEIV"+cI+"'),0)",.T.},0))
				Aadd(aCpAuto, "D2_VALIMP"+cI )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_VALIV"+cI+"'),0)",.T.},0))
				Aadd(aCpAuto, "D2_ALQIMP"+cI )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_ALIQIV"+cI+"'),0)",.T.},0))
			Else
				lFim := .T.
			EndIf
		End
		If cPaisLoc == "RUS"
			If ExisteCampo("D2_BSIMP1M",.T.)[1]
				Aadd(aCpAuto, "D2_BSIMP1M" )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_BASEIV1_C1'),0)",.T.},0))
			EndIF
			If ExisteCampo("D2_VLIMP1M",.T.)[1]
				Aadd(aCpAuto, "D2_VLIMP1M" )
				Aadd(aCpad	, Iif(MaFisFound(),{"IIf(MaFisFound('IT',n),MaFisRet(n,'IT_VALIV1_C1'),0)",.T.},0))
			EndIf
		EndIf
EndCase
//³Verifica se todos os campos automaticos dos itens estao sendo considerados e possuem conteudo nos array's enviados por parametro³
If Len(aCpAuto) > 0
	//³Verifica se algum conteudo automatico e formula³
	Aeval(aCpad, { |x| If(ValType(x)=="A",lForm:=.T.,) })
	//³Verifica se existe no parametro passado para a funcao, os campos automaticos e adiciona os que nao houverem, ³
	//³guardando a pos. de cada campo automatico no array passado por parametro no array aPos
	aPos := {}
	For nI	:=	1	To Len(aCpAuto)
		Aadd(aPos, Ascan(aCpos,{|x| Alltrim(x)==aCpAuto[nI]} ))
	Next nI
	Aeval(aPos, { |x,y| IIf(x==0,Aadd(aCpos,aCpAuto[y]),) })
	//³Atualiza o array de conteudos³
	nI := 0
	For nI := IIf(nLinha==0,1,nLinha) to IIf(nLinha==0,Len(aDados),nLinha)
		n := nI
		//³Se existir algum conteudo que seja formula, carrega em variaveis de memoria o conteudo de todos os campos³
		IIf(lForm, Aeval(aCpos, { |x,y| IIf(y<=Len(aDados[nI]),&("M->"+x):=IIf(ValType(aDados[nI][y])!="A",aDados[nI][y],NIL),) }) ,)
		//³Carregando conteudos³
		nX := 0
		For nX := 1 to Len(aCpAuto)
			If aPos[nX] == 0
				nAux := 0
				Aadd(aDados[nI], NIL)
				If ValType(aDados[nI][Len(aDados[nI])-1]) == "L"
					aDados[nI][Len(aDados[nI])]	:= aDados[nI][Len(aDados[nI])-1]
					nAux := 1
				EndIf
				aDados[nI][Len(aDados[nI])-nAux]	:= IIf(ValType(aCpad[nX])!="A",aCpad[nX],ExecFormula(aCpad[nX][1],,))
				&("M->"+aCpAuto[nX]) := aDados[nI][Len(aDados[nI])-nAux]
			ElseIf Empty(aDados[nI][aPos[nX]])
				aDados[nI][aPos[nX]] := IIf(ValType(aCpad[nX])!="A",aCpad[nX],ExecFormula(aCpad[nX][1],,))
				&("M->"+aCpAuto[nX]) := aDados[nI][aPos[nX]]
			EndIf
			If aCfgNF[SlRemito] .AND. aCpAuto[nX] == "D1_QTDACLA" .AND. AllTrim(aCfgNf[ScEspecie])!="RTE" .AND. AllTrim(aCfgNf[ScEspecie])!="RTS"
				aDados[nI][aPos[nX]] := IIf(ValType(aCpad[nX])!="A",aCpad[nX],ExecFormula(aCpad[nX][1],,))
				&("M->"+aCpAuto[nX]) := aDados[nI][aPos[nX]]
			Endif
		Next nX
		//³Acertando o array de origem³
		Aeval(aPos, { |x,y| IIf(x>0,IIf(Empty(aDadosOri[nI][x]),aDadosOri[nI][x]:=aDados[nI][x],),) })
	Next nI
EndIf
//³Montando array de Devolucao da funcao³
aRet[1] := aClone(aCpos)
aRet[2] := aClone(aDados)
//³Restaura numero do item do aCols³
If nSavn > 0
	n := nSavn
EndIf
Return(aRet)

/*
±±³Fun‡…o    ³MontaHeader ³ Autor ³ Leandro C. G.         ³ Data ³28/11/2001³±±
±±³Descri‡…o ³Monta o aHeader de acordo com os campos desejados				³±±
param.
aCpos	- Campos que serao incluidos no aHeader
*/
Function MontaHeader(aCpos)
Local aArea  	:= GetArea()			//Guarda configuracao da area atual
Local aSX3		:= GetArea("SX3")
Local nI	   							//Flag's para loop's
Local aH		:= {}

DBSelectArea("SX3")
DBSetOrder(2)

nI := 0
For nI := 1 to Len(aCpos)
	If MSSeek(AllTrim(aCpos[nI]), .F.)
		AADD(aH,{ 	TRIM(x3titulo())	,;
					SX3->X3_CAMPO		,;
					SX3->X3_PICTURE		,;
					SX3->X3_TAMANHO		,;
					SX3->X3_DECIMAL		,;
					SX3->X3_VALID		,;
					SX3->X3_USADO		,;
					SX3->X3_TIPO		,;
					SX3->X3_ARQUIVO		,;
					SX3->X3_CONTEXT		})
	Else
		AADD(aH, {,,,,,,,,,})
	EndIf
Next nI

RestArea(aSX3)
RestArea(aArea)
Return(aH)

/*
±±³Fun‡…o    ³RestauraMatriz ³ Autor ³ Leandro C. G.      ³ Data ³28/11/2001³±±
±±³Descri‡…o ³Restaura conteudo do aCols e do aHeader       				³±±
param.
aSalvaCols		- aCols que estava salvo e deve ser restaurado
aSalvaHeader	- aHeader que estava sendo restaurado
*/
Function RestauraMatriz(aSalvaCols,aSalvaHeader)
IIf(Type("aCols")!="U".AND.!Empty(aSalvaCols)		,aCols		:= aClone(aSalvaCols)	,)
IIf(Type("aHeader")!="U".AND.!Empty(aSalvaHeader)	,aHeader	:= aClone(aSalvaHeader)	,)
Return(.T.)

/*
±±³Fun‡…o    ³ConsisteSX3    ³ Autor ³ Leandro C. G.      ³ Data ³05/12/2001³±±
±±³Descri‡…o ³Efetua consistencias nos campos da NF de acordo com SX3		³±±
param.
aCposc	 - campos de cabecalho que devem ser consistidos
aDadosC	 - dados referentes aos campos de cabecalho que devem ser consistidos
aCposI	 - campos de itens de NF que devem ser consistidos
aDadosI	 - dados referentes aos campos de itens da NF
aFormula - indica quais os conteudos de cabecalho sao totalizadores
*/
Function ConsisteSX3(aCposC,aDadosC,aTotaliz,aCposI,aDadosI)
Local nI,nX					//Flag's para loop's
Local cConteudo				//Conteudo de um determinado campo (pode ser o proprio conteudo ou tambem uma formula
Local lRet	:= .T.			//Indica consistencia da Funcao

//³Variaveis utilizadas em outras funcoes³
IIf(Type("bRefresh")!="B",bRefresh:=&("{|| NIL }"),)
IIf(Type("bListRefresh")!="B",bListRefresh:=&("{|| NIL }"),)

//³Verifica param. dos dados de cabecalho ³
If	!Empty(aCposC) 		.AND.	!Empty(aDadosC)		.AND.;
    Len(aCposC) > 0 	.AND.	Len(aDadosC) > 0	.AND.;
    Len(aCposC)+1 == Len(aDadosC)

	//³Acertana pos. referente a indicador de formula ³
	Default aTotaliz := Array(Len(aCposC))
	Asize(aTotaliz, Len(aCposC))
	Aeval(aTotaliz, { |x,y| If(x==NIL,aTotaliz[y]:=.F.,) })

	//³Consistindo campos de cabecalho³
	nI := 0
	For nI := 1 to Len(aCposC)
		&("M->"+aCposC[nI]) := aDadosC[nI]
		__ReadVar := aCposC[nI]
		//³Verifica se o conteudo do campo e totalizador ou e uma formula³
		If aTotaliz[nI]
			cConteudo := ExecTotal(aDadosC[nI],aCposI,aDadosI)
		ElseIf ValType(aDadosC[nI]) != "A"
			cConteudo := aDadosC[nI]
		ElseIf aDadosC[nI][2]
			cConteudo := ExecFormula(aDadosC[nI][1],aCposC,aDadosC)
		EndIf
		//³Checando validacoes do SX3³
		If !CheckSX3(aCposC[nI],cConteudo)
			lRet := .F.
		EndIf
	Next nI
EndIf

If lRet //(1)
	//³Verifica param. dos dados de itens
	If	!Empty(aCposI) 		.AND.	!Empty(aDadosI)		.AND.;
	    Len(aCposI) > 0 	.AND.	Len(aDadosI) > 0
		nI := 0
		For nI := 1 to Len(aDadosI)
			//³Verifica se a linha nao esta deletada³
			If aDadosI[nI][Len(aDadosI[nI])] .OR. Len(aDadosI) != Len(aCposI)+1
				Loop
			EndIf
			n  := nI 	//variavel utilizada em sub-rotinas de validacao. Representa o numero do item do acols
			nX := 0
			For nX := 1 to Len(aCposI)
				&("M->"+aCposI[nX]) := aDadosI[nI][nX]
				__ReadVar := aCposI[nX]
				//³Verifica se o conteudo do campo e formula³
				If ValType(aDadosI[nI][nX]) != "A"
					cConteudo := aDadosI[nI][nX]
				ElseIf aDadosI[nI][nX][2]
					cConteudo := ExecFormula(aDadosI[nI][nX][1],aCposI,aDadosI[nI])
				EndIf
				//³Checa validacoes do SX3³
				If !CheckSX3(aCposI[nX], cConteudo)	//so consiste dados quando nao for formula (valtype == A)
					lRet := .F.
				EndIf
			Next nX
		Next nI
	EndIf
EndIf //lRet (1)
Return lRet

/*
±±³Fun‡…o    ³NfTudOk        ³ Autor ³ Leandro C. G.      ³ Data ³12/12/2001³±±
±±³Descri‡…o ³Efetua as validacoes gerais na gravacao das notas fiscais  	³±±
±±³ Uso      ³ CONSISTENF												    ³±±
param.
cAliasC			-	Alias de cabecalho de NF
cAliasI			- 	Alias de Itens de NF
cAliasCF		- 	Alias referente ao arquivo de clientes ou fornec. (SA1/SA2)
cTipDoc 		- 	Tipo de documento da NF
			  		N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
lFormP			- Indica se tem formulario proprio(.T.) ou nao(.F.)
aCabNotaOri 	- 	Cabecalho da Nota
		   		[1] - campos do cabecalho
		   		[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
		   		[3] - indica se o campo e totalizador (Default .F.)
		   		Obs.: se o campo for um totalizador, a formula para se totalizar deve ser colocada no lugar do conteudo [2]
           		e deve ser levado em consideracao que ira totalizar sempre o conteudo atual mais o conteudo da formula a cada item gravado
aCpItensOri 	- campos dos itens (aHeader)
aCitensOri  	- conteudo dos itens da NF (aCols) * o conteudo de cada campo pode ser uma formula
nLinha			- se for 0 nao consiste atraves da LinOk, se for > 0 consiste apenas a linha passada pelo parametro e se for nulo consiste todas as linhas
*/
Function NfTudOk(cAliasC,cAliasI,cAliasCF,aCabNotaOri,aCpItensOri,aCitensOri,nLinha,cTipDoc,lFormP,aGetsTela,lTela)
Local nI,nX							//Flag's para Loop's
Local aArea    := GetArea()
Local aAreaC   := GetArea(cAliasC)
Local lRet	   := .T.				//Indica consistencia da rotina
Local aAux	   := {}				//Array auxiliar
Local nPos	   := 0					//pos. de um determinado campo numa matriz
//Local cPrefix  := IIf(!Empty(cAliasC),cAliasC+"->"+PrefixoCpoc(cAliasC),"") //Prefixo do arquivo de cabecalho
Local cCliFor  := ""
Local cLoja    := ""
Local nSerie,nNF
Local nVend	   := 0					//Numero de vendedores utilizados no sistema
//Local cSeriex  := ""				//Serie especifica para o cliente
Local aPars	   := {}				//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local aCitens  := aClone(aCitensOri)
Local aCpItens := aClone(aCpItensOri)
Local aCabNota := aClone(aCabNotaOri)
Local lGeraBlq := .F.
Local lClasBlq := If(SuperGetMV("MV_RESTCLA",.F.,"2")=="1",.T.,.F.) //Restringe Classificacao de NF Bloqueada 1=Sim, 2=Nao (default)
Local lBlockPed:= .T.
Local nPosPc   := aScan(aCpItens,{|x| AllTrim(x)=="D1_PEDIDO" })
Local nPosProd := aScan(aCpItens,{|x| AllTrim(x)=="D1_COD"    })
Local nPosItem := aScan(aCpItens,{|x| AllTrim(x)=="D1_ITEM"   })
Local nPosItPc := aScan(aCpItens,{|x| AllTrim(x)=="D1_ITEMPC" })
Local nPosQtd  := aScan(aCpItens,{|x| AllTrim(x)=="D1_QUANT"  })
Local nPosVlr  := aScan(aCpItens,{|x| AllTrim(x)=="D1_VUNIT"  })
Local nPosRmt  := aScan(aCpItens,{|x| AllTrim(x)=="D1_REMITO" })
Local nPosRSer := aScan(aCpItens,{|x| AllTrim(x)=="D1_SERIREM"})
Local nPosItemR:= aScan(aCpItens,{|x| AllTrim(x)=="D1_ITEMREM"})
Local nPosGrade:= aScan(aCpItens,{|x| AllTrim(x)=="D1_GRADE"})
Local nPosItGrd:= aScan(aCpItens,{|x| AllTrim(x)=="D1_ITEMGRD"})
//Local nPosTotal:= aScan(aCpItens,{|x| AllTrim(x)=="D2_TOTAL"  })
//Local nPosPdIva:= 0
//Local cEspUSe  :=	""
//Local cSerieNf :=""
Local nTotDup	:=	0
//Local nPosCxVal := 0
//Local nPosCxCxa := 0
//Local nPosCxBen := 0
//Local nPosCxAdi := 0
//Local nPosCxHis := 0
Local nAltera := GetMV("MV_ALTNUM",,1)
Local cNumAnt :=""
//Local cAgente := GetNewPar("MV_AGENTE", "   ")
//Local nImpLst := 0
Local aDupli  := IIf(Type("aDupl")=="U",{},aDupl)
//Local cMesLim := ""
//Local cAnoLim := ""
//Local nAt	  := 0
Local nPosAFN := 0
Local nValAdt := 0 // Armazena o valor do adiant.
//Local nTotVenta := 0
//Local nLimVenta := GetMv("MV_EQUBVCF",,0)
//Local oGetNomeCli  := Nil
Local lIntNtCRDB := SuperGetMV( "MV_ATFNCRD", .F., .F. )	//Parâmetro de ativação do ajuste de valor do bem.
//Local cCentavos  := Iif(nMoedaNF==1,"MV_CENT",("MV_CENT"+AllTrim(Str(nMoedaNF))))
Local lLinhaOK	:= .F.
Local cFilSC7		:= xFilial("SC7")
Local cFilSD1	:= xFilial("SD1")
Local cFilSF1		:= xFilial("SF1")
Local nPosCdBar   := 0
Local cCodBar     := ""
//Local lMVCdcLoc := SuperGetMV( "MV_CDCLOC", .F., .F. ) //Paramentro consulta factura AFIP
Local dDataBloq	:= GetNewPar("MV_ATFBLQM",CTOD("")) //Data de Bloqueio da Movimentação - MV_ATFBLQM
Local dDataRef	:= CTOD("  /  /  ")
//Local nTamSer	:= TamSX3(SerieNfId("SF1",3,"F1_SERIE"))[1]
//Local nPosRelSat := Ascan(aCfgNf[SaCposBr], {|x,y| ALLTRIM(x[2])=="F2_RELSAT"})
//Local nPosUsoCFD := Ascan(aCfgNf[SaCposBr], {|x,y| ALLTRIM(x[2])=="F2_USOCFDI"})
//Local nPosRelCFD := Ascan(aCfgNf[SaCposBr], {|x,y| ALLTRIM(x[2])=="F2_UUIDREL"})
Local nPosCP     := 0 //Posición de campo de Carta Porte
//Local cSF        := IIf(cAliasC == "SF2", "F2", "F1")
Local nItemSrv   := 0
Local nTpProd    := 0
Local lCartaP    := cPaisLoc == "MEX" .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0 .And. M->F2_TPCOMPL =='S'
//Local lCfdi40    := SuperGetMV("MV_CFDI40",.F.,.F.)

// -- Utilizadas pelo controle de adiantameto, Somente para Angola|Mexico.
Local aPedido    := {}
Local aRecSC7    := {}
//Local oDlgVenta  := Nil
Local nValRelAdt := 0  // Valor que sera o limite do adiant. (Liquido da Primeira no Mexico)
Local cFunName	:= IIf(Type("cFunName")=="U" .Or. cFunName == Nil,Upper(Alltrim(FunName())),cFunName)	//Funcao Origem
Default aGetsTela := {}

If !IsMemVar("aHdrAFN")
	Private aHdrAFN := {}
EndIf
//utilizada na funcao a465Qtde
If Type("lCliente") == "U"
	Private lCliente := IIf(!Empty(cAliasCF).AND.cAliasCF=="SA1",.T.,.F.)
EndIf
//Utilizada na funcao
Private cVendedor := ""

Default lTela	:= .T.

//³Consistindo param.³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String		,"SA1"	,"SA2"	} )
Aadd(aPars, {"aCabNota"	, aCabNota	, SpLenArray	,1		,3		} )
Aadd(aPars, {"aCitens"	, aCitens	, SpEmpty						} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty						} )
Aadd(aPars, {"lFormP"	, lFormP	, SpEmpty						} )
lRet := LocxParam("NFTUDOK",aPars)

nPosCdBar := Ascan(aCabNotaOri[1], AllTrim(PrefixoCpo(cAliasC)+"_CODBAR"))
nPosCP    := Ascan(aCabNotaOri[1], AllTrim("F2_TPCOMPL"))

If nPosCdBar <> 0
	cCodBar := aCabNotaOri[2][nPosCdBar]
EndIf
If !LocxCODBOK(cAliasC, cCodBar, .T.)
	Return .F.
Endif
If lRet //(1)
	//³Valida as linhas de itens³
	If   nLinha == NIL .OR. nLinha > 0
		aAux 		:= CposAutoNf(cAliasI,cAliasCF,lFormP,aCpItens,aCitens,cTipDoc,)
		aCpItens	:= aAux[1]
		aCitens	:= aAux[2]
		If lCartaP
			nTpProd  := aScan(aAux[1],{|x| AllTrim(x)=="D2_TP"})
		EndIf
		For nI :=1 To Len(aCitens)
			If !aCitens[nI][Len(aCitens[nI])]
				lLinhaOK := .T.
				If nNFTipo == 1 .And. lCartaP .And. nTpProd > 0 .And. aCitens[nI][nTpProd] == "SV" //Factura de Tipo Normal
					nItemSrv += 1
				EndIf
			EndIf
		Next nI
		If !lLinhaOK
			lRet := .F.
		EndIf
		If !NfLinOk(cAliasI,aCpItens,cAliasCF,aCitens,cTipDoc,nLinha,lFormP)
			lRet := .F.
		EndIf
	 	If lRet .AND. !lLocxAuto .AND. Type("oGetDados") <> "U" .AND. lTela
	   		lRet:=	oGetDados:TudoOk()
	  	Endif
	EndIf
	If lRet //(2)
		//Verifica campos de cabecalho obrigatorios
		If !CposVazio(cAliasC,,cTipDoc,aCabNota,,)
			lRet := .F.
		EndIf
		If lRet //(3)
			//³Variaveis sobre campos de cabecalho³
			//³Como algumas validacoes foram retiradas de outros fontes, foi necessario preencher algumas ³
			//³variaveis para nao haver risco de que algum RDMake que possa ter sido criado considerando  ³
			//³a existencia de alguma das variaveis, desse problema										  ³
			//cTipo
			cTipo := cTipDoc
			//cnFiscal
			nPos := Ascan(aCabNota[1], AllTrim(PrefixoCpo(cAliasC)+"_DOC"))
			IIf(nPos>0,cnFiscal:=aCabNota[2][nPos],"")

			lSerie2     := (((SF2->(FieldPos("F2_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (aCfgNf[ScEspecie]$"NCE|NCP")) .or. (cPaisLoc == "COL" .and. aCfgNf[SAliasHead] == "SF2" )); // Determina o uso do campo F2_SERIE2 para o Peru
						.Or. ((SF1->(FieldPos("F1_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (Trim(aCfgNf[ScEspecie])$"NF|NDP|NDE") .And. !aCfgNf[SlFormProp])
			//³Para o Peru pode-se utilizar o campo especifico para serie com 4 digitos caso ³
			//³se tratar de Notas de Credito(NCE/NCP) - Nota de Debito (NDP/NDE) 	         |
			//|Factura de Entrada (NF) que nao utilizem formulario proprio.

			If cPaisLoc == "PER"
				cSerie := LxSer2Per(cAliasC, aCabNota, cSerie, lSerie2)
			ElseIf cPaisLoc == "COL"
				cSerie := LxSer2Col(cAliasC, aCabNota, cSerie, lSerie2)
			Else
				nPos := Ascan(aCabNota[1],{ |x| UPPER(x) == AllTrim(PrefixoCpo(cAliasC)+"_SERIE") } )
				IIf(nPos>0,cSerie:=aCabNota[2][nPos],"")
			EndIf
			//cEspecie
			nPos := Ascan(aCabNota[1], AllTrim(PrefixoCpo(cAliasC)+"_ESPECIE"))
			IIf(nPos>0,cEspecie:=aCabNota[2][nPos],"")
			//cCondicao
			nPos := Ascan(aCabNota[1], AllTrim(PrefixoCpo(cAliasC)+"_COND"))
			IIf(nPos>0,cCondicao:=aCabNota[2][nPos],"")
			//cCliFor
			nPos := Ascan(aCabNota[1], IIf(cAliasC=="SF1","F1_FORNECE","F2_CLIENTE"))
			IIf(nPos>0,cCliFor:=aCabNota[2][nPos],"")
			//cLoja
			nPos := Ascan(aCabNota[1], AllTrim(PrefixoCpo(cAliasC)+"_LOJA"))
			IIf(nPos>0,cLoja:=aCabNota[2][nPos],"")
			//Verifica se corres´ponde informa condicao de pagamento e esta nao foi informada
			If lRet .AND. !(l103Class.AND.lEicFinanc) .AND. Empty(cCondicao) .AND. !Empty(aCfgNf[ScOpFin]) .AND. MaFisRet(,'NF_BASEDUP') > 0
				SX3->(DbSetOrder(2))
				SX3->(MsSeek(AllTrim(PrefixoCpo(cAliasC)+"_COND")))
				Aviso(STR0038,STR0075+X3Titulo(AllTrim(PrefixoCpo(cAliasC)+"_COND")),{STR0021})				 //"ATENCAO!"###"Preencha o campo de cabecalho : "###"OK"
				lRet	:=	.F.
			Endif
			//³Verfica vendedores³
			If lRet .AND. cAliasC == "SF2"
				nVend := Fa440CntVen()
				nI := 0
				For nI := 1 to nVend
					cVendedor := &("SF2->F2_VEND"+AllTrim(Str(nVend)))
					If !ValidVend()
						Aviso(STR0038,STR0039+"("+cVendedor+")",{"OK"}) //"ATENCAO!"###"Codigo do vendedor invalido!"
						lRet := .F.
					EndIf
				Next nI
				//³Trava SB2 e SA1 ou SA2 para validar estoque e Credito
				If lRet .AND. LocxTrava(aCpItens,aCItens)
					lRet:=LocXAvStok(aCpItens,aCItens)
					If lRet .AND. aCfgNF[ScCliFor] == "SA1" .AND. aCfgNF[ScOpFin] == "+"
					   lRet:=LocXAvCred(aCpItens,aCItens)
					Endif
					If !lRet
						SB2->(MsUnLock())
						SA1->(MsUnLock())
						SA2->(MsUnLock())
					Endif
				Endif
				//Validacoes de Adiantamento => Mexico
				If lRet .AND. cPaisLoc  $ "MEX"	.AND. (aCfgNf[SnTipo] == 1 .OR. aCfgNf[SnTipo] == 19)
					lRet := LxTudOkMex(aCfgNf[ScTipoDoc],cAliasI,aCpItens,aCItens,cNatureza,cCondicao,aRecnoSE1)
				EndIf
				//³Verifica se o usuário inclui o Adiantamento necesário para³
				//³gerar a Nota quando utilizou uma Cond.Pagto c/Adiant
				If 	lRet 							.AND.;
					StrZero(aCfgNf[SnTipo],2)=="01"	.AND.;
					cPaisLoc $ "ANG"			.AND.;
				 	A410UsaAdi( cCondicao )
					While(.T.)
						nValAdt := 0
						lRet := .F.
						For nI := 1 To Len(aRecnoSE1)
							If Len(aRecnoSE1[nI]) > 3
								//Desconsidera itens apagados
								If !aCols[aRecnoSE1[nI][4]][Len(aCols[aRecnoSE1[nI][4]])]
									nValAdt += aRecnoSE1[nI][3]
								EndIf
							Else
								nValAdt += aRecnoSE1[nI][3]
							EndIf
						Next nI

						If cPaisLoc == "ANG"
							nValRelAdt := DesTrans(Extrae(aDupl[1],5))
						EndIf
						If (cPaisLoc == "ANG" .AND. nValAdt == nValRelAdt)
							lRet := .T.
							Exit
						Else
							If MsgYesNo( STR0262 ) // "O valor do adiant. não é suficiente para geração da NF. Deseja incluir agora?"
								A410Adiant(M->F2_DOC, cCondicao, nValRelAdt, @aRecnoSE1, .F., M->F2_CLIENTE, M->F2_LOJA,NIL,NIL,NIL,NIL,cNatureza)
							Else
								Exit
							EndIf
						EndIf
					Enddo
				EndIf
			Endif
			//³Valida Doc./Serie em outras filiais p/ oper.de Transf.Suc.³
			If Str(aCfgNF[SnTipo],2)$"54|64" .And. aNumTRFNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie,aCabNotaOri)
			    lRet:=.F.
			EndIf
			//³Validacoes de existencia da nota³
			If lRet .AND. !l103Class
				cNumAnt:= cnFiscal
				lExisteFin := !aDupNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,aCfgNF[ScEspecie],aDupli)
				lExiste    := !aNumNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie)
				If  lExiste .OR. lExisteFin
					If lFormP
						While lExiste .OR. lExisteFin
							cNFiscal := Soma1(cNFiscal)
							lExiste    := !aNumNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie)
							lExisteFin := !aDupNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,aCfgNF[ScEspecie],aDupli,.F.)
						EndDo
					Else
						cSerie:= Subs((Alltrim(cSerie)+cEspecie),1,TamSX3("F1_SERIE")[1])
						While lExiste .OR. lExisteFin
							lExiste    := !aNumNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie)
							lExisteFin := !aDupNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,aCfgNF[ScEspecie],aDupli,.F.)
							If  lExiste .OR. lExisteFin
								cSerie := Soma1(cSerie)
							EndIf
						EndDo
						If lExiste
							Aviso(STR0018,STR0092+"("+cNumAnt+" / "+cSerie+") " +STR0068 ,{STR0021}) //"ATENCAO"###"Documento no."### "ja existe "###"OK"
						EndIf
						lRet:= .f.
					Endif
					If cNumAnt <> cNFiscal
						If nAltera == 1
						   MsgInfo(STR0089 + cNumAnt + STR0090 + cNFiscal, STR0091)  //  " O Numero do Documento foi alterado de: " ### " para: " ### " Numero"
						ElseIf nAltera == 2
							lRet:= MsgYesNo(STR0092 + cNumAnt +  STR0093 + cNFiscal  )  // " O documento no.: "  ###" ja existe, confirma alteracao da numeracao para: "
						Else
							Aviso(STR0018,STR0047+"("+cNumAnt+" / "+cSerie+")",{STR0021}) //"ATENCAO"###"Verifique a numeracao da NF! Esta Nota ja existe."###"OK"
							lRet:= .f.
						EndIf
						If lRet  // Nao tirar pois e necessario acertar o numero nos itens da NF ( Validacao)
					    	nNF     := Ascan(aCpItens, {|x| Trim(x) == PrefixoCpo(cAliasI)+"_DOC"})
							If nNF > 0
								For nI := 1 to Len(aCItens)
	   					  			aCItens[nI][nNF] 		:= cNFiscal
   								Next
							Endif
					    	nNF     := Ascan(aCpItensOri, {|x| Trim(x) == PrefixoCpo(cAliasI)+"_DOC"})
							If nNF > 0
								For nI := 1 to Len(aCItensOri)
						  			aCItensOri[nI][nNF] 	:= cNFiscal
	 							Next
							Endif
							nNF						:= Ascan(aCabNotaOri[1],PrefixoCpo(aCfgNf[SAliasHead])+ "_DOC")
							aCabNotaOri[2][nNF] 	:= cNFiscal
							aCabNota[2][nNF] 		:= cNFiscal
   						Else
							cnFiscal:= cNumAnt
						EndIf
					EndIf
				EndIf
				/*If cPaisLoc == "PTG" .And. lHashPTG .And. !lExiste .And. !(Str(aCfgNF[SnTipo],2)$"50|55") .And. aCfgNF[SlFormProp]
					cPe :=  LocxPE(50)
					If lRet .And. !Empty(cPE)
						lHashPTG := ExecBlock(cPE,.F.,.F.)
					Endif
				EndIf*/
				If cPaisLoc == "BOL"
					AtuNumNF(cNFiscal,cSerie)
				EndIf
			EndIf
			If lRet .and. cPaisLoc $ "VEN" .And. Valtype(aCfgNF[SlFormProp]) == "L" .And. aCfgNF[SlFormProp] .And. (!Str(aCfgNF[SnTipo],2)$"54|64|50|60") .And. GetNewPar("MV_CTRLFOL",.F.)
				lRet := CtrFolios(cFilAnt,cSerie,cEspecie,cnFiscal)
			EndIf

			//³ Verifica a natureza ³
			If lRet .AND. MaFisRet(,"NF_BASEDUP") > 0 .AND. Empty(MaFisRet(,"NF_NATUREZA")) .AND. cTipDoc <> "D"  .AND. cAliasC == "SF1" .And. !aCfgNf[SlRemito] .And. !(cPaisLoc $ "PER")
				If cPaisLoc == "MEX"
					lRet := xVldNatMex(aCfgNf, @cNatureza, cAliasI, aCpItens, aCItens)
				Else
					If !Empty(M->F1_NATUREZ)
						MaFisAlt("NF_NATUREZA",M->F1_NATUREZ)
						cNatureza:=M->F1_NATUREZ
					EndIf
				EndIf
				If GetNewPar("MV_NFENAT",.F.) .And. Empty(MaFisRet(,"NF_NATUREZA"))
					Aviso(STR0018,STR0040,{STR0021}) //"Preencha o codigo da natureza!"###"OK"
					lRet := .F.
				EndIf
			EndIf

			if AllTrim(FunName()) <> "MATA447"
				//Validacoes de Adiantamento => Mexico
				if lRet .AND. cAliasC == "SF1"
					If lRet .AND. cPaisLoc $ "MEX"	.AND. (aCfgNf[SnTipo] == 10 .OR. aCfgNf[SnTipo] == 20 )
						If ValType(cNatureza) = "U"
							cNatureza := M->F1_NATUREZ
						EndIf
						lRet := LxTudOkMex(aCfgNf[ScTipoDoc],cAliasI,aCpItens,aCItens,cNatureza,cCondicao,aRecnoSE1)
					EndIf
				endif
			Endif

			//³Verifica preenchimento do grupo de depositos se for remito de transf. e o retorno for automatico.³
			If aCfgNf[SlRemito] .AND. aCfgNf[SnTipo] == 54 .AND. Type("M->F2_TIPORET")=='C' .AND. M->F2_TIPORET == '1' .AND. Empty(M->F2_GRPDEP)
				Aviso(STR0018,STR0173,{STR0021}) //"ATENCAO"###"O Grupo de Almoxarifados deve ser Informado"###"OK"
			Endif

			//³Verifica preenchimento da condicao de pagamento quando nao for uma devolucao³
			If lRet .AND. !l103Class .AND. !Empty(aCfgNF[ScOpFin]).AND. MaFisRet(,"NF_BASEDUP") > 0 .AND. Empty(cCondicao) .AND. cTipo<>"D"
				Aviso(STR0018,STR0041,{STR0021}) //"Preencha a condicao de pagamento!"###"OK"
				lRet := .F.
			EndIf
			//³Para o Peru quando utilizar o campo especifico para serie com 4 digitos ³
			//³nao verifica numeracao dos itens da NF.
	        If !(cPaisLoc $ "PER|COL|")
				//³Verificando numeracao da NF em todos os itens
	        	nSerie	:= Ascan(aCpItens, {|x| Trim(x) == PrefixoCpo(cAliasI)+"_SERIE"})
	        	nNF		:= Ascan(aCpItens, {|x| Trim(x) == PrefixoCpo(cAliasI)+"_DOC"})
				For nI := 1 to Len(aCitens)
	    			If !aCitens[nI][Len(aCitens[nI])] .AND. aCitens[nI][nNF] != cNFiscal .OR. aCitens[nI][nSerie] != cSerie
						Aviso(STR0018,STR0042+"("+cnFiscal+"-"+cSerie+"/"+aCitens[nI][nNF]+"-"+aCitens[nI][nSerie]+")",{STR0021})					    			 //"ATENCAO"###"Inconsistencias com a numeracao da NF em relacao a seus itens"###"OK"
						lRet := .F.
						Loop
	    			EndIf
				Next nI
			EndIf
			// Valida que exista informacion de los titulos cuando la condicion de pago es informada
			If lRet .AND. !l103Class .AND. !Empty(aCfgNf[ScOpFin]) .AND. Len(aDupl) > 0 .AND. MaFisRet(,"NF_BASEDUP") > 0 .AND. cPaisLoc $ "ARG|PAR" .AND. IIF(cPaisLoc == "ARG", DesTrans(Extrae(aDupl[1],5))==0, Val(Alltrim(Extrae(aDupl[1],5)))==0)
				Aviso(STR0018,STR0057,{STR0021}) //"ATENCAO"### "Inconsistencias nos valores financeiros"###"OK"
				lRet	:= .F.
			EndIf
			//Controla se o valor total das duplicatas bate com o total
			If lRet .AND. !l103Class .AND. !Empty(aCfgNf[ScOpFin]) .AND. Len(aDupli) > 0 .and. IIF(cPaisLoc $ "ARG|PAR",Val(Substr(aDupli[1],rat("³",aDupli[1])+1,len(aDupli[1])))>0,.T.) .And. !(cPaisLoc $ "BOL|CHI|URU")  // O sistema gera uma estrutura vazia para duplicata.
				For nI := 1 To Len(aDupli)
					nTotDup += DesTrans(Extrae(aDupli[nI],5,Iif(cPaisLoc != 'RUS',,CHR(124))))
				Next nI
				If lRet
					//Ajuste para permitir el valor financiero con impuestos provisionales del MATA462N y MATA462AN
					If cPaisLoc <> "EUA"
						If Abs(xMoeda(MaFisRet(,"NF_BASEDUP"),nMoedaNF,nMoedaCor,dDataBase,,nTaxa) - nTotDup) > SuperGetMV("MV_LIMPAG")
							Aviso(STR0018,STR0057,{STR0021})				 //"ATENCAO"### "Inconsistencias nos valores financeiros"###"OK"
							lRet	:= .F.
						EndIf
					EndIf
				EndIf
			Endif
			//Verifica se o total da NF esta' negativo devido ao vlr.desconto
			If xMoeda(MaFisRet(,"NF_TOTAL"),nMoedaNF,nMoedaCor,dDataBase,,nTaxa) < 0
				Help("  ",1,'TOTAL')
				lRet := .F.
			EndIf

			//Verifica se o valor informado para o Imposto Selo nao eh maior que o valor da factura
			//#PORTUGAL#
			/*If lRet .AND. cPaisLoc == "PTG" .And. cAliasC == "SF1"
				If M->F1_IMPSELO > Abs(xMoeda(MaFisRet(,"NF_TOTAL"),nMoedaNF,nMoedaCor,dDataBase,,nTaxa))
					Aviso(STR0018,STR0252,{STR0021}) //"ATENCAO"###"O valor informado para o Imposto Selo é  maior que o total da NF"###"OK"
					lRet := .F.
				EndIf
			EndIf*/

			//Consistencias para Formulario Proprio
			If lRet .AND. lFormP .AND. !l103Class
				//Verifica a numeracao e serie da Nota de acordo com o tipo de cliente quando for Argentina
				If cAliasCF == "SA1"
					SA1->(DBSetOrder(1))
					If !SA1->(MSSeek(xFilial("SA1")+cCliFor+cLoja))
		 				Aviso(STR0018,STR0045+"("+cCliFor+"/"+cLoja+")",{STR0021})
		 				lRet := .F.
					EndIf
				EndIf
				//Verifica numero de itens
				If	lRet .AND. (cModulo=="FIS")
					If Len(aCitens) > a460NumIt(cSerie)
						Aviso(STR0018,STR0046+"("+AllTrim(Str(Len(aCitens)))+")",{STR0021})
						lRet := .F.
					EndIf
				EndIf
			EndIf
			//Verifica validacao do controle de multinatureza
			If lRet .And. ((SuperGetMv("MV_MULNATP") .AND. aCfgNf[ScAliasFin] == "SE2" .And. MaFisRet(,"NF_BASEDUP")>0) .OR. (SuperGetMv("MV_MULNATR") .AND. aCfgNf[ScAliasFin] == "SE1" .and. MaFisRet(,"NF_BASEDUP")>0))
				If cPaisLoc <> "BRA"
					lRet := lContSEV
				Else
					lRet := LxVldSEV()
				Endif

			EndIf
			//Verifica a Tolerancia de Qtde e Preco do pedido
			If (aCfgNF[SAliasHead]=="SF1") .AND. lRet .AND. !lGeraBlq .AND. lClasBlq ;
			   .AND. ( nPosPc  >0 ) .AND. ( nPosItPc>0 ) .AND. ( nPosQtd>0 ) .AND. ( nPosVlr>0 ) ;
			   .AND. ( nPosProd>0 ) .AND. ( nPosItem>0 )
				For nX := 1 to Len(aCItens)
					//Verifica se a linha nao esta deletada
					If aCitens[nX][Len(aCitens[nX])]
						Loop
					EndIf
					Do Case
						Case If ( nPosRmt>0, !Empty(aCItens[nx][nPosRmt]), .F. ) .AND. ( nPosRSer>0 )
							//³Compara Qtde em relacao ao Remito  e Vlr em relacao ao Remito ou Pedido ³
							DbSelectArea("SD1")
							DbSetOrder(1)
							SF1->(MSSeek(cFilSF1+aCItens[nX][nPosRmt]))
							SD1->(MSSeek(cFilSD1+aCItens[nX][nPosRmt]+aCItens[nX][nPosRSer]+M->F1_FORNECE+M->F1_LOJA+aCItens[nX][nPosProd]+aCItens[nX][nPosItemR]))
							If Found()
								lGeraBlq := MaAvalToler(SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_COD, aCItens[nX][nPosQtd], SD1->D1_QUANT, aCItens[nX][nPosVlr], SD1->D1_VUNIT, .F., .T., .F., .F.,.F.)[1]
								If lGeraBlq
									Help(" ",1,"QTDLIBMAI")
								Endif
								If !lGeraBlq .AND. !Empty(aCItens[nx][nPosVlr])
									If !Empty(SD1->D1_VUNIT)
										lGeraBlq := MaAvalToler(SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_COD, aCItens[nX][nPosQtd], SD1->D1_QUANT, aCItens[nX][nPosVlr], SD1->D1_VUNIT, .F., .F., .T., .F.,.F.)[1]
									Else
										DbSelectArea("SC7")
										If ( nPosGrade > 0 .And. aCItens[nX][nPosGrade] == "S" ) .And.;
										( nPosItGrd > 0 .And. !Empty(aCItens[nX][nPosItGrd]) )
											DbSetOrder(4)
											SC7->(MsSeek(cFilSC7+aCItens[nX][nPosProd]+aCItens[nX][nPosPc]+aCItens[nX][nPosItPc]))
										Else
											DbSetOrder(1)
											SC7->(MsSeek(cFilSC7+aCItens[nX][nPosPc]+aCItens[nX][nPosItPc]))
										EndIf
										If Found()
											lGeraBlq := MaAvalToler(SC7->C7_FORNECE, SC7->C7_LOJA, SC7->C7_PRODUTO, aCItens[nX][nPosQtd]+SC7->C7_QUJE+SC7->C7_QTDACLA-IIf(l103Class,SD1->D1_QUANT,0), SC7->C7_QUANT, aCItens[nX][nPosVlr], SC7->C7_PRECO, .F., .F., .T., .F.,.T.)[1]
										Endif
									Endif
									If lGeraBlq
										Help(" ",1,"PRCLIBMAI")
									Endif
									If !lgeraBlq
										lGeraBlq := MaAvalToler(SC7->C7_FORNECE, SC7->C7_LOJA, SC7->C7_PRODUTO, aCItens[nX][nPosQtd]+SC7->C7_QUJE+SC7->C7_QTDACLA-IIf(l103Class,SD1->D1_QUANT,0), SC7->C7_QUANT, aCItens[nX][nPosVlr], SC7->C7_PRECO, .F., .F., .F., .T.,.T.)[1]
										If lGeraBlq
											Help(" ",1,"DATLIBMAI")
										Endif
									Endif
								Endif
							Endif
						Case !Empty(aCItens[nx][nPosPc])
							//³Compara Qtde e Vlr em relacao ao Pedido³
							DbSelectArea("SC7")
							If ( nPosGrade > 0 .And. aCItens[nX][nPosGrade] == "S" ) .And.;
							( nPosItGrd > 0 .And. !Empty(aCItens[nX][nPosItGrd]) )
								DbSetOrder(4)
								SC7->(MsSeek(cFilSC7+aCItens[nX][nPosProd]+aCItens[nX][nPosPc]+aCItens[nX][nPosItPc]))
							Else
								DbSetOrder(1)
								SC7->(MsSeek(cFilSC7+aCItens[nX][nPosPc]+aCItens[nX][nPosItPc]))
							EndIf
							If Found()
								lGeraBlq := MaAvalToler(SC7->C7_FORNECE, SC7->C7_LOJA, SC7->C7_PRODUTO, aCItens[nX][nPosQtd]+SC7->C7_QUJE+SC7->C7_QTDACLA, SC7->C7_QUANT, aCItens[nX][nPosVlr], SC7->C7_PRECO, .F., .T., .F., .F.,.T.)[1]
								If lGeraBlq
									Help(" ",1,"QTDLIBMAI")
								Endif
								If !lGeraBlq .AND. !Empty(aCItens[nx][nPosVlr])
									lGeraBlq := MaAvalToler(SC7->C7_FORNECE, SC7->C7_LOJA, SC7->C7_PRODUTO, aCItens[nX][nPosQtd]+SC7->C7_QUJE+SC7->C7_QTDACLA, SC7->C7_QUANT, aCItens[nX][nPosVlr], SC7->C7_PRECO, .F., .F., .T., .F.,.T.)[1]
									If lGeraBlq
										Help(" ",1,"PRCLIBMAI")
									Endif
								Endif
								If !lGeraBlq
									lGeraBlq := MaAvalToler(SC7->C7_FORNECE, SC7->C7_LOJA, SC7->C7_PRODUTO, aCItens[nX][nPosQtd]+SC7->C7_QUJE+SC7->C7_QTDACLA, SC7->C7_QUANT, aCItens[nX][nPosVlr], SC7->C7_PRECO, .F., .F., .F., .T.,.T.)[1]
									If lGeraBlq
										Help(" ",1,"DATLIBMAI")
									Endif
								Endif
							Endif
					EndCase
					If lGeraBlq
						Exit
					Endif
				Next nX
			EndIf
			//Valida IVA Adquirente
			//#PORTUGAL#
			/*If lRet .And. cPaisLoc=="PTG"
				lRet := ValidaIvaAdq(aCabNota)
			EndIf*/
		EndIf //lRet (3)
	EndIf //lRet (2)
EndIf //lRet (1)

If lRet .and. cPaisLoc == "ARG"
	lRet := TudoOkArg(cAliasC,cAliasI,cAliasCF,aCabNotaOri,aCpItensOri,aCitensOri,nLinha,cTipDoc,lFormP,aGetsTela,lTela,aCfgNF,nMoedaNF,nMoedaCor,nTaxa,cNFiscal,cSerie)
EndIf
If lRet .And. cPaisLoc == "COL"
	lRet := NfTudOkCol(cAliasI, cSerie, aCfgNF, aCitens, aCpItens, cFilAnt, cEspecie, cnFiscal, cFunName)
EndIf
If lRet .And. cPaisLoc == "PER"
	lRet := NfTudOkPer(cFunName, aCfgNf, cAliasC, cAliasI, aCpItens, aCItens, @cNatureza, cCondicao, aRecnoSE1, cnFiscal, cSerie, cEspecie, cTipDoc, cFilAnt)
EndIf
If lRet .And. cPaisLoc == "EQU"
	lRet := NfTudOkEqu(nNFTipo, cAliasC, cAliasCF, IIf(Type('cFormCrbo') <> 'U', cFormCrbo, ""), cNomeCli, cDoctoId, aCItens, aCpItens, aCfgNf, IIf(Type('aLlaveOrg') <> 'U', aLlaveOrg, {}), cFunname)
EndIf
If lRet .And. cPaisLoc == "BOL"
	lRet := NfTudOkBol(aCfgNf, aDupli, MaFisRet(,"NF_BASEDUP"), nMoedaNF, nMoedaCor, nTaxa, l103Class, cFunName)
EndIf
If lRet .And. cPaisLoc == "URU"
	lRet := NfTudOkUru(aCfgNf, aDupli, MaFisRet(,"NF_BASEDUP"), nMoedaNF, nMoedaCor, nTaxa, l103Class, cFunName)
EndIf
If lRet .And. cPaisLoc == "CHI"
	lRet := NfTudOkChi(aCfgNf, aDupli, MaFisRet(,"NF_BASEDUP"), nMoedaNF, nMoedaCor, nTaxa, l103Class, cCxCaixa, @nCxValor, cFunName)
EndIf
If lRet .And. cPaisLoc == "EUA"
	lRet := NfTudOkEUA(aCfgNf, cFunName)
EndIf
//³Valida se o numero esta homologado pela SAT
If lRet .AND. cPaisLoc == "GUA"
   lRet  := LocxNumSAT(cSerie,cNFiscal)
   //³ A gravacao do motivo da devolucao eh Obrigatoriedade fiscal - Loc. Guatemala
   //³ Nao deve considerar as Notas de envio(remitos)
   If lRet .AND. aCfgNf[ScTipoDoc] == "D" .AND. aCfgNF[SnTipo] < 10 .AND. ;
      (Type("lLocxAuto") == "U" .OR. !lLocxAuto )
      lRet  := LocxMotDev()
   EndIf
EndIf

//³Ponto de Entrada para incluir consistencias do tudok³
cPe	:=	LocxPE(16)
If lRet .AND. !Empty(cPE)
	lRet:=ExecBlock(cPE,.F.,.F.)
Endif

//   .: Integracao PMS :.
// Deleta em aRatAFN os itens
// correspondentes que foram
// deletados da NF (Denardi)
If lRet .AND. IntePms()
	For nI := 1 To Len(aCitens)
		If aCitens[nI][Len(aCitens[nI])] // Item Deletado
			nPosAFN  := Ascan(aRatAFN,{|x|x[1]==(StrZero(nI,4))})
			If nPosAFN >  0
				aDel( aRatAFN, nPosAFN )
				aSize( aRatAFN, Len(aRatAFN)-1)
			Endif
		Endif
	Next nI

	For nI := 1 To Len(aCitens)
		If !aCitens[nI][Len(aCitens[nI])]
			nPosAFN  := Ascan(aRatAFN,{|x|x[1]==aCitens[nI,GdFieldPos("D1_ITEM")]})
			nPPed	  := GdFieldPos("D1_PEDIDO")
			nPItP	  := GdFieldPos("D1_ITEMPC")
			If Len(aHdrAFN) == 0
				aHdrAFN := GetaHeader("AFN",,,,{"AFN_QUANT"})
			Endif
			nPosQtde := Ascan(aHdrAFN,{|x|Alltrim(x[2])=="AFN_QUANT"})
			nTotAFN  := 0
			If (nPosAFN > 0) .AND. (nPosQtde > 0)
				For nX := 1 To Len(aRatAfn[nPosAFN][2])
					If !aRatAFN[nPosAFN][2][nX][LEN(aRatAFN[nPosAFN][2][nX])]
						nTotAFN	+= aRatAfn[nPosAFN][2][nX][nPosQtde]
					Endif
				Next nX
				If nPPed > 0 .And. nPItP > 0
					If !PMSNFSA(aCitens[nI][nPPed],aCitens[nI][nPItP])[1]
						If nTotAFN > aCitens[nI][GdFieldPos("D1_QUANT")]
							Help("   ",1,"PMSQTNF")
							lRet := .F.
							Exit
						Endif
					Endif
				Endif
			Endif
		Endif
	Next nI
Endif
//Tirar o foco do campo selecionao para que nao se valide novamente quando se MATA o objeto DIALOG principal
If lRet .AND. Type("oBSomaItens")=="O" .AND. aCfgNf[SnTipo] <> 64
	oBSomaItens:SetFocus()
Endif
If lGeraBlq
	lRet := .F.
Endif

//Verifica se existe bloqueio contábil
If !(Empty(M->F1_EMISSAO)) .And. cAliasC <> "SF2"
	dDataRef := M->F1_EMISSAO
ElseIf !(Empty(M->F2_EMISSAO))  .And. cAliasC == "SF2"
	dDataRef := M->F2_EMISSAO
EndIf

If lRet .And. !(Empty(dDataRef)) .And. (lRet := CtbValiDt(Nil,dDataRef,/*.T.*/ ,Nil ,Nil ,{"COM001"}/*,"Data de apuração bloqueada pelo calendário contábil."*/))
	If!Empty(dDataBloq) .AND. (dDataRef <= dDataBloq)
		Help(" ",1,"ATFCTBBLQ") //P: Processo bloqueado pelo Calendário Contábil ou parâmetro de bloqueio nesta data ou período. S: Caso possível altere a data de referência do processo, verifique o parâmetro ou contate o responsável pelo Módulo Contábil.)
		lRet := .F.
	End
EndIf

//Validação da integração do ativo fixo com as notas de crédito e débito, para ajuste no valor do bem.
If lRet .And. lIntNtCRDB .And. cEspecie $ "NDP|NCI|NCP|NDI"
	lRet := A103VLNCD( cAliasI, aCpItens, aCItens )
EndIf

// Caixinha deve ser a ultima validacao
If lRet .And. Type("cCxCaixa")!="U" .And. Type("nCxValor")!="U" .And. !Empty(cCxCaixa)
	If !Empty(nCxValor)
		lRet := NFVldCxa(3,cCxBenef,nCxValor,cCxCaixa,cCxAdian,cCxHistor,If(Type("cCxRendic")!="U",cCxRendic,""))
	Endif
EndIf

If lRet .And. cPaisLoc == "ANG" .And. A120UsaAdi(cCondicao).And. cTipDoc == "N"
	SC7->(DbSetOrder(1))
	For nX:=1 to len(aCols)
	    If aCols[nX][len(aCols[nX])] == .F. .And. aScan(aPedido,{|x| x == aCols[nX][nPosPc]}) <= 0
	    	aAdd(aPedido,aCols[nX][nPosPc])
	    EndIf
		If SC7->(MsSeek(xFilial("SC7")+aCols[nX][nPosPc]+aCols[nX][nPosItPc]))
			aAdd(aRecSC7,SC7->(Recno()))
		EndIf
	Next
	If !Empty(aPedido)
		lRet := a101NAdian(aPedido, cCondicao, aRecSC7, SC7->C7_FORNECE, SC7->C7_LOJA, nTotDup)
	EndIf
EndIf

If lRet
	//³Bloqueia Pedidos Amarrados ao Processo ³
	If Type("aRegsLock")<>"U"
		cPe	:=LocxPE(70)
		If !Empty(cPE)
			lBlockPed:=	ExecBlock(cPe,.F.,.F.,{})
		Endif
		If lBlockPed
			If !PedidoLock(aCitens,aCpItens)
				Aviso(STR0018,STR0290,{STR0021})
				lret:=.F.
			EndIf
		EndIf
	EndIf
EndIf

If lRet .And. cPaisLoc == "MEX"
	lRet := NfTudOkMex(aCfgNf, aCpItens, aCitens, nLinha, nNFTipo, cAliasC, nItemSrv, lGerarCFD, OAPP, cFilAnt, cSerie, cnFiscal, cEspecie, aCabNotaOri, aCabNota, cFunName)
EndIf

If lRet .And. cPaisLoc $ "MEX|COL|PER|EQU" .And. SuperGetMV("MV_PCOINTE", .F., "2") == "1"
	PcoLancto(aCfgNf[SAliasHead],aCfgNf[SAliasCols],,,aCfgNf[SaLancPCO][1],aCfgNf[SaLancPCO][2],aCfgNf[SaLancPCO][4],aCfgNf[SaLancPCO][3], .T./*lInclui*/, .F./*lDeleta*/, @lRet)
EndIf

If Type("nNumDocNF") <> "U" .And. (cPaisLoc $ "MEX|PER|COL" .And. FunName() == "ATFA036") .Or. (cPaisLoc == "ARG" .And. (FunName() $ "FINA935|FINA846|FISA828" .OR. IsInCallStack("F935GeraNF") .Or. IsInCallStack("FINA998")))
	nNumDocNF := cNFiscal
EndIf

RestArea(aArea)
RestArea(aAreaC)
Return lRet

/*
±±³Fun‡…o    ³ExecTotal      ³ Autor ³ Leandro C. G.      ³ Data ³06/12/2001³±±
±±³Descri‡…o ³Efetua o calculo para campos de um arquivo de cabecalho a     ³±±
±±³			 ³partir dos dados de seus itens							    ³±±
±±³ Uso      ³ EXECTOTAL												    ³±±
param.
cTotaliz	- formula utilizada para conteudo totalizador Ex.: M->D1_TOTAL
aCpos		- nome dos campos referentes aos itens (aHeader[2])
aItens		- Dados dos itens de onde deve ser executada a formula. A formula e executada para cada item
  			somando-se o novo conteudo com o conteudo anterior */
Function ExecTotal(cTotaliz,aCpos,aItens)
Local 	nResult := 0
Local 	nI		:= 0
Default aItens 	:= {}

If Empty(aCpos) .OR. Empty(aItens)
	Return(nResult)
EndIf
nI := 0
For nI := 1 to Len(aItens)
	//³Verifica se a linha nao esta deletada³
	If ValType(aItens[nI][Len(aItens[nI])]) == "L" .AND. aItens[nI][Len(aItens[nI])]
		Loop
	EndIf
	//³Atribui valor dos campos em variaveis de memoria³
	Aeval(aCpos, { |x,y| IIf(x!=NIL,&("M->"+x):=If(ValType(aItens[nI][y])!="A",aItens[nI][y],NIL),) })
	//³Executa totalizador³
	nResult	+= &cTotaliz
Next nI
Return(nResult)

/*
±±³Fun‡…o    ³ExecFormula    ³ Autor ³ Leandro C. G.      ³ Data ³07/12/2001³±±
±±³Descri‡…o ³Efetua o uma formula a partir de dados de um array ou nao 	³±±
±±³ Uso      ³ GENERICO 												    ³±±
param.
cFormula	- formula utilizada para conteudo
aCpos		- nome dos campos serao carregados em memoria antes de executar a formula
aItens		- conteudo dos campos
lMem		- Flag que indica se os campos devem ser carregados em memoria ou nao
*/
Function ExecFormula(cFormula,aCpos,aDados)
Local xResult
//³Verifica se deve carregar campos em memoria³
If !Empty(aCpos) .AND. !Empty(aDados)
	Asize(aDados, Len(aCpos))
	Aeval(aCpos, { |x,y| If(x!=NIL,&("M->"+x):=If(ValType(aDados[y])!="A",aDados[y],NIL),) })
EndIf
xResult := &cFormula
Return(xResult)

/*
±±³Fun‡…o    ³NfLinOk        ³ Autor ³ Leandro C. G.      ³ Data ³17/12/2001³±±
±±³Descri‡…o ³Efetua validacoes referentes a itens de uma NF     			³±±
param.
cAliasI		- 	Alias de Itens de NF
aCposOri	- campos dos itens (posicoes [2] do aHeader)
cAliasCF	- Indica se e cliente ou fornec. (SA1-Cliente ; SA2-Fornec.)
aItensOri	- conteudo dos itens da NF (aCols) * o conteudo de cada campo pode ser uma formula
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
nLinha		- Indica a linha do aDadosIOri que deve ser validada                          ]
lFormP		- indica se e formulario proprio ou nao

Obs.: no caso de haver apenas um linha a ser consistida em aDadosIOri, a mesma dever ser um array, nao esquecer de que o parametro aDadosIOri deve ter sempre duas dimensoes
*/
Function NfLinOk(cAliasI,aCposIOri,cAliasCF,aDadosIOri,cTipDoc,nLinha,lFormP)
Local nI,nX,nZ		 															//Flag's para Loop's
Local lQtdeZero	:= .F. // Permite qtde maior que Zero, F4_QTDZERO = SIM
Local cCampo   	:= ""															//Nome de campos
//Local cPrefixI 	:= IIf(!Empty(cAliasI),cAliasI+"->"+PrefixoCpo(cAliasI),"")	//Prefixo do alias de itens
Local cPrefDev 	:= ""			 												//Prefixo do alias da Nota Original de uma devolucao
//Local aAux		:= {}															//Array auxiliar
Local aDadosI	:= aClone(aDadosIOri)
Local aCposI	:= aClone(aCposIOri)
//Local lForm		:= .F.															//Indica se algum conteudo refersntes aos campos do parametro aCposI e uma formula
Local lRet		:= .T.															//Indica consistencia da funcao
Local aAuxI	    := IIf(!Empty(aDadosI),aClone(aDadosI),{})				  		//Array auxiliar com o conteudo dos dados
Local nSalvaN   := IIf(Type("n")!="U",n,0)										//Salva linha atual de um possivel aCols que esteja sendo utilizado
Local nQuantAux := 0															//Somatoria das qtdes de uma nota de origem de uma devolucao
//Local nQtdDispD := 0
Local nValaVista,nValDigita
//Local nOrdSB8
//Local lUsaVenc	:= (SuperGetMv('MV_LOTVENC')=='S')
Local cAliasVld	:= ""
Local lVldLocal := .F.
Local nTotLin   := 0
Local lPCNFE	:= GetNewPar( "MV_PCNFE", .F. ) //-- NF tem que ser amarrada a um Pedido de Compra ?
Local cTesPcNf	:= SuperGetMV("MV_TESPCNF") // Tes que nao necessita de pedido de compra amarrado
Local cTesRem	:= ''
//Local nTamTotal := TamSX3("D1_TOTAL")[2]+1
Local lVer116   := .T.
Local lRevProd  := SuperGetMv("MV_REVPROD",.F.,.F.)
Local nRet		:= 0
Local cRvSB5	:= ""
Local cBlqSG5	:= ""
Local cStatus	:= ""
Local cFilSD2	:= xFilial("SD2")
Local cFilSB1	:= xFilial("SB1")
Local cFilSB5	:= xFilial("SB5")
Local cFilSB6	:= xFilial("SB6")
Local cFilSC7	:= xFilial("SC7")
Local cFilSC8	:= xFilial("SC8")
Local cFilSD1	:= xFilial("SD1")
LOCAL cFilSF4	:= xFilial("SF4")
Local cFilSG5	:= xFilial("SG5")
Local lMaAvalPerm	:= .T.
Local lLxDelAdt		:= .T.
LOCAL lFifoOnLine	:= .T.
Local lAvalBlqLoc	:= .T.
Local cCQ 			:= SuperGetMV("MV_CQ",.F.,"98")
Local lLocaliz 	:= SuperGetMV("MV_LOCALIZ")=="S"
//³Posicoes dos campos do array de dados³
Local nPosCod:=nPosSerRem:=nPosUm:=nPosSegUm:=nPosItemPc:=nPosQuant:=nPosVunit:=nPosTotal:=nPosTes				:= 0
Local nPosCFo:=nPosLocal:=nPoslote:=nPosLoteCtl:=nposIdentB6:=nPosOp:=nPosNfOri:=nPosSerOri			:= 0
Local nPosCodvei:=nPosViagem:=nPosCliFor:=nPosLoja:=nPosDtVld:=nPosLocaliz:=nPosSerie	:= 0 //nPosItemOri
Local nPosPedido:=nPosItemPv:=nPosRemito:=nPosItemRem:=nPosEmissao:=nPosNumSer:=nPosEspecie := nPosSequen := 0
Local nPosAFN  := 0
Local nPosQtde := 0
Local nTotAFN  := 0
Local nA	   := 0
Local lRmtdevf := (SuperGetMv("MV_RMTDEVF",.F.,"N")=="S")
Local lTesPeRemi := .F.
Local nPD2_PROJPMS := aScan(aHeader,{|x| AllTrim(x[2])=="D2_PROJPMS"})
Local nPD2_EDTPMS  := aScan(aHeader,{|x| AllTrim(x[2])=="D2_EDTPMS"})
Local nPD2_TASKPMS := aScan(aHeader,{|x| AllTrim(x[2])=="D2_TASKPMS"})
Local aAreaSN1 := {}
Local nPosConta := nPosCC := nPosItCC := nPosCLVL := 0
Local nPosServ  :=0
Local lVerLoca	:=.T.
Local lFactElec	:= !Empty(SuperGetMV("MV_PROVFE", .F., "")) //Facturacion Electronica Activa
Local nPos		:= 0
Local nPosItem	:= 0
Local cCpoUbiP  := ""

//³Variaveis utilizadas em outras funcoes³
Private cA100For
If Type("n")=="U"
	Private n := 0				//numero de cada linha de dados
EndIf
Private cTipo := ""
Private cLoja := ""
//utilizada na funcao a465Qtde
If Type("lCliente") == "U"
	Private lCliente := IIf(!Empty(cAliasCF).AND.cAliasCF=="SA1",.T.,.F.)
EndIf

//³Valores padrao³
Default nLinha  := 0
cPrefdev		:= IIf(cAliasI=="SD1","SD2->D2","SD1->D1")
nPosItem	:= aScan(aHeader,{|x| AllTrim(x[2]) == IIf(cAliasI == "SD2", "D2_ITEM", "D1_ITEM")}) //Posicion de _ITEM

//³Verificando a pos. dos campos que serao utilizados³
nX := 0
For nX := 1 To Len(aCposI)
	cCampo := AllTrim(aCposI[nx])
	Do Case
	Case cCampo == IIf(cAliasI=="SD1","D1_FORNECE","D2_CLIENTE")
		nPosCliFor  := nx
	Case cCampo == PrefixoCpo(cAliasI)+"_LOJA"
		nPosLoja    := nx
	Case cCampo == PrefixoCpo(cAliasI)+'_COD'
		nPosCod		:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_REVISAO'
		nRevisao	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_UM'
		nPosUm		:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_SEGUM'
		nPosSegUM	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_PEDIDO'
		nPosPedido	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_ITEMPC'
		nPosItemPC	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_QUANT'
		nPosQuant	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+IIf(cAliasI=="SD1","_VUNIT","_PRCVEN")
		nPosVunit	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_TOTAL'
		nPosTotal 	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_TES'
		nPosTes		:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_CF'
		nPosCFO		:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_LOCAL'
		nPosLocal	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_NUMLOTE'
		nPosLote	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_LOTECTL'
		nPosLoteCtl	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_IDENTB6'
		nPosIdentB6	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_OP'
		nPosOP		:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_NFORI'
		nPosNFOri	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_SERIORI'
		nPosSerOri	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_ITEMORI'
		nPosItmOri	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_CODVEI'
		nPosCodVei	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+'_VIAGEM'
		nPosViagem	:= nx
	Case cCampo == PrefixoCpo(cAliasI)+"_DTVALID"
		nPosDtVld	:=	nX
	Case cCampo == PrefixoCpo(cAliasI)+"_LOCALIZ"
		nPosLocaliz := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_NUMSERI"
		nPosNumSer  := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_SERIE"
		nPosSerie   := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_SERIREM"
		nPosSerRem   := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_ITEMPV"
		nPosItemPv  := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_REMITO"
		nPosRemito  := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_TPDCENV"
		nPosTPDCENV := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_ITEMREM"
		nPosItemRem := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_EMISSAO"
		nPosEmissao := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_SEQUEN"
		nPosSequen := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_ESPECIE"
		nPosEspecie := nX
	Case cCampo == PrefixoCpo(cAliasI)+"_CONTA"
		nPosConta 	:= nX
	Case cCampo == PrefixoCpo(cAliasI)+IIf(cAliasI=="SD2","_CCUSTO","_CC")
		nPosCC	  	:= nX
	Case cCampo == PrefixoCpo(cAliasI)+IIf(cAliasI=="SD2","_ITEMCC","_ITEMCTA")
		nPosItCC  	:= nX
	Case cCampo == PrefixoCpo(cAliasI)+"_CLVL"
		nPosCLVL  	:= nX
	Case cCampo == PrefixoCpo(cAliasI)+"_SERVIC"
		nPosServ  	:= nX
	EndCase
Next nx

//Varrendo todos os itens
nI := 0
For nI := IIf(nLinha>0,nLinha,1) to IIf(nLinha>0,nLinha,Len(aDadosI))
	nQuantAux := 0
	//Verifica se a linha nao esta deletada
	If aDadosI[nI][Len(aDadosI[nI])]
		//Se a linha for deletada. Desvincula Titulos de Adiantamento Relacionados
		If cPaisLoc  $ "MEX|PER" .AND. lLxDelAdt
			LxDelAdt(nI, aCols, aRecnoSE1, N, aHeader, IIf(Type("bDoRefresh") != "U",bDoRefresh,Nil), IIf(Type("bListRefresh") != "U",bListRefresh,Nil))
		EndIf
		Loop
	EndIf
	// verifica se valor unitario e valido
	If lRet .And. nPosVunit > 0 .And. (aDadosI[nI][nPosVunit] < 0)
		Aviso(STR0018,STR0346,{STR0021}) //"Valor unitario nao pode ser negativo."
		lRet := .F.
	EndIf
	//³ Verifica a permissao do armazem. ³
	If  lMaAvalPerm
		lRet := MaAvalPerm(3,{aDadosI[nI][nPosLocal],aDadosI[nI][nPosCod]})
	EndIf
	// Valida qtde com a Integracao PMS
	If lRet .And. IntePms() .AND. Len(aRatAFN)>0
		nPosAFN  := Ascan(aRatAFN,{|x|x[1]==(StrZero(nI,4))})
		If Len(aHdrAFN) == 0
			aHdrAFN := GetaHeader("AFN",,,,{"AFN_QUANT"})
		Endif
		nPosQtde := Ascan(aHdrAFN,{|x|Alltrim(x[2])=="AFN_QUANT"})
		nTotAFN	:= 0
		If (nPosAFN > 0) .AND. (nPosQtde > 0)
			For nA := 1 To Len(aRatAfn[nPosAFN][2])
				If !aRatAFN[nPosAFN][2][nA][LEN(aRatAFN[nPosAFN][2][nA])]
					nTotAFN	+= aRatAfn[nPosAFN][2][nA][nPosQtde]
				Endif
			Next nA

			If nPosPedido > 0 .And. nPosItemPC > 0 .And. nPosQuant > 0
				If !PMSNFSA(aDadosI[nI][nPosPedido],aDadosI[nI][nPosItemPC])[1]
					If nTotAFN > aDadosI[nI][nPosQuant]
						Help("   ",1,"PMSQTNF")
						lRet := .F.
						Exit
					Endif
				Endif
			Endif
		Endif
	Endif
	//Seta variaveis utilizadas por outras funcoes
	n 			:= nI
	cA100For := IIf(nPosCliFor>0.AND.cAliasI=="SD1",aDadosI[IIf(!Empty(nLinha),nLinha,1)][nPosCliFor],"") //codigo do fornec. (usada em rotinas de validacao)
	cLoja		:= IIf(nPosLoja>0,aDadosI[IIf(!Empty(nLinha),nLinha,1)][nPosLoja],"")
	cTipo    := cTipDoc
	//Verifica campos de preenchimento obrigatorio
	If !l103Class
		If lRet .AND. !CposVazio(,cAliasI,cTipDoc,,aCposI,aDadosI[nI])
			lRet := .F.
		EndIf
		//³Efetuando as validacoes genericas³
		//³Permite gravar a nota com qtde zero quando for nota de complemento ou devolução³
		If nPosTes>0 .AND. nPosQuant > 0 .AND.;
			lRet .AND. !MaTesSel(aDadosI[nI][nPosTes]).AND. aDadosI[nI][nPosQuant] <= 0
			Aviso(STR0018,STR0048,{STR0021})
			lRet := .F.
		EndIf
		// Replica chamado TUDCUI - Nao permitir gravar nota com quantidade maior que zero utilizando TES com F4_QTDZERO = Sim
		if cPaisloc=='RUS'
			If lRet .And. nPosTes > 0 .And. nPosQuant > 0 .And. MaTesSel(aDadosI[nI][nPosTes]).And. aDadosI[nI][nPosQuant] > 0
				Aviso(STR0018,STR0048,{STR0021})
				lRet := .F.
			EndIf
		ENDIF
		//³Verifica Preenchimento de Remito e Item de Remito³
		If lRet .AND. ((nPosRemito>0.AND.!Empty(aDadosI[nI][nPosRemito])) .AND. (nPosItemRem==0.OR.Empty(aDadosI[nI][nPosItemRem])) ) .OR.;
			((nPosItemRem>0.AND.!Empty(aDadosI[nI][nPosItemRem])) .AND. (nPosRemito==0.OR.Empty(aDadosI[nI][nPosRemito])))
			Aviso(STR0018,STR0049,{STR0021})
			lRet := .F.
		EndIf
		// NF de Origem
		If lRet .AND. cTipDoc $'PI' .AND. (nPosNfOri==0 .OR. Empty(aDadosI[nI][nPosNFOri]))
			Aviso(STR0018,STR0050,{STR0021})
	   		lRet := .F.
	  	EndIf
	  	// Obriga preenchimento de D2_LOCALIZ qdo fatura nao vier de um pedido
	  	// e o produto tem controle de localiz. pela MV_LOCALIZ = "S" (sempre que
	  	// a qtde nao for zero)
	  	If nPosTes>0 .AND. nPosCod>0 .AND.;
	  		( lRet ) .AND. lLocaliz .AND.;
	  		 &("Val('"+aDadosI[nI][nPosTes]+"') > 500").AND.;
			(nPosQuant > 0	.AND. aDadosI[nI][nPosQuant] > 0) // Alteracao conforme BOPS 66.670
			cAliasVld := Alias()
			DbSelectArea("SB1")
			DbSetOrder(1)
			MsSeek( cFilSB1+aDadosI[nI][nPosCod] )
			lVerLoca:=.T.
			If cPaisLoc=="ARG" .AND. GetMV('MV_INTDL') == 'S' .AND. nPosServ>0 .AND.    !Empty(aDadosI[nI][nPosServ])
				lVerLoca:=.F.
			EndIf
			If ( RetFldProd(SB1->B1_COD,"B1_LOCALIZ") == "S" ) .And. lVerLoca
				If nPosPedido = 0 .AND. nPosLocaliz>0
					If ( Empty(aDadosI[nI][nPosLocaliz]) )
		   				lVldLocal := .T.
		   			Endif
		   		Else
		   			If nPosLocaliz>0 .AND.  nPosPedido >0   .AND. ;
		   				( Empty(aDadosI[nI][nPosPedido]) ) .AND. ( Empty(aDadosI[nI][nPosLocaliz]) )
		   				lVldLocal := .T.
		   			Endif
		   		Endif
		   		If lVldLocal  .And. nPostes >0
					If SF4->(MsSeek(cFilSF4+aDadosI[nI][nPostes]))
						If SF4->F4_ESTOQUE == "S"
					   		Aviso(STR0018,STR0198,{STR0021})
						   	lRet := .F.
						EndIf
					EndIf
			   	Endif
				If lRet .And. cPaisLoc == "ARG" .And. FindFunction("VldSerProd") .And. FunName() $ ("MATA467N|MATA462N")
					If SF4->F4_ESTOQUE == "S" .And. Empty(aDadosI[nI][nPosNumSer])
						If VldSerProd(aDadosI[nI][nPosCod], aDadosI[nI][nPosLocal], aDadosI[nI][nPosLocaliz])
							cCpoUbiP := AllTrim(RetTitle('D2_LOCALIZ'))
							Help(" ", 1, "NUMSERI", , STR0442, 2, 0,,,,,, {STRTRAN(STR0443, "[VAR01]", cCpoUbiP )})
							lRet := .F.
						EndIf
					EndIf
				EndIf
			Endif
			DbSelectArea(cAliasVld)
	  	Endif
	EndIf
	//Verifica o TES selecionado
	If nPosTes>0 .AND.;
		lRet .AND. &("Val('"+aDadosI[nI][nPosTes]+"') "+IIf(cAliasI=="SD1",">","<=")+" 500" )
		Aviso(STR0018,STR0051+"("+aDadosI[nI][nPosTes]+")",{STR0021})
		lRet := .F.
	EndIf
	If nPostes>0 .AND.;
		lRet .AND. !SF4->(MsSeek(cFilSF4+aDadosI[nI][nPostes]))
		Aviso(STR0018,STR0052+"("+aDadosI[nI][nPosTes]+")",{STR0021})
		lRet := .F.
	EndIf
	//valida que la tes no afecte financiero y stock
	If nPostes>0 .AND. lRet .AND. Strzero(aCfgNF[SnTipo],2)== "21"
		lRet := LxTesTras(aDadosI[nI][nPosTes])
	EndIf
	//³Verifica casas decimais e arredondamento do valor total³
	cCampo:=PrefixoCpo(cAliasI)+"_TOTAL"
	If !(cPaisLoc $ "ARG") .and. !((cPaisLoc == "PAR"  .And. ( MsDecimais(nMoedaNF) == 0 .or. (FunName()$"MATA143"))))
		If nPosTes>0 .AND. nPosQuant>0 .AND. nPosVUnit>0 .AND. nPosTotal>0 .AND.;
			lRet .And. Iif(MaTesSel(aDadosI[nI][nPosTes]).And.aDadosI[nI][nPosQuant]==0,IIf(!(FunName()$"MATA462AN"),aDadosI[nI][nPosVUnit]<>aDadosI[nI][nPosTotal],.F.),;
			(Abs(aDadosI[nI][nPosTotal] - IIf(cPaisLoc$"CHI".And.!Strzero(aCfgNF[SnTipo],2)$"06|07|08|09|10|12|13|14|54|60|61|62|64",A410Arred((aDadosI[nI][nPosVUnit]*aDadosI[nI][nPosQuant]),cCampo,nMoedaNF),(aDadosI[nI][nPosVUnit]*aDadosI[nI][nPosQuant]))) > (1/(10**(Iif(MsDecimais(nMoedaNF)==0,1,MsDecimais(nMoedaNF))-1)))/   IIF (MsDecimais(nMoedaNF)==0 ,1,  2)     )) .and. !l103Class
			Aviso(STR0018,STR0053,{STR0021})
			lRet := .F.
		EndIf
	EndIf
    // Valida Qtde = 0 qdo F4_QTDZERO = Sim
    If ( lRet ) .AND. ( SF4->F4_QTDZERO == "1" )
    	lQtdeZero := .T.
    Endif
	//³Validando lotes³
	If nPosTotal>0 .And.;
		lRet .And. cTipDoc == 'D' .And. (Rastro(aDadosI[nI][nPosCod],"S")) .And. (nPosLote == 0 .Or. Empty(aDadosI[nI][nPosLote])) .And. !lQtdeZero

		If (nPosTes>0) .And. (SF4->(MsSeek(cFilSF4+aDadosI[nI][nPostes])))
			If SF4->F4_ESTOQUE=="S"
				Aviso(STR0018,STR0054,{STR0021})
				lRet := .F.
			Endif
		Endif
	EndIf
	If nPosCod>0 .And.;
		lRet .And. cTipDoc == 'D' .And. (Rastro(aDadosI[nI][nPosCod],"L")) .And. (nPosLoteCtl == 0 .Or. Empty(aDadosI[nI][nPosLoteCtl])).And. !lQtdeZero
		If (nPosTes>0) .And. (SF4->(MsSeek(cFilSF4+aDadosI[nI][nPostes])))
			If SF4->F4_ESTOQUE=="S"
				Aviso(STR0018,STR0055,{STR0021})
				lRet := .F.
			Endif
		Endif
	EndIf
	//³Campos de acordo com o TES³
	If lRet .AND. nPosRemito>0 .AND. Empty(aDadosI[nI][nPosRemito])
		If SF4->F4_PODER3 == "D" .AND. (nPosIdentB6 == 0 .OR. Empty(aDadosI[nI][nPosIdentB6]))
			Aviso(STR0018,STR0056,{STR0021})
			lRet := .F.
		Endif
	Endif
	//³Nao poder haver F2_TIPOREM == "1" e F4_PODER3 <> "R" ³
	If lRet .AND. aCfgNF[SlRemito] .AND. aCfgNF[ScTipoDoc]=="N" .AND. aCfgNF[SAliasHead]=="SF2" .AND. M->F2_TIPOREM==_RMCONS  .AND. SF4->F4_PODER3 <> "R"
		Aviso(STR0018,STR0051+" ("+aDadosI[nI][nPosTes]+")"+CRLF+;
				STR0129,{STR0021})			 //"ATENCAO"###"TES invalida para este Documento!"###"Remesas de consignacao deven usar TES de 'Remesa a terceiros'"###"OK"
		lRet := .F.
	EndIf
	//³Quando o processo for "Liquido Produto" a TES nao pode atualizar estoque                                 ³
	cAuxPaisL := "ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|HAI|MEX|PAD|PAN|PAR|PER|POR|SAL|TRI|URU|VEN"
	If lRet .AND. FunName()=="MATA462N" .AND. ( cPaisLoc $ cAuxPaisL .and. SF2->F2_LIQPROD=="1") .AND. SF4->F4_ESTOQUE <> "N"
		Aviso(STR0018,STR0051+" ("+aDadosI[nI][nPosTes]+")"+CRLF+STR0291,{STR0021})
		lRet := .F.
	EndIf
	//³Validacoes para SF1/SD1³
    If lRet .AND. cAliasI == "SD1"
		//³ Verifica se o produto est  em revisao vigente e envia para armazem de CQ para ser validado pela engenharia    ³
		If lRet .AND. lVer116 .And. lRevProd
			cRvSB5 := Posicione("SB5",1,cFilSB5+aDadosI[nI][nPosCod],"B5_REVPROD")
			cBlqSG5:= Posicione("SG5",1,cFilSG5+aDadosI[nI][nPosCod]+aDadosI[nI][nRevisao],"G5_MSBLQL")
			cStatus:= Posicione("SG5",1,cFilSG5+aDadosI[nI][nPosCod]+aDadosI[nI][nRevisao],"G5_STATUS")
			If cRvSB5="1"
			    If Empty(cRvSB5)
					MsgAlert(STR0325) //"Não foi encontrado registro do produto selecionado na rotina de Complemento de Produto."
					lRet:= .F.
				ElseIf Empty(cBlqSG5)
					MsgAlert(STR0326) //"Não foi encontrado revisão do produto selecionado"
					lRet:= .F.
				ElseIf cBlqSG5="1"
					Help(" ",1,"REGBLOQ")
					lRet:= .F.
				ElseIf cStatus=="2" .AND. aDadosI[nI][nPosTes]< "500"
					Aviso(STR0097,STR0334,{STR0021})//"Esta revisão não pode ser alimentada pois está inativa."
					lRet:= .F.
				ElseIf aDadosI[nI][nRevisao] <> Posicione("SB5",1,cFilSB5+aDadosI[nI][nPosCod],"B5_VERSAO") .AND. aDadosI[nI][nPosLocal] <> cCQ
					If ExistCpo("SG5",aDadosI[nI][nPosCod]+aDadosI[nI][nRevisao])
						nRet := Aviso(STR0327,STR0328 + AllTrim(aCols[n][nPosCod]) + STR0329 ,{STR0330,STR0331},1,STR0332) //"O Produto xxxxx " foi informado com revisão diferente da revisão vigente, este produto será enviado para o Armazém de CQ."
						If nRet==1
							aCols[nI][nPosLocal]:= cCQ
						Else
							lRet:= .F.
						EndIf
					Else
						lRet:= .F.
					EndIf
				EndIf
			EndIf
		EndIf
		//³Para retorno simbólico eh obrigatorio informar um TES com devolucao de poder de 3ros.³
		If lRet .AND. cTipDoc == 'B' .AND. aCfgNF[SnTipo] == 63 .AND. (nPosIdentB6 == 0 .OR. Empty(aDadosI[nI][nPosIdentB6]) )
			Aviso(STR0018,STR0050,{STR0021})
	   		lRet := .F.
	  	EndIf
		//³Remito Transf. (Rot.Auto): Verifica o documento de origem ³
	  	If lRet .And. aCfgNF[SnTipo] == 64 .And. Type("lLocxAuto") <> "U" .And. lLocxAuto .And.;
			Empty(Posicione("SD2",3,M->F1_FILORIG+aDadosI[nI][nPosNfOri]+aDadosI[nI][nPosSerOri]+RetForFil(M->F1_FILORIG)+aDadosI[nI][nPosCod]+aDadosI[nI][nPosItmOri],"D2_COD"))
			Aviso(STR0018,STR0259,{STR0021})
			lRet := .F.
        Endif
		//³Verifica se o produto esta bloqueado³
		If lRet .And. nPosCod>0 .And. nPosLocal>0 .And. (BlqInvent(aDadosI[nI][nPosCod],aDadosI[nI][nPosLocal]) .Or. ;
			(lAvalBlqLoc .And. AvalBlqLoc(aDadosI[nI][nPosCod],aDadosI[nI][nPosLocal],aDadosI[nI][nPosTes])))
			Aviso(STR0018,STR0058+" ("+aDadosI[nI][nPosCod]+STR0059+aDadosI[nI][nPosLocal]+")",{STR0021}) //"ATENCAO"###"Produto inventariado"###" Almox: "###"OK"
			lRet := .F.
		EndIf
		//³Verifica Preenchimento de Pedido e Item de Compra³
		If lRet .AND. 	( (nPosPedido>0.AND.!Empty(aDadosI[nI][nPosPedido])) .AND. (nPosItemPc==0.OR.Empty(aDadosI[nI][nPosItemPC])) ) .OR.;
				( (nPosItemPc>0.AND.!Empty(aDadosI[nI][nPosItemPC])) .AND. (nPosPedido==0.OR.Empty(aDadosI[nI][nPosPedido])) )
			Aviso(STR0018,STR0060,{STR0021})
			lRet := .F.
		EndIf
		//³Verifica se a Factura de entrada usa TES c/ estoque = S; a TES do Remito vinculado tb deve ser assim ³
		If lRet .And. aCfgNF[SnTipo] == 10 .And. nPosRemito*nPosItemRem*nPosSerRem > 0 .And. ;
			!Empty(aDadosI[nI][nPosRemito]).And. SF4->F4_ESTOQUE=="S"
			cTesRem := Posicione('SD1',1,cFilSD1+aDadosI[nI][nPosRemito]+aDadosI[nI][nPosSerRem]+M->F1_FORNECE+M->F1_LOJA+aDadosI[nI][nPosCod]+aDadosI[nI][nPosItemRem],"D1_TES")
			If Posicione('SF4',1,cFilSF4+cTesRem,'F4_ESTOQUE') =="N"
				lRet := .F.
				Help(" ",1,"A101FACTES")
			EndIf
		Endif
		If (nPosTes>0) .And. (SF4->(MsSeek(cFilSF4+aDadosI[nI][nPostes])))
			SF4->(MsSeek(cFilSF4+aDadosI[nI][nPostes]))
		EndIf
		aAreaSN1 := SN1->(GetArea())
		SN1->(DBSETORDER(RETORDEM("SN1","N1_FILIAL+N1_FORNEC+N1_LOJA+N1_NFESPEC+N1_NFISCAL+N1_NSERIE+N1_NFITEM")))
		// Verifica se a Factura de entrada usa TES c/ geracao de ativo; nao permite se a TES do Remito vinculado tambem atualiza ativo.
		lActFjRm := .F.
		If lRet .And. aCfgNF[SnTipo] == 10 .And. nPosRemito*nPosItemRem*nPosSerRem > 0 .And. ;
			!Empty(aDadosI[nI][nPosRemito]).And. SF4->F4_ATUATF=="S"
			If (SN1->(MsSeek(xFilial("SN1")+ M->F1_FORNECE + M->F1_LOJA + POSICIONE("SD1",1,xFilial("SD1")+aDadosI[nI][nPosRemito]+aDadosI[nI][nPosSerRem]+M->F1_FORNECE + M->F1_LOJA+aDadosI[nI][nPosCod]+aDadosI[nI][nPosItemRem],"D1_ESPECIE")+aDadosI[nI][nPosRemito]+aDadosI[nI][nPosSerRem]+aDadosI[nI][nPosItemRem])))
				lActFjRm := .T.
			Else
				cTesRem := Posicione('SD1',1,cFilSD1+aDadosI[nI][nPosRemito]+aDadosI[nI][nPosSerRem]+M->F1_FORNECE+M->F1_LOJA+aDadosI[nI][nPosCod]+aDadosI[nI][nPosItemRem],"D1_TES")
				If Posicione('SF4',1,cFilSF4+cTesRem,'F4_ATUATF') =="S"
					lRet := .F.
					Help(" ",1,"A101ATFTES")
				EndIf
				SF4->(MsSeek(cFilSF4+aDadosI[nI][nPostes]))
			EndIf
		Endif
		RestArea(aAreaSN1)
		//³Verifica se o Remito ou Factura de Entrada e' amarrado ao Ped.de Compra - MV_PCNFE ³
		//³OU se a TES esta' relacionada em MV_TESPCNF								 		  ³
		If lRet .And. (aCfgNF[SnTipo] == 10 .Or. aCfgNF[SnTipo] == 60) .And. nPosPedido>0 .And. nPosTes>0 .And. ;
			cTipDoc == 'N' .And. lPCNFE .And. Empty(aDadosI[nI][nPosPedido]) .And. SF4->F4_PODER3=="N" .And. ;
			( Empty(cTesPcNf) .Or. (!Empty(cTesPcNf) .And. !aDadosI[nI][nPosTes] $ cTesPcNf) )
			lRet := .F.
			//³Verifica se a Factura de Entrada esta' amarrada a um Remito com PC       ³
			If aCfgNF[SnTipo] == 10 .And. nPosRemito*nPosItemRem*nPosSerRem > 0 .And.;
				!Empty(Posicione('SD1',1,cFilSD1+aDadosI[nI][nPosRemito]+aDadosI[nI][nPosSerRem]+M->F1_FORNECE+M->F1_LOJA+aDadosI[nI][nPosCod]+aDadosI[nI][nPosItemRem],"D1_PEDIDO") )
				lRet := .T.
			Endif
			If !lRet
				Help(" ",1,"A101NPCNFE")
			EndIf
		Endif
		//³Valida OP selecionada³
		If lRet .AND. nPosOp >0 .AND. (( !Empty(aDadosI[nI][nPosOp]).AND.!ExistCpo("SC2",aDadosI[nI][nPosOp]) );
				.OR. ( !Empty(aDadosI[nI][nPosOP]) .AND. !Empty(SC2->C2_DATRF) ))
			Aviso(STR0018,STR0061+" ("+AllTrim(aDadosI[nI][nPosOP])+")",{STR0021})			 //"ATENCAO"###"OP invalida"###"OK"
			lRet := .F.
		EndIf
		//³Campos e funcionalidades de acordo com TES³
		If nPosCod>0 .AND. nPosLocal>0 .AND.;
			lRet .AND. SF4->F4_ESTOQUE == 'S' .AND. !A103Alert(aDadosI[nI][nPosCod],aDadosI[nI][nPosLocal],( Type('l103Auto') <> 'U' .AND. l103Auto ))
			lRet := .F.
		EndIf
		//³Verifica se a qtde classificada e' valida ³
		If lRet .And. aCfgNF[ScTipoDoc] == "N" .And. nPosRemito*nPosItemRem*nPosSerRem > 0 .And. !Empty(aDadosI[nI][nPosRemito])
			//³Soma qtde total³
			nZ := 0
			nQuantAux := 0
			For nZ := 1 to Len(aAuxI)
				If 	aAuxI[nZ][nPosCod]     		== aDadosI[nI][nPosCod]		.And. ;
					aAuxI[nZ][nPosRemito]		== aDadosI[nI][nPosRemito]	.And. ;
					aAuxI[nZ][nPosSerRem] 		== aDadosI[nI][nPosSerRem]	.And. ;
					aAuxI[nZ][nPosItemRem] 		== aDadosI[nI][nPosItemRem]	.And. ;
					!aAuxI[nZ][Len(aAuxI[nZ])]
					nQuantAux += aAuxI[nZ][nPosQuant]
				EndIf
			Next
			//³Avisa caso a soma das qtdes informadas ultrapasse a qtde.disponivel do remito original
			If Posicione('SD1',1,cFilSD1+aDadosI[nI][nPosRemito]+aDadosI[nI][nPosSerRem]+M->F1_FORNECE+M->F1_LOJA+aDadosI[nI][nPosCod]+aDadosI[nI][nPosItemRem],"D1_QTDACLA") < nQuantAux
				Aviso(STR0018,STR0012+" ("+aDadosI[nI][nPosSerRem]+"/"+aDadosI[nI][nPosRemito]+")"+CRLF+STR0143+;
				STR(Posicione('SD1',1,cFilSD1+aDadosI[nI][nPosRemito]+aDadosI[nI][nPosSerRem]+M->F1_FORNECE+M->F1_LOJA+aDadosI[nI][nPosCod]+aDadosI[nI][nPosItemRem],"D1_QTDACLA")-(nQuantAux-aDadosI[nI][nPosQuant]),15,2);
				,{STR0021})
				lRet := .F.
			EndIf
		EndIf
		//Integracao
		If lRet .AND. IntTMS() .AND. nPosCodVei >0 .AND. nPosViagem >0 .AND. !Empty(aDadosI[nI][nPosCodVei]) .AND. !Empty(aDadosI[nI][nPosViagem])
			Aviso(STR0018,STR0062,{STR0021})
			lRet := .F.
		EndIf
		//Verifica qtde disponivel no SB6
		If nPosNfOri>0 .AND. nPosSerOri>0 .AND. nPosIdentB6>0 .AND. nPosQuant>0 .AND.;
			lRet .AND. SF4->F4_PODER3 == 'D'
			nZ := 0
			For nZ := 1 to Len(aAuxI)
				If nPosIdentB6 <= Len(aDadosI[nI]) .And. nPosIdentB6 <= Len(aDadosI[nZ]) .And. ;
					aDadosI[nZ][nPosNfOri]  	== aDadosI[nI][nPosNfOri]  	.AND. aDadosI[nZ][nPosSerOri] 	== aDadosI[nI][nPosSerOri] 	.AND. ;
					aDadosI[nZ][nPosIdentB6] 	== aDadosI[nI][nPosIdentB6] .AND. !aDadosI[nZ][Len(aDadosI[nZ])]
					nQuantAux += aDadosI[nZ][nPosQuant]
				EndIf
			Next
			dbSelectArea("SB6")
			dbSetOrder(3)
			If nPosIdentB6 <= Len(aDadosI[nI]) .And. nPosIdentB6>0 .AND. nPosCod>0 .AND. ;
				lRet .AND. MSSeek(cFilSB6+aDadosI[nI][nPosIdentB6]+aDadosI[nI][nPosCod]+"R", .F.)
				If nQuantAux > SB6->B6_SALDO
					Aviso(STR0018,STR0063+" ("+AllTrim(Str(nQuantAux))+"/"+AllTrim(Str(SB6->B6_SALDO))+")",{STR0021})
					lRet := .F.
				EndIf
			EndIf
		EndIf
		//³ Se todos os campos foram encontrados ele verifica a cotacao³
		If lRet .AND. 	nPosPedido > 0 .AND. nPosItemPc > 0 .AND.!Empty(aDadosI[nI][nPosPedido]) .AND.;
				!Empty(aDadosI[nI][nposItemPc]) .AND. !(cModulo=="FIS")
			DBSelectArea("SC7")
			DBSetOrder(1)
			If MSSeek(cFilSC7+aDadosI[nI][nPosPedido]+aDadosI[nI][nPosItemPc], .F.)
				If nPosVunit>0 .AND. nPosCliFor>0 .AND. nPosLoja>0 .AND.;
					lRet .AND. aDadosI[nI][nPosVunit] > 0 .AND. C7_ITEMSC == "CT"
					DBSelectArea("SC8")
					DBSetOrder(3)
					MSSeek(cFilSC8+SC7->C7_NUMSC+SC7->C7_PRODUTO+aDadosI[nI][nPosCliFor]+aDadosI[nI][nPosLoja], .F.)
					DBSetOrder(1)
					If Found() .AND. C8_AVISTA > 0
						DBSelectArea("SM2")
						Set SoftSeek On
						MSSeek(SC8->C8_DTVISTA)
						If !Found()
							DBSkip(-1)
						EndIf
						nValaVista := SC8->C8_AVISTA/IIF( SM2->M2_MOEDA2>0,SM2->M2_MOEDA2,1)
						MSSeek(aDadosI[nI][nPosEmissao], .F.)
						If !Found()
							DBSkip(-1)
						EndIf
						nValDigita := aDadosI[nI][nPosVunit]/IIf(SM2->M2_MOEDA2>0,SM2->M2_MOEDA2,1)
						Set SoftSeek Off
						If nValaVista != nValDigita
							Aviso(STR0018,STR0065+" ("+AllTrim(Str(nValDigita))+"/"+AllTrim(Str(nValaVista)),{STR0021}) //"ATENCAO"###"Incosistencias no valor unitario digitado de acordo com a cotacao"###"OK"
							lRet := .F.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	//³Validacoes para SF2/SD2³
    If lRet .AND. cAliasI == "SD2"
		//³ Verifica se o produto est  em revisao vigente e envia para armazem de CQ para ser validado pela engenharia
		If lRet .AND. lVer116 .And. lRevProd
			cRvSB5 := Posicione("SB5",1,cFilSB5+aDadosI[nI][nPosCod],"B5_REVPROD")
			cBlqSG5:= Posicione("SG5",1,cFilSG5+aDadosI[nI][nPosCod]+aDadosI[nI][nRevisao],"G5_MSBLQL")
			cStatus:= Posicione("SG5",1,cFilSG5+aDadosI[nI][nPosCod]+aDadosI[nI][nRevisao],"G5_STATUS")
			If cRvSB5="1"
			    If Empty(cRvSB5)
					Aviso(STR0097,STR0325,{STR0021}) //"Não foi encontrado registro do produto selecionado na rotina de Complemento de Produto."
					lRet:= .F.
				ElseIf Empty(cBlqSG5)
					Aviso(STR0097,STR0326,{STR0021}) //"O produto selecionado não possui revisão em uso. Verifique o cadastro de Revisões."
					lRet:= .F.
				ElseIf cBlqSG5="1"
					Help(" ",1,"REGBLOQ")
					lRet:= .F.
				ElseIf cStatus=="2" .AND. aDadosI[nI][nPosTes]< "500"
					Aviso(STR0097,STR0334,{STR0021})//"Esta revisão não pode ser alimentada pois está inativa."
					lRet:= .F.
				EndIf
			EndIf
		EndIf
		//³Verifica Preenchimento de Pedido e Item de Venda
		If lRet .AND. 	( (nPosPedido>0.AND.!Empty(aDadosI[nI][nPosPedido])) .AND. (nPosItemPv==0.OR.Empty(aDadosI[nI][nPosItemPv])) ) .OR.;
				( (nPosItemPv>0.AND.!Empty(aDadosI[nI][nPosItemPv])) .AND. (nPosPedido==0.OR.Empty(aDadosI[nI][nPosPedido])) )
			Aviso(STR0018,STR0066,{STR0021})
			lRet := .F.
		EndIf
		//³ Efetuar a avaliacao do Saldo en Estoque  quando nao existe pedido³
		//³ de vendas (no caso de existir, a qtde ja esta reservada.

		If lRet .AND. SF4->F4_ESTOQUE == "S" .AND. (aCfgNF[SlRemito] .OR. (nPosPedido==0 .OR. Empty(aDadosI[nI][nPosRemito])) .OR. aDadosI[nI][nPosTPDCENV]=="1" .OR.aDadosI[nI][nPosTPDCENV]==_RMCONS )
			If aCfgNF[SlRemito] .and. (IIf(nPosPedido>0,!Empty(aDadosI[nI][nPosPedido]),.F.))   //Se for Remito e tem pedido a TES de aprovação do pedido pode ser outra
				lTesPeRemi := Posicione('SF4',1,cFilSF4+aDadosI[nI][nPosTes],'F4_ESTOQUE') == "N"  //com F4_ESTOQUE = N, então não tem reserva.
			Endif
			If cPaisLoc == "ARG" .and. aDadosI[nI][nPosEspecie] == "NCP"//identifica se a NCP possui um Remito vinculado, caso haja, o sistema não deve realizar a consulta de saldo do produto no estoque
				If Empty(aDadosI[nI][nPosRemito])
					If !SaldoOk(aDadosI[nI][nPosCod],aDadosI[nI][nPosLocal],aDadosI[nI][nPosQuant],IIf(nPosLoteCtl>0,aDadosI[nI][nPosLoteCtl],""),IIf(nPosLote>0,aDadosI[nI][nPosLote],""),IIf(nPosLocaliz>0,aDadosI[nI][nPosLocaliz],""),IIf(nPosNumSer>0,aDadosI[nI][nPosNumSer],""),IIf(nPosPedido>0,!Empty(aDadosI[nI][nPosPedido]),.F.) , IIf(nPosPedido>0,aDadosI[nI][nPosPedido],""), IIf(nPosItemPv>0,aDadosI[nI][nPosItemPv],""),IIf(nPosSequen>0,aDadosI[nI][nPosSequen],""),,lTesPeRemi)
						Aviso(STR0018,STR0070,{STR0021})
						lRet	:=	.F.
					EndIf
				Endif
			ElseIf (cPaisLoc == "ARG" .and. aDadosI[nI][nPosEspecie] != "NCP" ) .or. cPaisLoc <> "ARG"
				If !SaldoOk(aDadosI[nI][nPosCod],aDadosI[nI][nPosLocal],aDadosI[nI][nPosQuant],IIf(nPosLoteCtl>0,aDadosI[nI][nPosLoteCtl],""),IIf(nPosLote>0,aDadosI[nI][nPosLote],""),IIf(nPosLocaliz>0,aDadosI[nI][nPosLocaliz],""),IIf(nPosNumSer>0,aDadosI[nI][nPosNumSer],""),IIf(nPosPedido>0,!Empty(aDadosI[nI][nPosPedido]),.F.) , IIf(nPosPedido>0,aDadosI[nI][nPosPedido],""), IIf(nPosItemPv>0,aDadosI[nI][nPosItemPv],""),IIf(nPosSequen>0,aDadosI[nI][nPosSequen],""),,lTesPeRemi)
					Aviso(STR0018,STR0070,{STR0021})
					lRet	:=	.F.
				EndIf
			EndIf
		Endif
		//³Verifica se o produto esta bloqueado³
		If lRet .And. nPosCod>0 .And. nPosLocal>0 .And. SF4->F4_ESTOQUE == "S" .And. (BlqInvent(aDadosI[nI][nPosCod],aDadosI[nI][nPosLocal]) .Or. ;
			(lAvalBlqLoc .And. AvalBlqLoc(aDadosI[nI][nPosCod],aDadosI[nI][nPosLocal],aDadosI[nI][nPosTes])))
			Aviso(STR0018,STR0058+" ("+aDadosI[nI][nPosCod]+STR0059+aDadosI[nI][nPosLocal]+")",{STR0021})
			lRet := .F.
		EndIf
		//³Verifica qtde disponivel no SB6³
		If nPosNfOri>0 .AND. nPosSerOri>0 .AND. nPosIdentB6>0 .AND. nPosQuant>0 .AND.;
			lRet .AND. SF4->F4_PODER3 == 'D'
			nZ := 0
			For nZ := 1 to Len(aAuxI)
				If nPosIdentB6 <= Len(aDadosI[nI]) .And. nPosIdentB6 <= Len(aDadosI[nZ]) .And. ;
					aDadosI[nZ][nPosNfOri]  	== aDadosI[nI][nPosNfOri]  	.AND. aDadosI[nZ][nPosSerOri] 	== aDadosI[nI][nPosSerOri] 	.AND. ;
					aDadosI[nZ][nPosIdentB6] 	== aDadosI[nI][nPosIdentB6] .AND. !aDadosI[nZ][Len(aDadosI[nZ])]
					nQuantAux += aDadosI[nZ][nPosQuant]
				EndIf
			Next
			DBSelectArea("SB6")
			DBSetOrder(3)
			If nPosIdentB6 <= Len(aDadosI[nI]) .And. nPosIdentB6>0 .AND. nPosCod>0 .AND. ;
				lRet .AND. MSSeek(cFilSB6+aDadosI[nI][nPosIdentB6]+aDadosI[nI][nPosCod]+"R", .F.)
				If nQuantAux > SB6->B6_SALDO
					Aviso(STR0018,STR0071+" ("+AllTrim(Str(nQuantAux))+"/"+AllTrim(Str(SB6->B6_SALDO))+")",{STR0021})
					lRet := .F.
				EndIf
			EndIf
		EndIf
		//³ Validacao do Custo FIFO On-Line|
		If lRet .And. SF4->F4_ESTOQUE == "S" .And. lFifoOnLine .And. IsFifoOnLine()
			If SaldoSBD("SD2",aDadosI[nI][nPosCod],aDadosI[nI][nPosLocal],dDataBase,.F.)[1] < aDadosI[nI][nPosQuant]
				Help(" ",1,"DIVFIFO2")
				lRet := .F.
			EndIf
		EndIf
		If lRet .AND. IntePms() .AND. ( nPD2_PROJPMS > 0 .AND. nPD2_EDTPMS > 0 .AND. nPD2_TASKPMS > 0 )
    		lRet := a467VldPMS(aDadosI[nI][nPD2_PROJPMS],aDadosI[nI][nPD2_EDTPMS],aDadosI[nI][nPD2_TASKPMS])
		EndIf
		If lRet .And. nPosConta > 0 .And. nPosCC > 0 .And. nPosItCC > 0 .And. nPosCLVL > 0 .And.;
			!CtbAmarra(aDadosI[nI,nPosConta],aDadosI[nI,nPosCC],aDadosI[nI,nPosItCC],aDadosI[nI,nPosCLVL])
			lRet := .F.
		EndIf
    EndIf
	//³Efetuando as validacoes genericas ³
	//³Validacoes para devolucoes
	If lRet .And. cTipDoc == "D" .And. nPosNfOri > 0 .And. nPosSerOri > 0 .And. nPosItmOri > 0 .And. !Empty(aDadosI[nI][nPosNFOri])
		DBSelectArea(If(cAliasI=="SD1","SD2","SD1"))
		DBSetOrder(If(cAliasI=="SD1",3,1))
		//³Posiciona Nota de Origem³
		If nPosCliFor>0 .And. nPosLoja>0 .And. nPosCod>0 .And. nPosItmOri>0 .And.;
			MsSeek(xFilial()+aDadosI[nI][nPosNFOri]+aDadosI[nI][nPosSerOri]+aDadosI[nI][nPosCliFor]+aDadosI[nI][nPosLoja]+aDadosI[nI][nPosCod]+aDadosI[nI][nPosItmOri])
			// Caso o TES permita valor ZERO pelo campo F4_QTDZERO, pula esta validacao
			If .F.
				If ( !lQtdeZero ) // Alteracao conforme BOPS 66.652
					//³Verifica se devolucao possui desc. especial
					If DevZFranca(&(cPrefDev+"_COD"))
						If NoRound(aDadosI[nI][nPosVUnit],TamSX3(IIf(cAliasI=="SD1","D2_PRCVEN","D1_VUNIT"))[2]) <> NoRound((&(cPrefDev+"_TOTAL")+&(cPrefDev+"_DESCZFR"))/&(cPrefDev+"_QUANT"),TamSX3(IIf(cAliasI=="SD1","D2_PRCVEN","D1_VUNIT"))[2])
								Aviso(STR0018,STR0073,{STR0021})
								lRet := .F.
						EndIf
					Else
						If NoRound(aDadosI[nI][nPosVUnit],TamSX3(IIf(cAliasI=="SD1","D2_PRCVEN","D1_VUNIT"))[2]) <> NoRound(&(IIf(cAliasI=="SD1","SD2->D2_PRCVEN","SD1->D1_VUNIT"))+(&(IIf(cAliasI=="SD1","SD2->D2_DESCON","SD1->D1_DESC"))/&(cPrefDev+"_QUANT")),TamSX3(IIf(cAliasI=="SD1","D2_PRCVEN","D1_VUNIT"))[2])
							Aviso(STR0018,STR0073,{STR0021})
							lRet := .F.
						EndIf
					EndIf
				Endif
			Endif
			//³Soma qtde total ³
			nZ := 0
			nQuantAux := 0
			For nZ := 1 to Len(aAuxI)
				If 	aAuxI[nZ][nPosCod]     		== &(cPrefDev+"_COD")		.And. ;
					aAuxI[nZ][nPosNfOri]			== &(cPrefDev+"_DOC")		.And. ;
					aAuxI[nZ][nPosSerOri] 			== &(cPrefDev+"_SERIE")	.And. ;
					aAuxI[nZ][nPosItmOri] 			== &(cPrefDev+"_ITEM")		.And. ;
					!aAuxI[nZ][Len(aAuxI[nZ])]
					nQuantAux += aAuxI[nZ][nPosQuant]
				EndIf
			Next
			If lRet .And. nQuantAux > IIf((cPrefDev=="SD1->D1" .And. !cEspecDoc $ "NCP|NDP|NCI|NDI"), &(cPrefDev+"_QTDACLA") , (&(cPrefDev+"_QUANT") - &(cPrefDev+"_QTDEDEV")) ) .And. ;
				!lRmtdevf
				//³Avisa caso a soma da qtde devolvida ultrapassar a qtde original
				Aviso(STR0018,STR0074+ ;
				     IIf(cPrefDev=="SD1->D1", " ("+AllTrim(Str(nQuantAux))+"/"+AllTrim(Str(&(cPrefDev+"_QTDACLA")))+" )" ,;
				         " ("+AllTrim(Str(nQuantAux))+"/"+AllTrim(Str(&(cPrefDev+"_QUANT")-&(cPrefDev+"_QTDEDEV")))+" )"),{STR0021})
				lRet := .F.
			EndIf
		EndIf
    EndIf
	//³Validacao para NCP amarrada a Remito de Devol.
	If lRet .AND. aCfgNF[SnTipo] == 7 .And. cTipDoc == "D" .And. nPosRemito*nPosItemRem*nPosSerRem > 0 .And. !Empty(aDadosI[nI][nPosRemito]) .And. !(cPaisLoc == "EQU")
		//Posiciona Nota de Origem
		SD2->(DBSetOrder(3))
		If nPosCliFor>0 .And. nPosLoja>0 .And. nPosCod>0 .And. ;
			SD2->(MsSeek(cFilSD2+aDadosI[nI][nPosRemito]+aDadosI[nI][nPosSerRem]+aDadosI[nI][nPosCliFor]+aDadosI[nI][nPosLoja]+aDadosI[nI][nPosCod]+aDadosI[nI][nPosItemRem]))
			//³Soma qtde total
			nZ := 0
			nQuantAux := 0
			For nZ := 1 to Len(aAuxI)
				If 	aAuxI[nZ][nPosCod]     		== SD2->D2_COD	 .And. ;
					aAuxI[nZ][nPosRemito]		== SD2->D2_DOC	 .And. ;
					aAuxI[nZ][nPosSerRem] 		== SD2->D2_SERIE .And. ;
					aAuxI[nZ][nPosItemRem] 		== SD2->D2_ITEM  .And. ;
					!aAuxI[nZ][Len(aAuxI[nZ])]
					nQuantAux += aAuxI[nZ][nPosQuant]
				EndIf
			Next
			If lRet .And. nQuantAux > (SD2->D2_QUANT - SD2->D2_QTDEFAT)
				//Avisa caso a soma da qtde informada ultrapassar a qtde. disponivel do remito original
				Help(" ",1,"A466NQTDIS")
				lRet := .F.
			EndIf
		EndIf
    EndIf
   	If lRet .And. !Empty(aDadosI[nI][nPosLocal])
		NNR->(dbSetOrder(1))
		If !NNR->(dbSeek(xFilial("NNR")+aDadosI[nI][nPosLocal]))
			Help(" ",1,"A430LOCAL")
			lRet:= .F.
		EndIf
	EndIf
Next nI
// Validacao notas fiscais originais
If lRet .AND. cPaisLoc == "PER" .AND. nLinha > 0
	lRet := LxLOkPer(cAliasI,aCposIOri,aDadosIOri,cTipDoc,nLinha,lFormP, aCfgNF, cEspecie, cCondicao, nSalvaN, aHeader, aCols, Funname())
EndIf
If lRet .AND. cPaisLoc == "MEX" .AND. nLinha > 0
	lRet := LxLOkMex(cAliasI,aCposIOri,aDadosIOri,cTipDoc,nLinha,lFormP,IIf(Type("bDoRefresh") != "U",bDoRefresh,Nil), IIf(Type("bListRefresh") != "U",bListRefresh,Nil))
EndIf
If lRet .and. cPaisLoc == "ARG" .and. nLinha > 0
	lRet := ArgLinOk(cAliasI,aCposIOri,cAliasCF,aDadosIOri,cTipDoc,nLinha,lFormP,l103Class,aCfgNf)
EndIf
If lRet .and. cPaisLoc == "PAR" .and. nLinha > 0
	lRet := ParLinOk(cAliasI,aCposIOri,cAliasCF,aDadosIOri,cTipDoc,nLinha,lFormP,nMoedaNF,l103Class)
EndIf
If lRet .and. cPaisLoc == "EQU" .And. nLinha > 0
	lRet := LxLOkEqu(aCfgNF, aDadosI, cTipDoc, nLinha, nPosRemito, nPosItemRem, nPosSerRem, nPosCliFor, nPosLoja, nPosCod, nPosEspecie, nPosNFOri, nPosItmOri, nPosQuant)
EndIf
If lRet .and. cPaisLoc == "BOL" .And. nLinha > 0
	lRet := LxLOkBol(aHeader, aCols, nLinha, lFactElec, lFormP, cCFDUso, cEspecie, cFunname, nPosRemito, nPosNFOri, nPosSerOri)
EndIf

// Ponto de Entrada para inclusao de consistencias na LINOK
cPe	:=	LocxPE(17)
If lRet .And. !Empty(cPE)
	lRet:= ExecBlock(cPE,.F.,.F.)
Endif
//³Restaurando valores da entrada da funcao³
IIf(nSalvaN>0.And.Type("n")!="U",n:=nSalvaN,)
//³Verifica se existe a necessidade de aumentar o numero maximo de itens|
If Type("oGetDados")=="O" .And. AllTrim(FunName()) <> "MATA462TN"
	If lRet .And. (nLinha == Len(aCols) .And. (nLinha == oGetDados:nMax .Or. nLinha > oGetDados:nMax))
		AEval(aCols,{|x| nTotLin += Iif(!x[Len(aHeader)+1]	,1,0) })
		If nTotLin < LjGetMaxIt(cSerie)
			oGetDados:nMax := (Len(aCols) + 1)
		EndIf
	EndIf
Endif

//Se valida que el Documento Original informado en NDC/NCC - Colombia/Peru
If lRet .And. cPaisLoc $ "COL" .And. nLinha > 0 .And.  FunName() == "MATA465N" .And. cEspecie $ "NDC|NCC" .And. lFormP .And. (aCols[nSalvaN][Len(aHeader)+1] == .F.) .And. (lFactElec) .And. Empty(aCols[nSalvaN][nPosRemito])
	lRet := LxVldDocIt(aCols[nSalvaN][nPosNFOri], aCols[nSalvaN][nPosSerOri], cEspecie)
EndIf
// WMS Integration - Line Validation.
If cPaisLoc == "RUS"
 	If SuperGetMV("MV_WMSNEW",.F.,.F.) .and. lRet .And. cAliasI == "SD1" .And. cTipDoc $ "N|D|B" .And. SF4->F4_ESTOQUE == "S" .And. FindFunction("WmsValLiMI") .And. IntWMS()
		lRet := WmsValLiMI(aCols,n,aHeader)
	EndIf
Else
	//Integração WMS - Validação da Linha
	If lRet .And. cAliasI == "SD1" .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE == "S" .And. FindFunction("WmsValLiMI") .And. IntWMS()
		lRet := WmsValLiMI(aCols,n,aHeader)
	EndIf
ENDIF
//Validacion PCO por salto de linea
If lRet .And. cPaisLoc $ "MEX|COL|PER|EQU" .And. SuperGetMV("MV_PCOINTE", .F., "2") == "1"
	If Len(aItemsPCO) > 0
		nPos := aScan(aItemsPCO, {|x| x[1] == aCols[nSalvaN][nPosItem]})
	EndIf
	If nPos == 0 .Or. !(aItemsPCO[nPos][2])
		PcoDetLan(aCfgNf[SaLancPCO][1], aCfgNf[SaLancPCO][2][1], aCfgNf[SaLancPCO][3], .F.) //Presenta Detalle de Poliza
		lRet := PcoVldLan(aCfgNf[SaLancPCO][1], aCfgNf[SaLancPCO][2][1], aCfgNf[SaLancPCO][3], , ,.T.) //Valida bloqueo
		If lRet
			aAdd(aItemsPCO, {aCols[nSalvaN][nPosItem], lRet})
		EndIf
	EndIf
EndIf
Return(lRet)

/*
±±³Fun‡…o    ³CposVazio      ³ Autor ³ Leandro C. G.      ³ Data ³14/12/2001³±±
±±³Descri‡…o ³Verifica todos os campos obrigatorios para gravacao de uma  	³±±
±±³			 ³NF											   				³±±
param.
cAliasC		-	Alias de cabecalho de NF
cAliasI		- 	Alias de Itens de NF
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
aCabNota 	-	Cabecalho da Nota
		   		[1] - campos do cabecalho
		   		[2] - conteudo dos campos do cabecalho * pode ser uma formula, inclusive qdo for um totalizador
		   		[3] - indica se o campo e totalizador (Default .F.)
aCpItens 	- 	campos dos itens (devem obedecer a sequencia do aHeader)
aCitens  	- 	conteudo do item da NF (devem odebecer a sequencia do aCols) * o conteudo de cada campo pode ser uma formula
				deve ser passado um item por vez
lObrigSX3	-	Indica se devem ser verificados os obrigatorios do SX3
lObrigNF		-  Indica se devem ser verificados os obrigatorios proprios da rotina
*/
Function CposVazio(cAliasC,cAliasI,cTipDoc,aCabNota,aCpItens,aCitens,lObrigSX3,lObrigNF)
Local nI//,nX						//Flag's para loop's
Local aObrigC	   := {}		//Array com os campos obriagtorios de cabecalho
Local aObrigI	   := {}		//Array com os campos obriagtorios de itens
//Local aPos		   := {}		//Posicoes de campos em um array
Local lRet		   := .T.		//Indica consistencia da Funcao
Local nPos		   := 0
Local aPars	   	   := {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lCartaP      := SF2->(ColumnPos("F2_TPCOMPL")) > 0
DEFAULT lObrigSX3	:=	.T.
DEFAULT lObrigNF	:=	.T.

//³Consistindo param
If !Empty(cAliasI)
	Aadd(aPars	, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
	Aadd(aPars	, {"aCpItens"	, aCpItens	, SpEmpty						} )
	Aadd(aPars	, {"aCitens"	, aCitens	, SpEmpty						} )
EndIf
If !Empty(cAliasC)
	Aadd(aPars	, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
	Aadd(aPars	, {"aCabNota"	, aCabNota	, SpLenArray	,1		,3		} )
EndIf
Aadd(aPars	, {"lObrigSX3"	, lObrigSX3	, SpValType	,	"L"	} )
Aadd(aPars	, {"lObrigNF"	, lObrigNF	, SpValType	,	"L"	} )

lRet := LocxParam("CPOSVAZIO",aPars)

If lRet //(1)
	//³Busca campos obrigatorios nos arquivos de NF, de acordo com SX3
	If lObrigSX3
		IIf(!Empty(cAliasC),aObrigC:=CposObrig(cAliasC,aCabNota[1]),)
		IIf(!Empty(cAliasI),aObrigI:=CposObrig(cAliasI,aCpItens),)
	Endif
	//³Adiciona os campos obrigatorios especificamente na gravacao de uma NF
	If lObrigNF
		IIf(!Empty(cAliasC),aObrigC:=CposObrigNf(cAliasC,cTipDoc,aObrigC,aCabNota[1]),)
		IIf(!Empty(cAliasI),aObrigI:=CposObrigNf(cAliasI,cTipDoc,aObrigI,aCpItens),)
	Endif
	//³Verifica se todos os campos obrigatorios, de cabecalho, estao presentes e preenchidos³
	If !Empty(cAliasC)
		nI := 0
		For nI := 1 to Len(aObrigC)
			nPos := Ascan(aCabNota[1], {|x| Upper(AllTrim(x)) == Upper(AllTrim(aObrigC[nI]))})
			If aObrigC[nI] != (PrefixoCpo(cAliasC)+"_FILIAL") .AND. ; //o campo de filial possui valor automatico
			   (nPos <= 0 .OR. ValType(aCabNota[2][nPos]) == "A" .OR. Empty(aCabNota[2][nPos]))
				SX3->(DBSetOrder(2))
				SX3->(MSSeek(aObrigC[nI],.F.))
				Aviso(STR0038,STR0075+X3Titulo(aObrigC[nI]),{STR0021})
				lRet := .F.
				Exit
			EndIf
		Next nI
	EndIf
	//³Verifica se todos os campos obrigatorios, de itens, estao presentes e preenchidos³
	If !Empty(cAliasI)
		nI := 0
		For nI := 1 to Len(aObrigI)
			If aObrigI[nI] != (PrefixoCpo(cAliasI)+"_FILIAL")
				nPos := Ascan(aCpItens, {|x| Upper(AllTrim(x)) == Upper(AllTrim(aObrigI[nI]))})
				If nPos == 0 .OR. Empty(aCitens[nPos])
					If Alltrim(aObrigI[nI]) $ "D2_PRCVEN|D2_TOTAL" .And. cPaisLoc == "MEX" .And. FWIsInCallStack("MATA467N") .And. (nNFTipo == 21 .Or. (lCartaP .And. M->F2_TPCOMPL == "S"))
						lRet := .T. // Traslado o NF con carta porte ==> aceptar precio unitario y total cero
					Else
						SX3->(DBSetOrder(2))
						SX3->(MsSeek(aObrigI[nI],.F.))
						Aviso(STR0038,STR0076+X3Titulo(aObrigI[nI]),{STR0021})
						lRet := .F.
						Exit
					EndIf
				EndIf
			EndIf
		Next nI
	EndIf
EndIf //lRet (1)
Return(lRet)

/*
±±³Fun‡…o    ³HeaderCpos     ³ Autor ³ Leandro C. G.      ³ Data ³17/12/2001³±±
±±³Descri‡…o ³Devolve um array apenas com o nome dos campos baseados no 	³±±
±±³          ³aHeader que estiver declarado									³±±
*/
Function HeaderCpos()
Local aCpos := {}
If Type("aHeader") != "U"
	Aeval(aHeader, { |x| IIf(Len(x)>=2.AND.!Empty(x[2]),Aadd(aCpos, x[2]),) })
EndIf
Return(aCpos)

/*
±±³Fun‡…o    ³ GravaFina     ³ Autor ³ Leandro C. G.          ³ Data ³ 24.01.2002 ³±±
±±³Descri‡…o ³ Grava movimentacoes do financeiro                                  ³±±
±±³ Uso      ³ LocXNF                                                             ³±±
param.
cAliasC		- Alias do cabecalho da NF que esta sendo gravada (SF1/SF2)
cAlaisFin	- Alias do arquivo financeiro que sera atualizado (SE1/SE2)
aDuplOri	- Array com os dados referentes aos vencimentos
'			  [x][1] - Serie da NF
			  [x][2] - Numero da NF
			  [x][3] - Parcela referente ao vencimento
			  [x][4] - Data do Vencimento
			  [x][5] - Valor do Vencimento
cTipoFin	- tipo do titulo a ser gravado no financeiro
cSinal 	- indica sinal de operacao financeira (+ = receber ou - = pagar)
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
Obs. :Considera que o arquivo de Notas Fiscais estao posicionados antes da chamada da funcao
Obs. :Considera que as variaveis de impostos estao carregadas
*/
Function GravaFina(cAliasC,cAliasFin,aDuplOri,cTipoFin,cSinal,cTipDoc,aFin,aRecnoI,aRecnoSE1)
Local nX							//Flag's para Loop's
//Local aArea   	:= GetArea()
Local lRet		:= .T.				//Indica consistencia da funcao
//Local aRetIrrf	:= {}
//Local cPrefFin	:= IIf(!Empty(cAliasFin),cAliasFin+"->"+PrefixoCpo(cAliasFin),"")	//Prefixo do Alias do arquivo Financeiro que sera atualizado
Local cPrefC   := IIf(!Empty(cAliasC),cAliasC+"->"+PrefixoCpo(cAliasC),"")  		//Prefixo do Alias de Cabecalho da NF
Local cNatureza:= aFin[ScNatureza]
//Local nTamData := IIf(__SetCentury(),10,8)
//Local nTotDup  := 0																	//Valor total das duplicatas gravadas
//Local aRecSE1  := {}
Local nBaseDup := MaFisRet(,"NF_BASEDUP")
//Local nTotCruz	:= 0
//Local dDataCnd := dDataBase
//Local nValFat  := 0
//Local nMcompra := 0
Local aPars	   := {}						//Array para a funcao de validacao de parametros (Olhar funcao LocxParam())
Local aRet	 	:= {}

Default aRecnoSE1 := {}

//³Variaveis utilizadas em outras rotinas³
Private aCaixaFin:= xCxFina()			// Caixa Geral do Financeiro
Private l103Auto := .T.
Private cNFiscal := ""
Private cSerie   := ""
PRIVATE nValFun  := MaFisRet(,"NF_FUNRURAL")
Private aDupl    := aClone(aDuplOri)		//Array com os dados referentes aos vencimentos
Private nTaxa	 := 0
/*			  								[x][1] - Serie da NF
											[x][2] - Numero da NF
											[x][3] - Parcela referente ao vencimento
											[x][4] - Data do Vencimento
											[x][5] - Valor do Vencimento */
//³Consistindo parametros³
Aadd(aPars, {"cAliasC"		, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasFin"	, cAliasFin	, Sp2String		,"SE1"	,"SE2"	} )
Aadd(aPars, {"cTipoFin"		, cTipoFin	, SpEmpty						} )
Aadd(aPars, {"cSinal"		, cSinal	, Sp2String		,"+"	,"-"	} )
Aadd(aPars, {"cTipDoc"		, cTipDoc	, SpEmpty						} )
lRet := LocxParam("GRAVAFINA",aPars)

If lRet //(1)
	//³Carrega variaveis de acordo com a NF ³
	ASize(aFin,SnMaxFin)
	If cAliasC == "SF1"
		nMoedaNF  := SF1->F1_MOEDA
	Else
		nMoedaNF  := SF2->F2_MOEDA
	EndIf
	If aFin[SnMoedaFin]==Nil
	 	aFin[SnMoedaFin]:=nMoedaNF
	Endif
	nMoedaCor := aFin[SnMoedaFin]
	If aFin[ScNatureza]==Nil.OR.Empty(aFin[ScNatureza])
		If cAliasC == "SF1"
			cNatureza := SF1->F1_NATUREZ
		Else
			cNatureza := SF2->F2_NATUREZ
		EndIf
	 	aFin[ScNatureza]:= cNatureza
	Else
		cNatureza:=aFin[ScNatureza]
	Endif
	If cAliasC == "SF1"
		nTaxa	 := SF1->F1_TXMOEDA
		cNFiscal := SF1->F1_DOC
		cSerie   := SF1->F1_SERIE
	Else
		nTaxa	 := SF2->F2_TXMOEDA
		cNFiscal := SF2->F2_DOC
		cSerie   := SF2->F2_SERIE
	EndIf

	//³Verifica numero de vendedores do sistema³
	nVend := Fa440CntVen()

	//³Carrega o array com os vencimentos da duplicata³
	If Empty(aDuplOri)
		LxA103Dupl(nBaseDup,nMoedaCor,&(cPrefC+"_EMISSAO"),&(cPrefC+"_COND"),@aDuplOri,,,,,,aFin[ScNatureza])
	EndIf

	//Ponto de Entrada para generación de SE1/SE2 para ajustar el array de Financiero llamado por MATA475
	If cPaisLoc == "EUA" .And. ExistBlock("MATA475DP") .And. FunName() == 'MATA475'
		aDuplOri :=	ExecBlock("MATA475DP",.F.,.F.,{aDuplOri,aFin})
	EndIf

	//³Ponto de Entrada apos geracao de SE1/SE2
	cPe	:=	LocxPE(38)
	If !Empty(cPE)
		aDuplOri	:=	ExecBlock(cPE,.F.,.F.,{aDuplOri,aFin})
	EndIf
	//Adiantamentos do mexico chama com nBaseDup == 0 Portanto nao deve ser gerado SE1, apenas acionada a baixa
	If nBaseDup > 0
		//³ Gera titulo no financeiro
		If cAliasFin == "SE1"
			aRet	:=	GravaSE1(aDuplOri,aRecnoI,aFin)
		Else
			aRet	:=	GravaSE2(aDuplOri,Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_EMISSAO,SF2->F2_EMISSAO),aFin)
		Endif
		RecLock(aCfgNf[SAliasHead],.F.)
		If aCfgNf[SAliasHead] == "SF2"
			SF2->F2_VALFAT := aRet[2][1]
		Endif
		If cAliasC == "SF1"
			SF1->F1_PREFIXO := aRet[2][2]
			SF1->F1_DUPL    := aRet[2][3]
		Else
			SF2->F2_PREFIXO := aRet[2][2]
			SF2->F2_DUPL    := aRet[2][3]
		EndIf
		MsUnLock()
		//³ Gera titulo de recolhimento de impostos no financeiro
		If aCfgNf[ScAliasFin]=="SE2"
			GeraTitImp(cAliasC,aRet)
		Endif
		//³Ponto de Entrada apos geracao de SE1/SE2
		cPe	:=	LocxPE(37)
		If !Empty(cPE)
			ExecBlock(cPE,.F.,.F., aRet[1])
		EndIf
		If aCfgNF[ScCliFor] == "SA1"
			//³ Estorna os valores da Comissao.
			If ( SuperGetMv("MV_TPCOMIS")=="O" )
				For nX := 1 To Len(aRet[1])
					dbSelectArea("SE1")
					MsGoto(aRet[1][nX])
					Fa440CalcE(IIf(cTipoFin=="D","MATA100","MATA460") )
					//³Ponto de Entrada apos geracao das comissoes³
					cPe	:=	LocxPE(25)
					If !Empty(cPE)
						ExecBlock(cPE,.F.,.F., aRet[1])
					EndIf
				Next
			EndIf
		Endif
		//³ Executa a baixa de titulos com pagamento a vista
		BaixAutSE1(cCondicao,aRet[1],aCaixaFin,aCfgNf[ScAliasFin])
	EndIf
	//Compensación de anticipos
	If StrZero(aCfgNf[SnTipo],2) $ "|01|10|" .AND. cAliasFin $ "|SE1|SE2|" .AND. A410UsaAdi( cCondicao )
		If !(cPaisLoc $ "MEX|PER") //Para o Mexico a Baixa do RA eh feita sem compensacao, apenas baixa do titulo.
			a468NCompAd(, aRet[1], aRecnoSE1)
		ElseIf Len(aRecnoSE1) > 0
			//Baixa os adiantamentos para o Mexico
			LxBaixaAdt(aRecnoSE1,aCaixaFin,aCols,aHeader,cNatureza)
		EndIf
	EndIf
EndIf //lRet (1)
Return(.T.)


/*ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CTBILNF       º Leandro C.G. ³Microsiga º Data ³  28/12/01  º±±
±±ºDesc.     ³ Efetua atualizacoes Contabeis sobre uma NF   		      º±±
±±ºUso       ³ GRAVANFGERAL                                               º±±
Parametros
cAliasC		-	Alias de cabecalho de NF
cAliasI		- 	Alias de Itens de NF
nRecno 		-	Numero do registro no arquivo de cabecalho
aRecno		-	Numero dos registros nos arquivos de itens
aLpC		-	Array com o numero dos lanç. padrao referentes a Cabecalho
aLpI		-	Array com o numero dos lanç. padrao referentes a Itens
lVerCtbil	-	Indica se deve mostrar na tela o lanç contabil
lAglutina	-	Indica se deve aglutinar lanç. contabeis
*/
Function CtbilNF(cAliasC,cAliasI,nRecno,aRecno,aLpC,aLpI,lVerCtbil,lAglutina)
//Local aArea        := GetArea()
Local cArquivo     := ""  //Nome do arquivo da contabilidade
Local lCtbilC      := .F. //Indica se existe lanç padrao para cabecalho
Local lCtbilI      := .F. 	//Indica se existe lanç padrao para itens
Local lCtbil       := .F. //Indica se existe algum lanç padrao (tanto cabecalho quanto item)
Local lLanctOk     := .F. //Indica se foi lanç contabil foi gerado com sucesso
Local lRet         := .T. //Indica consistencia da funcao
Local lVer613      := .F. //Salida de NCP Devolucao/Beneficiamento ( Proveedor ) - Itens do Rateio
Local lVer641      := .F. //Entrada de NF Devolucao/Beneficiamento ( Cliente ) - Itens do Rateio
Local lVer651      := .F. //Entrada de NF Normal ( Fornec. ) - Itens do Rateio
Local lVer950      := .F. //Indica se deve ou nao gerar lanç. contabeis referentes a import.
Local lVer965      := .F.
Local lVer711      := .F.
Local aPars        := {}  //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nI           := 0
Local aCtbDia      := {}

Private nHdlPrv	   := 0	    //Guarda a evolucao da funcao HeadProva
Private cLote      := ""  	//Lote utilizado nas rotinas contabeis
Private nTotalLcto := 0	    //Acumula totais dos lanç. padores de cada item

Default nRecno      := 0
Default aRecno      := {}
Default aLpC		:= {}
Default aLpI		:= {}
Default lVerCtbil   := .F.
Default lAglutina   := .F.

//³Consistindo parametros
Aadd(aPars, {"nRecno"	, nRecno	, SpEmpty						} )
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"aLpC"		, aLpC		, SpValType		,"A"			} )
Aadd(aPars, {"aLpI"		, aLpI		, SpValType		,"A"			} )
lRet := LocxParam("CTBILNF",aPars)

If lRet //(1)
	//³Verifica existencia dos lanç. contabeis recebidos e dos lanç. fixos (SDE)
	IIf(!Empty(aLpC), Aeval(aLpC, { |x| lCtbilC := IIf(!lCtbilC,VerPadrao(x),lCtbilC) }), )
	IIf(!Empty(aLpI), Aeval(aLpI, { |x| lCtbilI := IIf(!lCtbilI,VerPadrao(x),lCtbilI) }), )
	DBSelectArea(cAliasC)
	MSGoto(nRecno)
	//Confirma posicionamento do arquivo de cabecalho
	If Recno() != nRecno
		lCtbilC := .F.
	EndIf
	lVer641	:= cAliasC == "SF1" .AND. VerPadrao('641') .AND. Recno() == nRecno .AND. SF1->F1_TIPO $ 'BD'		// Entrada de NF Devolucao/Beneficiamento ( Cliente ) - Itens do Rateio
	lVer651	:= cAliasC == "SF1" .AND. VerPadrao('651') .AND. Recno() == nRecno .AND. !(SF1->F1_TIPO $ 'BD')	// Entrada de NF Normal ( Fornec. ) - Itens do Rateio
	lVer950 := cAliasC == "SF1" .AND. VerPadrao('950') .AND. Recno() == nRecno .AND. AllTrim(SF1->F1_TIPO_NF) $ "123456789AB" .AND. GetMV("MV_EASY") == "S"
	lVer965 := cAliasC == "SF1" .AND. VerPadrao('965') .AND. Recno() == nRecno .AND. AllTrim(SF1->F1_TIPO_NF) $ "123456789AB" .AND. GetMV("MV_EASY") == "S"
	lVer613 := cAliasC == "SF2" .AND. VerPadrao('613') .AND. Recno() == nRecno .AND. SF2->F2_TIPO $ 'BD'
	lVer711 := Iif (Len(aLpC) == 1, Iif(aLpC[1] == "711", .T., .F.) , .F.)
	lCtbil  := lCtbilC .OR. lCtbilI .OR. lVer641 .OR. lVer651 .OR. lVer965 .Or. lVer711
	//³ Inicializa o cabecalho dos lanç. Contabeis OnLine
	If  lCtbil
		DBSelectArea("SX5")
		MSSeek(xFilial()+IIf(cAliasC=="SF1","09COM","09FAT"), .F.)
		cLote 	 := IIf(Found(),Trim(X5DESCRI()),IIf(cAliasC=="SF1","COM ","FAT "))
		If Empty(nHdlPrv) .OR. nHdlPrv < 0
			nHdlPrv  := HeadProva(cLote,FunName(),Subs(cUsuario,7,6),@cArquivo)
		Endif
		If nHdlPrv <= 0
			Help(" ",1,"A100NOPRV")
			lRet := .F.
		EndIf
	EndIf
	If lRet //(2)
		//³ Gera lanç contabil  a partir de cabecalho
		If lCtbilC
			//³aLpC e um array com o numero dos	lanç. padrao referentes ao Cabecalho da NF  ³
			//³Para cada um dos lanç. padrao roda-se a funcao "DetProva" atraves do 		³
			//³comando "Aeval" onde "x" sera o numero de cada lanç padrao
			Aeval(aLpC, { |x| IIf((x!="950".OR.lVer950).AND.VerPadrao(x), nTotalLcto+=DetProva(nHdlPrv,x,FunName(),cLote), ) })
		EndIf
		//³ Gera lanç contabil  a partir de itens
		If lCtbilI .AND. !Empty(aRecno)
			nI := 0
			For nI := 1 to Len(aRecno)
				DBSelectArea(cAliasI)
				MSGoto(aRecno[nI,1])
				SB1->(dbSetOrder(1))
				//-- Posiciona B1 para lancamentos padrao
				If (cAliasI)->(FieldPos(Substr(cAliasI,2,2) + "_COD")) > 0
					SB1->(dbSeek(xFilial("SB1")+(cAliasI)->&(Substr(cAliasI,2,2) + "_COD")))
				ElseIf (cAliasI)->(FieldPos(Substr(cAliasI,2,2) + "_PRODUTO")) > 0
					SB1->(dbSeek(xFilial("SB1")+(cAliasI)->&(Substr(cAliasI,2,2) + "_PRODUTO")))
				ElseIf (cAliasI)->(FieldPos(cAliasI + "_PRODUT")) > 0
					SB1->(dbSeek(xFilial("SB1")+(cAliasI)->&(cAliasI + "_PRODUT")))
				EndIf
				//Confirma posicionamento do arquivo
				If Recno() == aRecno[nI,1]
					//³aLpI e um array com o numero dos lanç. padrao referentes aos itens da Nota  ³
					//³Para cada um dos lanç. padrao roda-se a funcao "DetProva" atraves do 	   ³
					//³comando "Aeval" onde "x" sera o numero de cada lanç padrao
					Aeval(aLpI, { |x| IIf(VerPadrao(x), nTotalLcto+=DetProva(nHdlPrv,x,FunName(),cLote), ) })
				EndIf
			Next nI
		EndIf
		//³ Gera lanç contabil  a partir de itens de importacao
		If lCtbilI .AND. lVer965 .AND. !Empty(aRecIMP)
			nI := 0
			cAliasImp	:=	IIf(GetNewPar("MV_CUSTIMP","1") == "1",'SD3','SWN')
			nPosRec		:=	iF(cAliasImp == 'SD3',1,2)
			For nI := 1 to Len(aRecIMP)
				SWN->(	MSGoto(aRecIMP[nI][2]))
				SD3->(	MSGoto(aRecIMP[nI][1]))
				SB1->(DbSetOrder(1))
				SB1->(DbSeek(xFilial("SB1")+SWN->WN_PRODUTO))
				DbSelectArea(cAliasImp)
				//Confirma posicionamento do arquivo
				If Recno() == aRecIMP[nI][nPosRec]
					//³aLpI e um array com o numero dos lanç. padrao referentes aos itens da Nota  ³
					//³Para cada um dos lanç. padrao roda-se a funcao "DetProva" atraves do 	   ³
					//³comando "Aeval" onde "x" sera o numero de cada lanç padrao
					nTotalLcto+=DetProva(nHdlPrv,'965',FunName(),cLote)
				EndIf
			Next nI
		EndIf
		//³Gera lanç. contabeis dos rateios por centro de custo sobre o arquivo SDE
	   	If cAliasI == "SD1"
			dbSelectArea("SF1")
			MsGoto(nRecno)
			If Recno() == nRecno .AND. (lVer641 .OR. lVer651)
				dbSelectArea("SD1")
				dbSetOrder(1)
				If dbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
					While !Eof() .AND. ;
						xFilial("SD1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA == SF1->F1_FILIAL+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA
						dbSelectArea("SDE")
						dbSetOrder(1)
						If dbSeek(xFilial("SDE")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_ITEM)
							While !Eof() .AND. ;
								SDE->DE_FILIAL+SDE->DE_DOC+SDE->DE_SERIE+SDE->DE_FORNECE+SDE->DE_LOJA+SDE->DE_ITEMNF == xFilial("SDE")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_ITEM
								//³ lanç contabil 641- Devolucao / Beneficiamento
								//³ lanç contabil 651- NF Entrada- Itens
								nTotalLcto	+= DetProva(nHdlPrv,IIf(lVer641,'641','651'),FunName(),cLote)
								dbSelectArea("SDE")
								dbSkip()
							End
						Endif
						dbSelectArea("SD1")
						dbSkip()
					End
				EndIf
			EndIf
		ElseIf cAliasI == "SD2"
			CTBOFFLND2(nRecno,lVer613,@nTotalLcto,FunName(),cLote)
		EndIf
		//³Finalizando lanç. contabeis
		If  lCtbil .AND. nHdlPrv > 0 .AND. nTotalLcto > 0
			SaveInter()
			RodaProva(nHdlPrv, nTotalLcto)
			If ( UsaSeqCor() )
				If cAliasC == "SF1"
					aCtbDia := {{"SF1",SF1->(RECNO()),SF1->F1_DIACTB,"F1_NODIA","F1_DIACTB"}}
				ElseIf cAliasC == "SF2"
					aCtbDia := {{"SF2",SF2->(RECNO()),SF2->F2_DIACTB,"F2_NODIA","F2_DIACTB"}}
				EndIf
			Else
	    		aCtbDia := {}
			EndIF
			lLanctOk := cA100Incl(cArquivo,nHdlPrv,3,cLote,lVerCtbil,lAglutina,,If(aCfgNf[SaPergs][SlCtbEmiss],&(cAliasC+"->"+PrefixoCpo(cAliasC)+"_EMISSAO"),dDataBase ),,,,aCtbDia)
			If lLanctOk .AND. nRecno > 0
				RecLock(cAliasC,.F.)
				Replace &(cAliasC+"->"+PrefixoCpo(cAliasC)+"_DTLANC") With If(aCfgNf[SaPergs][SlCtbEmiss],&(cAliasC+"->"+PrefixoCpo(cAliasC)+"_EMISSAO"),dDataBase)
				MsUnLock()
				If lVer965 .AND. !Empty(aRecIMP) .AND. GetNewPar("MV_CUSTIMP","1") == "1"
					For nI:= 1 To Len(aRecIMP)
						SD3->(MsGoTo(aRecIMP[nI][1]))
						RecLock('SD3',.F.)
							Replace D3_DTLANC With dDataBase
						MsUnLock()
					Next
				Endif
			Endif
			RestInter()
		EndIf
	EndIf //lRet  (2)
EndIf //lRet (1)
Return(lRet)

/*ºPrograma  ³GRAVAIMPOSTO  º Leandro C.G. ³Microsiga º Data ³  10/01/02  º±±
±±ºDesc.     ³ Efetua atualizacoes de impostos sobre uma NF    			  º±±
±±ºUso       ³ GENERICO                                                   º±±
param.
cAliasC		-	Alias de cabecalho de NF
cAliasI		- 	Alias de Itens de NF
cAliasCF	- 	Alias do Cliente ou fornec. (SA1/SA2)
nRecno 		-	Numero do registro no arquivo de cabecalho
aRecno		-	Numero dos registros nos arquivos de itens
aCpItens    -   Campos dos itens (posicoes [2] do aHeader - usar funcao HeaderCpos)
aCitens     -   Conteudo dos itens da NF (aCols)
cTipDoc 	- 	Tipo de documento da NF
			  	N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
lFinaliza   -   Indica se deve finalizar o MatxFis()
*/
Function GravaImposto(cAliasC,cAliasI,cAliasCF,aCpItens,aCitens,cTipDoc,nRecnoC,aRecnoI,lFinaliza)
Local cPrefix	:= IIf(!Empty(cAliasC),cAliasC+"->"+PrefixoCpo(cAliasC),"")  //Prefixo do arquivo de cabecalho
Local lRet		:= .T.														//Indica consistencia das rotinas
Local aPars		:= {}														    //Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local nZ		:= 0
//Local nC		:= 0
Local nMoeda	:= 1
Local cPe74		:= LocxPE(74)
Local lTotal	:= SuperGetMV("MV_CUSDESP",.F.,.F.)
Local nPosPed	:= 0
Local nPosCF	:= 0
Local nCodPro   := 0
//Local lPedido 	:= .F.
Local aAreaSB1	:= SB1->(GetArea())
Local cFilSB1   := xFilial("SB1")
//³Variaveis utilizadas em sub-rotinas³
Private nValFrete	:= 0
Private nValDesc	:= 0
Private aImpS		:= {}
Private cVenda		:= "NORMAL"
Private cNFiscal	:= ""
Private cSerie		:= ""
Private l103Class	:= .F.
Private lInclui		:= .T.
Private aRecSF3		:= {}
Private Inclui		:= .T.
Private cTipo		:= cTipDoc
Private	nValNTrib	:= 0
Private	nValTara	:= 0
If ( Type("l103Auto") == "U" )
	Private l103Auto	:= lLocxAuto
EndIf

Default lFinaliza := .T.

dbSelectArea("SB1")
SB1->(dbSetOrder(1)) //B1_FILIAL + B1_COD
//³Consistindo parametros³
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String		,"SF1"	,"SF2"	} )
Aadd(aPars, {"aRecnoI"	, aRecnoI	, SpEmpty						} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String		,"SD1"	,"SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String		,"SA1"	,"SA2"	} )
Aadd(aPars, {"aCitens"	, aCitens	, SpEmpty						} )
Aadd(aPars, {"aCpItens"	, aCpItens	, SpEmpty						} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty						} )
Aadd(aPars, {"nRecnoC"	, nRecnoC	, SpEmpty						} )
lRet := LocxParam("GRAVAIMPOSTO",aPars)

If lRet //(1)
	//³Posicionando arquivo de cabecalho³
	&(cAliasC+"->(DbGoto("+AllTrim(Str(nRecnoC))+"))")

	//³Carregando variaveis utilizadas em sub-rotinas³
	cNFiscal := &(cPrefix+"_DOC")
	cSerie   := &(cPrefix+"_SERIE")
	cEspecie := &(cPrefix+"_ESPECIE")

	//³Inicializando variaveis para calculos de impostos
	If !MaFisFound()
		If !InicializaFis(MontaHeader(aCpItens),aCItens,cAliasC,cAliasI,cAliasCF,cTipDoc)
			lRet := .F.
		EndIf
	Endif
	If lRet //(2)
		nPosPed	:= Ascan(aHeader,{|x| Alltrim(x[2])=="D1_PEDIDO"})
		nPosCF	:= Ascan(aHeader,{|x| Alltrim(x[2])=="D1_CF"})
		nCodPro := Ascan(aHeader,{|x| Alltrim(x[2])=="D1_COD"}) //Código de Producto
		//³Executando atualizacoes de impostos para cada item
		If l103Auto .and. !lFacImport .And. !lTotal .And. (aAutoItens[1]!=Nil .And. Ascan(aAutoItens[1],{|x| Subs(x[1],4,6) $ "BASIMP|ALQIMP|VALIMP" }) > 0 )
			LxGrvAutoItem(cAliasI,aRecnoI)
	 	Else
			For nZ	:=	1	To Len(aRecnoI)
				If aRecnoI[nZ,1] # 0
					&(cAliasI+"->(DbGoTo("+AllTrim(Str(aRecnoI[nZ,1]))+"))")
					If cPaisLoc == "COL"
						xGrvImpCol(cAliasC, nPosPed, nCodPro, nPosCF, cFilSB1, aCols, nZ)
					EndIf
					RecLock(cAliasI,.F.)
						If cPaisLoc == "ARG" .And. cTipo == "D" .And. GetNewPar('MV_DESCSAI','1') =='2' .And. ALLTRIM(SF1->F1_ESPECIE) $ "RFD"
							MaFisWrite(2,cAliasI,nZ,(cAliasI $ 'SD1'),aCfgNF[SnTipo]>49)
						else
							MaFisWrite(2,cAliasI,nZ,(cAliasI $ 'SD2'),aCfgNF[SnTipo]>49)
						endif
					MsUnlock()
				Endif
			Next
        EndIf
		//³Para os remitos atualiza as referencias fiscais nao contempladas
		If aCfgNF[SnTipo] > 49 .And. cAliasC == 'SF2'
			MaFisAlt('NF_SERIENF',SF2->F2_SERIE)
			MaFisAlt('NF_UFDEST' ,SF2->F2_EST)
		ElseIf aCfgNF[SnTipo] > 49 .And. cAliasC == 'SF1'
			MaFisAlt('NF_SERIENF',SF1->F1_SERIE)
		EndIf
		//³Executando atualizacoes de impostos por cabecalho
		RecLock(cAliasC,.F.)
		nMoeda := &(cPrefix+"_MOEDA")
		If !(cPaisLoc $ "RUS|ARG")
			LocXImpNF(cAliasC)
		Endif
		MaFisWrite(2,cAliasC,,,aCfgNF[SnTipo]>49)
		If  cAliasC == 'SF2'
			(cAliasC)->F2_MOEDA := nMoeda
			If Empty((cAliasC)->F2_SEGURO)
			   (cAliasC)->F2_SEGURO := M->F2_SEGURO
			Endif
			If Empty((cAliasC)->F2_FRETE)
			   (cAliasC)->F2_FRETE := M->F2_FRETE
			Endif
			If Empty((cAliasC)->F2_DESPESA)
			   (cAliasC)->F2_DESPESA := M->F2_DESPESA
			Endif
			If Empty((cAliasC)->F2_VALBRUT)
			   (cAliasC)->F2_VALBRUT := M->F2_VALBRUT
			Endif
			If Empty((cAliasC)->F2_DESCONT)
			   (cAliasC)->F2_DESCONT := M->F2_DESCONT
			Endif
		ElseIf cAliasC == 'SF1'
			(cAliasC)->F1_MOEDA := nMoeda
			If AllTrim(cEspecie) $ "NDP|NCI|NCP|NDI" .And. !Empty(cPe74)
				(cAliasC)->F1_PROVENT := MaFisRet(,"NF_PROVENT")
			EndIf
			If cPaisLoc == "ARG" .And. cTipo == "D" .And. GetNewPar('MV_DESCSAI','1') =='2' .And. ALLTRIM(SF1->F1_ESPECIE) $ "RFD"
				(cAliasC)->F1_VALMERC := (M->F1_VALMERC - M->F1_DESCONT)
			EndIf
		EndIf
		MsUnlock()
		If lFinaliza
			MaFisEnd()
		Endif
	EndIf //lRet (2)
EndIf //lRet (1)
RestArea(aAreaSB1)
Return(lRet)

/*ºPrograma  ³InicializaFis º Leandro C.G. ³Microsiga º Data ³  20020111  º±±
±±ºDesc.     ³ Efetua atualizacoes de impostos sobre uma NF  		      º±±
±±ºUso       ³ GENERICO                                                   º±±
Parametros
aH      	- aHeader
aC      	- aCols
cAliasC 	- Alias do Cabecalho da NF
cAliasI 	- Alias dos Itens da NF
cAliasCF	- Alias do cliente ou fornec. (SA1/SA2)
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
*/
Function InicializaFis(aH,aC,cAliasC,cAliasI,cAliasCF,cTipDoc,lRecalc,lVisual)
Local lRet  	:= .T.		//Indica consistencia da funcao
Local aPars		:= {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
//Local cAOri		:=	""
//Local cAval		:=	""
//Local cNfOri	:=	""
//Local nX		:=	0
Local nPosTes	:= 0
Local nPosCFO	:= 0
Local nPosCod   := 0
Local nPosItem  := 0
Local nPosQtd   := 0
Local nI		:= 0
Local cNumDesp  := ""
Local cOrigem   := ""
Local aArea 	:= {}
Local aSEU 		:= {}
Local cChaveSD1 := ""
Local aSD1 		:= {}
Local lW9Proce	:= SW9->(FieldPos("W9_PROCE")) > 0
Private n 		:= 0
DEFAULT lRecalc	:=	.F.
DEFAULT lVisual	:=	.F.

//³Consistindo Parametros
Aadd(aPars, {"aH"		, aH		, SpEmpty					} )
Aadd(aPars, {"aC"		, aC		, SpEmpty					} )
Aadd(aPars, {"cAliasC"	, cAliasC	, Sp2String	, "SF1"	, "SF2"	} )
Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars, {"cAliasCF"	, cAliasCF	, Sp2String	, "SA1"	, "SA2"	} )
Aadd(aPars, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
Aadd(aPars, {"lRecalc"	, lRecalc	, SpValType,	"L"		} )
lRet := LocxParam("INICIALIZAFIS",aPars)

If lRet //(1)
	//³Inicializando Varivaeis
	If lVisual .AND. cAliasI=="SD2" .AND. GetNewPar('MV_DESCSAI','1') =='2' .AND. SF2->F2_DESCONT > 0
		nPosUni:=Ascan(aH,{|x| Alltrim(x[2])=="D2_PRCVEN"})
		nPosDes:=Ascan(aH,{|x| Alltrim(x[2])=="D2_DESCON"})
		nPosTot:=Ascan(aH,{|x| Alltrim(x[2])=="D2_TOTAL" })
		nPosQtd:=Ascan(aH,{|x| Alltrim(x[2])=="D2_QUANT" })

		For nI:= 1 To Len(aC)
			aC[nI][nPosTot]	+=	IIf(Upper(FunName())=="MATA462N" .And. SF2->F2_DESCCAB > 0,(SF2->F2_DESCCAB/Len(aC)),aC[nI][nPosDes])
			aC[nI][nPosUni]	:=	Round(aC[nI][nPosTot]/aC[nI][nPosQtd],MsDecimais(SF2->F2_MOEDA))
		Next
	Endif
	If lVisual .AND. cAliasI=="SD1" .AND. GetNewPar('MV_DESCSAI','1') =='2' .AND. SF1->F1_DESCONT > 0
		nPosUni:=Ascan(aH,{|x| Alltrim(x[2])=="D1_VUNIT"})
		nPosDes:=Ascan(aH,{|x| Alltrim(x[2])=="D1_VALDESC"})
		nPosTot:=Ascan(aH,{|x| Alltrim(x[2])=="D1_TOTAL" })
		nPosQtd:=Ascan(aH,{|x| Alltrim(x[2])=="D1_QUANT" })

		For nI:= 1 To Len(aC)
			aC[nI][nPosTot]	+=	IIf( Upper(FunName())=="MATA462DN" .And. SF1->F1_DESCONT > 0 .And. !(cPaisLoc $ "PER|MEX"), aC[nI][nPosDes] , 0 )
			aC[nI][nPosUni]	:=	Round( aC[nI][nPosTot] / aC[nI][nPosQtd] , MsDecimais(SF1->F1_MOEDA) )
		Next
	Endif
	MaFisIni('      ',' ',IIf(cAliasCF=="SA1","C","F"),cTipDoc,Nil,MaFisRelImp("MT100",{cAliasC,cAliasI}),,.F.,,,StrZero(aCfgNF[SnTipo],2))
	If lFacImport .AND. (l103Class .OR. (l103Visual .AND. Empty(SF1->F1_STATUS)))
		nPosTes:=Ascan(aH,{|x| Alltrim(x[2])=="D1_TES"})
		nPosCFO:=Ascan(aH,{|x| Alltrim(x[2])=="D1_CF"})
		nPosCod:=Ascan(aH,{|x| Alltrim(x[2])=="D1_COD"})
		nPosItem:=Ascan(aH,{|x| Alltrim(x[2])=="D1_ITEM"})
		nPosNumDesp:=Ascan(aH,{|x| Alltrim(x[2])=="D1_NUMDESP"})
		nPosOrigem :=Ascan(aH,{|x| Alltrim(x[2])=="D1_ORIGEM"})
		If SF1->F1_TIPO_NF $ "5678"
			aSD1:=SD1->(GetArea())
			cChaveSD1:=xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA
			nI:=0
			If SD1->(DbSeek(cChaveSD1))
				While (SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA)==cChaveSD1
					If SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
						If !Empty(SYD->YD_TES)
							If SF4->(MSSeek(xFilial("SF4")+SYD->YD_TES))
								SW6->(DbSetOrder(1))
								If SW6->(MsSeek(xFilial("SW6")+SF1->F1_HAWB)) .AND. (nPosNumDesp > 0)
	                            	cNumDesp := SW6->W6_DI_NUM
	                            EndIf
	                            SW9->(DbSetOrder(3))
								If SW9->(MsSeek(xFilial("SW9")+SF1->F1_HAWB)) .AND. (nPosOrigem > 0)
	                            	cOrigem := Iif(lW9Proce,SW9->W9_PROCE,"")
								EndIf
								nI:=Ascan(aC,{|x| Alltrim(x[nPosCod])==Alltrim(SD1->D1_COD) .AND. x[nPosItem]==SD1->D1_ITEM})
								If nI>0
									If Empty(aC[nI,nPosTes])
										aC[nI,nPosTes]:=SF4->F4_CODIGO
										aC[nI,nPosCFO]:=SF4->F4_CF
										cPe	:=	LocxPE(40)
										If !Empty(cPe)
											aC[nI,nPosTes] := Execblock(cPE,.F.,.F.)
											aC[nI,nPosCFO]:=SF4->F4_CF
										EndIf
									Endif
									If nPosNumDesp > 0
										aC[nI,nPosNumDesp]:= cNumDesp
									EndIf
									If nPosOrigem > 0
										aC[nI,nPosOrigem] := cOrigem
									EndIf
								Endif
							EndIf
			 			Endif
					Endif
					SD1->(DbSkip())
				End
				SD1->(RestArea(aSD1))
			Endif
		Else
			If SF1->F1_TIPO_NF=="9"
				If SuperGetMV("MV_DESPSD1",,"N")=="S"
					For nI:=1 to Len(aC)
						If SD1->(DbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aC[nI][2]+aC[nI][1]))
							SF4->(DbSetOrder(1))
							SF4->(DbSeek(xFilial("SF4")+SD1->D1_TESDES))
							aC[nI,nPosTes]:=SD1->D1_TESDES
							aC[nI,nPosCFO]:=SF4->F4_CF
						Endif
					Next
					LocxInsDes(aH,aC)
				Endif
			Else
				SW6->(DbSetOrder(1))
				If SW6->(MsSeek(xFilial("SW6")+SF1->F1_HAWB)) .AND. (nPosNumDesp > 0)
					cNumDesp := SW6->W6_DI_NUM
				EndIf
				SW9->(DbSetOrder(3))
				If SW9->(MsSeek(xFilial("SW9")+SF1->F1_HAWB)) .AND. (nPosOrigem > 0)
					cOrigem := Iif(lW9Proce,SW9->W9_PROCE,"")
				EndIf
				If SuperGetMV("MV_DESPSD1",,"N")=="S"
					If SD1->(FieldPos("D1_TESDES")) > 0
						SD1->(DbSetOrder(1))
						For nI:=1 to Len(aC)
							If SD1->(DbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aC[nI][2]+aC[nI][1]))
								SF4->(DbSetOrder(1))
								SF4->(DbSeek(xFilial("SF4")+SD1->D1_TESDES))
								aC[nI,nPosTes]:=SD1->D1_TESDES
								aC[nI,nPosCFO]:=SF4->F4_CF
								cPe	:=	LocxPE(40)
								If !Empty(cPe)
									aC[nI,nPosTes] := Execblock(cPE,.F.,.F.)
									aC[nI,nPosCFO]:=SF4->F4_CF
								EndIf
								If nPosNumDesp > 0
									aC[nI,nPosNumDesp]:= cNumDesp
								EndIf
								If nPosOrigem > 0
									aC[nI,nPosOrigem] := cOrigem
								EndIf
							EndIf
						Next nI
					Else
						cFilSWW:=xFilial("SWW")
						nI:=0
						If SWW->(MsSeek(cFilSWW+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
							While ! SWW->(EOF()).AND.SWW->WW_FILIAL==cFilSWW .AND.;
								SWW->WW_NF_COMP == SF1->F1_DOC     .AND.;
								SWW->WW_SE_NFC  == SF1->F1_SERIE   .AND.;
								SWW->WW_FORNECE == SF1->F1_FORNECE .AND.;
								SWW->WW_LOJA    == SF1->F1_LOJA
								SWD->(DbSetOrder(3))
								If SWD->(DbSeek(xFilial("SWD")+Left(SWW->WW_DESPESA,3)+SWW->WW_NF_COMP+SWW->WW_HAWB))
									For nI:=1 to Len(aC)
										SYB->(DbSetOrder(1))
										If SYB->(MSSeek(xFilial("SYB")+SWD->WD_DESPESA))
											If aC[nI,nPosCod] == SYB->YB_COD_I
												SF4->(DbSetOrder(1))
												SF4->(DbSeek(xFilial("SF4")+SWD->WD_TES))
												aC[nI,nPosTes]:=SWD->WD_TES
												aC[nI,nPosCFO]:=SF4->F4_CF
											Endif
										EndIf
										If nPosNumDesp > 0
											aC[nI,nPosNumDesp]:= cNumDesp
										EndIf
										If nPosOrigem > 0
											aC[nI,nPosOrigem] := cOrigem
										EndIf
									Next nI
								Endif
								SWW->(DbSkip())
							End
						Endif
					EndIf
				Else
					SD1->(DbSetOrder(1))
					SF4->(DbSetOrder(1))
					For nI:=1 to Len(aC)
						If SD1->(DbSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aC[nI][2]+aC[nI][1]))
							SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
							SF4->(DbSeek(xFilial("SF4")+SYD->YD_TES))
							aC[nI,nPosTes]:=SYD->YD_TES
							aC[nI,nPosCFO]:=SF4->F4_CF
							cPe	:=	LocxPE(40)
							If !Empty(cPe)
								aC[nI,nPosTes] := Execblock(cPE,.F.,.F.)
								aC[nI,nPosCFO]:=SF4->F4_CF
							EndIf
							If nPosNumDesp > 0
								aC[nI,nPosNumDesp]:= cNumDesp
							EndIf
							If nPosOrigem > 0
								aC[nI,nPosOrigem] := cOrigem
							EndIf
						EndIf
					Next nI
				EndIf
			EndIf
		EndIf
		MaColsToFis(aH,aC,,"MT100",lRecalc,lVisual)
		If Type("oGetDados")=="O"
			oGetDados:nMax:=Len(aC)
		EndIf
	Else
		If FunName() == "MATA468N"   //Atualizar os dados da matxfis quando a execucao for por programas externos
			MaColsToFis(aH,aC,,"MT100",lRecalc,lVisual)
		Endif
	Endif
	If lFacImport
		MaFisAlt('NF_SERIENF',cSerie) //Forzar a serie na MATXFIS paar que seja gravado corretamente
		If SF1->F1_TIPO_NF$"9"
			MaFisAlt('NF_FRETE',0)
			MaFisAlt('NF_SEGURO',0)
			MaFisAlt('NF_DESPESA',SF1->F1_DESPESA)
			MaFisAlt('NF_DESCONTO',SF1->F1_DESCONT)
			//#PORTUGAL#
			/*If cPaisLoc == "PTG"
				MaFisAlt('NF_DESNTRB',SF1->F1_DESNTRB)
				MaFisAlt('NF_TARA',SF1->F1_TARA)
			Endif*/
		ElseIf SF1->F1_TIPO_NF $ "AB"
			MaFisAlt('NF_DESPESA',0)
			//#PORTUGAL#
			/*If cPaisLoc == "PTG"
				MaFisAlt('NF_DESNTRB',SF1->F1_DESNTRB)
			Endif*/
		Else
			MaFisAlt('NF_DESPESA',0)
			MaFisAlt('NF_FRETE',0)
			//#PORTUGAL#
			/*If cPaisLoc == "PTG"
				MaFisAlt('NF_DESNTRB',SF1->F1_DESNTRB)
				MaFisAlt('NF_TARA',SF1->F1_TARA)
			Endif*/
		Endif
		Eval(bDoRefresh)
	Else
		If SF1->F1_TIPODOC=="10"
			If SIX->(DbSeek("SEU7"))
				aArea:=GetArea()
				DbSelectArea("SEU")
				aSEU:=GetArea()
				DbSetOrder(7)
				If DbSeek(xFilial("SEU")+SF1->F1_FORNECE+SF1->F1_LOJA+Padr(SF1->F1_DOC,Len(EU_NRCOMP))+SF1->F1_SERIE)
					If Type("CCXCAIXA")<>"U"
						cCxCaixa:=SEU->EU_CAIXA
					Endif
					If Type("NCXVALOR")<>"U"
						nCxValor:=SEU->EU_VALOR
					Endif
					If Type("CCXBENEF")<>"U"
						cCxBenef:=SEU->EU_BENEF
					Endif
					If Type("CCXHISTOR")<>"U"
						cCxHistor:=SEU->EU_HISTOR
					Endif
					If Type("CCXADIAN")<>"U"
						cCxAdian:=SEU->EU_NROADIA
					Endif
					If Type("CCXRENDIC")<>"U"
						cCxRendic:=SEU->EU_NRREND
					Endif
				Endif
				RestArea(aSEU)
				RestArea(aArea)
			Endif
		Endif
	Endif
EndIf //lRet (1)
Return(lRet)

/*ºPrograma  ³BUSCAIDENTB6  º Leandro C.G. ³Microsiga º Data ³  16/01/02  º±±
±±ºDesc.     ³ Busca o campo XX_IDENB6 na Nota Original para uma Devolucaoº±±
±±ºUso       ³ GENERICO                                                   º±±
Parametros
cAliasI - Alias do Item da NF de Devolucao
Obs.: Campos referentes ao Alias devem estar declarados em variaveis de memoria
*/
Function BuscaIdentB6(cAliasI)
Local cIdentB6 := "" 																	//Codigo sequencial no arquivo SB6
Local cAliasO  := IIf(!Empty(cAliasI),IIf(cAliasI=="SD1","SD2","SD1"),"")				//Alias do item da Nota de Origem
Local cPref		:= IIf(!Empty(cAliasI),"M->"+PrefixoCpo(cAliasI),"")
Local cCF		:= IIf(!Empty(cAliasI),IIf(cAliasI=="SD1","_FORNECE","_CLIENTE"),"")	//Complemento dos campos de acordo com cliente ou fornec. para nota de devolucao
Local cCFo		:= IIf(!Empty(cAliasI),IIf(cAliasI=="SD1","_CLIENTE","_FORNECE"),"")	//Complemento dos campos de acordo com cliente ou fornec. para nota de origem
Local cNfOri,cSeriOri,cItOri,cCliFor,cCod,cLoja  										//Conteudo de Campos para posicioanr a Nota Original

//³Verifica se o TES e de Devolucao³
If !Empty(cAliasI) .AND. (cAliasI == "SD1" .OR. cAliasI == "SD2") .AND.;
	Posicione('SF4',1,xFilial('SF4')+&(cPref+"_TES"),'F4_PODER3') == "D"

	//³Montando campos necessarios para chave de posicionamento da nota original³
    cNfori 		:= &(cPref+"_NFORI") 	+ Space(TamSX3(PrefixoCpo(cAliasO)+"_DOC")[1]-Len(&(cPref+"_NFORI")))
    cSeriOri 	:= &(cPref+"_SERIORI") 	+ Space(TamSX3(PrefixoCpo(cAliasO)+"_SERIE")[1]-Len(&(cPref+"_SERIORI")))
	cCliFor     := &(cPref+cCF) 		+ Space(TamSX3(PrefixoCpo(cAliasO)+cCFo)[1]-Len(&(cPref+cCF)))
	cLoja 		:= &(cPref+"_LOJA")	  	+ Space(TamSX3(PrefixoCpo(cAliasO)+"_LOJA")[1]-Len(&(cPref+"_LOJA")))
	cCod 		:= &(cPref+"_COD")		+ Space(TamSX3(PrefixoCpo(cAliasO)+"_COD")[1]-Len(&(cPref+"_COD")))
	cItOri 		:= &(cPref+"_ITEMORI")	+ Space(TamSX3(PrefixoCpo(cAliasO)+"_ITEM")[1]-Len(&(cPref+"_ITEMORI")))

	//³Posicionando a Nota Original³
	&( cAliasO + "->(DBSetOrder(" + IIf(cAliasO=="SD1","1","3") + "))" )
	If &(cAliasO+"->(MSSeek('"+xFilial(cAliasO)+cNfOri+cSeriOri+cCliFor+cLoja+cCod+cItOri+"',.F.))")
		cIdentB6 := &(cAliasO+"->"+PrefixoCpo(cAliasO)+"_IDENTB6")
	EndIf
EndIf
Return(cIdentB6)

/*
±±ºPrograma  ³CARREGABOTOES ºLeandro C.G.  ³Microsiga º Data ³  05/02/02  º±±
±±ºDesc.     ³Cria os botoes necessarios para a tela de acordo com o tipo º±±
±±º			 ³de NF junto as suas respectivas funcoes		  			  º±±
±±ºUso       ³MONTACFGNF                                                  º±±
*/
Function CarregaBotoes(nTipo)
Local bPMSDlgNF	:= {|| PmsVldNf() }
Local aRet		:= {}
Local lRet      := .F.
Local lIsRemito := .F.
Local cTipDoc   := ""
Local aBtnDocOri:= {}	// Botoes para documento de origem
Local nEscAvs			// Retorno do Aviso
Local aBtnDOChi := {} //Botones para documento origen Chile
Local nChiOp // Regreso de aviso Chile

Default nTipo   := 0

// Verifica se o documento e um remito
lIsRemito := IsRemito(1,"'"+StrZero(nTipo,2)+"'")

Do Case
	//³Botoes para Notas de Entrada quando nao for devolucao³
	Case StrZero(nTipo,2) $ "10|60"
		AAdd(aRet ,	{'PEDIDO'		,{|| lReajuste:=.T.,LxA103ForF4(Nil,lIsRemito),ModxAtuObj()}	,STR0077,STR0214,"3"	})	//'Pedidos de Compras [F5]' ## "Ped Comp"
		AAdd(aRet ,	{'PEDIDO'		,{|| lReajuste:=.T.,LxA103ItemPC(),ModxAtuObj()}	,STR0078,STR0215,"3"	})	 			//'Pedidos de Compras( por item ) [F6]'##"Item PC"
		AAdd(aRet , {'RECALC'		,{|| lConsLoja:=!Empty(cLoja),LxA103NFORI()}		,STR0085,STR0216,"3"	})				//'NF Original ( Devolucao/Beneficiamento ) [F7]'
		If SuperGetMV("MV_PRNFBEN",.F.,.F.)
			SF5->(dbSetOrder(1))
			If SF5->(MsSeek(xFilial("SF5")+GetMV("MV_TMPAD")))
				AAdd(aRet , {'RECALC'		,{|| lConsLoja:=!Empty(cLoja),ARetBenef()}, STR0337,STR0338,"3"	}) //'Retorno de Beneficiamento  [F7]#Retorno Ben.'
			EndIf
		EndIf
		If StrZero(nTipo,2) $ "10"
			//#PORTUGAL#
			//If cPaisLoc<>"PTG"
				AAdd(aRet , {'AUTOM'	,{|| nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,IIF(cPaisLoc == "CHI",STR0333,Substr(GetDescRem(),1))}),;
											  lRet:=IIf(nAviso==1,SCMToNF(),Iif(nAviso==2,SCMToRem(),.F.))} ,GetDescRem()+' <F8>',Substr(GetDescRem(),1) ,"3"	})  //'Remitos [F8]'
			//#PORTUGAL#
			/*Else
				AAdd(aRet , {'AUTOM'	,{|| lRet:=.T.,SCMToRem()},STR0292 ,STR0292 ,"3"})	 //'Guias de Remessa [F8]"
			EndIf*/
		Endif

		AAdd(aRet ,	{'S4WB013N'		,{|| MontaRATCC()},STR0080,STR0218,""	}) 				//'Rateio por Centro de Custo [F9]'##"Rateio"
		AAdd(aRet ,	{'BMPVISUAL'	,{|| LocxTrack()} ,OemToAnsi(STR0213),STR0220,"2"})	//System Tracker

		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}									,STR0083,STR0219,"" }) //'Gerenciamento de Projetos [F10]'##"Int. PMS"
		EndIf
		If cPaisLoc $ "MEX|PER" .AND. StrZero(nTipo,2) == "10"
			Aadd(aRet,{"FINIMG32",{|| LxAdianMex(M->F1_DOC, cCondicao, Eval({|aX|IIf(Len(aX)>0,aX[1][2],0)},Condicao(MaFisRet(,"NF_VALMERC"),cCondicao,0.00,dDataBase,0.00)), @aRecnoSE1, .F., M->F1_FORNECE, M->F1_LOJA, cNatureza, aHeader)},STR0263,STR0264,"3"}) //"Recebimento antecipado"##"Adiantamento"
		EndIf
	Case StrZero(nTipo,2) $ "08|09|12|62|23"
		If StrZero(nTipo,2) $ "08|09|23"
	  		AAdd(aRet      ,{'CONTAINR'	,   {|| LxN466ForF6(nTipo),}	,STR0235,STR0223,"3"	}) //"Prorrateo del custo de los productos <F6>"
	  	EndIf
		If cPaisLoc == "RUS" .And. StrZero(nTipo,2) == "09"
			AAdd(aRet		,{'RECALC'		,	{|| LocXStock('2','M->D1_NFORI')	 },STR0085,STR0216,"3"	})		//"NF Original [F7]"
		EndIf
		Aadd(aRet	   ,{'S4WB013N'			,{|| MontaRATCC()}         ,STR0080,STR0218,""	}) //'Rateio por Centro de Custo [F9]'##"Rateio"
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}	,STR0083,STR0219,""   	}) //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Notas de Entrada quando for devolucao³
	Case StrZero(nTipo,2) $ "04|05|51|53"
      If  !(StrZero(nTipo,2) $ '51/53')
			AAdd(aRet , {'AUTOM'			,{|| 	nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,Substr(GetDescRem(),1)}),;
											  			lRet:=IIf(nAviso==1,SCMToNF(),Iif(nAviso==2,SCMToRem(),.F.))},;
														GetDescRem()+STR0088,Substr(GetDescRem(),1),"3"	})  //'Remitos [F6]'
      Endif
   		aBtnDocOri := {STR0007,IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(1),STR0223),STR0320}//"Item"#"Facturas"#Pedido
		If cPaisLoc == "CHI" .And. (StrZero(nTipo,2) == "04")
			aBtnDOChi := {STR0124, STR0223} //Nota de Debito # Facturas
			Aadd(aRet, {'RECALC',;
				{|| lConsLoja:=!Empty(cLoja),;
					(If((nChiOp := Aviso(STR0113, STR0005 + " " + STR0124 + " o " + STR0223 + "?", aBtnDOChi)) == 1,; //Selecciona # Nota de Debito # Facturas
					LxDocOri(.T.),;
					If((nEscAvs := Aviso(IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223), STR0005 + " " + IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223) + "?", aBtnDocOri)) == 2, Processa({||LxDocOri()}, STR0241), Iif(nEscAvs == 1, LxA103NFORI(), LxNFOrig("P", SAliasHead, StrZero(nTipo, 2))))));
				},STR0085, STR0216, "3"}) //'NF Original ( Devolucao/Beneficiamento ) [F7]'
		Else
			Aadd(aRet	   ,{'RECALC'		,{|| lConsLoja:=!Empty(cLoja),If((nEscAvs := Aviso(IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223),STR0005+" "+IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223)+"?",aBtnDocOri))==2,Processa({|| LxDocOri()},STR0241),Iif(nEscAvs == 1,LxA103NFORI(),LxNFOrig("P",SAliasHead,StrZero(nTipo,2))))},STR0085,STR0216,"3"	}) //'NF Original ( Devolucao/Beneficiamento ) [F7]'
		EndIf
  		Aadd(aRet	   ,{'BMPINCLUIR'	,{|| A103LoteF4()}												,STR0086,STR0221,"3"	}) //'Lotes Disponiveis [F8]'
		Aadd(aRet	   ,{'S4WB013N'	,{|| MontaRATCC()}                 							,STR0080,STR0218,""	}) //'Rateio por Centro de Custo [F9]'
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'	,{|| Eval(bPmsDlgNF)}										,STR0083,STR0219,""	})	 //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Notas de Saida quando nao for Devolucao³
	Case StrZero(nTipo,2) $ "01|02|03|11|50|52|54|17|18|19|21"
		cTipDoc := IIf(StrZero(nTipo,2)$"01|17|18|19|21","N",IIf(StrZero(nTipo,2)$"02|03","C","B"))
		AAdd(aRet		,{'RECALC'		, 	{|| LocxStock('1',"M->D2_QUANT") },STR0122,STR0222,"3"	})		//Consulta ao Estoque [F4]
		If cPaisLoc == "AUS" .AND. StrZero(nTipo,2) $ "02|03"
			Aadd(aRet	    ,{'BMPINCLUIR'	,{|| LxNFOrig(IIf(Aviso(STR0005,STR0319,{STR0320,STR0321})==1,"P","NF"),SAliasHead,StrZero(nTipo,2))},STR0085,STR0216,"3"}) //Selecciona#"Escolha a Maneira de Pesquisar o Documento de Origem"#Pedido#Vendas
		EndIf
		If cPaisLoc == "RUS" .And. StrZero(nTipo,2) $ "02"
			aBtnDocOri := {STR0007,STR0223,STR0320}//"Item"#"Facturas"#Pedido
			Aadd(aRet	   ,{'RECALC'		,{|| lConsLoja:=!Empty(cLoja),;
									If((nEscAvs := Aviso(STR0223,STR0005+" "+STR0223+"?",aBtnDocOri))==2,;
									Processa({|| RU05X0002_OriDoc(aCfgNF[SAliasHead],nTipo)},STR0241),Iif(nEscAvs == 1,LxA103NFORI(),LxNFOrig("P",SAliasHead,StrZero(nTipo,2))))},STR0085,STR0216,"3"	}) //'NF Original ( Devolucao/Beneficiamento ) [F7]'
		EndIf
		If StrZero(nTipo,2) $ "02" .And. cPaisLoc == "ARG" .And. Findfunction("LDocOriSd") .and. Findfunction("ARGNFORIDB")
			aBtnDocOri := {STR0007,STR0223}//"Item"#"Facturas"
			Aadd(aRet   ,{'RECALC' ,{|| If((nEscAvs := Aviso(STR0223,STR0005+" "+STR0223+"?",aBtnDocOri))==2,Processa({|| LDocOriSd()},STR0241),ARGNFORIDB())},STR0085,STR0216,"3" }) //'NF Original
		Endif
		If StrZero(nTipo,2) $ "02" .and. cPaisLoc == "PAR" .And. Findfunction("DocOriPAR")
			Aadd(aRet   ,{'RECALC' ,{|| Processa({|| DocOriPAR()},STR0241)},STR0085,STR0216,"3" }) //'NF Original
		EndIf
		//O processo de Recebimento Antecipado estará disponivel
		//apenas para TOP no Financeiro.
		If cPaisLoc == "ANG" .AND. StrZero(nTipo,2)=="01"
			Aadd(aRet,{"FINIMG32",{|| A410Adiant(M->F2_DOC, cCondicao, Eval({||IIf(Len(aDupl)>0,DesTrans(Extrae(aDupl[1],5)),0)}), @aRecnoSE1, .F., M->F2_CLIENTE, M->F2_LOJA, NIL,NIL,NIL,NIL,cNatureza)},STR0263,STR0264,"3"}) //"Recebimento antecipado"##"Adiantamento"
		ElseIf cPaisLoc $ "MEX|PER" .AND. StrZero(nTipo,2) $ "01|21"
			If StrZero(nTipo,2) == "01"
				Aadd(aRet,{"FINIMG32",{|| LxAdianMex(M->F2_DOC, cCondicao, Eval({|aX|IIf(Len(aX)>0,aX[1][2],0)},Condicao(MaFisRet(,"NF_VALMERC"),cCondicao,0.00,dDataBase,0.00)), @aRecnoSE1, .F., M->F2_CLIENTE, M->F2_LOJA, cNatureza, aHeader)},STR0263,STR0264,"3"}) //"Recebimento antecipado"##"Adiantamento"
			EndIf
			If cPaisLoc == "MEX" .And. (StrZero(nTipo,2)=="01" .Or. StrZero(nTipo,2)=="21") .And. FindFunction("LxCartaPor") .And. SF2->(ColumnPos("F2_TPCOMPL")) > 0
				Aadd(aRet,{"CARTAPORTE", {|| LxCartaPor("SF2",M->F2_FILIAL,M->F2_DOC,M->F2_SERIE,M->F2_ESPECIE,M->F2_TPCOMPL=='S',.F.) },STR0437,STR0438,"3"}) //"Carta Porte FE" //"Carta Porte"
				IIF(StrZero(nTipo,2)=="21" .And. FindFunction("LxMxPFact"),Aadd(aRet,{"FACTURAS", {||LxMxPFact() },STR0445,STR0445,"3"}),"") // "Facturas" ## "Facturas")
			EndIf
		ElseIf cPaisLoc $ "EQU" .AND. StrZero(nTipo,2)=="01" .AND. FindFunction("MATA488") .AND. SF2->(FieldPos("F2_TPDOC")) > 0
			Aadd(aRet,{"REEMBOLSO", {|| MATA488(M->F2_DOC, M->F2_SERIE, M->F2_CLIENTE, M->F2_LOJA,M->F2_TPDOC,M->F2_TPVENT,M->F2_TIPOPE,M->F2_NATUREZ) },STR0441,STR0441,"3"}) //"Reembolso"##"Reembolso"
		EndIf
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'	,{|| Eval(bPmsDlgNF)}										,STR0083,STR0219,""	})	 //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Notas de SAIDA   que sejam devolucoes³
	Case StrZero(nTipo,2) $ "06|07|61|22"
		AAdd(aRet		,{'PLNPROP'		,	{|| LocXStock('2','M->D2_QUANT')	 },STR0122,STR0222,"3"	})		//Consulta ao Estoque [F4]
		If StrZero(nTipo,2) $ "06/07/22"
	  		AAdd(aRet       ,{'CONTAINR'	,   {|| LxN466ForF6(nTipo),}	,STR0235,STR0223,"3"	}) //"Prorrateo del custo de los productos <F6>"
		EndIf
		AAdd(aRet		,{'RECALC'		,	{|| LocXStock('2','M->D2_NFORI')	 },STR0085,STR0216,"3"	})		//"NF Original [F7]"

		If StrZero(nTipo,2) $ "06/07"
			AAdd(aRet	,{'AUTOM'		,{|| 	nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,Substr(GetDescRem(),1)}),;
									  			lRet:=IIf(nAviso==1,SCMToNF2(),Iif(nAviso==2,SCMToRem2(),.F.))},;
												GetDescRem()+" <F9>",Substr(GetDescRem(),1),"3"	})  //'Remitos [F9]'
		EndIf
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'	,{|| Eval(bPmsDlgNF)}										,STR0083,STR0219,""	})	 //'Gerenciamento de Projetos [F10]'
		EndIf
	Case StrZero(nTipo,2) $ "13"
		AAdd(aRet ,	{'CONTAINR'		,{|| LocXNfDesp(2)	}	,STR0141+STR0087,STR0223,"3"	}) //'Facturas de entrada [F4]'
		Aadd(aRet ,	{'S4WB013N'		,{|| MontaRATCC()	}	,STR0080,STR0218,""	}) //'Rateio por Centro de Custo [F9]'
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}									,STR0083,STR0219	}) //'Gerenciamento de Projetos [F10]'
		EndIf
	Case StrZero(nTipo,2) $ "14"
		AAdd(aRet ,	{'CONTAINR'		,{|| LocXNfDesp(1)	}	,STR0141+STR0087,STR0223,"3"	}) //'Facturas de entrada [F4]'
		Aadd(aRet ,	{'S4WB013N'		,{|| MontaRATCC()	}	,STR0080,STR0218,""	}) //'Rateio por Centro de Custo [F9]'
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}							,STR0083,STR0219	}) //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Recibo de servicos³
	Case StrZero(nTipo,2) $ "15"
		Aadd(aRet	   ,{'S4WB013N'	,{|| MontaRATCC()}                 					,STR0080,""	}) //'Rateio por Centro de Custo [F9]'
		If IntePms()
			Aadd(aRet	   ,{'PROJETPMS'		,{|| Eval(bPmsDlgNF)}									,STR0083,"" }) //'Gerenciamento de Projetos [F10]'
		EndIf
	//³Botoes para Retorno simbolico(CONSIGNACAO)³
	Case StrZero(nTipo,2) $ "63"
		Aadd(aRet	   ,{'RECALC'		,{|| lConsLoja:=!Empty(cLoja),LxA103NFORI()}			,STR0085,STR0216,"3"	}) //'NF Original ( Devolucao/Beneficiamento ) [F7]'
  		Aadd(aRet	   ,{'BMPINCLUIR'	,{|| A103LoteF4()}											,STR0086,STR0221,"3"	}) //'Lotes Disponiveis [F8]'
	//³Botoes para Entrada transf. ³
	Case StrZero(nTipo,2) $ "64"
		Aadd(aRet	   ,{'RECALC'		,{|| NfTrfOri(M->F1_FILORIG) }		,DESCREM+STR0166,STR0217,"3"	}) //
	//³Guia de Remessa / Guia de Remessa-Cancelada
	Case StrZero(nTipo,2) $ "65"
		AAdd(aRet ,	{'PEDIDO'		,{|| lReajuste:=.T.,LxA103ForF4(Nil,lIsRemito),ModxAtuObj()}	,STR0077,STR0214,"3"	})	//'Pedidos de Compras [F5]' ## "Ped Comp"
		AAdd(aRet ,	{'PEDIDO'		,{|| lReajuste:=.T.,LxA103ItemPC()}					,STR0078,STR0215,"3"	})	 		//'Pedidos de Compras( por item ) [F6]'##"Item PC"
EndCase
Return(aRet)

/*
±±ºPrograma  ³CARREGATECLAS ºLeandro C.G.  ³Microsiga º Data ³  05/02/02  º±±
±±ºDesc.     ³Define todas as teclas com suas respectivas funcoes de 	  º±±
±±º			 ³acordo com o tipo de NF									  º±±
±±ºUso       ³MONTACFGNF                                                  º±±
Parametros: nTipo    - tipo de NF
*/
Function CarregaTeclas(nTipo)
Local bPMSDlgNF	:= {|| PmsVldNf() }
Local aRet		:= {}
Local bTeclaF4	:= {|| NIL } 			//Bloco de codigo para tecla F4
Local aBtnDocOri:= {}
Local lIsRemito := .F.
Local nEscAvs
Local aBtnDOChi := {} //Botones para documento origen Chile
Local nChiOp // Regreso de aviso Chile

Default nTipo   := 0

// Verifica se o documento e um remito
lIsRemito := IsRemito(1,"'"+StrZero(nTipo,2)+"'")

Do Case
	//³Teclas para Notas de Entrada que nao sejam devolucoes³
	Case StrZero(nTipo,2) $ "08/09/10/12/60/23"
		cPe	:=	LocxPE(19)
		bTeclaF4 := IIf(!Empty(cPE),{ || ExecBlock(cPE,.F.,.F.)},{|| A103F4()})
		If StrZero(nTipo,2) $ "08/09/23"
	   	   	AAdd(aRet 		,{VK_F6     ,{|| LxN466ForF6(nTipo) },"3"	}) //'NF de Credito/Debito NCI/NDP [F6]'
	   	EndIf
		If StrZero(nTipo,2) $ "10/60"
			AAdd(aRet		,{VK_F4		, bTeclaF4                  ,"3"})						//Consulta de Pedidos de Compra em Aberto
			AAdd(aRet		,{VK_F5		,{|| LxA103ForF4(Nil,lIsRemito)} ,"3"})				//Pedido de compra
			AAdd(aRet		,{VK_F6		,{|| LxA103ItemPC() 			} ,"3"})				//Pedido de Compra por Item
			AAdd(aRet 		,{VK_F7		,{|| lConsLoja:=!Empty(cLoja),LxA103NFORI() }	,"3"}) //'NF Original ( Devolucao/Beneficiamento )'
			If !StrZero(nTipo,2) $ "60"
		 		AAdd(aRet		,{VK_F8		,{|| nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,GetDescRem()}),;
														  lRet:=IIf(nAviso==1,SCMToNF(),Iif(nAviso==2,SCMToRem(),.F.))} ,"3"})		//'Remitos'
			Endif
		Endif
		AAdd(aRet		,{VK_F9		,{|| MontaRATCC() 			} ,""})		//Rateio por Centro de Custo
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		}})		//Gerenciamento de Projetos
		EndIf
	//³Teclas para Notas de Entrada que sejam devolucoes³
	Case StrZero(nTipo,2) $ "04|05|51|53"
		If cPaisLoc == "CHI" .And. StrZero(nTipo,2) == "04"
		  aBtnDOChi := {STR0124, STR0223} //Nota de Debito # Facturas
		  Aadd(aRet,{VK_F7 ,{|| (If((nChiOp := Aviso(STR0113, STR0005 + " " + STR0124 + " o " + STR0223 + "?", aBtnDOChi)) == 1,LxDocOri(.T.),If((nEscAvs := Aviso(IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223), STR0005 + " " + IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223) + "?", aBtnDocOri)) == 2, Processa({||LxDocOri()}, STR0241), Iif(nEscAvs == 1, LxA103NFORI(), LxNFOrig("P", SAliasHead, StrZero(nTipo, 2))))))},"3"})
		Else
			Aadd(aRet,{VK_F7 ,{|| If(Aviso(IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223),STR0005+IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223)+"?",{STR0007,IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223)})==2,Processa({|| LxDocOri()},STR0241),LxA103NFORI())},"3"})
		EndIf
		AAdd(aRet,{VK_F8 ,{|| A103LoteF4() 					} ,"3"})		//Lotes Disponiveis
		If  !(StrZero(nTipo,2) $ '51/53')
			AAdd(aRet,{VK_F6 ,{|| nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,GetDescRem()}),;
											  lRet:=IIf(nAviso==1,SCMToNF(),Iif(nAviso==2,SCMToRem(),.F.)) } ,"3"})		//'Remitos'
		Endif
		AAdd(aRet		,{VK_F9		,{|| MontaRATCC() 			} ,""})		//Rateio por Centro de Custo
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
		If IntTms()
			AAdd(aRet	,{VK_F11	,{|| A103RatVei() 		} ,"3"})		//Rateio por Veiculo/Viagem - <F11>
		EndIf
	//³Teclas para Notas de SAIDA ³
	Case StrZero(nTipo,2) $ "01|02|03|11|50|52|54|17|18|19|21"
		AAdd(aRet	,{VK_F4	,{|| LocxStock('1') },"3"})		//Consulta ao Estoque
		AAdd(aRet	,{VK_F8	,{|| LocxStock('3') },"3"})		//Consulta Lote e localiz.
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Teclas para Notas de Saida que sejam devolucoes  ³
	Case StrZero(nTipo,2) $ "06|07|61|22"
		AAdd(aRet	,{VK_F4	,{|| LocxStock('1',"M->D2_QUANT") },"3"})		//Consulta ao Estoque
		If StrZero(nTipo,2) $ "06/07/22"
	   	   	AAdd(aRet   ,{VK_F6 ,{|| LxN466ForF6(nTipo) },"3"	}) //'NF de Credito/Debito - NCP/NDI [F6]'
   	   	EndIf
		AAdd(aRet	,{VK_F7	,{|| LocXStock('2',"M->D2_NFORI") },"3"})		//NF Original
		AAdd(aRet	,{VK_F8	,{|| LocxStock('3') },"3"})		//Consulta Lote e localiz.
		If StrZero(nTipo,2) $ "06/07"
			AAdd(aRet,{VK_F9 ,{|| nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem()+STR0006,{STR0007,GetDescRem()}),;
											  lRet:=IIf(nAviso==1,SCMToNF2(),Iif(nAviso==2,SCMToRem2(),.F.)) } ,"3"})		//'Remitos'
   	   	EndIf
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Teclas para Notas de DESPESAS DE IMPORTACAO      ³
	Case StrZero(nTipo,2) $ "13"
		AAdd(aRet ,	{VK_F4	,{|| LocXNfDesp(2) },"3"}) 					//'Despesas de import.'
		AAdd(aRet ,	{VK_F9	,{|| MontaRATCC() },""})		//Rateio por Centro de Custo
		If IntePms() //.AND.!IsRemito(1,"'"+StrZero(nTipo,2)+"'")
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Teclas para Notas de conhecimento de frete       ³
	Case StrZero(nTipo,2) $ "14"
		AAdd(aRet ,	{VK_F4	,{|| LocXNfDesp(1) },"3"}) 					//'Despesas de import.'
		AAdd(aRet ,	{VK_F9	,{|| MontaRATCC() },""})		//Rateio por Centro de Custo
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Botoes para Recibo de servicos                   ³
	Case StrZero(nTipo,2) $ "15"
		AAdd(aRet ,	{VK_F9	,{|| MontaRATCC() },""})		//Rateio por Centro de Custo
		If IntePms()
			AAdd(aRet	,{VK_F10	,{|| Eval(bPmsDlgNF)		} })		//Gerenciamento de Projetos
		EndIf
	//³Teclas para retorno simbolico (consignacao)      ³
	Case StrZero(nTipo,2) $ "63"
		AAdd(aRet,{VK_F7 ,{|| LxA103NFORI()     } ,"3"})		//Notas Orignais da Devolucao
		AAdd(aRet,{VK_F8 ,{|| A103LoteF4()    } ,"3"})		//Lotes Disponiveis
	Case StrZero(nTipo,2) $ "64"
		Aadd(aRet	   ,{VK_F4		,{|| NfTrfOri(M->F1_FILORIG) } ,"3" }) // Remitos de transf.
EndCase

//Documento Original
If StrZero(nTipo,2) $ "04|05|51|53"
	aBtnDocOri := {STR0007,IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(1),STR0223),STR0320}//"Item"#"Facturas",Pedido
	If cPaisLoc == "CHI" .And. StrZero(nTipo,2) == "04"
		aBtnDOChi := {STR0124, STR0223} //Nota de Debito # Facturas
		Aadd(aRet,{VK_F7 ,{|| lConsLoja:=!Empty(cLoja),(If((nChiOp := Aviso(STR0113, STR0005 + " " + STR0124 + " o " + STR0223 + "?", aBtnDOChi)) == 1,LxDocOri(.T.),If((nEscAvs := Aviso(IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223), STR0005 + " " + IIf(StrZero(nTipo, 2) $ "51|53", GetDescRem(), STR0223) + "?", aBtnDocOri)) == 2, Processa({||LxDocOri()}, STR0241), Iif(nEscAvs == 1, LxA103NFORI(), LxNFOrig("P", SAliasHead, StrZero(nTipo, 2))))))},"3"})
	Else
		Aadd(aRet,{VK_F7 ,{|| lConsLoja:=!Empty(cLoja),If((nEscAvs := Aviso(IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223),STR0005+" "+IIf(StrZero(nTipo,2) $ "51|53",GetDescRem(),STR0223)+"?",aBtnDocOri))==2,Processa({|| LxDocOri()},STR0241),Iif(nEscAvs == 1,LxA103NFORI(),LxNFOrig("P",SAliasHead,StrZero(nTipo,2))))},"3"})
	EndIf
EndIf
Return aRet

/*
±±ºPrograma  ³CarregaAtualizaº ³Microsiga º Data ³  21/01/02  º±±

*/
Function CarregaAtualiza(nTipo,lTela)
Local aRet:=Array(SnMaxAtua)
If nTipo < 50 //Notas fiscais
	aRet[SlCtbilOL]:= .T.//lTela
	aRet[SlAtuEstq]:= .T.
	aRet[SlAtuFina]:= .T.
	aRet[SlAtuImp] := .T.
	aRet[SlAtuLF]  := .T.
	aRet[SlConsist]:= !(lTela)
Else //Remitos
	aRet[SlCtbilOL]:= .T.//lTela
	aRet[SlAtuEstq]:= .T.
	aRet[SlAtuFina]:= IIf(cPaisLoc == "EUA", .T., .F.) //Ajuste para permitir generacion de financiero provisional de remito
	aRet[SlAtuImp] := .T.
	aRet[SlAtuLF]  := .F.
	aRet[SlConsist]:= !(lTela)

	//#PORTUGAL#
	/*If cPaisLoc=="PTG"
		If nTipo==65
			aRet[SlAtuLF]  := .T.
		EndIf
	EndIf*/
Endif
Return(aRet)

/*
±±ºPrograma  ³NFRATEIOCC    º Leandro C.G. ³Microsiga º Data ³  21/01/02  º±±
±±ºDesc.     ³Grava rateios por centro de custo para um item de uma NF    º±±
±±ºUso       ³ GENERICO	                                                  º±±
Parametros
aRatCC		- array com os rateios de cada item
			  [1] - Item da NF
			  [2] - Itens de Rateios por centro de custo
nOpc		- indicador inclusao ou exclusao -- Default 1
  			  (1) - inclusao
  			  (2) - exclusao
aCusto		- Custo de todos os itens em todas as moedas
			  [1] - Custo moeda1
			  [2] - Custo moeda2
			  [3] - Custo moeda3
			  [4] - Custo moeda4
			  [5] - Custo moeda5
_lGeraLanc	- Indica se deve gerar lanç contabil
*/
Function NfRateioCC(aRatCC,nOpc,aCusto,nItem)
Local aArea  		:= GetArea()
//Local nI							//flag para loop's
Local aRecSDE		:= {}			//array com numero dos registros do SDE que devem ser excluidos
Local lRet			:= .T.			//Indica consistencia da funcao
Local aHeaderSDE	:= {}			//Aheader sobre o arquivo de rateios por NF
Local aPars	   		:= {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Default nOpc 		:= 1


//³Esta variavel define se dentro da rotina Lxa103SD1AtuSDE, deve gerar os lanç. contabeis ou nao³
//³Neste caso, como na rotina de NF existe uma rotina que gera todos os lanç.					 ³
//³contabeis referentes a uma NF, nao pode ser gerado nenhum lanç em outra funcao     			 ³
//³Funcao que gera os lanç. contabeis : CtbilNF											 		 ³

Private lGeraLanc   := .F.


//³Consistindo Parametros³

Aadd(aPars, {"aRatCC"	, aRatCC	, SpEmpty})
lRet := LocxParam("NFRATEIOCC",aPars)
Aeval(aRatCC, { |x| Asize(x, 2) } )

If lRet //(1)

	//³ Montagem do aHeader para utilizacao na gravacao do SDE       ³

	DBSelectArea("SX3")
	DBSetOrder(1)
	MsSeek("SDE")
	While !EOF() .AND. (X3_ARQUIVO == "SDE")
		If X3uso(X3_USADO) .AND. cNivel >= X3_NIVEL
			AADD(aHeaderSDE,{ 	Trim(x3titulo())	,X3_CAMPO	,X3_PICTURE	,;
								X3_TAMANHO			,X3_DECIMAL	,X3_VALID	,;
								X3_USADO			,X3_TIPO	,X3_ARQUIVO	,;
								X3_CONTEXT 										} )
		EndIf
		DBSkip()
	End

	//³Verifica inclusao ou exclusao³

	Lxa103SD1AtuSDE(nOpc,aRatCC,aRecSDE,aHeaderSDE,aCusto)

EndIf //lRet (1)

RestArea(aArea)
Return

/*
±±ºPrograma  ³NfGravaCusto  º Leandro C.G. ³Microsiga º Data ³  21/01/02  º±±
±±ºDesc.     ³Busca custo para um item de uma NF			 		      º±±
Parametros
cAliasI		- Alias referente ao item da NF (SD1/SD2)
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
nItem		- Item da NF (n - linha do aCols) -- usado apenas quando cAliasI == "SD1"
oBS.:
Considera que os aqruivos de itens da NF e TES estao posicionados no registro correto
*/
Function NfGravaCusto(cAliasI,cTipDoc,nItem)
Local aCusto 	:= {}			//array com o custo do item nas moedas correntes
Local aEnvcus	:= {}
Local lRet 		:= .T.			//Indica consistencia da funcao
Local aPars	    := {}			//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local lTotal	:= SuperGetMV("MV_CUSDESP",.F.,.F.)
Local lParAuto:=.F.
//- Utilizada na funcao a103Custo e precisava ser declarada,
// porém se utilizo a função MATA465N essa variavel já vem preenchida então não permite sobrescrever o valor
Private aDupl	:= Iif(Type("aDupl") <> "U", IIf(Type("aDupl") == "A" .And. (Len(aDupl)> 0),aDupl,{}) , {} )


//³Consistindo Parametros³

Aadd(aPars		, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
Aadd(aPars		, {"cTipDoc"	, cTipDoc	, SpEmpty					} )
If cAliasI == "SD1" .And. (Empty(nItem) .Or. nItem <= 0)
	Aadd(aPars	, {"nItem"		, nItem		, SpEmpty					} )
EndIf
lRet := LocxParam("NFGRAVACUSTO",aPars)
IF cPaisLoc$"MEX|ARG|PAR|URU|CHI|BOL" .And. Type("aAutoItens") <> "U"
	IF Len(aAutoItens) > 0
		IF FunName() <> "MATA143" .and.  FunName() <> "MATA447"
			lParAuto:=.T.
		ENDIF
	ENDIF
ENDIF
If lRet //(1)

	//³Armazena o custo em todas as moedas e Grava Custo na NF ³

	If cAliasI == "SD1"
		nTaxa		:= SF1->F1_TXMOEDA
		nMoedaNF	:= SF1->F1_MOEDA
		If l103Auto .And. !lTotal .and. !lParAuto
			aCusto := {}
		Else
			aCusto := Lxa103Custo(nItem)
			If !GravaCusNF(cAliasI,aCusto)
				lRet := .F.
			EndIf
		EndIf
	Else
		nTaxa		:= SF2->F2_TXMOEDA
		nMoedaNF	:= SF2->F2_MOEDA
		If nMoedaNF <= 1
			nTaxa	:=	0
		Endif
		aEnvCus :=	{	SD2->D2_TOTAL		,;
						SD2->D2_VALIPI		,;
						SD2->D2_VALICM		,;
						SF4->F4_CREDIPI		,;
						SF4->F4_CREDICM		,;
						SD2->D2_NFORI		,;
						SD2->D2_SERIORI		,;
						SD2->D2_COD			,;
						SD2->D2_LOCAL		,;
						SD2->D2_QUANT		,;
						If(SF4->F4_IPI=='R',SD2->D2_VALIPI,0)		}

		//³Caso seja uma Nota de Credito/Debito com qtde Zerada, ³
		//|gravar somente o custo da nota.                       |

		If SD2->D2_TIPO == "D" .And. AllTrim(SD2->D2_ESPECIE) $ "NCP|NDI" .And. QtdComp(SD2->D2_QUANT) == QtdComp(0)
			aCusto  := 	{	xMoeda(SD2->D2_TOTAL,nMoedaNF,1,SF2->F2_EMISSAO,,nTaxa),;
							xMoeda(SD2->D2_TOTAL,nMoedaNF,2,SF2->F2_EMISSAO,,nTaxa),;
							xMoeda(SD2->D2_TOTAL,nMoedaNF,3,SF2->F2_EMISSAO,,nTaxa),;
							xMoeda(SD2->D2_TOTAL,nMoedaNF,4,SF2->F2_EMISSAO,,nTaxa),;
							xMoeda(SD2->D2_TOTAL,nMoedaNF,5,SF2->F2_EMISSAO,,nTaxa) }
		Else
			aCusto  := PegaCMAtu(SD2->D2_COD,SD2->D2_LOCAL,If(SF4->F4_PODER3=="D","D",cTipDoc),aEnvCus,cTipDoc=="D")
		EndIf
		aCusto  := GravaCusD2(aCusto,If(SF4->F4_PODER3=="D","D",cTipDoc))
	EndIf

EndIf //lRet (1)
Return(aCusto)

/*
±±ºPrograma  ³ATUDIFCUSREM  º Leandro C.G. ³Microsiga º Data ³  24/01/02  º±±
±±ºDesc.     ³Quando for classificacao de remito, atualiza o custo 	      º±±
±±º			 ³original de acordo com o custo da movimentacao atual		  º±±
±±ºUso       ³ ATUSCMNF	                                                  º±±
±±ºParametros³ aCusto : Array com os custos da NF.              		  º±±
Obs.: Considera que os arquivos SF1 e SD1 do remito esta posicionado no registro correto
*/
Function AtuDifCusREM(aCusto,nQuant,nSigno,cAliasTmp)
Local nQtdMoeda := 5					//Numero de moedas utilizadas no sistemas
//Local aCM		:= Array(nQtdMoeda)		//Custo medio atualizado em todas as moedas para atualizacao do SB2
Local aCunitREM := Array(nQtdMoeda)		//Custo unitario na movimentacao original em todas as moedas
Local aValDif	:= Array(nQtdMoeda)
Local aAreaSB2  := SB2->(GetArea())
Local dData
Local lAtuCusRem:= .T.
Local nMoeda
Local nTxMoeda
local cIndex
local cChave

If cAliasTMP == Nil
	If Select("__LOCXSF1") == 0
		ChkFile("SF1",.F.,"__LOCXSF1")
	Else
		dbSelectArea("__LOCXSF1")
	Endif
	cAliasTMP	:=	"__LOCXSF1"
Endif

dbSelectArea(cAliasTmp)
cIndex := CriaTrab(Nil, .F.)
cChave := IndexKey()

IndRegua(cAliasTmp, cIndex, "F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO", , , "")

(cAliasTmp)->(DbSetOrder(1))
(cAliasTmp)->(MSSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO))

//Data da movimentacao original
dData	 := IIf(!Empty((cAliasTmp)->F1_DTDIGIT),(cAliasTmp)->F1_DTDIGIT,(cAliasTmp)->F1_EMISSAO)
//Moeda referente a movimentacao original
nMoeda   := IIf(!Empty((cAliasTmp)->F1_MOEDA).AND.(cAliasTmp)->F1_MOEDA>0,(cAliasTmp)->F1_MOEDA,1)
//Taxa da moeda da movimentacao original na data da movimentacao
nTxMoeda := IIf(nMoeda == 1 ,1,If(!Empty((cAliasTmp)->F1_TXMOEDA).AND.(cAliasTmp)->F1_TXMOEDA>0,(cAliasTmp)->F1_TXMOEDA,RecMoeda(dData,nMoeda)))

//³Buscando o custo original da movimentacao em todas as moedas³

Aeval(aCunitREM	, {|x,y| aCunitREM[y] := xMoeda(SD1->D1_CUSORI,1,y,dData,,,If(y=nMoeda,nTxMoeda,Nil)) / SD1->D1_QUANT } )

//³Verificando a diferenca do custo da movimentacao atual em relacao a movimentacao de origem³

AEval(aValDif	, {|x,y| aValDif[y] := (aCusto[y] - aCunitREM[y]) * nQuant 	} )

// Verificar se esta no periodo valido
If !(GetMV("MV_ULMES") >= dData)

	//³Ponto de Entrada p/ atualizacao do custo do remito³

	If ExistBlock( "LOCCUSREM" )
		lAtuCusRem  := ExecBlock("LOCCUSREM",.F.,.F.,{aCusto,nQuant,nSigno,cAliasTmp,aCunitREM,aValDif})
		If ValType(lAtuCusRem) <> "L"
		   lAtuCusRem := .T.
		EndIf
	EndIf
	If lAtuCusRem
		// Atualizando o valor do custo da movimentacao original
		RecLock("SD1", .F.)
		Aeval(aValDif, {|x,y| &("SD1->D1_CUSTO"+IIf(y==1,"",AllTrim(Str(y)))+" += "+AllTrim(Str(nSigno*aValDif[y])) ) } )
		MsUnlock()
		DbSelectArea("SB2")
		DbSetOrder(1)
		If MsSeek(xFilial("SB2")+SD1->D1_COD+SD1->D1_LOCAL)
			If SD1->D1_CUSTO > 0 .And. SD1->D1_QUANT > 0
		   		RecLock("SB2", .F.)
				Aeval(aValDif,{|x,y| &("SB2->B2_VATU" +AllTrim(Str(y))+" += "+AllTrim(Str(nSigno*aValDif[y])) ) } )
			   	Aeval(aValDif,{|x,y| &("SB2->B2_CM"   +AllTrim(Str(y))+" += "+AllTrim(Str(nSigno*(aValDif[y]/SD1->D1_QUANT))) ) } )
				MsUnlock()
			EndIf
		EndIf
	EndIf
EndIf
RestArea(aAreaSB2)
Return

/*
±±ºPrograma  ³RetValor  ºLeandro C.G. ³Microsiga     º Data ³  24/01/2002 º±±
±±ºDesc.     ³ Posiciona uma arquivo devolvendo o valor de acordo com a   º±±
±±º          ³formula enviada como parametro. Reposiciona os arquivos na  º±±
±±º			 ³saida da rotina											  º±±
±±ºUso       ³ GENERICO                                                   º±±
Parametros
cAlias		- Alias do arquivo que deve ser posiionado
nOrdem		- Indice do arquivo
cExpr		- Expressao para posicionar o arquivo
cFormula	- Formula que sera executada apos posicionamento do arquivo
cTipo		- Tipo do conteudo do resultado da formula. Se este parametro for passado mesmo que o resultado da formula seja nulo, retorna um valor valido segundo suas propriedades
			("C") - caractere
			("A") - Array
			("N") - Numerico
			("L") - Logico (boolean)
lTpSeek		- Se refere ao Seek realizado pelo parametro cExpr. MSSeek( ...., lTpSeek) Default .F.
*/
Function RetValor(aAlias,nOrdem,cExpr,cFormula,cTipo,lTpSeek)
Local aArea 		:= GetArea()
Local nRecno,nIndex,xRet

Default nOrdem  	:= 1
Default lTpSeek 	:= .F.

If !Empty(cAlias)
	DbSelectArea(cAlias)
	nRecno := Recno()
	nIndex := IndexOrd()

	DbSetOrder(nOrdem)
	If MsSeek(cExpr, lTpSeek)
		xRet := &(cFormula)
	EndIf

	IIf(nRecno>0,MSGoto(nRecno),)
	IIf(nIndex>0,DBSetOrder(nIndex),)
	RestArea(aArea)
EndIf

If Empty(xRet) .AND. !Empty(cTipo)
	Do Case
		Case cTipo == "A"
			xRet := {}
		Case cTipo == "C"
			xRet := ""
		Case cTipo == "N"
			xRet := 0
		Case cTipo = "L"
			xRet := .F.
	EndCase
EndIf
Return xRet

/*
±±ºPrograma  ³COMPENSANCC ºLeandro C.G. ³Microsiga   º Data ³  04/02/2002 º±±
±±ºDesc.     ³ Chama tela de compensacao de titulos financeiros para uma  º±±
±±º			 ³NCC            											  º±±
±±ºUso       ³ GRAVANFGERAL                                               º±±

Parametros
cAliasI		- Alias do arquivo de itens da NF
cTipoFin	- Tipo do titulo financeiro referente a NF
aPergs		- Array com o conteudo das perguntas feitas na tela de NF
			[SlAmarraca 1]	-   Incluir Amarraçäo  ? (Cli.xProd.) ou (For.xProd.)
			[SlGerCtbil 2]	-   lanç. On-Line?
			[SlVerCtbil 3]	- 	Mostra Lanç.Contab ?
			[SlAglutina 4]	-	Aglut Lançamentos  ?
			[SlQbraAliq 5]	-	Quebra do Rodap   ? Por Alíquota    /  Por Imposto
			[SlCtbEmiss 6]	-	Contabiliza por    ? Emissao         /  Data Base

Obs.: Considera que o arquivo de cabecalho da NF SF1 ja esta posicionado no registro correto

*/
Function CompensaNCC(cAliasI,cTipoFin,aPergs)
Local lRet  := .T.		//Retorno da funcao
Local aPars	:= {}		//Array para a funcao de validacao de param. (Olhar funcao LocxParam())
Local cX5Lote := ""

//³Consistindo parametros³

Aadd(aPars, {"cAliasI"	, cAliasI	, Sp2String	, "SD1"	, "SD2"	} )
lRet := LocxParam("COMPENSANCC",aPars)

Default aPergs   := {}
Default cTipoFin := ""

//³Posiciona SE1³

DBSelectArea("SE1")
DBSetOrder(2)
If lRet
	SX5->(DBSetOrder(1))
	SX5->(MsSeek(xFilial("SX5")+"09FAT"))
	cX5Lote := IIf(SX5->(Found()),Trim(X5Descri()),"FAT ")

	//³Declara variaveis necessarias e chama funcao. As variaveis a serem declaradas foram retiradas³
	//³do MATA465																					³

	PRIVATE cLote	:=""	// Utilizado para Contabilizacao
	PRIVATE VALOR 	:= 0 	// Utilizada para Contabilizacao
	PRIVATE nTamTit := TamSX3("E1_PREFIXO")[1]+TamSX3("E1_NUM")[1]+TamSX3("E1_PARCELA")[1]
	PRIVATE nTamTip := TamSX3("E1_TIPO")[1]
	PRIVATE nTamLoj := TamSX3("E1_LOJA")[1]
	Fa330Comp(cAliasI,,1,oMainWnd,cX5Lote,"COMPENSANCC")

	//³Restaura valores dos parametros com base no aPergs³

	Aeval(aPergs,{|x,y| &("MV_PAR"+StrZero(y,2)) := x })
Else
	lRet := .F.
EndIf
Return(lRet)

/*
±±ºPrograma  ³MONTAPE     ºLeandro C.G. ³Microsiga   º Data ³  14/02/2002 º±±
±±ºDesc.     ³ Carrega todos os pontos de entrada em suas devidas posicoesº±±
±±º			 ³ de acordo com o tipo de NF								  º±±
±±ºUso       ³ MONTACFGNF                                                 º±±


Parametros
nTipo    - tipo de NF
		    (1)  - NF ou fatura de Vendas
		    (2)  - NDC
		    (3)  - NCE
		    (4)  - NCC
		    (5)  - NDE
		    (6)  - ND1
		    (7)  - NCP
		    (8)  - NCI
		    (9)  - NDP
		    (10) - NF ou Fatura de Compras
		    (11) - Beneficiamento / Fornec.
		    (12) - Beneficiamento / Cliente
			(13) - Remito faturam. normal
			(14) - Remito faturam. Devolucao
			(15) - Remito compras normal
			(16) - Remito compras Devolucao
*/

Function MontaPE(nTipo)
Local nX	:= 0
Local aRet	:= Array(SnMaxPE,2)	//Retorno da funcao
/*								[1]	- No inicio da rotina da tela que cria a EnchoiceBar
								[2] 	- Antes de comecar a montagem da tela, aCols e aHeader
								[3]	- Apos o Ponto de entrada anterior
								[4]	- No inicio da Rotina de Gravacao
								[5] 	- Apos gravacao do Livro Fiscal
								[6]	- Permite alterar o valor da duplicata
								[7]	- Integracao com o Celerina, depois de gravar a NF
								[8]	- Apos gravacao do arquivo de cabecalho da Nota e todas as atualizacoes referentes a este arquivo
								[9]	- Apos gravacao do arquivo de cabecalho da Nota e antes das atualizacoes referentes a este arquivo
								[10]	- Apos atualizacoes do arquivo SB2
								[11]	- Apos a gravacao da NF fora da transacao
								[12]	- Na atualizacao do arquivo SC9
								[13]	- Retorna a qtde da segunda unidade de medida
								[14]	- Apos a gravacao do SD1 e todas as atualizacoes referentes a este arquivo
								[15]	- Apos a gravacao do SD1
								[16]	- Apos as validacoes da rotina TudOk
								[17]	- Apos as validacoes de cada item (LinOk)
								[18]	- Apos a gravacao do arquivo financeiro
								[19]	- Tecla F4 - Pedidos de Compra em Aberto
								[20]	- Permite alterar a condicao de pagamento
								[21]	- Altera os vencimentos da duplicata
								[22]	- Deixa alterar a data inicial da condicao de pagamento
								[23]	- Alteracao do numero e prefixos do aqruivo financeiro
								[24]	- Apos confirmar o numero da NF
								[25]	- Apos a geracao das comissoes
								[26]	- Num sei
								[27]	- Num sei
								[28]	- Num sei
								[29]	- Num sei
								[30]	- Depois de definir os campos obrigatorios (generico)
								.:sempre que for incluido um ponto de entrada sera preciso altera o "Define" no inicio do fonte de nome "SnMaxPE"
*/

Default nTipo := 0

For nX:=1	To SnMaxPE
	aRet[nX][1]	:=	""
	aRet[nX][2]	:=	"LOCXPE"+StrZero(nX,2)
Next

//³Montando os pontos de entrada de acordo com o tipo da Nota³

Do Case
	Case nTipo == 1 .Or. nTipo == 17 .OR. nTipo == 18 .OR. nTipo == 19 //Especifico EQUADOR - Nota Venta | Aus - RCTI | Mexico - Adiantamento
		aRet[04][1]	:= "M460PROC"	;	aRet[08][1]	:= "SF2460I"
		aRet[09][1]	:= "MTASF2"		;	aRet[10][1]	:= "GRVCOSB2"
		aRet[11][1]	:= "A467GRAV"	;	aRet[12][1]	:= "SC6460X"
		aRet[13][1]	:= "MSD2UM2"	;	aRet[14][1]	:= "MSD2460"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1]	:= "M467SQNF" 	;	aRet[32][1]	:= "M467FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 2
		aRet[04][1]	:= "M460PROC"  ;	aRet[05][1]	:= "M465SF3D"
		aRet[08][1]	:= "M465SF2"   ;	aRet[09][1]	:= "MTASF2"
		aRet[10][1]	:= "GRVCOSB2"	;	aRet[11][1]	:= "A467GRAV"
		aRet[12][1]	:= "SC6460X"  	;	aRet[13][1]	:= "MSD2UM2"
		aRet[14][1]	:= "M465SD2"	;	aRet[16][1]	:= "M465BOK"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1] := "M465SQNF"	;	aRet[32][1] := "M465FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 3
		aRet[04][1]	:= "M460PROC"  ;	aRet[05][1]	:= "M465SF3D"
		aRet[08][1]	:= "M465SF2"   ;	aRet[09][1]	:= "MTASF2"
		aRet[10][1]	:= "GRVCOSB2"	;	aRet[11][1]	:= "A467GRAV"
		aRet[12][1]	:= "SC6460X"  	;	aRet[13][1]	:= "MSD2UM2"
		aRet[14][1]	:= "M465SD2"	;	aRet[16][1]	:= "M465BOK"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1] := "M465SQNF"	;	aRet[32][1] := "M465FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 4
		aRet[01][1] := "MT103BUT" 	;	aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	;	aRet[04][1] := "MT100GRV"
		aRet[05][1] := "M465SF3"	;	aRet[06][1] := "A103VLR"
		aRet[07][1] := "GQREENTR"	;	aRet[08][1] := "M465SF1"
		aRet[11][1] := "MT100AGR" 	;	aRet[14][1] := "M465SD1"
		aRet[16][1] := "M465BOK"  	;	aRet[17][1] := "MT100LOK"
		aRet[18][1] := "MT100GE2"	;	aRet[19][1] := "A100F4CP"
		aRet[20][1] := "A103CND2" 	;	aRet[23][1] := "MT100DP"
		aRet[28][1] := "SD1100E"	;	aRet[29][1] := "SF1100E"
		aRet[31][1] := "M465SQNF"	;	aRet[32][1] := "M465FILT"
		aRet[33][1] := "M465CPO"
		aRet[47][1] := "M101SX5"
	Case nTipo == 5
		aRet[01][1] := "MT103BUT" 	;	aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	;	aRet[04][1] := "MT100GRV"
		aRet[05][1] := "M465SF3"	;	aRet[06][1] := "A103VLR"
		aRet[07][1] := "GQREENTR"	;	aRet[08][1] := "M465SF1"
		aRet[11][1] := "MT100AGR" 	;	aRet[14][1] := "M465SD1"
		aRet[16][1] := "M465BOK"  	;	aRet[17][1] := "MT100LOK"
		aRet[18][1] := "MT100GE2"	;	aRet[19][1] := "A100F4CP"
		aRet[20][1] := "A103CND2" 	;	aRet[23][1] := "MT100DP"
		aRet[28][1] := "SD1100E"	;	aRet[29][1] := "SF1100E"
		aRet[31][1] := "M465SQNF"	;	aRet[32][1] := "M465FILT"
		aRet[33][1] := "M465CPO"
		aRet[47][1] := "M101SX5"
	Case nTipo == 6
		aRet[04][1]	:= "M460PROC" 	;	aRet[08][1]	:= "M466SF2"
		aRet[09][1]	:= "MTASF2"		;	aRet[10][1]	:= "GRVCOSB2"
		aRet[11][1]	:= "A466DBTO"	;	aRet[12][1]	:= "SC6460X"
		aRet[13][1]	:= "MSD2UM2"	;	aRet[14][1]	:= "M466SD2"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1]	:= "M466SQNF"	;	aRet[32][1]	:= "M466FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 7 .Or. nTipo == 22
		aRet[04][1]	:= "M460PROC" 	;	aRet[08][1]	:= "M466SF2"
		aRet[09][1]	:= "MTASF2"		;	aRet[10][1]	:= "GRVCOSB2"
		aRet[11][1]	:= "A466DBTO"	;	aRet[12][1]	:= "SC6460X"
		aRet[13][1]	:= "MSD2UM2"	;	aRet[14][1]	:= "M466SD2"
		aRet[21][1]	:= "ME4_COND"	;	aRet[22][1]	:= "M460COND"
		aRet[24][1]	:= "M460NUM"  	;	aRet[25][1]	:= "FA440COM"
		aRet[26][1]	:= "MS520VLD"	;	aRet[27][1]	:= "SF2520E"
		aRet[31][1]	:= "M466SQNF"	;	aRet[32][1]	:= "M466FILT"
	Case nTipo == 8
		aRet[01][1] := "MT103BUT" 	;	aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	;	aRet[04][1] := "MT100GRV"
		aRet[06][1] := "A103VLR"	;	aRet[07][1] := "GQREENTR"
		aRet[08][1] := "M466SF1"  	;	aRet[11][1] := "A466CRTO"
		aRet[14][1] := "M466SD1"	;	aRet[16][1] := "MT100TOK"
		aRet[17][1] := "MT100LOK"	;	aRet[18][1] := "MT100GE2"
		aRet[19][1] := "A100F4CP"	;	aRet[20][1] := "A103CND2"
		aRet[23][1] := "MT100DP"	;	aRet[28][1] := "SD1100E"
		aRet[29][1] := "SF1100E"	;	aRet[31][1] := "M466SQNF"
		aRet[32][1] := "M466FILT"
		aRet[47][1] := "M101SX5"
	Case nTipo == 9 .Or. nTipo == 23
		aRet[01][1] := "MT103BUT" 	;	aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	;	aRet[04][1] := "MT100GRV"
		aRet[06][1] := "A103VLR"	;	aRet[07][1] := "GQREENTR"
		aRet[08][1] := "M466SF1"  	;	aRet[11][1] := "A466CRTO"
		aRet[14][1] := "M466SD1"  	;	aRet[16][1] := "MT100TOK"
		aRet[17][1] := "MT100LOK"	;	aRet[18][1] := "MT100GE2"
		aRet[19][1] := "A100F4CP"	;	aRet[20][1] := "A103CND2"
		aRet[23][1] := "MT100DP"	;	aRet[28][1] := "SD1100E"
		aRet[29][1] := "SF1100E"	;	aRet[31][1] := "M466SQNF"
		aRet[32][1] := "M466FILT"
		aRet[47][1] := "M101SX5"
	Case nTipo == 10
		aRet[01][1] := "MT103BUT" 	; aRet[02][1] 	:= "MT103NFE"
		aRet[03][1] := "MT100F4"	; aRet[04][1] 	:= "MT100GRV"
	 	aRet[06][1] := "A103VLR"	; aRet[07][1] 	:= "GQREENTR"
	 	aRet[08][1] := "SF1100I"	; aRet[11][1]	:= "MT100AGR"
		aRet[14][1] := "SD1100I"	; aRet[15][1] 	:= "M100GRAV"
		aRet[16][1] := "MT100TOK"	; aRet[17][1] 	:= "MT100LOK"
		aRet[18][1] := "MT100GE2"	; aRet[19][1] 	:= "A100F4CP"
		aRet[20][1] := "A103CND2"	; aRet[23][1] 	:= "MT100DP"
		aRet[28][1] := "SD1100E"	; aRet[29][1] 	:= "SF1100E"
		aRet[45][1] := "M101SER"
		aRet[47][1] := "M101SX5"
	Case nTipo == 11
		aRet[04][1]	:= "M460PROC"	; aRet[08][1] := "SF2460I"
		aRet[09][1]	:= "MTASF2"		; aRet[10][1] := "GRVCOSB2"
		aRet[11][1]	:= "A467GRAV"	; aRet[12][1] := "SC6460X"
		aRet[13][1]	:= "MSD2UM2"	; aRet[14][1] := "MSD2460"
		aRet[21][1]	:= "ME4_COND"	; aRet[22][1] := "M460COND"
		aRet[24][1]	:= "M460NUM"	; aRet[25][1] := "FA440COM"
		aRet[26][1]	:= "MS520VLD"	; aRet[27][1] := "SF2520E"
		aRet[31][1]	:= "M467SQNF"	; aRet[32][1] := "M467FILT"
		aRet[36][1]	:= "A467VEN"
	Case nTipo == 12
		aRet[01][1] := "MT103BUT" 	; aRet[02][1] := "MT103NFE"
		aRet[03][1] := "MT100F4"	; aRet[04][1] := "MT100GRV"
		aRet[06][1] := "A103VLR"	; aRet[07][1] := "GQREENTR"
		aRet[08][1] := "SF1100I"	; aRet[11][1] := "MT100AGR"
		aRet[14][1] := "SD1100I"	; aRet[15][1] := "M100GRAV"
		aRet[16][1] := "MT100TOK"	; aRet[17][1] := "MT100LOK"
		aRet[18][1] := "MT100GE2"	; aRet[19][1] := "A100F4CP"
		aRet[20][1] := "A103CND2" 	; aRet[23][1] := "MT100DP"
		aRet[28][1] := "SD1100E"	; aRet[29][1] := "SF1100E"
		aRet[47][1] := "M101SX5"
	Case nTipo == 13 .OR. nTipo == 14
		aRet[08][1] := "SF1100I"
	Case nTipo == 50
		aRet[11][1] := "RMT50FIM"
	Case cPaisLoc == "MEX" .And. nTipo == 54
		aRet[31][1] := "M462TSR"
	Case cPaisLoc == "ARG" .And. nTipo == 51
		aRet[17][1] := "MT100LOK"
	Case nTipo == 64 .And. If(Type("cEspecDoc")=="U",Alltrim(SF1->F1_ESPECIE),cEspecDoc) == "RTE" .AND. cPaisLoc == "ARG"
		aRet[07][1] := "GQREENTR"
EndCase
Aeval(aRet, { |x,y| IIf(Empty(x),aRet[y]:="",) } )
Return(aRet)

/*

±±ºPrograma  ³LOCXPARAM   ºLeandro C.G. ³Microsiga   º Data ³  19/02/2002 º±±

±±ºDesc.     ³ Efetua a consistencia dos parametros na entrada das funcoesº±±
±±º			 ³de acordo com o tipo de consistencia desejada				  º±±

Parametros
cProg		- 	nome da funcao de onde serao checados os param.
aPars		- 	dados sobre cada paramtero que deve ser consistido
				[1]	- nome do parametro
				[2] - conteudo do parametro
				[3] - tipo da validacao
				... qdo tipo de validacao for SpValor ([3] == SpValor)
					[4] valor minimo
					[5] valor maximo
				... qdo tipo de validacao for SpLenArray ([3] == SpLenArray)
					[4] Length minimo
					[5] Length maximo
				... qdo tipo de validacao for Sp2String ([3] == Sp2String)
					[4] String 1
					[5] String 2
				... qdo o tipo de validacao for Sp4String
					[4] String 1
					[5] String 2
					[6] String 3
					[7] String 4
lMensagem	-	indica se deve mostrar ou nao mensagem de erro (Default .T.)

-------------------------
-- TIPOS DE VALIDACOES --
-------------------------
SpEmpty		- verifica se o conteudo esta vazio
SpValor		- verifica se o valor numerico esta dentro de dois limites (maximo e minimo). Neste caso o parametro aPars
			possuira duas posicoes especiais ([4]-limite minimo / [5]-limite maximo
SpLenArray	- verifica se o Length do array esta dentro de dois limites (maximo e minimo). Neste caso o paramteros aPars
			possuira duas posicoes especiais ([4]-limite minimo / [5]-limite maximo
Sp2String	- verifica se o conteudo e igual a uma de duas string's. Neste caso o parametro aPars possuira duas posicoes
			especiais ([4]-string1 / [5]-string2)
Sp4String	- verifica se o conteudo e igual a uma de quatro string's. Neste caso o parametro aPars possuira quatro posicoes
			especiais ([4]-string1 / [5]-string2 / [6]-string3 / [7]-string4)
SpValType	- verifica o tipo do conteudo de um parametro. Neste caso o parametro aPars possuira uma pos. especial
			([4] - tipo desejado ("A";"C";"L";"N"...)
*/
Function LocxParam(cFunc,aPars,lMensagem)
Local lRet		  := .T.					//Indica inconsistencias
Local nI									//Flag para loop's

Default lmensagem := .T.
Default aPars     := {}
Default cFunc	  := ""

//³Verificando parametros da propria funcao³

If lRet
 	Aeval(aPars, { |x,y| IIf(ValType(aPars[y])!="A",aPars[y]:={},),IIf(Len(x)<3,Asize(x,3),), IIf(aPars[y][3]==NIL,aPars[y][3]:=0,), IIf(aPars[y][1]==NIL,aPars[y][1]:="",) } )

	//³Validando todos os param.³

	nI := 0
	For nI := 1 to Len(aPars)

		//³Validando parametros de acordo com o tipo selecionado³

		Do Case

			//³Verifica se o conteudo esta vazio³

			Case aPars[nI][3] == SpEmpty
				If aPars[nI][2] == NIL
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf

			//³Verifica se o valor numero se encontra dentro dos limites estabelecidos³

			Case aPars[nI][3] == SpValor
				Asize(aPars[nI],5)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:=0,)
				IIf(aPars[nI][5]==NIL,aPars[nI][5]:=0,)
				If aPars[nI][2] == NIL .OR. aPars[nI][2] < aPars[nI][4] .OR. aPars[nI][2] > aPars[nI][5]
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf
			//³Verifica o Lenght minimo de um array³

			Case aPars[nI][3] == SpLenArray
				Asize(aPars[nI],5)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:=0,)
			IIf(aPars[nI][5]==NIL,aPars[nI][5]:=0,)
				If ValType(aPars[nI][2]) != "A" .OR. ;
				   Len(aPars[nI][2]) < aPars[nI][4] .OR. Len(aPars[nI][2]) > aPars[nI][5]
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf

			//³Verifica se o contudo e igual a uma de duas strings      ³

			Case aPars[nI][3] == Sp2String
				Asize(aPars[nI],5)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:="",)
				IIf(aPars[nI][5]==NIL,aPars[nI][5]:="",)
				If aPars[nI][2] == NIL .OR. (aPars[nI][2] != aPars[nI][4] .AND. aPars[nI][2] != aPars[nI][5])
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf

			//³Verifica se o contudo e igual a uma de quatro strings      ³

			Case aPars[nI][3] == Sp4String
				Asize(aPars[nI],7)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:="",)
				IIf(aPars[nI][5]==NIL,aPars[nI][5]:="",)
				IIf(aPars[nI][6]==NIL,aPars[nI][6]:="",)
				IIf(aPars[nI][7]==NIL,aPars[nI][7]:="",)
				If aPars[nI][2] == NIL .OR. ;
				   (aPars[nI][2] != aPars[nI][4] .AND. aPars[nI][2] != aPars[nI][5] .AND. aPars[nI][2] != aPars[nI][6] .AND. aPars[nI][2] != aPars[nI][7])
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf

			//³Verifica se o tipo do contudo e do tipo desejado ³

			Case aPars[nI][3] == SpValType
				Asize(aPars[nI],4)
				IIf(aPars[nI][4]==NIL,aPars[nI][4]:="",)
				If ValType(aPars[nI][2]) != aPars[nI][4]
					If lMensagem
						Alert(STR0010+cFunc+CRLF+STR0011+aPars[nI][1])
					EndIf
					lRet := .F.
				EndIf
		EndCase
	Next nI
EndIf
Return(lRet)

/*

±±ºPrograma  ³SCMToNF   º±±

±±ºDesc.     ³ Mostra os remitos que sera amarrados ao documento sendo di-º±±
±±º          ³gitado (devolucao ou NF de entrada)                         º±±
*/
Function SCMToNF()
Local aRecs    := {}
Local aRecCols := {}
Local aRecHeader:={}
Local aRet     := {}
Local aCpoExt  := {}
Local aCpoExtra:= {}
Local aAreaSD1 := GetArea()
Local nI       := 0
Local nDescri  := 0
Local nPorDesc	:= 0
Local nItemRem := 0
Local nUm      := 0
Local nSegum   := 0
Local nCod     := 0
Local nLocal   := 0
Local nQuant   := 0
Local nQtdACla := 0
Local nRemito  := 0
Local nItem    := 0
Local nTes     := 0
Local nCF      := 0
Local nSeriRem := 0
Local nLOTEFOR := 0
Local nLOTECTL := 0
Local nNUMLOTE := 0
Local nDTVALID := 0
Local nProvEnt := 0
Local nConcept := 0
Local nIPI     := 0
Local nQtSegUm := 0
Local nConta   := 0
Local nCCusto  := 0
Local nFDESC   := 0
Local nBsImp1M	:= 0
Local nVlImp1M	:= 0
Local nTotalM	:= 0
Local cTipoDoc := ""
Local cCliFor:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_FORNECE,M->F2_CLIENTE)
Local cLoja  := IIf(aCfgNF[SAliasHead]=="SF1",M->F1_LOJA,M->F2_LOJA)
//Local nPosSolici := 0
//Local cCampo := "" ,cItem	:=	""
Local cSeek  := "'" + xFilial('SD1')+cCliFor+cLoja + "'"
Local cCondUser := ""
Local nPedido	:= 0
Local nItemPC	:= 0

//Alteracao para buscar o remito de SD1
Local cWhile := "!EOF() .AND. SD1->D1_FILIAL+SD1->D1_FORNECE+SD1->D1_LOJA== " + cSeek
Local cCondicao2 := ""
Local cPe		:=	""
Local cPeT		:=	""
Local aCposF4	:= 	   {"D1_DOC",;
						"D1_FORNECE",;
						"D1_LOJA"   ,;
						"D1_ITEM"   ,;
						"D1_COD"	,;
						"D1_UM"     ,;
						"D1_QUANT"  ,;
						"D1_QTDACLA",;
						"D1_SEGUM"  ,;
						"D1_QTSEGUM",;
						"D1_LOCAL"  ,;
						"D1_PEDIDO" }

Local nFEPP    := 0
Local nIE	   := 0
Local cTipConv := GetNewPar("MV_ALTTXNF",'1')
Local nTaxaNf  := 0
Local nTaxaPed := 0
Local nSeguro  := 0
Local nFrete   := 0
Local nDescont := 0
Local nDespesa := 0
//Local nDesNTrb := 0
//Local nTara    := 0
Local nDifRem  := 0
Local nVlTotal := 0
Local cFilSC7		:= xFilial("SC7")
Local nT_TOTAL	:= TamSx3("D1_TOTAL")[2]
Local nT_VUNIT	:= TamSX3("D1_VUNIT")[2]
Local cFilSF1		:= xFilial("SF1")
Local cFilSB1		:= xFilial("SB1")
Local lCheckMoed	:= .T.
Local aChMoeda 	AS Array
Local aHeaderSDE	:= {}
//Local cCFO			:= ""

Private aColsSD1 	:= aCols

cPet := LocxPEt(34)
If !Empty(cPet)
	cCondUser	:=	ExecTemplate(cPEt,.F.,.F.,)
EndIf
cPe	:=	LocxPE(34)
If !Empty(cPe)
	cCondUser	:=	IIf(Empty(cCondUser),""," .AND. ") + Execblock(cPE,.F.,.F.,)
EndIf
If Empty(cCliFor) .OR. Empty(cLoja)
	Aviso(cCadastro,STR0094,{STR0021}) //"Llene los datos del encabezado."###"OK"
	Return
EndIf
If nModulo == 12 .AND. !nModulo == 72
	Aviso(cCadastro,STR0238,{STR0021})  //"Esta funcionalidade nao esta habilitada para o modulo SigaLoja."
	Return
EndIf
For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D1_DESCRI"
			nDescri  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FDESC"
			nFDESC  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DESC"
			nPorDesc	:= nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMREM"
			nItemRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SEGUM"
			nSegum   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_REMITO"
			nRemito  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SERIREM"
			nSeriRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTEFOR"
			nLoteFor := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_IPI"
			nIpi     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VUNIT"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CC"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FEPP"
			nFepp := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_IE"
			nIE   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VALDESC"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_PROVENT"
			nProvEnt := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CONCEPT"
			nConcept := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMCTA"
			nItConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CLVL"
			nClValor := nI
		Case Alltrim(aHeader[nI][2]) == "D1_BSIMP1M" .AND. cPaisloc == "RUS"
			nBsImp1M := nI
		Case Alltrim(aHeader[nI][2]) == "D1_VLIMP1M" .AND. cPaisloc == "RUS"
			nVlImp1M := nI
		Case Alltrim(aHeader[nI][2]) == "D1_TOTALM" .AND. cPaisloc == "RUS"
			nTotalM := nI
		Case Alltrim(aHeader[nI][2]) == "D1_PEDIDO"
			nPedido := nI
		Case Alltrim(aHeader[nI][2]) == "D1_ITEMPC"
			nItemPC := nI
	Endcase
Next nI
//verifica o tipo de documento.
If aCfgNF[SnTipo] == 4 .OR. aCfgNF[SnTipo] == 5
	cTipoDoc := "51/53"
ElseIf aCfgNF[SnTipo] == 10
	cTipoDoc := "60"
Else
	Return
EndIf
lFilData:=.T.
If ExistBlock("LOCFDTR")
	lFilData:=Execblock("LOCFDTR",.F.,.F.,)
EndIf
If nRemito * nSeriRem * nItemRem > 0
	If lFilData
		cCondicao2 	:= IIf(Empty(cCondicao2),""," .And. ") + "DTOS(SD1->D1_DTDIGIT)<='"+Dtos(dDataBase)+"' .And. SD1->D1_QTDACLA > 0 .And. AllTrim(SD1->D1_TIPO) == aCfgNF["+AllTrim(Str(ScTipoDoc))+"] .And. AllTrim(SD1->D1_TIPODOC) $ Alltrim('"+cTipoDoc+"')"
    Else
    	cCondicao2 	:= IIf(Empty(cCondicao2),""," .And. ") +" SD1->D1_QTDACLA > 0 .And. AllTrim(SD1->D1_TIPO) == aCfgNF["+AllTrim(Str(ScTipoDoc))+"] .And. AllTrim(SD1->D1_TIPODOC) $ Alltrim('"+cTipoDoc+"')"
    EndIf
	If aCfgNF[SnTipo] <> 10
		cCondicao2 +=  ".And. Iif(Ascan(aColsSD1,{ |X| X["+Alltrim(str(nRemito))+"]+ X["+Alltrim(Str(nSeriRem))+"] +X["+Alltrim(Str(nItemRem))+"] == SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_ITEM})==0,.T.,.F. )"
	EndIf
	If !Empty(cCondUser)
		cCondicao2 := "(" + cCondicao2 + ") .AND. (" + cCondUser + ")"
	EndIf
	If ExistBlock('LOCXCOND')
		cCondicao2 := Execblock('LOCXCOND',.F.,.F.,{cCondicao2,"I"})
	EndIf
	//³Ponto de entrada para adicao de campos ao gride de itens.³
	//³Deve retornar um array e cada item deve ter a seguinte   ³
	//³estrutura:                                               ³
	//³	                                                        ³
	//³[n,1] = Nome do Campo    (SX3)                           ³
	//³[n,2] = Formula para o conteudo do campo                 ³
	//³[n,3] = Coluna em que o campo sera visualizado           ³
	aCpoExt   := {}
	aCpoExtra := {}
	cPe	:=	LocxPE(46)
	If !Empty(cPe)
		aCpoExtra := Execblock(cPE,.F.,.F.,)
		If (ValType(aCpoExtra) == "A")
			For nI := 1 To Len(aCpoExtra)
				If ValType(aCpoExtra[nI]) == "A"
					Aadd(aCpoExt,{,aCpoExtra[nI,1],,,,,,,,,aCpoExtra[nI,2],aCpoExtra[nI,3]})
				Endif
			Next
		Endif
	EndIf
	If cPaisLoc =="RUS"
		aRet := LocxF4("SD1",10,cWhile,cSeek,aCposF4,,DESCREM,cCondicao2,.T.,,aCpoExt,,"LockSCM(Agrid[6,oLBCli:nAt])",.F.,,.T.,.T.)  // Retorna os Recnos das linhas selecionadas
	Else
		aRet := LocxF4("SD1",10,cWhile,cSeek,aCposF4,,DESCREM,cCondicao2,.T.,,aCpoExt,,"LockSCM(Agrid[6,oLBCli:nAt])",.F.,,.T.)  // Retorna os Recnos das linhas selecionadas
	EndIf
	Eval( bFilBrw )
Else
	Alert(STR0098 + " D2_REMITO, D2_SERIREM, D2_ITEMREM.")//"Para utilizar esta opcao se faz
EndIf
If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs	  := aRet[3]
	aRecCols  := aRet[2]
	aRecHeader:= aRet[1]
EndIf
If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return
EndIf
//check currency in selected recocds
If cPaisLoc == "RUS"
	If Len(aRecs) > 1
		aChMoeda	:= {}
		for nI:=1 to Len(aRecs)
			SD1->(MsGoto(aRecs[nI]))
			SF1->(DbSetOrder(1))
			If (SF1->(MsSeek(cFilSF1+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA)))	//F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO
				Aadd(aChMoeda,SF1->F1_MOEDA)
				dmaxRem := max(dmaxRem, SF1->F1_EMISSAO)
			Else
				lCheckMoed := .F.
			EndIf
		Next nI
		If lCheckMoed
			aSort(aChMoeda,,,{ |x, y| x < y })
			for nI:=1 to Len(aChMoeda)-1
				if aChMoeda[nI]<>aChMoeda[nI+1]
					lCheckMoed	:= .F.
					Exit
				EndIf
			next nI
		EndIf
	Else
		SD1->(MsGoto(aRecs[1]))
		SF1->(DbSetOrder(1))
		If (SF1->(MsSeek(cFilSF1+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA)))	//F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO
			dmaxRem := SF1->F1_EMISSAO
		Else
			lCheckMoed := .F.
		EndIf
	EndIf
EndIf
If !lCheckMoed
	Help("A100MOEDA",1,STR0403)	//Selected Records have different currency
EndIf
If lCheckMoed
	If Len(aCols)==0
		cItem	:=	StrZero(0,TamSx3('D1_ITEM')[1])
	Else
		If nItem>0
			If Len(aCols)>1
				If !Empty(aCOLS[Len(aCols)][nCod])
					cItem:=aCols[Len(aCols)][nItem]
				Else
					cItem:=aCols[Len(aCols)-1][nItem]
				EndIf
			Else
				cItem	:=	StrZero(0,TamSx3('D1_ITEM')[1])
			EndIf
		EndIf
	EndIf
	nI:=0
	For nI := 1 To Len(aRecs)
		cItem	:=	Soma1(cItem)
		//Prorrateo por centro de costo
		If cPaisLoc == "ARG" .And. FunName() == "MATA101N"
			aHeaderSDE:=HeaderSDE(aHeaderSDE)
			RateioRemFac(aHeaderSDE,@aRatCC,cItem,aRecs[nI])
		EndIf
		If ( nCod > 0  .AND.  !Empty(aCOLS[Len(aCols)][nCod]))
			AAdd(aCols,Array(Len(aHeader)+1))
		EndIf
		aCols[Len(aCols)][Len(aHeader)+1]:=.F.
		SD1->(MsGoto(aRecs[nI]))
		SB1->(MsSeek(cFilSB1+SD1->D1_COD))
		SC7->(dbSetOrder(1)) // C7_FILIAL+C7_NUM+C7_ITEM
		SC7->(MsSeek(cFilSC7+SD1->D1_PEDIDO+SD1->D1_ITEMPC))

		If (nDescri  >  0  ,  aCOLS[Len(aCols)][nDescri ] := SD1->D1_DESCRI ,)
		If (nFDESC   >  0  ,  aCOLS[Len(aCols)][nFDESC  ] := SD1->D1_FDESC ,)
		If (nItemRem >  0  ,  aCOLS[Len(aCols)][nItemRem] := SD1->D1_ITEM   ,)
		If (nUm      >  0  ,  aCOLS[Len(aCols)][nUm     ] := SD1->D1_UM     ,)
		If (nSegum   >  0  ,  aCOLS[Len(aCols)][nSegum  ] := SD1->D1_SEGUM  ,)
		If (nCod     >  0  ,  aCOLS[Len(aCols)][nCod    ] := SD1->D1_COD	  ,)
		If (nSeriRem >  0  ,  aCOLS[Len(aCols)][nSeriRem] := SD1->D1_SERIE  ,)
		If (nLocal   >  0  ,  aCOLS[Len(aCols)][nLocal  ] := SD1->D1_LOCAL  ,)
		If nQuant   >  0
			If aCfgNF[SnTipo] == 10
				aCOLS[Len(aCols)][nQuant  ] := aRecCols[nI ,Ascan(aRecHeader,{|X| Alltrim(X) ==  "D1_QTDACLA" })]
			Else
				aCOLS[Len(aCols)][nQuant  ] := SD1->D1_QTDACLA
			EndIf
			nQtdACla := aCOLS[Len(aCols)][nQuant  ]
		EndIf
		If (nRemito  >  0  ,  aCOLS[Len(aCols)][nRemito ] := SD1->D1_DOC	  ,)
		If (nItem    >  0  ,  aCOLS[Len(aCols)][nItem   ] := cItem			  ,)
		If (nTes     >  0  ,  aCOLS[Len(aCols)][nTes    ] := SD1->D1_TES    ,)
		If (nCF      >  0  ,  aCOLS[Len(aCols)][nCF     ] := SD1->D1_CF     ,)
		If (nLOTEFOR >  0  ,  aCOLS[Len(aCols)][nLOTEFOR] := SD1->D1_LOTEFOR,)
		If (nLOTECTL >  0  ,  aCOLS[Len(aCols)][nLOTECTL] := SD1->D1_LOTECTL,)
		If (nNUMLOTE >  0  ,  aCOLS[Len(aCols)][nNUMLOTE] := SD1->D1_NUMLOTE,)
		If (nDTVALID >  0  ,  aCOLS[Len(aCols)][nDTVALID] := SD1->D1_DTVALID,)
		If (nProvEnt >  0  ,  aCOLS[Len(aCols)][nProvEnt] := SD1->D1_PROVENT,)
		If (nIPI     >  0  ,  aCOLS[Len(aCols)][nIPI    ] := SD1->D1_IPI    ,)
		If (nQtSegUm >  0  ,  aCOLS[Len(aCols)][nQtSegUm] := SD1->D1_QTSEGUM,)
		If (nConta   >  0  ,  aCOLS[Len(aCols)][nConta  ] := If(!Empty(SD1->D1_CONTA),SD1->D1_CONTA,SB1->B1_CONTA),)
		If (nCCusto  >  0  ,  aCOLS[Len(aCols)][nCCusto ] := If(!Empty(SD1->D1_CC),SD1->D1_CC,SB1->B1_CC),)
		If (nItConta >  0  ,  aCOLS[Len(aCols)][nItConta] := SD1->D1_ITEMCTA,)
		If (nClValor >  0  ,  aCOLS[Len(aCols)][nClValor] := SD1->D1_CLVL,)
		If (nPedido  >  0  ,  aCOLS[Len(aCols)][nPedido ] := SD1->D1_PEDIDO,)
		If (nItemPC  >  0  ,  aCOLS[Len(aCols)][nItemPC ] := SD1->D1_ITEMPC,)

		If cPaisLoc == "EQU" .OR. cPaisLoc == "VEN"
			If (nConcept > 0 , aCOLS[Len(aCols)][nConcept] := If(!Empty(SD1->D1_CONCEPT),SD1->D1_CONCEPT,SC7->C7_CONCEPT),)
		EndIf
		If cPaisLoc == "CHI"
			If (nFEPP    >  0  ,  aCOLS[Len(aCols)][nFEPP   ] := SD1->D1_FEPP   ,)
			If (nIE      >  0  ,  aCOLS[Len(aCols)][nIE     ] := SD1->D1_IE     ,)
		EndIf
		If Select("__LOCXSF1") == 0
			ChkFile("SF1",.F.,"__LOCXSF1")
		Else
			dbSelectArea("__LOCXSF1")
		Endif
		cIndex := CriaTrab(Nil, .F.)
		IndRegua("__LOCXSF1", cIndex, "F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO", , , "")

		__LOCXSF1->(DbSetOrder(1))
		__LOCXSF1->(MSSeek(cFilSF1+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO))
		IIF (type("cCondicao") <> "U" .And. !Empty(__LOCXSF1->F1_COND), cCondicao := __LOCXSF1->F1_COND,)
		//(18/07/18):Change moeda from remito invoice
		If cPaisloc == "RUS"
			M->F1_MOEDA := __LOCXSF1->F1_MOEDA
			M->F1_EMISSAO := dmaxRem
			dDEmissao := dmaxRem
			nMoedaNF := __LOCXSF1->F1_MOEDA
			nMoedaCor := nMoedaNF
			MaFisRef("NF_MOEDA","MT100",__LOCXSF1->F1_MOEDA)
			M->F1_TXMOEDA:=RecMoeda(M->F1_EMISSAO,nMoedaNF)
		EndIf
		nTaxaNF		:= Iif(MaFisRet(,'NF_TXMOEDA')==0,Recmoeda(dDatabase,M->F1_MOEDA),MaFisRet(,'NF_TXMOEDA'))
		nTaxaPed		:= Iif(cTipConv=='1',Iif(__LOCXSF1->F1_TXMOEDA=0,RecMoeda(__LOCXSF1->F1_EMISSAO,__LOCXSF1->F1_MOEDA),__LOCXSF1->F1_TXMOEDA),RecMoeda(dDatabase,__LOCXSF1->F1_MOEDA))
		If nVUnit   >  0
			If SD1->D1_VUNIT <> 0
				nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
			Else
				If ! Empty(SD1->D1_PEDIDO)
					nPrecio := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					nPrecio := RetFldProd(SB1->B1_COD,"B1_UPRC")
					If M->F1_MOEDA<>1 .And. M->F1_TXMOEDA<>0
						nPrecio:=NoRound(nPrecio / M->F1_TXMOEDA,nT_VUNIT)
					EndIf
				EndIf
			EndIf
			If cPaisloc=="ARG" .AND. (SuperGetMV("MV_DESCSAI",.T.,'1')=='2') .and. Alltrim(aCfgNF[8]) == "NCC"
					nPrecio += (SD1->D1_VALDESC / SD1->D1_QUANT)
			EndIf
			aCOLS[Len(aCols)][nVunit] := nPrecio
		EndIf
		If nTotal > 0
			IF SD1->D1_VUNIT <> 0
				nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
			ELSE
				IF .NOT. EMPTY(SD1->D1_PEDIDO)
					nPrecio := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
				ELSE
					nPrecio := RetFldProd(SB1->B1_COD,"B1_UPRC")
					If M->F1_MOEDA<>1 .And. M->F1_TXMOEDA<>0
						nPrecio:=NoRound(nPrecio / M->F1_TXMOEDA,nT_VUNIT)
					EndIf
					aCOLS[Len(aCols)][nVunit] := nPrecio
				ENDIF
			ENDIF
			If cPaisloc=="ARG" .AND. (SuperGetMV("MV_DESCSAI",.T.,'1')=='2') .and. Alltrim(aCfgNF[8]) == "NCC"
				nPrecio += (SD1->D1_VALDESC / SD1->D1_QUANT)
			EndIf
			aCOLS[Len(aCols)][nTotal] := (nPrecio * nQtdACla)
			// Verificação para previnir diferença de centavos quando do retorno da função MaColsToFis
			If nT_TOTAL == 2
				nVlTotal := 0
				nDifRem  := 0.01
				nVlTotal := Round((nPrecio * SD1->D1_QTDACLA),2)
				If ABS(nVlTotal - SD1->D1_TOTAL) == nDifRem
					nVlTotal := SD1->D1_TOTAL
				EndIf
				aCOLS[Len(aCols)][nTotal] := nVlTotal
			EndIf
		Endif
		If nDesc > 0
			IF SD1->D1_VALDESC <> 0
				If nQtdACla == SD1->D1_QUANT
					aCols[Len(aCols)][nDesc] :=xMoeda(SD1->D1_VALDESC,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					aCols[Len(aCols)][nDesc] :=xMoeda(SD1->D1_VALDESC*nQtdACla/SD1->D1_QUANT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
				Endif
			Else
				dbSelectArea("SC7")
				dbSetOrder(1)
				If SC7->(MsSeek(cFilSC7+SD1->D1_PEDIDO+SD1->D1_ITEMPC,.F.))
					If nQtdACla == SC7->C7_QUANT
						aCols[Len(aCols)][nDesc] :=xMoeda(SC7->C7_VLDESC,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
					Else
						aCols[Len(aCols)][nDesc] :=xMoeda(SC7->C7_VLDESC*SC7->C7_QUANT/nQtdAcla ,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
					Endif
				EndIf
			EndIf
		Endif
		If nPorDesc	 > 0
			If SD1->D1_DESC <> 0
				aCOLS[Len(aCols)][nPorDesc ] := SD1->D1_DESC
			Else
				dbSelectArea("SC7")
				dbSetOrder(1)
				If SC7->(MsSeek(cFilSC7+SD1->D1_PEDIDO+SD1->D1_ITEMPC,.F.))
					aCols[Len(aCols)][nPorDesc] := SC7->C7_DESC
				EndIf
			Endif
		Endif
		oGetDados:lNewLine:=.F.
		cPe	:=	LocxPE(35)
		If !Empty(cPe)
			Execblock(cPE,.F.,.F.,)
		EndIf
		AEval(aHeader,{|x,y| If(aCols[Len(aCols)][y]==NIL,aCols[Len(aCols)][y]:=CriaVar(x[2]),) })
		If cPaisLoc == "COL" .And. nCF>0
			MaFisAlt("IT_CF", aCols[Len(aCols)][nCF], Len(aCols))
		EndIf
		MaColsToFis(aHeader,aCols,Len(aCols),"MT100",.T.)
		MafisAlt('IT_FRETE'		,SD1->D1_VALFRE		,Len(aCols))
		MafisAlt('IT_DESPESA'	,SD1->D1_DESPESA	,Len(aCols))
		MafisAlt('IT_DESCONTO'	,SD1->D1_VALDESC	,Len(aCols))
		MafisAlt('IT_SEGURO'	,SD1->D1_SEGURO		,Len(aCols))
		//#PORTUGAL#
		/*If cPaisLoc == "PTG"
			MafisAlt('IT_DESNTRB',SD1->D1_DESNTRB	,Len(aCols))
			MafisAlt('IT_TARA',SD1->D1_TARA	,Len(aCols))
		Endif*/
		nFrete   += SD1->D1_VALFRE
		nDespesa += SD1->D1_DESPESA
		nDescont += SD1->D1_VALDESC
		nSeguro  += SD1->D1_SEGURO
		//#PORTUGAL#
		/*If cPaisLoc == "PTG"
			nDesNTrb += SD1->D1_DESNTRB
			nTara    += SD1->D1_TARA
		Endif*/
		If cPaisloc == "RUS"	//(18/07/18): Value from items of remito invoice
			aCols[Len(aCols)][nBsImp1M] := SD1->D1_BSIMP1M
			MafisAlt('IT_BASEIV1_C1',	SD1->D1_BSIMP1M,	Len(aCols))
			aCols[Len(aCols)][nVlImp1M] := SD1->D1_VLIMP1M
			MafisAlt('IT_VALIV1_C1'	,	SD1->D1_VLIMP1M,	Len(aCols))
			aCols[Len(aCols)][nTotalM] := SD1->D1_TOTALM
		EndIF
	Next nI

	If cPaisLoc == "COL" .And. FunName() == "MATA101N" .And. SF1->(ColumnPos("F1_TPACTIV"))
		MaFisRef("NF_TPACTIV", "MT100", M->F1_TPACTIV)
	EndIf

	// Atualizar pasta Gastos com base nos itens do Remito
	If nFrete > 0 .And. ValType(F1_FRETE) == "N"
		M->F1_FRETE := SF1->F1_FRETE + nFrete
	EndIf
	If nSeguro > 0	.And. ValType(F1_SEGURO) == "N"
		M->F1_SEGURO := SF1->F1_SEGURO + nSeguro
	EndIf
	If nDespesa > 0	.And. ValType(F1_DESPESA) == "N"
		M->F1_DESPESA := SF1->F1_DESPESA + nDespesa
	EndIf
	If nDescont > 0 .And. ValType(F1_DESCONT) == "N"
		M->F1_DESCONT := SF1->F1_DESCONT + nDescont
	EndIf
	//#PORTUGAL#
	/*If cPaisLoc == "PTG"
		If nDesNTrb > 0 .And. ValType(F1_DESNTRB) == "N"
			M->F1_DESNTRB := SF1->F1_DESNTRB + nDesNTrb
		EndIf
		If nTara > 0 .And. ValType(F1_TARA) == "N"
			M->F1_TARA := SF1->F1_TARA + nTara
		EndIf
	Endif*/
	Eval(bDoRefresh)
	oGetDados:obrowse:refresh()
	/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Atualiza o browse de qtde de produtos.³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	AtuLoadQt(.T.)
EndIf
RestArea(aAreaSD1)
Return

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
Function AtuDadosFin(cAliasFin,cAliasHead)
Local cPrefixo:= ""
Local cSeek   := ""
Local nInd    := 0
Local cWhile  :=""
If cAliasHead == "SF1"
	cCondicao    := SF1->F1_COND
	If cAliasFin == "SE2"
		nInd     := 6
		If !Empty(GetMV("MV_2DUPREF"))
			cPrefixo := &(GetMV("MV_2DUPREF"))
		Endif
		cPrefixo := If(Empty(cPrefixo),Criavar("SF1->F1_PREFIXO"),cPrefixo)
		cPrefixo := IIf(Empty(SF1->F1_PREFIXO),cPrefixo,SF1->F1_PREFIXO)
		cSeek    := "'" + xFilial(cAliasFin)+SF1->F1_FORNECE+SF1->F1_LOJA+cPrefixo+SF1->F1_DUPL + "'"
		cWhile   := "E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM=="+cSeek
    Else
		nInd     := 2
		If !Empty(GetMV("MV_2DUPREF"))
			cPrefixo := &(GetMV("MV_2DUPREF"))
		Endif
		cPrefixo := If(Empty(cPrefixo),Criavar("SF1->F1_PREFIXO"),cPrefixo)
		cPrefixo := IIf(Empty(SF1->F1_PREFIXO),cPrefixo,SF1->F1_PREFIXO)
		cSeek    := "'" + xFilial(cAliasFin)+SF1->F1_FORNECE+SF1->F1_LOJA+cPrefixo+SF1->F1_DUPL + "'"
		cWhile   := "E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM=="+cSeek
    EndIf
Else
	cCondicao    := SF2->F2_COND
	If cAliasFin == "SE2"
		nInd     := 6
		If !Empty(GetMV("MV_1DUPREF"))
			cPrefixo := &(GetMV("MV_1DUPREF"))
		Endif
		cPrefixo := If(Empty(cPrefixo),Criavar("SF2->F2_PREFIXO"),cPrefixo)
		cPrefixo := IIf(Empty(SF2->F2_PREFIXO),cPrefixo,SF2->F2_PREFIXO)
		cSeek    := "'" + xFilial(cAliasFin)+SF2->F2_CLIENTE+SF2->F2_LOJA+cPrefixo+SF2->F2_DUPL + "'"
		cWhile   := "E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM=="+cSeek
    Else
		nInd     := 2
		If !Empty(GetMV("MV_1DUPREF"))
			cPrefixo := &(GetMV("MV_1DUPREF"))
		Endif
		cPrefixo := If(Empty(cPrefixo),Criavar("SF2->F2_PREFIXO"),cPrefixo)
		cPrefixo := IIf(Empty(SF2->F2_PREFIXO),cPrefixo,SF2->F2_PREFIXO)
		cSeek    := "'" + xFilial(cAliasFin)+SF2->F2_CLIENTE+SF2->F2_LOJA+cPrefixo+SF2->F2_DUPL + "'"
		cWhile   := "E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM=="+cSeek
    EndIf
EndIf
If cAliasFin == "SE2"
	aRecSE2 := aClone(LocxGrid(cAliasFin,cWhile,,,,cSeek,nInd,,,,)[6])
	aRecSE1 := {}
Else
	aRecSE2 := {}
	aRecSE1 := aClone(LocxGrid(cAliasFin,cWhile,,,,cSeek,nInd,,,,)[6])
EndIf

Eval(bDoRefresh)
Return
/*
±±ºPrograma  ³ATUNUMNF  ºAutor  ³Leandro C. G.       º Data ³  28/02/2002   º±±
±±ºDesc.     ³ Atualiza a numeracao das notas fiscais no arquivo de tabelas º±±
±±ºUso       ³ GravaNfGeral                                                 º±±
Parametros
cNFiscal	- Numero da NF
cSerie		- Serie da NF
cTipDoc 	- Tipo de documento da NF
			  N - Normal ; C - Complemento ; D - Devolucao ; B - Beneficiamento
cAliasCF	- Alias do cliente ou fornec. (SA1/SA2)
*/
Function AtuNumNF(cNFis,cSerie,cTipDoc,cAliasCF)
Local cTabela   := ""
Local cChave    := ""
Local cPe		:= ""
Local lRet 		:= .T.
Local lRetPE	:= .T.
Local lSeqEspecie  := SuperGetMV("MV_SEQESPE",,.F.)

IF Type("cLocxNFPV") == "U"
	cLocxNFPV:= ""
EndIf
IF Type("cIdPVArg") == "U"
	cIdPVArg:= ""
EndIf

//³Acertando formato da numeracao da NF ³

cNFis := Soma1(cNFiscal)
cTabela := IIf(lSeqEspecie,"AC","01")
cChave  := IIf(lSeqEspecie,cEspecDoc+cSerie,cSerie)


//³Ponto de Entrada para permitir nao atualizar a numeracao da nota no SX5  ³

cPe	:= LocxPE(47)
If !Empty(cPE)
	If ValType(lRetPE := ExecBlock(cPe, .F., .F.,{cTabela,cChave}) ) == "L"
		lRet := lRetPE
	EndIf
EndIf

DBSelectArea("SX5")
DBSetOrder(1)

//³Efetua atualizacao da numeracao da nota³

If lRet
	If (cPaisLoc == "ARG") .And. !aCfgNF[SlRemito] .And. Empty(cIdPVArg)
		cIdPVArg := POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
	EndIf

	//Verifica si existe el número de documento en la tabla SF2, si existe, asigna el número siguiente.
	If cPaisLoc == "ARG" .And. !Empty(cSerie) .And. (Type("cFunName")<>"U" .And. cFunName $ "MATA467N") .And. FindFunction("ANumExis")
		While ANumExis(cSerie,cNFis,cLocxNFPV)
			cNFis:= Soma1(cNFis)
		EndDo
	EndIf

	If DBSeek(xFilial("SX5")+cTabela+AllTrim(cChave)+ Iif(cPaisLoc=="ARG",cIdPVArg,""))
		RecLock("SX5",.F.)
			Replace X5_DESCRI 	With cNFis
			Replace X5_DESCSPA	With cNFis
			Replace X5_DESCENG	With cNFis
		MsUnLock()
		IF cPaisLoc $ "EUA|PER|EQU|MEX|COL" .and. X5DESCRI() <> cNFis
			X5Descri(,,,,.F.)
		EndIf
	Else
		RecLock("SX5",.T.)
			Replace X5_FILIAL 	With xFilial("SX5")
			Replace X5_TABELA 	With cTabela
			if cPaisLoc == "ARG"
				Replace X5_CHAVE  	With AllTrim(cChave)+ cIdPVArg
			else
				Replace X5_CHAVE  	With cChave
			endif
			Replace X5_DESCRI 	With cNFis
			Replace X5_DESCSPA 	With cNFis
			Replace X5_DESCENG 	With cNFis
		MsUnLock()
	EndIf
	If (cPaisLoc == "RUS")
		FWPutSX5("TRANSL", "01", cSerie, cNFis, cNFis, cNFis, cNFis)
	Endif
EndIf
Return(lRet)
/*
±±³Funcao    ³NFNumNota ³ Autor ³Leandro C. G.          ³ Data ³05.03.2002³±±
±±³Descri‡…o ³Verifica qual a serie de Nota a ser considerada             ³±±
*/
Function NFNumNota()
Local nVezes    := 0
Local nTamNota  := Len(SF2->F2_DOC)
Local lContinua := .T.
Local nTimeOut  := GetNewPar("MV_NOTAOUT",20)*1000
Local nOpcA     := 0
Local aSerNF    := {}
Local cNumero   := ""
Local oDlg
Local oQual
Local oTimer
Local cCadastro  := OemToAnsi(STR0095) //"Notas"
Local cFilSx5	 := xFilial("SX5")

Default cSerie 	 := ""

IF Type("__lChgX5Fil") == "U" .OR. __lChgX5Fil == NIl
	__lChgX5FIL := ExistBlock("CHGX5FIL")
Endif

IF __lChgX5FIL
	cFilSx5 := ExecBlock("CHGX5FIL",.f.,.f.)
Endif

//³Trava o parametro do SX6 por seguranca
If ( GetMv("MV_NUMITEN",.T.) )
	If InTransact()
		If !RecLock("SX6",.F.)
			lContinua := .F.
        EndIf
    Else
		While ( lContinua .And. !SX6->(MsRLock()) )
			Inkey(1)
			nVezes++
			If ( nVezes > 200 )
				lContinua := .F.
			EndIf
		EndDo
    EndIf
Else
	lContinua := .F.
EndIf

cTabela := "01"


//³Verifica as series de notas fiscais validas  ³

If ( lContinua )

	//³Posiciona o cliente quando for Argentina³

	cAliasC		:= aCfgNf[SAliasHead]
	cPrefC		:= PrefixoCpo(aCfgNf[SAliasHead])
	cCliFor		:= IIf(cAliasC=="SF1","_FORNECE","_CLIENTE")

	DbSelectArea("SX5")
	dbSetOrder(1)
	MsSeek(cFilSX5+cTabela,.F.)

	While ( SX5->X5_FILIAL == cFilSX5 .AND. SX5->X5_TABELA == cTabela .AND. lContinua )

		//³ Se a S‚rie for CPF, n„o mostra no aChoice, pois ‚ utilizada ³
		//³ internamente para emissao de Cupom Fiscal.                  ³

		If ( AllTrim(SX5->X5_CHAVE) != "CPF" .AND. AllTrim(SX5->X5_CHAVE) != "CP" )
			If !cPaisLoc == "ARG" .OR. (aCfgNf[ScCliFor] == "SA1" .AND. Upper(Alltrim(SX5->X5_CHAVE)) == Upper(AllTrim(cSerie)) )
				nVezes := 0
				If InTransact()
					If !RecLock("SX5",.F.)
						aSerNF    := {}
						lContinua := .F.
                    EndIf
				Else
					While ( !SX5->(MsRLock()) .AND. lContinua )
						nVezes ++
						If ( nVezes > 20 )
							aSerNF    := {}
							lContinua := .F.
						EndIf
					EndDo
                EndIf

				AADD( aSerNF,{PadR(SX5->X5_CHAVE,3),LocConvNota(X5Descri(),nTamNota) })
				If ExistBlock("SX5NOTA")
					If !ExecBlock("SX5NOTA",.F.,.F.)
						aSize(aSerNF,Len(aSerNF)-1)
					EndIf
				EndIf
			EndIf
		EndIf
		dbSelectArea("SX5")
		dbSkip()
	End
EndIf

//³Montagem da janela de exibicao  ³

If ( Len(aSerNF) != 0 )
	DEFINE MSDIALOG oDlg TITLE cCadastro From 140,320 To 280,560 OF oMainWnd PIXEL
	oTimer:= TTimer():New(nTimeOut,{|| oDlg:End() },oDlg)
	oTimer:Activate()
	@ 001,010 LISTBOX oQual VAR cVarQ ;
		FIELDS HEADER OemToAnsi(STR0138),cCadastro ; //"Serie"
		SIZE 150,100 ;
		ON DBLCLICK (If(NFNumTroca(@aSerNF,oQual:nAt,@oTimer,nTimeOut),oQual:Refresh(),oDlg:End())) NOSCROLL PIXEL
	oQual:SetArray(aSerNF)
	oQual:bLine := { || {aSerNf[oQual:nAT,1],aSerNf[oQual:nAT,2]}}
	DEFINE SBUTTON FROM 051,058 TYPE 1 ACTION (nOpcA := oQual:nAt,oDlg:End()) ENABLE OF oDlg PIXEL
	If ( cModulo!="TMK" )
		DEFINE SBUTTON FROM 051,088 TYPE 2 ACTION (oDlg:End()) ENABLE OF oDlg
	EndIf
	ACTIVATE MSDIALOG oDlg VALID (oTimer:End(),.T.) CENTERED
	If ( lContinua .AND. nOpcA != 0 )
		cSerie := aSerNF[nOpcA][1]
		cNumero:= aSerNF[nOpcA][2]
	Else
		lContinua := .F.
	EndIf
Else
	Help(" ",1,"A460FLOCK")
EndIf

//³Trava o registro escolhido  ³

If ( lContinua )
	dbSelectArea("SX5")
	dbSetOrder(1)
	If ( MsSeek(cFilSX5+"01"+cSerie) )
		nVezes := 0

		If InTransact()
			If !RecLock("SX5",.F.)
				lContinua := .F.
			EndIf
		Else
			While ( !SX5->(MsRLock()) )
				nVezes ++
				If ( nVezes > 10 )
					Help(" ",1,"A460FLOCK")
					lContinua := .F.
				EndIf
			EndDo
        EndIf

		If ( lContinua )
			SX5->X5_DESCRI  := cNumero
			SX5->X5_DESCSPA := cNumero
			SX5->X5_DESCENG := cNumero
		EndIf
	EndIf
EndIf

//³Destrava os registro do SX5 ³

If !InTransact()
	SX5->(MsRUnLock())
EndIf

//³Destrava o parametro  ³

If ( GetMv("MV_NUMITEN",.T.) )
	If !InTransact()
		SX6->(MsRUnLock())
	EndIf
EndIf
Return lContinua

/*
±±ºPrograma  ³ATUNUMIT  ºAutor  ³Leandro C. G.       º Data ³  04/03/2002   º±±
±±ºDesc.     ³ Atualiza o numero e serie das Notas Fiscais nos itens quando º±±
±±º			 ³for alterado o numero ou serie no cabecalho					º±±
*/
Function AtuNumIt(cNumeroNF)
Local nNF,nSerie//,nI
Local cMnf		:= Iif(ValType(cNumeroNF)<> "C","M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_DOC",cNuMeroNF)
Local cMserie	:= IIf(Type("aCfgNf")=="A","M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE","")
Local cNFiscal,cSerie

If Type("aHeader") == "A" .AND. Type("aCols") == "A" .AND. Type("aCfgNf") == "A" .AND. ;
   Type(cMnf) != "U" .AND. Type(cMserie) != "U"
	nNF			:= Ascan(aHeader, { |x| AllTrim(x[2])==PrefixoCpo(aCfgNf[SAliasCols])+"_DOC" })
	nSerie		:= Ascan(aHeader, { |x| AllTrim(x[2])==PrefixoCpo(aCfgNf[SAliasCols])+"_SERIE" })
	cNFiscal	:= &(cMnf)
	cSerie		:= &(cMserie)
	If nNF > 0 .AND. nSerie > 0
		Aeval(aCols, { |x,y| IIf(x[nNF]!=cNFiscal,aCols[y][nNF]:=cNFiscal,), IIf(x[nSerie]!=cSerie,aCols[y][nSerie]:=cSerie,) })
	EndIf
EndIf
Return(.T.)

/*
±±ºPrograma  ³NFCOMIS   ºAutor  ³Leandro C. G.       º Data ³  05/03/2002   º±±

±±ºDesc.     ³ Devolve o valor de comissao padrao referente ao vendedor     º±±
±±º			 ³desejado 														º±±
Parametros: nVend	- numero do vendedor
*/
Function NFComis(nVend)
Local nComis	:= 0			//Valor de comissao retornado pela funcao

/*
aDados		- Clone do aCols + campos de conteudo padrao e obrigatorio
aCpos		- Campos referentes aos itens da Nota
n			- Item atuzal do aCols ou aDados
*/


//³Verifica se todas as variaveis necessarias estao declaradas³

If nVend != NIL .AND. nVend > 0 .AND. Type("n") == "N" .AND. n > 0 .AND. Type("aDados") == "A" .AND.;
   Type("aCpos") == "A"


	//³pos. dos campos nos itens da Nota ³

	nPosProd	:= Ascan(aCpos, "D2_COD")
	nPosClie	:= Ascan(aCpos, "D2_CLIENTE")
	nPosLoja	:= Ascan(aCpos, "D2_LOJA")


	//³Verifica se o vendedor escolhido esta indicado no cabecalho³

	If Type("M->F2_VEND"+AllTrim(Str(nVend))) != "U" .AND. &("M->F2_VEND"+AllTrim(Str(nVend))) != NIL .AND. AllTrim(&("M->F2_VEND"+AllTrim(Str(nVend)))) != ""


		//³Busca comissao conforme indicado no produto³

		SB1->(DBSetOrder(1))
		If nPosProd > 0	.AND. SB1->(MSSeek(xFilial("SB1")+aDados[n][nPosProd]))
			If !Empty(SB1->B1_COMIS) .AND. SB1->B1_COMIS > 0
				nComis := SB1->B1_COMIS
			EndIf
		EndIf

		//³Busca comissao do cliente³

		SA1->(DBSetOrder(1))
		If !(nComis > 0) .AND. nPosClie > 0 .AND. nPosLoja > 0 .AND. SA1->(MSSeek(xFilial("SA1")+aDados[n][nPosClie]+aDados[n][nPosLoja]))
			If !Empty(SA1->A1_COMIS) .AND. SA1->A1_COMIS > 0
				nComis := SA1->A1_COMIS
			EndIf
		EndIf

		//³Busca comissao do vendedor³

		SA3->(DBSetOrder(1))
		If !(nComis > 0) .AND. SA3->(MSSeek(xFilial("SA3")+&("M->F2_VEND"+AllTrim(Str(nVend)))))
			nComis := SA3->A3_COMIS
		EndIf

	EndIf
EndIf
Return(nComis)

/*

±±ºPrograma  ³NFCOMISTOT ºAutor  ³Leandro C. G.       º Data ³  05/03/2002  º±±
±±ºDesc.     ³ Recalcula o valor de comissao padrao referente ao vendedor   º±±
±±º			 ³desejado em todos os itens da NF					   			º±±

±±ºObs       ³ GravaNfGeral                                                 º±±
Parametros: nVend	- numero do vendedor
*/
Function NFComisTot(nVend)
//Local nComis	:= 0			//Valor de comissao retornado pela funcao
Local nSavn		:= IIf(Type("n")=="N",n,0)
Local nI		:= 0

//³Variavel utilizada na funcao NFComis³

Private aDados	:= {}
Private aCpos	:= {}

//³Verifica se todas as variaveis necessarias estao declaradas³

If nVend != NIL .AND. nVend > 0 .AND. Type("aCols") == "A" .AND. Type("aHeader") == "A"

	//³Verifica se o vendedor escolhido esta indicado no cabecalho³

	If Type("M->F2_VEND"+AllTrim(Str(nVend))) != "U" .AND. &("M->F2_VEND"+AllTrim(Str(nVend))) != NIL


		//³pos. do campo de comissao nos itens da Nota |

		nPosComis	:= Ascan(aHeader,{ |x| AllTrim(x[2])=="D2_COMIS"+AllTrim(Str(nVend)) } )

		//³Alterando o valor de comissao em todos os itens³

		If nPosComis > 0
			aDados	:= aClone(aCols)
			aCpos	:= HeaderCpos()
			For nI := 1 to Len(aCols)
				n := nI
				aCols[nI][nPosComis] := NFComis(nVend)
			Next nI
		EndIf

	EndIf
EndIf

//³Restaura numeracao do aCols³

If nSavn > 0
	n := nSavn
EndIf
Return(.T.)

/*
±±ºPrograma  ³ATUCLIFOR  ºAutor  ³Leandro C. G.       º Data ³  06/03/2002  º±±
±±ºDesc.     ³ Atualiza codigo do cliente ou fornec. e da loja nos itens    º±±
±±º			 ³quando alterar o conteudo de cabecalho               			º±±
*/
Function AtuCliFor()
Local nPosCliFor	:= 0				//pos. do campo de cliente no aHeader
Local nPosLoja		:= 0				//pos. do campo de loja no aHeader
Local lCliFor		:= .F.				//Indica se deve atualizar cliente
Local lLoja			:= .F.				//Indica se deve atualizar loja
Local lAltCond		:= .F.
Local lAltNat		:= .F.
Local cCliForLoj	:= ""
//Local cMunic		:= ""
//Local cActiv		:= ""
//Local nPorBase		:= 0.0

If Type("lAtuFor") == "U"
	lAtuFor := .F.
Endif

//Se não houve alteracao do fornecedor não e necessario passar pela funcao
If READVAR() == "M->F1_FORNECE" .And. !lAtuFor
	Return .T.
EndIf

If Type("aCfgNf") == "A" .AND. Type("aCols") == "A" .AND. Type("aHeader") == "A" .AND. Len(aCols) > 0

	nPosCliFor 	:= Ascan(aHeader, { |x| AllTrim(x[2])==IIf(aCfgNf[SAliasCols]=="SD2","D2_CLIENTE","D1_FORNECE")	})
	nPosLoja 	:= Ascan(aHeader, { |x| AllTrim(x[2])==IIf(aCfgNf[SAliasCols]=="SD2","D2_LOJA"	,"D1_LOJA")	 	})

	lCliFor 	:= nPosCliFor > 0 .AND. Type(IIf(aCfgNf[SAliasHead]=="SF2","M->F2_CLIENTE","M->F1_FORNECE")) 	!= "U"
	lLoja		:= nPosLoja   > 0 .AND. Type(IIf(aCfgNf[SAliasHead]=="SF2","M->F2_LOJA","M->F1_LOJA")) 		!= "U"

	If cPaisLoc == "ARG"
		xCliForARG(Funname(), nPosCliFor, nPosLoja, aHeader, @aCols, bRefresh, aCfgNf, @_nTotOper_, @_aValItem_)
	EndIf

	If lCliFor .OR. lLoja
		Aeval(aCols, { |x,y| IIf(lCliFor,aCols[y][nPosCliFor]:=IIf(aCfgNf[SAliasHead]=="SF2",M->F2_CLIENTE,M->F1_FORNECE),),IIf(lLoja,aCols[y][nPosLoja]:=IIf(aCfgNf[SAliasHead]=="SF2",M->F2_LOJA,M->F1_LOJA),) })
	EndIf
	//Atualizacao da condicao de pagamento.
	If !Empty(aCfgNf[ScOpFin])
		If aCfgNf[SAliasHead] == "SF2"
			cCliForLoj := M->F2_CLIENTE+M->F2_LOJA
		Else
			cCliForLoj := M->F1_FORNECE+M->F1_LOJA
		EndIf
		If aCfgNf[ScCliFor]=="SA2"
			If SA2->A2_COD+SA2->A2_LOJA <> 	cCliForLoj
				Posicione('SA2',1,xFilial('SA2')+cCliForLoj,"A2_NATUREZ")
			EndIf
			If !Empty(SA2->A2_COND) .AND. (SA2->A2_COND <> cCondicao)
				If FunName() == "FINA100"
					cCondicao := GETMV("MV_FINCPGB", , "498")
				Else
					cCondicao := SA2->A2_COND
				EndIf
				lAltCond  := .T.
			Else
				If FunName() == "FINA100"
					cCondicao := GETMV("MV_FINCPGB", , "498")
					lAltCond := .T.
				EndIf
			EndIf
			If !Empty(SA2->A2_NATUREZ) .AND. (SA2->A2_NATUREZ <> cNatureza)
				cNatureza := SA2->A2_NATUREZ
				lAltNat   := .T.
			EndIf
		Else
			If SA1->A1_COD+SA1->A1_LOJA <> 	cCliForLoj
				Posicione('SA1',1,xFilial('SA1')+cCliForLoj,"A1_NATUREZ")
			EndIf
			If !Empty(SA1->A1_COND) .AND. (SA1->A1_COND <> cCondicao)
				cCondicao := SA1->A1_COND
				lAltCond  := .T.
			EndIf
			If !Empty(SA1->A1_NATUREZ) .AND. (SA1->A1_NATUREZ <> cNatureza)
				cNatureza := SA1->A1_NATUREZ
				lAltNat  := .T.
			EndIf
		EndIf

		//Atualiza dados do Folder Financeiro...
		If (lAltCond .Or. lAltNat) .And. (Type('lLocxAuto') == 'U' .Or. !lLocxAuto)
			Eval(bDoRefresh)
		EndIf
	EndIf

EndIf

If cPaisLoc == "EUA"
	xCliForEUA(aCfgNf)
EndIf

If cPaisLoc == "COL"
	xCliForCol(aCfgNf, @cTASARTF)
EndIf

If cPaisLoc == "PAR"
	xCliForPAR()
EndIf

Return(.T.)
/*
±±ºPrograma  ³LocXVal º±±
*/
Function LocXVal(cVar,lExResh)
Local cAux,lRet,aNF,lAltNota, dDataFec
Local lSeqEspecie := SuperGetMV("MV_SEQESPE",,.F.)
Local cChaveSX5   := ""
Local cCAEA		:= ""
Local dCAEAVENC	:= CTOD("\\")
Local aCFD        := {"",""}
Local aRetCF      := {}
Local aDados      := {"","",""}
Local lContrFol   := .F. // Controle de Folios - Uruguai
Local cNCF 		:= "" //Controle folios Numero NCF - Rep. Dom
Local lFunCAEE		:= .T.
Local lSF2CAEE		:= cPaisloc == "ARG"
Local lSF1CAEE		:= cPaisloc == "ARG"
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local cSerieAlt:= ""
Local lOpcQW   := .T.
Local nQtdItem := 0
Local lPermite := .T.
If Type("lDocSp") == "U"
	Private lDocSp := .F.
EndIf
DEFAULT lExResh:=.T.
If cPaisLoc $ "ARG|PAR|CHI" .and. IsInCallStack("MATA143") .Or. (cPaisLoc $ "ARG|PAR|CHI" .And. IsBlind())
	bRefresh := { || {|| Iif(Type("bDoRefresh") <> "B",{|| Nil},Eval(bDoRefresh))}}
	bDoRefresh := { || {||  LxA103Dupl(MaFisRet(,"NF_BASEDUP"),nMoedaCor,dDEmissao,cCondicao,@aTemp,oList,@oNatu,@oDescri,@oCond,@oMoeda,@cNatureza,@cDescri,oNew )}}
EndIF

IF Type("cLocxNFPV") == "U"
	cLocxNFPV:= ""
EndIf

Default cVar=ReadVar()
dDataFec := MVUlmes() // Verificar data do ultimo fechamento

// Controle de Folios - Bolivia
If cPaisLoc == "DOM" .AND. (cVar == Substr(cVar,1,3)+"DOC" .OR. cVar == Substr(cVar,1,3)+"SERIE") // Republica Dominicana
	lContrFol := GetNewPar("MV_CTRLFOL",.T.)
	If (!lContrFol) .AND. lInclui
		MsgAlert(STR0285)
	EndIf
ElseIf cPaisloc == "ARG"
	lContrFol     :=	aCfgNf[SlFormProp] .and. AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720|MATA462N|MATA462DN|MATA462R" .And. GetNewPar("MV_CTRLFOL",.F.)
ElseIf cPaisloc $ "EQU|VEN|PAR"
	lContrFol:=	AllTrim(FunName())$"MATA468N|MATA467N|MATA462N|MATA465N|MATA466N|MATA101N" .And. GetNewPar("MV_CTRLFOL",.F.)
Else
	lContrFol     := cPaisLoc == "BOL" .And. AllTrim(FunName())$"MATA466N|MATA101N|MATA465N|MATA467N|MATA468N|LOJA701|LOJA720" ;
	                 .And. GetNewPar("MV_CTRLFOL",.F.)
EndIf

lRet:=.T.
lAltNota := .F.

Do Case
	Case cVar=="F2_DOC"
		cNFiscal:= IIF(M->F2_DOC <= cNFiscal, cNFiscal, M->F2_DOC )
		cSerie	:=M->F2_SERIE
		If lContrFol
			aDados[1] := cSerie
			aDados[2] := M->F2_ESPECIE
			aDados[3] := cNFiscal
			If !cPaisLoc$'ARG|EQU|VEN|PER|DOM|PAR'
				aRetCF := RetCF(aDados)
				M->F2_NUMAUT := aRetCF[1]
				M->F2_CODCTR := aRetCF[2]
				M->F2_LIMEMIS:= aRetCF[3]
			EndIf
		Endif
		If aCfgNf[SlFormProp]
			If lGerarCFD .and. cPaisLoc <> "PAR"
				lRet := (CFDChkFol(cFilAnt,cSerie,cNFiscal,@aCFD,.F.,.T.,M->F2_ESPECIE) < 2)
				M->F2_APROFOL := aCFD[1]
				M->F2_CERTFOL := aCFD[2]
			Endif
			If lContrFol .And. cPaisloc == "ARG"
				lRet := ChkFolARG(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE, M->F2_PV)
			ElseIf lContrFol .And. cPaisloc=="EQU"
				lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE)
			ElseIf lContrFol .And. cPaisLoc =="VEN|PAR"
				lRet := CtrFolios(cFilAnt,cSerie,M->F2_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisloc=="DOM"
				If (Trim(M->F2_ESPECIE) $ "NF|NCI|NDI|NCC|NDC")
					cNCF := ChkFolDOM(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE)
					lRet := (cNCF!="")
					M->F2_NCF := cNCF
				EndIf
			ElseIf lContrFol .and. cPaisLoc == "URU"
				lRet := ChkFolURU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE)
			ElseIf lContrFol .And. cPaisLoc =="BOL" .and. FindFunction("CtrFolBol")
				lRet := CtrFolBol(cFilAnt,cSerie,M->F2_ESPECIE,cnFiscal)
			EndIf

			If lRet .And. AllTrim(M->F2_ESPECIE) $ "NF/NDC" .AND. IIf(Type("lFiscal")== "L" .And. lFiscal, (SuperGetMv("MV_CONTNFI",,"I") == "M"), .T. )
				If lUsaNewKey
					lRet := VldSX5Num(cNFiscal,SerieNfId("SF2",4,"F2_SERIE",M->F2_EMISSAO,M->F2_ESPECIE,cSerie))
				Else
					lRet := VldSX5Num(cNFiscal,cSerie)
				Endif
			EndIf
			If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF2CAEE
				lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F2_ESPECIE,M->F2_EMISSAO,@cCaea,@dCAEAVENC)
				M->F2_CAEE 	:= cCaea
				M->F2_EMCAEE 	:= dCAEAVENC
			Endif
		Endif
		LocxAtuFis(.T.,cNFiscal)
		MaFisAlt('NF_SERIENF',cSerie)
		If lExResh
		Eval(bRefresh)
		EndIf
	Case cVar=="F2_SERIE"
		cNFiscal:=M->F2_DOC
		If cPaisLoc=="ARG" .and. aCfgNf[SlFormProp] .and. Type("M->F2_PV")=="C" .and. !Empty(M->F2_PV)
		   cSerieAlt:=Subs(Alltrim(SX5->X5_CHAVE),1,Len(Alltrim(SX5->X5_CHAVE))- (TAMSX3("CFH_IDPV")[1]) )
		   If !Empty(cSerieAlt)
		   	M->F2_SERIE  :=cSerieAlt
		   EndIf
		EndIf

		cSerie  :=M->F2_SERIE
		If lContrFol
			aDados[1] := cSerie
			aDados[2] := M->F2_ESPECIE
			aDados[3] := cNFiscal
			If !cPaisLoc $'ARG|EQU|VEN|PER|DOM|PAR'
				aRetCF := RetCF(aDados)
				M->F2_NUMAUT := aRetCF[1]
				M->F2_CODCTR := aRetCF[2]
				M->F2_LIMEMIS:= aRetCF[3]
			EndIf
		Endif
		If (aCfgNf[SlFormProp] .And. FunName()<>"FISA828") .OR. (cPaisLoc == "COL" .AND. cFunName == "MATA466N" .AND. aCfgNF[SnTipo] == 22  )
			If lGerarCFD .and. cPaisLoc <> "PAR"
				lRet := (CFDChkFol(cFilAnt,cSerie,cNFiscal,@aCFD,.T.,.F.,M->F2_ESPECIE) < 2)
				M->F2_APROFOL := aCFD[1]
				M->F2_CERTFOL := aCFD[2]
			Endif
			// Controle de Folios do Uruguai
			If lContrFol .And. cPaisloc=="EQU"
				lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE)
			ElseIf lContrFol .And. cPaisLoc $ "VEN|PAR"
				lRet := CtrFolios(cFilAnt,cSerie,M->F2_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisLoc $ "BOL"
				lRet := CtrFolBol(cFilAnt,cSerie,M->F2_ESPECIE,cnFiscal)
			EndIf

			If lRet
				SX5->(dbSetOrder(1))
				cChaveSX5  := IIf(lSeqEspecie,"AC"+cEspecDoc+cSerie,"01"+cSerie)
				If  cPaisLoc = "ARG" .And. !aCfgNf[SlRemito]
					cChaveSX5  :="01"+AllTrim(cSerie) + POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
				EndIf
				If !(SX5->(dbSeek(xFilial("SX5")+cChaveSX5)))
					Help(" ",1,"A467SERIE")
					lRet:=.f.
				Else
					cNFiscal	:=	Alltrim(X5DESCRI())
					//Controle de Folios da Rep. Dom utiliza F2_DOC na geracao do NCF
					If lContrFol .And. cPaisloc=="DOM"
						If (Trim(M->F2_ESPECIE) $ "NF|NCI|NDI|NCC|NDC")
							cNCF := ChkFolDOM(cFilAnt,cSerie,cNFiscal,cNFiscal,lLocxAuto,M->F2_ESPECIE)
							lRet := (cNCF!="")
							M->F2_NCF := cNCF
						EndIf
					EndIf
				    M->F2_DOC := cNFiscal
				EndIf
			EndIf

			If lContrFol .And. cPaisloc == "ARG"
				If !Empty(cNFiscal)
					lRet := ChkFolARG(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F2_ESPECIE,M->F2_PV)
				EndIf
			EndIf
			If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF2CAEE
				lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F2_ESPECIE,M->F2_EMISSAO,@cCaea,@dCAEAVENC)
				M->F2_CAEE 	:= cCaea
				M->F2_EMCAEE 	:= dCAEAVENC
			Endif

		Endif
		LocxAtuFis(.F.,cNFiscal)
		If  cPaisloc == "ARG" .AND. FUNNAME() == "FINA096" .AND. lRet
			MaFisAlt('NF_SERIENF',cSerie)
		Endif
		Eval(bRefresh)
	Case cVar=="F1_DOC"
    	cNFiscal:=IIF(M->F1_DOC <= cNFiscal, cNFiscal, M->F1_DOC )
		If cPaisLoc =="EUA" .And. AllTrim(M->F1_ESPECIE) == "NCC" .And. cFunName =="MATA465N" .And. FindFunction("LxVlNDocEUA")
			lRet := LxVlNDocEUA(M->F1_DOC,M->F1_SERIE,.T.)
			cNFiscal:= M->F1_DOC
		EndIf
		cSerie	:=M->F1_SERIE
		If aCfgNf[SlFormProp]
			If lGerarCFD .and. cPaisLoc <> "PAR"
				lRet := (CFDChkFol(cFilAnt,cSerie,cNFiscal,@aCFD,.F.,.T.,M->F1_ESPECIE) < 2)
				M->F1_APROFOL := aCFD[1]
				M->F1_CERTFOL := aCFD[2]
			Endif
			If lContrFol .And. cPaisloc == "ARG"
				lRet := ChkFolARG(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE, M->F1_PV)
			ElseIf lContrFol .And. cPaisloc=="EQU"
				lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE)
			ElseIf lContrFol .And. cPaisLoc $ "VEN|PAR"
				lRet := CtrFolios(cFilAnt,cSerie,M->F1_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisLoc $ "BOL"
				lRet := CtrFolBol(cFilAnt,cSerie,M->F1_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisloc=="DOM"
				If (Trim(M->F1_ESPECIE) $ "NCC")
					cNCF := ChkFolDOM(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE)
					lRet := (cNCF!="")
					M->F1_NCF := cNCF
				EndIf
			ElseIf lContrFol .and. cPaisLoc == "URU"
				lRet := ChkFolURU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE)
			EndIf

			If lRet .And. AllTrim(M->F1_ESPECIE) $ "NF/NCC" .AND. IIf(Type("lFiscal")== "L" .And. lFiscal, (SuperGetMv("MV_CONTNFI",,"I") == "M"), .T. )
				If lUsaNewKey
					lRet := VldSX5Num(cNFiscal,SerieNfId("SF1",4,"F1_SERIE",M->F1_EMISSAO,M->F1_ESPECIE,cSerie))
				Else
					lRet := VldSX5Num(cNFiscal,cSerie)
                //#PORTUGAL#
				/*If lRet .And. cPaisLoc == "PTG" .And. lHashPTG  //Valida SF3 - SAFT-PT
                    If !lRet
                        HELP("  ",1,"EXISTNF")
                    EndIf
                EndIf*/
				Endif
			EndIf
			If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF1CAEE
				lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F1_ESPECIE,M->F1_EMISSAO,@cCaea,@dCAEAVENC)
				M->F1_CAEE 	:= cCaea
				M->F1_EMCAEE 	:= dCAEAVENC
			Endif
		Endif
		IF (cPaisLoc=="PAR") .AND. lAutoFact .AND. (ALLTRIM(FunName())=="MATA101N") .and. !EMPTY(M->F1_SERIE) .AND. !EMPTY(M->F1_DOC) .AND. FindFunction("CtrFolAutPAR")
			lRet:=CtrFolAutPAR(cFilAnt,M->F1_SERIE,"1",M->F1_DOC)
		ENDIF
		LocxAtuFis(.T.,cNFiscal)
		If (cPaisLoc <> "RUS")
			MaFisAlt('NF_SERIENF',cSerie)
		Endif
		If lExResh
			Eval(bRefresh)
		EndIf
	Case cVar=="F1_SERIE"
    	cNFiscal:=M->F1_DOC
		If cPaisLoc=="ARG"   .and. aCfgNf[SlFormProp]  .and. Type("M->F1_PV")=="C" .and. !Empty(M->F1_PV)
			cSerieAlt:=Subs(Alltrim(SX5->X5_CHAVE),1,Len(Alltrim(SX5->X5_CHAVE))- (TAMSX3("CFH_IDPV")[1]) )
		   If !Empty(cSerieAlt)
		   	M->F1_SERIE  :=cSerieAlt
		   EndIf
		EndIf
		cSerie  :=M->F1_SERIE
		If aCfgNf[SlFormProp] .OR. (cPaisLoc == "COL" .AND. (lDocSp .OR. aCfgNF[SnTipo] == 23) .AND. cFunName $ "MATA101N|MATA466N"  )
			If lGerarCFD .and. cPaisLoc <> "PAR"
				lRet:=(CFDChkFol(cFilAnt,cSerie,cNFiscal,@aCFD,.T.,.F.,M->F1_ESPECIE) < 2)
				M->F1_APROFOL := aCFD[1]
				M->F1_CERTFOL := aCFD[2]
			Endif

			// Controle de Folios
			If lContrFol .And. cPaisloc=="EQU"
				lRet := ChkFolEQU(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE)
			ElseIf lContrFol .And. cPaisLoc $ "VEN|PAR"
				lRet := CtrFolios(cFilAnt,cSerie,M->F1_ESPECIE,cnFiscal)
			ElseIf lContrFol .And. cPaisLoc $ "BOL"
				lRet := CtrFolBol(cFilAnt,cSerie,M->F1_ESPECIE,cnFiscal)
			EndIf

			If lRet
				SX5->(dbSetOrder(1))
				cChaveSX5  := IIf(lSeqEspecie,"AC"+cEspecDoc+cSerie,"01"+cSerie)
				If cPaisLoc = "ARG" .and. !aCfgNf[SlRemito]
					cChaveSX5  :="01"+AllTrim(cSerie) + POSICIONE("CFH",1, xFilial("CFH")+cLocxNFPV,"CFH_IDPV")
				EndIf
				If !(SX5->(dbSeek(xFilial("SX5")+cChaveSX5)))
					Help(" ",1,"A467SERIE")
					lRet:=.f.
				Else
					cNFiscal	:=	Alltrim(X5DESCRI())
					M->F1_DOC:=	cNFiscal
					//Controle de Folios da Rep. Dom utiliza F1_DOC na geracao do NCF
					If lContrFol .And. cPaisloc=="DOM"
						If (Trim(M->F1_ESPECIE) $ "NCC")
							cNCF := ChkFolDOM(cFilAnt,cSerie,cNFiscal,cNFiscal,lLocxAuto,M->F1_ESPECIE)
							lRet := (cNCF!="")
							M->F1_NCF := cNCF
						EndIf
					EndIf
				EndIf
			EndIf
			If lContrFol .And. cPaisloc == "ARG"
				If !Empty(cNFiscal)
					lRet := ChkFolARG(cFilAnt,cSerie,cNFiscal,cVar,lLocxAuto,M->F1_ESPECIE, M->F1_PV)
				EndIf
			EndIf
			If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF1CAEE
				lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F1_ESPECIE,M->F1_EMISSAO,@cCaea,@dCAEAVENC)
				M->F1_CAEE 	:= cCaea
				M->F1_EMCAEE 	:= dCAEAVENC
			Endif
		Endif
		IF (cPaisLoc=="PAR") .AND. lAutoFact .AND. (ALLTRIM(FunName())=="MATA101N") .AND. FindFunction("CtrFolAutPAR")
			lRet:=CtrFolAutPAR(cFilAnt,M->F1_SERIE,"1",M->F1_DOC)
		ENDIF
		LocxAtuFis(.F.,cNFiscal)
		Eval(bRefresh)
	Case Right(cVar,6)=="_MOEDA"
		If cPaisLoc == "MEX" .And. (AllTrim(FunName()) $ "MATA101N|MATA102N")
			If nMoedaNF	<> &cVar.
				AEval(aCols, {|x,y| If(!Empty(aCols[y][3]), nQtdItem++,.T.)})
				If nQtdItem > 0
					lOpcQW := MsgYesNo(OemToAnsi(STR0415),OemToAnsi(STR0097)) //"Al modificar la moneda del documento los ítems serán limpiados. ¿Desea continuar?" //"Atención"
					If !(lOpcQW .And. nMoedaNF <> &cVar.)
						lRet := .F.
						lPermite := .F.
					EndIf
				EndIf
			Else
				lPermite := .F.
			EndIf
		EndIf
		If lPermite
			nMoedaNF	:=	&cVar.
			If cVar == "F1_MOEDA"
				If &cVar. <> M->F1_MOEDA
					nMoedaNF := M->F1_MOEDA
				EndIf
			EndIf
			If cPaisloc=="RUS" .AND. Left(cVar,2) == "F1"
				nTaxa	:=RecMoeda(M->F1_EMISSAO,nMoedaNF)
			Elseif cPaisloc=="RUS" .AND. Left(cVar,2) == "F2"
				nTaxa	:=RecMoeda(dDEmissao,nMoedaNF)
			Else
				nTaxa	:=RecMoeda(dDataBase,nMoedaNF)
			EndIf
			cAux		:="M->"+Left(cVar,2)+"_TXMOEDA"
			&cAux		:=nTaxa
			If cPaisLoc == "RUS" .AND. Left(cVar,2) == "F1"	//(29/05/18): For recalculation values in Main currency (in Rubles) when F1_MOEDA change F1_TXMOEDA
				ExcRt101N()
			ElseIf cPaisLoc == "RUS" .AND. Left(cVar,2) == "F2"	//(29/05/18): For recalculation values in Main currency (in Rubles) when F2_MOEDA change F2_TXMOEDA
				ExcRt467N()
			EndIf
			//Moeda para a duplicata
			nMoedaCor	:=	nMoedaNF
			MaFisAlt("NF_MOEDA",nMoedaNF)
			If cPaisLoc <> "RUS"
				If AllTrim(FunName()) $ "MATA101N|MATA102N|MATA102DN" .Or. (cPaisLoc $ "ARG|CHI|PAR|URU|BOL" .And. AllTrim(FunName()) $ "MATA465N|MATA466N")
					LocxAtuMoeda(aHeader,@aCols)
				EndIf
			EndIf
			Eval(bRefresh)
		EndIf
	Case Right(cVar,8)=="_TXMOEDA"
		nTaxa		:=	&cVar
		MaFisAlt("NF_TXMOEDA",nTaxa)
		Eval(bRefresh)
	Case cVar=="F2_LOJA"  .AND. aCfgNf[SlFormProp]
		If cPaisLoc == "ARG" .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
			If M->F2_ECF <> "S"
				aNF:=LocXFatAut()
			Else
				aNF    := {"",LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie])}
				aNF[1] := GetNumCFis(aNF[2],aCfgNf[ScEspecie])
			EndIf
			lAltNota := .T.
		Else
			If Empty(M->F2_DOC) .and. cPaisLoc <> "PAR"
				aNF := LocXFatAut()
				lAltNota := .T.
			EndIf
		EndIf
		If lAltNota
			If Len(aNF)==0
				lRet:=.F.
			Else
				cNFiscal	:=	aNF[1]
				cSerie := Padr(aNF[2],TAMSX3("F2_SERIE")[1])
				M->F2_DOC	:=cNFiscal
				M->F2_SERIE	:=cSerie
				If lGerarCFD
					M->F2_APROFOL := aNF[3]
					M->F2_CERTFOL := aNF[4]
				Endif
				MaFisAlt('NF_SERIENF',cSerie)
				Eval(bRefresh)
			Endif
		Endif
	Case cVar=="F2_LOJA" .AND. !aCfgNf[SlFormProp] .AND. cPaisLoc =="ARG"
		cSerie:= LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie]) // Trazer a serie automat.  para o documento
		MaFisAlt("NF_SERIENF",cSerie)
		M->F2_SERIE	:=	cSerie
	Case cVar=="F1_LOJA" .AND. aCfgNf[SlFormProp]
		If cPaisLoc == "ARG" .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
			If M->F1_ECF <> "1"
				aNF:=LocXFatAut()
			Else
				aNF    := {"",LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie])}
				aNF[1] := GetNumCFis(aNF[2],aCfgNf[ScEspecie])
			EndIf
			lAltNota := .T.
		Else
			If Empty(M->F1_DOC)
				aNF := LocXFatAut()
				lAltNota := .T.
			EndIf
		EndIf
		If lAltNota
			If Len(aNF)==0
				lRet:=.F.
			Else
				cNFiscal	:=	aNF[1]
				cSerie		:=	Padr(aNF[2],TAMSX3("F1_SERIE")[1])
				M->F1_DOC	:=	cNFiscal
				M->F1_SERIE	:=	cSerie
				If lGerarCFD
					M->F1_APROFOL := aNF[3]
					M->F1_CERTFOL := aNF[4]
				Endif
				MaFisAlt('NF_SERIENF',cSerie)
				Eval(bRefresh)
			Endif
		Endif
	Case cVar=="F1_LOJA"  .AND. !aCfgNf[SlFormProp]	.AND. cPaisLoc =="ARG"
		cSerie:= LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie]) // Trazer a serie automat.  para o documento
		MaFisAlt("NF_SERIENF",cSerie)
		M->F1_SERIE	:=	cSerie
	Case cVar=="F1_ECF" .AND. aCfgNf[SlFormProp] .AND. cPaisLoc =="ARG" .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
		If M->F1_ECF == "1"
			cSerie:= LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie]) // Trazer a serie automat.  para o documento
			M->F1_SERIE	:=	cSerie
			cNFiscal := GetNumCFis(cSerie,aCfgNf[ScEspecie])
			M->F1_DOC := cNFiscal
			LocxAtuFis(.T.,cNFiscal)
			Eval(bRefresh)
		Else
			cSerie:= ""
			M->F1_SERIE	:=	cSerie
			cNFiscal := ""
			M->F1_DOC := cNFiscal
			LocxAtuFis(.T.,cNFiscal)
			Eval(bRefresh)
		EndIf
	Case cVar=="F2_ECF" .AND. aCfgNf[SlFormProp] .AND. cPaisLoc =="ARG" .AND. IIf(Type("lFiscal")#"U",lFiscal,.F.)
		If M->F2_ECF == "S"
			cSerie:= LocXTipSer(aCfgNf[ScCliFor],aCfgNf[ScEspecie]) // Trazer a serie automat.  para o documento
			M->F2_SERIE	:=	cSerie
			cNFiscal := GetNumCFis(cSerie,aCfgNf[ScEspecie])
			M->F2_DOC := cNFiscal
			LocxAtuFis(.T.,cNFiscal)
			Eval(bRefresh)
		Else
			cSerie:= ""
			M->F2_SERIE	:=	cSerie
			cNFiscal := ""
			M->F2_DOC := cNFiscal
			LocxAtuFis(.T.,cNFiscal)
			Eval(bRefresh)
		Endif
	Case cVar=="F1_EMISSAO"
		If M->F1_EMISSAO > dDatabase
			Help("",1,"A100DATAM")
			lRet  := .F.
		Endif
		If lRet .And. cPaisloc=="ARG" .And. Upper(Alltrim(M->F1_SERIE))=="M"
			If !Empty(SA2->A2_DTINISM) .And. !Empty(SA2->A2_DTFIMSM) .And. (M->F1_EMISSAO < SA2->A2_DTINISM .or. M->F1_EMISSAO > SA2->A2_DTFIMSM)
				MsgAlert(STR0266,STR0018)
				lRet  := .F.
			EndIf
		EndIf
		If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF1CAEE
			lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F1_ESPECIE,M->F1_EMISSAO,@cCaea,@dCAEAVENC)
			M->F1_CAEE 	:= cCaea
			M->F1_EMCAEE 	:= dCAEAVENC
		Endif
		If cPaisLoc == "RUS" .And. !(cEspecie $ "NCC/NDP")	//(06/06/2018): Change Currency according to Date
			If ExcRt101N(.F.)
				cAux	:= "M->F1_TXMOEDA"
				&cAux	:= RecMoeda(M->F1_EMISSAO,M->F1_MOEDA)
				nTaxa	:= RecMoeda(M->F1_EMISSAO,nMoedaNF)
			EndIf
		EndIf
	Case cVar=="F2_EMISSAO"
		If M->F2_EMISSAO > dDatabase
			Help("",1,"A100DATAM")
			lRet  := .F.
		Endif
		If dDataFec >= M->F2_EMISSAO .And. cEspecie<>"NCP"
	   		Help( " ", 1, "FECHTO" )
			lRet  := .F.
		EndIf
		If lRet .And. cPaisloc=="ARG" .And. Upper(Alltrim(M->F2_SERIE))=="M"
			If !Empty(SA2->A2_DTINISM) .And. !Empty(SA2->A2_DTFIMSM) .And. (M->F2_EMISSAO < SA2->A2_DTINISM .or. M->F2_EMISSAO > SA2->A2_DTFIMSM)
				MsgAlert(STR0266,STR0018)
				lRet  := .F.
			EndIf
		EndIf
		If lRet .And. cPaisLoc == "ARG" .And. lFunCAEE .And. lSF2CAEE
			lRet  := VldNFCAEA(cFilAnt,cSerie,cNFiscal, lLocxAuto,M->F2_ESPECIE,M->F2_EMISSAO,@cCaea,@dCAEAVENC)
			M->F2_CAEE 	:= cCaea
			M->F2_EMCAEE 	:= dCAEAVENC
		Endif
	Case cVar=="F2_DTSAIDA"
		If cPaisLoc =="RUS" .AND. !Empty(&(cVar)) .AND. ValType(M->F2_DTSAIDA)== "D"
			dDEmissao:=M->F2_DTSAIDA
			lRet := RU05X0005_(M->F2_EMISSAO,M->F2_DTSAIDA)

			If lRet .And. !(cEspecie $ "NDC/NCP") .And. M->F2_MOEDA != 1
				If ExcRt467N(.F.)
					cAux	:="M->F2_TXMOEDA"
					&cAux	:=RecMoeda(M->F2_DTSAIDA,M->F2_MOEDA)
					nTaxa	:=RecMoeda(M->F2_DTSAIDA,nMoedaNF)
					Eval(bRefresh)
				EndIf
			EndIf
		EndIf
	Case Right(cVar,7)=="TASARFT"
		If cVar == "F1_TASARFT"
			If &cVar. <> cTASARTF
				cTASARTF := &cVar.
				If AllTrim(FunName()) == "MATA101N"
					LOCXATUBASE(aHeader,@aCols)
				EndIf
				Eval(bRefresh)
			EndIf
		EndIf
EndCase
Return lRet
/*
±±³Funcao    ³NFNumTroca  ³ Autor ³Eduardo Riera        ³ Data ³14.03.2002³±±
±±³Descri‡…o ³Efetua a Troca do Numero da Nota                            ³±±
±±³Retorno   ³ExpA1: Series de NF de Saida.           			          ³±±
±±³Parametros³ExpA1: Array com as series da NF                  		  ³±±
±±³          ³ExpN2: Item da Nota de Saida                                ³±±
±±³          ³ExpO3: Objeto Timer                                         ³±±
±±³          ³ExpN4: Time Out.                                            ³±±

*/
Function NFNumTroca(aSerNf,nItem,oTimer,nTimeOut)
Local cCadastro := OemToAnsi(STR0139) //"Numero"
Local oTimer2
Local cNumero   := aSerNf[nItem][2]
Local lContinua := .T.

oTimer:Deactivate()

DEFINE MSDIALOG oDlg TITLE cCadastro From 12,60 To 15,77 OF oMainWnd
oTimer2 := TTimer():New(nTimeOut,{|| lContinua := .F.,oDlg:End() },oDlg)
oTimer2:Activate()
@ .8,.8 MSGET cNumero PICTURE "@!" WHEN Substr(cAcesso,50,1) == "S" VALID !Empty(cNumero)
DEFINE SBUTTON FROM 10,166  TYPE 1 ACTION oDlg:End() ENABLE OF oDlg
ACTIVATE MSDIALOG oDlg

oTimer:Activate()

aSerNf[nItem][2] := cNumero
Return(lContinua)
/*
Descri‡…o ³Tela/Gravação motivo de anulação na NF (Loc. Rep Dom)
*/
Function LocxMotAnu(cAlias)
Local oDlg
Local nRet := 0
Local aComboMot := {""}
Local oComboMot
Local cComboMot
Local oTButtonOk
Local oTButtonCc
Local lRet := .T.
Local aArea
Local cFilSX5	:= xFilial("SX5")
If cPaisloc=="DOM" .AND. (cAlias)->(FieldPos(PrefixoCpo(cAlias)+"_NCF")) > 0 .AND. Type("M->"+PrefixoCpo(cAlias)+"_NCF") == "C" .AND. Trim( &((cAlias)->(PrefixoCpo(cAlias)+"_NCF")) ) <> ""
	If !lAnulaSF3
		Aviso( STR0018,STR0283,{STR0021})	//ATENCAO#"Não é permitida a exclusão de notas fiscais"#OK
		lRet := .F.
	Else
		aArea := GetArea()
		DbSelectArea("SX5")
		DbSetOrder(1)
		If DbSeek(cFilSX5+"AV")
			While !Eof() .AND. X5_FILIAL == cFilSX5 .AND. X5_TABELA == "AV"
				AAdd(aComboMot,(TRIM(X5_CHAVE)+"="+X5Descri()))
				DbSkip()
			End
		EndIf
		oDlg := MSDialog():New(0,0,50,540,STR0284,,,,,,,,,.T.) // Motivo Anulacao
		oDlg:lEscClose := .F.
	    oComboMot := TComboBox():New(5,10,{|u|if(PCount()>0,cComboMot:=u,cComboMot)},;
	                         aComboMot,195,20,oDlg,,;
	                         ,,,,.T.,,,,,,,,,'cComboMot')
		oTButtonOk := TButton():New( 5, 210, STR0021 ,oDlg,{||iif(!Empty(cComboMot),(nRet:=1,oDlg:End()),)},25,10,,,.F.,.T.,.F.,,.F.,,,.F. ) // OK
		oTButtonCc := TButton():New( 5, 240, STR0189 ,oDlg,{||nRet:=1,lRet:=.F.,oDlg:End()},25,10,,,.F.,.T.,.F.,,.F.,,,.F. ) // Cancelar
		oDlg:Activate(,,,.T.,{||Iif(nRet==1,.T.,.F.)},,)

		If (lRet)
			//Gravado em matxfis
			LcSetTAnu(Val(cComboMot))
		EndIf
		RestArea(aArea)
	EndIf
EndIf
Return lRet
/*
±±³Funcao    ³LocxDelNF   ³ Autor ³Guilherme / Leandro C.G.³Data ³14.03.2002³±±
±±³Descri‡…o ³Chamada da Exclusao de Notas Fiscais                          ³±±
*/
Function LocxDelNF(cAlias,nRecno,lMostraCtb,lAglCtb,lContab,lCarteira,lTela,lPerg,lRSAuto)
Local lRet       := .T.
Local lValido    := .T.
Local aRecSC5    := {}
Local aPedPV     := {}
Local cArquivo   := ""
Local aArea,aAreaItem,nQtdItem,cChaveItem
Local aAreaSalva, aCfgNFSalva, aCusto
Local nRegSF1    := 0
Local aItem      := {}
Local aItens     := {}
Local aCab       := {}
Local aRecnoI    := {}
Local aAreaSD2   := {}
Local nAuto      := 0
Local aStruSDB   := SDB->(DBSTRUCT())
Local nPosEstor  := Ascan(aStruSDB,{|x| x[1] == 'DB_ESTORNO'})
Local lRastro    := .F.
Local cLoteSDA   := ""
Local lContinua  := .T.
//Local aRecSF8    := {}
Local lVerPad695 := VerPadrao('695') //Exclusão dos Itens da Nota Entrada
Local lVerPad687 := VerPadrao('687') //Exclusão Total da Nota Entrada
Local lVerPad697 := VerPadrao('697') //Exclusão dos Itens da Nota Debito
Local lVerPad689 := VerPadrao('689') //Exclusão Total da Nota Debito
Local lVerPad698 := VerPadrao('698') //Exclusão dos Itens Remito de Entrada
Local lVerPad690 := VerPadrao('690') //Exclusão Total Remito de Entrada
Local lVerPad655 := VerPadrao('655')
Local lVerPad665 := VerPadrao('665')
Local lVerPad995 := VerPadrao('995')
Local lVerPad975 := VerPadrao('975')
Local lVerPad711 := VerPadrao('711')
Local lVerPad721 := VerPadrao('721')
Local cLoteCom   := IIf(Found(),Trim(X5DESCRI()),"COM ")
Local lAtuEstoq  := .T.
Local cDepTrf    := GetNewPar("MV_DEPTRANS","95")  			// Dep.transf.
Local lEICFinanc := IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) 	// Integracao SIGAEIC - Financeiro
Local cMyNumFor
Local cAliasImp
Local nPosRec
Local aTiposOrig := { {01,"MATA467N/MATA468A/MATA468N/MATA460/MATA461/MATA460B/ATFA036" },;
                       {02,"MATA465N"},{03,"MATA465N"},{04,"MATA465N"},;
                       {05,"MATA465N"},{06,"MATA466N"},{07,"MATA466N"},;
                       {08,"MATA466N"},{09,"MATA466N"},{10,"MATA101N/MATA100/MATA447/MATA143"},;
                       {11,"MATA101N/MATA100"},{12,"MATA101N/MATA100"},;
                       {13,"MATA101N/MATA100/MATA119N/MATA447/MATA143"},{14,"MATA101N/MATA100/MATA116N/MATA447/MATA143"},;
                       {15,"MATA463N"},{17,"MATA467N"},{18,"MATA467N"},{19,"MATA467N"},;
                       {20,"MATA101N/MATA100"},{22,"MATA466N"},{23,"MATA466N"}}
Local cFilOrig   := ""
Local cOrigFin   := ""
Local cCondIf    := ""
Local aRecIMP    := {}
Local nI         := 0
Local nX         := 0
Local uRet       := NIL
Local aCtbDia    := {}
Local cStatusDBA := "1"
Local cItemAtf   := ""
Local aPedsDesp  := {}
Local nForDesp   := 0
Local lAjustaNCD := SuperGetMV( "MV_ATFNCRD", .F., .F. )
Local nRecSD1AUT := 0
Local aDadSfe    := {}
Local aArea2     := GetArea()
Local cDoc       := SF1->F1_DOC
Local cSer       := SF1->F1_SERIE
Local lTX        := .T.
//Local lVer116    := .T.
Local cFilSB1    := xFilial("SB1")
Local cFilSC7    := xFilial("SC7")
Local cFilSD1    := xFilial("SD1")
Local cFilSD2    := xFilial("SD2")
Local cFilSD3    := xFilial("SD3")
Local cFilSDA    := xFilial("SDA")
Local cFilSDB    := xFilial("SDB")
Local cFilSF1    := xFilial("SF1")
Local cFilSF4    := xFilial("SF4")
Local cFilSWN    := xFilial("SWN")
Local cFilDBB    := xFilial("DBB")
Local lNGMNTES   := GetNewPar("MV_NGMNTES","N") == "S"
Local lIntACD    := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local cAuxPaisL  := ""
Local lRetCC     := .T.
Local dDataBloq  := GetNewPar("MV_ATFBLQM",CTOD("")) //Data de Bloqueio da Movimentação - MV_ATFBLQM
Local dDataRef   := CTOD("  /  /  ")
Local lCanCFDi   := SuperGetMV("MV_CFDI_CA",,.F.) //PAC maneja cancelacion de CFDi y esta implementado para usarse (.T.)
Local aAuxAGH    := {}
Local a711       := {}
Local a721       := {}
//Local cAliCampo	 := Right(cAlias, 2)
Local cLvroRetC  := SuperGetMV("MV_LVRORIC",,"") //Número de libro para ret. de IVA al % (Ecuador)
Local lF817NCC	 := (cFunName$"FISA817" .And. ValType("nTipo") <> "U" .And. nTipo == 3) //Cancelar NCC desde FISA817
Local cMotCan    := ""
Local cDocCan    := ""
Local cSerCan    := ""
Local cNomXml    := ""
Local cUUID      := ""

Private nHdlPrv	:= 0	//Guarda a evolucao da funcao HeadProva
Private nTotalLcto 	:= 0

DEFAULT lTela		:=	.F.
DEFAULT lPerg		:=	.T.
DEFAULT lRSAuto  	:=	.F.

aCfgNF   := MontaCfgNf(Val(&(aCfgNf[SAliasHead]+"->"+PrefixoCpo(aCfgNf[SAliasHead]) + "_TIPODOC")) ,aCfgNF[SaPergs],lTela)
NFSetPrv(aCfgNF)
cOrigFin :=	IIf(Ascan(aTiposOrig,{|x| x[1] == aCfgNf[SnTipo]})==0,"",aTiposOrig[Ascan(aTiposOrig,{|x| x[1] == aCfgNf[SnTipo]})][2])

Private lMSErroAuto	:=	.F.
If Type("aDupl") != "A"
	aDupl := {}
EndIf

//³Verifica se o usuario tem permissao de delecao. ³
aArea2 := GetArea()
SD1->(DbSeek(cFilSD1+cDoc+cSer))
While !SD1->(Eof()) .And. lRet .And. SD1->D1_DOC == cDoc .And. SD1->D1_SERIE == cSer
	If IsInCallStack("MATA102N") // Remito de Entrada
		lRet := MaAvalPerm(1,{SD1->D1_COD,"MT102N",5})
	ElseIf IsInCallStack("MATA101N") // Factura de Entrada
		lRet := MaAvalPerm(1,{SD1->D1_COD,"MT101N",5})
	EndIf
	SD1->(dbSkip())
End
RestArea(aArea2)
If !lRet
	Help(,,1,'SEMPERM')
EndIf

//Verifica se existe bloqueio contábil
If !(Empty(SF1->F1_EMISSAO))  .And. cAlias <> "SF2"
	dDataRef := SF1->F1_EMISSAO
ElseIf !(Empty(SF2->F2_EMISSAO)) .And. cAlias == "SF2"
	dDataRef := SF2->F2_EMISSAO
EndIf

If lRet .And. !(Empty(dDataRef)) .And. (lRet := CtbValiDt(Nil,dDataRef,/*.T.*/ ,Nil ,Nil ,{"COM001"}/*,"Data de apuração bloqueada pelo calendário contábil."*/))
	If!Empty(dDataBloq) .AND. (dDataRef <= dDataBloq)
		Help(" ",1,"ATFCTBBLQ") //P: Processo bloqueado pelo Calendário Contábil ou parâmetro de bloqueio nesta data ou período. S: Caso possível altere a data de referência do processo, verifique o parâmetro ou contate o responsável pelo Módulo Contábil.)
		lRet := .F.
	End
EndIf

If SIX->(MsSeek("SEU7")) .And. nNFTipo == 10
	DbSelectArea("SEU")
	DbSetOrder(7)
	If MsSeek(xFilial("SEU")+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_DOC+SF1->F1_SERIE)
		SET->(dbSetOrder(1))
		SET->(MsSeek(xFilial("SET")+SEU->EU_CAIXA))
		If SET->ET_SITUAC != "0" .Or. (cPaisLoc <> "ARG" .and. !Empty(SEU->EU_BAIXA)) //O registro de gasto gerado a partir da NF já vem baixado. - ARG
			Help(" ",1,"FA560BAIXA")
			lRetCC := .F.
		EndIf
	EndIf
EndIf

//³ Ponto de Entrada para permitir ou não a excluir facturas que possuam caixinha vinculadas.                                |

If lRet .And. ExistBlock("LOCCADEL")
	uRet := ExecBlock("LOCCADEL" , .F. , .F.)
	If valtype(uRet) == "L"
		lRet := uRet
		If !lRet
			Alert(STR0281)
			Return lRet
		EndIf
	EndIf
EndIf

If valtype(uRet) != "L" .And. !lRetCC
	lRet := .F.
EndIf

If cPaisLoc == "MEX" .And. FunName() $ "MATA467N|MATA465N" .And. SuperGetmv( "MV_CFDICAN" , .F. , .F. )
	If ( cAlias == "SF2" .And. SF2->(FieldPos("F2_UUID")) > 0 .And. !Empty(SF2->F2_UUID) ) .Or. ;
		( cAlias == "SF1" .And. SF1->(FieldPos("F1_UUID")) > 0 .And. !Empty(SF1->F1_UUID) )
		MsgAlert( STR0404 + CRLF + STR0405 ) //"Está habilitado el Nuevo Esquema de Cancelación de CFDI (parámetro MV_CFDICAN)," # "para borrar/anular documentos timbrados utilice la rutina Cancelación de CFDI."
		Return .F.
	EndIf
EndIf

If lRet
	lRet:= Iif(cPaisLoc == "ARG".And. FunName() <> "MATA143" , ExcluiCCr(cAlias,nRecno) , lRet) //Chamada da função que verifica se a NF pode ser excluida depois de transmitir para a afip ## Valida C. Corrente
EndIf
If cPaisLoc == "RUS"
	If SuperGetMV("MV_WMSNEW",.F.,.F.) .and. lRet .And. cAlias =="SF1" .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE == "S" .And. FindFunction("WmsValEsMI") .And. IntWMS()
		If !WmsValEsMI()
			Return .F.
		EndIf
	EndIf
else
	If lRet .And. cAlias =="SF1" .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE == "S" .And. FindFunction("WmsValEsMI") .And. IntWMS()//Integração WMS - Validação do Estorno da Ordem de Serviço
		If !WmsValEsMI()
			Return .F.
		EndIf
	EndIf
EndIf
If lRet .And. (IIf(lPerg == .T. , MsgYesNo(OemToAnsi(STR0096),OemToAnsi(STR0097)), .T.))  //"Confirma estorno do documento ?"###"Aten‡„o"

	If cPaisLoc == "COL" .And. FunName() $ "MATA467N|MATA465N|"
	 	LxVldFact(cAlias)
	EndIf
	If cPaisLoc == "COL" .And. FunName() == "MATA466N" .And. (aCfgNf[SnTipo] == 22 .Or. aCfgNf[SnTipo] == 23)
	 	lRet:=LxVldFact(cAlias, .T.)
	EndIf
	//PE - Permite validar exclusao do documento
	If ExistBlock("LOCXVLDDEL")
		uRet := ExecBlock( "LOCXVLDDEL" , .F. , .F. , {cAlias} )
		If valtype(uRet) == "L"
			lRet := uRet
		EndIf
	EndIf
	If lRet .And. cPaisLoc = "MEX"
		lRet := LxDelNfMex(cAlias, lCanCFDi)
	EndIf
	If lRet .And. cPaisLoc == "PER"
		lRet := LxDelNFPer(cAlias, lLocxAuto, Funname())
	EndIf
	If lRet .And. cPaisLoc == "EQU"
		lRet := LxDelNfEqu(aCfgNf, cAlias, lDeleta, Funname())
	EndIf
	If lRet .And. cPaisLoc == "BOL"
		lRet := LxDelNfBol(cAlias, lLocxAuto, Funname())
	EndIf
	If lRet .And. cPaisLoc == "URU"
		lRet := LxDelNfUru(cAlias, lDeleta)
	EndIf
	If lRet .And. cPaisLoc == "EUA"
		LxDelNfEUA(Funname())
	EndIf
	If cPaisLoc == "DOM"
		If (lRet .AND. !LocxMotAnu(cAlias))
			lRet := .F.
		EndIf
	EndIf
	If lRet
		If cPaisLoc $ "VEN" .And. lDeleta
			aDadSFE:={}
			If cAlias == "SF1" .And. !Alltrim(SF1->F1_ESPECIE)$"NDE/NCC"
				aAdd(aDadSFE,{"",0,"",0,0,0,SF1->F1_DOC,SF1->F1_SERIE,"E",SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_ESPECIE,"",SF1->F1_NATUREZ})
			ElseIf cAlias == "SF2" .And. Alltrim(SF2->F2_ESPECIE)$"NDI/NCP/NF"
				aAdd(aDadSFE,{"",0,"",0,0,0,SF2->F2_DOC,SF2->F2_SERIE,"S",SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_ESPECIE,"",SF2->F2_NATUREZ})
		    Endif
			lRet:=FGrvSFE("5",aDadSfe)
			If !lRet
				Return lRet
			Endif
		Endif

		//Exclusão de ajuste do valor do bem por notas de Crédito ou Débito
		If lAjustaNCD .And. lDeleta
			If cEspecie $ "NCP|NDP|NCI|NDI"
				IF cPaisLoc!="ARG"
					If !A103ExAjNC( cAlias )
						lRet := .F.
						Return lRet
					EndIf
				Else
					aAreaSD2:= SD2->(GetArea())
					SD2->(dbSelectArea("SD2"))
					SD2->(dbSetOrder(3))
				    cChave := xFilial("SF2") + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA
					aAreaSF4:= SF4->(GetArea())
					IF (SD2->(MsSeek( cChave )) )

						While SD2->(!Eof()) .And.;
		      				cChave == xFilial("SF2") + SD2->D2_DOC + SD2->D2_SERIE + SD2->D2_CLIENTE + SD2->D2_LOJA

							If SF4->(MsSeek(xFilial("SF4")+SD2->D2_TES))

								IF SF4->F4_ATUATF=='S'
									If !A103ExAjNC( cAlias )
										lRet := .F.
										Return lRet
									EndIf
								End

							EndIf

							SD2->(dbSkip())
							EndDo

				 	ENDIF
					SF4->(RestArea(aAreaSF4))
					SD2->(RestArea(aAreaSD2))
				EndIf
		   	EndIf
		EndIf

		//³ Estorna o PR0 para quando o apontamento for gerado atraves do remito de entrada |
		lRet := MTEstornPR(SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA)
		Do Case
		Case cAlias == "SF2"
			aAreaSalva	:= GetArea()
			SD2->(dbSetOrder(3))
			If SD2->(MsSeek(cFilSD2+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA));
				.AND. (SD2->D2_TPDCENV == _RMCONS)
				SF1->(DbSetOrder(1))
				If SF1->(MsSeek(cFilSF1+SF2->F2_NFORI+SF2->F2_SERIORI+SF2->F2_CLIENTE+SF2->F2_LOJA+"B"))
					nRegSF1	:= SF1->(Recno())
				EndIf
			EndIf
			If !Empty(SF2->F2_DTLANC)
				lContab := .T.
			EndIf
			If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
				If (SF2->F2_TIPODOC == "54") .AND. (AllTrim(SF2->F2_ESPECIE) == "RTS") .AND. (SF2->F2_TIPORET == "1")
					SF1->(DbSetOrder(1))
					If SF1->(MsSeek(cFilSF1+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA+"N"))
						While !SF1->(Eof()) .AND. (cFilSF1+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA+"N" == ;
						      SF1->F1_FILIAL+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+"N")

							If (SF1->F1_TIPODOC == "64") .AND. (AllTrim(SF1->F1_ESPECIE) == "RTE")
	      						nRegSF1	:= SF1->(Recno())
								MsgInfo(STR0237)  //"O remito de entrada, correspondente ao remito de saida escolhido pelo usuario, sera excluido automat.mente."
						      	Exit
						 	Else
						    	SF1->(dbSkip())
							EndIf
						End
						// Caso tenha sido encontrado o remito de entrada, realiza a
						// exclusao do mesmo.
						If nRegSF1 > 0
							SF1->(MsGoto(nRegSF1))
							aCfgNFSalva	:= aClone(aCfgNF)
							aCfgNF 		:= MontaCfgNf(64,aCfgNF[SaPergs],.F.)
							lRet    := LocxDelNF("SF1",nRegSF1,lMostraCtb,lAglCtb,lContab,lCarteira,.F.,.F.,.T.)
							aCfgNF  := aClone(aCfgNFSalva)
							nRegSF1 := 0
						EndIf
						// Caso o usuario tenha optado em abortar o processo, eh necessario
						// tambem interromper a exclusao do remito de saida.
						If !lRet
							Return(lRet)
						EndIf
					EndIf
				EndIf
			EndIf
			RestArea(aAreaSalva)

			cPe	:=	LocxPE(26)
			If !Empty(cPE)
	 			If !ExecBlock(cPE,.F.,.F.)
					Return .F.
	 			Endif
	 		EndIf
			//³ Verifica se o estorno do documento de saida pode ser feito     ³
			aRegSD2 := {}
			aRegSE1 := {}
			aRegSE2 := {}
			If lValido .AND. MaCanDelF2(cAlias,SF2->(RecNo()),@aRegSD2,@aRegSE1,@aRegSE2,cOrigFin)
				If cPaisLoc == "COL" .AND. FunName() $ "MATA467N|MATA465N|" .and. SF2->(FieldPos("F2_FLFTEX"))>0
					If (Val(SF2->F2_FLFTEX) <> 0 .OR. !Empty(SF2->F2_FLFTEX))
						IF SF2->F2_FLFTEX == "6" .OR. !Empty(SF2->F2_UUID)
							MsgAlert(STR0401) // "El documento ya fue autorizado por la DIAN, utilice una Nota de Crédito para Anular Factura"
							Return .F.
						EndIf
					EndIf
				EndIf
				cPe	:=	LocxPE(27)
				If !Empty(cPE)
	 				ExecBlock(cPE,.F.,.F.)
				Else
					If __lPyme .And. ExistBlock( "LOCXS327" , .F. , .T. )
						Execblock( "LOCXS327" , .F. , .F. )
					EndIf
	 			EndIf
				If cPaisLoc == "GUA"
	                //³Verificar se deve gerar NCC para anulacao de docs. do ERP ³
	                If AllTrim(aCfgNf[ScEspecie])=="NF"
	                	//"Deseja gerar Nota de Credito para esta operacao de cancelamento de NF?"
	                    //"Uma Nota de Credito nao deve ser gerada quando o pagamento nao foi efetuado ou "
	                    //"na ocorrencia de erro na impressao do documento."
	                    lGeraNCC  := MsgYesNo(STR0228+chr(13)+STR0229+chr(13)+STR0230)
	                EndIf
	                If lGeraNCC
	                	//³ Valida se o numero da Nota de Credito eh valido pela SAT - Loc. Guatemala³
	                	If !LocxSATNCC()
							Return .F.
	                	EndIf
	                 	//³ A gravacao do motivo da devolucao eh Obrigatoriedade fiscal - Loc. Guatemala³
	                 	If !LocxMotDev()
	                    	Return .F.
		              	EndIf
	                  	//³ Armazena os dados da NF em array para gravacao futura ³
	                  	//³ da Nota de Credito - Loc. Guatemala                   ³
			          	aDadosSF2  := {SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_MOEDA,SF2->F2_TXMOEDA,;
			                         SF2->F2_COND}

			          	aAreaItem  := SD2->(GetArea())
			          	aDadosSD2  := {}
			          	For nI:= 1 to Len(aRegSD2)
			            	SD2->(MsGoto(aRegSD2[nI]))
				         	Aadd(aDadosSD2,{SD2->D2_COD,SD2->D2_UM,SD2->D2_QUANT,SD2->D2_PRCVEN,SD2->D2_TOTAL,;
				                         SD2->D2_LOCAL,SD2->D2_TES})
			          	Next nI
			          	RestArea(aAreaItem)
			        EndIf
				EndIf

				If !aCfgNF[SlRemito]

					//³ Retorna o remito de saida ³

					aArea    :=GetArea()
					aAreaItem:=SD2->(GetArea())
					SD2->(DbSetOrder(3))
					For nI:= 1 to Len(aRegSD2)
						SD2->(MsGoto(aRegSD2[nI]))
						cChaveItem  := cFilSD2+SD2->D2_REMITO+SD2->D2_SERIREM+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEMREM
						nQtdItem    := SD2->D2_QUANT
						If !Empty(SD2->D2_REMITO) .AND. SD2->(MsSeek(cChaveItem))
							NFAtuSCN(nQtdItem,-1)
						EndIf
					Next nI
					RestArea(aAreaItem)
					RestArea(aArea)
				EndIf

				If cPaisLoc == "ARG" .and. cTipo $ "N|D|B" .And. FindFunction("WmsEsIntM2")
					WmsEsIntM2()
				EndIf

				//³Cancela a baixa dos titulos com pagamento a vista.³

				CaBxAutSE1(aCfgNf[ScAliasFin],,cAlias)

				If lUsaCor .And. !Empty(SF2->F2_NUMCOR)//libera o numero correlativo
					CORR_EXCL(SF2->F2_DTDIGIT,SF2->F2_NUMCOR)
				Endif

				If aCfgNf[ScAliasFin]=="SE2"
					ApagTitImp(cAlias)
				EndIf

				//³Loop para guardar numero dos registros da tabela SD2 a serem eliminados e atualização da tabela-espelho ³

				For nx := 1 to Len(aRegSD2)
	   				AAdd( aRecnoI, { aRegSD2[nx] } )

				Next nx

				//Si es la anulación de un Remito de Salida, para Argentina y con los asientos configurados 711 Y 721, ejecuta la contabilidad.
				If lRet .And. lVerPad711 .And. lVerPad721 .And. cPaisLoc == "ARG" .And. AllTrim(aCfgNf[ScEspecie]) == "RTS"
					aAdd(a711, {"711"})
					aAdd(a721, {"721"})

					CtbilNF(aCfgNf[SAliasHead],aCfgNf[SAliasCols],SF2->(RecNo()),aRecnoI,a711[1],a721[1],lMostraCtb,lAglCtb)
				EndIf

				//³Lancto.PCO  	  ³

				For nx := 1 to Len(aRegSD2)
	   				AAdd( aRecnoI, { aRegSD2[nx] } )
				Next nx
				PcoLancto(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecno,aRecnoI,aCfgNf[SaLancPCO][1],aCfgNf[SaLancPCO][2],aCfgNf[SaLancPCO][4],aCfgNf[SaLancPCO][3], .F./*lInclui*/, .T./*lDeleta*/)

				For nx := 1 to Len(aRegSD2)
					dbSelectArea('SD2')
					MsGoto(aRegSD2[nx])
	   				aAuxAGH := BuscaAGH()
					LxaSD2AtuSDE(2,aClone(aAuxAGH[3]),aClone(aAuxAGH[2]),aClone(aAuxAGH[1]),LxA103Custo(nx,aCfgNf[SlRemito]))
				Next nx


				//³ Estorna o documento de saida.                                  ³
				//³ Se for nota de consignacao forca o parametro MV_PDEVLOC como 1 ³
				//³ para devolver o produto na localizacao original.               ³

				If ( nRegSF1 > 0 ) // IF -> alteracao conforme BOPS 66.670
					cAuxPaisL := "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
					SF2->(MaDelNFS(aRegSD2,aRegSE1,aRegSE2,lMostraCtb,lAglCtb,lContab,lCarteira,,1	,IIf(cPaisLoc $ cAuxPaisL,SF2->F2_DIACTB,)))
				Else
					SF2->(MaDelNFS(aRegSD2,aRegSE1,aRegSE2,lMostraCtb,lAglCtb,lContab,lCarteira,,,IIf( cPaisLoc $ cAuxPaisL,SF2->F2_DIACTB,)))
				Endif
				If aCfgNf[SAliasHead]=="SF1"
					aDadSFE:={}
					If cPaisLoc $ "VEN"
						If (SF1->F1_VALIMP2+SF1->F1_VALIMP3+SF1->F1_VALIMP4)>0 .OR. SF1->F1_VALIMP6>0
						   	Aadd(aDadSFE,{.F.,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE})
					   		FGrvCrt(1,aDadSFE)
					   	EndIf
					ElseIf (cPaisLoc $ "EQU" .AND. FUNNAME() <> "MATA143")
						If ((SF1->F1_BASIMP2 + SF1->F1_BASIMP3 + SF1->F1_BASIMP4 + IIf(!Empty(cLvroRetC) ;
							.And. !(AllTrim(cLvroRetC) $ "2|3|4"), SF1->&("F1_BASIMP" + AllTrim(cLvroRetC)),0)) > 0 .OR. SF1->F1_VALIMP6 >= 0) .And. !(AllTrim(Str(nNFTipo)) $ "60|61|64|54|07")
						   	Aadd(aDadSFE,{.F.,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE})
					   		FGrvCrt(1,aDadSFE)
					   	EndIf
					ElseIf cPaisloc == "CHI"
						If SF1->F1_VALIMP5 > 0 ///retencao de honorario
						   	Aadd(aDadSFE,{.F.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RHO",0,0,0,SF1->F1_ESPECIE})
		   					GrvRetSFE(1,aDadSFE)
					   	Endif
					ElseIf cPaisloc == "COS"
						If SF1->F1_VALIMP5 > 0 ///retencao de IR
						   	Aadd(aDadSFE,{.F.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RIR",0,0,0,SF1->F1_ESPECIE})
		   		   			GrvRetSFE(1,aDadSFE,.F.,.T.)
					   	Endif
					EndIf
				Endif

				If aCfgNf[SAliasHead]=="SF2"
					aDadSFE:={}
					If cPaisLoc $ "VEN" .And. Alltrim(SF2->F2_ESPECIE) == "NCP"
						If (SF2->F2_VALIMP2+SF2->F2_VALIMP3+SF2->F2_VALIMP4)>0 .OR. SF2->F2_VALIMP6>0
						   	Aadd(aDadSFE,{.F.,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE})
						   	FGrvCrt(2,aDadSFE)
					   	Endif
					EndIf
				Endif

				//³Apaga o arquivo .xml criado na geracao da nota.   ³
				If cPaisLoc <> "MEX" .And. lGerarCFD .And. FunName() <> "MATA466N"
					CFDExcXML(SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE,lAnulaSF3)
				Endif
			EndIf
			MsUnLockAll()
			// Libera los registros bloqueados por la funcion FtMultLock-MATA521 DMICNS-13915/DSERFAT-21116
			If cPaisLoc == "BOL" .AND. FindFunction("UNLOCSB2BO")
				UNLOCSB2BO(aRegSD2)
			EndIf
			//³Libera Faturas de Importacao ³

			If lRet .AND. aCfgNf[SAliasCols] == "SD1"
				If !Empty(SF1->F1_HAWB)
					If !lBloqImp
						   LibFatImp()
					EndIf
				EndIf
	        EndIf
			If SF2->F2_ESPECIE == "NCP" .AND. GetMV("MV_EASY") == "S" .AND. !Empty(SF2->F2_HAWB)
				DbSelectArea("SWN")
				DbSetOrder(2)
				If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
		   			While !Eof() .AND.;
						WN_FILIAL == cFilSWN .AND.;
					   	WN_DOC == SF2->F2_DOC .AND.;
					   	WN_SERIE == SF2->F2_SERIE

					   	SB1->(DbSetOrder(1))
	 					SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

					   	SD2->(DbSetOrder(1))
	 					SD2->(DbSeek(cFilSD2+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA))

	 		   			If WN_TIPO_NF == "N"
					   		aCusto := PegaCMAtu(SWN->WN_PRODUTO,SWN->WN_LOCAL)

							//³ Achar Custo das Moedas 3,4 e 5 pela RecMoeda³

							If Len(aCusto)>0 .AND. Len(aCusto)<5
								For nX := 1 To (5-Len(aCusto))
									aAdd(aCusto, 0)
							Next nX
							ElseIf Len(aCusto) == 0
								aCusto := PegaCMD3()
							EndIf

							//³ Gravar no SD3 a 'DE8' para o Produto ³

							RecLock('SD3',.T.)
							Replace D3_FILIAL  With cFilSD3
							Replace D3_COD	   With SWN->WN_PRODUTO
							Replace D3_GRUPO   With SB1->B1_GRUPO
							Replace D3_TIPO    With SB1->B1_TIPO
							Replace D3_LOCAL   With SWN->WN_LOCAL
							Replace D3_UM	   With SB1->B1_UM
							Replace D3_CONTA   With SB1->B1_CONTA
							Replace D3_DOC	   With SWN->WN_DOC
							Replace D3_QUANT   With 0.00
							Replace D3_CF	   With 'DE8' 	//-- Identifica Movimentacao com Origem no SIGAEIC
							Replace D3_TM	   With '999'
							Replace D3_USUARIO With SubStr(cUsuario,7,15)
							Replace D3_NUMSEQ  With SWN->WN_NUMSEQ
							Replace D3_EMISSAO With SD2->D2_EMISSAO
							Replace D3_CHAVE   With 'E9' 	//-- N„o Alterar !!!
							Replace D3_QTSEGUM With SB1->B1_QTSEGUM
							Replace D3_SEGUM   With SB1->B1_SEGUM
							Replace D3_IDENT   With ""		//cNumSeqD1  //-- Diferencia as Movimentacoes
							Replace D3_CUSTO1  With aCusto[1]
							Replace D3_CUSTO2  With aCusto[2]
							Replace D3_CUSTO3  With aCusto[3]
							Replace D3_CUSTO4  With aCusto[4]
							Replace D3_CUSTO5  With aCusto[5]
							Replace D3_DOCSWN  With SWN->WN_PO_NUM
							Replace D3_ITEMSWN With SWN->WN_ITEM
							MsUnlock()
							aCM := aClone(aCusto)
							B2AtuComD3(aCM,,,,,,,,,,,,,,,,.F.)
						EndIf
				   		DbSelectArea("SWN")
						DbSkip()
					End
				EndIf

				DbSelectArea("SWN")
				DbSetOrder(1)
				If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
		   			While !Eof() .AND.;
						WN_FILIAL == cFilSWN .AND.;
					   	WN_DOC == SF2->F2_DOC .AND.;
					   	WN_SERIE == SF2->F2_SERIE

			   			If WN_TIPO_NF == "N"
							DbSelectArea("SD3")
							If DbSeek(cFilSD3+SWN->WN_DOC+SWN->WN_PRODUTO)
								RecLock('SD3',.F.)
								Replace D3_ESTORNO	With "S"
								MsUnlock()
							EndIf
						EndIf
				   		DbSelectArea("SWN")
						DbSkip()
					End
				EndIf
			EndIf

			//³Chama a mesma rotina para fazer a exclusao da nota de entrada ³
			//³associada a nota de consignacao.                              ³

			If nRegSF1 <> 0
				SF1->(MsGoto(nRegSF1))
				SD1->(dbSetOrder(1))
				If	SD1->(MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_lOJA))
					aCfgNFSalva	:= aClone(aCfgNF)
					aCfgNF 		:= MontaCfgNf(63,aCfgNF[SaPergs],.F.)
					Do While !SD1->(EOF()) .AND. cFilSD1+SF1->F1_DOC+SF1->F1_SERIE == SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE
						nRecSD1AUT:=SD1->(Recno())
						RecLock("SD1",.F.)
						Replace SD1->D1_QTDEDEV	With 0
						Replace SD1->D1_VALDEV	With 0
						MsUnlock()

						//³Fazer o estorno da distribuicao do material³

	        	       If Localiza(SD1->D1_COD) .AND. Alltrim(SF1->F1_PEDVEND) == "AUTO"
							aCAB  :={{"DA_PRODUTO",SD1->D1_COD   , nil},;
										{"DA_LOCAL"  ,SD1->D1_LOCAL  , nil},;
										{"DA_NUMSEQ" ,SD1->D1_NUMSEQ , nil},;
										{"DA_DOC"    ,SD1->D1_DOC    , nil}}
							cChave	:=	SD1->(D1_COD+D1_LOCAL+D1_NUMSEQ+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA)
							SDA->(DbSetOrder(1))
							SDA->(MsSeek(cFilSDA+cChave))
							cLoteSDA	:=	SDA->DA_LOTECTL
							lRastro	:=	Rastro(SDA->DA_PRODUTO)
							SDB->(DbsetOrder(1))
							SDB->(MsSeek(cFilSDB+cChave))
							aItens	:=	{}
							While !SDB->(EOF()) .AND. cFilSDB == SDB->DB_FILIAL .AND. cChave == ;
										SDB->(DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA)
								If SDB->DB_TM > "500" .OR. SDB->DB_TIPO # "D"
									SDB->(dbSkip())
									Loop
								EndIf
								If lRastro .AND. !(cLoteSDA==SDB->DB_LOTECTL)
									SDB->(dbSkip())
									Loop
								EndIf

								aItem	:=	{}
								For nAuto:= 1 To Len(aStruSDB)
									AAdd(aItem,{SDB->(Field(nAuto)),SDB->(FieldGet(nAuto)),Nil})
								Next
								aItem[nPosEstor][2]	:=	"S"
								Aadd(aItens,aClone(aItem))
								SDB->(DbSkip())
							End
							lMSErroAuto := .F.
							SX3->(DbSetOrder(1))
							msExecAuto({|x,y,z,w| mata265(x,y,z,w)},aCab,aItens,4,.T.)
							If lMsErroAuto
								DisarmTransaction()
								MostraErro()
							EndIf
							// Trecho abaixo reposiciona SD1 que se perde depois do msexecauto
							// que não executava para notas com mais de um item
							SD1->(Dbgotop())
							SD1->(dbSetOrder(1))
							SD1->(Msgoto(nRecSD1AUT))
						Endif
						SD1->(dbSkip())
					End
					LocxDelNF("SF1",nRegSF1,lMostraCtb,lAglCtb,lContab,lCarteira,.F.,.F.,.T.)
					aCfgNF		:=	aClone(aCfgNFSalva)
				EndIf
	   		EndIf
		/*
		  ³ Estorno da notas de importacao integracao Average.             ³
		  ³ Estornar Movimentos e apagar campo D1_TES para NF de Importação³
		*/
		Case  cAlias =="SF1"

			lDesclassif := (lIntegracao .AND. AllTrim(SF1->F1_TIPO_NF) $ "123456789AB" .AND. (aCfgNF[SnTipo]==10 .OR. aCfgNF[SnTipo]==13 .OR. aCfgNF[SnTipo]==60))

			cA100For:=SF1->F1_FORNECE
			cLoja   :=SF1->F1_LOJA
			If lEicFinanc
				If !(cTipo$'DIB')
					A103DelTX(aRecSE2)
					lTX := .F.
				EndIf
			EndIf
			If lDesclassif .AND. lFacImport
		  		cPe	:=	LocxPE(41)
				If !Empty(cPe)
					ExecBlock(cPe,.F.,.F.)
				EndIf
				DbSelectArea('SD1')
				DbSetOrder(1)
				MsSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)

				//³ Apaga os remitos internos para produtos importados SIGAEIC ³

				If LxMaCanDelF1(nRecno,@aRecSC5,aRecSE2,.F.,aCfgNf[SlConFrDp][2],aCfgNf[SlRemito],.F.,Nil,.F.,.T.)
					LxApagaREM(lMostraCtb,lAglCtb,lContab,lCarteira,lTela,lPerg,lRSAuto,@aRecImp)
				Else
					Help(" ",1,"SDAJADISTR")
					Return .F.
				EndIf

				//³ Apaga os titulos no Contas a Pagar SE2                   ³

				If lEicFinanc .and. lTX
					If !(cTipo$'DIB')
						LxA103SE2(2,aRecSE2)
					EndIf
				EndIf
	        EndIf
	        //Integração WMS - Estorno da Ordem de Serviço
			If cPaisLoc == "RUS"
				If SuperGetMV("MV_WMSNEW",.F.,.F.) .and. cTipo $ "N|D|B" .And. FindFunction("WmsEsIntMI") .And. IntWMS()
					WmsEsIntMI()
				EndIf
			else
				If cTipo $ "N|D|B" .And. FindFunction("WmsEsIntMI") .And. IntWMS()
					WmsEsIntMI()
				EndIf
			EndIf

			//³ Inicializa o cabecalho dos lanç. Contabeis OnLine  ³

			If ( lContab .AND. (!__TTSinUse .Or. cPaisLoc $ "PTG|RUS|")) .OR. !Empty(SF1->F1_DTLANC)
				lContab := .T.
				DBSelectArea("SX5")
				MsSeek(xFilial("SX5")+"09COM")
				cLoteCom := IIf(Found(),Trim(X5DESCRI()),"COM ")
				If Empty(nHdlPrv) .OR. nHdlPrv < 0
					nHdlPrv := HeadProva(cLoteCom,"MATA103",Subs(cUsuario,7,6),@cArquivo)
				Endif
				If nHdlPrv <= 0
					HELP(" ",1,"A100NOPRV")
					lContab := .F.
				EndIf
			EndIf

			If lVerPad975
				aAreaSalva	:=	GetArea()
				cAliasImp	:=	IIf(GetNewPar("MV_CUSTIMP","1") == "1",'SD3','SWN')
				nPosRec		:=	iF(cAliasImp == 'SD3',1,2)
				For nI := 1 to Len(aRecIMP)
					SWN->(	MSGoto(aRecIMP[nI][2]))
					SD3->(	MSGoto(aRecIMP[nI][1]))
					SB1->(DbSetOrder(1))
					SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))
					DbSelectArea(cAliasImp)
					//Confirma posicionamento do arquivo
					If Recno() == aRecIMP[nI][nPosRec]
						nTotalLcto	+= DetProva(nHdlPrv,'975','MATA103',cLoteCom)
					EndIf
				Next nI
				RestArea(aAreaSalva)
			EndIf
			/*
			Verifica se ha movimentos gerados para caja chica. */
			If cPaisLoc == "CHI"
				If !LxVerifCC(nRecno)
					Return(.F.)
				Endif
			Endif

			//³Cancela a baixa dos titulos com pagamento a vista.³

			CaBxAutSE1(aCfgNf[ScAliasFin],,cAlias)

			//³ Gera lanç contabil 665- Exclusao - Total ³

	 		If !lDesclassif .OR. lEICFinanc
		 		If !LxMaCanDelF1(nRecno,@aRecSC5,aRecSE2,aCfgNf[SlConFrDp][1],aCfgNf[SlConFrDp][2],aCfgNf[SlRemito],lRSAuto,cOrigFin,!(lDesclassif.AND.lEICFinanc))

					//³ Efetua a gravacao dos lanç. Contabeis  ³

					If lContab .AND. nHdlPrv > 0 .AND. nTotalLcto > 0
						RodaProva(nHdlPrv,nTotalLcto)
						If UsaSeqCor()
							If cAlias == "SF1"
								aCtbDia := {{"SF1",SF1->(RECNO()),SF1->F1_DIACTB,"F1_NODIA","F1_DIACTB"}}
							elseIf cAlias == "SF2"
								aCtbDia := {{"SF2",SF2->(RECNO()),SF2->F2_DIACTB,"F2_NODIA","F2_DIACTB"}}
							EndIf
						Else
	    					aCtbDia := {}
						EndIF
						lLctoOk	:= cA100Incl(cArquivo,nHdlPrv,3,cLoteCom,lMostraCtb,lAglCtb,,If(aCfgNf[SaPergs][SlCtbEmiss],&(cAlias+"->"+PrefixoCpo(cAlias)+"_EMISSAO"),dDataBase ),,,,aCtbDia)
						If lLctoOk .AND. !Empty(aRecIMP) .AND. lVerPad975
							For nI:= 1 To Len(aRecIMP)
								SD3->(MsGoTo(aRecIMP[nI][1]))
								If !SD3->(EOF()) .AND. SD3->(Recno()) == aRecIMP[nI][1] .AND. aRecIMP[nI][1]<>0
									RecLock('SD3',.F.)
									Replace D3_DTLANC With dDataBase
									MsUnLock()
								EndIf
							Next
						EndIf
					EndIf
					Return .F.
				EndIf
			EndIf

			//³ Realiza baja de Adientamentos     ³
			If cPaisLoc $ "MEX" .AND. AliasInDic("FR3") .AND. AliasInDic("FIE") .AND. A410UsaAdi(SF1->F1_COND)
				If !BaixaAdt()
					If IsBlind()
						Conout(STR0175)
					Else
						Aviso(STR0033,STR0175 + CRLF + STR0176,{STR0041}) //"Atenção"#"Não foi possível excluir a baixa do adiantamento associado ao Documento de Saída."#"Não será possível excluir o Documento de Saída."#OK
					EndIf
					DisarmTransaction()
					Return(.F.)
				Endif
			Endif
			cAliasGrid	:= "SD1"
			cSeekGrid 	:= "'" + cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA + "'"
			cWhileGrid	:= "SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA == " + cSeekGrid
			cCondIf     := "SD1->D1_ESPECIE == SF1->F1_ESPECIE"
			nIndGrid	:= 1
			aRecSD1		:= AClone(LocxGrid(cAliasGrid,cWhileGrid,cCondIf,,,cSeekGrid,nIndGrid,{"D1_DOC"},,,)[6])
			If !lDesclassif
				nRegSF1:=SF1->(Recno())

				//³ Apaga o pedido de vendas quando gerado pelo D1_GERAPV      ³

				a103GrvPV(2,,aRecSC5)

				//³ Apaga o arquivo de Livros Fiscais (SF3)³

				MaFisAtuSF3(2,"E",SF1->(RecNo()))

				If cPaisloc == "CHI"
					Aadd(aDadSFE,{.T.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RHO",0,0,0,SF1->F1_ESPECIE})
		   			GrvRetSFE(1,aDadSFE)
				ElseIf cPaisloc == "COS"
					Aadd(aDadSFE,{.T.,"",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA,"RIR",0,0,0,SF1->F1_ESPECIE})
		   			GrvRetSFE(1,aDadSFE)
				EndIf

				//³ Apaga as NFs de Despacho gravadas no SF3 ³

				If SF1->F1_TIPO_NF $ "9"
					MaFisF3Eic(2)
				EndIf

				//³ Gera os titulos no Contas a Pagar SE2  ³

				If !(cTipo$'DIB')
					LxA103SE2(2,aRecSE2)
				EndIf

				//³ Estorna Amarracao com SF8 de NF de frete ³

				If aCfgNF[SlConFrDp][1]
					A116Grava(.T.,Nil,Nil,A116GetSF8(lContinua),.F.)
					If !lContinua
						Return .F.
					Endif
				EndIf

				//³ Estorna Amarracao com SF8 de NF de despesas  ³

				If aCfgNF[SlConFrDp][2]
					A119Grava(.T.,Nil,Nil,A119GetSF8())
				EndIf

				//³ Estorna os titulos de NCC ao cliente  ³

				A103EstNCC()
			EndIf

			//³Lacto. PCO ³

			For nx := 1 to Len(aRecSD1)
   				AAdd( aRecnoI, { aRecSD1[nx] } )
			Next nx
			PcoLancto(aCfgNf[SAliasHead],aCfgNf[SAliasCols],nRecno,aRecnoI,aCfgNf[SaLancPCO][1],aCfgNf[SaLancPCO][2],aCfgNf[SaLancPCO][4],aCfgNf[SaLancPCO][3], .F./*lInclui*/, .T./*lDeleta*/)
			//SF1->(dbGoto(nRegSF1))
			SF1->(MsGoto(nRecno))

			For nx := 1 to Len(aRecSD1)
				dbSelectArea('SD1')
				MsGoto(aRecSD1[nx])
				dbSelectArea('SF4')
				dbSetOrder(1)
				MsSeek(cFilSF4+SD1->D1_TES)

				//Estorna os arquivos de Gerenciamento de Projetos - 2:Estorno,3:Exclusao ³
				If IntePMS() .AND. (!IsRemito(1,'SD1->D1_TIPODOC') .Or. (IsRemito(1,'SD1->D1_TIPODOC') .And. IsIntegTop(,.T.)))
					If !IsIntegTop(,.T.)
						PmsWriteNF(2,"SD1")
						PmsWriteNF(3,"SD1")
					Else
						If AllTrim(SD1->D1_TIPODOC) == "60" .Or. AllTrim(SD1->D1_TIPODOC) == "10"
							If !Empty(SD1->D1_PEDIDO)
								If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
									PmsWriteNF(2,"SD1")
									PmsWriteNF(3,"SD1")
								Endif
							Else
								If Empty(SD1->D1_REMITO)
									PmsWriteNF(2,"SD1")
									PmsWriteNF(3,"SD1")
								Endif
							Endif
						Else
							PmsWriteNF(2,"SD1")
							PmsWriteNF(3,"SD1")
						Endif
					Endif
	      		EndIf
				//Atualiza o arquivo de rateios por C.C.  ³
				aAux := BuscaSDE()
				Lxa103SD1AtuSDE(2,aClone(aAux[3]),aClone(aAux[2]),aClone(aAux[1]),LxA103Custo(nx))

				dbSelectArea('SD1')
				MsGoto(aRecSD1[nx])
				dbSelectArea('SF4')
				dbSetOrder(1)
				MsSeek(cFilSF4+SD1->D1_TES)

				//Estorna classificação dos remitos  ³
				If !aCfgNF[SlRemito]
					aArea		:=GetArea()
					aAreaItem	:=SD1->(GetArea())
					SD1->(DbSetOrder(1))
					cChaveItem	:=	cFilSD1+SD1->D1_REMITO+SD1->D1_SERIREM+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMREM
					aCusto		:=	{SD1->D1_CUSTO/SD1->D1_QUANT,SD1->D1_CUSTO2/SD1->D1_QUANT,SD1->D1_CUSTO3/SD1->D1_QUANT,SD1->D1_CUSTO4/SD1->D1_QUANT,SD1->D1_CUSTO5/SD1->D1_QUANT}
					nQtdItem	:=	SD1->D1_QUANT
					If !Empty(SD1->D1_REMITO) .And. SD1->(MsSeek(cChaveItem))
						NFAtuSD1(nQtdItem,-1,aCusto)
					EndIf
					RestArea(aAreaItem)
					RestArea(aArea)
				EndIf

				//Apaga movimentacao no SD3 Qdo Documento de transf.  ³
				If SD1->D1_TIPODOC == '64'
					// Filial origem da transf.
					cFilOrig := RetFilFor(SD1->D1_FORNECE,SD1->D1_LOJA)
					SD3->(DbSetOrder(3))
					If SD3->(MsSeek(GetFilOri('SD3',cFilOrig)+SD1->D1_COD+cDepTrf+SD1->D1_NUMSEQ))
						If !LocTranSB2(1,cFilOrig)
							// Apaga transf. RE4
							RecLock("SD3",.F.)
							DbDelete()
							MsUnlock()
						EndIf
					EndIf
					SD2->(DbSetOrder(3))
					cMyNumFor := GetNumFor(cFilOrig)
					If !Empty(cMyNumFor) .AND. SD2->(MsSeek( GetFilOri('SD2',cFilOrig)+SD1->D1_DOC+SD1->D1_SERIE+cMyNumFor+SD1->D1_COD+SD1->D1_ITEMORI))
						Reclock("SD2",.F.)
						D2_QTDAFAT += SD1->D1_QUANT
						MsUnlock()
					EndIf
				EndIf

				//Gera lanç contabil 655-691-697-698 Exclusao - Itens   ³
				If Type("cFunName")<>"U"
					If cFunName$"MATA101N|MATA447|MATA462DN" //Nota de Entrada | Pedimentos
						If lVerPad695
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'695','MATA103',cLoteCom)
							EndIf
						ElseIf lVerPad655
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
							EndIf
						EndIf
					EndIf
					If cFunName$"MATA466N" //Nota de Debito
						If lVerPad697
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'697','MATA103',cLoteCom)
							EndIf
						ElseIf lVerPad655
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
							EndIf
						EndIf
					EndIf
					If cFunName$"MATA465N" //Nota de Credito
						If VerPadrao("68N")
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'68N','MATA103',cLoteCom)
							EndIf
						ElseIf lVerPad655
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
							EndIf
						EndIf
					EndIf
					If lF817NCC//Nota de Credito desde FISA817
						If VerPadrao("68N")
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'68N','FISA817',cLoteCom)
							EndIf
						EndIf
					EndIf
					If cFunName$"MATA102N" //Remito de Entrada
						If lVerPad698
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'698','MATA103',cLoteCom)
							EndIf
						ElseIf lVerPad655
							If !Empty(SF1->F1_DTLANC)
								nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
							EndIf
						EndIf
					EndIf
				EndIf
				lAtuEstoq  := SF4->F4_ESTOQUE == "S"
	         	If !lDesclassif
					If Empty(SD1->D1_REMITO)
				   		//Estorna a baixa do pedido de compras SC7  ³
				   		LxA103SC7(2,lAtuEstoq)
				   		If lAtuEstoq
					  		//Efetua estornos referentes a devolucao de mercadorias   ³
					  		LxA103SD2(2,nx,@aPedPV,IIf(aCfgNF[SnTipo] == 63 ,'D',Nil))
					  		//Estornar lanç no arquivo SD3  (RE5)  ³
					  		If !Empty(SD1->D1_OP)
						  		Lxa103EstRE5()
					  		EndIf
					  		//Estorna o controle de qualidade da Microsiga/Celerina   ³
					  		LxA103AtuQuali(SD1->D1_COD, SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_FORNECE, SD1->D1_LOJA, SD1->D1_ITEM, cTipo, .F., 2)
					  		//Estorna os saldos do arquivo SB2  ³
					  		LxA103SB2(2)
					  		//Estorna o arquivo de Saldo Em/De Poder de Terceiros  SB6 ³
					  		If SF4->F4_PODER3 $ "R|D"
						  		MaAtuSB6("SD1",2,.F.)
						  	EndIf
					  		//Estorna o Servico do WMS (DCF) ³
					  		A103EstDCF()
					  	Else
							aAreaSD2 := SD2->(GetArea())
							SD2->(DbSetOrder(3))
							If SD2->(MsSeek( cFilSD1+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD+SD1->D1_ITEMORI) )
								If SD2->D2_QTDEDEV > 0
									RecLock("SD2",.F.)
									Replace SD2->D2_QTDEDEV With SD2->D2_QTDEDEV - SD1->D1_QUANT
									Replace SD2->D2_VALDEV  With SD2->D2_VALDEV  - SD1->D1_TOTAL
									MsUnlock("SD2")
								EndIf
							EndIf
							RestArea(aAreaSD2)
				   		EndIf
					EndIf
					//Efetua o Estorno do Ativo Imobilizado  ³
		 			If ( !Empty(SD1->D1_CBASEAF))
						If SF4->(FieldPos("F4_BENSATF")) > 0 .And. SF4->F4_BENSATF == "1" .And. SD1->D1_QUANT >= 1
							For nI := 1 TO Int(SD1->D1_QUANT)
								cItemAtf	:= PadL( nI, Len( SN1->N1_ITEM ), "0" )
								a103GrvAtf(2,SubsTR(Trim(SD1->D1_CBASEAF),1,Len(Trim(SD1->D1_CBASEAF))-Len(cItemAtf))+cItemAtf)
							Next
						Else
				   			A103GrvAtf(2,SD1->D1_CBASEAF)
				  		EndIf
			   		EndIf
				EndIf
				//Estorna  Amarracao no cadastro ProdutoxFornec. SA5 SX5 ³
				LxA103AtuAmarr(2)
				//Apaga os dados referentes ao CIAP SF9 ³
				LxA103SF9(2)
				//Estorna o Movimento de Custo de Transporte - Integracao TMS  ³
				If IntTMS()  .And. ( ( Type("aRatVei")=="A" .And. Len(aRatVei) > 0 ) .Or. ( Type("aRatVei") == "A" .And. Len(aRatFro) > 0 ) )
					EstornaSDG("SD1")
				EndIf
				//Exclui o item da CBE quando utilizado ACD
				If lIntACD
					EstCBED1(SD1->D1_DOC,SD1->D1_SERIE,SD1->D1_FORNECE,SD1->D1_LOJA,SD1->D1_COD)
				EndIf
				//Exclui o item da NF SD1   ³
				If lNGMNTES
					NGSD1100E()
				EndIf
				cPe	:=	LocxPE(28)
				If !Empty(cPE)
					ExecBlock(cPE,.F.,.F.,aCfgNF[SlConFrDp])
				EndIf
				If !lDesclassif
					If !Empty(SD1->(D1_PEDIDO+D1_ITEMPC))
						aAdd(aPedsDesp,{SD1->(D1_PEDIDO+D1_ITEMPC),SD1->D1_QUANT})
					EndIf
					RecLock('SD1',.F.,.T.)
					//Ambiente Portugal, Grava Tabela Espelho |
					//#PORTUGAL#
					/*If cPaisLoc="PTG"
						If Alltrim(SF1->F1_ESPECIE)$"GDN!NF!NCI!NCC"
							If !GravaTabEspelho("SD1",RetSqlName("SD1")+"_CANC",SD1->(RECNO()))
	 							Aviso(STR0018,STR0315+"SD1",{"OK"},2)
							EndIf
						EndIf
					EndIf*/
					dbDelete()
					MsUnlock()
				Endif
			Next nX
			dbSelectArea('SF1')
			MsGoto(nRecno)
			//Integração com ACD
			If lIntACD
				CBSF1EXC()
			Endif
			//Gera lanç contabil 665-687-689-690 Exclusao - Total ³
			If Type("cFunName")<>"U"
				If cFunName$"MATA101N|MATA447|MATA462DN" //Nota de Entrada | Pedimentos
					If lVerPad687
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'687','MATA103',cLoteCom)
						EndIf
					ElseIf lVerPad665
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
						EndIf
					EndIf
				EndIf
				If cFunName$"MATA466N" //Nota de Debito
					If lVerPad689
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'689','MATA103',cLoteCom)
						EndIf
					ElseIf lVerPad665
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
						EndIf
					EndIf
				EndIf
				If cFunName$"MATA465N" //Nota de Credito
					If VerPadrao("68F")
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'68F','MATA103',cLoteCom)
						EndIf
					ElseIf lVerPad665
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
						EndIf
					EndIf
				EndIf
				If lF817NCC//Nota de Credito desde FISA817
					If VerPadrao("68F")
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'68F','FISA817',cLoteCom)
						EndIf
					EndIf
				EndIf
				If cFunName$"MATA102N" //Remito de Entrada
					If lVerPad690
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'690','MATA103',cLoteCom)
						EndIf
					ElseIf lVerPad665
						If !Empty(SF1->F1_DTLANC)
							nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
						EndIf
					EndIf
				EndIf
			EndIf
			//Gera Lancto Contabil 995- Exclusao - Total - EIC ³
			If lIntegracao .AND. lVerPad995 .AND. !Empty(SF1->F1_DTLANC)
				nTotalLcto	+= DetProva(nHdlPrv,'995','MATA103',cLoteCom)
			EndIf

			If !lDesclassif
				//O correlativo e excluido na LOCXDELREM()
				If lUsaCor //libera o numero correlativo
					If  !(cPaisLoc == "CHI" .And.  SF1->F1_RECHON=="1")  .And. !Empty(SF1->F1_NUMCOR)
						CORR_EXCL(SF1->F1_DTDIGIT,SF1->F1_NUMCOR)
					EndIf
				EndIf

				If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|POR|PTG|SAL|URU|VEN"
					//apaga o registro de movim. do caixinha
					LocXDelCC(SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE)
				EndIf

				RecLock('SF1',.F.,.T.)
				//Apaga os titulos de recolhimento de impostos ³
				If aCfgNf[ScAliasFin]=="SE2"
					ApagTitImp(cAlias)
				EndIf

				cPe	:=	LocxPE(29)
				If !Empty(cPE)
					ExecBlock(cPE,.F.,.F.)
				Else
					If __lPyme .And. ExistBlock( "LOCXS329" , .F. , .T. )
						Execblock( "LOCXS329" , .F. , .F. )
					EndIf
				EndIf

				//Reabre o Desembaraco do Compras Internacional se houver ³
				dbSelectArea("DBB")
				dbSetOrder(1)
				If MsSeek(cFilDBB+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA, .F. )

					RecLock("DBB", .F.)
					DBB->DBB_OK := " "
					MsUnlock()

   					cStatusDBA := "1" // Assume o Status que nenhuma NFE do desembaraco foi gerada
					dbSetOrder(2)
					DbSeek(cFilDBB+SF1->F1_HAWB , .F. )
					While !Eof() .And. cFilDBB == DBB->DBB_FILIAL .And. DBB->DBB_HAWB == SF1->F1_HAWB

                        If DBB->DBB_OK == "S"
                           cStatusDBA := "2" // Ao encontrar apenas 1 NFE gerada no desembaraco assume o Status de desembaraco parcialmente gerado
					       Exit
					    EndIf

						DBB->(dbSkip())
                    EndDo

					dbSelectArea("DBA")
					dbSetOrder(1)
					If MsSeek(xFilial("DBA")+SF1->F1_HAWB, .F. )
						//Status de Desembaraco com NFEs parcialmente geradas ³
						RecLock("DBA", .F.)
						DBA->DBA_OK := cStatusDBA
						MsUnlock()
	                EndIf

	                For nForDesp := 1 To Len(aPedsDesp)
	                	dbSelectArea("SC7")
	                	dbSetOrder(1)
	                	If dbSeek(cFilSC7+aPedsDesp[nForDesp,1])
	                		RecLock("SC7",.F.)
	                		SC7->C7_QTDACLA += aPedsDesp[nForDesp,2]
	                		MsUnLock()
	                	EndIf
	                Next nForDesp
                EndIf

				dbSelectArea("SF1")
				//Ambiente Portugal, Grava Tabela Espelho |
				//#PORTUGAL#
				/*If cPaisLoc="PTG"
					If Alltrim(SF1->F1_ESPECIE)$"GDN!NF!NCI!NCC"
						If !GravaTabEspelho("SF1",RetSqlName("SF1")+"_CANC",SF1->(RECNO()))
							Aviso(STR0018,STR0315+"SF1",{"OK"},2)
						EndIf
					EndIf
				EndIf*/
				dbDelete()
				MsUnlock()

				//Apaga o arquivo .xml criado na geracao da nota ³
				If cPaisLoc <> "MEX" .And. lGerarCFD .And. FunName() <> "MATA466N"
					CFDExcXML(SF1->F1_ESPECIE,SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE,lAnulaSF3)
				EndIf

			EndIf
			//Efetua a gravacao dos lanç. Contabeis  ³
			If lContab .AND. nHdlPrv > 0 .AND. nTotalLcto > 0
				RodaProva(nHdlPrv,nTotalLcto)
				If UsaSeqCor()
					If cAlias == "SF1"
						aCtbDia := {{"SF1",SF1->(RECNO()),SF1->F1_DIACTB,"F1_NODIA","F1_DIACTB"}}
					ElseIf cAlias == "SF2"
						aCtbDia := {{"SF2",SF2->(RECNO()),SF2->F2_DIACTB,"F2_NODIA","F2_DIACTB"}}
					EndIf
				Else
		    		aCtbDia := {}
				EndIF
				lLctoOk	:= cA100Incl(cArquivo,nHdlPrv,3,cLoteCom,lMostraCtb,lAglCtb,,If(aCfgNf[SaPergs][SlCtbEmiss],&(cAlias+"->"+PrefixoCpo(cAlias)+"_EMISSAO"),dDataBase ),,,,aCtbDia)
				If lLctoOk .AND. !Empty(aRecIMP) .AND. lVerPad975
					For nI:= 1 To Len(aRecIMP)
						SD3->(MsGoTo(aRecIMP[nI][1]))
						If !SD3->(EOF()) .AND. SD3->(Recno()) == aRecIMP[nI][1] .AND. aRecIMP[nI][1]<>0
							RecLock('SD3',.F.)
							Replace D3_DTLANC With dDataBase
							MsUnLock()
						EndIf
					Next
				EndIf
			EndIf
			If !lDesclassif .And. cPaisLoc $ "PER"
				//apaga o registro de movim. do caixinha
				LocXDelCC(SF1->F1_FORNECE,SF1->F1_LOJA,SF1->F1_DOC,SF1->F1_SERIE)
			EndIf
		EndCase
		If cPaisLoc $ "MEX" .And. Funname() = "FISA817"
			If &(cAlias+"->"+PrefixoCpo(cAlias)+"_TIPNOTA") == "01"
				cMotCan := &(cAlias+"->"+PrefixoCpo(cAlias)+"_TIPNOTA")
				cDocCan := &(cAlias+"->"+PrefixoCpo(cAlias)+"_DOC")
				cSerCan := &(cAlias+"->"+PrefixoCpo(cAlias)+"_SERIE")
				cNomXml := &(cAlias+"->"+PrefixoCpo(cAlias)+"_CODDOC")
				cUUID   := &(cAlias+"->"+PrefixoCpo(cAlias)+"_UUID")

				LxActSF3(cMotCan,cDocCan,cSerCan,cNomXml,cUUID)
			Endif
		EndIf
	EndIf
EndIf

If cPaisLoc == "ARG"
	lRet := ArgxDelNF(lRet, nRecno)
EndIf

Return(lRet)


Static Function NfAtuSCN(nQuant,nSigno)
//Efetuar tratamento dos Remitos de Vendas ³
RecLock("SD2",.F.)
Replace D2_QTDAFAT With D2_QTDAFAT - (nQuant * nSigno)
Replace D2_QTDEFAT With D2_QTDEFAT + (nQuant * nSigno)
If D2_QTDEFAT < 0
	Replace D2_QTDEFAT With 0
EndIf
MsUnLock()
Return Nil

Static Function NfAtuSD1(nQuant,nSigno,aCusto)
//Atualiza Remito de entrada ³
RecLock("SD1",.F.)
Replace D1_QTDACLA With D1_QTDACLA - (nQuant * nSigno)
MsUnlock()

//Atualiza custo da movimentacao original de acordo com a movimentacao atual³
SF4->(DbSetOrder(1))
If SF4->(MsSeek(xFilial("SF4")+SD1->D1_TES)) .AND. SF4->F4_ESTOQUE == "S"
	ATUDIFCUSREM(aCusto,nQuant,nSigno)
Endif
Return NIL

/*

±±ºPrograma  ³BUSCASDE  ºAutor  ³Leandro C.G.        º Data ³  19/03/02   º±±
±±ºDesc.     ³Retorna dados referentes ao Rateio por Centro de Custo      º±±
±±º          ³relacionado a uma determinada NF             				  º±±
Obs.: Considera que o arquivo de Notas Fiscais ja esta posicionado no registro correto
aRet	- 	Retorno da funcao
			[1] - aHeader do SDE
			[2] - Recno's do SDE
			[3] - aRatCC
*/
Function BuscaSDE()
Local nItemSDE		:= 0
Local nUsadoSDE 	:= 0
Local aHeaderSDE	:= {}
Local aRecSDE		:= {}
Local aRatCC		:= {}
Local cItemSDE		:= ""
Local aRet			:= Array(3)
Local nY			:= 0
Local bWhile
Local nPosDoc		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_REMITO"	})
Local nPosSerie		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_SERIREM"})

DBSelectArea("SDE")

If (FunName() == "MATA101N" .And. !IsInCallStack("A103GRVATF")) .And. lInclui .And. !Empty(aCols[n,nPosDoc])
	MsSeek(xFilial("SDE")+aCols[n,nPosDoc]+aCols[n,nPosSerie])

	bWhile := { || !Eof() .AND.;
				   xFilial('SDE')	 	== SDE->DE_FILIAL 	.AND.;
				   aCols[n,nPosDoc] 	== SDE->DE_DOC		.AND.;
				   aCols[n,nPosSerie] 	== SDE->DE_SERIE	.AND.;
				   M->F1_FORNECE	 	== SDE->DE_FORNECE	.AND.;
				   M->F1_LOJA 	 	 	== SDE->DE_LOJA }
	lBuscaSDE := .F.
Else

	//³Posiciona arquivo SDE³

	MsSeek(xFilial("SDE")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)

	bWhile := { || !Eof() .AND.;
		xFilial('SDE')	== SDE->DE_FILIAL 		.AND.;
		SF1->F1_DOC 	== SDE->DE_DOC 			.AND.;
		SF1->F1_SERIE 	== SDE->DE_SERIE 		.AND.;
		SF1->F1_FORNECE	== SDE->DE_FORNECE		.AND.;
		SF1->F1_LOJA 	== SDE->DE_LOJA }
EndIf

While Eval(bWhile)

	//³ Montagem do aHeader ³

	If nUsadoSDE==0
		DBSelectArea("SX3")
		DBSetOrder(1)
		MsSeek("SDE")
		While	!EOF() .AND. SX3->X3_ARQUIVO == "SDE"
			If X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL
				nUsadoSDE++
				Aadd(aHeaderSDE,{ 	TRIM(X3Titulo())	,;
									SX3->X3_CAMPO		,;
									SX3->X3_PICTURE		,;
									SX3->X3_TAMANHO		,;
									SX3->X3_DECIMAL		,;
									SX3->X3_VALID		,;
									SX3->X3_USADO		,;
									SX3->X3_TIPO		,;
									SX3->X3_ARQUIVO		,;
									SX3->X3_CONTEXT 	})
			EndIf
			DBSelectArea("SX3")
			DBSkip()
		End
	EndIf

	Aadd(aRecSDE,SDE->(RecNo()))
	If cItemSDE <> 	SDE->DE_ITEMNF
		cItemSDE	:= SDE->DE_ITEMNF
		Aadd(aRatCC,{cItemSDE,{}})
		nItemSDE++
	EndIf
	Aadd(aRatCC[nItemSDE][2],Array(nUsadoSDE+1))

	For nY := 1 to Len(aHeaderSDE)
		If aHeaderSDE[nY][10] <> "V"
			aRatCC[nItemSDE][2][Len(aRatCC[nItemSDE][2])][nY] := SDE->(FieldGet(FieldPos(aHeaderSDE[nY][2])))
		Else
			aRatCC[nItemSDE][2][Len(aRatCC[nItemSDE][2])][nY] := SDE->(CriaVar(aHeaderSDE[nY][2]))
		EndIf

		//³ Lê campos Memos Virtuais da tabela SYP vinculado aos memos SDE ³

		If Type("aMemoSDE") == "A"
			If Len(aMemoSDE) > 0
				If (AllTrim(aHeaderSDE[nY][2])==AllTrim(aMemoSDE[1][2]))
					aRatCC[nItemSDE][2][Len(aRatCC[nItemSDE][2])][nY]:= MSMM(&("SDE->"+aMemoSDE[1][1]))
		    	EndIf
			EndIf
		EndIf

		aRatCC[nItemSDE][2][Len(aRatCC[nItemSDE][2])][nUsadoSDE+1] := .F.
	Next nY
	DBSelectArea("SDE")
	DBSkip()
End

aRet[1] := aClone(aHeaderSDE)
aRet[2] := aClone(aRecSDE)
aRet[3] := aClone(aRatCC)
Return(aRet)

/*

±±ºPrograma  ³MONTARATCCºAutor  ³Leandro C.G.        º Data ³  20/03/02   º±±
±±ºDesc.     ³Chama a tela que efetua o rateio por centro de custos       º±±

*/
Function MontaRatCC()
Local nPosItem		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_ITEM"	 })
Local nPosCC		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_CC"		 })
Local nPosConta		:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_CONTA"	 })
Local nPosItemCta	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_ITEMCTA" })
Local nPosCLVL		:= Ascan(aHeader,{|x| AllTrim(x[2]) == "D1_CLVL"	 })
Local nPosRateio	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_RATEIO"	 })
Local nPosRemito	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_REMITO"	 })
Local nPosItemRem	:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_ITEMREM" })

If nPosItem > 0 .And. nPosCC > 0 .And. nPosConta > 0 .And. nPosItemCta > 0 .And. nPosClVl > 0 .And. nPosRateio > 0
    If !lInclui
		aRatCC := BuscaSDE()[3]

	ElseIf lInclui .And. FunName() == "MATA101N" .And. aCols[n][nPosRateio] == "1";
			.And. !Empty(aCols[n][nPosRemito]) .And. !Empty(aCols[n][nPosItemRem]) .And. lLeSDE .And. Len(aRatCC) == 0
		aRatCC := BuscaSDE()[3]
		lLeSDE := .F.

    EndIf

	Lxa103RatCC()

Else
	//"Para utilizar esta opcao se faz necessario que os seguintes campos estejam em uso e disponiveis:"
	Alert(STR0098 + " D1_ITEM, D1_CC, D1_CONTA, D1_ITEMCTA, D1_CLVL, D1_RATEIO.")
EndIf
Return .T.
/*
±±ºPrograma  ³LocXFatAut ºº±±
*/
Function LocXFatAut()
Local aNumNF:={},aRet:={}
Local cFactAut := GetMV("MV_FACTAUT")

If (cFactAut == "N" .And. cPaisLoc <> "MEX") .Or. ;
	(cFactAut = "N" .And. cPaisLoc == "MEX" .And. (!lFuncAtual .Or. lAltSerie ) )
	If (Type("lLocxAuto") <> "U" .AND. lLocxAuto)
		aRet := LocXSx5NF(,lLocxAuto,aAutoCab)
	Else
		aRet := LocXSx5NF(&(cNomeDlg))
	Endif
Else
	If !Empty(aPE[31][1]) .AND.FindFunction("U_"+aPE[31][1])
		aNumNF := ExecBlock(aPe[31][1],.F.,.F.)
	ElseIf	FindFunction("U_"+aPE[31][2])
		aNumNF := ExecBlock(aPe[31][2],.F.,.F.)
	Else
		aNumNF := {"",space(TamSx3('F2_DOC')[1]),space(TamSx3('F2_SERIE')[1])}
	EndIf
	aRet := IIf(lGerarCFD, ValSFP(aNumNF),{AllTrim(aNumNF[1])+aNumNF[2],aNumNF[3]})

EndIf
Return(aRet)
/*
±±ºPrograma  ³LocXSx5NF  º±±
±±ºDesc.     ³Controle de numeracao dos documentos de formulario proprio    º±±
*/
Function LocXSx5NF(oDlgPae,lLocxAuto,aAutoCab,lNumNCC,lTransf)
Local nTimes
Local aSerNF 	:= {}
Local nTamNota	:= TamSX3("F1_DOC")[1]
Local nTamSerie	:= TamSX3("F1_SERIE")[1]
Local oDlg,cCadastro := OemToAnsi(STR0099),cVarQ:="  ",oQual    //"Nr de Fatura"
Local nOpcA 	:= 0//, lDone := .F.
Local lAbandona := .F.//, lInterno := .T.
Local lSeqEspecie := SuperGetMV("MV_SEQESPE",,.F.)
//Local nCntErro  := 0
Local nTimeOut	:=	GetMv("MV_NOTAOUT")
Local nPosNum   := 0
Local nPosSer   := 0
Local cLabelSer := OemToAnsi(STR0100)  //"Serie Factura"
Local cLabelDoc := OemToAnsi(STR0101)  //"NR de Factura"
Local cPrefC    := ""
Local cChaveSX5 := xFilial("SX5")+IIf(lSeqEspecie,"AC","01")
Local cSerieChave := ""
Local cSerieSX5	  := ""
Local aRet        := {}
Local nPosIni     := 0
Local cCombo      := ""
Local cFilSFP	  := xFilial("SFP")
Local AreaSX3     := {}
local nCount      := 0
Local aFiltro     := {}
Local cSFPEsp	  := ""
Local lnoAtivo	  := .F.
Local lReutiliza  := GetMv("MV_USAMNUM",,.T.)
Local lDifNum	  := .F.
Local cNumSx5	  := ""
Local nx 		  := 0

PRIVATE lSX5Troca := .F.

//Se lNumNCC = .T. indica que foi chamado da rotina para geracao de Nota de Credito no cancelamento da NF - Loc. Guatemala
DEFAULT lNumNCC  := .F.

// Parametro utilizado para tranferencia de material
DEFAULT lTransf := .F.

cPrefC := IIf(lTransf,"",PrefixoCpo(aCfgNF[SAliasHead]))

If lNumNCC
   cLabelSer  := OemToAnsi(STR0233)  //"Serie Nota de Credito"
   cLabelDoc  := OemToAnsi(STR0232)  //"Num. Nota de Credito"
   cCadastro  := OemToAnsi(STR0232)  //"Num. Nota de Credito"
EndIf

vNumero   := ""
cFiltro   := ""
cEspecDoc := IIf(lTransf,"",aCfgNf[ScEspecie])

//³Busca as series correntes na tabela AB - Loc. Guatemala ³

If cPaisLoc == "GUA"
   dbSelectArea("SX5")
   dbSetOrder(1)
   If dbSeek(xFilial("SX5")+"AB"+cEspecDoc)
      cFiltro  := IIf(lSeqEspecie,cEspecDoc,"")+Padr(X5Descri(),nTamSerie)
   EndIf
EndIf

aSerNF := {}

// Leandro Prado - 24/02/2014 - Controle de Ponto de Venda p/ Argentina.
If (cPaisLoc =="ARG") .And. (Type("cFunName")<>"U" .and. cFunName $ "MATA465N|MATA466N|MATA467N|MATA468N|MATA101N|MATA462N|MATA462DN|MATA462TN|MATA102DN||MATA462R|OMSA320")
	If AllTrim(cEspecie) == "NF"
		cSFPEsp := "1"
	ElseIf AllTrim(cEspecie) == "NCI"
		cSFPEsp := "2"
	ElseIf AllTrim(cEspecie) == "NDI"
		cSFPEsp := "3"
	ElseIf AllTrim(cEspecie) == "NCC"
		cSFPEsp := "4"
	ElseIf AllTrim(cEspecie) == "NDC"
		cSFPEsp := "5"
	ElseIf AllTrim(cEspecie) == "RFN" .or. AllTrim(cEspecie) == "RTS" .or. AllTrim(cEspecie) == "RCD"
		cSFPEsp := "6"
	ElseIf AllTrim(cEspecie) == "RFD" .or. AllTrim(cEspecie) == "RTE"
		cSFPEsp := "7"
	ElseIf AllTrim(cEspecie) == "RET"
		cSFPEsp := "8"
	ElseIf AllTrim(cEspecie) == "RFB"
		cSFPEsp := "9"
	EndIf
	("SFP")->(DbSetOrder(9))
	If ("SFP")->(MsSeek(xFilial("SFP")+cLocxNFPV))
		If cPaisLoc == "ARG" .AND. cEspecDoc $ "RFD"
			AreaSX3 := GetArea()
				SX3->(dbSetOrder(2))
				SX3->(dbSeek("FP_ESPECIE"))
				nPosIni := At(AllTrim(cEspecie),AllTrim(SX3->X3_CBOX))
				cCombo := Substr(AllTrim(SX3->X3_CBOX),nPosIni-2,1)
			RestArea(AreaSX3)
			While (SFP->(!EOF())) .And. (SFP->FP_PV = cLocxNFPV)
				If AllTrim(SFP->FP_ESPECIE) == AllTrim(cCombo) .AND. dDataBase <= SFP->FP_DTAVAL
					If	cPaisLoc == "ARG" .and. Empty(cFiltro)
						AADD(aFiltro,AllTrim(SFP->FP_SERIE)+ cIdPVArg)
					Else
						cFiltro += "'" + AllTrim(SFP->FP_SERIE) + cIdPVArg + "|'"
					EndIF
					nCount++
				EndIf
				SFP->( DBSkip() )
			EndDo
		Else
			While (SFP->(!EOF())) .And. (SFP->FP_PV = cLocxNFPV)
				If	cPaisLoc == "ARG" .and. Empty(cFiltro)
					If (AllTrim(SFP->FP_ESPECIE) == cSFPEsp .or. AllTrim(SFP->FP_ESPECIE) == "" ) .And. SFP->FP_ATIVO <> "2"
						AADD(aFiltro,AllTrim(SFP->FP_SERIE)+ cIdPVArg)
					Else
						lnoAtivo := .T.
					EndIf
				Else
					cFiltro += "'" + AllTrim(SFP->FP_SERIE) + cIdPVArg + "|'"
				EndIf
				SFP->( DBSkip() )
			EndDo
		EndIf
	EndIf
EndIf
cPe	:=	LocxPE(32)
If !Empty(cPe)
	cFiltro := ExecBlock(cPe,.F.,.F.,{cFiltro})
EndIf
If Len(aFiltro) > 0 .and. ExistBlock('FILSERPV')
	aFiltro := Execblock('FILSERPV',.F.,.F.,{aFiltro})
EndIf


dbSelectArea("SX5")
dbSetOrder(1)
DbSeek( cChaveSX5 )
If (Iif(cPaisLoc == "RUS", ValType(lLocxAuto) == "U", Type("lLocxAuto") == "U") .OR. !lLocxAuto)
    While !Eof() .AND. X5_FILIAL+X5_TABELA == cChaveSX5

		//³ Filtrar as Serie a serem mostradas ³

		If ! Empty(cFiltro) .or. (cPaisLoc = "ARG" .and. Len(aFiltro) > 0)
	       cSerieChave  := IIf(lSeqEspecie,SX5->X5_CHAVE,Substr(SX5->X5_CHAVE,1,nTamSerie))
	       cSerieChave  := IIf(cPaisLoc = "ARG",AllTrim(X5_CHAVE),cSerieChave)
	       cSerieSX5    := IIf(lSeqEspecie,Substr(X5_CHAVE,4,nTamSerie),Padr(X5_CHAVE,nTamSerie))
	       cSerieSX5    := IIf(cPaisLoc = "ARG",RetSERNF(X5_CHAVE),cSerieSX5)
	       If (cPaisLoc = "ARG") .And. (Len(cSerieChave) > 3) .and. Empty(cFiltro)
	       		If aScan(aFiltro,{|x|x==cSerieChave}) > 0
	       			AADD( aSerNF,{ cSerieSX5, LocConvNota(X5Descri(),nTamNota) } )
	       		EndIf
			ElseIf (cPaisLoc <> "ARG")
				If cSerieChave $ cFiltro
					AADD( aSerNF,{ cSerieSX5, LocConvNota(X5Descri(),nTamNota) } )
				EndIf
			EndIf
        Else
           //Filtrar pela especie do documento. Retornar as series apenas do documento emitido
           If lSeqEspecie
              If Substr(X5_CHAVE,1,3) != cEspecDoc
                 DbSkip()
                 Loop
              EndIf
           EndIf
           If cPaisLoc <> "ARG" .AND. nCount <= 0
              cSerieSX5    := IIf(lSeqEspecie,Substr(X5_CHAVE,4,nTamSerie),Padr(X5_CHAVE,nTamSerie))
			  AADD( aSerNF,{ cSerieSX5, LocConvNota(X5Descri(),nTamNota) } )
	       EndIf
        EndIf
		dbSkip()
	EndDo
	If cPaisLoc == "ARG" .And. len(aSerNF) > 0 .And. lReutiliza
		For nx := 1 To Len(aSerNF)
			cNumSx5 := aSerNF[nx,2]
			lDifNum := StaticCall(LOCXARG,AVldNum,aSerNF[nx,1],@cNumSx5,cEspecie,cLocxNFPV)
			//Verifica si existe el número de documento en la tabla SF2, si existe, asigna el número siguiente.
			If cPaisLoc == "ARG" .And. (Type("cFunName")<>"U" .And. cFunName $ "MATA467N") .And. FindFunction("ANumExis")
				While ANumExis(aSerNF[nx,1],@cNumSx5,cLocxNFPV)
					cNumSx5:= Soma1(cNumSx5)
				EndDo
			EndIf
			If !lDifNum .And. aSerNF[nx,2] <> cNumSx5
				aSerNF[nx,2] := cNumSx5
			Endif
		Next nx
	EndIf
	If (Len(aSerNF) == 0) .OR. lAbandona
		If cPaisLoc == "ARG" .AND. cEspecDoc $ "RFD"
			MsgAlert(STR0367 ,STR0366) //"Registrar series para Remitos de Devolucion (RFD) en Control de Formularios" //"¡Series vacias!"
		ElseIf cPaisLoc == "ARG" .AND. lnoAtivo
			MsgAlert(STR0426,STR0366)
		Else
			Help(" ",1,"A460FLOCK")
		endIf
	Endif

	If Len(aSerNF) > 1
		DEFINE MSDIALOG oDlg TITLE cCadastro FROM 0,0 TO 264,378 OF oDlgPae	PIXEL
		@ .5,.80 LISTBOX oQual VAR cVarQ Fields HEADER STR0100,STR0101 SIZE 180,100 ON DBLCLICK (aSerNF:=aSX5Troca(oQual:nAt,aSerNF,nTimeOut),oQual:Refresh()) NOSCROLL  //"Serie Factura"###"NR de Factura"
		oQual:SetArray(aSerNF)
		oQual:bLine := { || {aSerNf[oQual:nAT,1],aSerNf[oQual:nAT,2]}}
		DEFINE SBUTTON FROM 120,130  TYPE 1 ACTION (nOpca := 1,cNumero:=aSerNf[oQual:nAt,2],cSerie:=aSerNf[oQual:nAt,1],oDlg:End()) ENABLE OF oDlg
		DEFINE SBUTTON FROM 120,160 TYPE 2 ACTION (nOpcA := 3,oDlg:End()) ENABLE OF oDlg
		ACTIVATE MSDIALOG oDlg
	ElseIF !Len(aSerNF) == 0
		cNumero := aSerNf[1,2]
		cSerie  := aSerNf[1,1]
		nOpcA   := 1
	EndIf
	IF (nOpcA != 1)
		Return ( {} )
	Endif
	If !lSX5Troca
		vNumero := cNumero
	Endif

Else
    nPosNum  := Ascan(aAutoCab, { |x| Upper(AllTrim(x[1]))==cPrefC+"_DOC"   })
    nPosSer  := Ascan(aAutoCab, { |x| Upper(AllTrim(x[1]))==cPrefC+"_SERIE" })

	If nPosNum > 0
		cNumero := aAutoCab[nPosNum][2]
	Else
		cNumero := Space(nTamNota)
	Endif
	If nPosSer > 0
		cSerie	:= aAutoCab[nPosSer][2]
	Else
		cSerie	:= Space(nTamSerie)
	Endif
Endif

//Valida si la secuencia del número de documento está dentro del rango a la fecha emisión del documento anterior y posterior
If cPaisLoc == "ARG" .And. (Type("cFunName")<>"U" .And. cFunName $ "MATA467N") .And. FindFunction("AVldFecNf") .And. GetNewPar("MV_CTRLFOL",.F.)
	If !AVldFecNf(cSerie,cNumero,cLocxNFPV)
		HELP(" ",1,"FCHNOVLD",,STR0449 + Alltrim(cSerie)+"-"+cNumero, 2, 0,,,,,,{STR0450})
		Return ( {} )
	EndIf
EndIf

//³Valida se o numero esta homologado pela SAT ³

If cPaisLoc == "GUA"
	If !LocxNumSAT(cSerie,cNumero,lNumNCC)
    	Return ( {} )
	EndIf
EndIf
cSerieSX5  := IIf(lSeqEspecie,cEspecDoc+cSerie,cSerie)
If DbSeek( cChaveSX5+cSerieSX5,.F. )
	If (Iif(cPaisLoc == "RUS", ValType(lLocxAuto) != "U", Type("lLocxAuto") <> "U") .AND. lLocxAuto)
		cNumero := IIf(Empty(cNumero),X5Descri(),cNumero)
		//Caso o numero do documento nao tenha sido enviado no array do cabecalho
		If nPosNum == 0
		   AADD(aAutoCab,{IIf(lTransf,"F2",PrefixoCpo(aCfgNF[SAliasHead]))+"_DOC", cNumero, NIL})
		EndIf
	Endif
	cNumero := LocConvNota(cNumero,nTamNota)
	nTimes := 0

	If !InTransact()
		While !MsRLock() .AND. nTimes < 10
			nTimes++
			Inkey(.1)
			DbSeek( cChaveSX5+cSerieSX5,.F. )
		EndDo
	EndIf

	IF RecLock("SX5",.F.)
		Replace X5_DESCRI  With cNumero
		Replace X5_DESCENG With cNumero
		Replace X5_DESCSPA With cNumero
		MsUnlock()
	Else
		Return( {} )
	Endif
Else
	If !InTransact()
		SX5->(MsRUnLock())
	EndIf
	Return( {} )
EndIf

If !lTransf .AND. lGerarCFD
	// Busca pos. da descricao da especie da nota no combo da tabela SFP (1=NF;2=NCI;3=NDI;4=NCC;5=NDC)
	SX3->(dbSetOrder(2))
	SX3->(MsSeek("FP_ESPECIE"))
	nPosIni := At(AllTrim(cEspecie),AllTrim(SX3->X3_CBOX))
	cCombo := Substr(AllTrim(SX3->X3_CBOX),nPosIni-2,1)

	// Verifica se a nota selecionada esta dentro de algum range cadastrado
	// Necessario em caso de existir mais de um range com a mesma serie
	SFP->(DbSeek(cFilSFP + cFilAnt + cSerie))
	While SFP->FP_FILIAL+SFP->FP_FILUSO+SFP->FP_SERIE == cFilSFP+cFilAnt+cSerie
		If AllTrim(SFP->FP_ESPECIE) == AllTrim(cCombo)
			If Val(cNumero) >= Val(SFP->FP_NUMINI) .AND. Val(cNumero) <= Val(SFP->FP_NUMFIM)
				Exit
			Endif
		EndIf
		SFP->(dbSkip())
	EndDo
	aRet := {cNumero, cSerie, SFP->FP_CAI, IIF(SFP->(ColumnPos("FP_NRCERT")) > 0,SFP->FP_NRCERT,"")}
Else
	aRet := { cNumero, cSerie }
Endif
Return( aRet )

/*/
±±³Funcao    ³LocXStock ³±±
±±³Descri‡…o ³Apresenta consulta de estoque pressionando F4               ³±±
/*/
Function LocXStock(cTipo,cVar)
Local lGrade	:= GetMv("MV_GRADE")
Local lRusDebit	:= cPaisLoc == "RUS" .And. cEspecie == "NDP"
Local nPProduto := aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit, "D1_COD","D2_COD") 		})
Local nPTes		:= aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit,"D1_TES","D2_TES")		})
Local nPLocal	:= aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit,"D1_LOCAL","D2_LOCAL")	})
Local nPQuant 	:= aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit,"D1_QUANT","D2_QUANT")	})
//Local nPPrcVen  := aScan(aHeader,{|x| AllTrim(x[2])==Iif(lRusDebit,"D1_VUNIT","D2_PRCVEN")	})
Local nPIdent 	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_IDENTB6"	})
Local nPSerie	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_SERIORI"	})
Local nPosNF	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_NFORI"	})
Local nPItemOri := aScan(aHeader,{|x| AllTrim(x[2])=="D2_ITEMORI"	})
Local nProvEnt  := aScan(aHeader,{|x| AllTrim(x[2])=="D2_PROVENT"	})
Local aTeclas	:= {}
Local cProduto  := ""
Local cLocal    := ""
Local cTes      := ""
Local nItem     := n
Local nRecnoSD1 := 0
//Local nRecnoSD2 := 0
Local aArea		:= {}
Local lAtuTots	:=	.F.
Local aSavCols	:= aCols
Local nSavN		:= n
Local nPosItem	:= aScan(aHeader,{|x| AllTrim(x[2]) == Iif(lRusDebit,"D1_ITEM","D2_ITEM")} )
Local aRatDevAFS:= {}
Local nT_EDT	:= TamSx3("AFS_EDT")[1]

If Alias() $ 'SF2||SF1' .AND. !Empty(dbFilter())
	aArea	:=	{Alias()}
Else
	aArea	:= { Alias() , IndexOrd() ,  RecNo() }
Endif

cProduto := aCols[n][nPProduto]
cLocal	 := aCols[n][nPLocal]
cTes	 := aCols[n][nPTes]

//Estas variaveis sao usadas dentro da F4Lote, por isto devem ser privates
Private	 nPosLote	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_NUMLOTE"})
Private	 nPosLotCtl	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_LOTECTL"})
Private	 nPosDValid	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_DTVALID"})
Private	 nPosPotenc	:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_POTENCI"})

DEFAULT cVar	:=	READVAR()

//³Salva as taclas de atalhos para posterior restauracao
aTeclas := ContTeclas()

dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+cTes)

If ( lGrade )
	MatGrdPrrf(@cProduto)
EndIf

cCpoQtd := Iif(lRusDebit,"M->D1_QUANT","M->D2_QUANT")
cCpoPrc := Iif(lRusDebit,"M->D1_VUNIT","M->D2_PRCVEN")
Do Case

	//³F4 para NF original ³
	Case cTipo == "2" .AND. "D2_NFORI" $ cVar //Saida por devolucao
		If F4NfOri(,,cVar,M->F2_CLIENTE,M->F2_LOJA,cProduto,"A466",,,@nRecnoSD1,Iif(cPaisLoc == "RUS",M->F2_EMISSAO,))
			LxA103SD1ToaCols(nRecnoSD1,nItem)
      		lAtuTots	:=	.T.
		EndIf

	Case lRusDebit .And. cTipo == "2" .And. "D1_NFORI" $ cVar //Send Of inflow Invoice (Debit Note)
		If F4NfOri(,,cVar,M->F1_FORNECE,M->F1_LOJA,cProduto,"ARUS466",,,@nRecnoSD1,M->F1_EMISSAO)
			LxA103SD1ToaCols(nRecnoSD1,nItem)
      		lAtuTots	:=	.T.
		EndIf

	//³F4 para Localizacao Devolucao de poder de 3ros.  ³
	Case cTipo == "1" .AND. aCfgNF[ScTipoDoc] == "N" .AND. ( "D2_QUANT" $ cVar .AND. SF4->F4_PODER3=="D" )
		If nPIdent*nPItemOri*nPSerie*nPosNF > 0
			A440F4( "SB6",cProduto,cLocal,"B6_PRODUTO","D",M->F2_CLIENTE,M->F2_LOJA,.F.,.F.,,"C")
 	        If cPaisLoc == "ARG" .And. nProvEnt > 0
				MaFisAlt('IT_PROVENT'  ,aCols[n,nProvEnt],n)
			Endif
		Else
			Aviso(STR0018,STR0098+CRLF+"D2_IDENTB6"+CRLF+"D2_SERIORI"+CRLF+"D2_NFORI"+CRLF+"D2_ITEMORI",{"OK"})					 //"Esta nota esta sendo digitada por outra estacao"
		Endif

	//³F4 para Rastreabilidade ³
	Case cTipo == "3" .AND. ( "D2_NUMLOTE" $ cVar .OR. "D2_LOTECTL" $ cVar )

		//³Variaveis Privates utilizadas na  funcao  F4Lote  ³
		If F4Lote(,,,"A467",cProduto,cLocal)
			MaFisAlt('IT_QUANT'  ,aCols[n,nPQuant],n)
      		lAtuTots	:=	.T.
		Endif

	//³F4 para Localizacao Fisica ³
	Case cTipo == "3" .AND. "D2_LOCALIZ" $ cVar
      	If F4Localiz( ,,, "A467" )  //"A440"
			MaFisAlt('IT_QUANT'  ,aCols[n,nPQuant],n)
      		lAtuTots	:=	.T.
		Endif

	Case cTipo $ "12" .AND. (Empty(cVar) .OR. ( "D2_QUANT" $ cVar ) .OR. ( "D2_COD" $ cVar  ))
		If ( ExistBlock('A440STK') )
			ExecBlock('A440STK',.f.,.f.)
		Else
			A440Saldo(.F.)
		EndIf
EndCase
/*
  ³Atualiza o browse de qtde de produtos ³
  */
If lAtuTots
	AtuLoadQt(.T.)
Endif

dbSelectArea("SD1")
GoTo(nRecnoSD1)

dbSelectArea("AFN")
dbSetOrder(2)
If DbSeek(xFilial("AFN")+SD1->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_ITEM))
	While !EOF() .AND. (SD1->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_ITEM))==(AFN->(AFN_DOC+AFN_SERIE+AFN_FORNECE+AFN_LOJA+AFN_ITEM))
		Aadd(aRatDevAFS, {AFN->AFN_PROJET ,AFN->AFN_REVISA ,Space(nT_EDT),AFN->AFN_TAREFA ,AFN->AFN_QUANT, .F. })
		AFN->( dbSkip() )
	EndDo
	aADD(aRatAFS,{aSavCols[nSavN][nPosItem],aClone(aRatDevAFS)})
ENDIF

//³Restaura as teclas de atalhos. ³

ContTeclas(aTeclas)

//³Restaura a entrada da rotina ³

dbSelectArea(aArea[1])
If Len(aArea)>1
	dbSetOrder(aArea[2])
	MsGoto(aArea[3])
Endif
Return(.T.)
/*/
±±³Fun‡…o    ³ LocXAvStok³ ±±
±±³Descri‡…o ³ Valida o saldo em estoque                                  ³±±
±±³ Uso      ³ Faturam.                                                   ³±±
/*/
Function LocXAvStok(aCpItens,aCItens)
LOCAL lEstoque	:= .T.
LOCAL nx 		:= 0
LOCAL nQtd 		:= 0.00
LOCAL nPosLocal := 0, nPosQuant := 0.00,nPosPedido:=0
LOCAL nPosLotCtl:= 0, nPosNumLot := 0, nPosLocaliz := 0, nPosNumSer := 0
LOCAL nPosItemPV:= nPosSequen := 0
//LOCAL cCodProd	:= CriaVar("D2_COD")
LOCAL cLocal	:= CriaVar("D2_LOCAL")
LOCAL cLoteCtl	:= CriaVar("D2_LOTECTL")
LOCAL cNumLote	:= CriaVar("D2_NUMLOTE")
LOCAL cLocaliz	:= ""
LOCAL cPedido 	:= ""
LOCAL cNumSer	:= ""
LOCAL aProd		:= {}
LOCAL nCols		:= 0
LOCAL cAux		:= ""
LOCAL nPosProd	:= Ascan( aCpItens,{ |x| Alltrim(x) == "D2_COD" } )
LOCAL cItemPV   := ""
LOCAL cSequen   := ""
Local lTesPeRemi:=.F.
Local cFilSF4	:= xFilial("SF4")
//Local cFilSDC	:= xFilial("SDC")

nPosTES    := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_TES" } )
If nPosTES == 0
	Help(" ",1,"A467NOTES")
	lEstoque:=.F.
Else
	nPosLocal  := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_LOCAL" } )
	nPosQuant  := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_QUANT" } )
	nPosLotCtl := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_LOTECTL" } )
	nPosNumLot := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_NUMLOTE" } )
	nPosLocaliz:= Ascan( aCpItens,{ |x| Alltrim(x) == "D2_LOCALIZ" } )
	nPosNumSer := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_NUMSERI" } )
	nPosRemito := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_REMITO" } )
	nPosTPDCENV:= Ascan( aCpItens,{ |x| Alltrim(x) == "D2_TPDCENV"} )
	nPosPedido := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_PEDIDO" } )
	nPosItemPV := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_ITEMPV" } )
	nPosSequen := Ascan( aCpItens,{ |x| Alltrim(x) == "D2_SEQUEN" } )

	SF4->( dbSetOrder(1) )
	nCols:=Len(aCpItens)+1
	For nX:=1 to Len(aCols)

		If (GetMV("MV_ESTNEG")=="N").OR. Rastro(aCItens[nX][nPosProd]) .OR. Localiza(aCItens[nX][nPosProd])

			If !aCItens[nX][nCols]
				SF4->( MsSeek(cFilSF4+aCItens[nX,nPosTES]) )
				IF SF4->F4_ESTOQUE == "S" .AND.(aCfgNF[SlRemito] .OR. Empty(aCItens[nX][nPosRemito]).OR.nPosTPDCENV==0 .OR. aCItens[nX][nPosTPDCENV]=="1".OR. aCItens[nX][nPosTPDCENV]==_RMCONS )
					If nPosNumser>0
						cNumSer := aCItens[nX][nPosNumSer]
					Else
						cNumSer:= ""
					Endif
					If nPosPedido>0
						cPedido := aCItens[nX][nPosPedido]
					Else
						cPedido:= ""
					Endif
					If nPosProd > 0
						cCodPro := aCItens[nX][nPosProd]
					Else
						cCodPro	:= ""
					EndIf
					If nPosLocal > 0
						cLocal := aCItens[nX][nPosLocal]
					Else
						cLocal := ""
					EndIf
					If nPosQuant > 0
						nQtd := aCItens[nX][nPosQuant]
					Else
						nQtd := 0
					EndIf
					If nPosLotCtl > 0
						cLoteCtl := aCItens[nX][nPosLotCtl]
					Else
						cLoteCtl := ""
					EndIf
					If nPosNumLot > 0
						cNumLote := aCItens[nX][nPosNumLot]
					Else
						cNumLote := ""
					EndIf
					If nPosItemPV > 0
						cItemPV := aCItens[nX][nPosItemPV]
					Else
						cItemPV := ""
					EndIf
					If nPosSequen > 0
						cSequen := aCItens[nX][nPosSequen]
					Else
						cSequen := ""
					EndIf
					If nPosLocaliz > 0
						cLocaliz := aCItens[nX][nPosLocaliz]
					Else
						cLocaliz := ""
					EndIf
					If !Empty(cPedido+cItemPV+cSequen)
						dbSelectArea("SDC")
						dbSetOrder(1)
						MsSeek(xFilial("SDC")+cCodPro+cLocal+"SC6"+cPedido+cItemPV+cSequen)
						If Found() .And. QtdComp(nQtd) == QtdComp(1)
							cLocaliz := SDC->DC_LOCALIZ
							cNumSer  := SDC->DC_NUMSERI
						EndIf
					EndIf
					cAux:=cCodPro+cLocal+cLoteCtl+cNumLote+cLocaliz+cNumSer+If(Empty(cPedido),".F.",".T.")
					nPos:=Ascan(aProd,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6]+x[7]==cAux})
					If nPos==0
						Aadd(aProd,{cCodPro,cLocal,cLoteCtl,cNumLote,cLocaliz,cNumSer,If(Empty(cPedido),".F.",".T."),nQtd,aCItens[nX,nPosTES]})
					Else
						aProd[nPos][8]+=nQtd
					Endif
				Endif
			Endif
		Endif
	Next
	nCols:=Len(aProd)
	If nCols>0
		nX:=0
		lEstoque:=.T.
		While nX<nCols .AND. lEstoque
			nX++
			If aCfgNf[SlRemito] .And. &(aProd[nX][7])
			    lTesPeRemi := Posicione('SF4',1,cFilSF4+aProd[nX][9],'F4_ESTOQUE') == "N"
			EndIf
			If !SaldoOk(aProd[nX][1],aProd[nX][2],aProd[nX][8],aProd[nX][3],aProd[nX][4],aProd[nX][5],aProd[nX][6],&(aProd[nX][7]),,,,,lTesPeRemi)
				Aviso(STR0018,STR0070,{STR0021})
				lEstoque := .F.
			EndIf
		End
	EndIf
Endif
Return lEstoque
/*/
±±³Fun‡…o    ³ LocXAvCred³ ±±
±±³Descri‡…o ³ Validar o Valor digitado e verificar o limite de Credito.  ³±±
±±³ Uso      ³ Faturam.                                                   ³±±
/*/
Function LocXAvCred(aCpItens,aCItens)
LOCAL lCredito  := .F.
Local lMTValAvC := ExistBlock("MTVALAVC")
Local nValAv	:= 0

LOCAL nVlrTotal := 0.00
LOCAL cBlCred   := ""
LOCAL aEmpenho  := {}

nVlrTotal	:=	MaFisRet(,"NF_BASEDUP")

//³ Efetuar a avaliacao do Cr‚dito  ³

If lMTValAvC
	nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'LOCXNF',nVlrTotal,Nil})
Else
	nValAv	:=	nVlrTotal
Endif

lCredito := MaAvalCred(SA1->A1_COD,SA1->A1_LOJA,nValAv,nMoedaNF,.T.,@cBlCred,@aEmpenho)

If ! lCredito
	If !Empty(cBlCred)
		If     cBlCred == "01"
			cMsg := STR0102 //"01-Sin Limite de Cr‚dito"
		ElseIf cBlCred == "04"
			cMsg := STR0103 //"04-Limite de Cr‚dito Vencido"
		Else
			cMsg := STR0104 //"99-Otros"
		EndIf
		If IsInCallStack("FA096Anula") .And. cBlCred == "04" .or. cBlCred == "01"
			lCredito := .T.
		Else
			Help(" ",1,"A467LC",,cMsg,4,5)
		EndIf
	EndIf
EndIf
Return( lCredito )

/*/

±±³Funcao    ³LocxPesq  ³ ±±
±±³Descri‡…o ³Tratamento do Filtro e simulacao de SoftSeek na pesquisa.   ³±±

/*/
Function LocxPesq(bFilBrow)
AxPesqui()
Eval(bFilBrw)
Return(.T.)
/*/

±±³Fun‡…o    ³LocxLegenda³ ±±
±±³Descri‡…o ³ Cria uma janela com a legenda da mBrowse            		  ³±±
/*/
Function LocxLegenda(cAlias,lFiltra,cDescGer)
Local aLegenda := { 	{"DISABLE"   ,STR0013,{"01","10"}}  ,;				//"NF Normal"
						{"BR_CINZA"  ,STR0015,{"11","12","52","62"}}  ,;	//"NF de Beneficiamento"
						{"BR_AMARELO",STR0016,{"04","05","06","07"}}  ,;	//"NF de Devolucao"
						{"BR_PINK"   ,STR0014,{"02","03","08","09"}}  ,;	//"NF de Compl. Preco"
						{"BR_MARROM" ,DESCREM,{"50","60"}}  ,;				//"Remito"
						{"BR_AZUL"	 ,DESCREM+STR0105,{"51","53","61"}} ,;	//"Remito de devolucao"
						{"BR_PRETO"	 ,DESCREM+STR0185,{"54","64"}},;		//"Remito de Transferencia"
						{"BR_VERDE"	 ,STR0385,{"21"}} ,;                 	// Traslado - Mex
						{"BR_BRANCO" ,Iif(cPaisLoc=="AUS",STR0322,Iif(cPaisLoc=="MEX", STR0264,Iif(cPaisLoc=="PER",STR0264,STR0321))),{"17","18","19"}}} //"Nota de venta" - EQU/RCTI - AUS/Adiantamento - Mex /Adiantamento - Peru

Local aLeg		:=	{}
Local nX,nY

DEFAULT cAlias	 :=	aCfgNf[SAliasHead]
DEFAULT lFiltra	 :=	Iif(Type("lFiLD1D2")=="L",lFiLD1D2,GetMv('MV_FLTD1D2'))
DEFAULT cDescGer :=	aCfgnf[ScDescGer]

//#PORTUGAL#
/*If cPaisLoc$"PTG"
	If cFunName$"MATA103CG/MATA103CF/MATA462G"
		aLegenda:={}
		aLegenda:={ 	{"ENABLE"	 ,STR0313,{"65","65"}},;	//"Guia de Remessa - Normal"
						{"DISABLE"	 ,STR0314,{"65","65"}},; 	//"Guia de Remessa - Cancelada"
						{"ENABLE"	 ,STR0313,{"10","10"}},;	//"Factura de Entrada - Normal"
						{"DISABLE"	 ,STR0314,{"10","10"}},;   //"Factura de Entrada - Cancelada"
						{"ENABLE"	 ,STR0313,{"55","55"}},;	//"Factura de Entrada - Normal"
						{"DISABLE"	 ,STR0314,{"55","55"}},; 	//"Factura de Entrada - Cancelada"
						{"ENABLE"	 ,STR0313,{"08","08"}},;	//"Nota de Crédito (NCI) - Normal"
						{"DISABLE"	 ,STR0314,{"08","08"}}} 	//"Nota de Crédito (NCI) - Cancelada"
	EndIf
EndIf*/

If cAlias == "SF1"
	AAdd(aLegenda,	{"BR_LARANJA",STR0163,{"13"}})    		//"Desp.imp./Frete"
	If lIntegracao
		AAdd(aLegenda,	{"BR_PRETO", STR0159,{"10"}} ) 		//"NF import. (classificada)"
		AAdd(aLegenda,	{"BR_VERDE", STR0160,{"10"}} ) 		//"NF import. ( nao classif.)"
	Endif
	AAdd(aLegenda,	{"BR_BRANCO" ,DESCREM+STR0145,{"63"}}) //"Retorno simbolico"
Endif

If SuperGetMV("MV_CONFFIS",.F.,"N") == "S"
	aAdd(aLegenda,{"BR_VIOLETA",STR0350, {"08","09","10","51","53","60"}}) //"Docto. em processo de conferencia"
EndIf
If lFiltra
	For nX:=	1	To Len(aLegenda)
		For nY	:=	1 To Len(aLegenda[nX][3])
			If aLegenda[nX][3][nY] $ aCfgNf[ScFilRot]
				AAdd(aLeg, {aLegenda[nX][1], aLegenda[nX][2]})
				Exit
			Endif
		Next nY
	Next nX
Else
	For nX:=	1	To Len(aLegenda)
		AAdd(aLeg, {aLegenda[nX][1], aLegenda[nX][2]})
	Next
Endif

//³Ponto de entrada para inclusão de nova cor LOCXPE64	 ³

aLeg:=LocxLegCor(2,cAlias,aLeg)

BrwLegenda(cDescGer,STR0017 ,aLeg)
Return .T.
/*/

±±³Fun‡…o    ³NFSetPrv   ³ ±±
±±³Descri‡…o ³ Carrega os valores do array de configuracao em variaveis   ³±±
±±³          ³ necessarias cada vez que muda o aCfgNF.                    ³±±

/*/
Static Function NFSetPRV(aNF)
nNFTipo		:= aNF[SnTipo]
cNFTipo		:= aNF[ScTipoDoc]
cEspecie 	:= aNF[ScEspecie]
lCliente	:= aNF[ScCliFor]=="SA1"
cCadastro	:=	aNF[ScDescri]
Return

/*/

±±³Fun‡…o    ³NfAtuFlds  ³ Autor ³ Guilherme C.Leal     ³ Data ³ 24.05.02 ³±±
±±³Descri‡…o ³ Atualiza variaveis do MATXFIS relativas ao calculo de impos³±±
±±³          ³ tos                                                        ³±±

/*/
Function NfAtuFlds(cCampo)
Local nPosTotal := 0
Local aSX7
Local nX := 0
If aSX7_Total == Nil .OR. (IsInCallStack("FINA096") .AND. LEN(aSX7_Total)> 0 .AND. substr(aSX7_Total[1,1],1,at("_",aSX7_Total[1,1])) <> substr(cCampo,1,at("_",cCampo)))
	aSX7_Total := SetSX7Total()
Endif

aSX7	:=	aClone(aSX7_Total)

For nX:= 1 To Len(aSX7_TOTAL)
	If aSX7_TOTAL[nX][1]==cCampo
		nPosTotal := AScan(aHeader,{|x| AllTrim(x[2]) == aSX7[nX][2] })
		If nPosTotal > 0
			nPosRef := AT('MAFISREF("',Upper(aHeader[nPosTotal][6])) + 10
			cRefCols:=Upper(Substr(aHeader[nPosTotal][6],nPosRef,AT('","MT100",',aHeader[nPosTotal][6])-nPosRef ))
			If MaFisFound(Substr(cRefCols,1,2),n)
		  		If MaFisRet(n,cRefCols)   <> ACols[n][nPosTotal]
			 		MaFisAlt(cRefCols,aCols[n][nPosTotal],n)
					//Executar a validação do total
			  		&("M->"+aHeader[nPosTotal][2])	:=	aCols[n][nPosTotal]
			  		MaFisRef(cRefCols,"MT100",aCols[n][nPosTotal])
			 		ModxAtuObj()
	 			Endif
			ENDIF
		EndIf
	Endif
Next
Return .T.

/*/
±±³Fun‡…o    ³NFFldOk    ³ Autor ³ Guilherme C.Leal     ³ Data ³ 24.05.02 ³±±
±±³Descri‡…o ³ Set Bloco para atualizacao dos campos, apos gatilhos.      ³±±
/*/
Function NFFldOk()
Local lRet := .T.
Local cFieldEdit	:= SubStr(ReadVar(),4,Len(ReadVar()))

If !Inclui
	//Verifica se o usuario tem permissao de alteracao.
	If cFieldEdit $ "D1_COD"
		If IsInCallStack("MATA102N") // Remito de Entrada
			lRet := MaAvalPerm(1,{cCampo,"MT102N",5}) .And. MaAvalPerm(1,{SD1->D1_COD,"MT102N",3})
		ElseIf IsInCallStack("MATA101N") // Factura de Entrada
			lRet := MaAvalPerm(1,{cCampo,"MT101N",5}) .And. MaAvalPerm(1,{SD1->D1_COD,"MT101N",3})
		EndIf
	Else
		If IsInCallStack("MATA102N") // Remito de Entrada
			lRet := MaAvalPerm(1,{SD1->D1_COD,"MT102N",4})
		ElseIf IsInCallStack("MATA101N") // Factura de Entrada
			lRet := MaAvalPerm(1,{SD1->D1_COD,"MT101N",4})
		EndIf
	EndIf
	If !lRet
		Help(,,1,'SEMPERM')
	EndIf
EndIf
If cPaisLoc $ "MEX|PER" .AND. cFieldEdit $ "|D1_TES|D2_TES|"
	lRet := LxTesAdi(N)
EndIf
If lRet
	oGetDados:oBrowse:bEditCol := &("{|| NfAtuFlds('" + ReadVar() + "') }")
EndIf
Return lRet
/*/
±±³Fun‡…o    ³GetDescRem ³ ±±
±±³Descri‡…o ³ Pega a descricao do remito.                                ³±±

/*/
Function GetDescRem(nAbrev)
Local cDescRem	:=	""
Local lLocxDRem := Existblock("LOCXDREM")	// Retorna descricao do Remito
Default nAbrev  := 0

cDescRem	:=	STR0107 //"Remito"
Do Case
	Case cPaisLoc == "CHI"
		cDescRem	:=	STR0109       //Guia de despacho
	Case cPaisLoc $ "PAR|COL|MEX|PER"
		cDescRem	:=	STR0108		  // Remision
	Case cPaisLoc $ "POR|EUA|DOM"
		cDescRem	:=	STR0110      // Conduce
	Case cPaisLoc == "GUA"
		cDescRem	:=	STR0234      //"Nota de Envio"
	Case cPaisLoc == "ANG"
		cDescRem	:=	STR0265      //"Guia de Recep"
	Case cPaisLoc == "VEN"
		cDescRem	:=	STR0287      //"Fatura" ou "Factura"
	//Case cPaisLoc == "PTG"
	//	cDescRem	:=	STR0292      //"Guia"
	Case cPaisLoc == "AUS"
		If nAbrev == 1
			cDescRem:= "Deliv. Note"  //Delivery Note
		Else
			cDescRem:= "Delivery Note"  //Delivery Note
		EndIf
EndCase

If lLocxDRem
	cDescRem :=	ExecBlock("LOCXDREM",.F.,.F.)
EndIf
Return cDescRem

/*/
±±³Fun‡…o    ³ LocxGrvPed   ³ ±±
±±³Descri‡…o ³ Criar um novo pedido em base a uma devolucao               ³±±
/*/
Static Function LocxGrvPed()
Local aHeadC6	:= {}
Local nUsado	:=	0,nACols:=0,nCntFor	:= 0,nI	:= 0
Local aHeadBkp	:=	aClone(aHeader)
Local aColsBkp	:=	aClone(aCols)
Local cCadAux	:=	""
Local aColsC6	:= {}
Local cFilSB1	:= xFilial("SB1")
Local cFilSD1	:= xFilial("SD1")
Local nTamItem	:= TamSX3("C6_ITEM")[1]
Local cSecItem	:= Replicate("0", nTamItem)

dbSelectArea("SX3")
dbSetOrder(1)
dbSeek("SC6",.T.)
While ( !Eof() .AND. (SX3->X3_ARQUIVO == "SC6") )
	If ((X3Uso(SX3->X3_USADO) .AND. ;
		!( Trim(SX3->X3_CAMPO) == "C6_NUM" ) .AND.;
		Trim(SX3->X3_CAMPO) #"C6_QTDEMP"  .AND.;
		Trim(SX3->X3_CAMPO) #"C6_QTDENT") .AND.;
		cNivel >= SX3->X3_NIVEL)
		Aadd(aHeadC6,{ Trim(X3Titulo()),;
		SX3->X3_CAMPO,;
		SX3->X3_PICTURE,;
		SX3->X3_TAMANHO,;
		SX3->X3_DECIMAL,;
		SX3->X3_VALID,;
		SX3->X3_USADO,;
		SX3->X3_TIPO,;
		SX3->X3_ARQUIVO,;
		SX3->X3_CONTEXT } )
	EndIf
	dbSelectArea("SX3")
	dbSkip()
End

ProcRegua(Len(aCols)+2)

SD1->(DbSetOrder(1))
SD1->(DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
While !SD1->(EOF()) .AND. SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA==;
									cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA
	If SF1->F1_TIPODOC == SD1->D1_TIPODOC
		IncProc()
		cSecItem := Soma1(cSecItem, nTamItem)
		nUsado := Len(aHeadC6)
		aadd(aColsC6,Array(nUsado+1))
		nAcols := Len(aColsC6)
		aColsC6[nAcols,nUsado+1] := .F.
		For nCntFor := 1 To nUsado
			Do Case
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_ITEM"   )
					aColsC6[nAcols,nCntFor] := cSecItem
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_QTDVEN"  )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_QUANT
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_PRCVEN"  )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_VUNIT
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_OP"      )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_OP
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_PRODUTO" )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_COD
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_UM"      )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_UM
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_SEGUM"   )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_SEGUM
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_UNSVEN"  )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_QTSEGUM
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_VALOR"   )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_QUANT  *  SD1->D1_VUNIT
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_LOCAL"   )
					aColsC6[nAcols,nCntFor] :=   SD1->D1_LOCAL
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_TES"   )
					aColsC6[nAcols,nCntFor] :=   Posicione('SB1',1,cFilSB1+SD1->D1_COD,'B1_TS')
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_CF"   )
					aColsC6[nAcols,nCntFor] :=   Posicione('SF4',1,cFilSB1+Posicione('SB1',1,xFilial('SB1')+SD1->D1_COD,'B1_TS'),'F4_CF')
				Case ( Alltrim(aHeadC6[nCntFor,2]) == "C6_DESCRI"   )
					aColsC6[nAcols,nCntFor] := Posicione('SB1',1,cFilSB1+SD1->D1_COD,'B1_DESC')
				OtherWise
					aColsC6[nAcols,nCntFor] :=   Criavar(Alltrim(aHeadC6[nCntFor,2]))
			Endcase
		Next nCntFor
	Endif
	SD1->(DbSkip()	)
End
IncProc(STR0126)	//'Inicializando dados do cabecalho'
RegToMemory("SC5",.F.)
SA1->(DbSetOrder(1))
SA1->(MsSeek(xFilial("SA1")+SF1->F1_FORNECE+SF1->F1_LOJA))
DbSelectArea("SC5")
M->C5_NUM      :=  Criavar('C5_NUM',.T.)
M->C5_TIPOCLI  :=  SA1->A1_TIPO
M->C5_TABELA   :=  SA1->A1_TABELA
M->C5_MOEDA    :=  SF1->F1_MOEDA
M->C5_CLIENTE  :=  SA1->A1_COD
M->C5_LOJACLI  :=  SA1->A1_LOJA
M->C5_CLIENT   :=  SA1->A1_COD
M->C5_LOJAENT  :=  SA1->A1_LOJA
M->C5_TIPOREM  :=  '0'
M->C5_DOCGER   :=  '1'
M->C5_CONDPAG  :=  IIf(!Empty(SA1->A1_COND),SA1->A1_COND,M->C5_CONDPAG)
M->C5_EMISSAO  :=  dDatabase
M->C5_TIPO     :=  "N"
aCols    := aColsC6
aHeader  := aHeadC6
aColsC6  := {}
CurLen   := 70 - Len(aHeader)
nPosAtu  := 0
nPosAnt  := 9999
nColAnt  := 9999
Pergunte("MTA410",.F.)
dbSelectArea("SC5")
ALTERA := .F.
INCLUI := .T.
IncProc(STR0127)	//'Generando Pedido'
cCadAux  := cCadastro
cCadastro := OemToAnsi(STR0128) + DESCREM
If Type("aCfgNf[15]") == "A"
	For nI := 1 To Len(aCfgNf[15])
		SetKey(aCfgNf[15,nI,1],{||})
	Next nI
Endif
If a410Inclui(Alias(),Recno(),3,.T.) == 1
	Reclock('SF1',.F.)
	Replace F1_PEDVEND	With	SC5->C5_NUM
	MsUnLock()

	If ExistBlock('LOCXGRPV')
    	Execblock('LOCXGRPV',.F.,.F.,SC5->C5_NUM)
	EndIf
Endif
If Type("aCfgNf[15]") == "A"
	For nI := 1 To Len(aCfgNf[15])
		SetKey(aCfgNf[15,nI,1],aCfgNf[15,nI,2])
	Next nI
Endif
cCadastro:= cCadAux
aCols    := aClone(aColsBkp)
aHeader  := aClone(aHeadBkp)
Return

/*
±±ºPrograma  ³NFSetImps º±±
±±ºDesc.     ³Carrega os valores dos impostos na tela quando for visuali- º±±
±±º          ³zacao.                                                      º±±
*/
Function NfSetImps(cAliasI)
Local aArea		:=	GetArea()
Local aAreaSD1	:=	SD1->(GetArea())
Local aAuxRef ,nX,nY
Local lCarTudo	:=	!(cAliasI=="SD2" .AND. GetNewPar('MV_DESCSAI','1') =='2')
Local cDescSai	:= GetNewPar('MV_DESCSAI','1')
aAuxRef	:=	MaFisRelimp(Nil,{cAliasI})

//³ Inicializa a funcao fiscal  ³
For nY:=1	To Len(aRecnos)
	(cAliasI)->(MsGoTo(aRecnos[nY]))
	MaFisIniLoad(nY)
	For nX := 1 To Len(aAuxRef)
		If cPaisLoc $ "ARG|PER|MEX|VEN|PAR|" .And. cDescSai == '2'
			If cPaisLoc $ "PAR" .And. cAliasI == "SD2".And. aAuxRef[nX][3] == "IT_VALMERC" .And. (cAliasI)->D2_DESCON > 0
				MaFisLoad(aAuxRef[nX][3],(cAliasI)->(FieldGet(FieldPos(aAuxRef[nX][2]))) + (cAliasI)->D2_DESCON,nY)
			Else
				MaFisLoad(aAuxRef[nX][3],(cAliasI)->(FieldGet(FieldPos(aAuxRef[nX][2]))),nY)
			Endif
		ElseIf lCarTudo .OR. !(aAuxRef[nX][3] $ "IT_VALMERC|IT_PRCUNI")
			MaFisLoad(aAuxRef[nX][3],(cAliasI)->(FieldGet(FieldPos(aAuxRef[nX][2]))),nY)
		EndIf
	Next nX
	MaFisEndLoad(nY,2)
Next nY

RestArea(aAreaSD1)
RestArea(aArea)
Return
/*
±±ºPrograma  ³LOCXTrava º±±
±±ºDesc.     ³ Tratamento de LOCK - Arquivo SB2                           º±±
*/
Static Function LocxTrava(aCPitens,aCItens)
Local nI     := 0
Local aTrava := {}
Local nPosPrd:= 0
Local nPosLoc:= 0
Local lTrava := .T.
Local cCliFor:= ""
Local cLoja  := ""
If !InTransact()
	If aCfgNF[SAliasHead]=="SF2"
		cCliFor	:=	M->F2_CLIENTE
		cLoja	:=	M->F2_LOJA
	Else
		cCliFor	:=	M->F1_FORNECE
		cLoja	:=	M->F1_LOJA
	Endif
	nPosPrd:=aScan(aCPItens,{|x| AllTrim(x) == "D1_COD" 	.OR.	AllTrim(x) == "D2_COD"  })
	nPosLoc:=aScan(aCPItens,{|x| AllTrim(x) == "D1_LOCAL"	.OR. 	AllTrim(x) == "D2_LOCAL"})
	For nI := 1 to Len(aCols)
		IF ( Len(aCItens[nI]) > Len(aCPItens) ) .AND. !(aCItens[ni][Len(aCItens[ni])])
			AADD(aTrava,aCItens[nI,nPosPrd]+aCItens[nI,nPosLoc])
		EndIf
	Next
	lTrava := MultLock("SB2",aTrava,1) .AND.	MultLock(aCfgNF[ScCliFor],{cCliFor+cLoja},1)
	If ( !lTrava )
		SB2->(MsUnLock())
		SA1->(MsUnLock())
		SA2->(MsUnLock())
	EndIf
Endif
Return(lTrava)

/*/
±±³Fun‡…o    ³ NFVldCxa  ³ ±±
±±³Descri‡…o ³ Valida o OK dos dados de integracao com caixinha.          ³±±
/*/
Static Function NFVldCxa(nOpca,cBenef,nValor,cCaixa,cAdia,cHistor,cNrRend)
Local lRet			:= .T.
Local lAdia			:= .F.
Local nRecAdia		:= 0
Local cArquivo		:= ""
Local aSEUReg		:= {}
Local aFlagCTB		:= {}
Local nTotal		:= 0
Local lUsaFlag		:= SuperGetMV("MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local lPad579		:= VerPadrao("579")
//Local lPad572		:= VerPadrao("572")
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local aTmpSEU       := {}
Local aAreaSEU        := {}
Local cNumAnt       := ""
Local aCtbDia := {}
Local nRecSEU		:= 0
Local cFunName		:= FunName()
//Local aDiario		:= {}

Private nHdlPrv   	:= 0	//Guarda a evolucao da funcao HeadProva
Private cLote		:= ""  	//Lote utilizado nas rotinas contabeis

Default cAdia		:=	""
Default cNrRend	:=	""

If Empty(cBenef).OR.Empty(nValor).OR.Empty(cCaixa)
   Help("  ",1, "Obrigat" )
   Return .F.
Else
	If !Empty(cAdia)
		If  cPaisLoc == "BOL" .And. ALLTRIM(cEspecie) == "NF" .And. ALLTRIM(cFunName) == "MATA101N"
			lRet := LxNfCxaBol(cAdia, cCxRendic, cCaixa, @nRecAdia, nValor, @lAdia)
		Else
			dbSelectArea("SEU")
			SEU->(dbSetOrder(6))
			If SEU->(dbSeek(xFilial("SEU") + cCaixa + "01" + IIF(!EMPTY(cAdia),cAdia,Space(Len(EU_NROADIA)))))
				If (nValor <= SEU->EU_SLDADIA)
					RecLock("SEU",.F.)
					Replace EU_SLDADIA	With EU_SLDADIA - nValor

					//³ Se sobrou saldo no registro de adiantamento,                ³
					//³ pergunta-se se deseja REPASSAR O REMANESCENTE para o saldo  ³
					//³ do caixinha e com isso o adiantamento ficara com saldo zero,³
					//³ o que permitira que o mesmo seja baixado/rendido.           ³

					If EU_SLDADIA > 0
						lAdia		:=	.T.
						nRecAdia	:=	RECNO()
					Else
						Replace EU_BAIXA With dDataBase
					Endif
					MsUnlock()

					IIf(cPaisLoc == "ARG", cNumAnt := SEU->EU_NUM, Nil)

					If cPaisLoc == "ARG" .And. !Empty(cNumAnt) .And. SEU->EU_SLDADIA <= 0
						aAreaSEU := SEU->(GetArea())
						SEU->(dbSetOrder(3))
						If SEU->(dbSeek(xFilial()+cNumAnt))
							While SEU->(!Eof()) .And. SEU->(EU_FILIAL+EU_NROADIA) == (xFilial("SEU")+cNumAnt)
								RecLock("SEU", .F.)
								SEU->EU_BAIXA := dDataBase
								SEU->(MsUnlock())
								SEU->(dbSkip())
							Enddo
						Endif
						SEU->(RestArea(aAreaSEU))
					EndIF

				Else
					Help(" ",1,"FA560SALDO")
					lRet	:=	.F.
				Endif
			Else
				Help(" ",1,"FA560NE") // Adiantamento informado nao encontrado
				lRet	:=	.F.
			Endif
		Endif
	Else
		SET->(dbSetOrder(1))
		If SET->(MsSeek(xFilial("SET")+cCaixa)) .AND. SET->ET_SALDO >= nValor
			Reclock("SET",.F.)
			If cPaisLoc == "ARG"
				Replace ET_SALANT With SET->ET_SALDO
			EndIf
			Replace ET_SALDO	With ET_SALDO - xMoeda(nValor,nMoedaNF,1,dDataBase,,nTaxa)
			MsUnLock()
		Else
			Help(" ",1,"FA560SALDO")
			lRet	:=	.F.
    	Endif
	Endif
	If lRet
		SA2->(DbSetOrder(1))
		SA2->(MsSeek(xFilial("SA2")+M->(F1_FORNECE+F1_LOJA)))

		//³ Insere ou altera comprovantes do adiantamento   ³

		RecLock("SEU",.T.)
		Replace EU_FILIAL  	With 	xFilial()
		Replace EU_NUM     	With 	GetSXENum("SEU","EU_NUM")
		Replace EU_CAIXA   	With 	SET->ET_CODIGO
		Replace EU_VALOR   	With 	nValor
		Replace EU_BENEF   	With 	cBenef
		Replace EU_HISTOR  	With 	cHistor
		Replace EU_DTDIGIT 	With 	dDataBase
		Replace EU_EMISSAO 	With    M->F1_EMISSAO
		Replace EU_TIPO    	With 	"00"         	// Reembolso
		Replace EU_NROADIA 	With 	cAdia     		// informa a que adiant. se refere
		Replace EU_SEQCXA  	With 	SET->ET_SEQCXA
		Replace	EU_FORNECE	With	M->F1_FORNECE
		Replace	EU_NOME     With    SA2->A2_NOME
		Replace	EU_LOJA		With	M->F1_LOJA
		Replace	EU_NRCOMP	With	M->F1_DOC
		Replace	EU_CGC		With	SA2->A2_CGC
		Replace	EU_MOEDA	With	M->F1_MOEDA
		Replace	EU_VLMOED2	With	M->F1_TXMOEDA
		nRecSEU := SEU->(Recno())
		If cPaisLoc == "MEX" .OR. cPaisLoc == "COL"
			Replace EU_BAIXA With dDataBase
		Endif
		If cPaisLoc == "CHI"
			Replace EU_TIPDEB	With "_NF_"
		Endif
		If cPaisLoc == "ARG" .And. !Empty(cAdia)
			Replace	EU_STATUS	With "03"
		EndIf
		If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
			SerieNfId("SEU",1,"EU_SERCOMP",M->F1_EMISSAO,M->F1_ESPECIE,M->F1_SERIE)//Projeto Chave Unica - Tiago Silva
		Endif
		If cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
			Replace EU_NRREND	With	cNrRend
		Endif

		If __lSX8
			ConfirmSX8()
		EndIf

		If cPaisLoc == "CHI"
			BaixaCxChi(cAdia, lAdia)
		Endif
		If  cPaisLoc == "BOL"
			BaixaCxBol(cAdia)
		EndIf
		If cPaisLoc == "ARG"
			If !Empty(cAdia)
				aTmpSEU := SEU->(GetArea())
				SEU->(DbSetOrder(6))
				If SEU->(DbSeek(xFilial("SEU")+SET->ET_CODIGO+"00"+cAdia))
					While (SEU->(!Eof())) .And. (xFilial("SEU")+SET->ET_CODIGO+"00"+cAdia)== SEU->EU_FILIAL+SEU->EU_CAIXA+"00"+SEU->EU_NROADIA
						RecLock("SEU",.F.)
						Replace	EU_BAIXA With dDataBase
						MsUnlock()
						SEU->(DbSkip())
					Enddo
				Endif
				Restarea(aTmpSEU)
			Endif
		Endif
		nOpca := 1
		lRet	:=	.T.
	Endif
Endif
If lAdia .AND. (MsgYesNo(OemToAnsi(STR0131),OemToAnsi(STR0132))) //"¨Deseja transferir o saldo remanescente para o caixinha?"###"adiant. com saldo remanescente"
	SEU->(MsGoTo(nRecAdia))

	//³ Atualiza informacoes do registro de adiantamento            ³

	If cPaisLoc == "CHI"
		Fa560FcAdi(SEU->(Recno()),SEU->(EU_SLDADIA),,,,M->F1_FORNECE,M->F1_LOJA,M->F1_DOC,iif(lUsaNewKey,SerieNfId("SF1",4,"F1_SERIE",M->F1_EMISSAO,M->F1_ESPECIE,M->F1_SERIE),M->F1_SERIE)) //Projeto Chave Unica - Tiago Silva
	Else
		Fa560FcAdi(SEU->(Recno()),SEU->(EU_SLDADIA))
	Endif

	// Contabilizacao do movim. de caixinha gerado pela transf. do saldo remanescente
	If lPad579 .AND. mv_par02 == 1 .AND. SEU->(Recno()) # nRecAdia
		If lUsaFlag
			aAdd(aFlagCTB, {"EU_LA", "S", "SEU", SEU->(Recno()), 0, 0, 0})
		Endif
		If Empty(nHdlPrv) .OR. nHdlPrv <= 0
			nHdlPrv := HeadProva(cLote,FunName(),Subs(cUsuario,7,6),@cArquivo)
		Endif
		If  nHdlPrv > 0 .And. Empty(SEU->EU_LA)
			nTotal	+=	DetProva(nHdlPrv,"579",FunName(),cLote)
			AAdd(aSEUReg,SEU->(Recno()))
		Endif
		RodaProva(nHdlPrv,nTotal)

		If nTotal > 0
			If UsaSeqCor()
		 		aCtbDia := {{"SEU",SEU->(Recno()),SEU->EU_DIACTB,"EU_NODIA","EU_DIACTB"}}
			Else
				aCtbDia := {}
			EndIF
			If cA100Incl(	cArquivo                                     , nHdlPrv           , 3                 ,  cLote        ,;
							IIf(mv_par03 # 1, .F., .T.) /*Visualiza*/    , .F./*Aglutina*/   ,/*cOnLine*/        ,  /*dData*/    ,;
							/*dReproc*/                                  , @aFlagCTB         ,/*aDadosProva*/    , aCtbDia        )
					If !lUsaflag
						Reclock("SEU",.F.)
						SEU->EU_LA := "S"
						 MsUnLock()
					Endif
			Endif
		Endif
		aFlagCTB := {}
	Endif
Endif

If lRet .And. cPaisLoc == "PER"
	xVldCxaPer(lUsaFlag, nRecSEU, cUsuario, cFunName, (mv_par02 == 1), (mv_par03 == 1))
EndIf

Return lRet

Function LockSCM(nReg)
Local lMarca 	:= .F.
Local aAreaSD1	:= getArea()

SD1->(MsGoto(nReg))

If SD1->D1_QTDACLA > 0
	lMarca := .T.
Else
	Help(" ",1,"QUANTIMP")
EndIf

RestArea(aAreaSD1)
Return lMarca

/*

±±ºPrograma  ³SaldoOk   ºAutor  ³Bruno Sobieski      ºFecha ³  07/15/02   º±±
±±ºDesc.     ³Verifica se o saldo disponivel eh suficiente.               º±±
±±³Retorno   ³ExpL1: .T. se a qtde solicitada esta disponivel    		  ³±±
±±³          ³       .F. se a qtde solicitada NAO esta disponivel   	  ³±±
±±³Parametros³ExpC1: Codigo do Produto         - Obrigatorio              ³±±
±±³          ³ExpC2: Local                     - Obrigatorio              ³±±
±±³          ³ExpN3: Qtde                - Obrigatorio             		  ³±±
±±³          ³ExpC4: Lote de Controle          - Obrig. se Inf. Sub-Lote  ³±±
±±³          ³ExpC5: Sub-Lote                                             ³±±
±±³          ³ExpC6: Localizacao               - Obrig. se inf. Nr.Serie  ³±±
±±³          ³ExpC7: Numero de Serie                                      ³±±
±±³          ³ExpL8: Indica se considera saldo empenhado/reservado        ³±±
*/
Static Function SaldoOk(cCod,cLocal,nQuant,cLoteCtl,cNumLote,cLocaliz,cNumSer,lBaixaEmp, cPedido, cItemPV, cSequen, lSaldo, lTesPeRemi)
Local lRet	:=	.T.
Local aArea	:=	GetArea()

DEFAULT cPedido := ""
DEFAULT cItemPV := ""
DEFAULT cSequen := ""
DEFAULT lSaldo := Nil
DEFAULT lTesPeRemi := .F.

If GetMV("MV_ESTNEG") != "S" .AND. (!SB2->(MsSeek(xFilial("SB2")+cCod+cLocal)) .OR.SaldoSB2(,.F.) <  (nQuant  - Iif(lBaixaEmp,SB2->B2_RESERVA,0)))
	//O segundo parametro da funcao SaldoSB2 so trata empenhos, e nao reservas, por isto e que
	//o campo B2_RESERVA eh consultado aqui
	lRet	:=	.F.
Endif
If lBaixaEmp == .T.
	lSaldo  := .T.
EndIf
If lRet .AND. Rastro(cCod) .AND. SaldoLote(cCod,cLocal,cLoteCtl,cNumLote,lBaixaEmp,,,,,lSaldo) <  nQuant
	lRet	:=	.F.
Endif

If !Empty(cPedido+cItemPV+cSequen)
	dbSelectArea("SDC")
	dbSetOrder(1)
	MsSeek(xFilial("SDC")+cCod+cLocal+"SC6"+cPedido+cItemPV+cSequen)
	If Found() .And. QtdComp(nQuant) == QtdComp(1)
		cLocaliz := SDC->DC_LOCALIZ
		cNumSer  := SDC->DC_NUMSERI
	EndIf
EndIf

If lRet	.AND. Localiza(cCod) .AND. SaldoSBF(cLocal,cLocaliz,cCod,cNumSer,cLoteCtl,cNumLote,Iif(lTesPeRemi,.F.,lBaixaEmp)) <  nQuant
	lRet := .F.
Endif

RestArea(aArea)
Return  lRet

/*/
±±³Fun‡…o    ³LocxNfDesp ³ ±±
±±³Descri‡…o ³ Monta uma tela com as nota fiscais originais.              ³±±
±±³Uso       ³ LOCXNF	                                                  ³±±
/*/
Function LocxNFDesp(nTipNota)
Local aRecs		:= {}
Local aRet		:= {}
Local aAreaSA2	:= SA2->(GetArea())
Local aAreaSD1	:= SD1->(GetArea())
Local aAreaSF1	:= SF1->(GetArea())
Local nX := 0//,nI,nY
Local cWhile	:= ""
Local cCondicao := ""
//Local cQuery    := ""
Local aCposF4	:= {}
Local cPerg		:=	Iif(nTipNota == 1,'MT116A','MT119A')
//Local aCTemp	:= {}
Local aIndRem	:= {}
Local bFilRem	:=	{|| }
Local cFilRem	:= ""
Local cTitOrig	:= ""
Local cCondPE	:= ""
Local cPE		:= ""
Local lFltD1D2	:= GetMv('MV_FLTD1D2')
Local lLeRemito := SuperGetMv("MV_RMFREF1",.F.,"0") == "1"	// '1' = Enxerga Remitos para vincular na NF Conhec.Frete
Local lFilRemito:= .F.
Local nPosTesG	:= 2
//Local nTamSx1Grp:= Len(SX1->X1_GRUPO)
Local cFilSF4		:= xFilial("SF4")

Private oProcess

//³Verifica se os campos de cabeçalho obrigatorios  ³
//³para o calculo de impostos  estão preenchidos.   ³

SX3->(DBSetOrder(2))
If Empty(M->F1_FORNECE).OR.Empty(M->F1_LOJA).OR. Empty(M->F1_DOC).OR. Iif(cPaisLoc=="ARG",Empty(M->F1_SERIE),.F.)
	Aviso(STR0038,STR0075,{STR0021})				 //"ATENCAO!"###"Preencha o campo de cabecalho : "###"OK"
	Return .F.
EndIf


//³   01 -  Valor da nota        mv_par01            ³
//³   02 -  Fornec./Cliente      mv_par02            ³
//³   03 -  Loja                 mv_par03            ³
//³   04 -  TES                  mv_par04            ³
//³   05 -  Data Inicial         mv_par05            ³
//³   06 -  Data Final           mv_par06            ³
//³   07 -  Aglutina produtos    mv_par07 Sim x Nao  ³

If !Pergunte(cPerg,.T.)
	Return
Endif

RestArea(aAreaSA2)

AFN->(dbSetOrder(2))
/**/
If mv_par01==0   //total igual a zero, abre tela para digitacao das despesas
	If !LocxGastos()
		Return
	Endif
Else
	aCGastos:={{mv_par01,mv_par04,.F.}}
Endif
SF4->(DbSetOrder(1))
For nX:=1 To Len(aCGastos)
	If SF4->(MsSeek(cFilSF4+aCGastos[nX][nPosTesG]))
		If SF4->F4_ESTOQUE <> "S"
		   Aviso(STR0018,RetTitle("D1_TES")+" "+AcGastos[nX][nPosTesG]+" - "+STR0165, {"OK"},2)
		Endif
	Else
		aCGastos[nX][nPosTesG]:="   "
	Endif
Next

SX3->(DbSetOrder(1))
SX3->(DbSeek("SF1"))
While !SX3->(EOF()) .AND. SX3->X3_ARQUIVO == "SF1"
	If SX3->X3_BROWSE == "S" .AND. cNivel >= SX3->X3_NIVEL
		AAdd(aCposF4,SX3->X3_CAMPO)
	Endif
	SX3->(DbSkip())
End

cCondicao 	+= "DTOS(F1_DTDIGIT)>='"+DTOS(mv_par05)+"'.AND."
cCondicao 	+=	"DTOS(F1_DTDIGIT)<='"+DTOS(mv_par06)+"'.AND."
cCondicao	+= "F1_TIPO=='N'"
cSeek		:=	"xFilial('SF1')"
cWhile 		:=	"!EOF() .AND. F1_FILIAL== '" + xFilial("SF1")+"'"

//³Ponto de Entrada p/ alterar o filtro ³

cPe	:=	LocxPE(56)
If !Empty(cPe)
	cCondPE := Execblock(cPE,.F.,.F.,{cCondicao})
	If ValType(cCondPE) == "C"
		cCondicao:= cCondPE
	EndIf
EndIf
If !Empty(mv_par02).AND.!Empty(mv_par03)
	cWhile	+= " .AND. F1_FORNECE=='"+mv_par02+"'.AND.F1_LOJA=='"+mv_par03+"'"
	cSeek		+= "+'"+mv_par02+"'+'"+mv_par03+"'"
EndIf

// Notas de Frete: Novo filtro p/ enxergar tb remitos p/ vinculos, desligando temporariamente o filtro atual da mBrowse.
If lFltD1D2 .And. lLeRemito .And. nTipNota == 1
	EndFilBrw(aCfgNF[SAliasHead],aIndD1D2)
    cFilRem := PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC $ '60/" + aCfgNF[ScFilRot] + "'"
	bFilRem	:=	{|| FilBrowse(aCfgNF[SAliasHead],@aIndRem,@cFilRem)}
	Eval( bFilRem )
	lFilRemito := .T.
	cTitOrig :=STR0261	//"Facturas/Remitos Originales"
Else
	 // Notas de Frete/Gastos: Novo filtro p/ nao enxergar os remitos se parametro MV_RMFREF1 = 0, desligando temporariament
	 // e o filtro atual da mBrowse.
	If lFltD1D2 .And. !lLeRemito
		EndFilBrw(aCfgNF[SAliasHead],aIndD1D2)
	    cFilRem := PrefixoCpo(aCfgNF[SAliasHead]) + "_TIPODOC $ '" + aCfgNF[ScFilRot] + "'"
		bFilRem	:=	{|| FilBrowse(aCfgNF[SAliasHead],@aIndRem,@cFilRem)}
		Eval( bFilRem )
		lFilRemito := .T.
	EndIf

	cTitOrig :=STR0123	//"Facturas Originales"
EndIf
If cPaisLoc == "RUS"
	aRet 	:= LocxF4("SF1",2,cWhile,cSeek,aCposF4,,cTitOrig,cCondicao,.T.,,,,,,,,.T.)  // Retorna os Recnos das linhas selecionadas
Else
	aRet 	:= LocxF4("SF1",2,cWhile,cSeek,aCposF4,,cTitOrig,cCondicao,.T.)  // Retorna os Recnos das linhas selecionadas
Endif

// Volta filtro original da FilBrowse
If lFilRemito
	EndFilBrw(aCfgNF[SAliasHead],aIndRem)
	Eval( bFilBrw )
EndIf

If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf

If ValType(aRecs)=="A" .AND. ValType(aRecs)=="A" .AND. Len(aRecs) > 0
	oProcess:=	MsNewProcess():New({|lEnd| CarregaDesp(nTipNota,aRecs,oProcess,aCGastos,@lEnd)},STR0239,,.T.)//"Carregando as notas selecionadas..."
	oProcess:Activate()
Endif

AtuLoadQt()
RestArea(aAreaSF1)
RestArea(aAreaSD1)
Return

/*
±±ºPrograma  ³CarregaDespºº±±
±±ºDesc.     ³Rotina para ser utilizada pela processa na carga de items   º±±
±±º          ³ nas notas de despesas e de frete                           º±±
*/
Static Function CarregaDesp(nTipNota,aRecs,oProcess,aCGastos,lEnd)
Local nPItem    :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_ITEM'})
Local nPProduto :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_COD'})
Local nPLocal	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_LOCAL'})
Local nPTes     :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_TES'})
Local nPCF	    :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_CF'})
Local nPNumCQ 	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_NUMCQ'})
Local nPSegum 	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_SEGUM'})
Local nPConta 	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_CONTA'})
Local nPItemCta :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_ITEMCTA'})
Local nPCCusto  :=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_CC'})
Local nPPeso	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_PESO'})
Local nPUM    	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_UM'})
Local nPTotal	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_TOTAL'})
Local nPVlUnit	:=	Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_VUNIT'})
Local nNFOri	:= Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_NFORI'})
Local nITOri	:= Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_ITEMORI'})
Local nSerOri	:= Ascan(aHeader,{|x| Alltrim(x[2]) == 'D1_SERIORI'})
Local nPesoTotal:= 0
Local nVlrTotal	:= 0
Local nLenAcols	:= 0
Local nLin		:= 0
Local nW		:= 0
Local nI        := 0,nX,nY,nSF1
Local lDel		:= .F.
Local cRatDesp	:= SuperGetMV("MV_RATDESP")
Local nRatDesp  := Val(SubStr(cRatDesp,At("DESP=",cRatDesp)+5,1))
Local nRatFrete	:= Val(SubStr(cRatDesp,At("FR=",cRatDesp)+3,1))
//Local nRatSeg  	:= Val(SubStr(cRatDesp,At("SEG=",cRatDesp)+4,1))
Local cItem		:=	StrZero(0,TamSX3('D1_ITEM')[1])
Local nDifTotal	:=	0
Local nDecs		:=	MsDecimais(MAFISRET(,'NF_MOEDA'))
Local cAliasSD1	:=	"SD1"
Local nUsado	:=	Len(aHeader)
Local lQuery 	:= .F.
Local lAviso 	:= .T.
Local aSavaCols	:=	{}
Local aStruSD1	:=	{}
Local cFilSF4		:= xFilial("SF4")
Local cFilAFN		:= xFilial("AFN")
Local cFilSD1		:= xFilial("SD1")
//-- Verifica se utiliza custo fifo on-line
Local lFifoOnLine:= IsFifoOnLine()

Local cQuery	:=	""
Local cQueryPE	:=	""
lQuery	:=	TcSrvType()<>"AS/400"

oProcess:SetRegua1(2)
oProcess:IncRegua1(STR0240)
oProcess:SetRegua2(Len(aRecs))

aSavaCols	:=	aClone(aCols)

aCols	:=	{}
aAmarrAFN := {}
For nSF1:=1 To Len(aRecs)

	//³ Verifica os itens da nota de origem  ³

	SF1->(MsGoto(aRecs[nSF1]))
	oProcess:IncRegua2(STR0241+subStr(SF1->F1_SERIE,1,3)+"/"+SF1->F1_DOC)//"Lendo NF "  /Tiago Silva Projeto Chave Unica
	dbSelectArea("SD1")
	dbSetOrder(1)
	If Empty(aStruSD1)
		aStruSD1 := SD1->(dbStruct())
	EndIf
	If lQuery .And. aScan(aStruSD1,{|x| x[2]=="M"})==0
		cAliasSD1 := "SD1"
		cQuery := "SELECT * "
		cQuery += "FROM "+RetSqlName("SD1")+" SD1 "
		cQuery += "WHERE "
		cQuery += "SD1.D1_FILIAL='"+cFilSD1+"' AND "
		cQuery += "SD1.D1_DOC='"+SF1->F1_DOC+"' AND "
		cQuery += "SD1.D1_SERIE='"+SF1->F1_SERIE+"' AND "
		cQuery += "SD1.D1_FORNECE='"+SF1->F1_FORNECE+"' AND "
		cQuery += "SD1.D1_LOJA='"+SF1->F1_LOJA+"' AND "
		cQuery += "SD1.D1_FORMUL='"+SF1->F1_FORMUL+"' AND "
		cQuery += "SD1.D_E_L_E_T_=' ' "


		//³ PE para manipulacao da Query, permite filtragem dos itens da factura original selecionada  ³

		cPe	:=	LocxPE(51)
		If !Empty(cPe)
			cQueryPE := Execblock(cPe, .F., .F., {cQuery,nTipNota})
			cQuery   := If(ValType(cQueryPE)=='C', cQueryPE, cQuery)
		EndIf

		cQuery += " ORDER BY "+SqlOrder(SD1->(IndexKey()))
		cQuery := ChangeQuery(cQuery)

		dbSelectArea("SD1")
		dbCloseArea()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD1,.T.,.T.)
		For nX := 1 To Len(aStruSD1)
			If aStruSD1[nX][2] <> "C"
				TcSetField(cAliasSD1,aStruSD1[nX][1],aStruSD1[nX][2],aStruSD1[nX][3],aStruSD1[nX][4])
			EndIf
		Next nX
	Else
		MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
	EndIf
	While !lEnd .And. !Eof() .And. (cAliasSD1)->D1_FILIAL==cFilSD1 .And.;
			(cAliasSD1)->D1_DOC 		== SF1->F1_DOC 		.And.;
			(cAliasSD1)->D1_SERIE 	== SF1->F1_SERIE 		.And.;
			(cAliasSD1)->D1_FORNECE	== SF1->F1_FORNECE 	.And.;
			(cAliasSD1)->D1_LOJA 	== SF1->F1_LOJA

		If SF1->F1_FORMUL==(cAliasSD1)->D1_FORMUL

			If (cAliasSD1)->D1_ORIGLAN $"FD|F | D" .And. lAviso
				Aviso("",STR0246,{"OK"},2)
	  			lAviso := .F.
	        EndIf

			//³ Verifica se deve aglutinar os itens da NF de entrada ³

			If mv_par07 <> 1 .Or. lFifoOnLine
				nX := 0
			Else
				nX	:= aScan(aCols, { |x| x[nPProduto] == (cAliasSD1)->D1_COD .And.;
					x[nPLocal] == (cAliasSD1)->D1_LOCAL .And.;
					x[nPNumCQ] == (cAliasSD1)->D1_NUMCQ })
			EndIf
			If nX == 0

				//³ Faz a montagem de uma linha em branco no aCols ³

				Aadd(aCols,	Array(nUsado+1))
				Aadd(aAmarrAFN,{})
				nX	:= Len(aCols)
				For nY := 1 to Len(aHeader)
					aCols[nX][nY] := CriaVar(aHeader[nY][2])
				Next nY
				aCols[nX][nUsado+1] := .F.
				If nPItem > 0
					cItem	:=	Soma1(cItem)
					If nPItem 	<> 0	;	aCols[nX,nPItem]  := cItem	;	EndIf
				Endif
			EndIf

			//³ Preenche os campos com base nas notas originais  ³

			aCols[nX,nPProduto] := (cAliasSD1)->D1_COD
			aCols[nX,nPLocal]   := (cAliasSD1)->D1_LOCAL
			aCols[nX,nPTes]    	:= MV_PAR04
			If nPNumCQ 	 <> 0	;	aCols[nX,nPNumCQ]  	:= (cAliasSD1)->D1_NUMCQ	;	EndIf
			If nPSegum 	 <> 0	;	aCols[nX,nPSegum]  	:= (cAliasSD1)->D1_SEGUM	; 	EndIf
			If nPConta 	 >  0	;	aCols[nX,nPConta]	:= (cAliasSD1)->D1_CONTA	; 	Endif
			If nPItemCta >  0 	; 	aCols[nX,nPItemCta]	:= (cAliasSD1)->D1_ITEMCTA	; 	Endif
			If nPCCusto  >  0 	; 	aCols[nX,nPCCusto] 	:= (cAliasSD1)->D1_CC 		; 	Endif
				If nPCF		 >  0 	; 	aCols[nX,nPCF] 		:= Posicione("SF4",1,cFilSF4+MV_PAR04,"F4_CF")		; 	Endif
			If nPPeso	 <> 0	;	aCols[nX,nPPeso]  	+= (cAliasSD1)->D1_PESO		; 	EndIf

			If nNFOri  <>	0
				aCols[nX,nNFOri]  	:= (cAliasSD1)->D1_DOC
			EndIf
			If nITOri  <>	0
			   aCols[nX,nITOri]  	:= (cAliasSD1)->D1_ITEM
			EndIf
			If nSerOri <>	0
			   aCols[nX,nSerOri]  	:= (cAliasSD1)->D1_SERIE
			EndIf

			aCols[nX,nPUM]    := (cAliasSD1)->D1_UM
			aCols[nX,nPTotal] += xMoeda((cAliasSD1)->D1_TOTAL,SF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),dDataBase,,SF1->F1_TXMOEDA,MAFISRET(,'NF_TXMOEDA'))


			//³Ponto de entrada p/ atualizar item a item do aCols da factura original selecionada  |

	  		cPe	:=	LocxPE(44)
			If !Empty(cPe)
				ExecBlock(cPe,.F.,.F.,{nX})
			EndIf

			//³ Atualiza os acumuladores do rateio  ³

			nPesoTotal += (cAliasSD1)->D1_PESO
			nVlrTotal  += xMoeda((cAliasSD1)->D1_TOTAL,SF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),dDataBase,,SF1->F1_TXMOEDA,MAFISRET(,'NF_TXMOEDA'))


			//³ Verifica os itens apontados ao SIGAPMS  ³

			dbSelectArea("AFN")
			MsSeek(cFilAFN+(cAliasSD1)->D1_DOC+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_ITEM)
			While !Eof() .And. cFilAFN+(cAliasSD1)->D1_DOC+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_ITEM==;
								AFN_FILIAL+AFN_DOC+AFN_SERIE+AFN_FORNEC+AFN_LOJA+AFN_ITEM
				If AFN->AFN_REVISA==PmsAF8Ver(AFN->AFN_PROJET)
					aAdd(aAmarrAFN[nx],{AFN->AFN_PROJET,AFN->AFN_REVISA,AFN->AFN_TAREFA,(cAliasSD1)->D1_TOTAL*(AFN->AFN_QUANT/(cAliasSD1)->D1_QUANT),(cAliasSD1)->D1_PESO*(AFN->AFN_QUANT/(cAliasSD1)->D1_QUANT),0,0,"",(cAliasSD1)->D1_COD})
				EndIf
				dbSelectArea("AFN")
				dbSkip()
			Enddo
		EndIf
		dbSelectArea(cAliasSD1)
		dbSkip()
	EndDo
	If lQuery
		dbSelectArea(cAliasSD1)
		dbCloseArea()
		ChkFile("SD1")
		dbSelectArea("SD1")
	EndIf
	If lEnd
		Exit
	Endif
Next nSF1
If lEnd
   aCols	:=	aClone(aSavaCols)
	Return
Endif
If Len(aCols) == 0
	MsgAlert(STR0152 + " " + STR0153)
	aCols := aClone(aSavaCols)
	Return
Endif
aSecs := {}
oProcess:IncRegua1(STR0242)
oProcess:SetRegua2(Len(aCols)*Len(aCGastos))
oProcess:IncRegua2(STR0243)

If nTipNota	== 1 //Frete

	//³ Faz o rateio do frete nos itens  ³

	cItem 	:= StrZero(0,TamSX3('D1_ITEM')[1])
	nLenAcols:=(Len(aCols)*Len(aCGastos))
	aCols		:=	aSize(aCols,nLenAcols)
	aAmarrAFN:=	aSize(aAmarrAFN,nLenAcols)
	For nx := 1 to nLenAcols
		For nI:=1 To Len(aCGastos)
			If nI>1
		    	nX++
		    	AIns(aCols,nX)
		    	AIns(aAmarrAFN,nX)
		    	aCols[nX]		:=	aClone(aCTemp[1])
		    	aAmarrAFN[nX]	:=	aClone(aCTemp[2])
		   	Else
		    	aCTemp:={{},{}}
		    	aCTemp[1]:=aClone(aCols[nX])
		   		aCTemp[2]:=aClone(aAmarrAFN[nX])
		   	Endif
		   	cItem:=Soma1(cItem)
		   	aCols[nX,nPItem] 	:= cItem
			aCols[nX,nPTes] 	:= aCGastos[nI][2]
			If nPCF		 >  0 	; 	aCols[nX,nPCF]	:= Posicione("SF4",1,cFilSF4+aCGastos[nI][2],"F4_CF")		; 	Endif

			If nRatFrete == 2 .And. nPesoTotal > 0
				aCols[nx][nPTotal]	:= NoRound((aCols[nx][nPPeso]/nPesoTotal)*aCGastos[nI][1],nDecs,@nDifTotal)
				For nW := 1 to Len(aAmarrAFN[nx])
					aAmarrAFN[nX,nW][6] := NoRound((aAmarrAFN[nX,nW][5]/nPesoTotal)*aCGastos[nI][1],nDecs)
					aAmarrAFN[nx,nW][7] := aCols[nX][nPTotal]
				Next nW
				If NoRound(nDifTotal,nDecs) >= (1/(10**nDecs))
					aCols[nx][nPTotal]	+= NoRound(nDifTotal,nDecs)
					nDifTotal			-= NoRound(nDifTotal,nDecs)
				EndIf
				aCols[nx][nPVlUnit]	:= aCols[nx][nPTotal]
			Else
				aCols[nx][nPTotal]	:= NoRound((aCols[nx][nPTotal]/nVlrTotal)*aCGastos[nI][1],nDecs,@nDifTotal)
				For nW := 1 to Len(aAmarrAFN[nX])
					aAmarrAFN[nX,nW][6] := NoRound((aAmarrAFN[nX,nW][4]/nVlrTotal)*aCGastos[nI][1],nDecs)
					aAmarrAFN[nX,nW][7] := aCols[nX][nPTotal]
				Next nw
				If NoRound(nDifTotal,nDecs) >= (1/(10**nDecs))
					aCols[nx][nPTotal]	+= NoRound(nDifTotal,nDecs)
					nDifTotal			-= NoRound(nDifTotal,nDecs)
				EndIf
				aCols[nx][nPVlUnit]	:= aCols[nx][nPTotal]
			EndIf
		Next
		If !lEnd
			oProcess:IncRegua2(STR0244+Alltrim(STR(nX))+"/"+Alltrim(STR(nLenAcols)))
		Else
			Exit
		Endif
	Next nX
	MaColsToFis(aHeader,aCols,,"MT100",.T.,,,.T.)
Else //Despesa

	//³ Faz o rateio da despesa  (Gastos de Importacao) ³

	cItem := StrZero(0,TamSX3('D1_ITEM')[1])
	nLenAcols:=(Len(aCols)*Len(aCGastos))
	aCols:=aSize(aCols,nLenAcols)
	aAmarrAFN:=	aSize(aAmarrAFN,nLenAcols)
	For nx := 1 to nLenAcols
		For nI:=1 To Len(aCGastos)
		    If nI>1
		    	nX++
		    	Ains(aCols,nX)
		    	Ains(aAmarrAFN,nX)
		    	aCols[nX]:=aClone(aCTemp[1])
		    	aAmarrAFN[nX]:=aClone(aCTemp[2])
		    Else
		    	aCTemp:={{},{}}
		    	aCTemp[1]:=aClone(aCols[nX])
		    	aCTemp[2]:=aClone(aAmarrAFN[nX])
		    Endif
		    cItem:=Soma1(cItem)
		    aCols[nX,nPItem] := cItem
			aCols[nX,nPTes] := aCGastos[nI][2]
			If nPCF		 >  0 	; 	aCols[nX,nPCF]	:= Posicione("SF4",1,cFilSF4+aCGastos[nI][2],"F4_CF")		; 	Endif

			If nRatDesp == 2 .And. nPesoTotal > 0
				aCols[nX][nPTotal]	:= NoRound((aCols[nX][nPPeso]/nPesoTotal)*aCGastos[nI][1],nDecs,@nDifTotal)
				For nW := 1 to Len(aAmarrAFN[nx])
					aAmarrAFN[nX,nW][6] := NoRound((aAmarrAFN[nX,nW][5]/nPesoTotal)*aCGastos[nI][1],nDecs)
					aAmarrAFN[nx,nW][7] := aCols[nX][nPTotal]
				Next nW
				If NoRound(nDifTotal,nDecs) >=  (1/(10**nDecs))
					aCols[nX][nPTotal]	+= NoRound(nDifTotal,nDecs)
					nDifTotal 			-= NoRound(nDifTotal,nDecs)
				EndIf
				aCols[nX][nPVlUnit]	:= aCols[nX][nPTotal]
			Else
				aCols[nX][nPTotal]	:= NoRound((aCols[nX][nPTotal]/nVlrTotal)*aCGastos[nI][1],nDecs,@nDifTotal)
				For nW := 1 to Len(aAmarrAFN[nX])
					aAmarrAFN[nX,nW][6] := NoRound((aAmarrAFN[nX,nW][4]/nVlrTotal)*aCGastos[nI][1],nDecs)
					aAmarrAFN[nX,nW][7] := aCols[nX][nPTotal]
				Next nw
				If NoRound(nDifTotal,nDecs) >= (1/(10**nDecs))
					aCols[nX][nPTotal]	+= NoRound(nDifTotal,nDecs)
					nDifTotal 			-= NoRound(nDifTotal,nDecs)
				EndIf
				aCols[nX][nPVlUnit]	:= aCols[nX][nPTotal]
			EndIf
		Next
		If !lEnd
			oProcess:IncRegua2(STR0244+Alltrim(STR(nX))+"/"+Alltrim(STR(nLenAcols)))
		Else
			Exit
		Endif
	Next nX
	If cPaisLoc <> "ARG" .And. FindFunction("LxAjusPr")
		LxAjusPr(aCGastos, @aCols)
	EndIf
	MaColsToFis(aHeader,aCols,,"MT100",.T.,,,.T.)
Endif

aRecsSF1	:=	AClone(aRecs)

If !lEnd
	oProcess:IncRegua2(STR0245)
Else
	aSize(aCols,nX)
Endif

Eval(bDoRefresh) //Atualiza o folder financeiro.
oGetDados:obrowse:refresh()
/*
³Atualiza o browse de qtde de produtos.³
*/
lDel := Iif(Len(oBSomaItens:AARRAY)>0,.T.,.F.)
While lDel
	nLin:= Len(oBSomaItens:AARRAY)
	If Len(oBSomaItens:AARRAY) == 1
		oBSomaItens:AARRAY[nLin,1] := ''
		oBSomaItens:AARRAY[nLin,2] := 0
		lDel:=.F.
	Else
		Adel(oBSomaItens:AARRAY,nLin)
		ASize(oBSomaItens:AARRAY,Len(oBSomaItens:AARRAY)-1)
	EndIf
EndDo
Return
/*
±±³Fun‡…o    ³Locxgastos ³³±±
±±³Descri‡…o ³ Inclusao das despesas de uma nota de  frete                ³±±
±±³Uso       ³ LOCXNF	-  Notas de frete                                 ³±±
*/
Function LocxGastos()
Local aArea := GetArea()
Local aCpos := {}
Local nX := 0
//Local nTamAc := 0
Local nDel := 0
Local nOpc := 0
Local oDlg, oGetGastos
Local lRet := .F.

If Empty(aHGastos)
	aCpos:={"D1_TOTAL","D1_TES"}
	aHGastos:={}
	aCGastos:={}
	DbSelectArea("SX3")
	DbSetOrder(2)
	For nX:=1 To Len(aCpos)
		If MsSeek(aCpos[nX])
			If (X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL )
				Aadd(aHGastos,{AllTrim(X3Titulo()),;
								SX3->X3_CAMPO,;
								SX3->X3_PICTURE,;
								SX3->X3_TAMANHO,;
								SX3->X3_DECIMAL,;
								If(AllTrim(X3_CAMPO)=="D1_TES",'ExistCpo("SF4").AND.MaAvalTes("E",M->D1_TES)','M->D1_TOTAL>0'),;
								SX3->X3_USADO,;
								SX3->X3_TIPO,;
								SX3->X3_F3,;
								SX3->X3_CONTEXT,;
								X3CBOX(),;
								SX3->X3_RELACAO,;
								".T."})
			EndIf
		Endif
	Next
	Aadd(aCGastos,Array(Len(aHGastos)+1))
	For nX:=1 To Len(aHGastos)
		aCGastos[1][nX]:=Criavar(aHGastos[nX][2])
	Next
	aCGastos[1][Len(aCGastos[1])]:=.F.
Endif

DEFINE MSDIALOG oDlg TITLE STR0028 From 0,0 To 400,400 Of oMainWnd Pixel
	oGetGastos := MsNewGetDados():New(050,030,175,175,GD_INSERT+GD_UPDATE+GD_DELETE,,"AllwaysTrue()" ,,/*alteraveis*/,/*freeze*/,,/*fieldok*/,/*superdel*/,/*delok*/,oDlg,@aHGastos,@aCGastos)
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||aCGastos:=oGetGastos:aCols,nOpc:=1,oDlg:End()},{||nOpc:=0,oDlg:End()}) CENTERED

lRet:=(nOpc==1)
If nOpc==1
	nOpc:=Len(aCGastos)
	nLenAc:=Len(aCGastos[1])
	nDel:=0
	For nX:=nOpc To 1 Step -1
		If aCGastos[nX][nLenAc]
			nDel++
			Adel(aCGastos,nX)
		Endif
	Next
	If nDel>0
		aCGastos:=aSize(aCGastos,nOpc-nDel)
	Endif
Endif

RestArea(aArea)
Return(lRet)
/*/
±±³Fun‡…o    ³LocxChePed ³³±±
±±³Descri‡…o ³ Checa se existe um pedido asocioado a N.F.                 ³±±
/*/
Function LocxChePed(cAlias,nRecNo)
Local aAreaSD2		:= SD2->(GetArea())
Local nRecnoSF2	:=	SF2->(Recno())
Local cSeek 		:= ""
Local lRet 			:= .F.
Local cAprPed	:=	GetNewPar('MV_APRPED','3')

If cAprPed=='1'
	lRet	:=	.T.
ElseIf cAprPed=='2'
	lRet	:=	.F.
Else
	SF2->(MsGoTo(nRecNo))
	cSeek := xFilial("SD2")+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA

	DbSelectArea("SD2")
	DbSetOrder(3)

	If MsSeek(cSeek)
		Do While !Eof() .AND. cSeek == D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA
	   	If !Empty(D2_PEDIDO)
			If cPaisLoc == "BOL" .and. IsBlind()
				lRet := .T.
			Else
				If !MsgYesNo(STR0133 , STR0018)
					lRet := .T.
				EndIf
			EndIf
	    	Exit
	    EndIf
	  		dbSkip()
	 	End
	EndIf
	RestArea(aAreaSD2)
	SF2->(MsGoTo(nRecnoSF2))
Endif
Return lRet
/*/
±±³Fun‡…o    ³VisualNfRem|³±±
±±³Descri‡…o ³ Monta uma tela visualizando a NF ou Remito.      		  ³±±
±±³Parametros³ExpC1: Alias do Arquivo          - Obrigatorio              ³±±
±±³          ³ExpC2: Posicao do Registro       - Obrigatorio              ³±±
±±³Uso       ³ AP7   	                                                  ³±±
/*/
Function VisualNfRem(cAlias,nReg)
Private aPE		:=	Array(SnMaxPE,2)
Private aCfgNF	:=	{}
Private aRotina := {{ "", "AxPesqui", 2 },{ "" ,"LOCXDLGNF", 0, 2}}
Private lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)    //Integracao SIGAEIC
Private lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) //Integracao SIGAEIC - Financeiro
Private lFacImport	:= .F.
Private l103Class	:= .F.
lLocxAuto 			:=	Iif(Type("lLocxAuto") <> "U", lLocxAuto, .F. )

DbSelectArea(cAlias)
MsGoTo(nReg)
aCfgNf := MontaCfgNf(Val(&(Substr(cAlias,2,2)+"_TIPODOC")),{},.T.)
NFSetPrv(aCfgNF)
LocxDlgNF(aCfgNf,2)
Return
/*/

±±³Fun‡…o    ³ValidVend  ³±±
±±³Descri‡…o ³ Valida o vendedor                                          ³±±

/*/
Static Function ValidVend()
Local cPe	:=	LocxPE(36)
Private lRetv := .T.

IF !EMPTY(cVendedor)
	SA3->(dbSetOrder(1))
	lRetV :=	SA3->(MsSeek(xFilial("SA3")+cVendedor))
Endif
If !Empty(cPe)
	Execblock(cPE,.F.,.F.)
EndIf
Return lRetV
/*
±±³Fun‡…o    ³LocxGerRem ³±±
±±³Descri‡…o ³ Gera remisiones para as notas de importacao.               ³±±
*/
Function LocxGerRem(aCab,aRecIMP)
Local lRet := .T.
DEFAULT aRecIMP	:=	{}

lFacImport := ( AllTrim(SF1->F1_TIPO_NF) $ "123456789AB" )
If lFacImport
    If SF1->F1_TIPO_NF $ "56789AB"
       	LocxGrvCusImp(SF1->F1_DOC,SF1->F1_SERIE,,,@aRecImp)
	EndIf
Else
	Aviso(STR0018,STR0155+CRLF+STR0156+cTitRem+STR0157,{STR0021}) //"Esta NF nao e de import.."###"A geracao de "###" e permitida somente para notas de import.."
Endif
Return(lRet)
/*/
±±³Fun‡…o    ³NFxInclui  ³±±
±±³Descri‡…o ³ Prepara tela de Inclusão para LocxNF                       ³±±
±±³Parametros³ExpC1: Tipo da NF                                           ³±±
/*/
Function NFxInclui(nTipo,bInit,lPerg)
Local nX := 0
Local aPerg := {}
Private aCfgNF	:=	{}
Private aRotina := {}
Private aPE		:=	Array(SnMaxPE,2)
Private lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)    //Integracao SIGAEIC
Private lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) //Integracao SIGAEIC - Financeiro
Private lFacImport	:= .F.
Private l103Class	:= .F.
Private aDupl		:= {}
Private cFunName	:= IIf(Type("cFuncName")!="C",Upper(Alltrim(FunName())),cFuncName)	//Funcao Origem
Private lGerarCFD := .F.
Private aGerarCFD := {}
Private nNFTipo  := 0
Private cEspecie 	:= ""

Default lPerg	:= .T.

For nX := 1 to 5
	AADD(aRotina,{"","",0,3})
Next


//³Chama o grupo de Perguntas e acerta o array de perguntas³

//O tipo da variavel aPergunta estah sendo modificado para que a funcao Pergunte nao
//restaure a pergunta anterior

If Type("aPergunta")=="A"
	aPergunta  := NIL
EndIf

If lPerg
	If !Pergunte("MATXNF",.T.)
		Return .F.
	Endif
Else
	Pergunte("MATXNF",.F.)
Endif
AEval(aPergunta,{|x,y| AAdd(aPerg,&("MV_PAR"+StrZero(y,2))==1)})

aCfgNF := MontaCfgNf(nTipo,aPerg,.T.)
aPE	   := aClone(aCfgNF[SaPE]) //fina096
NFSetPrv(aCfgNF)
bFunAuto := bInit

lGerarCFD := .F.
aGerarCFD := {}
If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
	aGerarCFD := CFDVerific()
	If aGerarCFD[1] <> "0"
		If Empty(aGerarCFD[2])
			lGerarCFD := .T.
		Endif
	Else
		lGerarCFD := .F.
	Endif
Endif
nNFTipo  := aCfgNf[SnTipo]
cespecie := aCfgNF[ScEspecie]

LocxDlgNF(aCfgNf,3)
Return

/*/
±±³Fun‡…o    ³NFxExclui  ³±±
±±³Descri‡…o ³ Prepara tela de Exclusão para LocxNF                       ³±±
±±³Parametros³ExpC1: Tipo da NF                                           ³±±
/*/
Function NFxExclui(cAlias,bInit,nRecno)
Local nX			 := 0
Local aPerg 		:= {}
Private aCfgNF		:=	{}
Private aRotina		:= {}
Private aPE			:=	Array(SnMaxPE,2)
Private lIntegracao	:= IF(GetMV("MV_EASY")=="S",.T.,.F.)    //Integracao SIGAEIC
Private lEICFinanc	:= IF(GetMV("MV_EASYFIN")=="S",.T.,.F.) //Integracao SIGAEIC - Financeiro
Private lFacImport	:= .F.
Private l103Class	:= .F.
Private lAnulaSF3   := .F.  //Determina se anula ou exclui o registro no Livro Fiscal(MaFisAtuSF3)
Private lGerarCFD 	:= .F.
Private aGerarCFD 	:= {}

For nX := 1 to 5
	AADD(aRotina,{"","",0,5})
Next

DbSelectArea(cAlias)
MsGoTo(nRecno)

//³Chama o grupo de Perguntas e acerta o array de perguntas³

If Type("aPergunta")=="A"
	aPergunta  := NIL
EndIf

If !Pergunte("MATXNF",.T.)
	Return .F.
Endif
AEval(aPergunta,{|x,y| AAdd(aPerg,&("MV_PAR"+StrZero(y,2))==1)})
//³Monta array de configuracao da NF ³

aCfgNF := MontaCfgNf(Val(&(Substr(cAlias,2,2)+"_TIPODOC")),aPerg,.T.)

NFSetPrv(aCfgNF)
bFunAuto := bInit

lGerarCFD := .F.
aGerarCFD := {}
If aCfgNF[SlFormProp] .AND. aCfgNF[SnTipo] < 50
	aGerarCFD := CFDVerific()
	If aGerarCFD[1] <> "0"
		If Empty(aGerarCFD[2])
			lGerarCFD := .T.
		Endif
	Else
		lGerarCFD := .F.
	Endif
Endif

LocxDlgNF(aCfgNF,4)
Return
/*/
±±³Fun‡…o    ³ChkButtons  ³±±
±±³Descri‡…o ³ Retorna somente botoes utilizados pata a opcao do nopcx    ³±±
±±³Parametros³ExpA1: aRaay com os Botoes originalmente carregados         ³±±
±±³          ³ExpN1: nOpcx                                                ³±±
/*/
Static Function ChkButtons(aButtons,nOpc)
Local aBut := {}
AEval(aButtons, {|x,y| If(  Len(x)<5 .OR. Empty(x[5]) .OR. StrZero(nOpc,1)$x[5],AAdd(aBut,x),  ) } )
Return AClone(aBut)
/*/
±±³Fun‡…o    ³ChkTeclas ³±±
±±³Descri‡…o ³ Retorna somente Teclas utilizados pata a opcao do nopcx    ³±±
±±³Parametros³ExpA1: aRaay com os Teclas originalmente carregados         ³±±
±±³          ³ExpN1: nOpcx                                                ³±±
/*/
Static Function ChkTeclas(aTeclas,nOpc)
Local aTec := {}
AEval(aTeclas, {|x,y| If(  Len(x)<3 .OR. Empty(x[3]) .OR. StrZero(nOpc,1)$x[3],AAdd(aTec,x),  ) } )
Return AClone(aTec)

FUNCTION A467Lote()
Return .T.

FUNCTION A467LotCtl()
Return .T.

/*/
±±³Fun‡…o    ³NFGrpDep   ³±±
±±³Descri‡…o ³  Força validação da Filial quando digitada                 ³±±
/*/
Function ValFild (cTab)
  If cTab == "SF2"
	  if !Empty(M->F2_FILDEST)
		  NfFilDest(M->F2_FILDEST)
		  NFGrpDep(M->F2_CLIENTE,M->F2_LOJA)
		  LocXVal('F2_LOJA')
	  EndIf
  ElseIf Ctab == "SF1"
  	  If !Empty(M->F1_FILORIG)
  	  	 NfTrfOri(M->F1_FILORIG)
      Endif
  EndIf
  eval(bRefresh)
Return .T.

/*/
±±³Fun‡…o    ³NFGrpDep  ³±±
±±³Descri‡…o ³ Atualiza campo de Grupo de Depositos apos Digitar Fornec   ³±±
/*/
Function NFGrpDep(cFornece,cLoja)
Local 	aArea  := SA2->(GetArea())
SA2->(DbSetOrder(1))
If SA2->(MsSeek(xFilial("SA2")+cFornece+cLoja))
	M->F2_GRPDEP := SA2->A2_GRPDEP
EndIf
RestArea(aArea)
Return .T.

/*
±±³Fun‡…o    ³NfFilDest  ³±±
±±³Descri‡…o ³ Valida Filial destino para Remito de transf.      	      ³±±
*/
Function NfFilDest(cNumFil)
Local aArea    := GetArea()
Local aAreaSM0 := SM0->(GetArea())
Local aAreaSX5 := SM0->(GetArea())
Local cChave   := ''
Local cX5Descri:= ''
Local nTamEmFil:= Len(cFilAnt+cEmpAnt+cNumFil)
Local nTamEmSA2:= nTamEmFil
Local nTamForLj:= TamSX3("A2_COD")[1] + TamSX3("A2_LOJA")[1]
Local lGestCorp:= nTamEmFil > Len(SX5->X5_CHAVE)
Local lRet	   := .F.

If lGestCorp
	nTamEmSA2 := Len(cFilAnt+cEmpAnt+cNumFil)
EndIf

If !SM0->(MsSeek(cEmpAnt+cNumFil))
	Return .F.
EndIf

If lGestCorp
	cChave := xFilial("SX5")+'75'
	SX5->(DbSeek(cChave,.T.))
	While cChave == SX5->(X5_FILIAL+X5_TABELA)
		If SubsTr(SX5->X5_DESCRI,1,nTamEmSA2) == SubsTr(cFilAnt+cEmpAnt+cNumFil,1,nTamEmSA2)
			lRet := .T.
			Exit
		EndIf
	    SX5->(DbSkip())
	EndDo
Else
	lRet := SX5->(MsSeek(xFilial("SX5")+'75'+cFilAnt+cEmpAnt+cNumFil))
EndIf

If !lRet
	If MsgYesNo(STR0175,STR0038)
		lRet := AddFilSA2(cNumFil)
	EndIf
EndIf
If lGestCorp
	cX5Descri := Substr(SX5->X5_DESCRI,nTamEmFil+1,nTamForLj)
Else
	cX5Descri := Substr(SX5->X5_DESCRI,1,nTamForLj)
EndIf
If lRet .AND. SA2->(MsSeek(xFilial('SA2')+cX5Descri))
	If aCfgNf[SAliasHead]=="SF2"
		M->F2_CLIENTE := SA2->A2_COD
		M->F2_LOJA    := SA2->A2_LOJA
	ElseIf aCfgNf[SAliasHead]=="SF1"
		M->F1_FORNECE := SA2->A2_COD
		M->F1_LOJA    := SA2->A2_LOJA
	EndIf
Else
	lRet := .F.
EndIf

RestArea(aAreaSX5)
RestArea(aAreaSM0)
RestArea(aArea)
Return lRet

/*
±±³Fun‡…o    ³AddFilSA2 ³±±
±±³Descri‡…o ³ Cria Filial do sistema como fornec. no SA2              	  ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       		  ³±±
*/
Static Function AddFilSA2(cNewFil)
Local cChave	:= ''
Local cProvedor := ''
Local cLoja     := ''
Local nTamEmFil	:= Len(cNewFil+cEmpAnt+cFilAnt)
Local nTamProv  := TamSX3("A2_COD" )[1]
Local nTamLoja	:= TamSX3("A2_LOJA")[1]
Local lContinua := .F.
Local lGestCorp	:= nTamEmFil > Len(SX5->X5_CHAVE)
Local lMT462Vld := SuperGetMv("MT462VLD",.F.,.T.)
Local lRet		:= .F.

DbSelectArea("SA2")
DbSetOrder(1)
lRet := ConPad1(,,,"SA2")

//³MT462VLD - Parametro criado para nao permitir fornec.es diferentes nos    |
//|           documentos de entrada e saida da transf.. Vale ressaltar 		 |
//|           que se o parametro for desabilitado podem ocorrer problemas de |
//|           custos nos documentos de entrada.                              |

If lMT462Vld
	If lGestCorp
		cChave := xFilial("SX5")+'75'
		If SX5->(DbSeek(cChave,.T.))
			While cChave == SX5->(X5_FILIAL+X5_TABELA)
				If Substr(SX5->X5_DESCRI,1,nTamEmFil) == cNewFil+cEmpAnt+cFilAnt
					lContinua := .T.
					Exit
				EndIf
		    	SX5->(DbSkip())
			EndDo
			If lContinua
				cProvedor := SubStr(SX5->X5_DESCRI,nTamEmFil+1,nTamProv)
		    	cLoja     := SubStr(SX5->X5_DESCRI,nTamEmFil+nTamProv+1,nTamLoja)
				If SA2->A2_COD <> cProvedor .Or. SA2->A2_LOJA <> cLoja
					Aviso(STR0018,STR0249 + AllTrim(cProvedor)+" - "+AllTrim(cLoja)+' '+STR0250,{"Ok"},,STR0251)
					lRet := .F.
		    	EndIf
			EndIf
		EndIf
	Else
		If SX5->(MsSeek(xFilial("SX5")+'75'+cNewFil+cEmpAnt+cFilAnt))
			cProvedor := SubStr(SX5->X5_DESCRI,1,nTamProv)
	    	cLoja     := SubStr(SX5->X5_DESCRI,nTamProv+1,nTamLoja)
			If SA2->A2_COD <> cProvedor .Or. SA2->A2_LOJA <> cLoja
				Aviso(STR0018,STR0249 + AllTrim(cProvedor)+" - "+AllTrim(cLoja)+' '+STR0250,{"Ok"},,STR0251)
				lRet := .F.
		    EndIf
		EndIf
	EndIf
EndIf

If lRet
	RecLock('SX5',.T.)
	X5_FILIAL  := xFilial('SX5')
	X5_TABELA  := '75'
	If !lGestCorp
		X5_CHAVE   := cFilAnt+cEmpAnt+cNewFil
		X5_DESCRI  := SA2->A2_COD+SA2->A2_LOJA
		X5_DESCSPA := SA2->A2_COD+SA2->A2_LOJA
		X5_DESCENG := SA2->A2_COD+SA2->A2_LOJA
	Else
		X5_CHAVE   := ' '
		X5_DESCRI  := cFilAnt+cEmpAnt+cNewFil+SA2->A2_COD+SA2->A2_LOJA
		X5_DESCSPA := cFilAnt+cEmpAnt+cNewFil+SA2->A2_COD+SA2->A2_LOJA
		X5_DESCENG := cFilAnt+cEmpAnt+cNewFil+SA2->A2_COD+SA2->A2_LOJA
	EndIf
	MsUnlock()
EndIf
Return lRet

/*
±±³Fun‡…o    ³NfTrfOri  ³±±
±±³Descri‡…o ³ Busca Documentos de saida na filial original.              ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.     	                      ³±±
*/
Function NfTrfOri(cNumFil)
Local aRecOri	  := {}
Local aRetPE 	  := {}
Local cAlias,nIndex,cWhile,cSeek,aCpos,cCondicao,cMyNumFor
Local cCampo      := ""
Local nPosCOD     := 0
Local nPosUM      := 0
Local nPosLOCAL   := 0
Local nPosQUANT   := 0
Local nPosQtSeg   := 0
Local nPosVUNIT   := 0
Local nPosTOTAL   := 0
Local nPosTES     := 0
Local nPosCF      := 0
Local nPosItem    := 0
Local nPosIDENTB6 := 0
Local nPosLOTECTL := 0
Local nPosNUMLOTE := 0
Local nPosDTVALID := 0
Local nPosPOTENCI := 0
Local nPosNfOri   := 0
Local nPosItOri   := 0
Local nPosSeOri   := 0
Local nI		  := 0
Local lLocxD2D1   := ExistBlock('LOCXD2D1')
Local lLocxRemE   := ExistBlock('LOCXREME')
Local aAreaAnt	  := {}
Local cCodForTrf  := ""
Local cLojForTrf  := ""
Local cAliasQry   := ""
Local cQuery	  := ""
Local nT_ITEM		:= TamSX3("D1_ITEM")[1]
Local cFilSF4		:= xFilial("SF4")
Local lLocxM462   := ExistBlock('LOCXM462')
Local IntDl := GetMV('MV_INTDL') == 'S'
Local nPosServi:=0
Local nPosLocz:=0
Local nPosEnder := 0
Local lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.)

If Empty(cNumFil)
	Aviso(STR0018,OemToAnsi(STR0184),{STR0021}) //"Informe a Filial de Origem."
	Return .F.
EndIf
// Valida todos os dados da filial selecionada e preenche os campos de Fornec./Loja.
If !(NfFilDest(cNumFil) .AND. LocXVal('F1_LOJA') .AND. LxA103VFold('NF_CODCLIFOR',M->F1_FORNECE) .AND. LxA103VFold('NF_LOJA',M->F1_LOJA))
	Return .F.
EndIf

cMyNumFor := GetNumFor(cNumFil)
If Empty(cMyNumFor)
	Aviso(STR0018,OemToAnsi(STR0186),{STR0021}) //"Nao foram encontrados docs. de transf. para essa filial."
	Return .F.
EndIf

If Type("lLocxAuto") <> "U" .And. lLocxAuto
   Return .T.
Endif

// Melhoria de performance para trabalhar somente com os registros relevantes (D2_QTDAFAT > 0)

aAreaAnt := GetArea()
cCodForTrf := Substr(cMyNumFor,1,TamSX3("F2_CLIENTE")[1])
cLojForTrf := Substr(cMyNumFor,TamSX3("F2_CLIENTE")[1]+1,TamSX3("F2_LOJA")[1])
cAliasQry := "ANOTASTRF"
cQuery := "SELECT DISTINCT F2_DOC, F2_SERIE, F2_CLIENTE, F2_LOJA"
cQuery += "FROM "+RetSqlName("SF2")+" SF2 "
cQuery += "JOIN "+RetSqlName("SD2")+" SD2 "
cQuery += "ON SF2.F2_DOC = SD2.D2_DOC "
cQuery += "AND SF2.F2_SERIE = SD2.D2_SERIE "
cQuery += "AND SF2.F2_CLIENTE = SD2.D2_CLIENTE "
cQuery += "AND SF2.F2_LOJA = SD2.D2_LOJA "
cQuery += "AND SF2.F2_CLIENTE = '" + cCodForTrf + "' "
cQuery += "AND SF2.F2_LOJA = '" + cLojForTrf + "' "
cQuery += "AND SD2.D2_QTDAFAT > 0 "
cQuery += "AND SF2.D_E_L_E_T_ = '' "
cQuery += "AND SD2.D_E_L_E_T_ = '' "
cQuery := ChangeQuery(cQuery)

If lLocxM462
	cQuery :=	Execblock("LOCXM462",.F.,.F.,{cQuery,cCodForTrf,cLojForTrf,cNumFil} )
EndIf

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

DbSelectArea(cAliasQry)
(cAliasQry)->(DbGoTop())
While !Eof()
	AADD(aNotasTrf,F2_DOC)
	DbSelectArea(cAliasQry)
	dbSkip()
EndDo
(cAliasQry)->(dbCloseArea())
RestArea(aAreaAnt)

cAlias    := "SF2"
nIndex    := 2   //F2_FILIAL+F2_CLIENTE+F2_LOJA+F2_DOC+F2_SERIE
cSeek     := "'" + GetFilOri('SF2',cNumFil) + cMyNumFor + "'"
cWhile    := "!EOF() .AND. F2_FILIAL+F2_CLIENTE+F2_LOJA  == " + cSeek
If Len(aNotasTrf) > 0
	cCondicao := "Ascan(aNotasTrf,{|x| x == SF2->F2_DOC}) > 0 .AND. F2_TIPODOC == '54' .AND. NFHasSD2It(Recno()) .And. F2_FILDEST == cFilAnt"
Else
	cCondicao := "F2_TIPODOC == '54' .AND. NFHasSD2It(Recno()) .And. F2_FILDEST == cFilAnt"
EndIf
aCpos     := {'F2_DOC','F2_SERIE','F2_EMISSAO'}

//Ponto de entrada para incluir campos en Remitos de Entrada

If lLocxRemE
	aRetPE	:= ExecBlock("LOCXREME",.F.,.F.,{aCpos})
	If ValType(aRetPE) == "A"
		aCpos	:= aClone(aRetPE)
	End If
End If

aRecOri := LocxF4(cAlias,nIndex,cWhile,cSeek,aCpos,,,cCondicao,,,,,,,.F.)
If !(ValType(aRecOri)=="A" .AND. Len(aRecOri) >= 3 .AND. ValType(aRecOri[3])=="A" .AND. Len(aRecOri[3])> 0)
	Return .F.
EndIf

SF2->(MSGoto(aRecOri[3][1]))

cAlias    := "SD2"
nIndex    := 3   //D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
cSeek     := "'" + SF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA) + "'"
cWhile    := "!EOF() .AND. D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA  == " + cSeek
cCondicao := "D2_TIPODOC == '54' .And. D2_QTDAFAT > 0 .And. D2_QTDAFAT == D2_QUANT .And. SD2->D2_ESPECIE == SF2->F2_ESPECIE"

aRecOri := LocxGrid(cAlias,cWhile,cCondicao,,,cSeek,nIndex,{'D2_COD'},,,,,,)
If !(ValType(aRecOri)=="A" .AND. Len(aRecOri) >= 6 .AND. ValType(aRecOri[6])=="A" .AND. Len(aRecOri[6]) > 0)
	Return .F.
EndIf

For nI := 1 To Len(aHeader)
	cCampo := Upper(AllTrim(aHeader[nI][2]))
	Do Case
		Case cCampo == "D1_COD"
			nPosCOD := nI
		Case cCampo == "D1_UM"
			nPosUM := nI
		Case cCampo == "D1_LOCAL"
			nPosLOCAL := nI
		Case cCampo == "D1_QUANT"
			nPosQUANT := nI
		Case cCampo == "D1_QTSEGUM"
			nPosQtSeg := nI
		Case cCampo == "D1_VUNIT"
			nPosVUNIT := nI
		Case cCampo == "D1_TOTAL"
			nPosTOTAL := nI
		Case cCampo == "D1_TES"
			nPosTES := nI
		Case cCampo == "D1_CF"
			nPosCF := nI
		Case cCampo == "D1_IDENTB6"
			nPosIDENTB6 := nI
		Case cCampo == "D1_LOTECTL"
			nPosLOTECTL := nI
		Case cCampo == "D1_NUMLOTE"
			nPosNUMLOTE := nI
		Case cCampo == "D1_DTVALID"
			nPosDTVALID := nI
		Case cCampo == "D1_POTENCI"
			nPosPOTENCI := nI
		Case cCampo == "D1_ITEM"
			nPosItem    := nI
		Case cCampo == "D1_NFORI"
			nPosNfOri   := nI
		Case cCampo == "D1_ITEMORI"
			nPosItOri   := nI
		Case cCampo == "D1_SERIORI"
			nPosSeOri   := nI
		Case cCampo == "D1_SERVIC"
			nPosServi   := nI
		Case cCampo == "D1_LOCALIZ"
			nPosLocz   := nI
		Case cCampo == "D1_ENDER"
			nPosEnder   := nI
	EndCase
Next nI

M->F1_DOC     := SF2->F2_DOC
M->F1_SERIE   := SF2->F2_SERIE
M->F1_EMISSAO := SF2->F2_EMISSAO
M->F1_NATUREZ := SF2->F2_NATUREZ
M->F1_DTDIGIT := dDataBase
M->F1_MOEDA   := SF2->F2_MOEDA
M->F1_TXMOEDA := SF2->F2_TXMOEDA

// Redefinir o numero maximo de itens do objeto de acordo
// com a qtde de registros obtidos em aRecOri[6]
oGetDados:nMax:=Len(aRecOri[6])

If valtype(nTotQtIte) <> NIL
   nTotQtIte:= 0
EndIf

aCols := {}
For nI := 1 To Len(aRecOri[6])
	SD2->(MsGoto(aRecOri[6][nI]))
	oGetDados:AddLine()

	//³Ponto de entrada utilizado para carregar campos da tabela SD2 para a tabela SD1 |

	If lLocxD2D1
		Execblock('LOCXD2D1',.F.,.F.)
	EndIf

	//³SD1 - Itens de Entrada³

	If(nPosCOD     > 0 ,aCols[Len(aCols)][nPosCOD]     := SD2->D2_COD    ,)
	If(nPosUM      > 0 ,aCols[Len(aCols)][nPosUM]      := SD2->D2_UM     ,)
	If(nPosLOCAL   > 0 ,aCols[Len(aCols)][nPosLOCAL]   := SD2->D2_LOCDEST,)
	If(nPosQUANT   > 0 ,aCols[Len(aCols)][nPosQUANT]   := SD2->D2_QTDAFAT,)
	If(nPosQtSeg   > 0 ,aCols[Len(aCols)][nPosQtSeg]   := ConvUm(SD2->D2_COD,SD2->D2_QTDAFAT,0,2),)
	If(nPosVUNIT   > 0 ,aCols[Len(aCols)][nPosVUNIT]   := SD2->D2_PRCVEN ,)
	If(nPosTOTAL   > 0 ,aCols[Len(aCols)][nPosTOTAL]   := SD2->D2_TOTAL  ,)
	If(nPosTES     > 0 ,aCols[Len(aCols)][nPosTES]     := SD2->D2_TESENT ,)
	If(nPosCF      > 0 ,aCols[Len(aCols)][nPosCF]      := Posicione("SF4",1,cFilSF4+SD2->D2_TESENT,"F4_CF") ,)
	If(nPosIDENTB6 > 0 ,aCols[Len(aCols)][nPosIDENTB6] := SD2->D2_NUMSEQ ,)
	If(nPosItem    > 0 ,aCols[Len(aCols)][nPosItem   ] := Padl(SD2->D2_ITEM,nT_ITEM,"0"),)
	If(nPosNfOri   > 0 ,aCols[Len(aCols)][nPosNfOri  ] := SD2->D2_DOC    ,)
	If(nPosItOri   > 0 ,aCols[Len(aCols)][nPosItOri  ] := SD2->D2_ITEM   ,)
	If(nPosSeOri   > 0 ,aCols[Len(aCols)][nPosSeOri  ] := SD2->D2_SERIE  ,)

	If Rastro(SD2->D2_COD)
		If(nPosLOTECTL > 0 ,aCols[Len(aCols)][nPosLOTECTL] := SD2->D2_LOTECTL ,)
		If(nPosNUMLOTE > 0 ,aCols[Len(aCols)][nPosNUMLOTE] := SD2->D2_NUMLOTE ,)
		If(nPosDTVALID > 0 ,aCols[Len(aCols)][nPosDTVALID] := SD2->D2_DTVALID ,)
		If(nPosPOTENCI > 0 ,aCols[Len(aCols)][nPosPOTENCI] := SD2->D2_POTENCI ,)
	EndIf
	If Valtype(nTotQtIte) <> NIL
		nTotQtIte += aCols[Len(aCols)][nPosQUANT]
	EndIf

	If IntDl .And. cPaisLoc== "ARG"
		SB5->(DBSetOrder(1))
		If SB5->(MSSeek(xFilial("SB5")+SD2->D2_COD, .F.)) .or. SB5->(MSSeek(GetFilOri('SB5',cNumFil)+SD2->D2_COD, .F.))
			If(nPosServi > 0 ,aCols[Len(aCols)][nPosServi] := SB5->B5_SERVENT ,)
			If(nPosLocz > 0 .And. Empty(SB5->B5_SERVENT) ,aCols[Len(aCols)][nPosLocz] := SB5->B5_LOCALIZ ,)
			If lWmsNew .And. Funname() == "MATA462TN"
				If(nPosEnder > 0 ,aCols[Len(aCols)][nPosEnder] := SB5->B5_ENDECD ,)
			EndIf
		EndIf
	EndIf
Next nI
oGetDados:lNewLine := .F.
aCols:=aSort(aCols,,,{|x,y| x[nPosItem]<y[nPosItem]})
MaFisClear()
MaColsToFis(aHeader,aCols,,"MT100",.T.)

//³Ponto de Entrada para Alterar o Acols ³
cPE := LOCXPE(65)
If !Empty(cPE)
	aRetPE:= ExecBlock(cPE,.F.,.F.,{aCfgNF[SnTipo],aCols})
	If ValType(aRetPE) == "A"
   		aCols := aClone(aRetPE)
	EndIf
EndIf

oGetDados:oBrowse:nAt := 1
oGetDados:oBrowse:Refresh()
Return .T.
/*
±±³Fun‡…o    ³GetFilOri ³±±
±±³Descri‡…o ³ Pega xfilial de um arquivo, para uma outra filial.         ³±±
*/
Static Function GetFilOri(cAlias,cNumFil)
Local cTamFil := ""
//Local nDif	:= 0
//Local nDif1	:= 0
//Local cLayout := ""
//Local lEmp	:= .F.
//Local lUnid := .F.
//Local lFil	:= .F.
//Local nAchou := 0
Local aAreaFil := GetArea()

DEFAULT cAlias  := Alias()
DEFAULT cNumFil := cFilAnt
If FWModeAccess(cAlias) == "E"
	cTamFil := cNumFil
Else
	If cPaisLoc == "BOL" .AND. FunName() == "MATA462TN" .AND. cAlias == "SF4"
		cTamFil := TamFilBol()
	ElseIf cPaisLoc == "ARG" .AND. FunName() == "MATA462TN" .AND. FwSizeFilial() >= 4 .And. FWModeAccess("SF4",3) == "E"
		cTamFil := cNumFil
	Else
		cTamFil := Space(FwSizeFilial())
	EndIf
EndIf
RestArea(aAreaFil)
Return cTamFil
/*
±±³Fun‡…o    ³GetNumfor  ³±±
±±³Descri‡…o ³ Retorna o numero de Fornec. DESTA filial em outra filial	  ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       		  ³±±
*/
Static Function GetNumfor(cNumFil)
Local cChave	:= ''
Local cMyNum	:= ''
Local nTamEmFil	:= Len(cNumFil+cEmpAnt+cFilAnt)
Local nTamForLj	:= TamSX3("A2_COD")[1] + TamSX3("A2_LOJA")[1]
Local lContinua := .F.
Local lGestCorp	:= nTamEmFil > Len(SX5->X5_CHAVE)
Local cFilBus:=GetFilOri('SX5',cNumFil)

If cEmpAnt != NIL .AND. cNumFil != NIL
	If !SM0->(MsSeek(cEmpAnt+cNumFil))
		Return cMyNum
	EndIf
	If lGestCorp
		cChave := xFilial("SX5")+'75'
		SX5->(DbSeek(cChave,.T.))
		While cChave == SX5->(X5_FILIAL+X5_TABELA)
			If Substr(SX5->X5_DESCRI,1,nTamEmFil) == cFilAnt+cEmpAnt+cNumFil
				lContinua := .T.
				Exit
			EndIf
		    SX5->(DbSkip())
		EndDo
		If lContinua
			cMyNum := SubStr(SX5->X5_DESCRI,nTamEmFil+1,nTamForLj)
		EndIf
	ElseIf SX5->(MsSeek(cFilBus+'75'+cNumFil+cEmpAnt+cFilAnt))
    	cMyNum := SubStr(SX5->X5_DESCRI,1,nTamForLj)
	EndIf
EndIf
Return cMyNum

/*
±±³Fun‡…o    ³RetForFil ³±±
±±³Descri‡…o ³ Retorna o numero de Fornec. de OUTRA filial NESTA  	      ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                      		  ³±±

*/
Static Function RetForFil(cNumFil)
Local cChave	:= ''
Local cNumFor	:= ''
Local nTamEmFil	:= Len(cFilAnt+cEmpAnt+cNumFil)
Local nTamForLj	:= TamSX3("A2_COD")[1] + TamSX3("A2_LOJA")[1]
Local lContinua := .F.
Local lGestCorp	:= nTamEmFil > Len(SX5->X5_CHAVE)

If !SM0->(MsSeek(cEmpAnt+cNumFil))
	Return cNumFor
EndIf
If lGestCorp
	cChave := xFilial("SX5")+'75'
	SX5->(DbSeek(cChave,.T.))
	While cChave == SX5->(X5_FILIAL+X5_TABELA)
		If Substr(SX5->X5_DESCRI,1,nTamEmFil) == cFilAnt+cEmpAnt+cNumFil
			lContinua := .T.
			Exit
		EndIf
	    SX5->(DbSkip())
	EndDo
	If lContinua
	   	cNumFor := SubStr(SX5->X5_DESCRI,nTamEmFil+1,nTamForLj)
	EndIf
ElseIf SX5->(MsSeek(xFilial("SX5")+'75'+cFilAnt+cEmpAnt+cNumFil)) .And. ;
	SA2->(MsSeek(xFilial('SA2')+SubStr(SX5->X5_DESCRI,1,nTamForLj)))
   	cNumFor := SubStr(SX5->X5_DESCRI,1,nTamForLj)
EndIf
Return cNumFor

/*

±±³Fun‡…o    ³GerTrfRet ³±±
±±³Descri‡…o ³ Gera entrada por transf..                           		  ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       		  ³±±

*/
Static Function GerTrfRet(nRecOri,cFilDest)
Local aCposSF1   := {{},{}}
Local aCposSD1   := {{},{}}
Local cNumFilFor := NIL
Local cFilOri    := cFilAnt
Local nPosItem   := 0
Local lRetAuto	 := .F.
Local aCposUsr	 := {}
Local lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lRastro    := IIF(SuperGetMV("MV_RASTRO")=="S",.T.,.F.)

Private aHeader := {}
Private aCols   := {}
cFilAnt := cFilDest

SF2->(MsGoto(nRecOri))

cNumFilFor := RetForFil(cFilOri)
If Empty(cNumFilFor)
	If MsgYesNo(STR0175,STR0038) .AND. AddFilSA2(cFilOri)
		cNumFilFor := SA2->A2_COD+SA2->A2_LOJA
	Else
		Return .F.
	EndIf
EndIf
If !SA2->(MsSeek(xFilial('SA2')+cNumFilFor))
	Return .F.
EndIf

//SF1 - Cabecalho de Entrada
AAdd(aCposSD1[1], "D1_ITEM"   ); AADD(aCposSD1[2], 'Padl(SD2->D2_ITEM,TamSX3("D1_ITEM")[1],"0")')
AADD(aCposSF1[1], "F1_FILORIG"); AADD(aCposSF1[2], cFilOri         )
AADD(aCposSF1[1], "F1_DOC"    ); AADD(aCposSF1[2], SF2->F2_DOC     )
AADD(aCposSF1[1], "F1_SERIE"  ); AADD(aCposSF1[2], SF2->F2_SERIE   )
AADD(aCposSF1[1], "F1_FORNECE"); AADD(aCposSF1[2], SA2->A2_COD     )
AADD(aCposSF1[1], "F1_LOJA"   ); AADD(aCposSF1[2], SA2->A2_LOJA    )
AADD(aCposSF1[1], "F1_EMISSAO"); AADD(aCposSF1[2], SF2->F2_EMISSAO )
AADD(aCposSF1[1], "F1_DTDIGIT"); AADD(aCposSF1[2], dDataBase       )
AADD(aCposSF1[1], "F1_MOEDA"  ); AADD(aCposSF1[2], SF2->F2_MOEDA   )
AADD(aCposSF1[1], "F1_TXMOEDA"); AADD(aCposSF1[2], SF2->F2_TXMOEDA )
AADD(aCposSF1[1], "F1_TIPO"   ); AADD(aCposSF1[2], 'N' )
AADD(aCposSF1[1], "F1_FORMUL" ); AADD(aCposSF1[2], 'N' )
AADD(aCposSF1[1], "F1_ESPECIE"); AADD(aCposSF1[2], GetSESNew('RTE'))
AADD(aCposSF1[1], "F1_TIPODOC"); AADD(aCposSF1[2], '64' )

//SD1 - Itens de Entrada
AADD(aCposSD1[1], "D1_FILIAL" ); AADD(aCposSD1[2], 'xFilial("SD1")')
AADD(aCposSD1[1], "D1_COD"    ); AADD(aCposSD1[2], 'SD2->D2_COD    ')
AADD(aCposSD1[1], "D1_UM"     ); AADD(aCposSD1[2], 'SD2->D2_UM     ')
AADD(aCposSD1[1], "D1_LOCAL"  ); AADD(aCposSD1[2], 'SD2->D2_LOCDEST')
AADD(aCposSD1[1], "D1_QUANT"  ); AADD(aCposSD1[2], 'SD2->D2_QUANT  ')
AADD(aCposSD1[1], "D1_VUNIT"  ); AADD(aCposSD1[2], 'SD2->D2_PRCVEN ')
AADD(aCposSD1[1], "D1_TOTAL"  ); AADD(aCposSD1[2], 'SD2->D2_TOTAL  ')
AADD(aCposSD1[1], "D1_TES"    ); AADD(aCposSD1[2], 'SD2->D2_TESENT ')
AADD(aCposSD1[1], "D1_CF"     ); AADD(aCposSD1[2], 'Posicione("SF4",1,xFilial("SF4")+SD2->D2_TESENT,"F4_CF") ')
AAdd(aCposSD1[1], "D1_IDENTB6"); AADD(aCposSD1[2], 'SD2->D2_NUMSEQ ')
AAdd(aCposSD1[1], "D1_ESPECIE"); AADD(aCposSD1[2], 'GetSESNew("RTE")')
AAdd(aCposSD1[1], "D1_TIPODOC"); AADD(aCposSD1[2], '"64"')
AAdd(aCposSD1[1], "D1_TIPO"   ); AADD(aCposSD1[2], '"N"')
AADD(aCposSD1[1], "D1_NFORI"  ); AADD(aCposSD1[2], 'SD2->D2_DOC')
AADD(aCposSD1[1], "D1_SERIORI"); AADD(aCposSD1[2], 'SD2->D2_SERIE')
AADD(aCposSD1[1], "D1_ITEMORI"); AADD(aCposSD1[2], 'SD2->D2_ITEM')
If lRastro
	AADD(aCposSD1[1], "D1_LOTECTL"); AADD(aCposSD1[2], 'SD2->D2_LOTECTL ')
	AADD(aCposSD1[1], "D1_NUMLOTE"); AADD(aCposSD1[2], 'SD2->D2_NUMLOTE ')
	AADD(aCposSD1[1], "D1_DTVALID"); AADD(aCposSD1[2], 'SD2->D2_DTVALID ')
	AADD(aCposSD1[1], "D1_POTENCI"); AADD(aCposSD1[2], 'SD2->D2_POTENCI ')
EndIf

If cPaisLoc == "ARG"
	ArgGRemTrf(@aCposSD1, lRastro, lWmsNew)
EndIf

If SF2->F2_TIPORET=="1"  // Retorno Automático
	lRetAuto = .T.
EndIf

//³ Ponto de entrada para adicionar campos do usuário da tabela SD2 na tabela SD1 ³
//³ Utilizado para Tipo de Retorno Automático                                     ³

If lRetAuto
	cPe	:= LocxPE(71)
	If !Empty(cPe)
		aCposUsr := Execblock(cPE,.F.,.F.,{aCposSD1})
		If ValType(aCposUsr)=="A"
			aCposSD1 := aClone(aCposUsr)
		EndIf
	EndIf
EndIf

nPosItem := AScan(aCposSD1[1],"D1_ITEM")
SD2->(DbSetOrder(3))
SD2->(MsSeek( GetFilOri("SD2",cFilOri)+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA))
While !Eof() .AND. SD2->D2_FILIAL == GetFilOri("SD2",cFilOri) .AND.;
		SD2->D2_DOC     == SF2->F2_DOC     .AND.;
		SD2->D2_SERIE   == SF2->F2_SERIE   .AND.;
		SD2->D2_CLIENTE == SF2->F2_CLIENTE .AND.;
		SD2->D2_LOJA    == SF2->F2_LOJA

		AAdd(aCols, Array( Len(aCposSD1[1])+1 ) )
		//SD1 - Itens de Entrada
		AEval(aCposSD1[1],{|x,y| aCols[Len(aCols)][y] := &(aCposSD1[2][y])  } )
		aCols[Len(aCols)][Len(aCposSD1[1])+1] := .F.
	dbSelectArea("SD2")
	dbSkip()
End
aCols:=aSort(aCols,,,{|x,y| x[nPosItem]<y[nPosItem]})
aHeader := CposToHead(aCposSD1[1])

MsAguarde( {|| lRetGravacao := GravaNfGeral(aCposSF1,aCols,aCposSD1[1],64,aCfgNf[SaPergs],,.F.,,)},,STR0179,)
cFilAnt := cFilOri
Return lRetGravacao

/*

±±³Fun‡…o    ³NfVldDes  ³±±
±±³Descri‡…o ³ Valida Local Destino digitado no Item.                     ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       	      ³±±

*/
Function NfVldDes(cLocDest)
Local nPosLocal := AScan(aHeader,{ |x| UPPER(Alltrim(x[2]))=="D2_LOCAL" })
Local lRet := Vazio() .OR. Pertence(Posicione("SX5",1,xFilial("SX5")+'74'+M->F2_GRPDEP,"X5DESCRI()"))

DEFAULT cLocDest := &(ReadVar())

// Se a transf. for para a mesma filial, o depósito deve ser diferente.
IF (lRet .AND. M->F2_FILDEST == cFilAnt .AND. nPosLocal > 0 .AND. ACols[n][nPosLocal] == cLocDest)
	Aviso(STR0018,STR0181,{STR0021}) // "O deposito Destino nao pode ser o mesmo de origem."
	lRet := .F.
EndIf
Return lRet

/*
±±³Fun‡…o    ³NFVldDep  ³±±
±±³Descri‡…o ³ Valida o grupo de depositos digitado.                      ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                  		      ³±±

*/
Function NFVldDep()
Local lRet := (Empty(SA2->A2_GRPDEP) .OR. (M->F2_GRPDEP == SA2->A2_GRPDEP))
If !lRet
	Aviso(STR0018,STR0180,{STR0021}) // "O Grupo de Deposito deve ser o mesmo informado no cadastro do fornec.."
EndIf
Return lRet
/*
±±³Fun‡…o    ³NFVldTES ³±±
±±³Descri‡…o ³ Valida o TES do documento de retorno.                      ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                      		  ³±±
*/
Function NFVldTES(cTesDest)
Local lRet := .F.
Local aAreaSF4 := GetArea('SF4')
DEFAULT cTesDest := &(ReadVar())
SF4->(DbSetOrder(1))
lRet := (SF4->(MsSeek(GetFilOri('SF4',M->F2_FILDEST)+cTesDest)))
If !lRet
	Aviso(STR0018,STR0182,{STR0021})
EndIf

RestArea(aAreaSF4)
Return lRet

/*

±±³Fun‡…o    ³ GerSD3Trf ³±±
±±³Descri‡…o ³ Cria movimento no SD3 referente a Transferencia            ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de Transferencia                        ³±±

*/
Static Function GerSD3Trf(cAlias,nReg,nEvento,cFilOri)
Local nPosCpo  := 0
Local aCposSD3 := {}
Local cDepTrf  := SuperGetMv("MV_DEPTRANS",.F.,"95")
Local lTranSB2 := SuperGetMv("MV_TRANSB2",.F.,.F.)	  // Atualiza saldos de transf.
DbSelectArea(cAlias)
MsGoto(nReg)
cPE := LOCXPE(75)
Do Case
	Case nEvento == 1 // Faz a entrada no Deposito de Transferencia.
		SB1->(DbSetOrder(1))
		SB1->(MsSeek(xFilial("SB1")+SD2->D2_COD))
		AAdd(aCposSD3, {"D3_FILIAL" , xFilial("SD3")		,NIL } )
		AAdd(aCposSD3, {"D3_USUARIO", SubStr(cUsuario,7,15),NIL } )
		AAdd(aCposSD3, {"D3_NUMSEQ" , SD2->D2_NUMSEQ 		,NIL } )
		AAdd(aCposSD3, {"D3_TM"     , '499'      		    ,NIL } )
		AAdd(aCposSD3, {"D3_CF"     , 'DE4'         		,NIL } )
		AAdd(aCposSD3, {"D3_COD"    , SD2->D2_COD    		,NIL } )
		AAdd(aCposSD3, {"D3_ITEM"   , SD2->D2_ITEM   		,NIL } )
		AAdd(aCposSD3, {"D3_QUANT"  , SD2->D2_QUANT  		,NIL } )
		AAdd(aCposSD3, {"D3_UM"     , SD2->D2_UM     		,NIL } )
		AAdd(aCposSD3, {"D3_QTSEGUM", SD2->D2_QTSEGUM		,NIL } )
		AAdd(aCposSD3, {"D3_SEGUM"  , SD2->D2_SEGUM  		,NIL } )
		AAdd(aCposSD3, {"D3_LOCAL"  , cDepTrf        		,NIL } )
		AAdd(aCposSD3, {"D3_GRUPO"  , SB1->B1_GRUPO  		,NIL } )
		AAdd(aCposSD3, {"D3_TIPO"   , SB1->B1_TIPO   		,NIL } )
		AAdd(aCposSD3, {"D3_EMISSAO", SD2->D2_EMISSAO		,NIL } )
		AAdd(aCposSD3, {"D3_DOC"    , SD2->D2_DOC    		,NIL } )
		AAdd(aCposSD3, {"D3_LOTECTL", SD2->D2_LOTECTL		,NIL } )
		AAdd(aCposSD3, {"D3_NUMLOTE", SD2->D2_NUMLOTE		,NIL } )
		AAdd(aCposSD3, {"D3_DTVALID", SD2->D2_DTVALID		,NIL } )
		AAdd(aCposSD3, {"D3_POTENCI", SD2->D2_POTENCI		,NIL } )
		AAdd(aCposSD3, {"D3_PROJPMS", SD2->D2_PROJPMS		,NIL } )
		AAdd(aCposSD3, {"D3_TASKPMS", SD2->D2_TASKPMS		,NIL } )
		AAdd(aCposSD3, {"D3_LOCALIZ", SD2->D2_LOCALIZ		,NIL } )
		AAdd(aCposSD3, {"D3_CHAVE"  , 'RTS'           		,NIL } )
		If lTranSb2
			AAdd(aCposSD3, {"D3_CUSTO1" , SD2->D2_CUSTO1   		,NIL } )
			AAdd(aCposSD3, {"D3_CUSTO2" , SD2->D2_CUSTO2   		,NIL } )
			AAdd(aCposSD3, {"D3_CUSTO3" , SD2->D2_CUSTO3  		,NIL } )
			AAdd(aCposSD3, {"D3_CUSTO4" , SD2->D2_CUSTO4   		,NIL } )
			AAdd(aCposSD3, {"D3_CUSTO5" , SD2->D2_CUSTO5   		,NIL } )
		EndIf
        If !Empty(cPE)
			aRetPE:= ExecBlock(cPE,.F.,.F.,{aCposSD3,nEvento})
			If ValType(aRetPE) == "A"
				aCposSD3 := aClone(aRetPE)
			EndIf
		EndIf
		// Grava SD3 de transferencia
		Reclock("SD3",.T.)
		AEval(aCposSD3,{|x,y| nPosCpo := FieldPos(x[1]),If(nPosCpo>0,FieldPut(nPosCpo,x[2]),) } )
		MsUnlock()
		// Atualiza o saldo atual (SB2) com os dados do SD3
		If lTranSb2
			B2AtuComD3({SD2->D2_CUSTO1,SD2->D2_CUSTO2,SD2->D2_CUSTO3,SD2->D2_CUSTO4,SD2->D2_CUSTO5},Nil,Nil,.F.,Nil,.T.,.F.)
		EndIf
	Case nEvento == 2 // Faz a Saida do Deposito de Transferencia
	    SD2->(DbSetOrder(3))
		If Empty(RetForFil(cFilOri)) .OR. !SD2->(MsSeek( xFilial("SD2")+SD1->D1_DOC+SD1->D1_SERIE+RetForFil(cFilOri)+SD1->D1_COD+SD1->D1_ITEMORI))
			Return .F.
		EndIf
		Reclock("SD2",.F.)
		D2_QTDAFAT -= SD1->D1_QUANT
		MsUnlock()
		SD3->(DbSetOrder(3))
		If SD3->( MsSeek( xFilial("SD3")+SD2->( D2_COD+cDepTrf+D2_NUMSEQ ) ) )
			SB1->(DbSetOrder(1))
			SB1->( MsSeek( xFilial("SB1")+SD1->D1_COD ) )
			AAdd(aCposSD3, {"D3_FILIAL" ,  xFilial("SD3")			,NIL } )
			AAdd(aCposSD3, {"D3_USUARIO",  SubStr(cUsuario,7,15)	,NIL } )
			AAdd(aCposSD3, {"D3_NUMSEQ" ,  SD1->D1_NUMSEQ			,NIL } )
			AAdd(aCposSD3, {"D3_TM"     , '999'          			,NIL } )
			AAdd(aCposSD3, {"D3_CF"     , 'RE4'          			,NIL } )
			AAdd(aCposSD3, {"D3_COD"    , SD1->D1_COD    			,NIL } )
			AAdd(aCposSD3, {"D3_ITEM"   , SD1->D1_ITEM  			,NIL } )
			AAdd(aCposSD3, {"D3_QUANT"  , SD1->D1_QUANT  			,NIL } )
			AAdd(aCposSD3, {"D3_UM"     , SD1->D1_UM     			,NIL } )
			AAdd(aCposSD3, {"D3_QTSEGUM", SD1->D1_QTSEGUM			,NIL } )
			AAdd(aCposSD3, {"D3_SEGUM"  , SD1->D1_SEGUM  			,NIL } )
			AAdd(aCposSD3, {"D3_LOCAL"  , cDepTrf        			,NIL } )
			AAdd(aCposSD3, {"D3_GRUPO"  , SB1->B1_GRUPO  			,NIL } )
			AAdd(aCposSD3, {"D3_TIPO"   , SB1->B1_TIPO   			,NIL } )
			AAdd(aCposSD3, {"D3_EMISSAO", SD1->D1_DTDIGIT			,NIL } )
			AAdd(aCposSD3, {"D3_DOC"    , SD1->D1_DOC    			,NIL } )
			AAdd(aCposSD3, {"D3_LOTECTL", SD1->D1_LOTECTL			,NIL } )
			AAdd(aCposSD3, {"D3_NUMLOTE", SD1->D1_NUMLOTE			,NIL } )
			AAdd(aCposSD3, {"D3_DTVALID", SD1->D1_DTVALID			,NIL } )
			AAdd(aCposSD3, {"D3_POTENCI", SD1->D1_POTENCI			,NIL } )
			AAdd(aCposSD3, {"D3_LOCALIZ", SD3->D3_LOCALIZ			,NIL } )
			AAdd(aCposSD3, {"D3_CHAVE"  , 'RTE'	          			,NIL } )
			If lTranSb2
				AAdd(aCposSD3, {"D3_CUSTO1" , SD1->D1_CUSTO 	   		,NIL } )
				AAdd(aCposSD3, {"D3_CUSTO2" , SD1->D1_CUSTO2   			,NIL } )
				AAdd(aCposSD3, {"D3_CUSTO3" , SD1->D1_CUSTO3  			,NIL } )
				AAdd(aCposSD3, {"D3_CUSTO4" , SD1->D1_CUSTO4 	  		,NIL } )
				AAdd(aCposSD3, {"D3_CUSTO5" , SD1->D1_CUSTO5   			,NIL } )
			EndIf
		    If !Empty(cPE)
				aRetPE:= ExecBlock(cPE,.F.,.F.,{aCposSD3,nEvento})
				If ValType(aRetPE) == "A"
			   		aCposSD3 := aClone(aRetPE)
				EndIf
	        EndIf
			// Grava SD3 de transferencia
			Reclock("SD3",.T.)
			AEval(aCposSD3,{|x,y| nPosCpo := FieldPos(x[1]),If(nPosCpo>0,FieldPut(nPosCpo,x[2]),) } )
			MsUnlock()
			// Atualiza o saldo atual (SB2) com os dados do SD3
			If lTranSb2
				B2AtuComD3({SD1->D1_CUSTO,SD1->D1_CUSTO2,SD1->D1_CUSTO3,SD1->D1_CUSTO4,SD1->D1_CUSTO5},Nil,Nil,.F.,Nil,.T.,.F.)
			EndIf
		EndIf
EndCase
Return .T.

/*
±±³Fun‡…o    ³ GerSD3Trf  ³±±
±±³Descri‡…o ³ Cria movimento no SD3 referente a transf.            	  ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                       		  ³±±
*/
Function NFHasSD2It(nReg)
Local cAlias,nIndex,cSeek,cWhile,cCondicao
Local aAreaSF2 := GetArea("SF2")
Local aAreaSD2 := GetArea("SD2")
Local aRecOri  := {}
Local lRet     := .F.

SF2->(MsGoto(nReg))
cAlias    := "SD2"
nIndex    := 3
cSeek     := "'" + SF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA) + "'"
cWhile    := "!EOF() .AND. D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA  == " + cSeek
cCondicao := "D2_TIPODOC == '54' .And. D2_QTDAFAT > 0 .And. D2_QTDAFAT == D2_QUANT .And. SD2->D2_ESPECIE == SF2->F2_ESPECIE"

aRecOri := LocxGrid(cAlias,cWhile,cCondicao,,,cSeek,nIndex,{'D2_COD'},,,,,,)
lRet    := (ValType(aRecOri)=="A" .AND. Len(aRecOri) >= 6 .AND. ValType(aRecOri[6])=="A" .AND. Len(aRecOri[6]) > 0)

RestArea(aAreaSF2)
RestArea(aAreaSD2)
Return lRet
/*
±±³Fun‡…o    ³RetFilFor ³±±
±±³Descri‡…o ³ Retorna o da filial de um fornec. X.       	              ³±±
±±³Uso       ³ LOCXNF Qdo Remitos de transf.                 	          ³±±
*/
Static Function RetFilFor(cFornece,cLoja)
Local cFilFor	:= ''
Local cChave	:= ''
Local cCodForLj	:= ''
Local nTamEmFil	:= Len(cFilAnt+cEmpAnt+cFilAnt)
Local nTamFil	:= Len(cFilAnt+cEmpAnt)
Local nTamForLj	:= TamSX3("A2_COD")[1] + TamSX3("A2_LOJA")[1]
Local lGestCorp	:= nTamEmFil > Len(SX5->X5_CHAVE)

If lGestCorp
	cChave := xFilial("SX5")+'75'
	SX5->(DbSeek(cChave,.T.))
	While cChave == SX5->(X5_FILIAL+X5_TABELA)
		If Substr(SX5->X5_DESCRI,1,nTamFil) == cFilAnt+cEmpAnt
			cCodForLj := SubStr(SX5->X5_DESCRI,nTamEmFil+1,nTamForLj)
			If cFornece+cLoja == cCodForLj
				cFilFor := Substr(SX5->X5_DESCRI,nTamFil+1,Len(cFilAnt))
				Exit
			EndIf
		EndIf
	    SX5->(DbSkip())
	EndDo
Else
	cChave := xFilial("SX5")+'75'+cFilAnt+cEmpAnt
	If !SX5->(MsSeek(cChave))
		Return NIL
	EndIf
	While cChave == Left(SX5->(X5_FILIAL+X5_TABELA+X5_CHAVE),Len(cChave))
		cCodForLj := SubStr(SX5->X5_DESCRI,1,nTamForLj)
		If cFornece+cLoja == cCodForLj
			cFilFor := Substr(SX5->X5_CHAVE,5,2)
			Exit
		EndIf
	    SX5->(DbSkip())
	EndDo
EndIf
Return cFilFor

/*
±±ºPrograma  ³GravaSE2  º±±
±±ºDesc.     ³Gravacao do SE2                                             º±±
*/
Static Function GRAVASE2(aDupl,dDEmissao,aFin)
Local nX
Local cPref		:= ""
Local nValDup	:=	0
Local nTotCruz	:=	0
Local nVlCruz	:=	0
Local nDupTot	:=	0
Local aRecSE2	:=	{}
Local lMultNat  := SuperGetMv("MV_MULNATP")
Local cCodAprov := ""
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local cQuery	:= ""
Local cAliasSE2 := ""
Local cE2Num    := ""
Local cFilE2    := xFilial("SE2")
Local cFornece	:= ""
Local aDuplMCur :=	{}	//(20/04/18): Array Value in main currency if was manually changes
Local aDuplTB   := {} //Tax bases array according to payment terms
Local nTaxRate  := 0
Local nTotTBVl  := 0
Local nTotVATV  := 0
Local nVlBasI   := 0
Local nVlVatI   := 0
//Local lCpoPlaid := SE2->(ColumnPos("E2_SLPLAID")) > 0

Private	nResIRRF := 0
Private	nResInss := 0
Private	nResIss  := 0

If cPaisLoc=="RUS"
	dDEmissao	:= Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_EMISSAO,SF2->F2_DTSAIDA)
	aDuplMCur	:= Condicao(Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_VLBRUTM,SF2->F2_VLBRUTM),cCondicao,,dDEmissao)
	aDuplTB		:= Condicao(Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_BASIMP1,SF2->F2_BASIMP1),cCondicao,,dDEmissao)
EndIf
//³ Inicializa a Natureza ³

DEFAULT cNatureza := ""
If !Empty(SuperGetMV("MV_2DUPREF"))
	cPref := &(SuperGetMV("MV_2DUPREF"))
Endif
cPref := If(Empty(cPref),CriaVar("SF1->F1_PREFIXO"),cPref)
cPref := IIf(aCfgNf[SAliasHead]=="SF1",cPref,cSerie)

If lUsaNewKey
	/*CHAVE UNICA - Alterado por Tiago Silva*/
	cE2Num:=Extrae(aDupl[1],2)
	cFilE2:=xFilial("SE2")
	cAliasSE2 := "ALOCXPRFX"
	cQuery := " SELECT MAX(E2_PREFIXO) E2PRFXMAX FROM " + RetSqlName("SE2")
	cQuery += " WHERE E2_FILIAL = '" + cFilE2 + "'"
	cQuery += " AND E2_NUM      = '" + cE2Num + "'"
	cQuery += " AND E2_FORNECE = '" + SA2->A2_COD + "'"
	cQuery += " AND E2_LOJA     = '" + SA2->A2_LOJA + "'"
	cQuery += " AND D_E_L_E_T_  = ''"
   	cQuery	  := ChangeQuery(cQuery)
	cAliasSE2 := CriaTrab(Nil,.F.)

	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasSE2, .T., .T. )
	DbSelectArea(cAliasSE2)

	If !Empty( (cAliasSE2)->E2PRFXMAX )
		cPref:= Soma1( (cAliasSE2)->E2PRFXMAX , TamSX3("E2_PREFIXO")[1] )
		While .T.
			SE2->(dbSetOrder(1))
			If (SE2->(dbSeek(cFilE2+cPref+cE2Num)))
				cPref:= Soma1(cPref, TamSX3("E2_PREFIXO")[1])
			Else
				EXIT
			EndIf
		EndDo
	ElseIf Empty( (cAliasSE2)->E2PRFXMAX ) .AND. cPaisLoc == "PER" .AND. empty(substr(&(SuperGetMV("MV_2DUPREF")),1,TamSX3("E2_PREFIXO")[1]))
		cPref:= Soma1(" ")
	EndIf
	(cAliasSE2)->(DbCloseArea())
Endif


If Empty(cNatureza).AND. !Empty(SuperGetMV("MV_2DUPNAT"))
	cNatureza := &(SuperGetMV("MV_2DUPNAT"))
	cNatureza := If(Empty(cNatureza),Criavar(IIf(cPaisLoc == "RUS" .And. aCfgNf[SAliasHead]=="SF2","SF2->F2_NATUREZ","SF1->F1_NATUREZ")),cNatureza)
	MaFisAlt("NF_NATUREZA",cNatureza)
	aFin[ScNatureza] := cNatureza
EndIf
cPref+=Space(Len(SE2->E2_PREFIXO) - Len(cPref))

//³Obtem o codigo do aprovador atraves do parametro MV_FINAPXX ³
//³(onde XX é a moeda em questao)                              ³

cCodAprov := FA050Aprov(aFin[SnMoedaFin])
If cPaisLoc == "RUS"
	nTaxRate := RU09XFUN08(Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_VALIMP1,SF2->F2_VALIMP1)/*nTaxAmnt*/,;
									Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_BASIMP1,SF2->F2_BASIMP1)/*nTaxBase*/)  //LocxNF2.PRW 21 dec 2018
EndIf

For nX := 1 to Len(aDupl)
	If ! lFacImport
		nValDup := DesTrans(Extrae(aDupl[nx],5))
	Else
        nValDup := aDupl[nX][5]
    EndIf
	dbSelectArea("SE2")

		If AllTrim(cCodAprov) == ""
			cCodAprov := Fa006User( __cUserID, .F., 2, aFin[SnMoedaFin])
		EndIf

	RecLock("SE2",.T.)
	Replace E2_FILORIG With cFilAnt
	Replace	E2_FILIAL  With xFilial()
	Replace E2_PREFIXO With cPref
	Replace E2_EMISSAO With dDEmissao
	Replace E2_EMIS1   With dDataBase
	Replace	E2_FORNECE With SA2->A2_COD
	Replace	E2_LOJA    With SA2->A2_LOJA
	Replace	E2_NOMFOR  With SA2->A2_NREDUZ
	Replace	E2_TIPO    With aCfgNf[ScEspecie]
	Replace E2_MOEDA   With aFin[SnMoedaFin]
	Replace	E2_LA      With "S"

	If (cPaisLoc == "RUS")
		//start supplement wrided 18/07/2017
		cFornece:=SA2->A2_COD
		E2_CONUNI := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_CONUNI,SF2->F2_CONUNI)
		E2_MOEDA  := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_MOEDA,SF2->F2_MOEDA)
		E2_F5QCODE := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_CNTID,SF2->F2_CNTID)
		E2_F5QUID := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_F5QUID,SF2->F2_F5QUID)

		SA6->(DbSetOrder(5))
		If SA6->(DbSeek(xFilial("SA6")+"1"))
			Replace	E2_PORTADO With SA6->A6_COD
		Endif

		FIL->(dbSetOrder(1))
		If FIL->(dbSeek(xFilial('FIL') + cFornece))

			Replace	E2_FORBCO With FIL->FIL_BANCO
			Replace	E2_FORAGE With FIL->FIL_AGENCI
			Replace	E2_FORCTA With FIL->FIL_CONTA

		EndIf
		Replace	E2_ALQIMP1	With nTaxRate //18 dec 2018
		//end supplement wrided 18/07/2017
	Endif

	If !lFACImport
		Replace E2_NUM     With Iif(Extrae(aDupl[nx],2)<> cNFiscal,cNFiscal,Extrae(aDupl[nx],2))
		Replace	E2_PARCELA With AllTrim(Extrae(aDupl[nx],3))
		Replace	E2_VENCORI With Ctod(Extrae(aDupl[nx],4))
		Replace	E2_VENCTO  With Ctod(Extrae(aDupl[nx],4))
		Replace	E2_VENCREA With DataValida(Ctod(Extrae(aDupl[nx],4)),.T.)
	Else
		Replace E2_NUM     With cNFiscal
		Replace	E2_PARCELA With aDupl[nx][2]
		Replace	E2_VENCORI With aDupl[nx][4]
		Replace	E2_VENCTO  With aDupl[nx][4]
		Replace	E2_VENCREA With DataValida(aDupl[nx][4],.T.)
	EndIf
	Replace	E2_VALOR   With nValDup
	Replace	E2_SALDO   With nValDup
	Replace	E2_NATUREZ With aFin[ScNatureza]
	Replace	E2_ORIGEM  With cFunName
	if cPaisLoc == "RUS"
		nTaxa := Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_TXMOEDA,SF2->F2_TXMOEDA)
	EndIf
	Replace	E2_TXMOEDA With nTaxa
	if cPaisLoc == "COL"
		Replace E2_TRMPAC With If(aCfgNF[SAliasHead] == "SF1",CVALTOCHAR(SF1->F1_TRMPAC),CVALTOCHAR(SF2->F2_TRMPAC))
	endif
	If cPaisLoc == "CHI"
		Replace  E2_CGC	With SA2->A2_CGC
	EndIf
	Replace E2_CODAPRO With cCodAprov
	Replace E2_STATLIB With "01"
	If cPaisLoc == "RUS"
		nDupTot	+=	SE2->E2_VALOR
	EndIf
	If nX == Len(aDupl)
		If cPaisLoc	== "RUS"
			nVlCruz := Round((Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_VLBRUTM,SF2->F2_VLBRUTM) - nTotCruz),MsDecimais(1))
			nVlBasI := Round((Iif(aCfgNf[SAliasHead]=="SF1",SF1->F1_BASIMP1,SF2->F2_BASIMP1) - nTotTBVl),MsDecimais(1))
			nVlVatI := Round((nDupTot         - nTotTBVl - nVlBasI - nTotVATV),MsDecimais(1))
		Else
			nVlCruz := Round( Abs(xMoeda(MaFisRet(,'NF_BASEDUP'),nMoedaNF,1,dDataBase,MsDecimais(1)+1,nTaxa)) - Abs(nTotCruz), MsDecimais(1))
		EndIf
	Else
		If cPaisLoc	== "RUS"
			nVlCruz := aDuplMCur[nx][2]
			nVlBasI := aDuplTB[nx][2]
			nVlVatI := nValDup - nVlBasI
		Else
			If cPaisLoc	== "ARG"
				nVlCruz := ArgVlCruz("SE2", nMoedaNF, nTaxa)
			Else
				nVlCruz := Round(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,IIF(nMoedaNF==SE2->E2_MOEDA,0,nTaxa)),MsDecimais(1))
			EndIf
		EndIf
	Endif
	If cPaisLoc=="PER"
		If aCfgNf[SAliasHead]=="SF1"
			SerieNfId("SE2",1,"E2_SERORI",,,,SF1->F1_SERORI) //Projeto Chave Unica - Tiago Silva
	    Else
	    	SerieNfId("SE2",1,"E2_SERORI",,,,SF2->F2_SERORI) //Projeto Chave Unica - Tiago Silva
	    EndIf
	EndIf
	If cPaisLoc == "EUA"
		GrvSE2EUA(cFunname)
	EndIf
	nTotCruz += nVlCruz
	dbSelectArea("SE2")
	If cPaisLoc == "RUS"
			nTotTBVl += nVlBasI
			nTotVATV += nVlVatI
			SE2->E2_BASIMP1 := nVlBasI
			SE2->E2_VALIMP1 := nVlVatI
	EndIf

	If lMultNat
		//³ Verifica se foi gerada multinatureza para o titulo ³

		If GRAVASEV("SE2",nValDup)
			SE2->E2_MULTNAT := "1"
		EndIf
	EndIf

	a050DupPag(Iif(cFunName=="MATA101N","MATA100",cFunName),(nX==1),0)
	SE2->E2_VLCRUZ := nVlCruz
	If SE2->(ColumnPos('E2_CCR'))>0  .AND. aCfgNf[SAliasHead]=="SF1" .and. SF1->(ColumnPos("F1_CC")) > 0 .and. !Empty(SF1->F1_CC)
		SE2->E2_CCR :=SF1->F1_CC
	ElseIf SE2->(ColumnPos('E2_CCR'))>0 .AND. aCfgNf[SAliasHead]=="SF2" .and. SF2->(ColumnPos("F2_CC")) > 0 .and. !Empty(SF2->F2_CC)
		SE2->E2_CCR :=SF2->F2_CC
	EndIf
	If cPaisLoc <> "RUS"
		nDupTot	+=	SE2->E2_VALOR
	EndIf
	AAdd(aRecSE2,SE2->(Recno()))
Next nx
nDupTot	:=	xMoeda(nDupTot,aFin[SnMoedaFin],nMoedaNF,dDataBase,,,nTaxa)
Return {aRecSE2,{nDupTot,cPref,SE2->E2_NUM}}
/*
±±ºPrograma  ³GravaSE1  º±±
±±ºDesc.     ³Gravacao do SE1                                             º±±
*/
Static Function GRAVASE1(aDupl,aRecnoI,aFin)
Local nX,j,nY
Local cPref		:= ""
Local nValDup	:=	0
Local nTotCruz	:=	0
Local nVlCruz	:=	0
Local aVend 	:= {}
LOCAL bVend 	:= { |x| "SE1->E1_VEND"  + Str(x,1) }
LOCAL bVendF1 	:= { |x| If(SF1->(FieldPos("F1_VEND"+ Str(x,1)))>0,"SF1->F1_VEND"+ Str(x,1),"''") }
LOCAL bVendF2 	:= { |x| If(SF2->(FieldPos("F2_VEND"+ Str(x,1)))>0,"SF2->F2_VEND"+ Str(x,1),"''") }
LOCAL bPerComis:= { |x| "SE1->E1_COMIS" + Str(x,1) }
Local nQtdVend	:=	Fa440CntVen()
Local aRecSE1	:=	{}
Local nDupTot	:=	0
Local cVend		:=	""
Local lMultNat  := SuperGetMv("MV_MULNATR")
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local cQuery	:= ""
Local cAliasSE1 := ""
Local cE1Num    := ""
Local cFilE1    := xFilial("SE1")
//Local aDupl1 	:=	{}	//(20/04/18): Array Value in main currency if was manually changes
//Local lCpoPlaid := SE1->(ColumnPos("E1_SLPLAID")) > 0


DEFAULT cNatureza := ""
If cPaisLoc=="RUS"
	dDEmissao:= Iif(aCfgNf[SAliasHead]=="SF2", SF2->F2_DTSAIDA, SF1->F1_EMISSAO)
	aDuplMCur   := Condicao(Iif(aCfgNf[SAliasHead]=="SF2", SF2->F2_VLBRUTM, SF1->F1_VLBRUTM),cCondicao,,dDEmissao)
	aDuplTB  := Condicao(Iif(aCfgNf[SAliasHead]=="SF2",SF2->F2_BASIMP1,SF1->F1_BASIMP1),cCondicao,,dDEmissao)
EndIf
If !Empty(SuperGetMV("MV_1DUPREF"))
	cPref := &(SuperGetMV("MV_1DUPREF"))
Endif
cPref := If(Empty(cPref),CriaVar("SF2->F2_PREFIXO"),cPref)

//Ajsute para generar Financiero en emisión de Remito
If cPaisLoc == "EUA" .And. aCfgNf[8] == 'RFN'
	cPref := cSerie
	aCfgNf[ScEspecie] := 'PRE'
Else
	cPref := IIf(aCfgNf[SAliasHead]=="SF2",cPref,cSerie)
EndIf

If lUsaNewKey
	/*CHAVE UNICA - Alterado por Tiago Silva*/
	cE1Num:=Extrae(aDupl[1],2)
	cFilE1:=xFilial("SE1")
	cAliasSE1 := "ALOCXPRFX"
	cQuery := " SELECT MAX(E1_PREFIXO) E1PRFXMAX FROM " + RetSqlName("SE1")
	cQuery += " WHERE E1_FILIAL = '" + cFilE1 + "'"
	cQuery += " AND E1_NUM      = '" + cE1Num + "'"
	cQuery += " AND D_E_L_E_T_  = ''"
   	cQuery	  := ChangeQuery(cQuery)
	cAliasSE1 := CriaTrab(Nil,.F.)

	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasSE1, .T., .T. )
	DbSelectArea(cAliasSE1)

	If !Empty( (cAliasSE1)->E1PRFXMAX )
		cPref:= Soma1( (cAliasSE1)->E1PRFXMAX , TamSX3("E1_PREFIXO")[1] )
		While .T.
			SE1->(dbSetOrder(1))
			If (SE1->(dbSeek(cFilE1+cPref+cE1Num)))
				cPref:= Soma1(cPref, TamSX3("E1_PREFIXO")[1])
			Else
				EXIT
			EndIf
		EndDo
	ElseIf Empty( (cAliasSE1)->E1PRFXMAX ) .AND. cPaisLoc == "PER" .AND. empty(substr(&(SuperGetMV("MV_1DUPREF")),1,TamSX3("E1_PREFIXO")[1]))
		cPref:= Soma1(" ")
	EndIf
	(cAliasSE1)->(DbCloseArea())
Endif

If Empty(cNatureza) .AND. !Empty(SuperGetMV("MV_1DUPNAT"))
	cNatureza := &(SuperGetMV("MV_1DUPNAT"))
	cNatureza := If(Empty(cNatureza),Criavar("SF2->F2_NATUREZ"),cNatureza)
	MaFisAlt("NF_NATUREZA",cNatureza)
	aFin[ScNatureza] := cNatureza
EndIf
cPref+=Space(Len(SE1->E1_PREFIXO) - Len(cPref))
//Determinar os vendedores quando se trata de uma devolucao
If aCfgNF[ScTipoDoc] == "D"
	For nY := 1	To Len(aRecnoI)
		SD1->(MsGoTo(aRecnoI[nY,1]))
		If !Empty(SD1->D1_NFORI) .AND. Len(aVend)<= nQtdVend
			For nX:= 1 to nQtdVend
				DbSelectArea ("SF2")
				DbSetOrder(1)
				MsSeek(xFilial("SF2")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA)
				//Para garantir que se nao se trata de uma nota de beneficiamento ou devolucao com a mesma numeracao
				While !Eof() .AND. xFilial("SF2")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA == ;
						F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA
					If !F2_TIPO $ 'DB'
						If !Empty(&("SF2->F2_VEND" + Str(nX,1)))
							If Ascan(aVend,{|x| x[1]==&("SF2->F2_VEND" + Str(nX,1))}) == 0
								dbSelectArea("SD2")
								dbSetOrder(3)
								MsSeek(xfilial("SD2")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD)
								While !Eof() .AND. xFilial("SD2")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD== ;
     									D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD
									//Para garantir que se trata do D2 relativo ao SF2
									If Alltrim(D2_ITEM)== Alltrim(SD1->D1_ITEMORI) .AND. D2_TIPO == SF2->F2_TIPO
										AAdd(aVend,{&("SF2->F2_VEND" + Str(nX,1)),&("SD2->D2_COMIS" + Str(nX,1))} )
										Exit
									Endif
									DbSkip()
								End
							EndIf
						Endif
						Exit
					Endif
					DbSelectArea('SF2')
					DbSkip()
				End
			Next
		Endif
	Next
	//³Pegar os vendedores que possam ter sido informados no cabecalho e ³
	If Len(aVend)<= nQtdVend
		For nX:=1 To nQtdVend
			cVend	:=	&(Eval(bVendF1,nX))
			If !Empty(cVend)
				DbSelectArea("SA3")
				DbSetOrder(1)
				If MsSeek(xFilial("SA3")+cVend)
					If Ascan(aVend,{|x| x[1] == cVend}) == 0
						Aadd(aVend,{SA3->A3_COD,SA3->A3_COMIS} )
					Endif
				Endif
			Endif
		Next
	EndIf
Else
	//³Pegar os vendedores informados no cabecalho  ³
	If Len(aVend)<= nQtdVend
		For nX:=1 To nQtdVend
			cVend	:=	&(Eval(bVendF2,nX))
			If !Empty(cVend)
				DbSelectArea("SA3")
				DbSetOrder(1)
				If MsSeek(xFilial("SA3")+cVend)
					If Ascan(aVend,{|x| x[1] == cVend}) == 0
						Aadd(aVend,{SA3->A3_COD,SA3->A3_COMIS} )
					Endif
				Endif
			Endif
		Next
	EndIf
Endif

If !(FunName() $ 'FINA074|FINA846' .Or.(cPaisLoc=="ARG" .And. IsInCallStack("FINA998") )) .or.  (cPaisloc=="ARG" .and. Type("lFina935")<> "U" .And. lFina935    )
	SE4->(DbSeek(xFilial("SE4")+cCondicao))
	If cPaisLoc	== "RUS"
		TaxRate := RU09XFUN08(IIf(aCfgNf[SAliasHead]=="SF2",SF2->F2_VALIMP1,SF1->F1_VALIMP1)/*nTaxAmnt*/,;
										IIf(aCfgNf[SAliasHead]=="SF2",SF2->F2_BASIMP1,SF1->F1_BASIMP1)/*nTaxBase*/)  //LocxNF2.PRW
	EndIf
	For nX := 1 to Len(aDupl)
		nValDup := DesTrans(Extrae(aDupl[nx],5))
		dbSelectArea("SE1")
		RecLock("SE1",.T.)
		Replace	E1_FILIAL  	With xFilial()
		Replace E1_PREFIXO 	With cPref
		Replace E1_EMISSAO 	With Iif(cPaisLoc <> "RUS",IIf(aCfgNf[SAliasHead]=="SF2", SF2->F2_EMISSAO, SF1->F1_EMISSAO), dDEmissao)
		Replace E1_EMIS1   	With dDataBase
		Replace	E1_CLIENTE 	With SA1->A1_COD
		Replace	E1_LOJA    	With SA1->A1_LOJA
		Replace	E1_NOMCLI  	With SA1->A1_NREDUZ
		Replace	E1_TIPO    	With aCfgNf[ScEspecie]
		Replace E1_MOEDA   	With aFin[SnMoedaFin]
		Replace E1_TXMOEDA	With nTaxa
		If (cPaisLoc == "PER" .And. !VerPadrao('500')) .Or. cPaisloc <> "PER"
			Replace E1_LA   With "S"
		EndIf
		Replace E1_NUM     	With  IIf(Extrae(aDupl[nx],2)<> cNFiscal,cNFiscal,Extrae(aDupl[nx],2))
		SerieNfId("SE1",1,"E1_SERIE",,,,IIf(aCfgNF[SAliasHead] == "SF1",SF1->F1_SERIE,SF2->F2_SERIE)) // Projeto chave unica - Tiago Silva
		Replace	E1_PARCELA 	With AllTrim(Extrae(aDupl[nx],3))
		Replace	E1_VENCORI 	With Ctod(Extrae(aDupl[nx],4))
		Replace	E1_VENCTO  	With Iif(cPaisLoc <> "RUS",Ctod(Extrae(aDupl[nx],4)),aDuplMCur[nX][1])
		Replace	E1_VENCREA 	With DataValida(Iif(cPaisLoc <> "RUS",Ctod(Extrae(aDupl[nx],4)), aDuplMCur[nX][1]),.T.)
		Replace	E1_VALOR   	With nValDup
		Replace	E1_SALDO   	With nValDup
		Replace	E1_NATUREZ 	With aFin[ScNatureza]
		Replace E1_SITUACA 	With "0"
		Replace E1_STATUS	With "A"
		Replace E1_DESCFIN  With SE4->E4_DESCFIN
		Replace E1_DIADESC  With SE4->E4_DIADESC
		If cPaisLoc == "COL"
			Replace E1_TRMPAC   With If(aCfgNF[SAliasHead] == "SF1",CVALTOCHAR(SF1->F1_TRMPAC),CVALTOCHAR(SF2->F2_TRMPAC))
		EndIf
		If cPaisLoc == "CHI"
			Replace  E1_CGC	With SA1->A1_CGC
		EndIf
		If cPaisLoc == "RUS"
			E1_CONUNI  := Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_CONUNI,SF2->F2_CONUNI)
		    E1_MOEDA   := Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_MOEDA,SF2->F2_MOEDA)
			E1_ALQIMP1 := TaxRate
			E1_F5QCODE := Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_CNTID,SF2->F2_CNTID)
			E1_F5QUID := Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_F5QUID,SF2->F2_F5QUID)
			nDupTot	+=	SE1->E1_VALOR
		EndIf
		If nX == Len(aDupl)
			If cPaisLoc	== "RUS"
				nVlCruz := Round((Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_VLBRUTM,SF2->F2_VLBRUTM) - nTotCruz),MsDecimais(1))
				nVlBasI := Round((Iif(aCfgNF[SAliasHead] == "SF1",SF1->F1_BASIMP1,SF2->F2_BASIMP1) - nTotTBVl),MsDecimais(1))
				nVlVatI := Round((nDupTot         - nTotTBVl - nVlBasI - nTotVATV),MsDecimais(1))
			Else
				nVlCruz := Round( Abs(xMoeda(MaFisRet(,'NF_BASEDUP'),nMoedaNF,1,dDataBase,MsDecimais(1)+1,nTaxa)) - Abs(nTotCruz), MsDecimais(1) )
			EndIf
		Else
			If cPaisLoc	== "RUS"
				nVlCruz := aDuplMCur[nx][2]
				nVlBasI := aDuplTB[nx][2]
				nVlVatI := nValDup	 - nVlBasI
			ElseIf cPaisLoc == "ARG"
				nVlCruz := ArgVlCruz("SE1", nMoedaNF, nTaxa)
			Else
				nVlCruz := Round(xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,MsDecimais(1)+1,IIF(nMoedaNF==SE1->E1_MOEDA,0,nTaxa)),MsDecimais(1))
			EndIf
		Endif
		If cPaisLoc == "EUA"
			GrvSE1EUA(cFunName)
		EndIf
		nTotCruz += nVlCruz
		If cPaisLoc == "RUS"
			nTotTBVl += nVlBasI
			nTotVATV += nVlVatI
		EndIf
		dbSelectArea("SE1")
		SE1->E1_VLCRUZ := nVlCruz
		If cPaisLoc == "RUS"
			SE1->E1_BASIMP1 := nVlBasI
			SE1->E1_VALIMP1 := nVlVatI
		EndIf
		dbSelectArea("SE1")
		If Len(aVend) >0
			For j:=1 To Len(aVend)
				Replace &(EVAL(bVend,j))      With aVend[j][1]
				Replace &(EVAL(bPerComis,j))  With aVend[j][2]
			Next j
		Endif
		If lMultNat
			If GRAVASEV("SE1",nValDup)
				SE1->E1_MULTNAT := "1"
			EndIf
		EndIf
		If Type("lFina935")<> "U" .And. lFina935
			cFunName:="MATA465N"
		EndIf
		MsUnLock()
		If SE1->E1_TIPO $ MV_CRNEG      // Resta
			dbSelectArea( "SA1" )
			AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,,SE1->E1_EMISSAO)
		EndIf
		a040DupRec(cFunName,(nX==1))
		If cPaisLoc <> "RUS"
			nDupTot	+=	SE1->E1_VALOR
		EndIf
		AAdd(aRecSE1,SE1->(Recno()))
	Next nx
	nDupTot	:=	xMoeda(nDupTot,aFin[SnMoedaFin],nMoedaNF,dDataBase,,,nTaxa)
EndIf
Return {aRecSE1,{nDupTot,cPref,SE1->E1_NUM}}

/*
±±ºPrograma  ³BaixAutSE1º±±
±±ºDesc.     ³Baixa dos titulos com pagamento a vista                     º±±
±±³Parametros³ cCond     = Condicao de pagamento                          ³±±
±±³          ³ aRecno    = Array com os numeros dos registros gravados no ³±±
±±³          ³             SE1                                            ³±±
±±³          ³ aCaixaFin = Array com o codigo do banco para a baixa       ³±±
±±³          ³             [1] = codigo do banco                          ³±±
±±³          ³             [2] = codigo da agencia                        ³±±
±±³          ³             [3] = codigo da conta                          ³±±
*/
Function BaixAutSE1(cCond,aRecno,aCaixaFin,cAlias,lVdaAst)
Local aArea	 :=	{}
Local nRecSE4:= 0
Local nRecSE :=	0
Local aBaixa :=	{}
Local cHist	 :=	""
Local cMotBx :=	""
Local cFunOrig := IIf(Type("cFunName")=="C",cFunName,Upper(FunName()))  //Funcao Origem
Local nRec	 :=	0
Local dVcto  := dDataBase
Local lNegociada  := ((nModulo == 12 .OR. nModulo == 23 .OR. nModulo == 5 .OR. nModulo == 72) .AND. AllTrim(cCond) == "CN")
Local lCaixinha	:= .F.

Default cAlias:="SE1"
Default lVdaAst  := .F.

nRecSE4:=SE4->(Recno())
If !lNegociada
	SE4->(DbSeek(xFilial("SE4")+cCond))
EndIf

If cAlias == "SE2" .And. cPaisLoc == "CHI"
	If Type("cCxCaixa")!="U" .And. Type("nCxValor")!="U" .And. !Empty(cCxCaixa) .And. !Empty(nCxValor)
		lCaixinha := .T.
	Endif
Endif
If lNegociada .OR. SE4->E4_BXTITAV == "1" .OR. lCaixinha
	aArea:=GetArea()
	cMotBx := If(lCaixinha,"DAC","NOR")
	cHist := If(lCaixinha,STR0130,STR0208)
    DbSelectArea(cAlias)
    nRecSE:=Recno()
	For nRec:=1 To Len(aRecno)
		MsGoto(aRecno[nRec])
		If IIf(lNegociada, !AllTrim(SE1->E1_TIPO) $ GetMV("MV_LJBXPAG",,""),.F.)
		   Loop
		EndIf
		If cAlias=="SE1"
			dVcto:=SE1->E1_VENCORI
		Else
			dVcto:=SE2->E2_VENCORI
		Endif
		If (dVcto<=dDataBase) .Or. lCaixinha
			aBaixa:={}
			If cAlias=="SE1"
				AADD(aBaixa,{"E1_PREFIXO" 	,E1_PREFIXO			, Nil})	// 01
				AADD(aBaixa,{"E1_NUM"     	,E1_NUM				, Nil})	// 02
				AADD(aBaixa,{"E1_PARCELA" 	,E1_PARCELA			, Nil})	// 03
				AADD(aBaixa,{"E1_TIPO"    	,E1_TIPO			, Nil})	// 04
				AADD(aBaixa,{"E1_MOEDA"    	,E1_MOEDA			, Nil})	// 05
				AADD(aBaixa,{"E1_TXMOEDA"	,E1_TXMOEDA			, Nil})	// 06
				AADD(aBaixa,{"E1_ORIGEM"	,cFunOrig			, Nil})	// 07
				AADD(aBaixa,{"AUTVALREC"	,0         			, Nil})	// 06
				AADD(aBaixa,{"AUTMOTBX"  	,cMotBx				, Nil})	// 07
				AADD(aBaixa,{"AUTDTBAIXA"	,dDataBase			, Nil})	// 08
				AADD(aBaixa,{"AUTDTCREDITO"	,dDataBase			, Nil})	// 09
				AADD(aBaixa,{"AUTHIST"   	,cHist				, Nil})	// 10
				AADD(aBaixa,{"AUTBANCO"  	,aCaixaFin[1]		, Nil})	// 11
				AADD(aBaixa,{"AUTAGENCIA"  	,aCaixaFin[2]		, Nil})	// 12
				AADD(aBaixa,{"AUTCONTA"  	,aCaixaFin[3]		, Nil})	// 13
				MSExecAuto({|x,y| FINA070(x,y)},aBaixa,3)
			Else
				AADD( aBaixa, { "E2_PREFIXO" 	, E2_PREFIXO	, Nil } )	// 01
				AADD( aBaixa, { "E2_NUM"     	, E2_NUM		, Nil } )	// 02
				AADD( aBaixa, { "E2_PARCELA" 	, E2_PARCELA	, Nil } )	// 03
				AADD( aBaixa, { "E2_TIPO"    	, E2_TIPO		, Nil } )	// 04
				AADD( aBaixa, { "E2_FORNECE"	, E2_FORNECE	, Nil } )	// 05
				AADD( aBaixa, { "E2_LOJA"    	, E2_LOJA		, Nil } )	// 06
				AADD( aBaixa, { "E2_MOEDA"    	, E2_MOEDA		, Nil }	)	// 05
				AADD( aBaixa, { "E2_TXMOEDA"	, E2_TXMOEDA	, Nil } )	// 06
				AADD( aBaixa, { "E2_ORIGEM"		, cFunOrig		, Nil } )	// 07
				AADD( aBaixa, { "AUTMOTBX"  	, cMotBx		, Nil } )	// 08
				If lCaixinha
					AADD( aBaixa, { "AUTBANCO"  	, "   "	, Nil } )	// 09
					AADD( aBaixa, { "AUTAGENCIA"  	, "   "	, Nil } )	// 10
					AADD( aBaixa, { "AUTCONTA"  	, "   "	, Nil } )	// 11
				Else
					AADD( aBaixa, { "AUTBANCO"  	, aCaixaFin[1]	, Nil } )	// 09
					AADD( aBaixa, { "AUTAGENCIA"  	, aCaixaFin[2]	, Nil } )	// 10
					AADD( aBaixa, { "AUTCONTA"  	, aCaixaFin[3]	, Nil } )	// 11
				Endif
				AADD( aBaixa, { "AUTDTBAIXA"	, dDataBase		, Nil } )	// 12
				AADD( aBaixa, { "AUTHIST"   	, cHist			, Nil } )	// 13
				AADD( aBaixa, { "AUTDESCONT" 	, 0				, Nil } )	// 14
				AADD( aBaixa, { "AUTMULTA"	 	, 0				, Nil } )	// 15
				AADD( aBaixa, { "AUTJUROS" 		, 0				, Nil } )	// 16
				AADD( aBaixa, { "AUTOUTGAS" 	, 0				, Nil } )	// 17
				AADD( aBaixa, { "AUTVLRPG"  	, 0        		, Nil } )	// 18
				AADD( aBaixa, { "AUTVLRME"  	, 0				, Nil } )	// 19
				MSExecAuto({|x,y| Fina080(x,y)},aBaixa,3)
			Endif
		Endif
	Next
	MsGoto(nRecSE)
	RestArea(aArea)
Endif
SE4->(MsGoto(nrecSE4))
Return

/*
±±ºPrograma  ³CaBxAutSE1º±±
±±ºDesc.     ³Cancela a baixa dos titulos com pagamento a vista  para a   º±±
±±º          ³exclusao da NF.      			                              º±±
*/
Function CaBxAutSE1(cAlias,cCond,cAliasC)
Local aArea	:= {}
Local aSE1	:= {}
Local aTempSE := {}
Local aBaixa:= {}
Local lOk := .F.
Local cChSE:= ""
Local lNegociada  := Iif(ValType(cCond)#"U",((nModulo == 12 .OR. nModulo == 72 ) .AND. AllTrim(cCond) == "CN"),.F.)
Local lCaixinha	:= .F.

Default cAlias:="SE1"
Default cAliasC:=If(cAlias=="SE1","SF2","SF1")

If cAlias == "SE2" .And. cPaisLoc == "CHI"
	If Type("cCxCaixa")!="U" .And. Type("nCxValor")!="U" .And. !Empty(cCxCaixa) .And. !Empty(nCxValor)
		lCaixinha := .T.
	Endif
Endif

If IIf(lNegociada,.T.,SE4->E4_BXTITAV=="1") .Or. lCaixinha
	aArea:=GetArea()
	If cAlias=="SE1"
		DbSelectArea("SE1")
		aSE1:=GetArea()
		DbSetorder(2)
		If cAliasC=="SF2"
			cChSE:=xFilial("SE1")+SF2->F2_CLIENTE+SF2->F2_LOJA+SF2->F2_PREFIXO+SF2->F2_DUPL
		Else
			cChSE:=xFilial("SE1")+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_PREFIXO+SF1->F1_DUPL
		Endif
	Else
		DbSelectArea("SE2")
		aSE1:=GetArea()
		DbSetorder(6)
		If cAliasC=="SF2"
			cChSE:=xFilial("SE2")+SF2->F2_CLIENTE+SF2->F2_LOJA+SF2->F2_PREFIXO+SF2->F2_DUPL
		Else
			cChSE:=xFilial("SE2")+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_PREFIXO+SF1->F1_DUPL
		Endif
	Endif
	If DbSeek(cChSE)
		While If(cAlias=="SE1",(E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM),;
				(E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM))==cChSE
			If cAlias=="SE1"
				lOK:=E1_VENCORI==E1_EMISSAO .AND. !Empty(E1_BAIXA) .AND. !IsMoney(E1_TIPO)
			Else
				lOK:=(E2_VENCORI==E2_EMISSAO .OR. lCaixinha) .AND. !Empty(E2_BAIXA) .AND. !IsMoney(E2_TIPO)
			Endif
			If lOk
				aBaixa:={}
				aTempSE := (cAlias)->(GetArea())
				If cAlias=="SE1"
					AADD(aBaixa,{"E1_PREFIXO" 	,E1_PREFIXO			, Nil})	// 01
					AADD(aBaixa,{"E1_NUM"     	,E1_NUM				, Nil})	// 02
					AADD(aBaixa,{"E1_PARCELA" 	,E1_PARCELA			, Nil})	// 03
					AADD(aBaixa,{"E1_TIPO"    	,E1_TIPO			, Nil})	// 04
					AADD(aBaixa,{"E1_MOEDA"    	,E1_MOEDA			, Nil})	// 05
					AADD(aBaixa,{"E1_TXMOEDA"	,E1_TXMOEDA			, Nil})	// 06
					AADD(aBaixa,{"E1_CLIENTE"	,E1_CLIENTE			, Nil})	// 06
					AADD(aBaixa,{"E1_LOJA"		,E1_LOJA			, Nil})	// 06
					If SE4->E4_BXTITAV=="2"
					   MSExecAuto({|x,y| FINA070(x,y)},aBaixa,5)
					Else
					  MSExecAuto({|x,y| FINA070(x,y)},aBaixa,6)
					Endif
				Else
					AADD(aBaixa,{"E2_PREFIXO" 	,E2_PREFIXO			, Nil})	// 01
					AADD(aBaixa,{"E2_NUM"     	,E2_NUM				, Nil})	// 02
					AADD(aBaixa,{"E2_PARCELA" 	,E2_PARCELA			, Nil})	// 03
					AADD(aBaixa,{"E2_TIPO"    	,E2_TIPO			, Nil})	// 04
					AADD(aBaixa,{"E2_FORNECE"	,E2_FORNECE			, Nil})	// 05
					AADD(aBaixa,{"E2_LOJA"    	,E2_LOJA			, Nil})	// 06
					AADD(aBaixa,{"E2_MOEDA"    	,E2_MOEDA			, Nil})	// 07
					AADD(aBaixa,{"E2_TXMOEDA"	,E2_TXMOEDA			, Nil})	// 08
					MSExecAuto({|x,y| FINA080(x,y)},aBaixa,5)
				Endif
			Endif
			(cAlias)->(DbSkip())
		End
	Endif
	RestArea(aSE1)
	RestArea(aArea)
Endif
Return

/*
±±ºPrograma  ³GERATITIMPº±±
±±ºDesc.     ³Gera titulos de recolhimento de impostos                    º±±
*/
Static Function GeraTitImp(cArq,aRet)
Local aImp:={}
Local nY:=0,nG:=0,nValTit:=0
Local cPref	    :="",cImp:="",cTipoTit:="",cHist:=""
Local cParcela  :="",lOk
Local aArea	    :=GetArea()
Local aSA2	    :={},aSE2:={}
Local dVencto   := CTOD("  /  /  ")
Local clCliFor  := ""
Local clLoja    := ""
Local aDadosPai := {}
//Local nRecSE2	:= 0
//Local nX := 0

If cArq=="SF1"
	cHist:=SF1->F1_FORNECE+F1_LOJA
ElseIf cArq="SF2"
	cHist:=SF2->F2_CLIENTE+SF2->F2_LOJA
Endif
cTipoTit:=If(cPaisLoc=="ARG","RG ","TX ")
If cPaisLoc=="PER" .OR. cPaisLoc == "URU"
	If cArq=="SF1" .And. Subs(SF1->F1_ESPECIE,1,2)=="NC"
		cTipoTit:="TXA"
	ElseIf cArq="SF2" .And. Subs(SF2->F2_ESPECIE,1,2)=="NC"
		cTipoTit:="TXA"
	Endif
EndIf
If !Empty(GetMV("MV_2DUPREF"))
	cPref:=&(GetMV("MV_2DUPREF"))
Endif
cPref:=If(Empty(cPref),cSerie,cPref)
cPref:=IIf(aCfgNf[SAliasHead]=="SF1",cPref,cSerie)
aImp:=MaFisRet(,"NF_IMPOSTOS")
aImp:=ASort(aImp,,,{|x,y| x[1]<y[1]})
DbSelectArea("SA2")
aSA2:=GetArea()
dbSelectArea("SE2")
aSE2:=GetArea()
dbSetOrder(1)
nG:=Len(aImp)

IF cPaisLoc == "PER"
    // Recupera dos dados da primeira parcela gerada pela nota
    SE2->(SE2->(MsGoto(aRet[1][1])))
    AAdd(aDadosPai,{SE2->E2_FILIAL,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_EMISSAO,SE2->E2_VENCORI})
ENDIF

cParcela:=SuperGetMV("MV_1DUP",,"1")
For nY:=1 To nG
	nValTit:=0
	cImp:=aImp[nY][1]
	DbSelectArea("SFB")
	If DbSeek(xFilial("SFB")+cImp)
		If Iif(cPaisLoc $ "COS|PER|URU" ,SFB->FB_GERTIT$"1",.F.)
			While nY<=nG .AND. aImp[nY][1] == cImp
				nValTit+=aImp[nY][5]
				nY++
			End
			nY--
			If !Empty(FB_FORNECE) .and. !Empty(SFB->FB_LOJA)
				clCliFor := SFB->FB_FORNECE
				clLoja   := SFB->FB_LOJA
			Else
				clCliFor := SA2->A2_COD
				clLoja   := SA2->A2_LOJA
			EndIf
		EndIf
	EndIf
	DbSelectArea("SE2")
	If nValTit<>0
		lOk:=.F.
		While !lOk
			If !(lOk:=!(DbSeek(xFilial("SE2")+cPref+cNFiscal+cParcela+cTipoTit+clCliFor+clLoja)))
				cParcela:=Soma1(cParcela)
			EndIf
		End
		SA2->(dbSeek(xFilial("SA2")+clCliFor+clLoja))

		dVencto := LocVencImp(SFB->FB_DIAVENC,SFB->FB_PERIODO,aDadosPai)

		RecLock("SE2",.T.)
		SE2->E2_FILORIG := cFilAnt
		Replace	E2_FILIAL  With xFilial("SE2")
		Replace E2_PREFIXO With cPref
		Replace E2_EMISSAO With dDEmissao
		Replace E2_EMIS1   With dDataBase
		Replace E2_HIST    With cHist+"/"+aImp[nY][1]
		Replace	E2_FORNECE With SA2->A2_COD
		Replace	E2_LOJA    With SA2->A2_LOJA
		Replace	E2_NOMFOR  With SA2->A2_NREDUZ
		Replace E2_TIPO    With cTipoTit
		Replace	E2_MOEDA   With nMoedaCor
		Replace E2_TXMOEDA With nTaxa
		Replace	E2_LA      With "S"
		Replace E2_NUM     With cNFiscal
		Replace	E2_PARCELA With cParcela
		Replace E2_VENCORI With dVencto
		Replace E2_VENCTO  With dVencto
		Replace E2_VENCREA With DataValida(dVencto)
		Replace	E2_VALOR   With nValTit
		Replace	E2_SALDO   With nValTit
		If cPaisLoc=="PER" .AND. aImp[nY][1]== "DIG"    // Para esse imposto não pode existir casas decimais na moeda 1
			Replace E2_VLCRUZ  With Round(xMoeda(nValTit,nMoedaCor,1,dDataBase,,nTaxa),0)
        Else
			Replace E2_VLCRUZ  With xMoeda(nValTit,nMoedaCor,1,dDataBase,,nTaxa)
		EndIf
		If !Empty(SFB->FB_NATUREZ)
			Replace E2_NATUREZ With SFB->FB_NATUREZ
		Else
			Replace E2_NATUREZ With cNatureza
		Endif
		Replace	E2_ORIGEM  With cFunName
		If cPaisLoc == "CHI"
			Replace  E2_CGC	With SA2->A2_CGC
		EndIf
		if cPaisLoc == "COL"
			Replace E2_TRMPAC With If(cArq == "SF1",CVALTOCHAR(SF1->F1_TRMPAC),CVALTOCHAR(SF2->F2_TRMPAC))
		endif
		IF cPaisLoc == "PER"
		 	Replace E2_TITPAI With aDadosPai[1][2]+aDadosPai[1][3]+aDadosPai[1][4]+aDadosPai[1][5]+aDadosPai[1][6]+aDadosPai[1][7]
		Endif
		MsUnLock()

		If cPaisLoc == "PER"
			xUpdImpPer(SE2->(Recno()), aRet, Alltrim(SFB->FB_CPOLVRO), cParcela)
		Endif
		cParcimp:=Soma1(cParcela)

	Endif
Next
RestArea(aSA2)
RestArea(aSE2)
RestArea(aArea)
Return

/*
±±ºPrograma  ³APAGTITIMPº±±
±±ºDesc.     ³Gera titulos de recolhimento de impostos                    º±±
*/
Static Function ApagTitImp(cArq)
//Local nY:=0,nG:=0,nValTit:=0
Local cPref:="",cTipoTit:="",cHist:=""//cImp:="",
Local cFilSE2:=xFilial("SE2")//cParcela:="",
Local aArea:=GetArea()
Local aSE2:={}
Local cEspecie := "", cFornece := "", cLoja := ""

If cArq=="SF1"
	cHist:=SF1->F1_FORNECE+F1_LOJA
	cEspecie := SF1->F1_ESPECIE
	cFornece := SF1->F1_FORNECE
	cLoja    := SF1->F1_LOJA
ElseIf cArq="SF2"
	cHist:=SF2->F2_CLIENTE+SF2->F2_LOJA
	cEspecie := SF2->F2_ESPECIE
	cFornece := SF2->F2_CLIENTE
	cLoja    := SF2->F2_LOJA
Endif
cTipoTit:=If(cPaisLoc=="ARG","RG","TX")
If cPaisLoc=="PER" .OR. cPaisLoc == "URU"
	If cArq=="SF1" .And. Subs(SF1->F1_ESPECIE,1,2)=="NC"
			cTipoTit:="TXA"
	ElseIf cArq="SF2" .And. Subs(SF2->F2_ESPECIE,1,2)=="NC"
			cTipoTit:="TXA"
	Endif
EndIf
If !Empty(GetMV("MV_2DUPREF"))
	cPref:=&(GetMV("MV_2DUPREF"))
Endif
cPref:=If(Empty(cPref),Criavar("SF1->F1_PREFIXO"),cPref)
cPref:=IIf(aCfgNf[SAliasHead]=="SF1",cPref,cSerie)
dbSelectArea("SE2")
aSE2:=GetArea()
DbSetOrder(6) // Filial + Fornece + Loja + Prefixo + num
If DbSeek(cFilSE2+cFornece+cLoja+cPref+cNFiscal)
	While cFilSE2+cFornece+cLoja+cPref+cNFiscal == (E2_FILIAL+E2_FORNECE+E2_LOJA+E2_PREFIXO+E2_NUM) .AND. !Eof() // fabio
		If cHist==Left(E2_HIST,Len(cHist))
			If Alltrim(E2_TIPO)==cTipoTit .AND. Empty(E2_BAIXA)
				RecLock("SE2",.F.)
				DbDelete()
				MsUnLock()
			Endif
		Else
			If Alltrim(cEspecie) == Alltrim(E2_TIPO)  .and. Alltrim(cHist) == Alltrim(E2_FORNECE) + Alltrim(E2_LOJA)
				RecLock("SE2",.F.)
					DbDelete()
				MsUnLock()
			Endif
		Endif
		DbSkip()
	EndDo
Endif
RestArea(aSE2)
RestArea(aArea)
Return

/*
±±ºPrograma  ³aNumNaoExisteº±±
±±ºDesc.     ³Verifica se a numeracao do documento ja esta sendo usada    º±±
*/
Function aNumNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie,cOrigem, nLenSerNF)
Local cAliasC2	 :=	""
Local cAliasTmp  :=	cAliasC
Local lRet		 :=.T.
Local lReutiliza := GetMv("MV_USAMNUM",,.T.)  //Determina se permite reutilizar o numero da NF
Local lFormProp  := .T.
Local lDocExiste := .T.
Local cSerieNf   := ""
Local cTipContNF := Iif (ValType(lFiscal)== "L" .AND. lFiscal ,GetMV("MV_CONTNFI",,"I"),GetMV("MV_CONTNF"))
Local cFiltroSF1 := SF1->(dbFilter())
Local cFiltroSF2 := SF2->(dbFilter())
Local cFilSF1    := xFilial("SF1")
Local cFilSF2    := xFilial("SF2")
Local cFilSF3    := xFilial("SF3")
Local lUsaNewKey := TamSX3("F1_SERIE")[1] == 14
Local nLenSerie  := TamSX3("F1_SERIE")[1]
Local aArea      := {}
Local lVerif	 :=.T.
Local lOrigem    := .F.

//³Limpa o conteudo do filtro das tabelas SF1/SF2 para evitar  ³
//|incompatibilidade com o parametro MV_FLTD1D2.			   |

SF1->(dbClearFilter())
SF2->(dbClearFilter())

If lUsaNewKey
	cSerie:= SerieNfId(cAliasTMP,4,PrefixoCpo(cAliasTMP)+"_SERIE",M->&(PrefixoCpo(cAliasTMP)+"_EMISSAO"),cEspecie,cSerie)
Endif

If Type("lLocxAuto") <> "U" .AND. lLocxAuto
	Return .T.
EndIf
cOrigem := IIf(cOrigem == NIL,"GEN",cOrigem)
nLenSerNF := IIf(nLenSerNF == NIL, nLenSerie, nLenSerNF)

lOrigem:= IIf(cOrigem == "GEN",aCfgNF[SlFormProp],.T.)
If Upper(Alltrim(cOrigem)) == "LOJ"
	lRet := aNumNaoLj(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie,cOrigem)
Else
	If cAliasC == "SF2"

		//³Verifica se a NF esta sendo digitada em outra estacao³

		cSerieNf :=	Padr(cSerie,Len(Criavar("F2_SERIE",.F.)))
		If lOrigem
			If cMayUse == NIL .OR. cMayUse!="SF2"+cFilSF2+cNFiscal+cSerieNf+'S'
				If cMayUse!=Nil
					UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				Endif
				cMayUse := cNFiscal+cSerieNf+'S'
			Endif
		Else
			If cMayUse!=NIL .OR. cMayUse!="SF2"+cFilSF2+cNFiscal+cSerieNf+cCliFor+cLoja
				If cMayUse!=NIL
					UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				Endif
				cMayUse := cNFiscal+cSerieNf+cTipo+cCliFor+cLoja
			EndIf
		Endif
		If (!Empty(cNFiscal) .AND. !(cEspecie $ "NDC|NDI") .AND. (FunName() != "MATA467N")) .Or. (cPaisLoc == "EQU" .And. !Empty(cNFiscal))
			If !LockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				lRet := .F.
			EndIf
		EndIf
		If lRet .AND. lOrigem .AND. cTipContNF == "M"
			If !Empty(cNFiscal) .AND. !LockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				lRet := .F.
			EndIf
		Endif
	Else

		//³Verifica se o controle de numeracao eh o mesmo   ³
		//³para todos os documentos ou se eh independente   ³

		cSerieNf := 	Padr(cSerie,Len(Criavar("F1_SERIE",.F.)))

		//³Verifica se a NF esta sendo digitada em outra estacao ³

		If lOrigem
			If cMayUse==NIL .OR. cMayUse!="SF1"+cFilSF1+cNFiscal+cSerieNf+'S'
				If cMayUse != NIL
					UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				Endif
				cMayUse := cNFiscal+cSerieNf+'S'
			Endif
		Else
			If cMayUse==NIL .OR. cMayUse!="SF1"+cFilSF1+cNFiscal+cSerieNf+cCliFor+cLoja
				If cMayUse != NIL
					UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				Endif
				cMayUse := cNFiscal+cSerieNf+cCliFor+cLoja
			EndIf
		Endif
		If !Empty(cNFiscal)	.AND. !LockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
			lRet := .F.
		EndIf
		If lRet .AND. lOrigem .AND. cTipContNF == "M"
			If !Empty(cNFiscal) .AND. !LockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				lRet := .F.
			EndIf
		Endif

	EndIf
	If cPaisLoc == "ARG" .And. (AllTrim(cEspecie) == "RFN"  .OR. AllTrim(cEspecie) == "RTS" .OR. (FunName() $ "MATA467N|MATA466N" ))
		aArea := getArea()
		dbSelectArea("SF2")
		dbSetOrder(1) //F2_FILIAL+F2_DOC+F2_SERIE

		If !Empty(cSerie) .OR. !Empty(cnFiscal)
			If SF2->(DbSeek(xfilial("SF2") + cnFiscal + cSerie))
				Return .F.
			EndIf
		EndIf
		restArea(aArea)
	EndIf
	// Verifica se a NF existe nos arquivos
	If lRet.AND.GetMV('MV_FLTD1D2')
		If cAliasC == "SF1"
			cAliasC	:=	"__LOCXSF1"
		Else
			cAliasC	:=	"__LOCXSF2"
		Endif
		If Select(cAliasC) == 0
			If !ChkFile(cAliasTMP,.F.,cAliasC)
				cAliasC := cAliasTMP
			Endif
		Else
			dbSelectArea(cAliasC)
		Endif
	Endif

	cAliasC2	:=	Substr(cAliasTMP,1,2)+Iif(Substr(cAliasTMP,3,1)=='1','2','1')
	(cAliasC2)->(DbSetOrder(1))
	(cAliasC)->(DbSetOrder(1))
	If cPaisLoc $ "PAR|ARG|URU|CHI" .and. !lOrigem
		lVerif:=.F.
	EndIf
	If &(cAliasC+"->(MSSeek('"+xFilial(cAliasTMP)+cnFiscal+cSerie+IIF(lOrigem,"",cCliFor+cLoja)+"', .F.))")
		While lRet .AND. !(cAliasC)->(EOF()) .AND. &(cAliasC+'->("'+xFilial(cAliasTMP)+cnFiscal+cSerie+'")') ==;
			&(cAliasC+"->("+PrefixoCpo(cAliasTMP)+"_FILIAL+"+PrefixoCpo(cAliasTMP)+"_DOC+PadR(Substr("+PrefixoCpo(cAliasTMP)+"_SERIE,1,"+Str(nLenSerNF)+"),"+Str(nLenSerie)+"))")
			If lFormProp  := (&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_FORMUL") $ 'S ' .AND. lOrigem);
				.OR. lVerif .And. (!(&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_FORMUL") $ 'S ') .AND. !lOrigem)
				//Se o documento for Forumulario Proprio deve verificar o parametro MV_CONTNF
				If lFormProp
					If cTipContNF == "M"
						lDocExiste  := .T.
					ElseIf cTipContNF == "I"
						lDocExiste := AllTrim(&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_ESPECIE")) == AllTrim(cEspecie)
					EndIf
				EndIf
				If lDocExiste
					UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
					UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
					lRet := .F.
				EndIf
			Endif
			(cAliasC)->(DbSkip())
		End
		//³Verificar se o documento existe na outra tabela (SF1/SF2) quando é usado o ³
		//³mesmo numero de documento para todos os tipos de documento                 ³
	ElseIf (cTipContNF == "M" .AND.	&(cAliasC2+"->(MSSeek('"+xFilial(cAliasC2)+cnFiscal+cSerie+IIF(aCfgNF[SlFormProp],"",cCliFor+cLoja)+"', .F.))") )
		While lRet .AND. !(cAliasC2)->(EOF()) .AND. &(cAliasC2+'->("'+xFilial(cAliasC2)+cnFiscal+cSerie+'")') ==;
			&(cAliasC2+"->("+PrefixoCpo(cAliasC2)+"_FILIAL+"+PrefixoCpo(cAliasC2)+"_DOC+PadR(Substr("+PrefixoCpo(cAliasC2)+"_SERIE,1,"+Str(nLenSerNF)+"),"+Str(nLenSerie)+"))")
			If (&(cAliasC2+"->"+PrefixoCpo(cAliasC2)+"_FORMUL") $ 'S ' .AND. lOrigem);
				.OR. (lVerif .And. !(&(cAliasC2+"->"+PrefixoCpo(cAliasC2)+"_FORMUL") $ 'S ') .AND. !lOrigem)
				UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
				UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
				lRet := .F.
			Endif
			(cAliasC2)->(DbSkip())
		End
	Endif
	//³Validacoes de existencia da nota³
	(cAliasC)->(DbSetOrder(1))
	If lRet .AND. &(cAliasC+"->(MSSeek('"+xFilial(cAliasTmp)+cnFiscal+cSerie+cCliFor+cLoja+'N'+"', .F.))")
		UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
		UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
		lRet := .F.
	EndIf

	//³Validacoes de existencia da nota de complemento ³

	(cAliasC)->(DbSetOrder(1))
	If lRet .AND. &(cAliasC+"->(MSSeek('"+xFilial(cAliasTmp)+cnFiscal+cSerie+cCliFor+cLoja+'C'+"', .F.))")
		UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
		UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
		lRet := .F.
	EndIf
		//³Validacoes de existencia da nota de Beneficiamento³
	If cPaisLoc == "ARG"
		(cAliasC)->(DbSetOrder(1))
		If lRet .AND. &(cAliasC+"->(MSSeek('"+xFilial(cAliasTmp)+cnFiscal+cSerie+cCliFor+cLoja+'B'+"', .F.))")
			UnLockByName("SF1"+cFilSF1+cMayUse,.T.,!Empty(cFilSF1),.T.)
			UnLockByName("SF2"+cFilSF2+cMayUse,.T.,!Empty(cFilSF2),.T.)
			lRet := .F.
		EndIf
	EndIf
	//³Controla a a existencia da Nota no SF3³
	If lRet
		DbSelectArea( "SF3" )
		DbSetOrder( 5 )
		If DbSeek( cFilSF3+cSerie+cNFiscal,.F. )
			While !Eof() .AND. (cFilSF3+cSerie+cNFiscal) == (SF3->F3_FILIAL+SF3->F3_SERIE+SF3->F3_NFISCAL)
				//Devo controlar que a nota achada no SF3 seja de faturam., não esteja anulada,
				// e se a numeracao dos formularios e independente, que seja da mesma especie.
				If lOrigem
					If cTipContNF == "M"  .OR. (cTipContNF == "I" .AND. Alltrim(F3_ESPECIE)	==	Alltrim(cEspecie) )
						If (LocxFormP(SF3->F3_ESPECIE,SF3->F3_TIPOMOV,SF3->F3_TES,SF3->F3_FORMUL))
							If IIf(Empty(F3_DTCANC),.T.,!lReutiliza)
								lRet := .F.
							EndIf
						EndIf

					EndIf
				ElseIf  F3_TIPO ==	cTipo .AND. cCliFor+cLoja == F3_CLIEFOR+F3_LOJA .AND. Alltrim(F3_ESPECIE)	==	Alltrim(cEspecie) .AND. !(LocxFormP(SF3->F3_ESPECIE,SF3->F3_TIPOMOV,SF3->F3_TES,SF3->F3_FORMUL))
					If IIf(Empty(F3_DTCANC),.T.,!lReutiliza)
						lRet := .F.
					EndIf
				EndIf
				DbSkip()
			End
		EndIf
	Endif

	If lRet
		Aadd(__aCodLocs,"SF1"+xFilial("SF1")+cMayUse)
		Aadd(__aCodLocs,"SF2"+xFilial("SF2")+cMayUse)
	Endif
Endif
//³Restaura o conteudo do filtro das tabelas SF1/SF2  ³
If !Empty(cFiltroSF1)
	SF1->(dbSetFilter({||&cFiltroSF1},cFiltroSF1))
EndIF
If !Empty(cFiltroSF2)
	SF2->(dbSetFilter({||&cFiltroSF2},cFiltroSF2))
EndIf
Return (lRet)

/*
±±ºPrograma  ³aNumNaoLj    º±±
±±ºDesc.     ³Verifica se a numeracao do documento ja esta sendo usada    º±±
±±ºUso       ³ LOCXNF (SIGALOJA)                                          º±±
*/
Function aNumNaoLj(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cEspecie,cOrigem)
Local cAliasC2	 :=	""
Local cAliasTmp  :=	cAliasC
Local lRet		 :=.T.
Local lReutiliza := GetMv("MV_USAMNUM",,.T.)  //Determina se permite reutilizar o numero da NF
Local lFormProp  := .T.
Local lDocExiste := .T.
Local cSerieNf   :=""
Local cTipContNF := Iif (ValType(lFiscal)== "L" .AND. lFiscal ,GetMV("MV_CONTNFI",,"I"),GetMV("MV_CONTNF"))
Local cFilSF3		:= xFilial("SF3")
Local lOrigem:=.f.
If Type("lLocxAuto") <> "U" .AND. lLocxAuto
   Return .T.
EndIf
cOrigem := IIf(cOrigem == NIL,"GEN",cOrigem)
lOrigem:= IIf(cOrigem == "GEN",aCfgNF[SlFormProp],.T.)
If cAliasC == "SF2"

//³Verifica se a NF esta sendo digitada em outra estacao ³

   cSerieNf :=	Padr(cSerie,Len(Criavar("F2_SERIE",.F.)))
	If lOrigem
		If cMayUse == NIL .OR. cMayUse!=cNFiscal+cSerieNf+'S'
			FreeUsedCode()
			cMayUse := cNFiscal+cSerieNf+'S'
		Endif
	Else
		If cMayUse==NIL .OR. cMayUse!=cNFiscal+cSerieNf+cCliFor+cLoja
			FreeUsedCode()
			cMayUse := cNFiscal+cSerieNf+cTipo+cCliFor+cLoja
		EndIf
	Endif
	If !Empty(cNFiscal) .AND. !FreeForUse("SF2",cMayUse)
		lRet := .F.
	EndIf
	If lRet .AND. lOrigem .AND. cTipContNF == "M"
		If !Empty(cNFiscal) .AND. !FreeForUse("SF1",cMayUse)
			FreeUsedCode()
			lRet := .F.
		EndIf
	Endif
Else

	//³Verifica se o controle de numeracao eh o mesmo   ³
	//³para todos os documentos ou se eh independente   ³

    cSerieNf := 	Padr(cSerie,Len(Criavar("F1_SERIE",.F.)))

	//³Verifica se a NF esta sendo digitada em outra estacao³

	If lOrigem
		If cMayUse==NIL .OR. cMayUse!=cNFiscal+cSerieNf+'S'
			FreeUsedCode()
			cMayUse := cNFiscal+cSerieNf+'S'
		Endif
	Else
		If cMayUse==NIL .OR. cMayUse!=cNFiscal+cSerieNf+cCliFor+cLoja
			FreeUsedCode()
			cMayUse := cNFiscal+cSerieNf+cCliFor+cLoja
		EndIf
	Endif
	If !Empty(cNFiscal)	.AND. !FreeForUse("SF1",cMayUse)
		lRet := .F.
	EndIf
	If lRet .AND. lOrigem .AND. cTipContNF == "M"
		If !Empty(cNFiscal) .AND. !FreeForUse("SF2",cMayUse)
			FreeUsedCode()
			lRet := .F.
		EndIf
	Endif

EndIf

// Verifica se a NF existe nos arquivos
If lRet.AND.GetMV('MV_FLTD1D2')
	If cAliasC == "SF1"
		cAliasC	:=	"__LOCXSF1"
	Else
		cAliasC	:=	"__LOCXSF2"
	Endif
	If Select(cAliasC) == 0
		ChkFile(cAliasTMP,.F.,cAliasC)
	Else
		dbSelectArea(cAliasC)
	Endif
Endif

cAliasC2	:=	Substr(cAliasTMP,1,2)+Iif(Substr(cAliasTMP,3,1)=='1','2','1')
(cAliasC2)->(DbSetOrder(1))
(cAliasC)->(DbSetOrder(1))
If &(cAliasC+"->(MSSeek('"+xFilial(cAliasTMP)+cnFiscal+cSerie+IIF(lOrigem,"",cCliFor+cLoja)+"', .F.))")
	While lRet .AND. !(cAliasC)->(EOF()) .AND. &(cAliasC+'->("'+xFilial(cAliasTMP)+cnFiscal+cSerie+'")') ==;
		 &(cAliasC+"->("+PrefixoCpo(cAliasTMP)+"_FILIAL+"+PrefixoCpo(cAliasTMP)+"_DOC+"+PrefixoCpo(cAliasTMP)+"_SERIE)")
		If lFormProp  := (&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_FORMUL") $ 'S ' .AND. lOrigem);
			.OR.(!(&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_FORMUL") $ 'S ') .AND. !IIf(cOrigem == "GEN",aCfgNF[SlFormProp],.T.))
			//Se o documento for Forumulario Proprio deve verificar o parametro MV_CONTNF
			If lFormProp
			   If cTipContNF == "M"
			      lDocExiste  := .T.
			   ElseIf cTipContNF == "I"
			      lDocExiste := AllTrim(&(cAliasC+"->"+PrefixoCpo(cAliasTMP)+"_ESPECIE")) == AllTrim(cEspecie)
			   EndIf
			EndIf
			If lDocExiste
			   FreeUsedCode()
			   lRet := .F.
			EndIf
		Endif
		(cAliasC)->(DbSkip())
	End

	//³Verificar se o documento existe na outra tabela (SF1/SF2) quando é usado o ³
	//³mesmo numero de documento para todos os tipos de documento                 ³

ElseIf (cTipContNF == "M" .AND.	&(cAliasC2+"->(MSSeek('"+xFilial(cAliasC2)+cnFiscal+cSerie+IIF(aCfgNF[SlFormProp],"",cCliFor+cLoja)+"', .F.))") )
	While lRet .AND. !(cAliasC2)->(EOF()) .AND. &(cAliasC2+'->("'+xFilial(cAliasC2)+cnFiscal+cSerie+'")') ==;
		 &(cAliasC2+"->("+PrefixoCpo(cAliasC2)+"_FILIAL+"+PrefixoCpo(cAliasC2)+"_DOC+"+PrefixoCpo(cAliasC2)+"_SERIE)")
	  	If (&(cAliasC2+"->"+PrefixoCpo(cAliasC2)+"_FORMUL") $ 'S ' .AND. lOrigem);
			.OR.(!(&(cAliasC2+"->"+PrefixoCpo(cAliasC2)+"_FORMUL") $ 'S ') .AND. !IIf(cOrigem == "GEN",aCfgNF[SlFormProp],.T.))
			FreeUsedCode()
			lRet := .F.
		Endif
		(cAliasC2)->(DbSkip())
	End
Endif

//³Validacoes de existencia da nota³

(cAliasC)->(DbSetOrder(1))
If lRet .AND. &(cAliasC+"->(MSSeek('"+xFilial(cAliasTmp)+cnFiscal+cSerie+cCliFor+cLoja+'N'+"', .F.))")
	FreeUsedCode()
	lRet := .F.
EndIf

//³Controla a a existencia da Nota no SF3³

If lRet
	DbSelectArea( "SF3" )
	DbSetOrder( 5 )
	If DbSeek( cFilSF3+cSerie+cNFiscal,.F. )
		While !Eof() .AND. (cFilSF3+cSerie+cNFiscal) == (SF3->F3_FILIAL+SF3->F3_SERIE+SF3->F3_NFISCAL)
			//Devo controlar que a nota achada no SF3 seja de faturam., não esteja anulada,
			// e se a numeracao dos formularios e independente, que seja da mesma especie.
			If lOrigem
				If cTipContNF == "M"  .OR. (cTipContNF == "I" .AND. Alltrim(F3_ESPECIE)	==	Alltrim(cEspecie) )
			   		If (LocxFormP(SF3->F3_ESPECIE,SF3->F3_TIPOMOV,SF3->F3_TES,SF3->F3_FORMUL))
			      		If IIf(Empty(F3_DTCANC),.T.,!lReutiliza)
				    		 lRet := .F.
				 		EndIf
				 	EndIf

			   	EndIf
			ElseIf  F3_TIPO ==	cTipo .AND. cCliFor+cLoja == F3_CLIEFOR+F3_LOJA .AND. Alltrim(F3_ESPECIE)	==	Alltrim(cEspecie) .AND. !(LocxFormP(SF3->F3_ESPECIE,SF3->F3_TIPOMOV,SF3->F3_TES,SF3->F3_FORMUL))
				If IIf(Empty(F3_DTCANC),.T.,!lReutiliza)
			    	lRet := .F.
			   	EndIf
          	EndIf
			DbSkip()
		End
	EndIf
Endif
Return (lRet)

/*/
±±ºPrograma  ³MontCabBrow º±±
±±ºDesc.     ³Cria array com os campos que devem ser exibidos no mBrowse  º±±
/*/
Function MontCabBrow(aCfg)
Local aCpos    := {}
Local aAreaSX3 := {}
Local aAreaAtu := GetArea()

dbSelectArea("SX3")
aAreaSX3 := GetArea()
dbSetOrder(1)
dbSeek(aCfg[SAliasHead])
While !Eof() .AND. (X3_ARQUIVO == aCfg[SAliasHead])
	If X3USO(X3_USADO) .AND. (X3_BROWSE == "S")
		If (aCfg[ScCliFor] == "SA2") .AND. (aCfg[SAliasHead] == "SF2") .AND.;
		   (Trim(X3_CAMPO) == "F2_CLIENTE")
			AADD(aCpos,{ STR0187, SX3->X3_CAMPO } )
		ElseIf (aCfg[ScCliFor] == "SA1") .AND. (aCfg[SAliasHead] == "SF1") .AND.;
		   (Trim(X3_CAMPO) == "F1_FORNECE")
			AADD(aCpos,{ STR0188, SX3->X3_CAMPO } )
		Else
			//Leandro Prado - 10/03/2014 - Mecanismo para mostrar PV (Argentina) somente se for formulário próprio.
			If SX3->X3_CONTEXT <>"V" .And. !((Trim(X3_CAMPO) $ "F1_PV|F2_PV|") .And. (!aCfg[SlFormProp]))
				AADD(aCpos,{ AllTrim(X3Titulo()), SX3->X3_CAMPO } )
			Endif
		EndIf
	EndIf
	dbSkip()
End
RestArea(aAreaSX3)
RestArea(aAreaAtu)
Return(aCpos)

/*
±±ºPrograma  ³LocxAnula º±±
±±ºDesc.     ³Permite anulacao das notas fiscais                          º±±
*/
Function LocxAnula(aCfgNF,__nOpcx,bFilBrw)
if (cPaisLoc == "RUS")
	If (( __nOpcX == 5 ) .Or. ( __nOpcX == 6 )) ;
		.And. ((SF2->F2_STATUSR == "2") .Or. (SF1->F1_STATUSR == "2"))
		Help("",1,"LocxAnula",,STR0383,1,0)	// "Delete VAT Invoice linked to this record first."
		Return .F.
	EndIf
EndIf
If cPaisLoc == "ARG" .and. FunName() == "MATA462N" .and. (!Empty(SF2->F2_COMCOT) .Or. !Empty(SF2->F2_AUTHCOT))
	HELP("",NIL,'Anular',,STR0409,1,0)	//O remito não pode ser anulado, pois ja foi transmitido
	Return .F.
EndiF
lAnulaSF3  := .T.
LocxDlgNF(aCfgNF,__nOpcx,bFilBrw)
lAnulaSF3  := .F.
Return
/*
±±ºProgram   ³ LocxShowNFImp º±±
±±ºDescrição ³ Mostra todas as facturas envolvidas no processo de importação  º±±
±±º          ³ e solicita ao Usuário a execução da geração dos Remitos.       º±±
±±º          ³ antiga A101ShowNfImp()                                         º±±
*/
Function LocxShowNFImp()
LOCAL aArea := GetArea()
//LOCAL lRet  := .T.
LOCAL aCab  := {}
LOCAL aPicture := {}
LOCAL aCampos  := {"FATURA","F1_DOC","F1_SERIE"}
LOCAL oLbx
LOCAL cProcesso := SF1->F1_HAWB
LOCAL cNFImp    := SF1->F1_DOC
LOCAL cSerieImp := SF1->F1_SERIE
LOCAL nOpc		:= 0
LOCAL nI		:= 0
LOCAL cFilSD1	:= xFilial("SD1")
If cPaisLoc == "CHI"

	aFaturas := {}

	DbSelectArea("SX3")
	DbSetOrder(2)
	For nI := 1 To Len(aCampos)
		If nI == 1
			AADD(aCab,"Tipo")
			AADD(aPicture,"@!")
		Else
			MsSeek(aCampos[nI])
			AADD(aCab,X3Titulo())
			AADD(aPicture,SX3->X3_PICTURE)
		EndIf
	Next nI
	DbSetOrder(1)

	DbSelectArea("SF1")
	DbSetOrder(5)
	If DbSeek(xFilial("SF1")+cProcesso)
		While !Eof() .AND. SF1->F1_HAWB == cProcesso
			SD1->(DbSetOrder(1))
			SD1->(DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
			If ! Empty(SD1->D1_TES)
				AADD(aFaturas,{TypeNFImp(SF1->F1_TIPO_NF),SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA})
			ElseIf SF1->F1_DOC == cNFImp .AND. SF1->F1_SERIE == cSerieImp
				AADD(aFaturas,{TypeNFImp(SF1->F1_TIPO_NF),SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA})
			EndIf
			DbSkip()
		End
	EndIf

	If Len(aFaturas) > 0

		DEFINE MSDIALOG oDlgShow TITLE Oemtoansi(STR0101);
		FROM 10,30 To 25,92 OF GetWndDefault()

		@ 8.9, 005 SAY OemToAnsi(STR0102) OF oDlgShow PIXEL
		@ 8.5, 035 GET cProcesso  OF oDlgShow PIXEL WHEN .F.

		oLbx := RDListBox(1.9, .5, 235 , 55.5, aFaturas, aCab,,aPicture,,  )  // {||DetDblclk("F")} ) se cancela por funcion DetDblclk no compilada

		@ 91, 085 SAY OemToAnsi(STR0103) OF oDlgShow PIXEL

		DEFINE SBUTTON oButton FROM 89.4 ,179 TYPE 1 ACTION (nOpc:=1,oDlgShow:End()) ENABLE OF oDlgShow
		DEFINE SBUTTON oButton FROM 89.4 ,212 TYPE 2 ACTION (nOpc:=2,oDlgShow:End()) ENABLE OF oDlgShow

		ACTIVATE MSDIALOG oDlgShow
	EndIf
EndIf
RestArea(aArea)
Return( If(nOpc==1,aFaturas,{}) )

/*
±±ºProgram   ³LocxAtuFis  º±±
±±ºDescrição ³ Faz a atuazalizacao do folder fiscal, quando for alterada a    º±±
±±º          ³ serie ou numero da NF.                               		  º±±
±±³Sintaxe   ³ LocxAtuFis(lAtuNumDoc,cNumDoc)                                 ³±±
±±³Parametros³lAtuNumDoc Indica se foi alterado o numero da nota, ou a serie  ³±±
±±³          ³cNumDoc Numero da Fatura						            	  ³±±
*/
Function LocxAtuFis(lAtuNumDoc,cNumDoc)
Local nPosDoc := 0
Local cDesDoc := ""
Local xLivro
Local nB	  := 0
Local nA	  := 0

If lAtuNumDoc
	xLivro := MaFisRet(,'NF_LIVRO')
	If Valtype(xLivro) == "A" .AND. Len(xLivro) > 0
		nPosDoc	:= aScan(xLivro[1],{|x|x=="F3_NFISCAL"})
		If nPosDoc != 0
			For nA := 2 To Len(xLivro)
				xLivro[nA][nPosDoc] := cNumDoc
			Next nA
			MaFisAlt("NF_LIVRO",xLivro)
		EndIf
	EndIf
EndIf
If ( Type("lLocxAuto") == "U" .OR. !lLocxAuto )
	If IsMemVar("oLstSF3")
		If Len(oLstSF3:AARRAY)>0
			cDesDoc  := Rtrim(RetTitle("F3_NFISCAL"))
			nPosDoc	:= aScan(oLstSF3:AHEADERS,{|x|RTrim(x)==cDesDoc})
			For nB := 1 to Len(oLstSF3:AARRAY)
				oLstSF3:AARRAY[nB,nPosDoc]:= cNumDoc
			Next nB
			oLstSF3:Refresh()
		EndIf
	EndIf
Endif
Return

/*
±±³Fun‡Æo    ³A100ValImp³±±
±±³Descri‡Æo ³ Validar a digita‡„o do valor do imposto.                   ³±±
*/
Function LocXValImp(cImpDigit,nImpCalc,cCodImp)
Local lRet	:=	.T.
Local nRnd	:=	MsDecimais(MaFisRet(,"NF_MOEDA"))
Local lModif :=	GetMv("MV_EDITIMP")
Local nDifer := 0, nDiferA := 0, nImpDigit
Local lVldValor:= .F.
Local aAreaAtu:={}
Local aAreaAtuSFB:={}
Local cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
Default cCodImp:=""

lVldValor:=  lModif .And. !Empty(cCodImp) .And. cPaisLoc $ cAuxPaisL

If Type("lIntegracao")!= "L"
	lIntegracao:=.F.
Endif
If Type("lFacImport")!= "L"
	lFacImport:=.F.
Endif

If lIntegracao .AND. lFacImport
	lRet:=.F.
Else
	nImpDigit	:= &cImpDigit

	aAreaAtu:=GetArea()
	aAreaAtuSFB:=SFB->(GetArea())
	SFB->(DbSetOrder(1))
	SFB->(Dbseek(xfilial("SFB")+Alltrim(cCodImp))  )
	nDiferA := !(ABS(nImpDigit - nImpCalc) <= (nImpCalc * (SFB->FB_PERCALT/100)) )
	If !(ABS(nImpDigit - nImpCalc) <= (nImpCalc * (SFB->FB_PERCALT/100)) ) .Or. !(ABS(nImpDigit - nImpCalc) <= SFB->FB_VLRALT)
		Aviso( STR0018,IIf(nDiferA, STR0267,STR0268),{STR0021})
		lRet  := .F.
	EndIf
	RestArea(aAreaAtu)
	SFB->(RestArea(aAreaAtuSFB))

Endif
Return( lRet )

Static Function BloqFatImp(lVerRes)
Local cSeek 	:= ""
Local nOrd  	:= 3
Local aArea 	:= GetArea()
Local aAreaSB2, aAreaSB8, aAreaSDA
Local aSB2		:=	{}
Local aSB8		:=	{}
Local aSDA		:=	{}
Local lRet  	:= .F.
Local lPedido   := .F.
Local cCondSB8  := ""
Local aRecnoSD1 :=	{}
Local nEmpenha	:=	0
Local nQtdEmp   :=	0
Local nEmpenha2 :=	0
Local nQtdEmp2	:=	0
Local nTotQtd2	:=	0
Local lB8_ITEM	:= .F.
Local cFilSB1		:= xFilial("SB1")
Local cFilSB2		:= xFilial("SB2")
Local cFilSB8		:= xFilial("SB8")
Local cFilSDA		:= xFilial("SDA")
Local cFilSD1		:= xFilial("SD1")
Local nX
DEFAULT lVerRes	:=	.F.

DbSelectArea("SB2")
aAreaSB2 := GetArea()
DbSelectArea("SB8")
aAreaSB8 := GetArea()
DbSelectArea("SDA")
aAreaSDA := GetArea()

If SF1->F1_TIPO_NF == "5" .AND. !Empty(SF1->F1_HAWB)
	lRet := .T.
EndIf

If lRet
	DbSelectArea("SD1")
	DbSetOrder(1)
	MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)

	WHILE ! SD1->(EOF()) .AND. SD1->D1_FILIAL==cFilCD1.AND. D1_DOC==SF1->F1_DOC .AND. D1_SERIE==SF1->F1_SERIE .AND.;
		 	SD1->D1_FORNECE==SF1->F1_FORNECE .AND. SD1->D1_LOJA==SF1->F1_LOJA .AND. SD1->D1_TIPO==SF1->F1_TIPO

      If ALLTRIM(SF1->F1_ESPECIE) == ALLTRIM(SD1->D1_ESPECIE) .AND. SF1->F1_TIPO == SD1->D1_TIPO
			Aadd(aRecnoSD1,SD1->(Recno()))
			DbSelectArea("SB2")
			MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL)

	      	If (nPosRec	:=	Ascan(aSB2,{|x| x[1]==RECNO()})) == 0
				AAdd(aSB2,{Recno(),SD1->D1_QUANT})
				nPosRec	:=	Len(aSB2)
			Else
			   	aSB2[nPosRec][2]	+=	SD1->D1_QUANT
			Endif

	      	If SaldoSB2(.T.) < aSB2[nPosRec][2]
	        	lRet	:=	.F.
			Endif
			If Rastro(SD1->D1_COD    ).AND.lRet
				If Rastro(SD1->D1_COD    ,"S")
					nOrd  := 2
					cSeek := (cFilSB8+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL)
				Else
					nOrd  := 3
					cSeek := (cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL)
				EndIf

				DbSelectArea("SB8")
				DbSetOrder(nOrd)
				If DbSeek(cSeek)
	            	If (nPosRec	:=	Ascan(aSB8,{|x| x[1]==RECNO()})) == 0
						AAdd(aSB8,{Recno(),SD1->D1_QUANT})
						nPosRec	:=	Len(aSB8)
					Else
						aSB8[nPosRec][2]	+=	SD1->D1_QUANT
					Endif
					If SaldoLote(SB8->B8_PRODUTO,SB8->B8_LOCAL,SB8->B8_LOTECTL,If(nOrd==2,SB8->B8_NUMLOTE,Nil),,,.T.)<aSB8[nPosRec][2]
	    				lRet	:=	.F.
					Endif
				EndIf
			EndIf

			If Localiza(SD1->D1_COD) .AND. lRet
				DbSelectArea("SDA")
				DbSetOrder(1)
				If DbSeek(cFilSDA+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+SD1->D1_DOC)
	            	If (nPosRec	:=	Ascan(aSDA,{|x| x[1]==RECNO()})) == 0
						AAdd(aSDA,{Recno(),SD1->D1_QUANT})
						nPosRec	:=	Len(aSDA)
					Else
					   aSDA[nPosRec][2]	+=	SD1->D1_QUANT
					Endif
					If  (SDA->DA_SALDO-SDA->DA_EMPENHO) < aSDA[nPosRec][2]
	  		      		lRet	:=	.F.
					Endif
				EndIf
			EndIf
		eNDIF
		DbSelectArea("SD1")
		DbSkip()
	End
EndIf

If lRet
	lB8_ITEM	:= .T.
	For nX := 1 To Len(aRecnoSD1)
		SD1->(MsGoTo(aREcnoSD1[nX]))
		cTpOp := If(Empty(SD1->D1_OP),"F","P")

		SB1->(DbSetOrder(1))
		SB1->(MsSeek(cFilSB1+SD1->D1_COD))
		If Empty(SB1->B1_CONV) .AND. !Empty(SD1->D1_QTSEGUM)
			nTotQtd2 := SD1->D1_QTSEGUM
		ElseIf !Empty(SB1->B1_CONV)
			nTotQtd2 := SB1->(ConvUm(SB1->B1_COD,(SD1->D1_QUANT),SD1->D1_QTSEGUM,2))
		EndIf

		DbSelectArea("SB2")
		MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL)
		RecLock("SB2",.F.)
		If lPedido
			Replace B2_RESERVA With B2_RESERVA+SD1->D1_QUANT
			Replace B2_RESERV2 With B2_RESERV2+nTotQtd2
		Else
			If cTpOp  == "P"	// OP PREVISTA
				Replace B2_QEMPPRE With B2_QEMPPRE+SD1->D1_QUANT
				Replace B2_QEPRE2  With B2_QEPRE2 +nTotQtd2
			ElseIf cTpOp  == "F"	// OP FIRME
				Replace B2_QEMP  With B2_QEMP + SD1->D1_QUANT
				Replace B2_QEMP2 With B2_QEMP2+nTotQtd2
			EndIf
		EndIf
		MsUnlock()

		If Rastro(SD1->D1_COD)
			If Rastro(SD1->D1_COD,"S")
				nOrd  := 2
				cSeek := (cFilSB8+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL)
				cCondSB8 := "B8_FILIAL+B8_NUMLOTE+B8_LOTECTL+B8_PRODUTO+B8_LOCAL=="
				cCondSB8 += "xFilial('SB8')+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL"
			Else
				nOrd  := 3
				cSeek := (cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL)
				cCondSB8 := "B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL=="
				cCondSB8 +="xFilial('SB8')+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL"
			EndIf
      		nQtdEmp	:=	SD1->D1_QUANT
      		nQtdEmp2	:=	nTotQtd2

			DbSelectArea("SB8")
			DbSetOrder(nOrd)
			If DbSeek(cSeek)
				While !Eof() .AND. &(cCondSB8) .AND. nQtdEmp >	0
					If lB8_ITEM
						If B8_ITEM == SD1->D1_ITEM
	                 		nEmpenha	:=	IIf(nQtdEmp  > (SB8->B8_SALDO-SB8->B8_EMPENHO),(SB8->B8_SALDO-SB8->B8_EMPENHO),nQtdEmp)
	                 		nEmpenha2:=	IIf(nQtdEmp2 > (SB8->B8_SALDO2-SB8->B8_EMPENH2),(SB8->B8_SALDO2-SB8->B8_EMPENH2),nQtdEmp2)
							nQtdEmp	-=	nEmpenha
							nQtdEmp2	-=	nEmpenha2
							RecLock("SB8",.F.)
							Replace SB8->B8_EMPENHO With (SB8->B8_EMPENHO + nEmpenha)
							Replace SB8->B8_EMPENH2 With (SB8->B8_EMPENH2 + nEmpenha2)
							MsUnlock()
						EndIf
					Else
                 		nEmpenha	:=	IIf(nQtdEmp  > (SB8->B8_SALDO-SB8->B8_EMPENHO),(SB8->B8_SALDO-SB8->B8_EMPENHO),nQtdEmp)
                 		nEmpenha2:=	IIf(nQtdEmp2 > (SB8->B8_SALDO2-SB8->B8_EMPENH2),(SB8->B8_SALDO2-SB8->B8_EMPENH2),nQtdEmp2)
						nQtdEmp	-=	nEmpenha
						nQtdEmp2	-=	nEmpenha2
						RecLock("SB8",.F.)
						Replace SB8->B8_EMPENHO With (SB8->B8_EMPENHO + nEmpenha)
						Replace SB8->B8_EMPENH2 With (SB8->B8_EMPENH2 + nEmpenha2)
						MsUnlock()
					EndIf
					DbSkip()
				End
			EndIf
		EndIf

		If Localiza(SD1->D1_COD)
			DbSelectArea("SDA")
			DbSetOrder(1)
			If MsSeek(cFilSDA+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+SD1->D1_DOC)
				RecLock("SDA",.F.)
				Replace SDA->DA_EMPENHO With (SDA->DA_EMPENHO + SD1->D1_QUANT)
				Replace SDA->DA_EMP2 With (SDA->DA_EMP2 +nTotQtd2)
				MsUnlock()
			EndIf
		EndIf
	Next
EndIf
RestArea(aAreaSB2)
RestArea(aAreaSB8)
RestArea(aAreaSDA)
RestArea(aArea)
Return lRet

Static Function LibFatImp(lNaoForca)
Local aArea 	:= GetArea()
Local cSeek 	:= ""
Local nOrd  	:= 3
Local lEncerra  := .F.
Local aSWN, aSW6, aSD3, aSB8, aSDA, aSDB, aSB2
Local lRet 	    := .F.
Local lPedido   := .F.
Local cTpOp     := " "
Local cCondSB8  := ""
Local nEmpenha  := 0
Local nQtdEmp   := 0
Local nEmpenha2 := 0
Local nQtdEmp2	:= 0
Local nTotQtd2	:= 0
Local cFilSB1		:= xFilial("SB1")
Local cFilSB2		:= xFilial("SB2")
Local cFilSB8		:= xFilial("SB8")
Local cFilSD1		:= xFilial("SD1")
Local cFilSDA		:= xFilial("SDA")
Local cFilSDB		:= xFilial("SDB")
Local lB8_ITEM	:= .F.

DEFAULT lNaoForca	:=	.F.

dbSelectArea("SWN")
aSWN := GetArea()
dbSelectArea("SB2")
aSB2 := GetArea()
dbSelectArea("SW6")
aSW6 := GetArea()
dbSelectArea("SD3")
aSD3 := GetArea()
dbSelectArea("SB8")
aSB8 := GetArea()
dbSelectArea("SDA")
aSDA := GetArea()
dbSelectArea("SDB")
aSDB := GetArea()

If lNaoForca
	If SF1->F1_TIPO_NF $ "5" .AND. GetNewPar("MV_LIBIMP","S") == "S"
		lRet := .T.
	EndIf
Else
	If SF1->F1_TIPO_NF $ "9AB5" .AND. GetNewPar("MV_LIBIMP","S") == "S"
		lRet := .T.
	Endif
Endif
If lRet
	DbSelectArea("SD1")
	DbSetOrder(1)
	MsSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
	lB8_ITEM := .T.
	WHILE ! SD1->(EOF()) .AND. SD1->D1_FILIAL==cFilSD1.AND. D1_DOC==SF1->F1_DOC .AND. D1_SERIE==SF1->F1_SERIE .AND.;
		 	SD1->D1_FORNECE==SF1->F1_FORNECE .AND. SD1->D1_LOJA==SF1->F1_LOJA .AND. SD1->D1_TIPO==SF1->F1_TIPO

      If ALLTRIM(SF1->F1_ESPECIE) == ALLTRIM(SD1->D1_ESPECIE) .AND. SF1->F1_TIPO == SD1->D1_TIPO
			DbSelectArea("SB2")
			MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL)

			cTpOp := If(Empty(SD1->D1_OP),"F","P")
			cTpOp := "F"
			SB1->(DbSetOrder(1))
			SB1->(MsSeek(cFilSB1+SD1->D1_COD))
			If Empty(SB1->B1_CONV) .AND. !Empty(SD1->D1_QTSEGUM)
				nTotQtd2 := SD1->D1_QTSEGUM
			ElseIf !Empty(SB1->B1_CONV)
				nTotQtd2 := SB1->(ConvUm(SB1->B1_COD,(SD1->D1_QUANT),SD1->D1_QTSEGUM,2))
			EndIf

			If ! Empty(SD1->D1_QUANT)
				DbSelectArea("SB2")
				MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL)
				RecLock("SB2",.F.)
				If lPedido
					Replace B2_RESERVA With B2_RESERVA - SD1->D1_QUANT
					Replace B2_RESERV2 With B2_RESERV2 - nTotQtd2
				Else
					If cTpOp == "P"	// OP PREVISTA
						Replace B2_QEMPPRE With B2_QEMPPRE - SD1->D1_QUANT
						Replace B2_QEPRE2  With B2_QEPRE2 - nTotQtd2
					ElseIf cTpOp == "F"	// OP FIRME
						Replace B2_QEMP  With B2_QEMP - SD1->D1_QUANT
						Replace B2_QEMP2 With B2_QEMP2 - nTotQtd2
					EndIf
				EndIf
				MsUnlock()
			EndIf
			If Rastro(SD1->D1_COD)
				If Rastro(SD1->D1_COD,"S")
					nOrd  := 2
					cSeek := (cFilSB8+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL)
					cCondSB8 := "B8_FILIAL+B8_NUMLOTE+B8_LOTECTL+B8_PRODUTO+B8_LOCAL=="
					cCondSB8 := "xFilial('SB8')+SD1->D1_NUMLOTE+SD1->D1_LOTECTL+SD1->D1_COD+SD1->D1_LOCAL"
				Else
					nOrd  := 3
					cSeek := (cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL)
					cCondSB8 := "B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL=="
					cCondSB8+="xFilial('SB8')+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL"
				EndIf
	      		nQtdEmp	:=	SD1->D1_QUANT
	      		nQtdEmp2	:=	nTotQtd2

				DbSelectArea("SB8")
				DbSetOrder(nOrd)
				If DbSeek(cSeek)
					While !Eof() .AND. &(cCondSB8) .AND. nQtdEmp >	0
						If lB8_ITEM
							If B8_ITEM == SD1->D1_ITEM
		                 		nEmpenha	:=	IIf(nQtdEmp  > (SB8->B8_EMPENHO),(SB8->B8_EMPENHO),nQtdEmp)
		                 		nEmpenha2:=	IIf(nQtdEmp2 > (SB8->B8_EMPENH2),(SB8->B8_EMPENH2),nQtdEmp2)
								nQtdEmp	-=	nEmpenha
								nQtdEmp2	-=	nEmpenha2
								RecLock("SB8",.F.)
								Replace SB8->B8_EMPENHO With SB8->B8_EMPENHO-nEmpenha
								Replace SB8->B8_EMPENH2 With SB8->B8_EMPENH2-nEmpenha2
								MsUnlock()
							EndIf
						Else
	                 		nEmpenha	:=	IIf(nQtdEmp  > (SB8->B8_EMPENHO),(SB8->B8_EMPENHO),nQtdEmp)
	                 		nEmpenha2:=	IIf(nQtdEmp2 > (SB8->B8_EMPENH2),(SB8->B8_EMPENH2),nQtdEmp2)
							nQtdEmp	-=	nEmpenha
							nQtdEmp2	-=	nEmpenha2
							RecLock("SB8",.F.)
							Replace SB8->B8_EMPENHO With SB8->B8_EMPENHO-nEmpenha
							Replace SB8->B8_EMPENH2 With SB8->B8_EMPENH2-nEmpenha2
							MsUnlock()
						EndIf
						DbSkip()
					End
				EndIf
			EndIf

			If Localiza(SD1->D1_COD)
				DbSelectArea("SDA")
				DbSetOrder(1)
				If DbSeek(cFilSDA+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+SD1->D1_DOC)
					RecLock("SDA",.F.)
					Replace SDA->DA_EMPENHO With 0
					Replace SDA->DA_EMP2    With 0
					MsUnlock()
				EndIf
				DbSelectArea("SDB")
				DbSetOrder(1)
				If DbSeek(cFilSDB+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_NUMSEQ+SD1->D1_DOC)
					RecLock("SDB",.F.)
					Replace SDB->DB_EMPENHO With 0
					Replace SDB->DB_EMP2    With 0
					MsUnlock()
				EndIf
			EndIf
		EndIf
		lEncerra := .T.
		DbSelectArea("SD1")
		DbSkip()
	End
EndIf

RestArea(aSWN)
RestArea(aSW6)
RestArea(aSB2)
RestArea(aSD3)
RestArea(aSB8)
RestArea(aSDA)
RestArea(aSDB)
RestArea(aArea)
Return(lEncerra)

/*
±±³Fun‡…o    ³ LocxGrvCusImp ³±±
±±³Descri‡…o ³ Grava o Custo dos itens de importacao e as suas DE6/RE6    ³±±
±±³ Uso      ³ MATA100 (Integracao com Modulo de Importacao)              ³±±
*/
Function LocxGrvCusImp(cDoc,cSerie,cNBM,aCustoEnt,aRecImp)
Local aArea        := GetArea()
Local aAreaSF1     := SF1->(GetArea())
Local aAreaSD1     := SD1->(GetArea())

Local aCusto	   := {}
//Local aCustoRem    := {}
Local aImpostos	   := {}
Local aTes         := {}
Local aMoeda       := {}
//Local aRemitos     := {}
Local aRecnoSD3	   := {}
Local aRemito	   := {}

Local nPosSWN	   := 0
//Local nQuant	   := 0
Local nPosTes      := 0
//Local nTotal	   := 0
Local nY,nE		   := 0
Local nPosCols	   := 0
Local nRegs		   := 0
Local nQtdItens	   := 0
Local nTxCusEIC    := 0
Local nMoedaOrig   := 0
//Local nX           := 0
Local nValImpX     := 0
Local nItem        := 1
Local nValorCus    := 0.00

Local cTipoNF	   := ""
Local cTesDespacho := ""
Local cNumRemito   := ""
Local cSerRemito   := ""
Local cCampo       := ""
Local cHawb        := ""
//Local cCodDespesa  := ""
Local cQuery	   := ""
Local cAliasQry	   := ""
Local cSeek        := ""

Local lQuery	   := .F.

Local dDtValid     := Nil

Local lSWNLote     := .T.
Local lAtuSegUM    := .T.
//Local nLenDoc      := TamSX3("F1_DOC")[1]
Local lMovtaSD3    := GetNewPar("MV_CUSTIMP","1") == "1"
Local nPosAColsTes := AScan(aHeader,{|x| Upper(Alltrim(x[2]))$"D1_TES"})
Local cFornece     := SF1->F1_FORNECE
Local cLoja        := SF1->F1_LOJA
Local cFornDes     := SF1->F1_FORNECE
Local cLojaDes     := SF1->F1_LOJA
Local cNFiscalDes  := SF1->F1_DOC
Local cSerieDes    := SF1->F1_SERIE
Local dDataTaxa

Local lB2AtuUnif	:= .T.
Local lWN_TES 	:= .F.
Local lWN_ITEMNF	:= .F.
Local lWN_LOCAL	:= .F.
Local lWN_DESPSUB:= .F.
Local cFilSB1		:= xFilial("SB1")
Local cFilSB2		:= xFilial("SB2")
Local cFilSB8		:= xFilial("SB8")
Local cFilSD1		:= xFilial("SD1")
Local cFilSF1		:= xFilial("SF1")
Local cFilSF4		:= xFilial("SF4")
Local cFilSYD		:= xFilial("SYD")
Local cFilSWD		:= xFilial("SWD")
Local cFilSWN		:= xFilial("SWN")
Local cFilSW6		:= xFilial("SW6")
Local cFilSW9		:= xFilial("SW9")
Local cFilSWW		:= xFilial("SWW")
Local nT_ITEM		:= TamSx3('D1_ITEM')[1]
Local cAuxPaisL     := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14

DEFAULT aRecImp    := {}

lQuery	:=	TcSrvType()<>"AS/400"

nMoedaCor := If(nMoedaCor==NIL,1,nMoedaCor)
If lMovtaSD3 .AND. SF1->F1_TIPO_NF == "5"
	Return
EndIf

If lMovtaSD3	 //Ingresos e Custeos por Movimentos o Remitos
	DbSelectArea("SWN")
	DbSetOrder(2)
	MsSeek(cFilSWN+cDoc+cSerie+cFornece+cLoja)
	//³ Grava o Custo e as DE6 / RE6 para os Itens da NBM.           ³

	nQtdItens:=	Len(aCols)
	nItem		:=	4
	nPosCols	:=	1
	nRegs		:=	0
	lWN_LOCAL	:= .T.
	cAuxPaisL   := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
	lWN_DESPSUB	:= IIf(cPaisLoc $ cAuxPaisL, .T. , .F. )
	While !Eof() .AND. WN_FILIAL==cFilSWN .AND. WN_DOC==cDoc .AND. WN_SERIE==cSerie .AND. WN_FORNECE==cFornece .AND. WN_LOJA==cLoja
		nRegs++
		//Cada vez que processa nQtdItens registros do SWN, significa que passou para a
		//proxima linha do acols
		If nRegs	> nQtdItens
			nRegs	:=	0
			nPosCols++
		Endif
		If Type('otext')=='O' //Se foi chamada da MSAguarde()
			If Mod(nItem,nQtdItens)==0
		      	MsProcTxt(STR0004+SWN->WN_PRODUTO+" ("+StrZero((nItem/nQtdItens),4)+").")
  			EndIf
  			nItem++
		EndIf
		If	SWN->WN_TIPO_NF == "9" .OR. SWN->WN_TIPO_NF == "A"
			nValorCus := SWN->WN_DESPESA+SWN->WN_VALIMP5
		Else
			If lWN_DESPSUB
				nValorCus := Round(SWN->WN_VALOR-SWN->WN_DESPSUB,2)
			Else
				nValorCus := SWN->WN_VALOR
			EndIf
		EndIf
		If nValorCus >= 0.00

	    	SB1->(DbSetOrder(1))
    		SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

			//³ Posicionar os arquivos TES e PRODUTOS ³
			aTES := {}
			cTesDespacho := Space(3)

			If SWN->WN_TIPO_NF $ "5678"
				SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))
				AADD(aTes,SYD->YD_TES)
			Else
			   If lQuery
			   		cQuery	:=	" Select WD_TES FROM "+RetSqlName('SWW')+" SWW, "+RetSqlName('SWD')+" SWD	"
			   		cQuery	+=	" WHERE  WW_FILIAL  = '"+cFilSWW+"' AND "
					cQuery	+=	" WW_NF_COMP = '"+SF1->F1_DOC+"' AND "
					cQuery	+=	" WW_SE_NFC  = '"+SF1->F1_SERIE+"' AND "
					cQuery	+=	" WW_FORNECE = '"+SF1->F1_FORNECE+"'   AND "
					cQuery	+=	" WW_LOJA    = '"+SF1->F1_LOJA+"' AND "
			   		cQuery	+=	" WD_FILIAL  = '"+cFilSWD+"' AND "
					If UPPER(TcGetDb()) == "INFORMIX"
						cQuery	+=	" WD_DESPESA = SUBSTR(SWW.WW_DESPESA,1,3) AND "
					Else
						cQuery	+=	" WD_DESPESA = Left(SWW.WW_DESPESA,3) AND "
					EndIf
					cQuery	+=	" WD_DOCTO 	 = '"+SF1->F1_DOC+"' AND "
					cQuery	+=	" WD_HAWB 	 =  SWW.WW_HAWB AND "
					cQuery	+=	" SWD.D_E_L_E_T_='' AND "
					cQuery	+=	" SWW.D_E_L_E_T_='' "
					cQuery	+=	" GROUP BY WD_TES "

	  				cQuery	:=	ChangeQuery(cQuery)
	  				cAliasQry	:=	CriaTrab(Nil,.F.)
					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
					DbSelectArea(cAliasQry)
					While !EOF()
	  	         	nPosTes := Ascan(aTes,(cAliasQry)->WD_TES)
	  	         	If nPosTes == 0
  		   				AADD(aTes,If(Empty((cAliasQry)->WD_TES),aCols[nPosCols][nPosAColsTes],(cAliasQry)->WD_TES))
  						EndIf
			   		DbSkip()
					End
					DbCloseArea()
				Else
					DbSelectArea("SWW")
					DbSetOrder(1)
					If DbSeek(cFilSWW+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
						While ! Eof().AND. WW_FILIAL==cFilSWW .AND.;
      							WW_NF_COMP == SF1->F1_DOC     .AND.;
	  		    				WW_SE_NFC  == SF1->F1_SERIE   .AND.;
								WW_FORNECE == SF1->F1_FORNECE .AND.;
								WW_LOJA    == SF1->F1_LOJA

							DbSelectArea("SWD")
							DbSetOrder(3)
		   	 				If MsSeek(cFilSWD+Left(SWW->WW_DESPESA,3)+SWW->WW_NF_COMP+SWW->WW_HAWB)
		  		  				While !Eof() .AND.;
		    							WD_DESPESA == Left(SWW->WW_DESPESA,3) .AND.;
		    							WD_DOCTO == SWW->WW_NF_COMP .AND.;
		    							WD_HAWB == SWW->WW_HAWB
                    	    		nPosTes := Ascan(aTes,SWD->WD_TES)
                     	  			If nPosTes == 0
              							AADD(aTes,If(Empty(SWD->WD_TES),aCols[nPosCols][nPosAColsTes],SWD->WD_TES))
		    						EndIf
				   					DbSkip()
		   						End
		   					EndIf
		   					DbSelectArea("SWW")
			   				DbSkip()
						End
					EndIf
				EndIf
				DbSelectArea("SWN")
            EndIf

			For nE := 1 To Len(aTes)
				SF4->(MsSeek(cFilSF4+aTes[nE]))

		   		If !SF4->(EOF()) .AND. SF4->F4_ESTOQUE == "S"
					aCusto := {}
					If lWN_DESPSUB
						AADD(aCusto,{WN_VALOR-WN_DESPSUB,{},0,"N","N","","",WN_PRODUTO,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),WN_QUANT})
					Else
						AADD(aCusto,{WN_VALOR,{},0,"N","N","","",WN_PRODUTO,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),WN_QUANT})
					EndIf

					aImpostos := DefImposto(aTes[nE])
					For nY:=1 to Len(aImpostos)
						nPosSWN := SWN->(FieldPos("WN_"+Substr(aImpostos[nY][2],1,7)))
						If nPosSWN > 0
							If ( aImpostos[nY][5] $ "S1" )
								aCusto[1][1] += SWN->(FieldGet(nPosSWN))
							EndIf
						EndIf
					Next nY

					If SWN->WN_TIPO_NF $ "9"
						SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))
						cTesDespacho := SYD->YD_TES
						// Compara se Tes do Despacho é diferente do Tes de gastos
						If cTesDespacho != aTes[nE]
							aImpostos := DefImposto(cTesDespacho)
							For nY:=1 to Len(aImpostos)
								nPosSWN := SWN->(FieldPos("WN_"+Substr(aImpostos[nY][2],1,7)))
								If nPosSWN > 0
									If ( aImpostos[nY][5] $ "S1" )
										aCusto[1][1] += SWN->(FieldGet(nPosSWN))
									EndIf
								EndIf
							Next nY
						EndIf
		       		EndIf

					//³ Calcula o Custo de Entrada de Cada Item NBM                     ³

					aCustoEnt := {}
					aCustoEnt := RetCusEnt(,aCusto)

					//³ Gera lanç no SD3 para cada item do SWN.                   ³

					If Empty(WN_NUMSEQ)
						RecLock("SWN",.F.)
						Replace WN_NUMSEQ	With ProxNum()
						MsUnLock()
					EndIf

					If lWN_LOCAL
						MSGravaD3(	WN_PRODUTO,;
									SubStr(WN_PO_NUM,1,6),;
									WN_ITEM,;
									WN_QUANT,;
									aCustoEnt[1],;
									,;
									If(lSWNLote,SWN->WN_LOTECTL,""),;
									If(lSWNLote,SWN->WN_DTVALID,;
									CtoD("  /  /  ")),;
									If(lAtuSegUM,SWN->WN_QTSEGUM,0),;
									If(lAtuSegUM,SWN->WN_SEGUM,"  "),;
									If(Empty(SWN->WN_LOCAL),RetFldProd(SB1->B1_COD,"B1_LOCPAD"),SWN->WN_LOCAL))
					Else
						MSGravaD3(	WN_PRODUTO,;
									SubStr(WN_PO_NUM,1,6),;
									WN_ITEM,;
									WN_QUANT,;
									aCustoEnt[1],;
									,;
									If(lSWNLote,SWN->WN_LOTECTL,""),;
									If(lSWNLote,SWN->WN_DTVALID,;
									CtoD("  /  /  ")),;
									If(lAtuSegUM,SWN->WN_QTSEGUM,0),;
									If(lAtuSegUM,SWN->WN_SEGUM,))
					EndIf
					AAdd(aRecnoSD3,{SD3->(Recno()),SWN->(RECNO())} )
					If Empty(WN_NUMSEQ)
						RecLock("SWN",.F.)
						Replace WN_NUMSEQ	With ProxNum()
						MsUnLock()
					EndIf
					cPe	:=	LocxPE(42)
					If !Empty(cPe)
						ExecBlock(cPe,.F.,.F.)
					EndIf

					Exit
				EndIf
			Next nE
		EndIf
		DbSelectArea("SWN")
		DbSkip()
	End
Else
	aAreaSF1 := SF1->(GetArea())
	aAreaSD1 := SD1->(GetArea())

	If GetMv('MV_FLTD1D2')
		SF1->(DbClearFilter())
	EndIf

	SB2->(DbSetOrder(1))
	DbSelectArea("SWN")
	DbSetOrder(1)
	DbSeek(cFilSWN+cDoc+cSerie)
	cTipoNF := SWN->WN_TIPO_NF
	cHawb   := SWN->WN_HAWB
	cFornece:= SWN->WN_FORNECE
	cLoja   := SWN->WN_LOJA
	cLoteCtl:= SWN->WN_LOTECTL

	//³ Se eh FOB so tem um remito

	If cTipoNf  == '5'
		aRemito    := LocxNrReIm(SWN->WN_HAWB,Substr(SWN->WN_INVOICE,1,Len(SF1->F1_DOC))) // Buscar o remito da invoice
		cSerRemito := aRemito[1]
		cNumRemito := aRemito[2]
		cFornece   := If(Empty(aRemito[3]),SF1->F1_FORNECE,aRemito[3])
		cLoja      := If(Empty(aRemito[4]),SF1->F1_LOJA   ,aRemito[4])
		RecLock("SF1",.F.)
		Replace SF1->F1_REMITO With cNumRemito
		SF1->(MsUnlock())
	EndIf

	//³ Grava Remitos para registrar Ingresos ³

	nItem   := 0
	cInvAnt	:=	''

	DbSelectArea("SWN")
	DbSetOrder(1)
	lWN_TES 		:= cPaisLoc == "ARG"
	lWN_ITEMNF		:= cPaisLoc == "ARG"
	lWN_LOCAL		:= .T.
	lWN_DESPSUB	    := cPaisLoc $ cAuxPaisL
	While !Eof() .AND. WN_FILIAL==cFilSWN .AND. WN_DOC==cDoc .AND. WN_SERIE==cSerie

		AAdd(aRecImp,{0,SWN->(RECNO())})

		If cTipoNf  <> '5'
			If SWN->WN_INVOICE <> cInvAnt
				aRemito		:= LocxNrReIm(SWN->WN_HAWB,Substr(SWN->WN_INVOICE,1,Len(SF1->F1_DOC))) //Buscar o remito da invoice
				cSerRemito  := aRemito[1]
				cNumRemito 	:= aRemito[2]
				cFornece 	:= If(Empty(aRemito[3]),SF1->F1_FORNECE,aRemito[3])
				cLoja 		:= If(Empty(aRemito[4]),SF1->F1_LOJA,aRemito[4])
				cInvAnt 	:= SWN->WN_INVOICE
			EndIf
        EndIf

		If lWN_DESPSUB
			nValorCus := Round(SWN->WN_VALOR-SWN->WN_DESPSUB,2)
		Else
			nValorCus := SWN->WN_VALOR
		EndIf

		If nValorCus > 0.00
	    	SB1->(DbSetOrder(1))
    		SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

	    	SW6->(DbSetOrder(1))
    		SW6->(MsSeek(cFilSW6+SWN->WN_HAWB))

	    	SW9->(DbSetOrder(1))
    		SW9->(DbSeek(cFilSW9+SWN->WN_INVOICE+SWN->WN_FORNECE))

			//³ Posicionar os arquivos TES e PRODUTOS                           ³

			aTES         := {}
			cTesDespacho := Space(3)

			//³ Devido a gravacao das notas serem diferentes, o SWN sempre      |
			//³ mostrara os dados do produto importado e nas notas tipo 9/A as  |
			//| despesas usarao seu proprio TES (D1_TESDES).                    |

			If SWN->WN_TIPO_NF $ "5678"
				If lWN_TES
					AADD(aTes,SWN->WN_TES)
				Else
					SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))
					AADD(aTes,SYD->YD_TES)
				EndIf
			Else
    			DbSelectArea("SD1")
				DbSetOrder(2)
				MsSeek(cFilSD1+SWN->WN_PRODUTO+cNFiscalDes+cSerieDes+cFornDes+cLojaDes)

	           	nPosTes := Ascan(aTes,SD1->D1_TESDES)
               	If nPosTes == 0
   					AADD(aTes,SD1->D1_TESDES)
   				EndIf
  			EndIf

			//-- Posiciona TES
			SF4->(MsSeek(cFilSF4+aTes[1]))

        	//-- Posiciona Despesas/Gastos da import.
        	SWD->(DbSetOrder(1))
            SWD->(DbSeek(cSeek:=cFilSWD+SWN->WN_HAWB))
			Do While SWD->(!Eof()) .AND. cSeek == SWD->WD_FILIAL+SWD->WD_HAWB
			    If SWD->WD_DOCTO == SWN->WN_DOC .AND. SWD->WD_SE_DOC == SWN->WN_SERIE
			    	Exit
			    EndIf
				SWD->(dbSkip())
			End

			DbSelectArea("SWN")

			DbSelectArea("SF1")
			DbSetOrder(1)
			If lUsaNewKey
				cSerRemito:=SerieNfId("SF1",4,"F1_SERIE",SW9->W9_DT_EMIS,"RCN",cSerRemito)
			Endif
			DbSeek(cFilSF1+cNumRemito+cSerRemito+cFornece+cLoja)
			If !Found() .AND. SWN->WN_TIPO_NF == "5"
				RecLock("SF1",.T.)
				Replace F1_FILIAL		With cFilSF1
				Replace F1_DOC			With cNumRemito
				SerieNfId("SF1",1,"F1_SERIE",SW9->W9_DT_EMIS,"RCN",subStr(cSerRemito,1,3)) //Projeto Chave Unica - Tiago Silva
				Replace F1_FORNECE		With cFornece
				Replace F1_LOJA			With cLoja
				Replace F1_TIPODOC		With "10"
				Replace F1_MOEDA		With nMoedaCor
				Replace F1_TXMOEDA		With RecMoeda(dDataBase,nMoedaCor)
				Replace F1_ESPECIE		With "RCN"
				Replace F1_TIPO			With "N"
				Replace F1_STATUS		With "A"
				//Integracao com EIC, Lucas 12/08/2007
				Replace F1_EMISSAO		With SW9->W9_DT_EMIS
				Replace F1_DTDIGIT		With dDataBase
				Replace F1_HAWB     	With SWN->WN_HAWB
				Replace F1_TIPO_NF		With If(SWN->WN_TIPO_NF != "8","5",SWN->WN_TIPO_NF)
				MsUnLock()
			EndIf

			If SWN->WN_TIPO_NF == "5" //So gera SD1 para NF tipo FOB
				nItem++
				RecLock("SD1",.T.)
				Replace D1_FILIAL		With cFilSD1
				Replace D1_DOC			With cNumRemito
				SerieNfId("SD1",1,"D1_SERIE",SF1->F1_EMISSAO,"RCN",subStr(cSerRemito,1,3)) //Projeto Chave Unica - Tiago Silva
				Replace D1_FORNECE		With cFornece
				Replace D1_LOJA			With cLoja
				Replace D1_DTDIGIT		With dDataBase
				Replace D1_TIPO			With "N"
				Replace D1_ESPECIE		With "RCN"
				If cPaisLoc=="ARG"
				   Replace D1_ITEM		With STRZERO(VAL(SWN->WN_ITEMNF),TamSX3("D1_ITEM")[1] )//cItemRem
				Else
				   Replace D1_ITEM			With STRZERO(nItem,nT_ITEM)//cItemRem
				EndIf
				Replace D1_COD      	With SWN->WN_PRODUTO
				Replace D1_UM			With SB1->B1_UM
				Replace D1_SEGUM		With SB1->B1_SEGUM
				Replace D1_LOCAL		With SWN->WN_LOCAL
				Replace D1_LOTECTL		With SWN->WN_LOTECTL
				Replace D1_NUMLOTE		With SWN->WN_NUMLOTE
				Replace D1_DTVALID		With SWN->WN_DTVALID
				Replace D1_TIPODOC		With "64"
				Replace D1_QUANT		With SWN->WN_QUANT
				Replace D1_QTSEGUM		With SWN->WN_QTSEGUM
				Replace D1_TES			With aTes[1]
				Replace D1_CF			With SF4->F4_CF
				Replace D1_QTDACLA		With SD1->D1_QUANT
				Replace D1_TEC			With SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM
				Replace D1_CONHEC		With SWN->WN_HAWB
				Replace D1_TIPO_NF		With SF1->F1_TIPO_NF
				Replace D1_NUMSEQ		With ProxNum()
				Replace D1_EMISSAO		With SF1->F1_EMISSAO
				Replace D1_PEDIDO		With SWN->WN_PO_NUM
				Replace D1_ITEMPC		With SWN->WN_ITEM
                MsUnLock()
    		EndIf

			If lWN_ITEMNF
				DbSelectArea("SD1")
				DbSetOrder(1)
				MsSeek(cFilSD1+cNumRemito+cSerRemito+cFornece+cLoja+SWN->WN_PRODUTO+SWN->WN_ITEMNF)
			Else
				DbSelectArea('SD1')
				DbSetOrder(1)
				MsSeek(cFilSD1+cNumRemito+cSerRemito+cFornece+cLoja+SWN->WN_PRODUTO+If(SWN->WN_TIPO_NF=="5",STRZERO(nItem,nT_ITEM),""))
			EndIf

            If SD1->(Found())

				If SWN->WN_TIPO_NF == "9" .OR. SWN->WN_TIPO_NF == "A"	//Nota de Despesas do Despachante ou Nota Complementar de Custos

	    	      	//³ Pegar a taxa da Moeda do cabealho da fatura de Importacao  na tabela  |
            		//³ para pegar la moneda, tasa y TES.                                     ³

					nTxCusEIC  := SWD->WD_TX_MOE
					nMoedaOrig := SimbToMoeda(SWD->WD_MOEDA)
					nMoedaOrig := If(nMoedaOrig>0,nMoedaOrig,1)
					dDataTaxa  := If( Empty(SWD->WD_DT_EMIS),SWD->WD_DES_ADI,SWD->WD_DT_EMIS)

        		    //³ Gravar D1_TOTAL y D1_CUSTO ya convertido...      ³

					If nTxCusEIC == 0
						nTxCusEIC := 1
					EndIf

				    //³ Pesquisa TES do cadastro de NCM                  ³

					SYD->(dbSetOrder(1))
					SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))

					If lWN_TES .AND. !Empty(SWN->WN_TES)
						nValImpX  := LxSomaImp(SWN->WN_TES)
					Else
						nValImpX  := LxSomaImp(IIf(Found(),SYD->YD_TES,SD1->D1_TES))
					EndIf

					RecLock( 'SD1', .F. )
	    			Replace D1_TOTAL With D1_TOTAL + (SWN->WN_DESPESA+nValImpX)
			    	Replace D1_VUNIT With (D1_TOTAL/D1_QUANT)
    				Replace D1_CUSTO With D1_CUSTO + (SWN->WN_DESPESA+nValImpX)

					//³ Grava custo em moeda 2,3,4 y 5.                              ³

					aMoeda := {"","","","",""}
					For nY := 2 To 5
						cCampo := "SD1->D1_CUSTO"+Str(nY,1,0)
						If nMoedaOrig = nY
							Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
				        Else
							aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
        					Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
			    		EndIf
				    Next nY
					SD1->(MsUnLock())
					If SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))
		    	    	Reclock("SB2",.F.)
			    	    Replace SB2->B2_VATU1 With SB2->B2_VATU1 + xMoeda(SWN->WN_DESPESA+nValImpX,1,1,SF1->F1_EMISSAO,,,nTxCusEIC)
						aMoeda := {"","","","",""}
						For nY := 2 To 5
							cCampo := "SB2->B2_VATU"+Str(nY,1,0)
							If nMoedaOrig = nY
								Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
					        Else
								aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
								Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
				    		EndIf
					    Next nY
						SB2->(MsUnLock())
						If SB2->B2_QATU > 0
							RecLock("SB2",.F.)
							Replace SB2->B2_CM1		With SB2->B2_VATU1/SB2->B2_QATU
							Replace SB2->B2_CM2		With SB2->B2_VATU2/SB2->B2_QATU
							Replace SB2->B2_CM3		With SB2->B2_VATU3/SB2->B2_QATU
							Replace SB2->B2_CM4		With SB2->B2_VATU4/SB2->B2_QATU
							Replace SB2->B2_CM5		With SB2->B2_VATU5/SB2->B2_QATU
							SB2->(MsUnLock())
						EndIf

						//³Atualiza o custo unificado ON-LINE                     ³

						If lB2AtuUnif
							B2AtuUnif(SB2->B2_COD)
						EndIf
           	        EndIf

					//³ Acumular F1_VALMERC y F1_VALBRUT en SF1.    					|

					DbSelectArea('SF1')
					RecLock( 'SF1', .F. )
					Replace F1_VALMERC 	With F1_VALMERC + SWN->WN_DESPESA+nValImpX
					Replace F1_VALBRUT	With F1_VALBRUT + SWN->WN_DESPESA+nValImpX
					MsUnlock()

				ElseIf SWN->WN_TIPO_NF $ "5678" //FOB, Frete ou Seguro

           	    	//³  Pegar Moeda e Taxa do arquivo de Processos.        ³

	            	If 	SWN->WN_TIPO_NF $ "5|8"     //FOB ou CIF
	            		cMoedaEIC := SW9->W9_MOE_FOB
                 		nTxCusEIC := SW9->W9_TX_FOB
						dDataTaxa := SW9->W9_DT_EMIS
                 	ElseIf SWN->WN_TIPO_NF $ "6"	//Frete
	            		cMoedaEIC := SW6->W6_FREMOED
                   		nTxCusEIC := SW6->W6_TX_FRET
						dDataTaxa := SW6->W6_DTREG_D
                   	ElseIf SWN->WN_TIPO_NF $ "7"    //Seguro
		           		cMoedaEIC := SW6->W6_SEGMOED
    	           		nTxCusEIC := SW6->W6_TX_SEG
						dDataTaxa := SW6->W6_DTREG_D
    	           	EndIf

  	             	nMoedaOrig := SimbToMoeda(cMoedaEIC)
  	             	nMoedaOrig := If(nMoedaOrig>0,nMoedaOrig,1)

					RecLock( 'SD1', .F. )
	    			Replace D1_TOTAL 	With D1_TOTAL + (SWN->WN_VALOR - SWN->WN_DESPSUB)
			    	Replace D1_VUNIT  	With D1_TOTAL/D1_QUANT
   					Replace D1_CUSTO 	With D1_CUSTO + (SWN->WN_VALOR - SWN->WN_DESPSUB)


           			//³ Grava custo em moeda 2,3,4 y 5.  ³

					aMoeda := {"","","","",""}
					For nY := 2 To 5
						cCampo := "SD1->D1_CUSTO"+Str(nY,1,0)
						If nMoedaOrig = nY
			        		Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
				        Else
							aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
			        		Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
			    		EndIf
				    Next nY
					SD1->(MsUnLock())

					//³ Atualizar Saldos Fisico e Financeiro  |

					If SWN->WN_TIPO_NF $ "5|8"
						If ! SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))
							CriaSB2(SD1->D1_COD,D1_LOCAL)
						EndIf
						DbSelectArea("SB2")
						RecLock("SB2",.F.)
						Replace B2_QATU	With B2_QATU + SD1->D1_QUANT
						Replace B2_QTSEGUM	With B2_QTSEGUM + SD1->D1_QTSEGUM
						MsUnLock()

						//³ Movimenta Lotes/Sub-Lotes/Localizacao Fisica³

						If Rastro(SD1->D1_COD) .OR. Localiza(SD1->D1_COD)

							//³ Tratamento da gravacao do SD1 na Integridade Referencial  ³

							SD1->(FkCommit())
							dDtValid	:= SD1->D1_DTVALID
							If !Empty(SD1->D1_LOTECTL)
								SB8->(DbSetOrder(3))
								If SB8->(MsSeek(cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL))
									dDtValid	:=	SB8->B8_DTVALID
								EndIf
							EndIf

							//³ MovLote - Utilizada para gravacao da rastreabilidade do produto     ³

							cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
							MovLote("SD1",;					//1
									SD1->D1_COD,;			//2
									SD1->D1_LOCAL,;			//3
									If((cPaisLoc<>"BRA") .AND. cPaisLoc $ cAuxPaisL,SD1->D1_LOCALIZ,NIL),;	//4
									If((cPaisLoc<>"BRA") .AND. cPaisLoc $ cAuxPaisL,SD1->D1_NUMSERI,NIL),;	//5
									SD1->D1_LOTECTL,;		//6
									SD1->D1_NUMLOTE,;		//7
									SD1->D1_NUMSEQ,;		//8
									SD1->D1_TES,;         	//9
									SD1->D1_FORNECE,;		//10
									SD1->D1_LOJA,;			//11
									SD1->D1_LOTEFOR,;		//12
									"RCN",;					//13
									SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD,;	//14
									SD1->D1_DOC,;			//15
									SD1->D1_SERIE,;			//16
									SD1->D1_OP,;			//17
									NIL,;					//18
									NIL,;					//19
									NIL,;					//20
									NIL,;					//21
									SD1->D1_QUANT,;			//22
									SD1->D1_QTSEGUM,;		//23
									SD1->D1_DTDIGIT,;		//24
									dDtValid,;				//25
									NIL,;					//26
									NIL,;					//27
									SD1->D1_TES>"500",;   	//28
									.T.,;					//29
									SD1->D1_TES<="500",; 	//30
									NIL,;					//31
									NIL,;					//32
									NIL,;					//33
									NIL,;					//34
									NIL,;					//35
									NIL,;					//36
									NIL,;					//37
									NIL,;					//38
									NIL,;					//39
									NIL,;					//40
									NIL,;					//41
									NIL,;					//42
									NIL,;					//43
									NIL,;					//44
									NIL,;					//45
									NIL,;					//46
									NIL,;					//47
									NIL,;					//48
									NIL,;					//49
									SD1->D1_POTENCI) 		//50
							LogMov("SD1",,,,,,.F.,"SD1")
						EndIf
					EndIf

					//³ Atualizar Saldos Fisico e Financeiro |
					If SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))
		    	    	RecLock("SB2",.F.)
						Replace B2_VATU1 	With B2_VATU1 + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,1,SF1->F1_EMISSAO,,,nTxCusEIC)
						aMoeda := {"","","","",""}
						For nY := 2 To 5
							cCampo := "SB2->B2_VATU"+Str(nY,1,0)
							If nMoedaOrig = nY
					    	    Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
					        Else
								aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
					    	    Replace &(cCampo) With &(cCampo) + xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
				    		EndIf
					    Next nY
					    SB2->(MsUnLock())
						If SB2->B2_QATU > 0
						    RecLock("SB2",.F.)
							Replace SB2->B2_CM1		With SB2->B2_VATU1/SB2->B2_QATU
							Replace SB2->B2_CM2		With SB2->B2_VATU2/SB2->B2_QATU
							Replace SB2->B2_CM3		With SB2->B2_VATU3/SB2->B2_QATU
							Replace SB2->B2_CM4		With SB2->B2_VATU4/SB2->B2_QATU
							Replace SB2->B2_CM5		With SB2->B2_VATU5/SB2->B2_QATU
						EndIf
						SB2->(MsUnLock())

						//³Atualiza o custo unificado ON-LINE  ³

						If lB2AtuUnif
							B2AtuUnif(SB2->B2_COD)
						EndIf

           	        EndIf
					//³ Acumular F1_VALMERC y F1_VALBRUT en SF1.  |
					DbSelectArea('SF1')
					RecLock( 'SF1', .F. )
					Replace F1_VALMERC 	     With F1_VALMERC + ( SWN->WN_VALOR - SWN->WN_DESPSUB )
					Replace F1_VALBRUT		 With F1_VALBRUT + ( SWN->WN_VALOR - SWN->WN_DESPSUB )
					MsUnlock()
				EndIf
			EndIf
		EndIf
		DbSelectArea("SWN")
		DbSkip()
	End

	If GetMv('MV_FLTD1D2')
		Eval( bFilBrw )
	EndIf

EndIf

RestArea(aArea)
Return aRecnoSD3

Function LocxNCPEic(xAutoCab,xAutoItens,nOpc)
LOCAL aAutoCab	 := xAutoCab
LOCAL aAutoItens := xAutoItens
LOCAL nTxCusEic  := 0.00
LOCAL aTes 	:= {}
LOCAL lDupl := .F.
LOCAL nI	:= 0
LOCAL nJ	:= 0
LOCAL cFilSA2	:= xFilial("SA2")
LOCAL cFilSB1	:= xFilial("SB1")
LOCAL cFilSD2	:= xFilial("SD2")
LOCAL cFilSD3	:= xFilial("SD3")
LOCAL cFilSE2	:= xFilial("SE2")
LOCAL cFilSF4	:= xFilial("SF4")
LOCAL cFilSWD	:= xFilial("SWD")
LOCAL cFilSWN	:= xFilial("SWN")
LOCAL cAliasSE2	:= ""
LOCAL cQuery	:= ""
LOCAL lUsaNewKey:= TamSX3("F2_SERIE")[1] == 14
LOCAL cPref		:= ""

nPosDoc   := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_DOC"})
nPosSerie := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_SERIE"})
nPosForn  := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_CLIENTE"})
nPosLoja  := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_LOJA"})
nPosCond  := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_COND"})
nPosValor := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_VALBRUT"})
nPosHawb  := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "F2_HAWB"})

If nPosDoc > 0
	cNFiscal := aAutoCab[nPosDoc][2]
EndIf
If nPosSerie > 0
	cSerie := aAutoCab[nPosSerie][2]
EndIf
If nPosForn > 0
	cFornece := aAutoCab[nPosForn][2]
EndIf
If nPosLoja > 0
	cLoja := aAutoCab[nPosLoja][2]
EndIf
If nPosCond > 0
	cCond := aAutoCab[nPosCond][2]
EndIf
If nPosValor > 0
   nValDup := aAutoCab[nPosValor][2]
EndIf
If nPosHawb > 0
   cHawb := aAutoCab[nPosHawb][2]
EndIf

If nOpc == 3 //Inclusao
	If lUsaNewKey

		cAliasSE2 := "ALxNCPEic"
		cQuery := " SELECT MAX(E2_PREFIXO) E2PRFXMAX FROM " + RetSqlName("SE2")
		cQuery += " WHERE E2_FILIAL = '" + cFilSE2 + "'"
		cQuery += " AND E2_NUM      = '" + cNFiscal + "'"
		cQuery += " AND E2_FORNECE  = '" + cFornece + "'"
		cQuery += " AND E2_LOJA     = '" + cLoja+ "'"
		cQuery += " AND D_E_L_E_T_  = ''"
	   	cQuery	  := ChangeQuery(cQuery)
		cAliasSE2 := CriaTrab(Nil,.F.)

		dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasSE2, .T., .T. )
		DbSelectArea(cAliasSE2)

		If !Empty( (cAliasSE2)->E2PRFXMAX )
			cPref:= Soma1( (cAliasSE2)->E2PRFXMAX , TamSX3("E2_PREFIXO")[1] )
			/*
			Devido ao projeto CHAVE ÚNICA, a consistência abaixo é necessária para
			garantir que o novo título a ser gerado não irá colidir com um título
			da base histórica do cliente criada antes do projeto chave única.
			*/
			While .T.
				SE2->(dbSetOrder(1))
				If (SE2->(dbSeek(cFilSE2+cPref+cNFiscal)))
					cPref:= Soma1(cPref, TamSX3("E2_PREFIXO")[1])
				Else
					EXIT
				EndIf
			EndDo
		EndIf
		(cAliasSE2)->(DbCloseArea())
	Endif

	DbSelectArea("SF2")
	DbSetOrder(1)
	MsSeek(xFilial("SF2")+cNFiscal+cSerie+cFornece+cLoja)
	If Found()
		MsgStop("Nota de Credito ya existe!!!","Atencion")
		Return(.F.)
	EndIf

	DbSelectArea("SF2")
	RecLock("SF2",.T.)
	For nI := 1 To Len(aAutoCab)
		SF2->(FieldPut(FieldPos(AllTrim(aAutoCab[nI][1])),aAutoCab[nI][2]))
	Next nI
	Replace F2_FILIAL   With xFilial("SF2")
	Replace F2_TIPODOC  With "07"
	If lUsaNewKey .AND. !empty(cPref)
		Replace F2_PREFIXO	With cPref
	Else
		Replace F2_PREFIXO	With F2_SERIE
	Endif
	Replace F2_HAWB		With cHawb
	MsUnLock()

	For nI := 1 To Len(aAutoItens)
		RecLock("SD2",.T.)
		For nJ := 1 To Len(aAutoItens[nI])
			SD2->(FieldPut(FieldPos(AllTrim(aAutoItens[nI][nJ][1])),aAutoItens[nI][nJ][2]))
		Next nJ
		Replace D2_FILIAL With cFilSD2

		SB1->(DbSetOrder(1))
		SB1->(MsSeek(cFilSB1+SD2->D2_COD))

		AADD(aTes,SD2->D2_TES)

		Replace D2_ITEM		With StrZero(nI,Len(D2_ITEM))
		Replace D2_TIPO		With SF2->F2_TIPO
		Replace D2_FORMUL	With SF2->F2_FORMUL
		Replace D2_ESPECIE	With SF2->F2_ESPECIE
		Replace D2_TIPODOC	With "07"
		Replace D2_NUMSEQ	With ProxNum()
		Replace D2_UM		With SB1->B1_UM
		Replace D2_EST		With SF2->F2_EST
		MsUnLock()
	Next nI

	For nI := 1 To Len(aTes)
		SF4->(DbSetOrder(1))
		SF4->(MsSeek(cFilSF4+aTes[nI]))
		lDupl := If(SF4->F4_DUPLIC=="S",.T.,.F.)
		If lDupl
			nI := Len(aTes)
		EndIf
	Next nI
	//³ Quando impostos variaveis acrescentar o Array de impostos Variaveis ³
	If SuperGetMV("MV_EASYFIN") == "N" .AND. lDupl
		nValDup := ValDuplic(nValDup)
		aVenc := Condicao(nValDup,cCond,0.00,dDataBase,0.00)
		nDup  := Len(aVenc)

		DbSelectArea("SE1")
		For nI := 1 To nDup

			//³ VerIfica moeda para deducao do arredondamento     ³

			nValor := aVenc[nI][2]

			If nDup == 1
				cParcela := " "
			EndIf

			DbSelectArea("SA2")
			DbSetOrder(1)
			MsSeek(cFilSA2+cFornece+cLoja)

			DbSelectArea("SE2")
			RecLock("SE2",.T.)
			Replace	E2_FILIAL  With cFilSE2
			If lUsaNewKey .AND. !empty(cPref)
				Replace E2_PREFIXO With cPref
			Else
				Replace E2_PREFIXO With cSerie
			Endif
			Replace E2_EMISSAO With dDataBase
			Replace E2_EMIS1   With dDataBase
			Replace	E2_FORNECE With SA2->A2_COD
			Replace	E2_LOJA    With SA2->A2_LOJA
			Replace	E2_NOMFOR  With SA2->A2_NREDUZ
			Replace	E2_TIPO    With "NCP"
			Replace E2_MOEDA   With SF2->F2_MOEDA
			Replace	E2_LA      With "S"
			Replace E2_NUM     With cNFiscal
			Replace	E2_PARCELA With cParcela
			Replace	E2_VENCORI With aVenc[nI][1]
			Replace	E2_VENCTO  With aVenc[nI][1]
			Replace	E2_VENCREA With DataValida(aVenc[nI][1])
			Replace	E2_VALOR   With nValor
			Replace	E2_SALDO   With nValor
			Replace	E2_NATUREZ With SF2->F2_NATUREZ
			Replace	E2_ORIGEM  With "MATA466N"
			If cPaisLoc=="PER"
				Iif(!empty(SF2->F2_SERORI),SerieNfid("SE2",1,"E2_SERORI",,,,SF2->F2_SERORI),) //Projeto Chave Unica - Tiago Silva
	      	EndIf
			A050DupPag("MATA466",(nI==1),0)
			Replace E2_VLCRUZ  With Round(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,,SF2->F2_TXMOEDA),MsDecimais(SF2->F2_TXMOEDA))
		Next nI
    EndIf

	lQtdZero  := .T.
	aCusto    := {}
	aCM       := {}
	cTesEIC   := ""
	nTxCusEIC := 0.00
	aImposto  := {}
	nPosSWN   := 0

	DbSelectArea("SWN")
	DbSetOrder(2)
	If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
	   While !Eof() .AND.;
			WN_FILIAL == cFilSWN .AND.;
	   		WN_DOC == SF2->F2_DOC .AND.;
	   		WN_SERIE == SF2->F2_SERIE

			SB1->(DbSetOrder(1))
			SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

	   		If WN_TIPO_NF == "N"

		   		RecLock("SWN",.F.)
		   		Replace WN_NUMSEQ	With ProxNum()
		   		MsUnLock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gravar no SD3 a 'DE8' para o Produto  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				RecLock('SD3',.T.)
				Replace D3_FILIAL  With cFilSD3
				Replace D3_COD	   With SWN->WN_PRODUTO
				Replace D3_GRUPO   With SB1->B1_GRUPO
				Replace D3_TIPO    With SB1->B1_TIPO
				Replace D3_LOCAL   With SWN->WN_LOCAL
				Replace D3_UM	   With SB1->B1_UM
				Replace D3_CONTA   With SB1->B1_CONTA
				Replace D3_DOC	   With SWN->WN_DOC
				Replace D3_QUANT   With 0.00
				Replace D3_CF	   With 'DE8' 	//-- Identifica Movimentacao com Origem no SIGAEIC
				Replace D3_TM	   With '999'
				Replace D3_USUARIO With SubStr(cUsuario,7,15)
				Replace D3_NUMSEQ  With SWN->WN_NUMSEQ
				Replace D3_EMISSAO With dDataBase
				Replace D3_CHAVE   With 'E9' 	//-- N„o Alterar !!!
				Replace D3_QTSEGUM With SWN->WN_QTSEGUM
				Replace D3_SEGUM   With SB1->B1_SEGUM
				Replace D3_IDENT   With ""		//cNumSeqD1  //-- Diferencia as Movimentacoes
				Replace D3_DOCSWN  With SWN->WN_PO_NUM
				Replace D3_ITEMSWN With SWN->WN_ITEM

				MsUnLock()

        	    aCusto := {SWN->WN_VALOR,0,0,0,0}

				//³ Pegar taxa das despesas para custeos em outras moedas.     ³

				SWD->(DbSetOrder(3))
       			If SWD->(MsSeek(cFilSWD+SWN->WN_CODESP+SWN->WN_DOC+SWN->WN_HAWB))
				   nTxCusEIC := SWD->WD_TX_MOE
     			EndIf

				aCM := AClone(aCusto)

				For nI := 1 To Len(aCusto)
					cMoeda := Str(nI,1)
					If nI > 1 .AND. !Empty(GetMV("MV_MOEDA"+cMoeda))
					    If Empty(nTxCusEic)
					    	nTxCusEic := RecMoeda(dDataBase,nI)
					    EndIf
					    aCM[nI] := aCM[1]/nTxCusEic
					EndIf
				Next nI

				aCusto := GravaCusD3(aCM,,,,lQtdZero)
				B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,.T.)
			EndIf
		   	DbSelectArea("SWN")
			DbSkip()
		End
	EndIf
EndIf

If nOpc == 5	//Apagar
	lQtdZero  := .T.
	aCusto    := {}
	aCM       := {}
	cTesEIC   := ""
	nTxCusEIC := 0.00
	aImposto  := {}
	nPosSWN   := 0

	DbSelectArea("SF2")
	DbSetOrder(1)
	MsSeek(xFilial("SF2")+cNFiscal+cSerie+cFornece+cLoja)
	If !Found()
		MsgStop("Nota de Credito no existe!!!","Atencion")
		Return(.F.)
	EndIf

 	DbSelectArea("SWN")
	DbSetOrder(2)
	If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
		While !Eof() .AND.;
			WN_FILIAL == cFilSWN .AND.;
		   	WN_DOC == SF2->F2_DOC .AND.;
		   	WN_SERIE == SF2->F2_SERIE

		   	SB1->(DbSetOrder(1))
 			SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))

		   	SD2->(DbSetOrder(1))
 			SD2->(DbSeek(cFilSD2+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA))

 			If WN_TIPO_NF == "N"

				//³ Gravar no SD3 a 'DE8' para o Produto ³

				RecLock('SD3',.T.)
				Replace D3_FILIAL  With cFilSD3
				Replace D3_COD	   With SWN->WN_PRODUTO
				Replace D3_GRUPO   With SB1->B1_GRUPO
				Replace D3_TIPO    With SB1->B1_TIPO
				Replace D3_LOCAL   With SWN->WN_LOCAL
				Replace D3_UM	   With SB1->B1_UM
				Replace D3_CONTA   With SB1->B1_CONTA
				Replace D3_DOC	   With SWN->WN_DOC
				Replace D3_QUANT   With 0.00
				Replace D3_CF	   With 'RE8' 	//-- Identifica Movimentacao com Origem no SIGAEIC
				Replace D3_TM	   With '499'
				Replace D3_USUARIO With SubStr(cUsuario,7,15)
				Replace D3_NUMSEQ  With SWN->WN_NUMSEQ
				Replace D3_EMISSAO With SD2->D2_EMISSAO
				Replace D3_CHAVE   With 'E9' 	//-- N„o Alterar !!!
				Replace D3_SEGUM   With SB1->B1_SEGUM
				Replace D3_IDENT   With ""		//cNumSeqD1  //-- Diferencia as Movimentacoes
				Replace D3_EMISSAO With dDataBase
				MsUnlock()

			    aCusto := {SWN->WN_VALOR,0,0,0,0}

				//³ Pegar taxa das despesas para custeos em outras moedas.     ³

				SWD->(DbSetOrder(3))
       			If SWD->(MsSeek(cFilSWD+SWN->WN_CODESP+SWN->WN_DOC+SWN->WN_HAWB))
					nTxCusEIC := SWD->WD_TX_MOE
     			EndIf

				aCM := AClone(aCusto)

				For nI := 1 To Len(aCusto)
					cMoeda := Str(nI,1)
					If nI > 1 .AND. !Empty(GetMV("MV_MOEDA"+cMoeda))
					    If Empty(nTxCusEic)
					    	nTxCusEic := RecMoeda(dDataBase,nI)
					    EndIf
					    aCM[nI] := aCM[1]/nTxCusEic
					EndIf
				Next nI

				aCusto := GravaCusD3(aCM,,,,lQtdZero)

				B2AtuComD3(aCusto,NIL,NIL,NIL,NIL,.T.)

			EndIf
			DbSelectArea("SWN")
			DbSkip()
		End
	EndIf

	DbSelectArea("SWN")
	DbSetOrder(1)
	If DbSeek(cFilSWN+SF2->F2_DOC+SF2->F2_SERIE)
		While !Eof() .AND.;
			WN_FILIAL == cFilSWN .AND.;
		   	WN_DOC == SF2->F2_DOC .AND.;
		   	WN_SERIE == SF2->F2_SERIE

			If WN_TIPO_NF == "N"
				DbSelectArea("SD3")
				If MsSeek(cFilSD3+SWN->WN_DOC+SWN->WN_PRODUTO)
					RecLock('SD3',.F.)
					Replace D3_ESTORNO	With "S"
					MsUnlock()
				EndIf
			EndIf
	   		DbSelectArea("SWN")
			DbSkip()
		End
	EndIf

	If SuperGetMV("MV_EASYFIN") == "N"
		DbSelectArea("SE2")
		DbSetOrder(1)
		DbSeek(xFilial("SE2")+SF2->F2_SERIE+SF2->F2_DOC)
		While !Eof() .AND. E2_PREFIXO == SF2->F2_SERIE .AND.;
			E2_NUM == SF2->F2_DOC

			If E2_FORNECE == SF2->F2_CLIENTE .AND. E2_LOJA == SF2->F2_LOJA
				RecLock("SE2",.F.)
				DbDelete()
				MsUnLock()
			EndIf
			DbSkip()
		End
	EndIf

	DbSelectArea("SD2")
    DbSetOrder(3)
    DbSeek(xFilial("SD2")+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA)
    While ! Eof() .AND.;
    	D2_DOC     == SF2->F2_DOC     .AND.;
    	D2_SERIE   == SF2->F2_SERIE   .AND.;
    	D2_CLIENTE == SF2->F2_CLIENTE .AND.;
    	D2_LOJA    == SF2->F2_LOJA
    	RecLock("SD2",.F.)
    	DbDelete()
    	MsUnLock()
    	DbSkip()
    End

	DbSelectArea("SF2")
	RecLock("SF2",.F.)
	DbDelete()
	MsUnLock()
EndIf
Return
/*
±±³Funcao    ³ SetSX7Total ³±±
±±³Descri‡…o ³ Devolver array com todos gatilhos que afetam o conteudo dos³±±
±±³          ³ campos de Totais (D1_TOTAL ou D2_TOTAL)...                 ³±±
±±³Sintaxe   ³ ExpA1 := SetSX7Total()                                     ³±±
*/
Static Function SetSX7Total()
LOCAL aCpos := {}
LOCAL cPrefixoCpo := PrefixoCpo(aCfgNf[SAliasCols])

SX3->(DbSetOrder(2))
SX7->(DbSetOrder(1))
SX7->(DbSeek(cPrefixoCpo))
While !SX7->(Eof()) .AND. Substr(SX7->X7_CAMPO,1,2) == cPrefixoCpo
	IF SX3->(MSSEEK(SX7->X7_CDOMIN)).AND. 'MAFISREF'$UPPER(SX3->X3_VALID)
        Aadd(aCpos,{Alltrim("M->"+SX7->X7_CAMPO),Alltrim(SX7->X7_CDOMIN)})
	Endif
    SX7->(DbSkip())
End
Return  aCpos

/*
±±³Funcao    ³LocxValNum() ³±±
±±³Descri‡…o ³ Validacao para verificar a existencia da nf no momento da 	 ³±±
±±³          ³ digitacao doc campos de numero /Serie                   	 	 ³±±
*/
Function LocxValNum()
Local aArea     := GetArea()
Local Alias 	:= aCfgNF[SAliasHead]
Local cSerieNF	:= M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")
Local cNumNota	:= M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_DOC")
Local cCliForn	:= If (Alias== "SF2" ,M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_CLIENTE"),M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_FORNECE") )
Local cLoj 		:= M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA")
Local cEspec    := M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_ESPECIE")
Local dEmiss	:= M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_EMISSAO")
Local lExist	:= .F.
Local lReturn 	:= .T.
//Local lExisteFin:= .F.
Local cSerieOri:=cSerieNF
Local lVarSer2	:= (Type("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2") == "C")
Local lSer2     := (((SF2->(FieldPos("F2_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (cEspec$"NCE|NCP")) .or. (cPaisLoc == "COL" .and. Alias == "SF2" .And. lVarSer2) ); // Determina o uso do campo F2_SERIE2 para o Peru
				.Or. ((SF1->(FieldPos("F1_SERIE2")) > 0) .and. GetNewPar("MV_LSERIE2",.F.) .and. (Trim(cEspec)$"NF|NDP|NDE") .And. !aCfgNf[SlFormProp])
Local lJaexistD := .F.
Local nLenSerie := TamSX3("F1_SERIE")[1]
Local nLenSerNF := 0
Local lUsaNewKey:= TamSX3("F1_SERIE")[1] == 14
Local nTamSer	:= TamSX3(SerieNfId("SF1",3,"F1_SERIE"))[1]

If lSer2 .And.  !Empty( M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2") )
	If cPaisLoc == "COL"
		cSerieNF := M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")
	Else
		If TamSX3(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")[1] == TamSX3(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")[1];
			.OR. Len(M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")) == TamSX3(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")[1]
			cSerieNF := M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")
		EndIf
	EndIf
EndIf

If lUsaNewKey
	cSerieNF:= SerieNfId(aCfgNF[SAliasHead],4,PrefixoCpo(aCfgNF[SAliasHead])+"_SERIE",dEmiss,cEspec,cSerieNF)
Endif

nLenSerNF := If(cPaisLoc=="ARG", Len(Trim(cSerieNF)), nLenSerie)
If !l103Class
	If !aCfgNf[SlFormProp]
		lExist := !aNumNaoExiste(Alias,cSerieNF,cNumNota,cCliForn,cLoj,cEspec)
		If Alias== "SF2" .And. lExist
		    AliasSF2:=SF2->(GetArea())
		    SF2->(DbSetOrder(1))
		    lJaexist:=.F.

		    If SF2->(DbSeek(xFilial("SF2")+cNumNota+cSerieNF+cCliForn+cLoj) )
		    	While !Eof() .And. (xFilial("SF2")+cNumNota+cSerieNF+cCliForn+cLoj) ==(SF2->F2_FILIAL+SF2->F2_DOC+SF2->F2_SERIE+SF2->F2_CLIENTE+SF2->F2_LOJA)
		    		If Alltrim(SF2->F2_ESPECIE)==Alltrim(cEspec)
		    		    	lJaexistD:=.T.
		    		EndIf
		    		SF2->(DbSkip())
		    	EndDo
		    	If Eof() .And. Alltrim(SF2->F2_ESPECIE)==Alltrim(cEspec)
		  		  	lJaexistD:=.T.
		    	EndIf
		    EndIf
		    SF2->(RestArea( AliasSF2))

		ElseIf Alias== "SF1" .And. lExist
			AliasSF1:=SF1->(GetArea())
		    SF1->(DbSetOrder(1))
		    lJaexistD:=.F.
		    If SF1->(DbSeek(xFilial("SF1")+cNumNota+cSerieNF+cCliForn+cLoj) )
		    	While !Eof() .And. (xFilial("SF1")+cNumNota+cSerieNF+cCliForn+cLoj) ==(SF1->F1_FILIAL+SF1->F1_DOC+PadR(Substr(SF1->F1_SERIE,1,nLenSerNF),nLenSerie)+SF1->F1_FORNECE+SF1->F1_LOJA)
		    		If Alltrim(SF1->F1_ESPECIE)==Alltrim(cEspec)
		    		    lJaexistD:=.T.
		    		EndIf
		    		SF1->(DbSkip())
		    	EndDo
		    	If Eof() .And. Alltrim(SF1->F1_ESPECIE)==Alltrim(cEspec)
		  		  	lJaexistD:=.T.
		    	EndIf
		    EndIf
		    SF1->(RestArea( AliasSF1))
		EndIf

		If lExist .And. !lJaexistD
    		IF !(type("cEspecie") <> "U") .and. IsInCallStack("FINA096")
    			cEspecie := CEspec
    		EndIF
			cSerieNF:= Subs((Alltrim(cSerieNF)+cEspecie),1,TamSX3("F1_SERIE")[1])
			cSerie:=cSerieNF
			While lExist
				lExist    :=!aNumNaoExiste(Alias,cSerieNF,cNumNota,cCliForn,cLoj,cEspec,,nLenSerNF)
				If  lExist
					cSerieNF := Soma1(cSerieNF)
					cSerie:=cSerieNF
				EndIf
			EndDo
		EndIf
	Else
		lExist := .F.
	Endif
	If  lExist
	   Aviso(STR0018,STR0092+"("+ Iif(cPaisLoc $ "PAR|URU|ARG|CHI",cNumNota,cnFiscal)+" / "+cSerie+") " +STR0068 ,{STR0021}) //"ATENCAO"###"Documento no."### "ja existe "###"OK"
	   lReturn 	:= .F.
	EndIf
	If lReturn .AND. cPaisLoc == "GUA"
       //³Valida se o numero esta homologado pela SAT         ³
       lReturn  := LocxNumSAT(cSerieNF,cNumNota)
    EndIf
EndIf
RestArea( aArea )

If lReturn .AND. !Empty(cNumNota)
	If lSer2 .And. !Empty( M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2") )
		cSerieOri :=  M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE2")
	EndIf

	If cPaisLoc=="PER"
		M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERORI")    :=  cSerieOri
	EndIf

	If padr(subStr(cSerieNF,1,nTamSer),nTamSer," ")<>padr(subStr(cSerieOri,1,nTamSer),nTamSer," ")
		M->&(PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE"):=cSerieNF
		If cPaisLoc <> "PER"
			MsgAlert(StrTran(STR0432, '###', cSerieOri) + cSerieNF) //"La Serie Original fue alterada de: ### para: "
		EndIf
		MaFisAlt("NF_SERIENF",cSerieNF)
	EndIf
EndIf
Return (lReturn)
/*
±±ºPrograma  ³LocxFormP º±±
±±ºDesc.     ³Determina se a factur ou nota foi impressa em formulario    º±±
±±º          ³proprio.                                                    º±±
*/
Function LocxFormP(cEspecie,cTipoMov,cTES,cFormul)
Local lRet := .F.

If Empty(cFormul)
	//Determina a especie da Factura ou Nota...
	cEspecie := GetSesNew(AllTrim(cEspecie),Iif(cTES >= "500","1","2"))

	If (cEspecie$"NCI|NDI|NCC|NDC|CF") .OR. (cTipoMov == "V" .AND. cEspecie == "NF")
		lRet := .T.
	EndIf
Else
	lRet := (AllTrim(cFormul) == "S")
EndIf
Return(lRet)
/*
±±³Fun‡…o    ³LocxDelRem³ ³±±
±±³Descri‡…o ³ Estornar as movimentacoes Internas-SD3 ou Remitos gerados  ³±±
±±³          ³ pelas Notas Fiscais de Importacao.                         ³±±
±±³ Uso      ³ MATA101N (Integracao com Modulo de Importacao)             ³±±
*/
Function LxApagaREM(lMostraCtb,lAglCtb,lContab,lCarteira,lTela,lPerg,lRSAuto,aRecImp)
//Local aArea        := GetArea()
//Local lRet         := .T.
//Local lOutrasNF    := .F.
Local aAreaSF1     := {}
Local aAreaSD1     := {}
Local aTES         := {}
//Local aCusto       := {}
//Local aImpostos    := {}
//Local aCustoRem    := {}
Local aRemito      := {}
Local aRemitos     := {}
Local aMoeda       := {}
Local aRecImpSF1   := {}
Local aRecImpSD1   := {}
//Local aAreaSalva   := {}

Local nPosTes      := 0
//Local nPosSWN      := 0
Local nTxCusEIC    := 0
Local nMoedaOrig   := 0
Local nX           := 0
//Local nI           := 0
Local nValImpX     := 0
//Local nTotal       := 0
Local nTotalLcto   := 0
Local nHdlPrv      := 0

Local cNumRemito   := ""
Local cSerRemito   := ""
//Local cLote		   := ""
Local cArquivo	   := ""
Local cCampo       := ""
//Local cCodDespesa  := ""
Local cSeek        := ""

//Local nQuantTmp, nQtSegUMTmp
Local nY //nE,

Local cDoc         := SF1->F1_DOC
Local cFornece     := SF1->F1_FORNECE
Local cLoja        := SF1->F1_LOJA
Local cTipo        := SF1->F1_TIPO
Local cFornDes     := SF1->F1_FORNECE
Local cLojaDes     := SF1->F1_LOJA
Local cNFiscalDes  := SF1->F1_DOC
Local cSerieDes    := SF1->F1_SERIE
Local cSerie       := SF1->F1_SERIE
Local cTipoNF      := SF1->F1_TIPO_NF
//Local cHawb		   := SF1->F1_HAWB

Local cTesDespacho := CriaVar("F4_CODIGO")
Local lMovtaSD3    := GetNewPar("MV_CUSTIMP","1") == "1"
//Local nPosAColsTes := AScan(aHeader,{|x| Upper(Alltrim(x[2]))$"D1_TES"})
Local cLoteCom     := IIf(Found(),Trim(X5DESCRI()),"COM ")
Local dDtValid	   := Nil
Local lVerPad695:= VerPadrao('695')//Exclusão dos Itens da Nota Entrada
Local lVerPad687:= VerPadrao('687')//Exclusão Total da Nota Entrada
Local lVerPad697:= VerPadrao('697')//Exclusão dos Itens da Nota Debito
Local lVerPad689:= VerPadrao('689')//Exclusão Total da Nota Entrada
Local lVerPad698:= VerPadrao('698')//Exclusão dos Itens da Remito Entrada
Local lVerPad690:= VerPadrao('690')//Exclusão Total da Remito Entrada
Local lVerPad655   := VerPadrao('655')
Local lVerPad665   := VerPadrao('665')
Local aCtbDia	   := {}
Local dDataTaxa

Local cFilSB1	:= xFilial("SB1")
Local cFilSB2	:= xFilial("SB2")
Local cFilSB8	:= xFilial("SB8")
Local cFilSD1	:= xFilial("SD1")
Local cFilSF1	:= xFilial("SF1")
Local cFilSF3	:= xFilial("SF3")
Local cFilSF4	:= xFilial("SF4")
Local cFilSYD	:= xFilial("SYD")
Local cFilSW6	:= xFilial("SW6")
Local cFilSW9	:= xFilial("SW9")
Local cFilSWN	:= xFilial("SWN")
Local cFilSWD	:= xFilial("SWD")
Local lB2AtuUnif	:= .T.
Local lWN_TES := .F.
Local lWN_ITEMNF	:= .F.
Local lWN_DESPSUB := .F.
Local lWN_LOCAL	:= .F.
Local nT_ITEM	:= TamSX3("D1_ITEM")[1]

Private lUsaCor    :=.F.

aRecImp	 :=	{}

//Utilizacao do numero correlativo de compras
lUsaCor   :=.F.
lUsaCor   :=CORR_USO()
lUsaCor   :=lUsaCor .AND. Strzero(aCfgNF[SnTipo],2)$"07|09|10|12|13|14"  //ncp|ndp|nf|benef|import|frete
lGeraLanc :=.F.

//³ Inicializa o cabecalho dos lanç. Contabeis OnLine ³

If ( lContab .AND. (!__TTSinUse .Or. cPaisLoc $ "PTG|RUS|"))
	lContab := .T.
	dbSelectArea("SX5")
	MsSeek(xFilial("SX5")+"09COM")
	cLoteCom:=IIf(Found(),Trim(X5DESCRI()),"COM ")
	nHdlPrv:=HeadProva(cLoteCom,"MATA103",Subs(cUsuario,7,6),@cArquivo)
	If nHdlPrv <= 0
		HELP(" ",1,"A100NOPRV")
		lContab := .F.
	EndIf
EndIf

Begin Transaction

If lMovtaSD3	//Estornar Movimentacoes de SD3
	If SF1->F1_TIPO_NF != "5"
		DbSelectArea("SWN")
		DbSetOrder(2)
		If DbSeek(cFilSWN+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
			lWN_LOCAL := .T.
			While !EOF() .AND. WN_FILIAL==cFilSWN .AND.;
				WN_DOC==SF1->F1_DOC .AND. WN_SERIE == SF1->F1_SERIE .AND.;
				WN_FORNECE==SF1->F1_FORNECE .AND. WN_LOJA == SF1->F1_LOJA
				If lWN_LOCAL
					MSGravaD3(WN_PRODUTO,subs(WN_PO_NUM,1,6),WN_ITEM,WN_QUANT,,.T.,WN_LOTECTL,WN_DTVALID,WN_QTSEGUM,WN_SEGUM,WN_LOCAL)
				Else
					MSGravaD3(WN_PRODUTO,subs(WN_PO_NUM,1,6),WN_ITEM,WN_QUANT,,.T.,WN_LOTECTL,WN_DTVALID,WN_QTSEGUM,WN_SEGUM)
				EndIf
				AAdd(aRecIMP,{SD3->(RECNO()),SWN->(RECNO())})
				DbSelectArea("SWN")
				DbSkip()
			End
		EndIf
	EndIf
	LibFatImp(.T.)

Else //Estornar ou apagar Remitos gerados pelas Class. NF de import.

	aAreaSF1 := SF1->(GetArea())
	aAreaSD1 := SD1->(GetArea())

	If GetMv('MV_FLTD1D2')
		SF1->(DbClearFilter())
	Endif

	SB2->(DbSetOrder(1))
	DbSelectArea("SWN")
	DbSetOrder(1)
	DbSeek(cFilSWN+cDoc+cSerie)
	cTipoNF := SWN->WN_TIPO_NF
	//Se eh FOB so tem um remito por nota e este deve ser gravado no cabecalho
	If cTipoNf  == '5'
		aRemito		:= LocxNrReIm(SWN->WN_HAWB,Substr(SWN->WN_INVOICE,1,Len(SF1->F1_DOC))) //Buscar o remito da invoice
		cSerRemito	:= aRemito[1]
		cNumRemito	:= aRemito[2]
		cFornece	:= If(Empty(aRemito[3]),SF1->F1_FORNECE,aRemito[3])
		cLoja		:= If(Empty(aRemito[4]),SF1->F1_LOJA,aRemito[4])
	EndIf

	nItem   := 0
	cInvAnt	:=	''
	lWN_TES := cPaisLoc == "ARG"
	lWN_ITEMNF := cPaisLoc == "ARG"
	lWN_DESPSUB := cPaisLoc $ "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
	//³ Grava Remitos para registrar Ingresos e Custos para NF de Importacao ³
	While !Eof() .And. WN_FILIAL==cFilSWN .And. WN_DOC==cDoc .And. WN_SERIE==cSerie
		AAdd(aRecIMP,{0,SWN->(RECNO())})
		If cTipoNf <> '5'
			If cInvAnt <> SWN->WN_INVOICE
				aRemito	   := LocxNrReIm(SWN->WN_HAWB,Substr(SWN->WN_INVOICE,1,Len(SF1->F1_DOC))) //Buscar o remito da invoice
				cSerRemito := aRemito[1]
				cNumRemito := aRemito[2]
				cFornece   := If(Empty(aRemito[3]),SF1->F1_FORNECE,aRemito[3])
				cLoja      := If(Empty(aRemito[4]),SF1->F1_LOJA,aRemito[4])
				cInvAnt	   := SWN->WN_INVOICE
			EndIf
		EndIf

		If lWN_DESPSUB
			nValorCus := Round(SWN->WN_VALOR-SWN->WN_DESPSUB,2)
		Else
			nValorCus := SWN->WN_VALOR
		EndIf
		If nValorCus > 0.00

	    	SB1->(DbSetOrder(1))
    		SB1->(MsSeek(cFilSB1+SWN->WN_PRODUTO))
	    	SW6->(DbSetOrder(1))
    		SW6->(MsSeek(cFilSW6+SWN->WN_HAWB))
	    	SW9->(DbSetOrder(1))
    		SW9->(DbSeek(cFilSW9+SWN->WN_INVOICE+SWN->WN_FORNECE))
			//³ Posicionar os arquivos TES e PRODUTOS  ³
			aTES         := {}
			cTesDespacho := Space(3)

			//³ Devido a gravacao das notas serem diferentes, o SWN sempre      |
			//³ mostrara os dados do produto importado e nas notas tipo 9/A as  |
			//| despesas usarao seu proprio TES (D1_TESDES).                    |

			If SWN->WN_TIPO_NF $ "5678"
				If lWN_TES
					AADD(aTes,SWN->WN_TES)
				Else
					SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))
					AADD(aTes,SYD->YD_TES)
				EndIf
			Else
    			DbSelectArea("SD1")
				DbSetOrder(2)
				DbSeek(cFilSD1+SWN->WN_PRODUTO+cNFiscalDes+cSerieDes+cFornDes+cLojaDes)
              	nPosTes := Ascan(aTes,SD1->D1_TESDES)
               	If nPosTes == 0
   					AADD(aTes,SD1->D1_TESDES)
   				EndIf
  			EndIf

			DbSelectArea("SWN")

			//-- Posiciona TES
			SF4->(MsSeek(cFilSF4+aTes[1]))

        	//-- Posiciona Despesas/Gastos da import.
        	SWD->(DbSetOrder(1))
            SWD->(DbSeek(cSeek:=cFilSWD+SWN->WN_HAWB))
			Do While SWD->(!Eof()) .AND. cSeek == SWD->WD_FILIAL+SWD->WD_HAWB
			    If SWD->WD_DOCTO == SWN->WN_DOC .AND. SWD->WD_SE_DOC == SWN->WN_SERIE
			    	Exit
			    EndIf
				SWD->(dbSkip())
			EndDo

   			SW6->(DbSetOrder(1))
   			SW6->(MsSeek(cFilSW6+SWN->WN_HAWB))

			DbSelectArea("SF1")
			DbSetOrder(1)
			MsSeek(cFilSF1+cNumRemito+cSerRemito+cFornece+cLoja)

			If Found()

				AADD(aRemitos,{SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE+SF1->F1_LOJA,SWN->WN_TIPO_NF})

				cItemRem:=StrZero(nItem,nT_ITEM)
				If lWN_ITEMNF
					DbSelectArea("SD1")
					DbSetOrder(1)
					MsSeek(cFilSD1+cNumRemito+cSerRemito+cFornece+cLoja+SWN->WN_PRODUTO+SWN->WN_ITEMNF)
				Else
					DbSelectArea('SD1')
					DbSetOrder(2)
					MsSeek(cFilSD1+SWN->WN_PRODUTO+cNumRemito+cSerRemito+cFornece+cLoja)
			   	EndIf

 				If SD1->(Found())

					If SWN->WN_TIPO_NF == "9" .OR. SWN->WN_TIPO_NF == "A"	//Nota de Despesas do Despachante ou Nota Complentar de Custos

						//³ Pegar a taxa da Moeda do cabealho da fatura de import.  na tabela  ³
						//³ para pegar la moneda, tasa y TES.                                  ³

						nTxCusEIC  := SWD->WD_TX_MOE
						dDataTaxa  := If( Empty(SWD->WD_DT_EMIS), SWD->WD_DES_ADI, SWD->WD_DT_EMIS )
						nMoedaOrig := SimbToMoeda(SWD->WD_MOEDA)
						nMoedaOrig := If(nMoedaOrig>0,nMoedaOrig,1)

						//³ Gravar D1_TOTAL y D1_CUSTO ya convertido ³

						If nTxCusEIC == 0
							nTxCusEIC := 1
						EndIf

	        		    //³ Pesquisa TES do cadastro de NCM  ³

						SYD->(dbSetOrder(1))
						SYD->(MsSeek(cFilSYD+SWN->WN_TEC+SWN->WN_EX_NCM+SWN->WN_EX_NBM))

						If lWN_TES .And. !Empty(SWN->WN_TES)
							nValImpX  := LxSomaImp(SWN->WN_TES)
						Else
							nValImpX  := LxSomaImp(IIf(Found(),SYD->YD_TES,SD1->D1_TES))
						EndIf

						RecLock( 'SD1', .F. )
	    				Replace D1_TOTAL With D1_TOTAL - (SWN->WN_DESPESA+nValImpX)
	    				Replace D1_VUNIT With D1_TOTAL/D1_QUANT
    					Replace D1_CUSTO With D1_CUSTO - (SWN->WN_DESPESA+nValImpX)

            			//³ Grava custo em moeda 2,3,4 y 5. ³

						aMoeda := {"","","","",""}
						For nY := 2 To 5
							cCampo := "SD1->D1_CUSTO"+Str(nY,1,0)
							If nMoedaOrig = nY
								Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
					        Else
								aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
								Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
				    		EndIf
					    Next nY
						SD1->(MsUnLock())

						//³ Atualizar Saldos Fisico e Financeiro |

						If SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))
			    	    	RecLock("SB2",.F.)
							Replace B2_VATU1 	With B2_VATU1 - xMoeda(SWN->WN_VALOR + nValImpX,1,1,SF1->F1_EMISSAO,,,nTxCusEIC)
							aMoeda := {"","","","",""}
							For nY := 2 To 5
								cCampo := "SB2->B2_VATU"+Str(nY,1,0)
								If nMoedaOrig = nY
									Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
						        Else
									aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
									Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_DESPESA+nValImpX,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
					    		EndIf
							Next nY
							SB2->(MsUnLock())
							If SB2->B2_QATU > 0
								Reclock("SB2",.F.)
								Replace SB2->B2_CM1	With SB2->B2_VATU1/SB2->B2_QATU
								Replace SB2->B2_CM2	With SB2->B2_VATU2/SB2->B2_QATU
								Replace SB2->B2_CM3	With SB2->B2_VATU3/SB2->B2_QATU
								Replace SB2->B2_CM4	With SB2->B2_VATU4/SB2->B2_QATU
								Replace SB2->B2_CM5	With SB2->B2_VATU5/SB2->B2_QATU
								SB2->(MsUnLock())
							EndIf

							//³Atualiza o custo unificado ON-LINE ³

							If lB2AtuUnif
								B2AtuUnif(SB2->B2_COD)
							EndIf
						EndIf

						//³ Acumular F1_VALMERC y F1_VALBRUT en SF1. |

						DbSelectArea('SF1')
						RecLock( 'SF1', .F. )
						Replace F1_VALMERC 	 With F1_VALMERC - ( SWN->WN_DESPESA+nValImpX )
						Replace F1_VALBRUT	 With F1_VALBRUT - ( SWN->WN_DESPESA+nValImpX )
						MsUnlock()

				ElseIf SWN->WN_TIPO_NF $ "5678" //FOB, Frete ou Seguro

						//³  Pegar Moeda e Taxa do arquivo de Processos ³

		            	If 	SWN->WN_TIPO_NF $ "5|8"     //FOB ou CIF
							cMoedaEIC := SW9->W9_MOE_FOB
							nTxCusEIC := SW9->W9_TX_FOB
							dDataTaxa := SW9->W9_DT_EMIS
						ElseIf SWN->WN_TIPO_NF $ "6"	//Frete
							cMoedaEIC := SW6->W6_FREMOED
							nTxCusEIC := SW6->W6_TX_FRET
							dDataTaxa := SW6->W6_DTREG_D
						ElseIf SWN->WN_TIPO_NF $ "7"    //Seguro
							cMoedaEIC := SW6->W6_SEGMOED
							nTxCusEIC := SW6->W6_TX_SEG
							dDataTaxa := SW6->W6_DTREG_D
						EndIf

						nMoedaOrig := SimbToMoeda(cMoedaEIC)
						nMoedaOrig := If(nMoedaOrig>0,nMoedaOrig,1)

						//³ Gera lanç contabil 655-695-697-698 Exclusao - Itens ³

						DbSelectArea("SD1")
						If lContab .AND. D1_TIPO_NF $ "7"
							If Ascan(aRecImpSD1,{|x| x[1] == SD1->(RECNO())})==0
								AAdd(aRecImpSD1,{RECNO()})
								If Type("cFunName")<>"U"
									If cFunName$"MATA101N" //Nota de Entrada
										If lVerPad695
											nTotalLcto	+= DetProva(nHdlPrv,'695','MATA103',cLoteCom)
										ElseIf lVerPad655
											nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
										EndIf
									EndIf
									If cFunName$"MATA466N" //Nota de Debito
										If lVerPad697
											nTotalLcto	+= DetProva(nHdlPrv,'697','MATA103',cLoteCom)
										ElseIf lVerPad655
											nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
										EndIf
									EndIf
									If cFunName$"MATA465N" //Nota de Credito
										If VerPadrao("68N")
											If !Empty(SF1->F1_DTLANC)
												nTotalLcto	+= DetProva(nHdlPrv,'68N','MATA103',cLoteCom)
											EndIf
										ElseIf lVerPad655
											If !Empty(SF1->F1_DTLANC)
												nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
											EndIf
										EndIf
									EndIf
									If cFunName$"MATA102N" //Remito de Entrada
										If lVerPad698
											nTotalLcto	+= DetProva(nHdlPrv,'698','MATA103',cLoteCom)
										ElseIf lVerPad655
											nTotalLcto	+= DetProva(nHdlPrv,'655','MATA103',cLoteCom)
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf

						DbSelectArea("SD1")
						RecLock( 'SD1', .F. )
		    			Replace D1_TOTAL With D1_TOTAL - (SWN->WN_VALOR - SWN->WN_DESPSUB)
			    		Replace D1_VUNIT With D1_TOTAL/D1_QUANT
						Replace D1_CUSTO With D1_CUSTO - (SWN->WN_VALOR - SWN->WN_DESPSUB)

						aMoeda := {"","","","",""}
						For nY := 2 To 5
							cCampo := "SD1->D1_CUSTO"+Str(nY,1,0)
							If nMoedaOrig = nY
				        		Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
					        Else
								aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
			        			Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],dDataTaxa,.T.,.F.))
				    		EndIf
					    Next nY
						SD1->(MsUnLock())

						//³ Atualizar Saldos Fisico e Financeiro |

						If SB2->(MsSeek(cFilSB2+SD1->D1_COD+SD1->D1_LOCAL))

							//³ Atualizar Saldos Fisico e Financeiro  |

							If SWN->WN_TIPO_NF $ "5|8"
								DbSelectArea("SB2")
			                    RecLock("SB2",.F.)
                		        Replace B2_QATU		With B2_QATU - SD1->D1_QUANT
								Replace B2_QTSEGUM	With B2_QTSEGUM - SD1->D1_QTSEGUM
								MsUnLock()

								//³ Armazenar dados para excluir o Remito |

								AADD(aRemitos,{SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA})


								//³ Estorna os Movimenta Lotes/Sub-Lotes/Localizacao Fisica ³

								If Rastro(SD1->D1_COD) .OR. Localiza(SD1->D1_COD)

									//³ Tratamento da gravacao do SD1 na Integridade Referencial ³

									SD1->(FkCommit())
									dDtValid	:= SD1->D1_DTVALID
									If !Empty(SD1->D1_LOTECTL)
										SB8->(DbSetOrder(3))
										If SB8->(MsSeek(cFilSB8+SD1->D1_COD+SD1->D1_LOCAL+SD1->D1_LOTECTL))
											dDtValid	:=	SB8->B8_DTVALID
										EndIf
									EndIf
									cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
								    MovLote("SD1",;					//1
											SD1->D1_COD,;			//2
											SD1->D1_LOCAL,;			//3
											If( cPaisLoc $ cAuxPaisl,SD1->D1_LOCALIZ,NIL),;	//4
											If( cPaisLoc $ cAuxPaisl,SD1->D1_NUMSERI,NIL),;	//5
											SD1->D1_LOTECTL,;		//6
											SD1->D1_NUMLOTE,;		//7
											SD1->D1_NUMSEQ,;		//8
											Soma1('5'+SubStr(SD1->D1_TES,2)),;         //9
											SD1->D1_FORNECE,;		//10
											SD1->D1_LOJA,;			//11
											SD1->D1_LOTEFOR,;		//12
											"RCN",;					//13
											SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD,;				//14
											SD1->D1_DOC,;			//15
											SD1->D1_SERIE,;			//16
											SD1->D1_OP,;			//17
											NIL,;					//18
											NIL,;					//19
											NIL,;					//20
											NIL,;					//21
											SD1->D1_QUANT,;			//22
											SD1->D1_QTSEGUM,;		//23
											SD1->D1_DTDIGIT,;		//24
											SD1->D1_DTVALID,;		//25
											NIL,;					//26
											NIL,;					//27
											Soma1('5'+SubStr(SD1->D1_TES,2))>"500",;   //28
											.T.,;					//29
											Soma1('5'+SubStr(SD1->D1_TES,2))<="500",; //30
											NIL,;					//31
											NIL,;					//32
											NIL,;					//33
											NIL,;					//34
											NIL,;					//35
											NIL,;					//36
											NIL,;					//37
											NIL,;					//38
											NIL,;					//39
											NIL,;					//40
											NIL,;					//41
											NIL,;					//42
											NIL,;					//43
											NIL,;					//44
											NIL,;					//45
											NIL,;					//46
											NIL,;					//47
											NIL,;					//48
											NIL,;					//49
											SD1->D1_POTENCI)		//50
									LogMov("SD1",,,,,,.T.,"SD1")
								EndIf
							EndIf
							RecLock("SB2",.F.)
    						Replace B2_VATU1	 	With B2_VATU1 - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,1,SF1->F1_EMISSAO,,,nTxCusEIC)
							aMoeda := {"","","","",""}
							For nY := 2 To 5
								cCampo := "SB2->B2_VATU"+Str(nY,1,0)
								If nMoedaOrig = nY
						    	    Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,nTxCusEIC)
						        Else
									aMoeda[nY] := Alltrim(GetMV("MV_SIMB"+Str(nY,1,0)))
						    	    Replace &(cCampo) With &(cCampo) - xMoeda(SWN->WN_VALOR - SWN->WN_DESPSUB,1,nY,SF1->F1_EMISSAO,,,BuscaTaxa(aMoeda[nY],SF1->F1_EMISSAO,.T.,.F.))
					    		EndIf
						    Next nY
						    SB2->(MsUnLock())
						    If SB2->B2_QATU > 0
							    RecLock("SB2",.F.)
								Replace SB2->B2_CM1		With SB2->B2_VATU1/SB2->B2_QATU
								Replace SB2->B2_CM2		With SB2->B2_VATU2/SB2->B2_QATU
								Replace SB2->B2_CM3		With SB2->B2_VATU3/SB2->B2_QATU
								Replace SB2->B2_CM4		With SB2->B2_VATU4/SB2->B2_QATU
								Replace SB2->B2_CM5		With SB2->B2_VATU5/SB2->B2_QATU
								SB2->(MsUnLock())
							EndIf

							//³Atualiza o custo unificado ON-LINE ³

							If lB2AtuUnif
								B2AtuUnif(SB2->B2_COD)
							EndIf
						EndIf

						//³	Gera lanç contabil 665-687-689-690 Exclusao - Cabecalho ³

						DbSelectArea("SF1")
						If lContab .AND. F1_TIPO_NF $ "7"
							If Ascan(aRecImpSF1,{|x| x[1] == SF1->(RECNO())})==0
								AAdd(aRecImpSF1,{RECNO()})
								If cFunName$"MATA101N" //Nota de Entrada
									If lVerPad687
										nTotalLcto	+= DetProva(nHdlPrv,'687','MATA103',cLoteCom)
									ElseIf lVerPad665
										nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
									EndIf
								EndIf
								If cFunName$"MATA466N" //Nota de Debito
									If lVerPad689
										nTotalLcto	+= DetProva(nHdlPrv,'689','MATA103',cLoteCom)
									ElseIf lVerPad665
										nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
									EndIf
								EndIf
								If cFunName$"MATA465N" //Nota de Credito
									If VerPadrao("68F")
										If !Empty(SF1->F1_DTLANC)
											nTotalLcto	+= DetProva(nHdlPrv,'68N','MATA103',cLoteCom)
										EndIf
									ElseIf lVerPad655
										If !Empty(SF1->F1_DTLANC)
											nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
										EndIf
									EndIf
								EndIf
								If cFunName$"MATA102N" //Remito de Entrada
									If lVerPad690
										nTotalLcto	+= DetProva(nHdlPrv,'690','MATA103',cLoteCom)
									ElseIf lVerPad665
										nTotalLcto	+= DetProva(nHdlPrv,'665','MATA103',cLoteCom)
									EndIf
								EndIf
							EndIf
						EndIf

						//³ Acumular F1_VALMERC y F1_VALBRUT en SF1 |

						DbSelectArea("SF1")
						DbSetOrder(1)
						MsSeek(cFilSF1+cNumRemito+cSerRemito+cFornece+cLoja)
						If Found()
							DbSelectArea('SF1')
							RecLock( 'SF1', .F. )
							Replace F1_VALMERC 	With F1_VALMERC - (SWN->WN_VALOR - SWN->WN_DESPSUB)
							Replace F1_VALBRUT	With F1_VALBRUT - (SWN->WN_VALOR - SWN->WN_DESPSUB	)
							MsUnlock()
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		DbSelectArea("SWN")
		DbSkip()
	End

	If GetMv('MV_FLTD1D2')
		Eval( bFilBrw )
	EndIf

	//³gravacao dos lanç. Contabeis ³

	If lContab .AND. nHdlPrv > 0 .AND. nTotalLcto > 0
		RodaProva(nHdlPrv,nTotalLcto)
		If UsaSeqCor()
			aCtbDia := {{"SF1",SF1->(RECNO()),SF1->F1_DIACTB,"F1_NODIA","F1_DIACTB"}}
		Else
    		aCtbDia := {}
		EndIF
		lLctoOk	:= cA100Incl(cArquivo,nHdlPrv,3,cLoteCom,lMostraCtb,lAglCtb,,If(aCfgNf[SaPergs][SlCtbEmiss],&("SF1->"+PrefixoCpo("SF1")+"_EMISSAO"),dDataBase ),,,,aCtbDia)
	EndIf

	RestArea(aAreaSF1)
	RestArea(aAreaSD1)
EndIf
//³ Estornar ou apagar Livro Fiscal  ³

DbSelectArea("SF3")
DbSetOrder(4)
If DbSeek(cFilSF3+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_DOC+SF1->F1_SERIE)
	While !EOF() .AND. F3_FILIAL==cFilSF3 .AND.;
		F3_CLIEFOR==SF1->F1_FORNECE	.AND. F3_LOJA==SF1->F1_LOJA	.AND.;
		F3_NFISCAL==SF1->F1_DOC .AND. F3_SERIE == SF1->F1_SERIE
		RecLock("SF3",.F.)
		DbDelete()
		MsUnLock()
		DbSkip()
	End
EndIf

If SF1->F1_TIPO_NF $ "9"
	MaFisF3Eic(2)
EndIf

//³ Estornar ou apagar Livro Fiscal ³

DbSelectArea("SD1")
DbSetOrder(1)
If DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
	While !EOF() .AND. D1_FILIAL==cFilSD1 .AND.;
		D1_DOC==SF1->F1_DOC .AND. D1_SERIE == SF1->F1_SERIE .AND.;
		D1_FORNECE==SF1->F1_FORNECE	.AND. D1_LOJA==SF1->F1_LOJA
		//³ Estorna o pedido de compras ³
		LxA103SC7(2,.F.)
		//³ Estorna o Saldos de SB8, SD5 ³
		SF4->(DbSetOrder(1))
		SF4->(MsSeek(cFilSF4+SD1->D1_TES))

		If D1_TIPO_NF $ "5" .AND. lMovtaSD3
			LxA103SB2(2,SD1->D1_LOCAL)
		EndIf

		RecLock("SD1",.F.)
		Replace SD1->D1_TES	With " "
		Replace SD1->D1_CF	With " "
		MsUnLock()

		DbSelectArea("SD1")
		DbSkip()
	End
End

//³ Armazenar dados para excluir o Remito |

For nX := 1 To Len(aRemitos)
	DbSelectArea("SF1")
	DbSetOrder(1)
	If MsSeek(cFilSF1+aRemitos[nX][1]+aRemitos[nX][2]+aRemitos[nX][3]+aRemitos[nX][4])

		DbSelectArea("SD1")
		DbSetOrder(1)
		If DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
			While !EOF() .AND. D1_FILIAL==cFilSD1 .AND.;
					D1_DOC == aRemitos[nX][1] .AND. D1_SERIE == aRemitos[nX][2] .AND.;
					D1_FORNECE == aRemitos[nX][3] .AND. D1_LOJA == aRemitos[nX][4]

					RecLock("SD1",.F.)
					DbDelete()
					MsUnLock()

					DbSkip()
			End

			DbSelectArea("SF1")
			RecLock("SF1",.F.)
			DbDelete()
			MsUnLock()
    	EndIf
	EndIf
Next nX

If !lFacImport
	If lUsaCor .And. !Empty(SF1->F1_NUMCOR) //libera o numero correlativo
		CORR_EXCL(SF1->F1_DTDIGIT,SF1->F1_NUMCOR)
	EndIf
EndIf

//³ Limpar o Status no SF1 ³

DbSelectArea("SF1")
DbSetOrder(1)
If MsSeek(cFilSF1+cNFiscalDes+cSerieDes+cFornDes+cLojaDes+cTipo)
	RecLock("SF1",.F.)
	Replace SF1->F1_STATUS With " "
	If lUsaCor
		Replace SF1->F1_NUMCOR With " "
	EndIf
	MsUnLock()
EndIf
End Transaction
Return(.T.)
/*
±±³Fun‡…o    ³aDupNaoExiste ³±±
±±³Descri‡…o ³ Verifica se a numeracao da duplicata existe               ³±±
±±³ Uso      ³ MATA101N (Integracao com Modulo de Importacao)            ³±±
*/
Function aDupNaoExiste(cAliasC,cSerie,cnFiscal,cCliFor,cLoja,cTipoNf,aDuplicata,lMsg)
Local lRet := .T.
Local aArea := GetArea()
Local cSerieNf :=""
Local cFilSE2	:= xFilial("SE2")
Local cFilSE1	:= xFilial("SE1")
Local lfina998  := IsInCallStack("FINA998")

Default lMsg := .T.

If ValType(aDuplicata) == "A" .AND. len(aDuplicata) >0

	//³Controla a a existencia da Duplicata  ³

	If cAliasC == "SF2"

		//³Verifica se a NF esta sendo digitada em outra estacao ³

	   	cSerieNf :=	Padr(cSerie,Len(Criavar("F2_SERIE",.F.)))
	Else

		//³Verifica se o controle de numeracao eh o mesmo   ³
		//³para todos os documentos ou se eh independente   ³

	   	cSerieNf := 	Padr(cSerie,Len(Criavar("F1_SERIE",.F.)))
	EndIf
	If aCfgNf[ScAliasFin] =="SE1" .And. !FunName()=='FINA074' .And. !(FunName()=='FINA846' .Or. (cPaisLoc== "ARG" .And. lfina998)) .And. !(cPaisLoc == "URU" .And. (FunName()=='FINA087A' .Or. lfina998))
		If cPaisLoc == "ARG"
			DbSelectArea("SE1")
			DbSetOrder(1)
			If DbSeek( cFilSE1+cSerieNF +cNFiscal,.F. )//cCliFor+cLoja+
				While !Eof() .AND. lRet .AND. cFilSE1 + cSerieNF + cNFiscal == E1_FILIAL + E1_PREFIXO  + E1_NUM
		   			If cTipoNF == E1_TIPO
						lRet := .F.
					EndIf
				DbSkip()
				End
			EndIf
		Else
			DbSelectArea("SE1")
			DbSetOrder(2)
			If DbSeek( cFilSE1+cCliFor+cLoja+cSerieNF +cNFiscal,.F. )
				While !Eof() .AND. lRet .AND. cFilSE1+cCliFor+cLoja+cSerieNF +cNFiscal == ;
												E1_FILIAL + E1_CLIENTE + E1_LOJA + E1_PREFIXO  + E1_NUM
					If cTipoNF == E1_TIPO
						lRet := .F.
					EndIf

				DbSkip()
				End
			EndIf
		EndIf
	Else
		DbSelectArea("SE2")
		DbSetOrder( 6 )
		If DbSeek( cFilSE2+cCliFor+cLoja+cSerieNF +cNFiscal,.F. )
			While !Eof() .AND. lRet .AND. cFilSE2+cCliFor+cLoja+cSerieNF +cNFiscal == ;
											 E2_FILIAL + E2_FORNECE + E2_LOJA + E2_PREFIXO  + E2_NUM
				If cTipoNF == E2_TIPO
					lRet := .F.
				EndIf
				DbSkip()
			End
	    EndIf
	EndIf
	RestArea(aArea)
EndIf
If !lRet
	If lMsg
		Aviso(STR0018,STR0196+"("+cNFiscal+" / "+cSerieNF+") " +STR0068+ STR0197 +cTipoNF+"'" ,{STR0021}) //"ATENCAO"###"A Duplicata ."### "ja existe "###"OK"
	Endif
EndIF
Return (lRet)

Static Function SaveVar()
Static aStack:={}

aStack := IIf(aStack==Nil,{},aStack)

AAdd( aStack, { IIf(Type("n")=="N",N,Nil),;
	IIf(Type("F1_FORNECE") 	=="C",F1_FORNECE       			,Nil),;//caracter
	IIf(Type("F1_LOJA")  	=="C",F1_LOJA         			,Nil),;
	IIf(Type("CNOME")  		=="C",CNOME         			,Nil),;
	IIf(Type("F1_NUMTIM")  	=="C",F1_NUMTIM        			,Nil),;
	IIf(Type("F1_SERIE")  	=="C",F1_SERIE         			,Nil),;
	IIf(Type("F1_DOC")  	=="C",F1_DOC         			,Nil),;
	IIf(Type("F1_NATUREZ")  =="C",F1_NATUREZ         		,Nil),;
	IIf(Type("F1_ESPECIE")  =="C",F1_ESPECIE        		,Nil),;
	IIf(Type("F1_EMISSAO")  =="D",F1_EMISSAO         		,Nil),;//data
	IIf(Type("F1_DTDIGIT")  =="D",F1_DTDIGIT       			,Nil),;//data
	IIf(Type("F1_MOEDA")  	=="N",F1_MOEDA         			,Nil),;//numerico
	IIf(Type("F1_TXMOEDA")  =="N",F1_TXMOEDA         		,Nil),;//numerico
	IIf(Type("F1_VENCAI")  	=="D",F1_VENCAI        			,Nil),;//data
	IIf(Type("F1_CAI")  	=="C",F1_CAI         			,Nil),;
	IIf(Type("F1_QTDEFOL")  =="C",F1_QTDEFOL       			,Nil),;
	IIf(Type("F1_PROVENT")  =="C",F1_PROVENT        		,Nil),;
	IIf(Type("F1_ZONGEO")  	=="C",F1_ZONGEO         		,Nil),;
	IIf(Type("F1_CONCOBR")  =="C",F1_CONCOBR         		,Nil),;
	IIf(Type("F1_TPNFEXP")  =="C",F1_TPNFEXP         		,Nil),;
	IIf(Type("F1_TPVENT")  	=="C",F1_TPVENT         		,Nil),;
	IIf(Type("F1_FECDSE")  	=="D",F1_FECDSE         		,Nil),;//data
	IIf(Type("F1_FECHSE")  	=="D",F1_FECHSE         		,Nil),;//data
	IIf(Type("F1_CAE")  	=="C",F1_CAE	         		,Nil),;
	IIf(Type("F1_VCTOCAE") 	=="D",F1_VCTOCAE         		,Nil),;//data
	IIf(Type("F1_CVPCO")  	=="C",F1_CVPCO	         		,Nil),;
	IIf(Type("F1_DESPESA")  =="N",F1_DESPESA         		,Nil),;//numerico
	IIf(Type("F1_DESCONT")  =="N",F1_DESCONT         		,Nil),;//numerico
	IIf(Type("F1_FRETE")  	=="N",F1_FRETE	         		,Nil),;//numerico
	IIf(Type("F1_SEGURO")  	=="N",F1_SEGURO         		,Nil),;//n
	IIf(Type("F1_VALMERC")  =="N",F1_VALMERC         		,Nil),;//n
	IIf(Type("F1_VALBRUT")  =="N",F1_VALBRUT         		,Nil),;//n
	IIf(Type("A2_NOME")  	=="C",A2_NOME         			,Nil),;//c
	IIf(Type("A2_TEL")  	=="C",A2_TEL     	    		,Nil),;//c
	IIf(Type("A2_PRICOM")  	=="D",A2_PRICOM         		,Nil),;//d
	IIf(Type("A2_ULTCOM")  	=="D",A2_ULTCOM         		,Nil),;//d
	IIf(Type("A2_CGC")  	=="C",A2_CGC         			,Nil),;//c
	IIf(Type("A2_END")  	=="C",A2_END         			,Nil),;//c
	IIf(Type("A2_EST")  	=="C",A2_EST         			,Nil),;//c
	IIf(Type("LINCLUI")  	=="L",LINCLUI	         		,Nil),;//boolean
	IIf(Type("LDELETA")  	=="L",LDELETA	         		,Nil),;//b
	IIf(Type("LVISUALIZA")  =="L",LVISUALIZA	       		,Nil),})//b

	N := 1
Return(Nil)

Static Function RestVar()
Local lRet  := .F.
Local nSize

If ValType( aStack ) == "A" .And. !Empty( aStack )
    //³ Verifica se existe uma interface armazenada ( array valido )           ³
    nSize := Len( aStack )

	If aStack[ nSize, 1 ] <> Nil
	    n := aStack[ nSize, 1 ]
	EndIf

    If aStack[ nSize, 2 ] <> Nil
        F1_FORNECE:= aStack[ nSize, 2 ]
    EndIf

    If aStack[ nSize, 3 ] <> Nil
        F1_LOJA    := aStack[ nSize, 3 ]
    EndIf

    If aStack[ nSize, 4 ] <> Nil
        CNOME    := aStack[ nSize, 4 ]
    EndIf

	If aStack[ nSize, 5 ] <> Nil
		F1_NUMTIM:= aStack[ nSize, 5 ]
	EndIf

	If aStack[ nSize, 6 ] <> Nil
		F1_SERIE:= aStack[ nSize, 6 ]
	EndIf

	If aStack[ nSize, 7 ] <> Nil
	F1_DOC:= aStack[ nSize, 7 ]
	EndIf

	If aStack[ nSize, 8 ] <> Nil
	F1_NATUREZ:= aStack[ nSize, 8 ]
	EndIf

	If aStack[ nSize, 9 ] <> Nil
	F1_ESPECIE:= aStack[ nSize, 9 ]
	EndIf

	If aStack[ nSize, 10 ] <> Nil
	F1_EMISSAO:= aStack[ nSize, 10 ]
	EndIf

	If aStack[ nSize, 11 ] <> Nil
	F1_DTDIGIT:= aStack[ nSize, 11 ]
	EndIf

	If aStack[ nSize, 12 ] <> Nil
	F1_MOEDA:= aStack[ nSize, 12 ]
	EndIf

	If aStack[ nSize, 13 ] <> Nil
	F1_TXMOEDA:= aStack[ nSize, 13 ]
	EndIf

	If aStack[ nSize, 14 ] <> Nil
	F1_VENCAI:= aStack[ nSize, 14 ]
	EndIf

	If aStack[ nSize, 15 ] <> Nil
	F1_CAI:= aStack[ nSize, 15 ]
	EndIf

	If aStack[ nSize, 16 ] <> Nil
	F1_QTDEFOL:= aStack[ nSize, 16 ]
	EndIf

	If aStack[ nSize, 17 ] <> Nil
	F1_PROVENT:= aStack[ nSize, 17 ]
	EndIf

	If aStack[ nSize, 18 ] <> Nil
	F1_ZONGEO:= aStack[ nSize, 18 ]
	EndIf

	If aStack[ nSize, 19 ] <> Nil
	F1_CONCOBR:= aStack[ nSize, 19 ]
	EndIf

	If aStack[ nSize, 20 ] <> Nil
	F1_TPNFEXP:= aStack[ nSize, 20 ]
	EndIf

	If aStack[ nSize, 21 ] <> Nil
	F1_TPVENT:= aStack[ nSize, 21 ]
	EndIf

	If aStack[ nSize, 22 ] <> Nil
	F1_FECDSE:= aStack[ nSize, 22 ]
	EndIf

	If aStack[ nSize, 23 ] <> Nil
	F1_FECHSE:= aStack[ nSize, 23 ]
	EndIf

	If aStack[ nSize, 24 ] <> Nil
	F1_CAE:= aStack[ nSize, 24 ]
	EndIf

	If aStack[ nSize, 25 ] <> Nil
	F1_VCTOCAE:= aStack[ nSize, 25 ]
	EndIf

	If aStack[ nSize, 26 ] <> Nil
	F1_CVPCO:= aStack[ nSize, 26 ]
	EndIf

	If aStack[ nSize, 27 ] <> Nil
	F1_DESPESA:= aStack[ nSize, 27 ]
	EndIf

	If aStack[ nSize, 28 ] <> Nil
	F1_DESCONT:= aStack[ nSize, 28 ]
	EndIf

	If aStack[ nSize, 29 ] <> Nil
	F1_FRETE:= aStack[ nSize, 29 ]
	EndIf

	If aStack[ nSize, 30 ] <> Nil
	F1_SEGURO:= aStack[ nSize, 30 ]
	EndIf

	If aStack[ nSize, 31 ] <> Nil
	F1_VALMERC:= aStack[ nSize, 31 ]
	EndIf

	If aStack[ nSize, 32 ] <> Nil
	F1_VALBRUT:= aStack[ nSize, 32 ]
	EndIf

	If aStack[ nSize, 33 ] <> Nil
	A2_NOME:= aStack[ nSize, 33 ]
	EndIf

	If aStack[ nSize, 34 ] <> Nil
	A2_TEL:= aStack[ nSize, 34 ]
	EndIf

	If aStack[ nSize, 35 ] <> Nil
	A2_PRICOM:= aStack[ nSize, 35 ]
	EndIf

	If aStack[ nSize, 36 ] <> Nil
	A2_ULTCOM:= aStack[ nSize, 36 ]
	EndIf

	If aStack[ nSize, 37 ] <> Nil
	A2_CGC:= aStack[ nSize, 37 ]
	EndIf

	If aStack[ nSize, 38 ] <> Nil
	A2_END:= aStack[ nSize, 38 ]
	EndIf

	If aStack[ nSize, 39 ] <> Nil
	A2_EST:= aStack[ nSize, 39 ]
	EndIf

	If aStack[ nSize, 40 ] <> Nil
	LINCLUI:= aStack[ nSize, 40 ]
	EndIf

	If aStack[ nSize, 41 ] <> Nil
	LDELETA:= aStack[ nSize, 41 ]
	EndIf

	If aStack[ nSize, 42 ] <> Nil
	LVISUALIZA:= aStack[ nSize, 42 ]
	EndIf

    // Exclui o ultimo elemento da pilha
    ASize( aStack, nSize - 1 )
    lRet := .T.
EndIf
Return( lRet )

Function LocxTrack()
Local aEnt     := {}
Local cKey     := ""
Local nPosItem := 0
Local nPosCod  := 0
Local nLoop    := 0

MafisSave()
SaveVar()

If aCfgNF[SAliasCols]=="SD1"
	nPosItem := GDFieldPos("D1_ITEM")
	nPosCod  := GDFieldPos("D1_COD")
	cKey     := SF1->F1_DOC + SF1->F1_SERIE + SF1->F1_FORNECE + SF1->F1_LOJA
Else
	nPosItem := GDFieldPos("D2_ITEM")
	nPosCod  := GDFieldPos("D2_COD")
	cKey     := SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA
Endif
For nLoop:=1 To Len( aCols )
	AAdd(aEnt,{aCfgNF[SAliasCols],cKey+aCols[nLoop,nPosCod ]+aCols[nLoop,nPosItem]})
Next nLoop
MaTrkShow(aEnt)

MaFisRestore()
RestVar()
Return( .T. )

/*/

±±³Descri‡…o ³Validacao da tabela de precos na NF manual                  ³±±
±±³Usado em  ³MATA467N                                                    ³±±
±±³Retorno   ³ExpL1: Tabela valida                                        ³±±
±±³Parametros³ExpC1: Codigo da Tabela de Preco                            ³±±
±±³          ³ExpC2: Codigo da Condicao de Pagamento                      ³±±
±±³          ³ExpD3: Data de emissao da NF                                ³±±
/*/
Function FaVldTabPrc(cCodTab,dDataVld)
Local lVldTabPrc 	:= .T.
Local cCondPag		:= ""

//³Somente testa validacao qdo informado codigo da Tabela de Preco³

If ( Type("cFunName") == "C" ) .AND. ( cFunName == "MATA467N" ) .AND. ( !Empty(cCodTab) )

	//³Sempre testa conteudo da variavel cCondicao ( Condicao de Pagamento ) ³

	If ( Type("cCondicao") <> "U" )
		cCondPag := cCondicao
	Else
		cCondPag := ""
	Endif
	lVldTabPrc := MaVldTabPrc(cCodTab,cCondPag,,dDataVld)
Endif
Return( lVldTabPrc )

/*/
±±³Descri‡…o ³Esta funcao corrige os valores dos produtos quando e'       ³±±
±±³          ³informado a Tabela de Precos ou removida do cadastro        ³±±
±±³Retorno   ³ExpL1: Sempre .T.                                           ³±±
±±³Usado em: ³MATA467N                                                    ³±±
/*/
Function A467TrcVal()
Local aArea			:= GetArea()
Local aAreaSX3		:= SX3->(GetArea())
local lTabPrc		:= .T. // Indica se utiliza valores da Tabela de Preco (.T.) ou Cadastro SB1 (.F.)
Local aTabPrc		:= {}  // Array da Tabela de Preco (somente do cadastro)
Local nCntFor 		:= 0
Local nProdTab		:= 0 // pos. do produto no array da Tabela de Preco
Local nVlrTabela	:= 0 // Valor de venda pela Tabela de Preco
Local nPercDesc		:= 0 // Perc. de desc.
Local nMoeda		:= M->F2_MOEDA
Local nPProd		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_COD"   })
Local nPQuant		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_QUANT" })
Local nPPrcVen		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_PRCVEN"})
Local nPPrcTab		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_PRUNIT"})
Local nPPrcTot		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_TOTAL" })
Local nPPrcDes		:= aScan(aHeader,{|x| AllTrim(x[2])=="D2_DESC"  })
Local cFilSB1	:= xFilial("SB1")
Local cFilDA1	:= xFilial("DA1")
Local cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"

If cPaisLoc $ cAuxPaisL .And. Upper(FunName()) == "MATA467N"

	//³Nao faz nada para quando o valor de M->F2_TABELA       ³
	//³nao foi trocado, porem, ao trocar valor, verifica onde ³
	//³ira buscar o valor de produto, em seu cadastro (SB1) ou³
	//³na Tabela de Preco (DA1) informada                     ³

	If ( ReadVar() $ "M->D2_COD" ) .Or. ( ReadVar() $ "M->F2_TXMOEDA" ) .Or. ( Alltrim(cMTabPrc) <> Alltrim(M->F2_TABELA) )
		If Empty( M->F2_TABELA )
			lTabPrc := .F. // Precos de SB1
		Else
			lTabPrc := .T. // Precos de DA1
		Endif
	Else
		Return (.T.)
	Endif
	cMTabPrc := M->F2_TABELA

	//³Alimenta array com dados da Tabela de Preco informada ³
	//³ou entao com o preco no cadastro do produto           ³

	If lTabPrc
		//³TABELA DE PRECOS³

		dbSelectArea( "DA1" )
		DA1->( dbSetOrder( 1 ) )
		If DA1->( dbSeek( xFilial( "DA1" ) + M->F2_TABELA ) )
			While !DA1->( Eof() ) .AND. cFilDA1+M->F2_TABELA == DA1->DA1_FILIAL+DA1->DA1_CODTAB
				AAdd( aTabPrc, { DA1->DA1_CODPRO , DA1->DA1_PRCVEN , DA1->DA1_MOEDA } )
				DA1->( dbSkip() )
			End
		EndIf
	Else
		//³CADASTRO DE PRODUTOS ³
		dbSelectArea( "SB1" )
		SB1->( dbSetOrder( 1 ) )
		For nCntFor := 1 to Len(aCols)
			If ( nPProd > 0 )
				If SB1->( MsSeek( cFilSB1 + aCols[nCntFor][nPProd] ) )
					AAdd( aTabPrc, { SB1->B1_COD , SB1->B1_PRV1 , 1 } )
				EndIf
			Endif
		Next nCntFor
	Endif
	//³ Corrige o preco dos produtos inseridos no aCols conforme Tabela de preco informada ³
	If ( nPProd > 0 ) .AND. ( Len(aTabPrc) > 0 )
		For nCntFor := 1 to Len(aCols)

			nProdTab := aScan(aTabPrc,{|x| AllTrim(x[1])==Alltrim(aCols[nCntFor][nPProd])})

			If ( nProdTab > 0 )
				nVlrTabela := aTabPrc[nProdTab][2]
			Else
				nVlrTabela := -1 // Erro ( Nao encontrou )
			Endif

			If ( nVlrTabela <> -1 )
				//³Corrige dados da aCols³
				If ( nPPrcVen > 0 )
					If ( nMoeda == aTabPrc[nProdTab][3] )
						aCols[nCntFor][nPPrcVen] := nVlrTabela
					Else
						aCols[nCntFor][nPPrcVen] := xMoeda(nVlrTabela,aTabPrc[nProdTab][3],nMoeda,dDataBase,MsDecimais(aTabPrc[nProdTab][3]),,M->F2_TXMOEDA)
					Endif
				EndIf
	            If ( nPPrcDes > 0 ) .AND. ( aCols[nCntFor][nPPrcDes] > 0 )
	            	// Fator de multiplicacao para calculo do perc de desc.
	            	nPercDesc := (1-(aCols[nCntFor][nPPrcDes]/100))
	            Else
	            	nPercDesc := 0
	            Endif
	            If ( nPercDesc > 0 )
	            	aCols[nCntFor][nPPrcVen] := aCols[nCntFor][nPPrcVen]*nPercDesc
	            Endif
	            If ( nPPrcTab > 0 )
	            	aCols[nCntFor][nPPrcTab] := aCols[nCntFor][nPPrcVen]
	            Endif
	            If ( nPQuant > 0 ) .AND. ( nPPrcTot > 0 )
	            	aCols[nCntFor][nPPrcTot] := aCols[nCntFor][nPQuant] * aCols[nCntFor][nPPrcVen]
	            Endif
				//³Atualiza telas ³
				If ( Type("oGetDados")<>"U" )
					oGetDados:oBrowse:Refresh()
				Endif
				MaColsToFis(aHeader,aCols,,"MT100",.T.,.F.,.T.)
				Eval(bDoRefresh)
			Endif
		Next nCntFor
	Endif
EndIf
RestArea(aAreaSX3)
RestArea(aArea)
Return (.T.)

/*/
±±³Descri‡…o ³ Validar  4a. pergunta do grupo MT119A, objetivo validar o TES³±±
±±³			 | digitado considerando o preenchimento correcto dos campos na ³±±
±±³          ³ tablea SFC.    												³±±
±±³Usado em: ³ MATA101N                                                     ³±±
/*/
Function MT119Perg4()
LOCAL aArea := GetArea()
LOCAL cTes := &(ReadVar())
LOCAL lRet := .T.
LOCAL cFilSFC	:= xFilial("SFC")
If ExistCpo("SF4") .AND. cTes <= "500"
	DbSelectArea("SFC")
	DbSetOrder(1)
	If DbSeek(cFilSFC+cTes)
		While !Eof() .AND. FC_FILIAL == xFilial("SFC") .AND.;
			FC_TES == cTes
			If Empty(FC_INCDUPL) .OR. Empty(FC_INCNOTA) .OR. Empty(FC_CREDITA) .OR. Empty(FC_CALCULO)
				lRet := .F.
				Exit
			EndIf
			DbSkip()
		End
	EndIf
EndIf
RestArea(aArea)
If !lRet
	Help("","1","TESINV")
EndIf
Return( lRet )

/*
±±ºPrograma  ³LOCXINSDES±±
*/
Function LocxInsDes(ah,aC)
Local aArea			:= GetArea()
Local aAreaSB1		:= {}
Local aAreaSD1		:= {}
Local aImps			:= {}
Local nPosItem 		:= aScan(aH,{|x| Trim(x[2])=="D1_ITEM"})
Local nPosCod 		:= aScan(aH,{|x| Trim(x[2])=="D1_COD"})
Local nPosUM		:= aScan(aH,{|x| Trim(x[2])=="D1_UM"})
Local nPosSegUM		:= aScan(aH,{|x| Trim(x[2])=="D1_SEGUM"})
Local nPosQuant		:= aScan(aH,{|x| Trim(x[2])=="D1_QUANT"})
Local nPosQtSeg		:= aScan(aH,{|x| Trim(x[2])=="D1_QTSEGUM"})
//Local nPosLocal		:= aScan(aH,{|x| Trim(x[2])=="D1_LOCAL"})
Local nPosPrc		:= aScan(aH,{|x| Trim(x[2])=="D1_VUNIT"})
Local nPosTotal		:= aScan(aH,{|x| Trim(x[2])=="D1_TOTAL"})
Local nPosTes		:= aScan(aH,{|x| Trim(x[2])=="D1_TES"})
Local nPosCfo		:= aScan(aH,{|x| Trim(x[2])=="D1_CF"})
//Local nPosConh		:= aScan(aH,{|x| Trim(x[2])=="D1_CONHEC"})
Local nRegSD1		:= 0
Local cProdDes		:= ""
Local cItem			:= ""
Local cTes			:= ""
Local cCFO			:= ""
Local cCpoAux		:= ""
Local cFilSWN		:= ""
//Local nTamAH		:= 0
Local nTamAC		:= 0
Local nD			:= 0
Local nG			:= 0
Local nTotal		:= 0
Local nPosTESArr	:= 0
Local nY			:= 0
Local aImpostos		:= {}
Local aCusto		:= {}
Local aCustoDesp	:= {}
Local aTes			:= {}
Local lClasNF		:= (SuperGetMV("MV_CLASSNF") == "1")
Local cHawb			:= ""
//Local aSvAreaSF1	:= {}
//Local aSvAreaSD1	:= {}
Local cFilSD1		:= xFilial("SD1")
Local cFilSF4		:= xFilial("SF4")
Local cFilSYD		:= xFilial("SYD")
Local cFilSFC		:= xFilial("SFC")
Local cFilSFB		:= xFilial("SFB")
Local nT_COD		:= TamSX3("D1_COD")[1]
Local nP_TESDES	:= 0
Local nP_TES		:= 0
Local nP_CF		:= 0
Local nP_COD		:= 0
Local nP_UM		:= 0
Local nP_SEGUM	:= 0
Local nP_TP		:= 0
Local nP_GRUPO	:= 0
Local nP_DOC		:= 0
Local nP_SERIE	:= 0
Local nP_FORNECE	:= 0
Local nP_LOJA		:= 0
Local nP_ESPECIE	:= 0
Local nP_TIPO_NF	:= 0
Local nP_TIPO		:= 0
Local nP_EMISSAO	:= 0
Local nP_DTDIGIT	:= 0
Local nP_FORMUL	:= 0
Local nP_TIPODOC	:= 0

cProdDes:=SuperGetMV("MV_PRDDESP",,"")
If !Empty(cProdDes)
	DbSelectArea("SD1")
	aAreaSD1:=GetArea()
	nRegSD1:=Recno()
	DbSetOrder(1)
	nP_TESDES	:= FieldPos("D1_TESDES")
	nP_TES		:= 1 //FieldPos("D1_TES")
	nP_CF		:= 1 //FieldPos("D1_CF")
	nP_COD		:= 1 //FieldPos("D1_COD")
	nP_UM		:= 1 //FieldPos("D1_UM")
	nP_SEGUM	:= 1 //FieldPos("D1_SEGUM")
	nP_TP		:= 1 //FieldPos("D1_TP")
	nP_GRUPO	:= 1 //FieldPos("D1_GRUPO")
	nP_DOC		:= 1 //FieldPos("D1_DOC")
	nP_SERIE	:= 1 //FieldPos("D1_SERIE")
	nP_FORNECE	:= 1 //FieldPos("D1_FORNECE")
	nP_LOJA	    := 1 //FieldPos("D1_LOJA")
	nP_ESPECIE	:= 1 //FieldPos("D1_ESPECIE")
	nP_TIPO_NF	:= 1 //FieldPos("D1_TIPO_NF")
	nP_TIPO	    := 1 //FieldPos("D1_TIPO")
	nP_EMISSAO	:= 1 //FieldPos("D1_EMISSAO")
	nP_DTDIGIT	:= 1 //FieldPos("D1_DTDIGIT")
	nP_FORMUL	:= 1 //FieldPos("D1_FORMUL")
	nP_TIPODOC	:= 1 //FieldPos("D1_TIPODOC")

	If !DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+cProdDes)
		SD1->(MsGoto(nRegSD1))
		aAreaSB1:=SB1->(GetArea())
		SB1->(DbSetOrder(1))
		SB1->(MsSeek(xFilial("SB1")+cProdDes))
		dbSelectArea("SWN")
		dbSetOrder(3)
		nTotal	:= 0
		cHawb	:= SF1->F1_HAWB
		cFilSWN:= xFilial("SWN")
		aTes	:= {}
		If DbSeek(cFilSWN+SF1->F1_HAWB+SF1->F1_TIPO_NF)
			While WN_FILIAL==cFilSWN .And. WN_HAWB==SF1->F1_HAWB .And. WN_TIPO_NF==SF1->F1_TIPO_NF
				If SYD->(MsSeek(cFilSYD+SWN->(WN_TEC+WN_EX_NCM+WN_EX_NBM)))
					cTes:=SYD->YD_TES
					If (nPosTesArr := Ascan(aTes,{|x| x[1] == cTes })) == 0
						SFC->(DbSeek(cFilSFC+cTes))
						While !SFC->(Eof()) .And. SFC->FC_TES==cTes
							If SFB->(MsSeek(cFilSFB+SFC->FC_IMPOSTO))
								Aadd(aImps,{SFB->FB_CPOLVRO,0,0,0})
							Endif
							SFC->(DbSkip())
						EndDo
						AAdd(aTes,{WN_TES,WN_CIF,aClone(aImps)})
						nPosTesARR := Len(aTes)
					Else
						aTes[nPosTesARR,2] +=WN_CIF
					Endif
					For nG:=1 to Len(aTes[nPosTesARR,3])
						cCpoAux := "WN_BASIMP"+aTes[nPosTesARR,3,nG,1]
						aTes[nPosTesARR,3,nG,2]+= FieldGet(FieldPos(cCpoAux))
						cCpoAux := "WN_ALQIMP"+aTes[nPosTesARR,3,nG,1]
						aTes[nPosTesARR,3,nG,3]:= FieldGet(FieldPos(cCpoAux))
						cCpoAux := "WN_VALIMP"+aTes[nPosTesARR,3,nG,1]
						aTes[nPosTesARR,3,nG,4]+= FieldGet(FieldPos(cCpoAux))
					Next
				Endif
				DbSkip()
			EndDo
		Endif
		For nD:= 1 To Len(aTes)
			cTes	:= aTes[nD,1]
			nTotal	:= aTes[nD,2]
			aImps	:= aClone(aTes[nD,3])
			SF4->(MsSeek(cFilSF4+cTes))
			cCFO	:= SF4->F4_CF
			nTamAC	:= Len(aC)
			cItem	:= aC[nTamAC,nPosItem]
			cItem	:= Soma1(cItem)
			Aadd(aC,Array(Len(aH)+1))
			nTamAC	:= Len(aC)
			aC[nTamAC,Len(aC[nTamAC])]:=.F.

			Begin Transaction

			DbSelectArea("SD1")
			RecLock("SD1",.T.)
			Replace D1_FILIAL With cFilSD1
			For nG:=1 to Len(aH)
				Do Case
					Case nG==nPosItem
						aC[nTamAC,nPosItem]:=cItem
					Case nG==nPosCod
						aC[nTamAC,nPosCod]:=Padr(cProdDes,nT_COD)
					Case nG==nPosUM
						aC[nTamAC,nPosUM]:=SB1->B1_UM
					Case nG==nPosSegUM
						aC[nTamAC,nPosSegUM]:=SB1->B1_SEGUM
					Case nG==nPosTes
						aC[nTamAC,nPosTes]:=cTes
					Case nG==nPosCfo
						aC[nTamAC,nPosCfo]:=cCFO
					Case nG==nPosQuant
						aC[nTamAC,nPosQuant]:=1
					Case nG==nPosQtSeg
						If !Empty(SB1->B1_CONV)
							If SB1->B1_TIPCONV == "M"
						    	aC[nTamAC,nPosQtSeg]:= 1 * SB1->B1_CONV
						   	Else
						      	aC[nTamAC,nPosQtSeg]:= 1 / SB1->B1_CONV
						   	EndIf
						Else
							aC[nTamAC,nPosQtSeg]:=0
						EndIf
					Case nG==nPosPrc
						aC[nTamAC,nPosPrc]:=nTotal
					Case nG==nPosTotal
						aC[nTamAC,nPosTotal]:=nTotal
					OtherWise
						aC[nTamAC,nG]:=aC[1,nG]
				EndCase
				FieldPut(FieldPos(aH[nG,2]),aC[nTamAC,nG])
			Next
			FieldPut(nP_TESDES	,cTes)
			If lClasNF
				Replace D1_TES With cTes
				Replace D1_CF  With cCFO
			EndIf
			Replace D1_COD     With Padr(cProdDes,nT_COD)
			Replace	D1_UM	   With SB1->B1_UM
			Replace	D1_SEGUM   With SB1->B1_SEGUM
			Replace	D1_TP	   With SB1->B1_TIPO
			Replace	D1_GRUPO   With SB1->B1_GRUPO
			cAuxPaisL := "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
			If cPaisLoc $ cAuxPaisL
				Replace	D1_DOC	   With SF1->F1_DOC
				//Replace	D1_SERIE   With SF1->F1_SERIE
				SerieNfId("SD1",1,"D1_SERIE",,,,SF1->F1_SERIE ) //Projeto chave única - Tiago Silva
			EndIf

			Replace	D1_FORNECE With SF1->F1_FORNECE
			Replace	D1_LOJA    With SF1->F1_LOJA
			cAuxPaisL := "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN"
			If cPaisLoc $ cAuxPaisL
				Replace	D1_ESPECIE With SF1->F1_ESPECIE
			EndIf
			Replace	D1_TIPO_NF With SF1->F1_TIPO_NF
			Replace	D1_TIPO	   With SF1->F1_TIPO
			Replace	D1_EMISSAO With SF1->F1_EMISSAO
			Replace	D1_DTDIGIT With SF1->F1_DTDIGIT
			Replace	D1_FORMUL  With SF1->F1_FORMUL
			Replace	D1_TIPODOC With SF1->F1_TIPODOC

			For nG:=1 To Len(aImps)
				cCpoAux:="D1_BASIMP"+aImps[nG][1]
				FieldPut(FieldPos(cCpoAux),Round(aImps[nG][2],MSDecimais(1)))
				cCpoAux:="D1_ALQIMP"+aImps[nG][1]
				FieldPut(FieldPos(cCpoAux),aImps[nG][3])
				cCpoAux:="D1_VALIMP"+aImps[nG][1]
				FieldPut(FieldPos(cCpoAux),Round(aImps[nG][4],MSDecimais(1)))
			Next
			aCusto := {}
			AADD(aCusto,{0.00,{},0,"N","N","","",SD1->D1_COD,RetFldProd(SD1->D1_COD,"B1_LOCPAD"),SD1->D1_QUANT})

			aImpostos:=TesImpInf(SD1->D1_TES)

			For nY:=1 to Len(aImpostos)
				nPosSD1 :=SD1->(FieldPos("D1_"+Substr(aImpostos[nY][2],4)))
				If nPosSD1 > 0
					If ( aImpostos[nY][5] == "1" )
						aCusto[1][1]+= SD1->(FieldGet(nPosSD1))
					EndIf
				Endif
			Next  nY

			//³ Pegar o Custo do Despacho
			aCustoDesp := RetCusEnt(,aCusto,"N")

			If Len(aCustoDesp) > 0
				//³ Grava custo em todas moedas
				Replace   D1_CUSTO  	With aCustoDesp[1][1]
				Replace 	D1_CUSTO2 	With aCustoDesp[1][2]
				Replace 	D1_CUSTO3 	With aCustoDesp[1][3]
				Replace 	D1_CUSTO4 	With aCustoDesp[1][4]
				Replace 	D1_CUSTO5 	With aCustoDesp[1][5]
			EndIf
			SD1->(MsUnlock())
			SD1->(DbCommit())

			End Transaction

		Next
		RestArea(aAreaSB1)
		RestArea(aAreaSD1)
	EndIf
	If lClasNF

		If DbSeek(cFilSD1+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)

			While !Eof() .AND. D1_FILIAL == cFilSD1;
						 .AND. D1_DOC == SF1->F1_DOC;
						 .AND. D1_SERIE == SF1->F1_SERIE;
						 .AND. D1_FORNECE == SF1->F1_FORNECE;
						 .AND. D1_LOJA == SF1->F1_LOJA

            	If SD1->D1_COD <> cProdDes

					SF4->(MsSeek(cFilSF4+SD1->D1_TESDES))
					cCFO:=SF4->F4_CF

					Begin Transaction
					RecLock("SD1",.F.)
			   		Replace D1_TES  With SD1->D1_TESDES
					Replace D1_CF   With cCFO

					aCusto := {}
					AADD(aCusto,{SD1->D1_TOTAL,{},0,"N","N","","",SD1->D1_COD,RetFldProd(SD1->D1_COD,"B1_LOCPAD"),SD1->D1_QUANT})

					aImpostos:=TesImpInf(SD1->D1_TES)

					For nY:=1 to Len(aImpostos)
						nPosSD1 :=SD1->(FieldPos("D1_"+Substr(aImpostos[nY][2],4)))
						If nPosSD1 > 0
  			              	FieldPut(nPosSD1,SD1->(FieldGet(nPosSD1))) //Lucas, 16/08/07
							If ( aImpostos[nY][5] == "1" )
								aCusto[1][1]+= SD1->(FieldGet(nPosSD1))
							EndIf
						Endif
					Next  nY

					//³ Pegar o Custo do Despacho                                                                     ³
					aCustoDesp := RetCusEnt(,aCusto,"N")

					If Len(aCustoDesp) > 0
						//³ Grava custo em todas moedas                                  ³
						Replace D1_CUSTO  	With aCustoDesp[1][1]
						Replace D1_CUSTO2 	With aCustoDesp[1][2]
						Replace D1_CUSTO3 	With aCustoDesp[1][3]
						Replace D1_CUSTO4 	With aCustoDesp[1][4]
						Replace D1_CUSTO5 	With aCustoDesp[1][5]
					EndIf

					SD1->(MsUnlock())
					SD1->(DbCommit())

					End Transaction

				EndIf
				SD1->(DbSkip())
			EndDO
		EndIf
	EndIf
Endif
RestArea(aArea)
Return

/*/
±±³Descri‡…o ³Compatibilizacao de variaveis utilizadas no FINC010         ³±±
/*/
Function LocxFc010()
Local aArea	:= GetArea()

dbselectarea(aCfgNF[SAliasHead])
dbclearfilter()

If Pergunte("FIC010",.T.)
	Fc010Con('SA1',SA1->(RecNo()),3)
EndIf

dbselectarea(aCfgNF[SAliasHead])
Eval( bFilBrw )

RestArea(aArea)
Return .T.

/*
±±ºPrograma  ³LOCXNF    ºAutor  ³Microsiga           ºFecha ³  08/18/04   º±±
±±ºDesc.     ³ Procura pelo remito de origem da nota de entrada           º±±
*/
Function LocxNrReIm(cHawb,cDocSer)
Local aArea   := GetArea()
Local aRet    := {"","","",""}
Local aSF1    := {}
Local cChSF1  := ""
Local lRemito := .F.

aRet[1]:="RI "
dbSelectArea("SF1")
aSF1:=GetArea()
dbSetOrder(5)
cChSF1:=xFilial("SF1")+cHawb+"5"
If DbSeek(cChSF1)
	While F1_FILIAL+F1_HAWB+F1_TIPO_NF==cChSF1 .AND. !lRemito
		If !Empty(F1_REMITO) .And. (Empty(cDocSer) .Or. (cDocSer == F1_DOC /*.And. Empty(F1_SERIE)*/ ) )
			lRemito:=.T.
			aRet[2]:=F1_REMITO
			aRet[3]:=F1_FORNECE
			aRet[4]:=F1_LOJA
		EndIf
		DbSkip()
	EndDo
EndIf
RestArea(aSF1)
If !lRemito
	If SX5->(MsSeek(xFilial("SX5")+"01"+aRet[1]))
		RecLock("SX5",.F.)
		aRet[2]:=Alltrim(X5DESCRI())
		Replace SX5->X5_DESCRI	With Soma1(aRet[2])
		Replace SX5->X5_DESCSPA	With SX5->X5_DESCRI
		Replace SX5->X5_DESCENG	With SX5->X5_DESCRI
		SX5->(MsUnlock())
	Else
		RecLock("SX5",.T.)
		aRet[2]:=Padl("1",TamSX3("F1_DOC")[1],"0")
		Replace SX5->X5_FILIAL	With xFilial("SX5")
		Replace SX5->X5_TABELA	With "01"
		Replace SX5->X5_CHAVE	With aRet[1]
		Replace SX5->X5_DESCRI	With Soma1(aRet[2])
		Replace SX5->X5_DESCSPA	With SX5->X5_DESCRI
		Replace SX5->X5_DESCENG	With SX5->X5_DESCRI
	EndIf
EndIf
RestArea(aArea)
Return aRet

Function LocXDelCC(cForn,cLoja,cDoc,cSerie)
Local lRet  := .F.
Local aArea := {}
Local aSEU  := {}
Local nRegSEU := 0
//Local nValDev := 0
//Local cCx := ""
Local cFilSEU	:= xFilial("SEU")
local cFilSET	:= xFilial("SET")
Local cNumAnt   :=""
Local aSldAtu   :={}

//Contabilidad online
//Local lPad579	:= VerPadrao("579")
Local lUsaFlag	:= SuperGetMV("MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
//Local aFlagCTB	:= {}
//Local aCtbDia	:= {}
//Local nTotal	:= 0
//Local cArquivo	:= ""
Local cFunName	:= FunName()

//Contabilidad online
Private nHdlPrv := 0
Private cLote	:= ""

If SIX->(MsSeek("SEU7"))
	aArea:=GetArea()
	aSEU:=SEU->(GetArea())
	DbSelectArea("SEU")
	DbSetOrder(7)
	cDoc:=Padr(cDoc,Len(EU_NRCOMP))
	If MsSeek(cFilSEU+cForn+cLoja+cDoc+cSerie)
		SET->(dbSetOrder(1))
		SET->(MsSeek(cFilSET+SEU->EU_CAIXA))
		If IIF(SET->ET_SITUAC == "0" , .F. , .T.)
			lRet := .F.
		Else
			If SEU->EU_TIPO == "01" // adiant.
				nRegSEU:=Recno()
				cNroAdia := SEU->EU_NUM
				cNumAnt  := SEU->EU_NUM
				dbSelectArea("SEU")
				dbSetOrder(3)  // filial + nroadia
				While dbSeek( cFilSEU + cNroAdia)
					RecLock(cAlias,.F.,.T.)
					dbDelete()
					MsUnlock()
				End
				MsGoto(nRegSEU)
			EndIf

			DbSelectArea("SEU")

	  		If cPaisLoc == "BOL" .And. !Empty(EU_BAIXA)
				nVlrDel  := EU_VALOR
				cNroAdia := EU_NROADIA
				dBaixa   := EU_BAIXA
				cNumAnt  := posicione("SEU",6,cFilSEU+SEU->EU_CAIXA+"01"+cNroAdia,"EU_NUM")
      			Fa560FcAdi( SEU->(Recno()), SEU->EU_VALOR, GetSx8Len(),, .T.)
			Else
				nVlrDel  := EU_VALOR
				cNroAdia := EU_NROADIA
				dBaixa   := EU_BAIXA
				If cPaisLoc == "ARG" .And. !Empty(EU_BAIXA)
					nRegSEU := Recno()
					cNumAnt  := posicione("SEU",6,cFilSEU+SEU->EU_CAIXA+"01"+cNroAdia,"EU_NUM")
					MsGoto(nRegSEU)
				EndIf
				If cPaisLoc == "PER"
					LxDelCCPer(lUsaFlag, (mv_par03 == 1), cFunName, cUsuario)
				EndIf
				RecLock("SEU",.F.,.t.)
				dbDelete()
				MsUnlock()
			EndIf
			If Empty(cNroAdia)
				If Empty(dBaixa)
					//³ Atualiza saldo do caixinha e niveis superiores, se houverem ³
					dbSelectArea("SET")
					dbSetOrder(1)
					MsSeek(cFilSET+SEU->EU_CAIXA)
					aSldAtu := Fa570AtuSld( ET_CODIGO)
					RecLock("SET",.F.)
					If cPaisLoc == "ARG"
						REPLACE ET_SALANT WITH SET->ET_SALDO
					EndIf
					REPLACE ET_SALDO WITH aSldAtu[1][1]
					MsUnlock()
				EndIf
			Else
				If cPaisLoc == "CHI"
					LxDelCCChi(cFilSET, cFilSEU, cForn, cLoja, cDoc, cSerie, cNroAdia, @nVlrDel)
				Endif
				If cPaisLoc $ "BOL"
					LxDelCCBol(cFilSEU, cNroAdia, cNumAnt, nVlrDel)
				Else
					dbSelectArea("SEU")
					If cPaisLoc $ "ARG"
						SEU->(dbSetOrder(3))
					Else
						SEU->(dbSetOrder(1))
					Endif
					If SEU->(DbSeek(cFilSEU+cNroAdia+(Iif(cPaisLoc $ "ARG",cNumAnt,""))))
						RecLock("SEU",.F.)
						REPLACE EU_SLDADIA WITH EU_SLDADIA + nVlrDel
						If !Empty(EU_BAIXA)
							REPLACE EU_BAIXA WITH CTOD("//")
						Endif
						MsUnlock()
					EndIf
				EndIf
			EndIf
			lRet:=.T.
		Endif
	Endif
	RestArea(aSEU)
	RestArea(aArea)
Endif
Return(lRet)

/*
±±ºDesc.     ³ Funcao para calcular o vencimento do imposto.               º±±
±±º          ³ cDia  := Recebe o dia para o calculo de data valida         º±±
±±º          ³ cTipo := Tipo de calculo para data                          º±±
±±º          ³     1 -> Proximo dia valido, caso seja menor que o dia      º±±
±±º          ³          atual, fica valendo para o mes seguinte.           º±±
±±º          ³     2 -> Sera considerado o dia somente para o proxiomo mes.º±±
±±º          ³     3 -> E somado o valor na data corrente (DataBase+31)    º±±*/
Static Function LocVencImp(cDia,cTipo,aTitPai)
Local dVencto := CTOD("  /  /  ")
Local cMes    := ""
Local cAno    := ""

If cTipo == '1'  .OR. cTipo == '2'
	If (cTipo=='1' .AND. Val(cDia) < Day(dDataBase)) .OR. cTipo == '2'
		cMes	:=	StrZero(Mod(Month(dDataBase)+1,12),2)
		cAno	:=	StrZero(IIf(cMes=='01',Year(dDataBase)+1,Year(dDataBase)),4)
	Else
		cMes	:=	StrZero(Month(dDataBase),2)
		cAno	:=	StrZero(Year(dDataBase),4)
	Endif
	If cDia == "31"
		cDia	:=	StrZero(F_UltDia(CTOD('01/'+cMes+'/'+cAno,"dd/mm/yy")),2)
	Else
		cDia	:=	StrZero(MIN(VAL(ALLTRIM(STR(F_UltDia(Ctod('01/'+cMes+'/'+cAno,"dd/mm/yy"))))),Val(cDia)),2)
	Endif
	dVencto := CTOD(cDia+"/"+cMes+"/"+cAno,"dd/mm/yy")
ElseIf cTipo == '3'
	dVencto := (dDataBase + Val(cDia))
Else
	dVencto := dDataBase
Endif

If cPaisloc == "PER"
	dVencto := VencImpPer(dDatabase, aTitPai)
EndIf
Return dVencto

/*
±±ºDesc.     ³Validacao da Serie Informada X Serie do Codigo de Barra da NF.   º±±
±±ºParametros³ cAlias		- Alias do Arquivo (SF1/SF2)                       º±±
±±º          ³ cFieldCODBAR - (M->F1_CODBAR/M->F2_CODBAR)                      º±±
±±º          ³ cFieldSERIE  - (M->F1_SERIE/M->F2_SERIE)                        º±±
±±ºUso       ³ Validacao de: (M->F1_SERIE/M->F2_SERIE)                         º±±*/
Function LocxSERIE(cAlias,cFieldCODBAR, cFieldSERIE)
Local lValido:=.F.
Local aVTipoCompr := {}

DbSelectArea("SX3")
DbSetOrder(2)
If cAlias == "SF1"
	If !SX3->(MsSeek('F1_CODBAR'))
		Return .T.
	Else
		If Type("M->F1_CODBAR")=="U"
			Return .T.
		Endif
	Endif
Else
	If !SX3->(MsSeek('F2_CODBAR'))
		Return .T.
	Else
		If Type("M->F2_CODBAR")=="U"
			Return .T.
		Endif
	Endif
Endif

If Empty(IIf(cAlias=="SF1",M->F1_CODBAR,M->F2_CODBAR))
	lValido:=.T.
Else
	aVTipoCompr:=MT991SETpC(cAlias,SubStr(cFieldCODBAR,12,2))
	If Substr(AllTrim(aVTipoCompr[1]) ,1,1) == Substr(AllTrim(M->cFieldSERIE),1,1)
		lValido:=.T.
	Endif
Endif
If !lValido
	Help(" ",1,"LOCXNF0012")
Endif
Return lValido
/*
±±ºDesc.     ³Validacao dos Campos no Botao de Confirmacao                º±±
±±ºParametros³ cAlias        - Alias do Arquivo (SF1,SF2)                 º±±
±±º          ³ cTexto        - Codigo de Barras                           º±±
±±º          ³ lValidaDv     - Se valida o DV do Codigo de Barras         º±±
±±ºUso       ³ SX3->X3_VALID                                              º±±*/
Function LocxCODBOK(cAlias, cTexto, lValidaDv )
Local lValido		:= .F.//, lErro:=.F.
Local aAreaAtu		:= GetArea()
Local aVTipoCompr	:= {}
//Local aPHelpEsp		:= {}
//Local aPHelpPor		:= {}
//Local aPHelpEng		:= {}
//Local aSHelpEsp		:= {}
//Local aSHelpPor		:= {}
//Local aSHelpEng		:= {}
//Local lForneceOK	:= .F.
Local cEspecie		:= ""
Local cSerie		:= ""
//Local cCGC			:= ""
Local cFornece		:= ""
Local cLoja			:= ""
Local cCliente		:=IIf(aCfgNf[SAliasHead]=="SF1","_FORNECE","_CLIENTE")

If Type("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_CODBAR")=="U" .or. IsIncallStack("Fina560")
	Return .T.
Endif

If Empty(cTexto)
	Return .T.
Endif

DEFAULT lValidaDV:= .T.

If Len(AllTrim(cTexto)) == 40
	If lValidaDv
		If LocXCMod10(SubStr(cTexto,1,39)) # SubStr(cTexto,40,1)
			Help(" ",1,"LOCXNF0013")
			Return lValido
		Endif
	Endif
	cEspecie:=&("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_ESPECIE")
	cSerie	:=&("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_SERIE")

	aVTipoCompr:=MT991SETpC(cAlias,SubStr(cTexto,12,2))
	RestArea(aAreaAtu)
	If Substr(aVTipoCompr[2],1,2)==Substr(cEspecie,1,2)
		If Substr(AllTrim(aVTipoCompr[1]),1,1) == Substr(AllTrim(cSerie),1,1)
			DbSelectArea(aCfgNf[ScCliFor])
			DbSetOrder(1)
			lFornece:=.F.
			cFornece:=&("M->"+PrefixoCpo(aCfgNf[SAliasHead])+cCliente)
			cLoja	:=&("M->"+PrefixoCpo(aCfgNf[SAliasHead])+"_LOJA")
			If DbSeek(xFilial(aCfgNf[ScCliFor])+cFornece+cLoja)
				If !EOF()
					If Substr(Alltrim(&(aCfgNf[ScCliFor]+"->"+PrefixoCpo(aCfgNf[ScCliFor])+"_CGC")),1,11)==Substr(cTexto,1,11)
						lValido:=.T.
					Else
						Help(" ",1,"LOCXNF0006")
					Endif
				Else
					Help(" ",1,"LOCXNF0006")
				Endif
			Else
				RestArea(aAreaAtu)
				Help(" ",1,"LOCXNF0003")
			Endif
		Else
			Help(" ",1,"LOCXNF0012")
		Endif
	Else
		Help(" ",1,"LOCXNF0004")
	Endif
Else
	Help(" ",1,"LOCXNF0005")
Endif
Return lValido
/*
Programa  ³SCMToREM Fecha ³  09/02/05
Desc.     ³Selecao de remitos para NF de entrada
*/
Function SCMToREM()
Local aCposF4		:= {}
Local aRecs    		:= {}
Local aRet     		:= {}
Local aHeaderSDE	:= {}
Local aArea    		:= GetArea()
//Local cCampo 		:= ""
Local cCliFor		:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_FORNECE,M->F2_CLIENTE)
Local cCondicao2 	:= ""
Local cItem			:=	""
Local cLoja  		:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_LOJA,M->F2_LOJA)
Local cSeek  		:= "'" + xFilial('SF1')+cCliFor+cLoja + "'"
Local cTipoDoc 		:= ""
Local cWhile 		:= "!__LOCXSF1->(EOF()) .AND. __LOCXSF1->(F1_FILIAL+F1_FORNECE+F1_LOJA)== " + cSeek
Local cPosFilial	:= ""
Local cPosDoc		:= ""
Local cPosSerie		:= ""
Local cPosFornece	:= ""
Local cPosLoja		:= ""
Local cPosTipo		:= ""
Local nDescri  		:= 0
Local nPorDesc		:= 0
Local nItemRem 		:= 0
Local nUm      		:= 0
Local nSegum   		:= 0
Local nCod     		:= 0
Local nLocal   		:= 0
Local nQuant   		:= 0
Local nRemito  		:= 0
Local nSeriRem 		:= 0
Local nItem    		:= 0
Local nTes     		:= 0
Local nCf      		:= 0
Local nLoteFor 		:= 0
Local nLoteCtl 		:= 0
Local nNumLote 		:= 0
Local nDtValid 		:= 0
Local nProvEnt		:= 0
Local nIpi     		:= 0
Local nVunit   		:= 0
Local nTotal   		:= 0
Local nQTSegum 		:= 0
Local nConta 		:= 0
Local nCCusto 		:= 0
Local nFepp 		:= 0
Local nIE   		:= 0
Local nDesc 		:= 0
//Local nDesNTrb		:= 0
//Local nTara			:= 0
Local nBsImp1M		:= 0
Local nVlImp1M		:= 0
Local nServic		:= 0
Local nUbica		:= 0
Local lWmsNew    	:= SuperGetMV("MV_WMSNEW",.F.,.F.)
Local nTotalM		:= 0
Local nI 			:= 0
Local nJ 			:= 0
//Local nK 			:= 0
Local cTipConv 		:= GetNewPar("MV_ALTTXNF",'1')
Local nTaxaNf		:= 0
Local nTaxaPed		:= 0
Local nItConta  	:= 0
Local nClValor  	:= 0
Local nSeguro       := 0
Local nFrete        := 0
Local nDescont      := 0
Local nDespesa      := 0
Local cPe			:=	""
Local cPeT			:=	""
Local cRetPe		:=  ""
Local lRetPE69		:= .T.
Local lZeraCols     := .T.
Local nRat			:= 0
Local nPedido		:= 0
Local nItemPC		:= 0
Local nFornece		:= 0
Local nLojaForn		:= 0
Local nDifRem		:= 0
Local nFDESC		:= 0
Local nVlTotal		:= 0
Local lConfFis		:= SuperGetMV("MV_CONFFIS",.F.,"N") == "S"
Local lRemDiv		:= SuperGetMV("MV_REMDIV",.F.,.F.)
Local lCheckMoed	:= .T.
Local aFilTop		:= {.F.}
Local aChMoeda		AS Array
//Local cCFO			:= ""
Local lValDesc		:= cPaisLoc $ "PER|MEX|COL" .And. FunName() $ "MATA465N"
Local aRecSD1		:= {}		//OPTIMIZA...
Local lOtros		:= .F.		//...OPTIMIZA

Private aFiltro		:= {}
Private aColsSD1	:= aCols
Private oTmpRemito	:= Nil

If Empty(cCliFor) .OR. Empty(cLoja)
	Aviso(cCadastro,STR0094,{STR0021}) //"Llene encabezado."###"OK"
	Return
EndIf
For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D1_DESCRI"
			nDescri  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DESC"
			nPorDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMREM"
			nItemRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SEGUM"
			nSegum   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_REMITO"
			nRemito  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SERIREM"
			nSeriRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTEFOR"
			nLoteFor := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_IPI"
			nIpi     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VUNIT"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CC"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FEPP"
			nFepp := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_IE"
			nIE   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VALDESC"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMCTA"
			nItConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CLVL"
			nClValor := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_PROVENT"
			nProvEnt := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_RATEIO"
			nRat := nI
		Case Alltrim(aHeader[nI][2]) == "D1_PEDIDO"
			nPedido := nI
		Case Alltrim(aHeader[nI][2]) == "D1_ITEMPC"
			nItemPC := nI
		Case Alltrim(aHeader[nI][2]) == "D1_FORNECE"
			nFornece := nI
		Case Alltrim(aHeader[nI][2]) == "D1_LOJA"
			nLojaForn := nI
		Case Alltrim(aHeader[nI][2]) == "D1_FDESC"
			nFDESC := nI
		Case Alltrim(aHeader[nI][2]) == "D1_BSIMP1M" .AND. cPaisloc == "RUS"
			nBsImp1M := nI
		Case Alltrim(aHeader[nI][2]) == "D1_VLIMP1M" .AND. cPaisloc == "RUS"
			nVlImp1M := nI
		Case Alltrim(aHeader[nI][2]) == "D1_TOTALM" .AND. cPaisloc == "RUS"
			nTotalM := nI
		Case Alltrim(aHeader[nI][2]) == "D1_SERVIC" .AND. cPaisloc == "ARG"
			nServic := nI
		Case Alltrim(aHeader[nI][2]) == "D1_ENDER" .AND. cPaisloc == "ARG"
			nUbica := nI
	Endcase
Next nI
If aCfgNF[SnTipo] == 4 .OR. aCfgNF[SnTipo] == 5
	cTipoDoc := "51/53"
ElseIf aCfgNF[SnTipo] == 10
	//#PORTUGAL#
	/*If cPaisLoc=="PTG"
		nAviso:= Aviso(GetDescRem(),STR0005+GetDescRem(),{STR0309,STR0310},1)
		If nAviso==1
			cTipoDoc:="65"   // Amarra Guia de Remessa
		ElseIf nAviso==2
			cTipoDoc:="60"   // Amarra Guia de Transporte
		Else
			Return
		EndIf
	Else*/
		cTipoDoc := "60"
	//EndIf
Else
	Return
EndIf
SX3->(DbSetOrder(1))
SX3->(DbSeek("SF1"))
While !SX3->(EOF()) .AND. SX3->X3_ARQUIVO == "SF1"
	If SX3->X3_BROWSE == "S" .AND. cNivel >= SX3->X3_NIVEL .AND. SX3->X3_TIPO != "M"
		AAdd(aCposF4,SX3->X3_CAMPO)
	Endif
	SX3->(DbSkip())
End
For nI:=1 to Len(aCposF4)
	Do Case
		Case  Alltrim(aCposF4[nI]) == "F1_FILIAL"
			cPosFilial := nI
		Case  Alltrim(aCposF4[nI]) == "F1_DOC"
			cPosDoc := nI
		Case  Alltrim(aCposF4[nI]) == "F1_SERIE"
			cPosSerie := nI
		Case  Alltrim(aCposF4[nI]) == "F1_FORNECE"
			cPosFornece := nI
		Case  Alltrim(aHeader[nI]) == "F1_LOJA"
			cPosLoja := nI
		Case  Alltrim(aHeader[nI]) == "F1_TIPO"
			cPosTipo := nI
	Endcase
Next nI
If nRemito * nSeriRem * nItemRem > 0
	If FindFunction("FilToRemTop")
		aFilTop := FilToRemTop(cCliFor,cLoja,aCfgNF[ScTipoDoc],Alltrim(cTipoDoc),nRemito,nSeriRem,nItemRem)
	EndIf
	If	!aFilTop[1]
		DbSelectArea("SD1")
		SD1->(DbSetOrder(10))
		SD1->(DbSeek(xFilial("SD1")+cCliFor+cLoja))
		lFilData:=.T.
		If ExistBlock("LOCFDTR")
			lFilData:=Execblock("LOCFDTR",.F.,.F.,)
		EndIf

		If lFilData
			cFilRem:="DToS(SD1->D1_DTDIGIT) <= DToS(dDataBase) .AND. SD1->D1_QTDACLA > 0 .AND. AllTrim(SD1->D1_TIPO) == aCfgNF[ScTipoDoc] .AND.	AllTrim(SD1->D1_TIPODOC) $ Alltrim(cTipoDoc)"
		Else
			cFilRem:="SD1->D1_QTDACLA > 0 .AND. AllTrim(SD1->D1_TIPO) == aCfgNF[ScTipoDoc] .AND. AllTrim(SD1->D1_TIPODOC) $ Alltrim(cTipoDoc)"
		EndIf
		While !SD1->(EOF()) .AND.SD1->D1_FILIAL+SD1->D1_FORNECE+SD1->D1_LOJA == xFilial("SD1")+cCliFor+cLoja
			If 	DToS(SD1->D1_DTDIGIT) <= DToS(dDataBase) .AND. SD1->D1_QTDACLA > 0 .AND. AllTrim(SD1->D1_TIPO) == aCfgNF[ScTipoDoc] .AND.	AllTrim(SD1->D1_TIPODOC) $ Alltrim(cTipoDoc)
				If Ascan(aColsSD1,{ |X| X[nRemito]+X[nSeriRem]+X[nItemRem] == SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_ITEM .and. !X[len(aHeader)+1]})==0
					dbSelectArea("SF1")
					SF1->(DbSetOrder(1))
					If !lConfFis .Or. (lConfFis .And. SF1->(dbSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA)) .And. ((SF1->F1_STATCON $ (Iif(lRemDiv,"1*2","1"))) .OR. EMPTY(SF1->F1_STATCON)))
						Aadd(aFiltro, {SD1->D1_FILIAL+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_TIPO, SD1->(Recno())})
					EndIf
				Endif
			Endif
			SD1->(DbSkip())
		End
	EndIf
	If !Empty(aFiltro)
		If Select("__LOCXSF1") == 0
			ChkFile("SF1",.F.,"__LOCXSF1")
		Endif
		cPe	:=	LocxPE(49)
		If !Empty(cPe)
			cRetPe := Execblock(cPE,.F.,.F.,{"__LOCXSF1"})
			If ValType(cRetPe) <> "C"
		   	  	cRetPe := " "
		  	EndIf
		EndIf
		cCondicao2	:= "Ascan(aFiltro,{ |X| X[1]==__LOCXSF1->(F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO)}) > 0"
		cCondicao2   += if(empty(cRetPe),""," .AND. " + cRetPe)
		If ExistBlock('LOCXCOND')
			cCondicao2 := Execblock('LOCXCOND',.F.,.F.,{cCondicao2,"R"})
		EndIf
		If cPaisLoc == "RUS"
			MsgRun(STR0356,DESCREM,{||aRet := LocxF4("__LOCXSF1",IIf(!aFilTop[1],2,1),cWhile,cSeek,aCposF4,,DESCREM,cCondicao2,.T.,,,,,.F.,,,.T.)})
		Else
			MsgRun(STR0356,DESCREM,{||aRet := LocxF4("__LOCXSF1",IIf(!aFilTop[1],2,1),cWhile,cSeek,aCposF4,,DESCREM,cCondicao2,.T.,,,,,.F.)})
		Endif
	Else
		Help(" ",1,"A103F4")
		Return
	EndIf
Else
	Alert(STR0098 + " D2_REMITO, D2_SERIREM, D2_ITEMREM.")//"Para utilizar esta opcao se faz necessario que os seguintes campos estejam em uso e disponiveis:"
EndIf
If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf

If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return
EndIf
If cPaisLoc == "RUS"
	If Len(aRecs) > 1
		aChMoeda	:= {}
		for nI:=1 to Len(aRecs)
			__LOCXSF1->(MsGoto(aRecs[nI]))
				Aadd(aChMoeda,__LOCXSF1->F1_MOEDA)
				dmaxRem := max(dmaxRem,__LOCXSF1->F1_EMISSAO)
		Next nI
		aSort(aChMoeda,,,{ |x, y| x < y })
		for nI:=1 to Len(aChMoeda)-1
			if aChMoeda[nI]<>aChMoeda[nI+1]
				lCheckMoed	:= .F.
				Exit
			EndIf
		next nI
	Else
		dmaxRem := __LOCXSF1->F1_EMISSAO
	EndIf
EndIf
If !lCheckMoed
	Help("A100MOEDAREMITO",1,STR0403)	//Selected Records have different currency
EndIf
If lCheckMoed
	cItem	:=	StrZero(0,TamSx3('D1_ITEM')[1])
	nI:=0
	//³ Ponto de Entrada utilizado para nao carregar o aCols com pedidos Remision ³
	//³ caso a validacao retorne Falso                                            |
	cPe	:=	LocxPE(69)
	If !Empty(cPe)
		lRetPE69 := Execblock(cPE,.F.,.F.)
		If ValType(lRetPE69) <> "L"
			lRetPE69 := .T.
		EndIf
	EndIf
	nMoedRec:=MAFISRET(,'NF_MOEDA')
	nTaxaNF		:= MaFisRet(,'NF_TXMOEDA')
	If nTaxaNF ==0
		 nTaxaNF:=Recmoeda(dDatabase,M->F1_MOEDA)
	EndIf
	If lRetPE69
		CursorWait()			//OPTIMIZA
		For nI := 1 To Len(aRecs)
			__LOCXSF1->(MsGoTo(aRecs[nI]))
			If cPaisloc == "RUS"		//(18/07/18):Change moeda from remito invoice
				M->F1_EMISSAO := dmaxRem
				dDEmissao := dmaxRem
				M->F1_MOEDA := __LOCXSF1->F1_MOEDA
				nMoedaNF := __LOCXSF1->F1_MOEDA
				nMoedaCor := nMoedaNF
				MaFisRef("NF_MOEDA","MT100",__LOCXSF1->F1_MOEDA)
				M->F1_TXMOEDA:=RecMoeda(M->F1_EMISSAO,nMoedaNF)
				M->F1_CNORSUP	:= __LOCXSF1->F1_CNORSUP
				M->F1_CNEEBUY	:= __LOCXSF1->F1_CNEEBUY
				M->F1_CNORCOD	:= __LOCXSF1->F1_CNORCOD
				M->F1_CNORBR	:= __LOCXSF1->F1_CNORBR
				M->F1_CNEECOD	:= __LOCXSF1->F1_CNEECOD
				M->F1_CNEEBR	:= __LOCXSF1->F1_CNEEBR
				M->F1_CONUNI	:= __LOCXSF1->F1_CONUNI
				M->F1_F5QUID    := __LOCXSF1->F1_F5QUID
				M->F1_CNTID		:= __LOCXSF1->F1_CNTID
				M->F1_F5QDESC   := Iif(!EMPTY(__LOCXSF1->F1_F5QUID),Posicione("F5Q",1,XFILIAL("F5Q")+__LOCXSF1->F1_F5QUID,"F5Q_DESCR"),"")
			EndIf
			nTaxaPed		:= Iif(cTipConv=='1',Iif(__LOCXSF1->F1_TXMOEDA=0,RecMoeda(__LOCXSF1->F1_EMISSAO,__LOCXSF1->F1_MOEDA),__LOCXSF1->F1_TXMOEDA),RecMoeda(dDatabase,__LOCXSF1->F1_MOEDA))
			lMoedaDif	:=	__LOCXSF1->F1_MOEDA<>nMoedRec
			For nJ := 1 to Len(aFiltro)
				If aFiltro[nJ][1] == __LOCXSF1->(F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO)
					If lZeraCols
						aCols		:= {}
						lZeraCols	:= .F.
						MaFisClear()
						AAdd(aCols,Array(Len(aHeader)+1))
					Else
						If ( nCod > 0  .AND.  !Empty(aCOLS[Len(aCols)][nCod]))
							AAdd(aCols,Array(Len(aHeader)+1))
						EndIf
					EndIf
			 		aCols[Len(aCols)][Len(aHeader)+1]:=.F.
			 		DBSelectArea("SD1")
					SD1->(MsGoto(aFiltro[nJ][2]))
					DBSelectArea("SB1")
					SB1->(MsSeek(xFilial("SB1")+SD1->D1_COD))
					lPedido := .F.
					DBSelectArea("SC7")
					SC7->(dbSetOrder(1)) // C7_FILIAL+C7_NUM+C7_ITEM
					If SC7->(MsSeek(xFilial("SC7")+SD1->D1_PEDIDO+SD1->D1_ITEMPC,.F.))
						lPedido:=.T.
					EndIf
					cItem	:=	Soma1(cItem)
					nValAcols:=Len(aCols)
					//.. Atualiza o aRatCC com rateio do PC
					aHeaderSDE:=HeaderSDE(aHeaderSDE)
					RateioRemFac(aHeaderSDE,@aRatCC,cItem,aFiltro[nJ][2])

					If (nDescri  >  0  ,  aCOLS[Len(aCols)][nDescri ] := SD1->D1_DESCRI ,)
					If (nItemRem >  0  ,  aCOLS[Len(aCols)][nItemRem] := SD1->D1_ITEM   ,)
					If (nUm      >  0  ,  aCOLS[Len(aCols)][nUm     ] := SD1->D1_UM     ,)
					If (nSegum   >  0  ,  aCOLS[Len(aCols)][nSegum  ] := SD1->D1_SEGUM  ,)
					If (nCod     >  0  ,  aCOLS[Len(aCols)][nCod    ] := SD1->D1_COD	  ,)
					If (nSeriRem >  0  ,  aCOLS[Len(aCols)][nSeriRem] := SD1->D1_SERIE  ,)
					If (nLocal   >  0  ,  aCOLS[Len(aCols)][nLocal  ] := SD1->D1_LOCAL  ,)
					If (nQuant   >  0  ,  aCOLS[Len(aCols)][nQuant  ] := SD1->D1_QTDACLA,)
					If (nRemito  >  0  ,  aCOLS[Len(aCols)][nRemito ] := SD1->D1_DOC	  ,)
					If (nItem    >  0  ,  aCOLS[Len(aCols)][nItem   ] := cItem ,)
					If (nTes     >  0  ,  aCOLS[Len(aCols)][nTes    ] := SD1->D1_TES    ,)
					If (nCF      >  0  ,  aCOLS[Len(aCols)][nCF     ] := SD1->D1_CF     ,)
					If (nLOTEFOR >  0  ,  aCOLS[Len(aCols)][nLOTEFOR] := SD1->D1_LOTEFOR,)
					If (nLOTECTL >  0  ,  aCOLS[Len(aCols)][nLOTECTL] := SD1->D1_LOTECTL,)
					If (nNUMLOTE >  0  ,  aCOLS[Len(aCols)][nNUMLOTE] := SD1->D1_NUMLOTE,)
					If (nDTVALID >  0  ,  aCOLS[Len(aCols)][nDTVALID] := SD1->D1_DTVALID,)
					If (nProvEnt >  0  ,  aCOLS[Len(aCols)][nProvEnt] := SD1->D1_PROVENT,)
					If (nIPI     >  0  ,  aCOLS[Len(aCols)][nIPI    ] := SD1->D1_IPI    ,)
					If (nQtSegUm >  0  ,  aCOLS[Len(aCols)][nQtSegUm] := SD1->D1_QTSEGUM,)
					If (nConta   >  0  ,  aCOLS[Len(aCols)][nConta  ] := If(!Empty(SD1->D1_CONTA),SD1->D1_CONTA,SB1->B1_CONTA),)
					If (nCCusto  >  0  ,  aCOLS[Len(aCols)][nCCusto ] := If(!Empty(SD1->D1_CC),SD1->D1_CC,SB1->B1_CC),)
					If (nItConta >  0  ,  aCOLS[Len(aCols)][nItConta] := SD1->D1_ITEMCTA,)
					If (nClValor >  0  ,  aCOLS[Len(aCols)][nClValor] := SD1->D1_CLVL,)
					If (nRat     >  0  ,  aCOLS[Len(aCols)][nRat    ] := SD1->D1_RATEIO,)
					If (nPedido  >  0  ,  aCOLS[Len(aCols)][nPedido ] := SD1->D1_PEDIDO,)
			 		If (nItemPC  >  0  ,  aCOLS[Len(aCols)][nItemPC ] := SD1->D1_ITEMPC,)
			    	If (nFornece >  0  ,  aCOLS[Len(aCols)][nFornece] := SD1->D1_FORNECE,)
					If (nLojaForn>  0  ,  aCOLS[Len(aCols)][nLojaForn] := SD1->D1_LOJA,)
					If (nFDESC   >  0  ,  aCOLS[Len(aCols)][nFDESC  ] := SD1->D1_FDESC,)
					If (type("cCondicao") <> "U" .And. !Empty(__LOCXSF1->F1_COND), cCondicao := __LOCXSF1->F1_COND,)

					If cPaisLoc == "CHI"
						If (nFEPP    >  0  ,  aCOLS[Len(aCols)][nFEPP   ] := SD1->D1_FEPP   ,)
						If (nIE      >  0  ,  aCOLS[Len(aCols)][nIE     ] := SD1->D1_IE     ,)
					EndIf
					nTaxaNF		:= Iif(MaFisRet(,'NF_TXMOEDA')==0,Recmoeda(dDatabase,M->F1_MOEDA),MaFisRet(,'NF_TXMOEDA'))
					nTaxaPed		:= Iif(cTipConv=='1',Iif(__LOCXSF1->F1_TXMOEDA=0,RecMoeda(__LOCXSF1->F1_EMISSAO,__LOCXSF1->F1_MOEDA),__LOCXSF1->F1_TXMOEDA),RecMoeda(dDatabase,__LOCXSF1->F1_MOEDA))
					If nVUnit   >  0
						If SD1->D1_VUNIT <> 0
							If cPaisLoc == "BOL"
								nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,TAMSX3("D1_VUNIT")[2],nTaxaPed,nTaxaNF)
							ELSE
								nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
								If cPaisloc=="ARG" .AND. (SuperGetMV("MV_DESCSAI",.T.,'1')=='2') .and. Alltrim(aCfgNF[8]) == "NCC"
									nPrecio += (SD1->D1_VALDESC / SD1->D1_QUANT)
								EndIf
							endIf
						Else
							If ! Empty(SD1->D1_PEDIDO)
								nPrecio := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
							Else
								nPrecio := RetFldProd(SB1->B1_COD,"B1_UPRC")
								If M->F1_MOEDA<>1 .And. M->F1_TXMOEDA<>0
									nPrecio:=NoRound(nPrecio / M->F1_TXMOEDA,TamSX3("D1_VUNIT")[2])
								EndIf
							EndIf
						EndIf
						aCOLS[Len(aCols)][nVunit] := nPrecio
					EndIf
					If nTotal > 0
						IF SD1->D1_VUNIT <> 0
							If cPaisLoc == "BOL"
								nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,TAMSX3("D1_VUNIT")[2],nTaxaPed,nTaxaNF)
							Else
								nPrecio := xMoeda(SD1->D1_VUNIT,__LOCXSF1->F1_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
								If cPaisloc=="ARG" .AND. (SuperGetMV("MV_DESCSAI",.T.,'1')=='2') .and. Alltrim(aCfgNF[8]) == "NCC"
									nPrecio += (SD1->D1_VALDESC / SD1->D1_QUANT)
								EndIf
							EndIf
						ELSE
							IF .NOT. EMPTY(SD1->D1_PEDIDO)
								nPrecio := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,MAFISRET(,'NF_MOEDA'),M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
							ELSE
								nPrecio := RetFldProd(SB1->B1_COD,"B1_UPRC")
								If M->F1_MOEDA<>1 .And. M->F1_TXMOEDA<>0
									nPrecio:=NoRound(nPrecio / M->F1_TXMOEDA,TamSX3("D1_VUNIT")[2])
								EndIf
								aCOLS[Len(aCols)][nVunit] := nPrecio
							EndIf
						ENDIF
						aCOLS[Len(aCols)][nTotal] := (nPrecio * SD1->D1_QTDACLA)
						// Verificação para previnir diferença de centavos quando do retorno da função MaColsToFis
						If TamSx3("D1_TOTAL")[2] == 2
							nVlTotal := 0
							nDifRem := 0.01
							nVlTotal := Round((nPrecio * SD1->D1_QTDACLA),2)
							If ABS(nVlTotal - SD1->D1_TOTAL) == nDifRem
								nVlTotal := SD1->D1_TOTAL
							EndIf
							aCOLS[Len(aCols)][nTotal] := nVlTotal
						EndIf
					Endif
					If cPaisloc == "RUS"	//(19/07/18): value from items of remito invoice
						aCols[Len(aCols)][nBsImp1M] := SD1->D1_BSIMP1M
						aCols[Len(aCols)][nVlImp1M] := SD1->D1_VLIMP1M
						aCols[Len(aCols)][nTotalM] := SD1->D1_TOTALM
					EndIF
					IF cPaisloc == "ARG" .and. lWmsNew
						aCols[Len(aCols)][nServic] := SD1->D1_SERVIC
						aCols[Len(aCols)][nUbica] := SD1->D1_ENDER
					EndIF
					If nDesc > 0
						IF SD1->D1_VALDESC <> 0 .And. Iif(lValDesc, .T., !(SuperGetMv("MV_DESCSAI",,"1") == "1"))
							If SD1->D1_QTDACLA == SD1->D1_QUANT
								If lMoedaDif
									aCols[nValAcols][nDesc] :=xMoeda(SD1->D1_VALDESC,__LOCXSF1->F1_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
								Else
									aCols[nValAcols][nDesc] :=SD1->D1_VALDESC
								EndIf
							Else
								If lMoedaDif
									aCols[nValAcols][nDesc] :=xMoeda(SD1->D1_VALDESC*SD1->D1_QTDACLA/SD1->D1_QUANT,__LOCXSF1->F1_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
								Else
									aCols[nValAcols][nDesc] :=SD1->D1_VALDESC*SD1->D1_QTDACLA/SD1->D1_QUANT
								EndIf
							Endif
						Else
							If lPedido
								IF (cPaisLoc $ "ARG|PAR|URU|CHI|BOL")
									lMoedaDif := SC7->C7_MOEDA <> nMoedRec
									IF lMoedaDif
										nTaxaPed := iIF (SC7->C7_TXMOEDA <> 0 , SC7->C7_TXMOEDA, IIF(RecMoeda(SC7->C7_EMISSAO,SC7->C7_MOEDA) <> 0, RecMoeda(SC7->C7_EMISSAO,SC7->C7_MOEDA) , 1) )
									EndiF
								EndIf
								If SD1->D1_QTDACLA == SC7->C7_QUANT
									If lMoedaDif
										aCols[nValAcols][nDesc] :=xMoeda(SC7->C7_VLDESC,SC7->C7_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
									Else
								   		aCols[nValAcols][nDesc] :=SC7->C7_VLDESC
									EndIf
								Else
									If lMoedaDif
										If cPaisLoc == "ARG" .And. procname() == "SCMTOREM" .And.  Alltrim(SD1->D1_ESPECIE) == "RCN"
											aCols[nValAcols][nDesc] :=xMoeda((SC7->C7_VLDESC/SC7->C7_QUANT)*SD1->D1_QTDACLA ,SC7->C7_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
										Else
											aCols[nValAcols][nDesc] :=xMoeda(SC7->C7_VLDESC*SC7->C7_QUANT/SD1->D1_QTDACLA ,SC7->C7_MOEDA,nMoedRec,M->F1_EMISSAO,,nTaxaPed,nTaxaNF)
										Endif
									Else
										If cPaisLoc $ "ARG|BOL" .And. procname() == "SCMTOREM" .And.  Alltrim(SD1->D1_ESPECIE) == "RCN"
											aCols[nValAcols][nDesc] :=(SC7->C7_VLDESC/SC7->C7_QUANT) * SD1->D1_QTDACLA
										Else
											aCols[nValAcols][nDesc] :=SC7->C7_VLDESC*SC7->C7_QUANT/SD1->D1_QTDACLA
										Endif
									EndIf
								Endif
							EndIf
						EndIf
					Endif
					If nPorDesc	 > 0
						If SD1->D1_DESC <> 0
							aCOLS[Len(aCols)][nPorDesc ] := SD1->D1_DESC
						Else
							dbSelectArea("SC7")
							dbSetOrder(1)
							If SC7->(MsSeek(xFilial("SC7")+SD1->D1_PEDIDO+SD1->D1_ITEMPC,.F.))
								aCols[Len(aCols)][nPorDesc] := SC7->C7_DESC
							EndIf
						Endif
					Endif
					cPet := LocxPEt(35)
					If !Empty(cPet)
						ExecTemplate(cPEt,.F.,.F.,)
					EndIf
					cPe	:=	LocxPE(35)
					If !Empty(cPe)
						Execblock(cPE,.F.,.F.,)
					EndIf
					AEval(aHeader,{|x,y| If(aCols[nValAcols][y]==NIL,aCols[nValAcols][y]:=CriaVar(x[2]),) })	//OPTIMIZA...
					If cPaisLoc == "MEX"
						aAdd( aRecSD1 , SD1->(RecNo()) )
						lOtros := lOtros .Or. SD1->(D1_VALFRE + D1_DESPESA + D1_VALDESC + D1_SEGURO) <> 0
					Else		//...OPTIMIZA
						IIf(cPaisLoc == "COL" .And. nCF>0, cCFO := aCols[Len(aCols)][nCF],)
						MaColsToFis(aHeader,aCols,Len(aCols),"MT100",.T.)
						If cPaisLoc == "COL"
							LxVldCFCol(aCols, cCFO, Len(aCols), nCF)
						EndIf
						MafisAlt('IT_FRETE'		,SD1->D1_VALFRE		,Len(aCols))
						MafisAlt('IT_DESPESA'	,SD1->D1_DESPESA	,Len(aCols))
						MafisAlt('IT_DESCONTO'	,IIf(nDesc > 0,aCols[Len(aCols)][nDesc], SD1->D1_VALDESC)	,Len(aCols))
						MafisAlt('IT_SEGURO'	,SD1->D1_SEGURO		,Len(aCols))
					EndIf
					//#PORTUGAL#
					/*If cPaisLoc == "PTG"
						MafisAlt('IT_DESNTRB'	,SD1->D1_DESNTRB	,Len(aCols))
						MafisAlt('IT_TARA'		,SD1->D1_TARA		,Len(aCols))
					Endif*/
					nFrete   += SD1->D1_VALFRE
					nDespesa += SD1->D1_DESPESA
					nDescont += SD1->D1_VALDESC
					nSeguro  += SD1->D1_SEGURO
					//#PORTUGAL#
					/*If cPaisLoc == "PTG"
						nDesNTrb 	+= SD1->D1_DESNTRB
						nTara		+= SD1->D1_TARA
					Endif*/
					//(18/07/18):Value from items of remito invoice
					If cPaisloc == "RUS"
						aCols[Len(aCols)][nBsImp1M] := SD1->D1_BSIMP1M
						MafisAlt('IT_BASEIV1_C1',	SD1->D1_BSIMP1M,	Len(aCols))
						aCols[Len(aCols)][nVlImp1M] := SD1->D1_VLIMP1M
						MafisAlt('IT_VALIV1_C1'	,	SD1->D1_VLIMP1M,	Len(aCols))
						aCols[Len(aCols)][nTotalM] := SD1->D1_TOTALM
					EndIF
				EndIf
			Next nJ
		Next nI

		If cPaisLoc == "COL" .And. FunName() == "MATA101N" .And. SF1->(ColumnPos("F1_TPACTIV"))
			MaFisRef("NF_TPACTIV", "MT100", M->F1_TPACTIV)
		EndIf

		If Len(aRecSD1) > 0		//OPTIMIZA...
			MaColsToFis(aHeader,aCols,,"MT100",.T.)
			If lOtros
				For nI := 1 To Len(aRecSD1)
					SD1->(MsGoto(aRecSD1[nI]))
					MafisAlt('IT_FRETE'		,SD1->D1_VALFRE		,nI)
					MafisAlt('IT_DESPESA'	,SD1->D1_DESPESA	,nI)
					MafisAlt('IT_DESCONTO'	,IIf(nDesc > 0,aCols[nI][nDesc], SD1->D1_VALDESC)	,nI)
					MafisAlt('IT_SEGURO'	,SD1->D1_SEGURO		,nI)
				Next nI
			EndIf
		EndIf
		CursorArrow()			//...OPTIMIZA
	EndIf
	If cPaisLoc == "ARG"
		MaFisReprocess(2)
	EndIf
	// Atualizar pasta Gastos com base nos itens do Remito
	If nFrete > 0 .And. ValType(F1_FRETE) == "N"
		M->F1_FRETE := SF1->F1_FRETE + nFrete
	EndIf
	If nSeguro > 0	.And. ValType(F1_SEGURO) == "N"
		M->F1_SEGURO := SF1->F1_SEGURO + nSeguro
	EndIf
	If nDespesa > 0	.And. ValType(F1_DESPESA) == "N"
		M->F1_DESPESA := SF1->F1_DESPESA + nDespesa
	EndIf
	If nDescont > 0 .And. ValType(F1_DESCONT) == "N"
		M->F1_DESCONT := SF1->F1_DESCONT + nDescont
	EndIf
	//#PORTUGAL#
	/*If cPaisLoc == "PTG"
		If nDesNTrb > 0 .And. ValType(F1_DESNTRB) == "N"
			M->F1_DESNTRB := SF1->F1_DESNTRB + nDesNTrb
		EndIf
		If nTara > 0 .And. ValType(F1_TARA) == "N"
			M->F1_TARA := SF1->F1_TARA + nTara
		EndIf
	Endif*/
	Eval(bDoRefresh)
	oGetDados:obrowse:refresh()
	AtuLoadQt()
EndIf
If oTmpRemito <> Nil
	oTmpRemito:Delete()
	FreeObj(oTmpRemito)
	oTmpRemito := Nil
EndIf
RestArea(aArea)
Return
/*
Programa  ³PcoLancto Data ³  11/07/05
Desc.     ³rotina para contabilizacao no modulo sigapco
*/
Static Function PcoLancto(cAliasCab, cAliasDet,nRecnoCab,aRecnoItens,cProcesso,aItemInclProc,aItemExclProc,cProgram, lInclui, lDeleta, lRet)
Local nX		:= 0
Local aAreaCab	:= (cAliasCab)->(GetArea())
Local aAreaDet	:= (cAliasDet)->(GetArea())
//Local nPos		:= 0
//Local nPosItem	:= aScan(aHeader,{|x| AllTrim(x[2]) == IIf(cAliasCab == "SF2", "D2_ITEM", "D1_ITEM")})

DEFAULT lInclui	:= .F.
DEFAULT lDeleta	:= .F.
Default lRet	:= .T.

If !(cPaisLoc $ "MEX|COL|PER|EQU")
	dbSelectArea(cAliasCab)
	MsGoto(nRecnoCab)
	//Inicializa a gravacao dos lanç. do SIGAPCO
	PcoIniLan(cProcesso)
	dbSelectArea(cAliasDet)

	If cProcesso == "000306" .And. (aItemExclProc[1] == "02" .Or. aItemExclProc[2] == "04")
		For nX := 1 TO Len(aRecnoItens)
			MsGoto(aRecnoItens[nX,1])
			//por item (aItemInclProc[1])
			If !Empty(aItemInclProc[1])
				PcoDetLan(cProcesso,aItemInclProc[1],cProgram,lDeleta)
			EndIf
		Next nX
		dbSelectArea(cAliasCab)
		MsGoto(nRecnoCab)
		If !Empty(aItemInclProc[2])
			PcoDetLan(cProcesso,aItemInclProc[2],cProgram,lDeleta)
		EndIf
	Else
		If lInclui
			For nX := 1 TO Len(aRecnoItens)
				MsGoto(aRecnoItens[nX,1])
				//por item (aItemInclProc[1])
				If !Empty(aItemInclProc[1])
					PcoDetLan(cProcesso,aItemInclProc[1],cProgram)
				EndIf
			Next nX
			dbSelectArea(cAliasCab)
			MsGoto(nRecnoCab)
			//por total (aItemInclProc[2])
			If !Empty(aItemInclProc[2])
				PcoDetLan(cProcesso,aItemInclProc[2],cProgram)
			EndIf
		ElseIf lDeleta
			For nX := 1 TO Len(aRecnoItens)
				MsGoto(aRecnoItens[nX,1])
				//por item (aItemExclProc[1])
				If !Empty(aItemExclProc[1])
					PcoDetLan(cProcesso,aItemExclProc[1],cProgram, aItemExclProc[1]==aItemInclProc[1] )
				EndIf
			Next nX
			dbSelectArea(cAliasCab)
			MsGoto(nRecnoCab)
			//por total (aItemExclProc[2])
			If !Empty(aItemExclProc[2])
				PcoDetLan(cProcesso,aItemExclProc[2],cProgram, aItemExclProc[2]==aItemInclProc[2] )
			EndIf
		EndIf
	EndIf
Else
	If cProcesso $ "000306|000307" .And. (aItemExclProc[1] == "02" .Or. aItemExclProc[2] == "04")
		If !Empty(aItemInclProc[2]) //Lanzamiento para encabezado del documento
			PcoDetLan(cProcesso, aItemInclProc[2], cProgram, lDeleta)
		EndIf
	Else
		If lInclui
			If !Empty(aItemInclProc[2])
				PcoDetLan(cProcesso, aItemInclProc[2], cProgram)
			EndIf
		ElseIf lDeleta
			For nX := 1 TO Len(aCols)
				If !Empty(aItemExclProc[1])
					PcoDetLan(cProcesso, aItemExclProc[1], cProgram, aItemExclProc[1] == aItemInclProc[1])
				EndIf
			Next nX
			If !Empty(aItemExclProc[2])
				PcoDetLan(cProcesso,aItemExclProc[2], cProgram, aItemExclProc[2] == aItemInclProc[2])
			EndIf
		EndIf
	EndIf
EndIf

//³ Finaliza a gravacao dos lanç. do SIGAPCO            ³
PcoFinLan(cProcesso)
RestArea(aAreaDet)
RestArea(aAreaCab)
Return
/*
Programa  ³PcoCarregaLancto Data ³ 06/07/05
Desc.     ³Carregar array com os lanç do modulo sigaPco para
          ³alimentar array acfgnf para posterior uso PcoLancto()
*/
Static Function PcoCarregaLancto(nTipo, nOpcx)
//Retorna array com 03 posicoes
//onde 1a. pos. = processo_pco (lancto padrao do pco)
//QUANDO ROTINA FOR INCLUSAO
//     2a. pos. = array com na pos. 1 - item processo (detalhe-item)
//                                     pos. 2 - item processo  (cabeca-total)
//     3a. pos. = nome do programa que gerou o lancto no pco
//QUANDO ROTINA FOR EXCLUSAO
//     4a. pos. = array com na pos. 1 - item processo (EXCLUSAO detalhe-item)
//                                     pos. 2 - item processo  (EXCLUSAO cabeca-total)
Local aPcoLanc := {NIL/*processo_pco*/, NIL /*Inclusao*/, NIL/*nome do programa*/, NIL/*Exclusao*/}
	Do Case
		//Nota de Venta - Especificos EQUADOR - RCTI - Australia - Adiantamento - Traslado - Mexico
		Case nTipo==1 .Or. nTipo == 17 .OR. nTipo == 18 .OR. nTipo == 19 .OR. nTipo == 21
			//mata467
		    aPcoLanc[1] := "000300"
		    aPcoLanc[3] := "MATA467N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==2
			//mata465
			aPcoLanc[1] := "000308"
		    aPcoLanc[3] := "MATA465N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==3
			//mata465
			aPcoLanc[1] := "000308"
		    aPcoLanc[3] := "MATA465N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==4
			//mata465
			aPcoLanc[1] := "000309"
		    aPcoLanc[3] := "MATA465N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==5
			//mata465
			aPcoLanc[1] := "000309"
		    aPcoLanc[3] := "MATA465N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==6
			//mata466
			aPcoLanc[1] := "000310"
		    aPcoLanc[3] := "MATA466N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==7 .OR. nTipo==22
			//mata466
			aPcoLanc[1] := "000311"
		    aPcoLanc[3] := "MATA466N"
			aPcoLanc[2] := {"03", "04"}
			aPcoLanc[4] := {"03", "04"}
		Case nTipo==8
			//mata466
			aPcoLanc[1] := "000311"
		    aPcoLanc[3] := "MATA466N"
			aPcoLanc[2] := {"01", "02"}
			aPcoLanc[4] := {"01", "02"}
		Case nTipo==9 .OR. nTipo==23
			//mata466
			aPcoLanc[1] := "000310"
		    aPcoLanc[3] := "MATA466N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		Case nTipo==10 .Or. nTipo == 20 //Adiantamento - Peru
			//mata101
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA101N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		//Beneficiamento
		Case nTipo == 11
			//Mata467
		    aPcoLanc[1] := "000300"
		    aPcoLanc[3] := "MATA467N"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"05", "07"}
		Case nTipo == 12
			//Mata101
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA101N"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"06", "08"}
		Case nTipo	==	13
			//MATA119
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA101N"
   			aPcoLanc[2] := {"09", "11"}
			aPcoLanc[4] := {"10", "12"}
		Case nTipo	==	14
			//MATA116
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA101N"
			aPcoLanc[2] := {"13", "15"}
			aPcoLanc[4] := {"14", "16"}
		Case nTipo==15
			//mata463
			aPcoLanc[1] := "000312"
		    aPcoLanc[3] := "MATA463N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
	     //Remitos (facturacion)
		Case nTipo == 50
			//Mata462
		    aPcoLanc[1] := "000301"
		    aPcoLanc[3] := "MATA462N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 51
			//Mata462D Proprio
			aPcoLanc[1] := "000302"
		    aPcoLanc[3] := "MATA462DN"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 52
			//Mata462
		    aPcoLanc[1] := "000301"
		    aPcoLanc[3] := "MATA462N"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"06", "08"}
		Case nTipo == 53
			//Mata462 Doc nao proprio
			aPcoLanc[1] := "000302"
		    aPcoLanc[3] := "MATA462DN"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 54 // Remito de transf. Saida
			//Mata462
			aPcoLanc[1] := "000304"
		    aPcoLanc[3] := "MATA462TN"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"06", "08"}
		Case nTipo==55
			//mata462G
		    aPcoLanc[1] := "000300"
		    aPcoLanc[3] := "MATA462G"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"01", "03"}
		 //Remitos (Compras)
		Case nTipo == 60
			//Mata102
			aPcoLanc[1] := "000307"
		    aPcoLanc[3] := "MATA102N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 61
			//Mata102
			aPcoLanc[1] := "000305"
		    aPcoLanc[3] := "MATA102DN"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 62
			//Mata102
			aPcoLanc[1] := "000307"
		    aPcoLanc[3] := "MATA102N"
			aPcoLanc[2] := {"05", "07"}
			aPcoLanc[4] := {"06", "08"}
		Case nTipo == 63
			//Retorno SIMBOLICO
			aPcoLanc[1] := "000303"
		    aPcoLanc[3] := "MATA462R"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo == 64
			aPcoLanc[1] := "000304"
		    aPcoLanc[3] := "MATA462TN"
	   		aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
		Case nTipo==65
			//mata103N
			aPcoLanc[1] := "000306"
		    aPcoLanc[3] := "MATA103N"
			aPcoLanc[2] := {"01", "03"}
			aPcoLanc[4] := {"02", "04"}
	EndCase
Return aPcoLanc
/*
Descri‡…o ³ Utilizacao de menu Funcional
Retorno   ³Array com opcoes da rotina.
Parametros³Parametros do array a Rotina:
          ³1. Nome a aparecer no cabecalho
          ³2. Nome da Rotina associada
          ³3. Reservado
          ³4. Tipo de Transa‡„o a ser efetuada:
          ³	  1 - Pesquisa e Posiciona em um Banco de Dados
          ³    2 - Simplesmente Mostra os Campos
          ³    3 - Inclui registros no Bancos de Dados
          ³    4 - Altera o registro corrente
          ³    5 - Remove o registro corrente do Banco de Dados
          ³5. Nivel de acesso
          ³6. Habilita Menu Funcional
*/
Static Function MenuDef()
Local aAddOpc := {}
cFunName	:= IIf(Type("cFunName")=="U",Upper(Alltrim(FunName())),cFunName)
Private aRotina := {}
DBSELECTAREA("SF1")
aAdd(aRotina,{STR0022,"LocxPesq(bFilBrw,1)"	, 0 , 1 , 0 , .F. })  		  // "Pesquisar"
aAdd(aRotina,{STR0023,"LocxDlgNF(aCfgNF,2)"	, 0 , 2 , 0 , NIL })	      // "Visualizar"
If !(cFunName$ "MATA103CG/MATA103CF/MATA462G")
	aAdd(aRotina,{STR0024,"LocxDlgNF(aCfgNF,3,bFilBrw)"	, 0 , 3 , 0 , NIL})  // "Incluir"
EndIf

If (cFunName$ "MATA462G")
	aAdd(aRotina,{"Cancelar","LocxDlgNF(aCfgNF,4,bFilBrw)",0,4,0,NIL})
	aAdd(aRotina,{"Imprimir","LocxDlgNF(aCfgNF,5,bFilBrw)",0,5,0,NIL})
EndIf

If ((cFunName $ "MATA467N") .And. (cPaisLoc == "RUS"))
	aAddOpc := {{STR0368, "RU09T02Add(.T.)", 0, 4, 0, Nil},;
			{STR0369, "RU09T02act("+STR(MODEL_OPERATION_VIEW)+")", 0, 2, 0, Nil},;
			{STR0370, "RU09T02act("+STR(MODEL_OPERATION_UPDATE)+")", 0, 1, 0, Nil},;
			{STR0371, "RU09T02act("+STR(MODEL_OPERATION_DELETE)+")", 0, 1, 0, Nil}}

	aAdd(aRotina,{STR0373, aAddOpc, 0, MODEL_OPERATION_VIEW})
	aAdd(aRotina,;
		{STR0414, {;
        	{STR0368	, "RU05D01_17_CreateULCD(1,"+STR(MODEL_OPERATION_INSERT)+")", 0, 1}; // Add
        	, {STR0369	, "RU05D01_17_CreateULCD(1,"+STR(MODEL_OPERATION_VIEW)+")"	, 0, 1}; // View
        	, {STR0371	, "RU05D01_17_CreateULCD(1,"+STR(MODEL_OPERATION_DELETE)+")", 0, 1}; // Delete
        }, 0, MODEL_OPERATION_VIEW};
	)
	aAdd(aRotina,{STR0387, "RU05R01()", 0, 6, 0, NIL})
Endif

If ((cFunName $ "MATA101N") .And. (cPaisLoc == "RUS"))
	aAddOpc := {{STR0368, "addF37ComInv(.T.)", 0, 4, 0, Nil},; //Add
			{STR0369, "RU09T03act("+STR(MODEL_OPERATION_VIEW)+")", 0, 2, 0, Nil},; 		//View
			{STR0370, "RU09T03act("+STR(MODEL_OPERATION_UPDATE)+")", 0, 1, 0, Nil},; 	//Change
			{STR0371, "RU09T03act("+STR(MODEL_OPERATION_DELETE)+")", 0, 1, 0, Nil}}		//Delete

	aAdd(aRotina,{STR0373, aAddOpc, 0, MODEL_OPERATION_VIEW})
Endif
Return(aRotina)
/*
Programa  ³LXDOCORI  Data ³ 04/10/2006
Desc.     ³Mostra as faturas que serao amarradas ao documento sendo di-
          ³gitado (devolucao)
Parametros³Parametros do array a Rotina:
          ³1. Si es Chile y se selecciono como doc ori NDC a la NCC.
*/
Function LxDocOri(lNDCChi)
Local aArea    		:= GetArea()
Local aSF2			:= SF2->(GetArea())
Local aSD2			:= SD2->(GetArea())
Local aCposF4		:= {}
Local aRecs    		:= {}
Local aRet     		:= {}
Local nI 			:= 0
//Local nJ 			:= 0
//Local nPosTotal		:= 0
//Local nPosTES		:= 0
//Local nPosQuant		:= 0
//Local nPosQtSegun	:= 0
//Local nPosValDesc	:= 0
Local nTaxaNf		:= 0
//Local nTaxaPed		:= 0
//Local nPorDesc		:= 0
Local nUm			:= 0
Local nSegUm		:= 0
Local nCod			:= 0
Local nLocal		:= 0
Local nQuant		:= 0
Local nNfOri		:= 0
Local nSeriOri		:= 0
Local nItemOri		:= 0
Local nItem			:= 0
//Local Tes			:= 0
Local nCf			:= 0
Local nLoteCtl		:= 0
Local nNumLote		:= 0
Local nDtValid		:= 0
Local nVunit		:= 0
Local nTotal		:= 0
Local nQTSegum		:= 0
Local nConta		:= 0
Local nItemCta   	:= 0
Local nCCusto		:= 0
Local nDesc			:= 0
Local nValDesc		:= 0
Local nProvEnt 		:= 0
Local nClVl			:= 0
Local nForneD1		:= 0
Local nLojaD1		:= 0
Local nUniaduD1 	:= 0
Local nUsdaduD1 	:= 0
Local nValaduD1 	:= 0
Local nCanaduD1 	:= 0
Local nFraccaD1 	:= 0
Local nNICOD1	 	:= 0
//Local cCampo 		:= ""
Local cCondicao 	:= ""
Local cItem			:= ""
Local cTipoDoc 		:= ""
Local cCliFor		:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_FORNECE,M->F2_CLIENTE)
Local cLoja  		:= IIf(aCfgNF[SAliasHead]=="SF1",M->F1_LOJA,M->F2_LOJA)
Local cSeek  		:= ""
Local cWhile 		:= ""
Local cAliasCab		:= ""
Local cAliasItem	:= ""
Local cAliasTRB		:= ""
Local cQuery		:= ""
//Local cDoc			:= ""
//Local cSerDoc		:= ""
Local cFilSD		:= ""
//Local cTipConv		:= GetNewPar("MV_ALTTXNF",'1')
Local lLxDOrig		:= ExistBlock( "LXDORIG" )
Local lFiltroDoc	:= ExistBlock( "LxDocOri" )
Local lDescDVIt		:= .T.
Local lD2_PROVENT	:= .F.
Local cFilSB1		:= xFilial("SB1")
Local cFilSD2		:= xFilial("SD2")
Local cFilSF4		:= xFilial("SF4")
Local cDessai		:= SuperGetMV("MV_DESCSAI",.T.,'1')
Local cCFDUso		:= Alltrim(GetMv("MV_CFDUSO", .T., "1"))
Local aAreaSF4		:= {}
Local cCentavos		:= Iif(nMoedaNF==1,"MV_CENT",("MV_CENT"+AllTrim(Str(nMoedaNF))))
//Local cCtrl			:= CHR(13) + CHR(10)
Local lUUID			:= cPaisLoc == "MEX" .and. aCfgNF[SnTipo] == 4 .and. funname()=="MATA465N" .And. cCFDUso <> "0"// Activa solo para México de lo contrario presentara comportamiento normal
//Local nPosUUID		:= 0
Local cFunName		:= FunName()
Local cCFO			:= ""
Local lAutTES		:= SuperGetMV("MV_AUTTES", .F., .T.) //Parametro que indica activacion de TES automatizada
Local aRecOri		:= {}
//Local cItemAux		:= ""
Local nItemAux		:= 0
Local nPosDocOri	:= 0
Private aFiltro		:= {}
//Private aFilUUID   := {}
Private cCondUUID  := ""
Default lNDCChi := .F.
If GetNewPar("MV_DESCDVI",.T.) == .F. .And. cPaisloc=="MEX" .And. AllTrim(cEspecie) <> "NDE"    // Soma o valor do desconto ao item
	lDescDVIt:=.F.
EndIf

If cPaisLoc == "COL"
	If !LxVldEncC(aCfgNF,cFunName)
		Return .F.
	EndIf
Else
	If Empty(cCliFor) .OR. Empty(cLoja)
		Aviso(cCadastro,STR0094,{STR0021}) //"Llene los datos del encabezado."###"OK"
		Return
	EndIf
EndIf

For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D1_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SEGUM"
			nSegUm   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NFORI"
			nNfOri  := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_SERIORI"
			nSeriOri := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMORI"
			nItemOri := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTEFOR"
			nLoteFor := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VUNIT"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CC"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VALDESC"
			nValDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_DESC"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_PROVENT"
			nProvEnt := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_ITEMCTA"
			nItemCta := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CLVL"
			nClVl := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FORNECE"
			nForneD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_LOJA"
			nLojaD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_UNIADU"
			nUniaduD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_USDADU"
			nUsdaduD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_VALADU"
			nValaduD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_CANADU"
			nCanaduD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_FRACCA"
			nFraccaD1 := nI
		Case  Alltrim(aHeader[nI][2]) == "D1_NICO"
			nNICOD1 := nI
		Case  cPaisLoc == "RUS" .And. Alltrim(aHeader[nI][2]) == "D1_TOTALM"
			nTotalM		:= nI
		Case cPaisLoc == "RUS" .And.  Alltrim(aHeader[nI][2]) == "D1_FDESC"
			nFdesc		:= nI
		Case cPaisLoc == "RUS" .And.  Alltrim(aHeader[nI][2]) == "D1_DESCRI"
			nDescri		:= nI
	Endcase
Next nI
cAliasCab	:= "SF2"
cAliasItem	:= "SD2"
SX3->(DbSetOrder(1))
SX3->(DbSeek(cAliasCab))
While !SX3->(EOF()) .AND. SX3->X3_ARQUIVO == cAliasCab
	If SX3->X3_BROWSE == "S" .AND. cNivel >= SX3->X3_NIVEL
		AAdd(aCposF4,SX3->X3_CAMPO)
	Endif
	SX3->(DbSkip())
EndDo
If aCfgNF[SnTipo] == 4 .OR. aCfgNF[SnTipo] == 5 .OR. aCfgNF[SnTipo] == 53 .OR. aCfgNF[SnTipo] == 51
	// Se for Remito de devolucao (MATA462DN), seleciona apenas os remitos (F2_TIPODOC = "50"),
	//senao, seleciona as faturas (F2_TIPODOC = "01")
	If aCfgNF[SnTipo] == 53 .OR. aCfgNF[SnTipo] == 51		// Remito de Devolucao - MATA462DN (51=formulario proprio e 53=formulario nao proprio)
		cTipoDoc	:= "'50'"
	ElseIf lNDCChi
		cTipoDoc	:= "'02'"
	Else
		cTipoDoc	:= "'01'"
	EndIf

	cSeek  		:= "'" + xFilial(cAliasCab)+cCliFor+cLoja + "'"
	cWhile 		:= "SF2->(!EOF()) .AND. SF2->(F2_FILIAL+F2_CLIENTE+F2_LOJA)== " + cSeek
	cCondicao	:= "Ascan(aFiltro,SF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_TIPODOC)) > 0"
	cItem		:= aCols[Len(aCols),nItem]

	cAliasTRB := GetNextAlias()
	If !lUUID
		cQuery := "select distinct D2_FILIAL,D2_DOC,D2_SERIE,D2_CLIENTE,D2_LOJA,D2_TIPO,D2_TIPODOC,D2_ITEM"
		cQuery += " from " + RetSqlName("SD2") + " SD2 where "
		cQuery += " D2_FILIAL ='" + xFilial("SD2") + "'"
		cQuery += " and D2_CLIENTE = '" + cCliFor + "'"
		cQuery += " and D2_LOJA = '" + cLoja + "'"
		cQuery += " and D2_TIPODOC in (" + cTipoDoc + ")"
		cQuery += " and D2_QUANT > D2_QTDEDEV"
		cQuery += " and SD2.D_E_L_E_T_ = ' ' "
		If cPaisLoc == "RUS"
			cQuery += " and SD2.D2_EMISSAO <=  '"+ DTOS(M->F1_EMISSAO) + "' "
		EndIf
	Else
		cQuery := " SELECT DISTINCT SD2.D2_FILIAL, SD2.D2_DOC, SD2.D2_SERIE, SD2.D2_CLIENTE, SD2.D2_LOJA, SD2.D2_TIPO, SD2.D2_TIPODOC, SD2.D2_ITEM,SF2.F2_UUID "
		cQuery += " FROM " + RetSqlName("SD2") + " SD2"
		cQuery += " JOIN "+RetSqlName("SF2")+" SF2"
		cQuery += " ON SF2.F2_DOC = SD2.D2_DOC"
		cQuery += " AND SF2.F2_SERIE = SD2.D2_SERIE"
		cQuery += " AND SF2.F2_CLIENTE = SD2.D2_CLIENTE"
		cQuery += " AND SF2.F2_LOJA = SD2.D2_LOJA"
		cQuery += " AND SF2.F2_CLIENTE = '" + cCliFor + "'"
		cQuery += " AND SF2.F2_LOJA = '" + cLoja + "'"
		cQuery += " AND SD2.D2_QUANT > D2_QTDEDEV"
		cQuery += " AND SF2.F2_UUID <> ''"
		cQuery += " AND SD2.D2_FILIAL ='" + xFilial("SD2") + "'"
		cQuery += " AND SF2.D_E_L_E_T_ = ''"
		cQuery += " AND SD2.D_E_L_E_T_ = ''"
	EndIf

	//³Para Portugal quando se tratar de devolucao de Guia de Transporte, considera tambem  ³
	//³as Guias de Remessas ainda nao faturadas.                                            ³
	//#PORTUGAL#
	/*If cPaisLoc == "PTG" .and. ( '50'$cTipoDoc )
		cQuery += "UNION "
		cQuery += "SELECT DISTINCT D2_FILIAL,D2_DOC,D2_SERIE,D2_CLIENTE,D2_LOJA,D2_TIPO,D2_TIPODOC,D2_ITEM "
		cQuery += "FROM " + RetSqlName("SD2") + " SD2 WHERE "
		cQuery += " D2_FILIAL ='" + xFilial("SD2") + "' "
		cQuery += "AND D2_CLIENTE = '" + cCliFor + "' "
		cQuery += "AND D2_LOJA = '" + cLoja + "' "
		cQuery += "AND D2_TIPODOC = '55' "
		cQuery += "AND D2_QUANT > D2_QTDEDEV "
		cQuery += "AND D2_DOC NOT IN ( "

		//³Sub-query para desconsiderar as Guias de Remessas faturadas ³
		cQuery += "SELECT D2_REMITO "
		cQuery += "FROM " + RetSqlName("SD2") + " SD2NF WHERE "
		cQuery += "D2_FILIAL ='" + xFilial("SD2") + "' "
		cQuery += "AND D2_CLIENTE = '" + cCliFor + "' "
		cQuery += "AND D2_LOJA = '" + cLoja + "' "
		cQuery += "AND D2_REMITO <> ' ' "
		cQuery += "AND SD2NF.D_E_L_E_T_ = ' ' ) "
    EndIf*/

	If lFiltroDoc
		cQuery := ExecBlock( "LxDocOri", .F., .F., { cQuery } )
	EndIf
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTRB,.F.,.T.)

	If lUUID
		LxUUIDRel(aCols, lUUID, @aFiltro, @aRet, nNFOri, nItemOri, cAliasTRB, cAliasCab, cWhile, cSeek, aCposF4, cTipoDoc, cCondicao)
    Else
		DbSelectArea(cAliasTRB)
		While (cAliasTRB)->(!Eof())
			nI := Ascan(aCols,{|x| x[nNFORI] == (cAliasTRB)->D2_DOC .AND. x[nItemOri] == (cAliasTRB)->D2_ITEM .AND. !x[Len(x)]})
			If nI == 0
				Aadd(aFiltro, (cAliasTRB)->D2_FILIAL + (cAliasTRB)->D2_DOC + (cAliasTRB)->D2_SERIE + (cAliasTRB)->D2_CLIENTE + (cAliasTRB)->D2_LOJA + (cAliasTRB)->D2_TIPODOC)
			Endif
			(cAliasTRB)->(DbSkip())
		EndDo
		(cAliasTRB)->(DbCloseArea())
	EndIf
Else
	Return
EndIf
If !Empty(aFiltro) .And. !lUUID
	aRet := LocxF4(cAliasCab,2,cWhile,cSeek,aCposF4,,IIf(cTipoDoc =="'50'",GetDescRem(),Iif(cTipoDoc =="'02'", STR0124, STR0223)),cCondicao,.T.,,,,,.F.)  // Retorn
ElseIf Empty(aFiltro)
	Help(" ",1,"A103F4")
	Return
EndIf
If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf
If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return
EndIf
SD2->(DbSetOrder(3))
cFilSD := cFilSD2
ProcRegua(Len(aRecs))

lD2_PROVENT	:=	cPaisLoc == "ARG"
For nI := 1 To Len(aRecs)
	SF2->(MsGoTo(aRecs[nI]))
	SD2->(DbSeek(cFilSD + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA))
	IncProc(STR0244 + "(" + SF2->F2_DOC + ")")
	While SD2->D2_FILIAL == cFilSD .AND. SD2->D2_DOC == SF2->F2_DOC .AND. SD2->D2_SERIE == SF2->F2_SERIE .AND. SD2->D2_CLIENTE == SF2->F2_CLIENTE .AND. SD2->D2_LOJA == SF2->F2_LOJA
		If SD2->D2_QUANT > SD2->D2_QTDEDEV
        	If Ascan(aCols,{|x| x[nNFORI] == SD2->D2_DOC .AND. x[nItemOri] == SD2->D2_ITEM .AND. !x[Len(x)]}) == 0
				nLenAcols := Len(aCols)
				If !Empty(aCols[nLenAcols,nCod])
					AAdd(aCols,Array(Len(aHeader)+1))
					nLenAcols := Len(aCols)
					cItem := Soma1(cItem)
				Endif
			 	aCols[nLenAcols][Len(aHeader)+1]:=.F.
				SB1->(MsSeek(cFilSB1+SD2->D2_COD))
				If (nUm      >  0  ,  aCOLS[nLenAcols][nUm     ] := SD2->D2_UM	,)
				If (nSegUm   >  0  ,  aCOLS[nLenAcols][nSegUm  ] := SB1->B1_SEGUM,)
				If (nCod     >  0  ,  aCOLS[nLenAcols][nCod    ] := SD2->D2_COD,)
				If cPaisLoc == "RUS"
					If (nDescri  >  0  ,  aCOLS[nLenAcols][nDescri ] := SD2->D2_DESCRI,)
					If (nFdesc   >  0  ,  aCOLS[nLenAcols][nFdesc  ] := SD2->D2_FDESC,)
				EndIf
				If (nLocal   >  0  ,  aCOLS[nLenAcols][nLocal  ] := SD2->D2_LOCAL,)
				If (nNfOri   >  0  ,  aCOLS[nLenAcols][nNfOri  ] := SD2->D2_DOC,)
				If (nSeriOri >  0  ,  aCOLS[nLenAcols][nSeriOri] := SD2->D2_SERIE,)
				If (nItemOri >  0  ,  aCOLS[nLenAcols][nItemOri] := SD2->D2_ITEM,)
				If (nItem    >  0  ,  aCOLS[nLenAcols][nItem   ] := cItem,)
				If (nConta   >  0  ,  aCOLS[nLenAcols][nConta  ] := SD2->D2_CONTA,)
	   			If (nCCusto  >  0  ,  aCOLS[nLenAcols][nCCusto ] := SD2->D2_CCUSTO,)
			   	If (nItemCta >  0  ,  aCOLS[nLenAcols][nItemCta] := SD2->D2_ITEMCC,)
			   	If (nClVl    >  0  ,  aCOLS[nLenAcols][nClVl]  	:= SD2->D2_CLVL,)
				If (nLoteCtl >  0  ,  aCOLS[nLenAcols][nLoteCtl] := SD2->D2_LOTECTL,)
				If (nNumLote >  0  ,  aCOLS[nLenAcols][nNumLote] := SD2->D2_NUMLOTE,)
				If (nDtValid >  0  ,  aCOLS[nLenAcols][nDtValid] := SD2->D2_DTVALID,)
				If (nQtSegUm >  0  ,  aCOLS[nLenAcols][nQtSegUm] := SD2->D2_QTSEGUM,)
				If (nForneD1 >  0  ,  aCOLS[nLenAcols][nForneD1] := SD2->D2_CLIENTE,)
				If (nLojaD1  >  0  ,  aCOLS[nLenAcols][nLojaD1]	 := SD2->D2_LOJA,)
				If (nUniaduD1 > 0  ,  aCOLS[nLenAcols][nUniaduD1]:= SD2->D2_UNIADU,)
				If (nUsdaduD1 > 0  ,  aCOLS[nLenAcols][nUsdaduD1]:= SD2->D2_USDADU,)
				If (nValaduD1 > 0  ,  aCOLS[nLenAcols][nValaduD1]:= SD2->D2_VALADU,)
				If (nCanaduD1 > 0  ,  aCOLS[nLenAcols][nCanaduD1]:= SD2->D2_CANADU,)
				If (nFraccaD1 > 0  ,  aCOLS[nLenAcols][nFraccaD1]:= SD2->D2_FRACCA,)
				If (nNICOD1 > 0    ,  aCOLS[nLenAcols][nNICOD1]	 := SD2->D2_NICO,)
				nQtdeDev := SD2->D2_QUANT - SD2->D2_QTDEDEV
				If nQuant > 0
					aCols[nLenAcols,nQuant] := nQtdeDev
				Endif
				If nQtSegUm > 0
					aCols[nLenAcols,nQtSegUm] := ConvUm(SD2->D2_COD,nQtdeDev,0,2)
				Endif
				If cPaisLoc == "RUS"
					If Empty(cCondicao) .OR. RUXXTS05()
						M->F1_F5QUID	:= SF2->F2_F5QUID
						M->F1_CNTID 	:= SF2->F2_CNTID
						M->F1_F5QDESC   := Iif(!EMPTY(SF2->F2_F5QUID),Posicione("F5Q",1,XFILIAL("F5Q")+SF2->F2_F5QUID,"F5Q_DESCR"),"")
						M->F1_CNORSUP	:= SF2->F2_CNORVEN
						M->F1_CNEEBUY	:= SF2->F2_CNEECLI
						M->F1_CNORCOD	:= SF2->F2_CNORCOD
						M->F1_CNORBR	:= SF2->F2_CNORBR
						M->F1_CNEECOD	:= SF2->F2_CNEECOD
						M->F1_CNEEBR	:= SF2->F2_CNEEBR
						MaFisAlt("NF_MOEDA",SF2->F2_MOEDA)
						M->F1_MOEDA 	:= SF2->F2_MOEDA
						nMoedaNF		:= SF2->F2_MOEDA
						nMoedaCor		:= SF2->F2_MOEDA
						MaFisAlt("NF_TXMOEDA",SF2->F2_TXMOEDA)
						M->F1_TXMOEDA	:= SF2->F2_TXMOEDA
						M->F1_CONUNI	:= SF2->F2_CONUNI
						cCondicao	:= SF2->F2_COND
					EndIf
				EndIf
				If nTES <> 0
					SF4->(DbSetOrder(1))
					If SF4->(MsSeek(cFilSF4+SD2->D2_TES)) .AND. !Empty(SF4->F4_TESDV)
						aCols[nLenAcols][nTES] := SF4->F4_TESDV
						cCFO := Space(Len(SF4->F4_CF))
						If nCf > 0
							If cPaisLoc <> "COL"
								aAreaSF4 := SF4->(GetArea())
								cCFO := Posicione("SF4",1,xFilial("SF4")+SF4->F4_TESDV,"F4_CF")
								RestArea(aAreaSF4)
								aCols[nLenAcols][nCf] := cCFO
							Else
								cCFO := xObtCFOCol(lAutTES, cCliFor, cLoja, SD2->D2_COD, SF4->F4_TESDV, aHeader, aCols, nLenAcols, nCf, nTes, .F.)
							EndIf
						EndIf
					Endif
				EndIf
				If cPaisloc == "RUS" .And. nCf > 0
					aCols[nLenAcols][nCf] := SD2->D2_CF
				Endif
				nTaxaNF := MaFisRet(,'NF_TXMOEDA')
				nTaxaNF := Iif(nTaxaNF == 0,Recmoeda(dDatabase,M->F1_MOEDA),nTaxaNF)
				If (SD2->D2_DESC > 0 .OR. SD2->D2_DESCON > 0) .AND. lDescDVIt
					If SD2->D2_PRUNIT <> SD2->D2_PRCVEN .And. SD2->D2_PRUNIT > 0
						If !(cPaisLoc $ "ARG|COL|PER|VEN|MEX|CHI") .OR. (cPaisLoc $ "COL|PER|VEN|MEX" .AND. cDessai == '2') //ARG|
							nPrecio := xMoeda(SD2->D2_PRUNIT,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
						ElseIf cPaisLoc $ "ARG" 	.AND. cDessai == '2'
							nPrecio := ( xMoeda(SD2->D2_PRCVEN,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF) + (SD2->D2_DESCON / SD2->D2_QUANT) )
						ElseIf cPaisLoc $ "ARG|COL|PER|VEN|MEX|CHI" .and. cDessai = '1'
							nPrecio := xMoeda(SD2->D2_PRCVEN,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
						Endif
					Else
	  				    If (cPaisLoc == "ARG" .and. cDessai == '2')
							nPrecio := Round(xMoeda(((SD2->D2_TOTAL + SD2->D2_DESCON)/nQtdeDev),SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF),SuperGetMV(cCentavos,.F.,0))
						Else
		  				    nPrecio := xMoeda(SD2->D2_PRCVEN,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
		  				    IF (cDessai == '2' .and. cPaisLoc $ "ARG|COL|PER|VEN|MEX") .or. !(cPaisLoc $ "ARG|PER|COL|VEN|MEX")
		  				    	If cPaisLoc <> "ARG"
		  				    		nPrecio += ((xMoeda(SD2->D2_DESCON,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF))/nQtdeDev)
		  				    	Else
		  				    		nPrecio += Round(((xMoeda(SD2->D2_DESCON,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF))/nQtdeDev),SuperGetMV(cCentavos,.F.,0))
		  				    	EndIf
		  				    Endif
						Endif
	  				EndIf
				Else
					nPrecio := xMoeda(SD2->D2_PRCVEN,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
				Endif
				If nVUnit > 0
					aCols[nLenAcols,nVUnit] := nPrecio
				EndIf
				If nTotal > 0
					If !(cPaisLoc $ "ARG|COL") .or. ((cPaisLoc $ "ARG|COL") .and. cDessai == '2')
						If (cPaisLoc $ "MEX|PER" .And. cDessai == '1') .And. cFunName $ "MATA465N"
							aCols[nLenAcols][nTotal] := SD2->D2_TOTAL
						Else
							If cPaisLoc $ "MEX|COL|PER"
								aCols[nLenAcols][nTotal] := NoRound(nPrecio, TamSX3("D2_TOTAL")[2]) * nQtdeDev
							Else
								aCols[nLenAcols][nTotal] := (nPrecio * nQtdeDev)
								If cPaisloc == "RUS"
									aCols[nLenAcols][nTotalM] := SD2->D2_TOTALM
								EndIf
							EndIf
						EndIf
					Else
						aCols[nLenAcols][nTotal] := xMoeda(SD2->D2_TOTAL ,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
					Endif
				Endif
				If nDesc > 0
					aCols[nLenAcols][nDesc] := SD2->D2_DESC
				Endif
				If nValDesc > 0
				    If nQtdeDev < SD2->D2_QUANT
						aCols[nLenAcols][nValDesc] := xMoeda((SD2->D2_DESCON/SD2->D2_QUANT)*nQtdeDev,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
					Else
						If nDesc > 0 .And. (cPaisLoc == "COL" .And. cDessai == '2')
							aCols[nLenAcols][nValDesc] := ((nPrecio * nQtdeDev)*SD2->D2_DESC)/100
						Else
							aCols[nLenAcols][nValDesc] := xMoeda(SD2->D2_DESCON,SF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),,,,nTaxaNF)
						Endif
					EndIf
				Endif
				If cPaisLoc == "ARG" .And. nProvEnt > 0 .And. lD2_PROVENT
					aCols[nLenAcols,nProvEnt] := SD2->D2_PROVENT
				Endif
				AEval(aHeader,{|x,y| If(aCols[nLenAcols][y]==NIL,aCols[nLenAcols][y]:=CriaVar(x[2]),) })
				If !(cPaisLoc == "ARG" .and. Len(aRecs) == 1)
					MaColsToFis(aHeader,aCols,nLenAcols,"MT100",.T.)
				EndIf
				If cPaisLoc == "COL" .And. cFunName <> "MATA462DN"
					LxVldCFCol(aCols, cCFO, nLenAcols, nCF)
				Else
					If !(cPaisLoc == "ARG" .and. Len(aRecs) == 1)
						MaFisAlt("IT_RECORI",SD2->(Recno()),nLenAcols)
					Else
						AADD(aRecOri,{aCols[nLenAcols][nNfOri], aCols[nLenAcols][nItemOri],SD2->(Recno())})
					EndIf
				EndIf
				//³ Dispara o ponto para cada item da NF        ³
				If lLxDOrig
					ExecBlock( "LXDORIG", .F., .F. )
				EndIf
			EndIf
		Endif
		SD2->(DbSkip())
	EndDo
Next nI
If cPaisLoc == "ARG"
	If (Len(aRecs) == 1)
		nItemAux := StrZero(0,Len(aCols[1][nItem]))
		aSort(aCols,,,{|x,y| x[nItemOri] < y[nItemOri] })
		aEval(aCols, {|x| nItemAux := soma1(nItemAux), x[nItem] := nItemAux })
		MaColsToFis(aHeader,aCols,,"MT100",.T.)
		For nItemAux := 1 To Len(aCols)
			nPosDocOri := Ascan(aRecOri,{|x| x[1] == aCols[nItemAux][nNfOri] .and. x[2] == aCols[nItemAux][nItemOri]})
			If nPosDocOri > 0
				MaFisAlt("IT_RECORI",aRecOri[nPosDocOri][3],nItemAux)
			EndIf
		Next nItemAux
	EndIf
	MaFisReprocess(2)
EndiF
oGetDados:lNewLine:=.F.
oGetDados:obrowse:refresh()
Eval(bDoRefresh)
AtuLoadQt()
RestArea(aSD2)
RestArea(aSF2)
RestArea(aArea)
Return
/*Funcao    ³LocTranSB2³  Data ³06.08.2007
Descri‡…o ³Atualiza o saldo da tabela SB2 - Armazem de transito
Parametros³nTipo    - 1 = Estorno RE4 / 2 = Estorno DE4
          ³cFilOrig - Codigo da Filial Origem*/
Function LocTranSB2(nTipo,cFilOrig)
Local cFilBack := cFilAnt
Local lRet     := .F.
Local lTranSB2 := SuperGetMv("MV_TRANSB2",.F.,.F.)
If lTranSB2
	If nTipo == 1
		lRet    := .T.
		// Altera filial corrente
		cFilAnt := cFilOrig
		// Gera movimento de estorno
		RecLock("SD3",.F.)
		Replace D3_TM			With "499"
		Replace D3_CF       	With "DE4"
		Replace D3_ESTORNO  	With "S"
		MsUnLock()
		// Atualiza o saldo atual (SB2) com os dados do SD3
		B2AtuComD3({D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5},Nil,Nil,.F.,Nil,.T.,.F.)
		// Apaga movimento de transferencia
		RecLock("SD3",.F.)
		DbDelete()
		MsUnlock()
		// Restaura filial Atual
		cFilAnt := cFilBack
	Else
		lRet    := .T.
		// Altera movimento para exclusao
		RecLock("SD3",.F.)
		Replace D3_TM			With "999"
		Replace D3_CF       	With "RE4"
		Replace D3_ESTORNO  	With "S"
		MsUnLock()
		// Atualiza o saldo atual (SB2) com os dados do SD3
		B2AtuComD3({D3_CUSTO1,D3_CUSTO2,D3_CUSTO3,D3_CUSTO4,D3_CUSTO5},Nil,Nil,.F.,Nil,.T.,.F.)
		// Apaga movimento de transferencia
		RecLock("SD3",.F.)
		DbDelete()
		MsUnlock()
	EndIf
EndIf
Return lRet

/*
Fun‡…o    ³IsLocTran  ³ Data ³06/08/07
Descri‡…o ³Verifica se o armazem passado como parametro e o armazem de
          ³transito utilizado na transferencia localizada.
Parametros³cArmazem - Codigo do Armazen
          ³lHelp    - Indica se deseja visualizar o help
 Retorno  ³lRet - Logico
*/
Function IsLocTran(cArmazem,lHelp)
Local lRet     := .F.
Local cDepTran := SuperGetMv("MV_DEPTRANS",.F.,"95")

Default cArmazem := ''
Default lHelp    := .T.

If cPaisLoc <> "BRA"
	If cDepTran == cArmazem
		If lHelp
			Help(" ",1,"DEPTRAN")
		EndIf
		lRet := .T.
	EndIf
EndIf
Return lRet
/*
Funcao    ³LxSomaImp ³ Data ³31/07/2007
Descri‡…o ³Prorateio de faturas tipo 9 e A:
          ³Cada pais pode gravar em um _VALIMP? diferente
Retorno   ³Somatoria dos campos D1_VALIMP1+D1_VALIMP2+...+D1_VALIMPN
*/
Static Function LxSomaImp(cTes)
Local aArea     := GetArea()
Local nValImpX  := 0
Local aImpostos := {}
Local nPosSWN   := 0
Local nY        := 0

Default cTes    := ""
aImpostos := DefImposto(cTes)
For nY:=1 to Len(aImpostos)
	nPosSWN := SWN->(FieldPos("WN_"+Substr(aImpostos[nY][2],1,7)))
	If nPosSWN > 0
		If ( aImpostos[nY][5] $ "S1" )
			nValImpX += SWN->(FieldGet(nPosSWN))
		EndIf
	EndIf
Next nY
RestArea(aArea)
Return(nValImpX)
/*
Fun‡„o    ³ LocConvNota³  Data ³ 18/04/08
Descri‡„o ³ Preenche o numero da NF com zeros a esquerda
          ³ mesmo quando o conteudo for alfanumerico
Sintaxe   ³ ExpC1 := LocConvNota(ExpC2,ExpC3)
Parametros³ ExpC2: Numero da nota
          ³ ExpC3: Tamanho do numero da nota
Retorno   ³ ExpC1 := N£mero da Moeda
*/
Function LocConvNota(cX5Descri,nTamNota)
Local cNumNota 	 := ""
Local cParcNum 	 := ""
DEFAULT nTamNota := Len( SF2->F2_DOC )

cParcNum := AllTrim( cX5Descri )
If cPaisLoc $ "PER|PAR"
	cNumNota := cParcNum
Else
	cNumNota := Replicate( "0",nTamNota - Len( cParcNum ) ) + cParcNum
EndIf


Return( cNumNota )

/*
Programa  ³axNFImpExpº
Desc.     ³Verifica se os campos de declaracao de export. e liquida-
          ³cao de importacao devem estar habilitados para digitacao.
*/
Function axNFImpExp(cTipo)
Local lRet := .F.

Do Case
//Validacao do SF1 e do SF2
Case cTipo == "1"
	//   Usa Cliente
	If aCfgNf[ScCliFor] == "SA1" .And. Alltrim(SA1->A1_EST) == "99"
		lRet := .T.
	Endif
	// Usa Fornec.
	If aCfgNf[ScCliFor] == "SA2" .And. Alltrim(SA2->A2_EST) == "99"
		lRet := .T.
	Endif
//Validacao do SC5
Case cTipo == "2"
	If 	M->C5_TIPO == 'N' .And. Alltrim(SA1->A1_EST) == "99" .Or. ;
		M->C5_TIPO == 'B' .And. Alltrim(SA2->A2_EST) == "99"
		lRet := .T.
	Endif
//Validacao do SC7
Case cTipo == "3"
	If 	Alltrim(SA2->A2_EST) == "99"
		lRet := .T.
	Endif
EndCase
Return lRet
/*
Programa  ³GRAVASEV  Data ³  07/08/08
Desc.     ³Efetua gravacao da multinatureza de acordo com os titulos fin
*/
Static Function GRAVASEV(cAliasFin,nValDUP)
//Local cPrefFin := IIf(!Empty(cAliasFin),cAliasFin+"->"+PrefixoCpo(cAliasFin),"")
Local nRateio  := 0
Local aArea    := GetArea()
Local lRet     := .F.
Local nY,nZ
Local nTEZ_PERC	:= TamSX3("EZ_PERC")[2]
Local aSEZ			:= {}
Local nPosSEZ		:= 0
Local nRateioSEZ	:= 0
Local cFilSEZ	:= xFilial("SEZ")
Local cFilSEV	:= xFilial("SEV")

If TYPE("aRatCC") == "U"
	 aRatCC := {}
ENDIF

if TYPE("AColsSEV") == "U"
	AColsSEV := {}
endif

If ( cAliasFin == "SE2" .and. !empty(aRatCC) )
	For nZ := 1 To Len(aRatCC[01,02])
		If ( nPosSEZ := aScan( aSEZ, { |x| x[01] == aRatCC[01,02,nZ,03] .and. x[02] == aRatCC[01,02,nZ,04] .and. x[03] == aRatCC[01,02,nZ,05] } ) ) == 0
			//C.C. - ItemClasse - Classe - Percentual - Valor
			aAdd( aSEZ, {aRatCC[ 01, 02, nZ, 03 ],aRatCC[ 01, 02, nZ, 04 ],aRatCC[ 01, 02, nZ, 05 ],aRatCC[ 01, 02, nZ, 02 ],0} )
		Else
			aSEZ[ nPosSEZ, 04 ] += aRatCC[ 01, 02, nZ, 02 ]
			aSEZ[ nPosSEZ, 05 ] += If ( !Empty(aRatCC[ 01, 02, nZ, 05 ]), aRatCC[ 01, 02, nZ, 05 ], 0 )
		EndIf
	Next
EndIf
dbSelectArea("SEV")
//Verifica multinatureza
For nY := 1 To Len(aColsSEV)
	If !aColsSEV[nY][Len(aColsSEV[1])] .And. !Empty(aColsSEV[nY][1])
		RecLock("SEV", .T. )
		For nZ := 1 To Len(aHeadSEV)
			If aHeadSEV[nZ][10]<>"V"
				SEV->(FieldPut(FieldPos(aHeadSEV[nZ][2]),aColsSEV[nY][nZ]))
			EndIf
		Next nZ
		SEV->EV_FILIAL   := cFilSEV
		If cAliasFin == "SE1"
			SEV->EV_PREFIXO  := SE1->E1_PREFIXO
			SEV->EV_NUM      := SE1->E1_NUM
			SEV->EV_PARCELA  := SE1->E1_PARCELA
			SEV->EV_CLIFOR   := SE1->E1_CLIENTE
			SEV->EV_LOJA     := SE1->E1_LOJA
			SEV->EV_TIPO     := SE1->E1_TIPO
		Else
			SEV->EV_PREFIXO  := SE2->E2_PREFIXO
			SEV->EV_NUM      := SE2->E2_NUM
			SEV->EV_PARCELA  := SE2->E2_PARCELA
			SEV->EV_CLIFOR   := SE2->E2_FORNECE
			SEV->EV_LOJA     := SE2->E2_LOJA
			SEV->EV_TIPO     := SE2->E2_TIPO
		EndIf
		SEV->EV_VALOR    := IIf(nY==Len(aColsSEV),nValDup-nRateio,NoRound(nValDup*SEV->EV_PERC/100,2))
		SEV->EV_PERC     := SEV->EV_PERC/100
		SEV->EV_RECPAG   := If(cAliasFin=="SE2","P","R")
		SEV->EV_LA       := ""
		SEV->EV_IDENT    := "1"
		nRateio += SEV->EV_VALOR
		If ( cAliasFin == "SE2" .OR. cAliasFin == "SE1" )
			If cPaisLoc <> "BRA" .AND. empty(aSEZ) .AND. FindFunction("LxFunNatC")
				if Select("SEZTMP") > 0 .And. aColsSev[nY][4] == "1"
					SEV->EV_RATEICC := "1"
					LxFunNatC(aColsSev[nY][1])
				Endif
			Else
				if !empty(aSEZ)
					For nZ := 1 To Len(aSEZ)
					SEV->EV_RATEICC := "1"
					RecLock("SEZ",.T.)
					SEZ->EZ_FILIAL := cFilSEZ
					SEZ->EZ_PREFIXO:= SEV->EV_PREFIXO
					SEZ->EZ_NUM    := SEV->EV_NUM
					SEZ->EZ_PARCELA:= SEV->EV_PARCELA
					SEZ->EZ_CLIFOR := SEV->EV_CLIFOR
					SEZ->EZ_LOJA   := SEV->EV_LOJA
					SEZ->EZ_TIPO   := SEV->EV_TIPO
					SEZ->EZ_PERC   := aSEZ[nZ][04]/100
					SEZ->EZ_VALOR  := NoRound(SEV->EV_VALOR*SEZ->EZ_PERC,nTEZ_PERC)
					SEZ->EZ_NATUREZ:= SEV->EV_NATUREZ
					SEZ->EZ_CCUSTO := aSEZ[nZ][01]
					SEZ->EZ_ITEMCTA:= aSEZ[nZ][02]
					SEZ->EZ_CLVL   := aSEZ[nZ][03]
					SEZ->EZ_RECPAG := SEV->EV_RECPAG
					SEZ->EZ_LA     := ""
					SEZ->EZ_IDENT  := SEV->EV_IDENT
					SEZ->EZ_SEQ    := SEV->EV_SEQ
					SEZ->EZ_SITUACA:= SEV->EV_SITUACA
					nRateioSEZ += SEZ->EZ_VALOR
					SEZ->(MsUnLock())
					Next nZ
				Endif
			Endif
		EndIf
		SEV->(MsUnlock())
		lRet := .T.
	EndIf
Next nY

RestArea(aArea)
Return lRet
//Programa  ³SCMToREM2   ºData  ³  23/10/08
//Desc.     ³Selecao de remitos para NF de Saida
Function SCMToREM2()
Local aCposF4		:= {}
Local aRecs    		:= {}
Local aRet     		:= {}
Local aArea    		:= GetArea()
//Local cCampo 		:= ""
Local cCliFor		:= IIf(aCfgNF[SAliasHead]=="SF2",M->F2_CLIENTE,M->F1_FORNECE)
Local cCondicao 	:= ""
Local cItem			:=	""
Local cLoja  		:= IIf(aCfgNF[SAliasHead]=="SF2",M->F2_LOJA,M->F1_LOJA)
Local cSeek  		:= "'" + xFilial('SF2')+cCliFor+cLoja + "'"
Local cTipoDoc 		:= ""
Local cWhile 		:= "!__LOCXSF2->(EOF()) .AND. __LOCXSF2->(F2_FILIAL+F2_CLIENTE+F2_LOJA)== " + cSeek
Local cPosFilial	:= ""
Local cPosDoc		:= ""
Local cPosSerie		:= ""
Local cPosCliente	:= ""
Local cPosLoja		:= ""
Local cPosTipo		:= ""
Local nPorDesc		:= 0
Local nItemRem 		:= 0
Local nUm      		:= 0
Local nSegum   		:= 0
Local nCod     		:= 0
Local nLocal   		:= 0
Local nQuant   		:= 0
Local nRemito  		:= 0
Local nSeriRem 		:= 0
Local nItem    		:= 0
Local nTes     		:= 0
Local nCf      		:= 0
Local nLoteCtl 		:= 0
Local nNumLote 		:= 0
Local nDtValid 		:= 0
Local nProvEnt		:= 0
Local nIpi     		:= 0
Local nVunit   		:= 0
Local nTotal   		:= 0
Local nQTSegum 		:= 0
Local nConta 		:= 0
Local nCCusto 		:= 0
Local nDesc 		:= 0
//Local nDesNTrb		:= 0
//Local nTara			:= 0
Local nI 			:= 0
Local nJ 			:= 0
//Local nK 			:= 0
Local cTipConv		:= GetNewPar("MV_ALTTXNF",'1')
Local nTaxaNf		:= 0
Local nTaxaPed		:= 0
Local nItConta  	:= 0
Local nClValor  	:= 0
Local nSeguro       := 0
Local nFrete        := 0
Local nDescont      := 0
Local nDespesa      := 0
Local cPe		    := ""
Local cRetPe        := ""
Local cFilSB1	:= xFilial("SB1")
Local cFilSC5	:= xFilial("SC5")
Local cFilSC6	:= xFilial("SC6")
Local cFilSD2	:= xFilial("SD2")
//Local cCFO			:= ""
Private aFiltro		:= {}
Private aColsSD2	:= aCols

If Empty(cCliFor) .OR. Empty(cLoja)
	Aviso(cCadastro,STR0094,{STR0021})
	Return
EndIf

For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D2_DESC"
			nPorDesc	:= nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEMREM"
			nItemRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_SEGUM"
			nSegum   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_REMITO"
			nRemito  := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_SERIREM"
			nSeriRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_IPI"
			nIpi     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_PRCVEN"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CCUSTO"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_DESCON"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEMCC"
			nItConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CLVL"
			nClValor := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_PROVENT"
			nProvEnt := nI
	Endcase
Next nI

If aCfgNF[SnTipo] == 7 .Or. aCfgNF[SnTipo] == 6
	cTipoDoc := "61"
Else
	Return
EndIf

SX3->(DbSetOrder(1))
SX3->(DbSeek("SF2"))
While !SX3->(EOF()) .AND. SX3->X3_ARQUIVO == "SF2"
	If SX3->X3_BROWSE == "S" .AND. cNivel >= SX3->X3_NIVEL
		AAdd(aCposF4,SX3->X3_CAMPO)
	Endif
	SX3->(DbSkip())
EndDo

For nI:=1 to Len(aCposF4)
	Do Case
		Case  Alltrim(aCposF4[nI]) == "F2_FILIAL"
			cPosFilial := nI
		Case  Alltrim(aCposF4[nI]) == "F2_DOC"
			cPosDoc := nI
		Case  Alltrim(aCposF4[nI]) == "F2_SERIE"
			cPosSerie := nI
		Case  Alltrim(aCposF4[nI]) == "F2_CLIENTE"
			cPosCliente := nI
		Case  Alltrim(aHeader[nI]) == "F2_LOJA"
			cPosLoja := nI
		Case  Alltrim(aHeader[nI]) == "F2_TIPO"
			cPosTipo := nI
	Endcase
Next nI

If nRemito * nSeriRem * nItemRem > 0
	DbSelectArea("SD2")
	SD2->(DbSetOrder(9))
	SD2->(DbSeek(cFilSD2+cCliFor+cLoja))
	While !SD2->(EOF()) .And. SD2->D2_FILIAL+SD2->D2_CLIENTE+SD2->D2_LOJA == cFilSD2+cCliFor+cLoja
		If 	DToS(SD2->D2_EMISSAO) <= DToS(dDataBase) .And. (SD2->D2_QUANT - SD2->D2_QTDEFAT) > 0 .And. AllTrim(SD2->D2_TIPO) == aCfgNF[ScTipoDoc] .And.	AllTrim(SD2->D2_TIPODOC) $ Alltrim(cTipoDoc)
			If Ascan(aColsSD2,{ |X| X[nRemito]+X[nSeriRem]+X[nItemRem] == SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_ITEM})==0
				Aadd(aFiltro, {SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_TIPO, SD2->(Recno())})
			Endif
		Endif
		SD2->(DbSkip())
	EndDo
	If !Empty(aFiltro)
		If Select("__LOCXSF2") == 0
			ChkFile("SF2",.F.,"__LOCXSF2")
		Endif
		cPe	:=	LocxPE(57)
		If !Empty(cPe)
			cRetPe := Execblock(cPE,.F.,.F.,{"__LOCXSF2"})
			If ValType(cRetPe) <> "C"
		   	  	cRetPe := " "
		  	EndIf
		EndIf
		cCondicao	:= "Ascan(aFiltro,{ |X| X[1]==__LOCXSF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_TIPO)}) > 0"
	  	cCondicao   += if(empty(cRetPe),"",".AND." + cRetPe)
		aRet 		:= LocxF4("__LOCXSF2",2,cWhile,cSeek,aCposF4,,DESCREM,cCondicao,.T.,,,,,.F.)
	Else
		Help(" ",1,"A103F4")
		Return
	EndIf
Else
	Alert(STR0098 + " D2_REMITO, D2_SERIREM, D2_ITEMREM.")//"Para utilizar esta opcao se faz necessario que os seguintes campos estejam em uso e disponiveis:"
EndIf

If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf

If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return
EndIf

cItem	:=	StrZero(0,TamSx3('D2_ITEM')[1])
nI:=0

For nI := 1 To Len(aRecs)
	__LOCXSF2->(MsGoTo(aRecs[nI]))
	For nJ := 1 to Len(aFiltro)
		If aFiltro[nJ][1] == __LOCXSF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_TIPO)
			If ( nCod > 0  .AND.  !Empty(aCOLS[Len(aCols)][nCod]))
				AAdd(aCols,Array(Len(aHeader)+1))
			EndIf
		 	aCols[Len(aCols)][Len(aHeader)+1]:=.F.
			SD2->(MsGoto(aFiltro[nJ][2]))
			SB1->(MsSeek(cFilSB1+SD2->D2_COD))
			SC5->(dbSetOrder(1))
			SC5->(MsSeek(cFilSC5+SD2->D2_PEDIDO))
			SC6->(dbSetOrder(1))
			SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV))
			cItem	:=	Soma1(cItem)
			If (nItemRem >  0  ,  aCOLS[Len(aCols)][nItemRem] := SD2->D2_ITEM   ,)
			If (nUm      >  0  ,  aCOLS[Len(aCols)][nUm     ] := SD2->D2_UM     ,)
			If (nSegum   >  0  ,  aCOLS[Len(aCols)][nSegum  ] := SD2->D2_SEGUM  ,)
			If (nCod     >  0  ,  aCOLS[Len(aCols)][nCod    ] := SD2->D2_COD	  ,)
			If (nSeriRem >  0  ,  aCOLS[Len(aCols)][nSeriRem] := SD2->D2_SERIE  ,)
			If (nLocal   >  0  ,  aCOLS[Len(aCols)][nLocal  ] := SD2->D2_LOCAL  ,)
			If (nQuant   >  0  ,  aCOLS[Len(aCols)][nQuant  ] := (SD2->D2_QUANT - SD2->D2_QTDEFAT),)
			If (nRemito  >  0  ,  aCOLS[Len(aCols)][nRemito ] := SD2->D2_DOC	  ,)
			If (nItem    >  0  ,  aCOLS[Len(aCols)][nItem   ] := cItem ,)
			If (nTes     >  0  ,  aCOLS[Len(aCols)][nTes    ] := SD2->D2_TES    ,)
			If (nCF      >  0  ,  aCOLS[Len(aCols)][nCF     ] := SD2->D2_CF     ,)
			If (nLOTECTL >  0  ,  aCOLS[Len(aCols)][nLOTECTL] := SD2->D2_LOTECTL,)
			If (nNUMLOTE >  0  ,  aCOLS[Len(aCols)][nNUMLOTE] := SD2->D2_NUMLOTE,)
			If (nDTVALID >  0  ,  aCOLS[Len(aCols)][nDTVALID] := SD2->D2_DTVALID,)
			If (nProvEnt >  0  ,  aCOLS[Len(aCols)][nProvEnt] := SD2->D2_PROVENT,)
			If (nIPI     >  0  ,  aCOLS[Len(aCols)][nIPI    ] := SD2->D2_IPI    ,)
			If (nQtSegUm >  0  ,  aCOLS[Len(aCols)][nQtSegUm] := SD2->D2_QTSEGUM,)
			If (nConta   >  0  ,  aCOLS[Len(aCols)][nConta  ] := If(!Empty(SD2->D2_CONTA),SD2->D2_CONTA,SB1->B1_CONTA),)
			If (nCCusto  >  0  ,  aCOLS[Len(aCols)][nCCusto ] := If(!Empty(SD2->D2_CCUSTO),SD2->D2_CCUSTO,SB1->B1_CC),)
			If (nItConta >  0  ,  aCOLS[Len(aCols)][nItConta] := SD2->D2_ITEMCC,)
			If (nClValor >  0  ,  aCOLS[Len(aCols)][nClValor] := SD2->D2_CLVL,)
			nTaxaNF		:= Iif(MaFisRet(,'NF_TXMOEDA')==0,Recmoeda(dDatabase,M->F2_MOEDA),MaFisRet(,'NF_TXMOEDA'))
			nTaxaPed	:= Iif(cTipConv=='1',Iif(__LOCXSF2->F2_TXMOEDA=0,RecMoeda(__LOCXSF2->F2_EMISSAO,__LOCXSF2->F2_MOEDA),__LOCXSF2->F2_TXMOEDA),RecMoeda(dDatabase,__LOCXSF2->F2_MOEDA))
			If nVUnit   >  0
				If SD2->D2_PRCVEN <> 0
					nPrecio := xMoeda(SD2->D2_PRCVEN,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					If ! Empty(SD2->D2_PEDIDO)
						nPrecio := xMoeda(SC6->C6_PRCVEN,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
					Else
						nPrecio := RetFldProd(SB1->B1_COD,"B1_PRV1")
					EndIf
				EndIf
				aCOLS[Len(aCols)][nVunit] := nPrecio
			EndIf

			If nTotal > 0
				If SD2->D2_PRCVEN <> 0
					nPrecio := xMoeda(SD2->D2_PRCVEN,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					If .Not. Empty(SD2->D2_PEDIDO)
						nPrecio := xMoeda(SC6->C6_PRCVEN,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
					Else
						nPrecio := RetFldProd(SB1->B1_COD,"B1_PRV1")
					EndIf
				EndIf
				aCOLS[Len(aCols)][nTotal] := (nPrecio * (SD2->D2_QUANT - SD2->D2_QTDEFAT))
			Endif

			If nDesc > 0
				If SD2->D2_DESCON <> 0
					If SD2->D2_QTDAFAT == SD2->D2_QUANT .Or. SD2->D2_QTDAFAT == 0
						aCols[Len(aCols)][nDesc] :=xMoeda(SD2->D2_DESCON,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
					Else
						aCols[Len(aCols)][nDesc] :=xMoeda(SD2->D2_DESCON*SD2->D2_QTDAFAT/SD2->D2_QUANT,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
					Endif
				Else
					dbSelectArea("SC6")
					dbSetOrder(1)
					If SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV,.F.))
						If SD2->D2_QTDAFAT == SC6->C6_QTDVEN .Or. SD2->D2_QTDAFAT == 0
							aCols[Len(aCols)][nDesc] :=xMoeda(SC6->C6_VALDESC,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
						Else
							aCols[Len(aCols)][nDesc] :=xMoeda(SC6->C6_VALDESC*SC6->C6_QTDVEN/SD2->D2_QTDAFAT ,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
						Endif
					EndIf
				EndIf
			Endif

		   If nPorDesc	 > 0
				If SD2->D2_DESC <> 0
					aCOLS[Len(aCols)][nPorDesc ] := SD2->D2_DESC
				Else
					dbSelectArea("SC6")
					dbSetOrder(1)
					If SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV,.F.))
						aCols[Len(aCols)][nPorDesc] := SC6->C6_DESCONT
					EndIf
				Endif
			Endif

			cPe := LocxPE(50)
			If !Empty(cPe)
				Execblock(cPE,.F.,.F.,)
			EndIf
			AEval(aHeader,{|x,y| If(aCols[Len(aCols)][y]==NIL,aCols[Len(aCols)][y]:=CriaVar(x[2]),) })
			IIf(cPaisLoc == "COL" .And. nCF>0, cCFO := aCols[Len(aCols)][nCF],)
			MaColsToFis(aHeader,aCols,Len(aCols),"MT100",.T.)
			If cPaisLoc == "COL"
				LxVldCFCol(aCols, cCFO, Len(aCols), nCF)
			EndIf
			MafisAlt('IT_FRETE'		,SD2->D2_VALFRE		,Len(aCols))
			MafisAlt('IT_DESPESA'	,SD2->D2_DESPESA	,Len(aCols))
			MafisAlt('IT_DESCONTO'	,SD2->D2_DESCON 	,Len(aCols))
			MafisAlt('IT_SEGURO'	,SD2->D2_SEGURO		,Len(aCols))
			//#PORTUGAL#
			/*If cPaisLoc == "PTG"
				MafisAlt('IT_DESNTRB'	,SD2->D2_DESNTRB	,Len(aCols))
				MafisAlt('IT_TARA'		,SD2->D2_TARA		,Len(aCols))
			Endif*/
			nFrete   += SD2->D2_VALFRE
			nDespesa += SD2->D2_DESPESA
			nDescont += SD2->D2_DESCON
			nSeguro  += SD2->D2_SEGURO
			//#PORTUGAL#
			/*If cPaisLoc == "PTG"
				nDesNTrb 	+= SD2->D2_DESNTRB
				nTara		+= SD2->D2_TARA
			Endif*/
		EndIf
	Next nJ
Next nI

// Atualizar pasta Gastos com base nos itens do Remito
If nFrete > 0 .And. ValType(F2_FRETE) == "N"
	F2_FRETE := F2_FRETE + nFrete
EndIf
If nSeguro > 0	.And. ValType(F2_SEGURO) == "N"
	F2_SEGURO := F2_SEGURO + nSeguro
EndIf
If nDespesa > 0	.And. ValType(F2_DESPESA) == "N"
	F2_DESPESA := F2_DESPESA + nDespesa
EndIf
If nDescont > 0 .And. ValType(F2_DESCONT) == "N"
	F2_DESCONT := F2_DESCONT + nDescont
EndIf
/*If cPaisLoc == "PTG"
	If nDesNTrb > 0 .And. ValType(F2_DESNTRB) == "N"
		F2_DESNTRB := F2_DESNTRB + nDesNTrb
	EndIf
	If nTara > 0 .And. ValType(F2_TARA) == "N"
		F2_TARA := F2_TARA + nTara
	EndIf
Endif*/

Eval(bDoRefresh)
oGetDados:obrowse:refresh()
AtuLoadQt()
RestArea(aArea)
Return
/*
±±ºPrograma  ³SCMToNF2  ºAutor  ³ Ricardo Berti      º Data ³  23/10/08   º±±
±±ºDesc.     ³ Mostra remitos que serao amarrados ao documento sendo 	  º±±
±±º          ³ digitado (devolucao ou NF de saida)                        º±±
±±ºUso       ³MATA466N                                                    º±±
*/
Function SCMToNF2()
Local aRecs    := {}
Local aRet     := {}
//Local aCpoExt  := {}
//Local aCpoExtra:= {}
Local aAreaSD2 := GetArea()
Local nI       := 0
Local nPorDesc := 0
Local nItemRem := 0
Local nUm      := 0
Local nSegum   := 0
Local nCod     := 0
Local nLocal   := 0
Local nQuant   := 0
Local nRemito  := 0
Local nItem    := 0
Local nTes     := 0
Local nCF      := 0
Local nSeriRem := 0
Local nLOTECTL := 0
Local nNUMLOTE := 0
Local nDTVALID := 0
Local nProvEnt := 0
Local nIPI     := 0
Local nQtSegUm := 0
Local nConta   := 0
Local nCCusto  := 0
Local cTipoDoc := ""
Local cCliFor:= IIf(aCfgNF[SAliasHead]=="SF2",M->F2_CLIENTE,M->F1_FORNECE)
Local cLoja  := IIf(aCfgNF[SAliasHead]=="SF2",M->F2_LOJA,M->F1_LOJA)
//Local nPosSolici := 0
//Local cCampo := "" ,cItem	:=	""
Local cSeek  := "'" + xFilial('SD2')+cCliFor+cLoja + "'"
Local cWhile := "!EOF() .AND. SD2->D2_FILIAL+SD2->D2_CLIENTE+SD2->D2_LOJA== " + cSeek
Local cCondicao := ""
Local aCposF4	:= 	   {"D2_DOC",;
						"D2_CLIENTE",;
						"D2_LOJA"   ,;
						"D2_ITEM"   ,;
						"D2_COD"	,;
						"D2_UM"     ,;
						"D2_QUANT"  ,;
						"D2_QTDEFAT",;
						"D2_SEGUM"  ,;
						"D2_QTSEGUM",;
						"D2_LOCAL"  ,;
						"D2_PEDIDO" }

Local cTipConv := GetNewPar("MV_ALTTXNF",'1')
Local nTaxaNf  := 0
Local nTaxaPed := 0
Local nSeguro  := 0
Local nFrete   := 0
Local nDescont := 0
Local nDespesa := 0
//Local nDesNTrb := 0
//Local nTara    := 0
Local cPe	   := ""
Local cCondUser:= ""
Local cFilSB1	:= xFilial("SB1")
Local cFilSC5	:= xFilial("SC5")
Local cFilSC6	:= xFilial("SC6")
Local cFilSF2	:= xFilial("SF2")
//Local cCFO		:= ""
Private aColsSD2 	:= aCols

cPe	:=	LocxPE(58)
If !Empty(cPe)
	cCondUser := Execblock(cPE,.F.,.F.,)
	If ValType(cCondUser) <> "C"
		cCondUser := " "
	EndIf
EndIf

If Empty(cCliFor) .OR. Empty(cLoja)
	Aviso(cCadastro,STR0094,{STR0021})
	Return
EndIf

If  nModulo == 12 .And. !nModulo == 72  // SIGALOJA //SIGAPHOTO
	Aviso(cCadastro,STR0238,{STR0021})
	Return
EndIf

For nI:=1 to Len(aHeader)
	Do Case
		Case  Alltrim(aHeader[nI][2]) == "D2_DESC"
			nPorDesc	:= nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEMREM"
			nItemRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_UM"
			nUm      := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_SEGUM"
			nSegum   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_COD"
			nCod     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_LOCAL"
			nLocal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_QUANT"
			nQuant   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_REMITO"
			nRemito  := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_SERIREM"
			nSeriRem := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_ITEM"
			nItem    := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_TES"
			nTes     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CF"
			nCf      := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_LOTECTL"
			nLoteCtl := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_NUMLOTE"
			nNumLote := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_DTVALID"
			nDtValid := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_IPI"
			nIpi     := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_PRCVEN"
			nVunit   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_TOTAL"
			nTotal   := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_QTSEGUM"
			nQTSegum := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CONTA"
			nConta := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_CCUSTO"
			nCCusto := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_DESCON"
			nDesc := nI
		Case  Alltrim(aHeader[nI][2]) == "D2_PROVENT"
			nProvEnt := nI
	Endcase
Next nI

If aCfgNF[SnTipo] == 7 .Or. aCfgNF[SnTipo] == 6
	cTipoDoc := "61"
Else
	Return
EndIf

If nRemito * nSeriRem * nItemRem > 0
	cCondicao 	:= IIf(Empty(cCondicao),""," .And. ") + "DTOS(SD2->D2_EMISSAO)<='"+Dtos(dDataBase)+"' .And. (SD2->D2_QUANT - SD2->D2_QTDEFAT) > 0 .And. AllTrim(SD2->D2_TIPO) == aCfgNF["+AllTrim(Str(ScTipoDoc))+"] .And. AllTrim(SD2->D2_TIPODOC) $ Alltrim('"+cTipoDoc+"').And. " +;
				   "Iif(Ascan(aColsSD2,{ |X| X["+Alltrim(str(nRemito))+"]+ X["+Alltrim(Str(nSeriRem))+"] +X["+Alltrim(Str(nItemRem))+"] == SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_ITEM})==0,.T.,.F. )"

	If !Empty(cCondUser)
		cCondicao := "(" + cCondicao + ") .And. (" + cCondUser + ")"
	EndIf

	aRet := LocxF4("SD2",9,cWhile,cSeek,aCposF4,,DESCREM,cCondicao,.T.,,,,,.F.)  // Retorna os Recnos das linhas selecionadas
	Eval( bFilBrw )
Else
	Alert(STR0098 + " D2_REMITO, D2_SERIREM, D2_ITEMREM.")//"Para utilizar esta opcao se faz necessario que os seguintes campos estejam em uso e disponiveis:"
EndIf

If ValType(aRet)=="A" .AND. Len(aRet)==3
	aRecs := aRet[3]
EndIf

If ValType(aRecs)!="A" .OR. (ValType(aRecs)=="A" .AND. Len(aRecs)==0)
	Return
EndIf

cItem	:=	StrZero(0,TamSx3('D2_ITEM')[1])
nI:=0
For nI := 1 To Len(aRecs)
	If ( nCod > 0  .AND.  !Empty(aCOLS[Len(aCols)][nCod]))
		AAdd(aCols,Array(Len(aHeader)+1))
	EndIf
 	aCols[Len(aCols)][Len(aHeader)+1]:=.F.
	SD2->(MsGoto(aRecs[nI]))
	SB1->(MsSeek(cFilSB1+SD2->D2_COD))
	SC5->(dbSetOrder(1))
	SC5->(MsSeek(cFilSC5+SD2->D2_PEDIDO))
	SC6->(dbSetOrder(1))
	SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV))
	cItem	:=	Soma1(cItem)

	If (nItemRem >  0  ,  aCOLS[Len(aCols)][nItemRem] := SD2->D2_ITEM   ,)
	If (nUm      >  0  ,  aCOLS[Len(aCols)][nUm     ] := SD2->D2_UM     ,)
	If (nSegum   >  0  ,  aCOLS[Len(aCols)][nSegum  ] := SD2->D2_SEGUM  ,)
	If (nCod     >  0  ,  aCOLS[Len(aCols)][nCod    ] := SD2->D2_COD	,)
	If (nSeriRem >  0  ,  aCOLS[Len(aCols)][nSeriRem] := SD2->D2_SERIE  ,)
	If (nLocal   >  0  ,  aCOLS[Len(aCols)][nLocal  ] := SD2->D2_LOCAL  ,)
	If (nQuant   >  0  ,  aCOLS[Len(aCols)][nQuant  ] := (SD2->D2_QUANT - SD2->D2_QTDEFAT),)
	If (nRemito  >  0  ,  aCOLS[Len(aCols)][nRemito ] := SD2->D2_DOC	,)
	If (nItem    >  0  ,  aCOLS[Len(aCols)][nItem   ] := cItem			,)
	If (nTes     >  0  ,  aCOLS[Len(aCols)][nTes    ] := SD2->D2_TES    ,)
	If (nCF      >  0  ,  aCOLS[Len(aCols)][nCF     ] := SD2->D2_CF     ,)
	If (nLOTECTL >  0  ,  aCOLS[Len(aCols)][nLOTECTL] := SD2->D2_LOTECTL,)
	If (nNUMLOTE >  0  ,  aCOLS[Len(aCols)][nNUMLOTE] := SD2->D2_NUMLOTE,)
	If (nDTVALID >  0  ,  aCOLS[Len(aCols)][nDTVALID] := SD2->D2_DTVALID,)
	If (nProvEnt >  0  ,  aCOLS[Len(aCols)][nProvEnt] := SD2->D2_PROVENT,)
	If (nIPI     >  0  ,  aCOLS[Len(aCols)][nIPI    ] := SD2->D2_IPI    ,)
	If (nQtSegUm >  0  ,  aCOLS[Len(aCols)][nQtSegUm] := SD2->D2_QTSEGUM,)
	If (nConta   >  0  ,  aCOLS[Len(aCols)][nConta  ] := If(!Empty(SD2->D2_CONTA),SD2->D2_CONTA,SB1->B1_CONTA),)
	If (nCCusto  >  0  ,  aCOLS[Len(aCols)][nCCusto ] := If(!Empty(SD2->D2_CCUSTO),SD2->D2_CCUSTO,SB1->B1_CC),)

	If Select("__LOCXSF2") == 0
		ChkFile("SF2",.F.,"__LOCXSF2")
	Else
		dbSelectArea("__LOCXSF2")
	Endif
	__LOCXSF2->(DbSetOrder(1))
	__LOCXSF2->(MSSeek(cFilSF2+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_TIPO))
	nTaxaNF		:= Iif(MaFisRet(,'NF_TXMOEDA')==0,Recmoeda(dDatabase,M->F2_MOEDA),MaFisRet(,'NF_TXMOEDA'))
	nTaxaPed		:= Iif(cTipConv=='1',Iif(__LOCXSF2->F2_TXMOEDA=0,RecMoeda(__LOCXSF2->F2_EMISSAO,__LOCXSF2->F2_MOEDA),__LOCXSF2->F2_TXMOEDA),RecMoeda(dDatabase,__LOCXSF2->F2_MOEDA))
	If nVUnit   >  0
		If SD2->D2_PRCVEN <> 0
			nPrecio := xMoeda(SD2->D2_PRCVEN,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
		Else
			If ! Empty(SD2->D2_PEDIDO)
				nPrecio := xMoeda(SC6->C6_PRCVEN,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
			Else
				nPrecio := RetFldProd(SB1->B1_COD,"B1_PRV1")
			EndIf
		EndIf
		aCOLS[Len(aCols)][nVunit] := nPrecio
	EndIf

	If nTotal > 0
		If SD2->D2_PRCVEN <> 0
			nPrecio := xMoeda(SD2->D2_PRCVEN,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
		Else
			If ! Empty(SD2->D2_PEDIDO)
				nPrecio := xMoeda(SC6->C6_PRCVEN,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
			Else
				nPrecio := RetFldProd(SB1->B1_COD,"B1_PRV1")
			EndIf
		EndIf
		aCOLS[Len(aCols)][nTotal] := (nPrecio * (SD2->D2_QUANT - SD2->D2_QTDEFAT))
	Endif

	If nDesc > 0
		If SD2->D2_DESCON <> 0
			If SD2->D2_QTDAFAT == SD2->D2_QUANT .Or. SD2->D2_QTDAFAT == 0
				aCols[Len(aCols)][nDesc] :=xMoeda(SD2->D2_DESCON,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
			Else
				aCols[Len(aCols)][nDesc] :=xMoeda(SD2->D2_DESCON*SD2->D2_QTDAFAT/SD2->D2_QUANT,__LOCXSF2->F2_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
			Endif
		Else
			dbSelectArea("SC6")
			dbSetOrder(1)
			If SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV,.F.))
				If SD2->D2_QTDAFAT == SC6->C6_QTDVEN .Or. SD2->D2_QTDAFAT == 0
					aCols[Len(aCols)][nDesc] :=xMoeda(SC6->C6_VALDESC,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
				Else
					aCols[Len(aCols)][nDesc] :=xMoeda(SC6->C6_VALDESC*SC6->C6_QTDVEN/SD2->D2_QTDAFAT ,SC5->C5_MOEDA,MAFISRET(,'NF_MOEDA'),M->F2_EMISSAO,,nTaxaPed,nTaxaNF)
				Endif
			EndIf
		EndIf
	Endif

   If nPorDesc	 > 0
		If SD2->D2_DESC <> 0
			aCOLS[Len(aCols)][nPorDesc ] := SD2->D2_DESC
		Else
			dbSelectArea("SC6")
			dbSetOrder(1)
			If SC6->(MsSeek(cFilSC6+SD2->D2_PEDIDO+SD2->D2_ITEMPV,.F.))
				aCols[Len(aCols)][nPorDesc] := SC6->C6_DESCONT
			EndIf
		Endif
	Endif
	oGetDados:lNewLine:=.F.
	//Ponto entrada para preencher campos no aCols
	cPe := LocxPE(50)
	If !Empty(cPe)
		Execblock(cPE,.F.,.F.,)
	EndIf
  	AEval(aHeader,{|x,y| If(aCols[Len(aCols)][y]==NIL,aCols[Len(aCols)][y]:=CriaVar(x[2]),) })
	IIf(cPaisLoc == "COL" .And. nCF>0, cCFO := aCols[Len(aCols)][nCF],)
 	MaColsToFis(aHeader,aCols,Len(aCols),"MT100",.T.)
	If cPaisLoc == "COL"
		LxVldCFCol(aCols, cCFO, Len(aCols), nCF)
	EndIf
	MafisAlt('IT_FRETE'		,SD2->D2_VALFRE		,Len(aCols))
	MafisAlt('IT_DESPESA'	,SD2->D2_DESPESA	,Len(aCols))
	MafisAlt('IT_DESCONTO'	,SD2->D2_DESCON		,Len(aCols))
	MafisAlt('IT_SEGURO'	,SD2->D2_SEGURO		,Len(aCols))
	//#PORTUGAL#
	/*If cPaisLoc == "PTG"
		MafisAlt('IT_DESNTRB',SD2->D2_DESNTRB	,Len(aCols))
		MafisAlt('IT_TARA'	,SD2->D2_TARA	,Len(aCols))
	Endif*/
	nFrete   += SD2->D2_VALFRE
	nDespesa += SD2->D2_DESPESA
	nDescont += SD2->D2_DESCON
	nSeguro  += SD2->D2_SEGURO
	//#PORTUGAL#
	/*If cPaisLoc == "PTG"
		nDesNTrb += SD2->D2_DESNTRB
		nTara    += SD2->D2_TARA
	Endif*/
Next nI
// Atualizar pasta Gastos com base nos itens do Remito
If nFrete > 0 .And. ValType(F2_FRETE) == "N"
	F2_FRETE := F2_FRETE + nFrete
EndIf
If nSeguro > 0	.And. ValType(F2_SEGURO) == "N"
	F2_SEGURO := F2_SEGURO + nSeguro
EndIf
If nDespesa > 0	.And. ValType(F2_DESPESA) == "N"
	F2_DESPESA := F2_DESPESA + nDespesa
EndIf
If nDescont > 0 .And. ValType(F2_DESCONT) == "N"
	F2_DESCONT := F2_DESCONT + nDescont
EndIf
//#PORTUGAL#
/*If cPaisLoc == "PTG"
	If nDesNTrb > 0 .And. ValType(F2_DESNTRB) == "N"
		F2_DESNTRB := F2_DESNTRB + nDesNTrb
	EndIf
	If nTara > 0 .And. ValType(F2_TARA) == "N"
		F2_TARA := F2_TARA + nTara
	EndIf
Endif*/
Eval(bDoRefresh)
oGetDados:obrowse:refresh()

//Atualiza o browse de qtde de produtos.
AtuLoadQt(.T.)

RestArea(aAreaSD2)
Return
/*
±±³Fun‡„o    ³ALocPrdGrd³ ³±±
±±³Descricao ³ Interface de Grade de Produtos para Remito, Facturas de     ³±±
±±³          ³ de saida e nota de debito/credito (NDC e NCE no faturam.    ³±±
±±³          ³ NDI e NCP no Compras                                        ³±±
±±³Uso       ³Getdados das rotinas MATA462N, MATA465N e MATA467N disparada ³±±
±±³          ³pelo X3_VALID do D2_COD 									   ³±±
*/
Function ALocPrdGrd(lDo)
Local aArea	      := GetArea()
//Local aHlpPor     := {"Para incluir um produto com referência  ","de grade e necessário estar em uma nova ","linha do documento.          "}
//Local aHlpEng     := {"To include a product with bars reference"," and necessary to be in a new line of   ","the document.                  "}
//Local aHlpSpa     := {"Para incluir un producto con referencia ","de las barras y requisito estar en una  ","nueva línea del documento."}
//Local cDescri     := ""
Local cItem       := ""
Local cNewItem    := ""
Local cPrdOrig    := ""
Local cCpoName	  := StrTran(ReadVar(),"M->","")
Local cSaveReadVar:= __READVAR
Local nSaveN      := N
Local nNewItem    := Len(aCols)
Local nPosItem    := aScan(aHeader,{|x| AllTrim(x[2])=="D2_ITEM"})
Local nPosProd    := aScan(aHeader,{|x| AllTrim(x[2])=="D2_COD"})
Local nPosQuant   := aScan(aHeader,{|x| AllTrim(x[2])=="D2_QUANT"})
Local nPosQtSegum := aScan(aHeader,{|x| AllTrim(x[2])=="D2_QTSEGUM"})
Local nPosVUnit   := aScan(aHeader,{|x| AllTrim(x[2])=="D2_PRCVEN"})
Local nPosTotal   := aScan(aHeader,{|x| AllTrim(x[2])=="D2_TOTAL"})
Local nLinX       := 0
Local nColY       := 0
Local nY          := 0
Local lGrade	  := MaGrade()
Local lReferencia := .F.
Local lAadd       := .F.
Local lRet 		  := .T.
Local nTD2_TOTAL	:= TamSX3("D2_TOTAL")[2]
Local oDlg

Default lDo       := .T.

If lGrade .And. !Empty(&(ReadVar()))
	PRIVATE oGrade	  := MsMatGrade():New('oGrade',,"D2_QUANT",,"ALocVldGrd()",,;
	{{"D2_QUANT"  ,.T. , {{"D2_QTSEGUM",{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),aCols[nLinha][nColuna],0,2) } }} },;
	{"D2_PRCVEN"  ,NIL ,NIL},;
	{"D2_ITEM"	 ,NIL ,NIL},;
	{"D2_QTSEGUM",NIL , {{"D2_QUANT",{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),0,aCols[nLinha][nColuna],1) }}} };
	})

	cProdRef := &(ReadVar())
	lReferencia := MatGrdPrrf(@cProdRef)
	If lReferencia
		If N >= Len(aCols) .And. Empty(aCols[Len(aCols)][nPosProd])
			oGrade:MontaGrade(1,cProdRef,.T.,,lReferencia,.T.)
			oGrade:nPosLinO := 1
			oGrade:cProdRef	:= cProdRef
			oGrade:lShowMsgDiff := .F. // Desliga apresentacao do "A410QTDDIF"
			cItem    := aCols[nSaveN][nPosItem]
			nNewItem := Len(aCols)
			lAadd    := .F.

			DEFINE MSDIALOG oDlg TITLE STR0255 OF oMainWnd PIXEL FROM 000,000 TO 220,520  //"Interface para Grade de Produtos"

			@ 025,010 BUTTON STR0256 SIZE 70,15 FONT oDlg:oFont ACTION ;
			{|| __READVAR:="M->D2_QUANT"  ,M->D2_QUANT  := 0,cCpoName := StrTran(ReadVar(),"M->",""),oGrade:Show(cCpoName) } OF oDlg PIXEL //"Qtde"
			@ 045,010 BUTTON STR0257 SIZE 70,15 FONT oDlg:oFont ACTION ;
			{|| __READVAR:="M->D2_PRCVEN"  ,M->D2_PRCVEN  := 0,cCpoName := StrTran(ReadVar(),"M->",""),oGrade:Show(cCpoName) } OF oDlg PIXEL //"Valor Unitário"
			@ 065,010 BUTTON STR0258 SIZE 70,15 FONT oDlg:oFont ACTION ;
			{|| __READVAR:="M->D2_QTSEGUM",M->D2_QTSEGUM:= 0,cCpoName := StrTran(ReadVar(),"M->",""),oGrade:Show(cCpoName) } OF oDlg PIXEL //"Segunda Und Medida"

			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||oDlg:End()},{||oDlg:End()}) CENTERED
			//Somente realiza a carga do item para o aCols se pelo menos uma celula do D2_QUANT contiver valor.
			If oGrade:SomaGrade("D2_QUANT",oGrade:nPosLinO,oGrade:nQtdInformada) > 0
				For nLinX := 1 To Len(oGrade:aColsGrade[1])
					For nColY := 2 To Len(oGrade:aHeadGrade[1])
						If oGrade:aColsFieldByName("D2_QUANT",1,nLinX,nColY) <> 0
							//Faz a montagem de uma nova linha em branco no aCols para
							//adicionar novos itens vindos das celulas da Grade.
							If lAadd
								aadd(aCols,Array(Len(aHeader)+1))
								nNewItem := Len(aCols)
								cNewItem := StrZero(nNewItem,Len(SD2->D2_ITEM))
								For nY := 1 to Len(aHeader)
									If Trim(aHeader[nY][2]) == "D2_ITEM"
										aCols[nNewItem][nY] := cNewItem
									ElseIf IsHeadRec(aHeader[nY][2])
										aCols[nNewItem][nY] := 0
									ElseIf IsHeadAlias(aHeader[nY][2])
										aCols[nNewItem][nY] := "SD2"
									Else
										aCols[nNewItem][nY] := CriaVar(aHeader[nY][2])
									EndIf
									aCols[nNewItem][Len(aHeader)+1] := .F.
								Next nY
							EndIf

							N := nNewItem
							aCols[nNewItem][nPosProd]:= PadR(oGrade:GetNameProd(cProdRef,nLinX,nColY),Len(SD2->D2_COD))

							M->D2_COD := aCols[nNewItem][nPosProd]
							MaFisRef("IT_PRODUTO","MT100",M->D2_COD)
							A920IniCpo()

							aCols[nNewItem][nPosQuant]:= oGrade:aColsFieldByName("D2_QUANT",1,nLinX,nColY)
							M->D2_QUANT := oGrade:aColsFieldByName("D2_QUANT",1,nLinX,nColY)
							A100SegUm()
							MaFisRef("IT_QUANT","MT100",M->D2_QUANT)

							aCols[nNewItem][nPosQtSegum]:= oGrade:aColsFieldByName("D2_QTSEGUM",1,nLinX,nColY)
							M->D2_QTSEGUM := oGrade:aColsFieldByName("D2_QTSEGUM",1,nLinX,nColY)
							A100SegUm()

							aCols[nNewItem][nPosVUnit]:= oGrade:aColsFieldByName("D2_PRCVEN",1,nLinX,nColY)
							M->D2_PRCVEN := oGrade:aColsFieldByName("D2_PRCVEN",1,nLinX,nColY)
							MaFisRef("IT_PRCUNI","MT100",M->D2_PRCVEN)

							aCols[nNewItem][nPosTotal]:= NoRound(aCols[nNewItem][nPosQuant] * aCols[nNewItem][nPosVUnit],nTD2_TOTAL)
							M->D2_TOTAL := aCols[nNewItem][nPosTotal]
							A920Total(M->D2_TOTAL)
							MaFisRef("IT_VALMERC","MT100",M->D2_TOTAL)

							If !lAadd
                                cPrdOrig := aCols[nNewItem][nPosProd]
								lAadd := .T.
							Endif
						EndIf
					Next nColY
				Next nLinX
			Else
				lRet := .F.
			EndIf
			N := nSaveN
			__READVAR   := cSaveReadVar
            M->D2_COD   := cPrdOrig

			If cPaisLoc <> "BRA"
				AtuLoadQt(.T.)
			EndIf
		Else
			Help(" ",1,"AlocPRDGRD")
			lRet := .F.
		EndIf
	Else
		dbSelectArea("SB1")
		dbSetOrder(1)
		If !MsSeek(xFilial("SB1")+cProdRef,.F.)
			Help("  ",1,"REGNOIS")
			lRet := .F.
		EndIf
		If lRet
			MaFisRef("IT_PRODUTO","MT100",M->D2_COD)
			A920IniCpo()
		Endif
	EndIf
Else
	lRet := ExistCpo("SB1")
	If lRet
		MaFisRef("IT_PRODUTO","MT100",M->D2_COD)
		A920IniCpo(lDo)
	Endif
EndIf
RestArea(aArea)
Return(lRet)

Function LocProvEnt()
Local lRet:=.T.
lRet:=LocProvEn2t()
Return (lRet)

Function LocProEnIt()
Local lRet		:= .T.
lRet:=LocProEnI2t()
Return(lRet)

Function LocProvTes()
Local lRet		:= .T.
lRet:=LocProvTe2s()
Return lRet

Function VerProEnIt(cProv,cTes,lMsg,lVerPro)
Local lRet:=.T.
Default lMsg := .T.
Default lVerPro := .T.
lRet:=VerProEnI2t(cProv,cTes,lMsg,lVerPro)
Return(lRet)

Function LocEmisPro()
Local lRet:=.T.
lRet:=LocEmisPr2o()
Return(lRet)
/*Funcion LOCXATUBASE Funcao para limpar aCols en caso que el %BASE sea modificado.  º±±*/
Function LOCXATUBASE(aHeader,aCols)
Local cVarCont	:= Right(aCfgNF[5],2)+"_ITEM"   // aCfgNF[SAliasCols]
Local cItem		:= ""
Local nX		:= 0
Local lDel		:=.T.
Local nLin		:= 1
If Len(aCols) > 0 .and. !Empty(aCols[1][2])
	aCols := {}
	MaFisClear()
	aAdd(aCols,Array(Len(aHeader)+1))
	For nX := 1 to Len(aHeader)
		If Trim(aHeader[nX][2]) == cVarCont
			cVarCont := aCfgNF[5]+"->"+cVarCont  // aCfgNf[SAliasCols]
			aCols[Len(aCols)][nX] 	:= IIF(cItem<>Nil .AND. !Empty(cItem),cItem,StrZero(1,Len(&cVarCont)))
		Else//If ( aHeader[nX][10] <> "V")   // existem campos vituais que devem aparecer na tela exp. Tipo de Operacao
			aCols[Len(aCols)][nX] := CriaVar(aHeader[nX][2],.T.)
		EndIf
		aCols[Len(aCols)][Len(aHeader)+1] := .F.
	Next nX
	oGetDados:Refresh()
    // Limpa Tela de Qtd. Total dos Produtos
    lDel := Iif(Len(oBSomaItens:AARRAY)>0,.T.,.F.)
	While lDel
		nLin:= Len(oBSomaItens:AARRAY)
		If Len(oBSomaItens:AARRAY) == 1
			oBSomaItens:AARRAY[nLin,1] := ''
			oBSomaItens:AARRAY[nLin,2] := 0
			lDel:=.F.
		Else
			Adel(oBSomaItens:AARRAY,nLin)
			ASize(oBSomaItens:AARRAY,Len(oBSomaItens:AARRAY)-1)
		EndIf
	EndDo
	nTotQtIte:= 0
	oBSomaItens:Refresh()
	ModxAtuObj()
EndIf
Return

/*{Protheus.doc} RUXXTS01
@return character cRet
@description Returns counteragent atribute by alias, if it is some subdivision*/
Function RUXXTS01(cFieldName as character, cAliasP as character)
Local cRet := ""
If cAliasP == "A1_"
    If (SA1->A1_TIPO == "3")
	  cRet := Posicione('AI0',1,xFilial('AI0') + SA1->A1_COD + SA1->A1_LOJA, 'AI0_'+cFieldName)
    EndIf
 else
    If (SA2->A2_TIPO == "3")
	   cRet := SA2-> &("A2_"+cFieldName)
    EndIf
 EndIf
Return(cRet)
/*{Protheus.doc} RUXXTS02
@description Returns *_NREDUZ(short name) of Head Office if counteragent is a subdivision
*/
Function RUXXTS02(cAliasP as character,cNametab as character)
Local cRet := ""
   If  &(cNametab + "->" + cAliasP +"TIPO")=="3"
	   cRet := Posicione(cNametab,1,xFilial(cNametab) + RUXXTS01('HEAD',cAliasP) + RUXXTS01('HEADUN',cAliasP),cAliasP + "NREDUZ")
   Endif
Return(cRet)

/*{Protheus.doc} RUXXTS03_FullAdrOffice
@description Returns AGA->AGA_FULL address or empty string if none
*/
Static Function RUXXTO03_FullAdrOffice(cAliasP as character, cKeyP as character, cTipo as character)
Local cRet := ""
Local cQuery := ""
Local cAgaFull := ""
Local cTab := ""
if (!empty(cAliasP) .and. !empty(cKeyP) .and. !empty(cTipo))

	cQuery := " SELECT AGA.*, AGA.R_E_C_N_O_ AS AGAREC FROM " + RetSqlName("AGA") + " AGA "
	cQuery += " WHERE AGA_FILIAL = '"+xFilial("AGA")+"'"
	cQuery += " AND AGA_ENTIDA = '" + cAliasP + "'"
	cQuery += " AND AGA_CODENT = '" + cKeyP + "'"
	cQuery += " AND AGA_TIPO = '" + cTipo + "'"
	cQuery += " AND '" + DtoS(dDatabase) + "' BETWEEN AGA_FROM AND AGA_TO"
	cQuery += " AND D_E_L_E_T_ = ' ' "
	cTab := MPSysOpenQuery(cQuery)

	If (cTab)->(!EOF())
		AGA->(dbGoTo((cTab)->AGAREC))
		cAgaFull	:= AGA->AGA_FULL

		If !Empty(cAgaFull)
			cRet := cAgaFull
		EndIf
	EndIf

	(cTab)->( dbCloseArea() )
EndIf
Return(cRet)

/*{Protheus.doc} RUXXTS03
@return character cRet
@use RUXXTO03_FullAdrOffice()
@description Returns  postal address if flag 2,
                      legal address head office if flag 0 and A*_tipo = 3,
                      legal address if flag 0 and A*_tipo <> 3*/
Function RUXXTS03(cFlag as character,cAliasP as character,cNametab as character)
Local cRet as Character
   If cFlag == '0'
      If (&(cNametab + "->" + cAliasP +"TIPO")=="3")
	      cRet := RUXXTO03_FullAdrOffice(cNametab, xFilial(cNametab) + RUXXTS01('HEAD', cAliasP) + RUXXTS01('HEADUN',cAliasP),'0') //addr head office
        Else
	      cRet := RUXXTO03_FullAdrOffice(cNametab, xFilial(cNametab) + &(cNametab + "->" + cAliasP + "COD") + &(cNametab + "->" + cAliasP +"LOJA"),'0') //addr office
       Endif
    else
     cRet := RUXXTO03_FullAdrOffice(cNametab, xFilial(cNametab) + &(cNametab + "->" + cAliasP + "COD") + &(cNametab + "->" + cAliasP +"LOJA"),'2') // postal
   EndIf
Return(cRet)

/*{Protheus.doc} ExcRt101N
@return lRet
@description called by validation in Currency Rate to update all the item lines and header when the end user changes currency rate (for Inflow Invoice)
*/
Function ExcRt101N()
local lRet as logical
Local nPosImp := aScan(aHeader,{|x| AllTrim(x[2]) == ('D1_VALIMP1')} )
Local nPosBas := aScan(aHeader,{|x| AllTrim(x[2]) == ('D1_BASIMP1')} )
Local nPosTot := aScan(aHeader,{|x| AllTrim(x[2]) == ('D1_TOTAL')} )
//Local nPosBrut := aScan(aHeader,{|x| AllTrim(x[2]) == ('D1_VALBRUT')} )
Local nPosTotM := aScan(aHeader,{|x| AllTrim(x[2]) == ('D1_TOTALM')} )
Local nPosBrutM := aScan(aHeader,{|x| AllTrim(x[2]) == ('D1_VLBRUTM')} )
Local nPosBsIM := aScan(aHeader,{|x| AllTrim(x[2]) == ('D1_BSIMP1M')} )
Local nPosVlIM := aScan(aHeader,{|x| AllTrim(x[2]) == ('D1_VLIMP1M')} )
Local nTxMoe := M->F1_TXMOEDA
//Local dEmissao := M->F1_EMISSAO
Local nI as numeric
Local nVlImp1M as numeric
Local nBsImp1M as numeric
Local nTotalM as numeric
Local nBrutM as numeric
nVlImp1M :=	0
nBsImp1M :=	0
nTotalM :=	0
nBrutM	:=	0
For nI := 1 To Len(aCols)
	aCols[nI][nPosTotM] :=	Round(aCols[nI][nPosTot] * nTxMoe,2)
	aCols[nI][nPosBsIM] := 	Round(aCols[nI][nPosBas] * nTxMoe,2)
	aCols[nI][nPosVlIM] := 	Round(aCols[nI][nPosImp] * nTxMoe,2)
	aCols[nI][nPosBrutM] :=	aCols[nI][nPosBsIM] + aCols[nI][nPosVlIM]

	nVlImp1M += aCols[nI][nPosVlIM]
	nBsImp1M += aCols[nI][nPosBsIM]
	nTotalM += aCols[nI][nPosTotM]
	nBrutM += aCols[nI][nPosBrutM]
Next nI
M->F1_VLIMP1M := nVlImp1M
M->F1_BSIMP1M := nBsImp1M
M->F1_VLBRUTM := nBrutM
M->F1_VLMERCM := nTotalM
MaFisRef("NF_BASEIV1_C1","MT100",nBsImp1M)
MaFisRef("NF_VALIV1_C1","MT100",nVlImp1M)
MaFisRef("NF_VALMERC_C1","MT100",nTotalM)
MaFisRef("NF_TOTAL_C1","MT100",nBrutM)
If !IsBlind()
	aoSbx[1]:Refresh()
EndIf
lRet := .T.
return lRet

/*{Protheus.doc} ExcRt467N
@return lRet
@description called by validation in Currency Rate to update all the item lines and header when the end user changes currency rate (for Outflow Invoice)
*/
Function ExcRt467N()
local lRet as logical
Local nPosImp := aScan(aHeader,{|x| AllTrim(x[2]) == ('D2_VALIMP1')} )
Local nPosBas := aScan(aHeader,{|x| AllTrim(x[2]) == ('D2_BASIMP1')} )
Local nPosTot := aScan(aHeader,{|x| AllTrim(x[2]) == ('D2_TOTAL')} )
//Local nPosBrut := aScan(aHeader,{|x| AllTrim(x[2]) == ('D2_VALBRUT')} )
Local nPosTotM := aScan(aHeader,{|x| AllTrim(x[2]) == ('D2_TOTALM')} )
Local nPosBrutM := aScan(aHeader,{|x| AllTrim(x[2]) == ('D2_VLBRUTM')} )
Local nPosBsIM := aScan(aHeader,{|x| AllTrim(x[2]) == ('D2_BSIMP1M')} )
Local nPosVlIM := aScan(aHeader,{|x| AllTrim(x[2]) == ('D2_VLIMP1M')} )
Local nTxMoe := M->F2_TXMOEDA
//Local dDigit := M->F2_DTDIGIT
Local nI as numeric
Local nVlImp1M as numeric
Local nBsImp1M as numeric
Local nTotalM as numeric
Local nBrutM as numeric

nVlImp1M :=	0
nBsImp1M :=	0
nTotalM :=	0
nBrutM	:=	0
For nI := 1 To Len(aCols)
	aCols[nI][nPosTotM] :=	Round(aCols[nI][nPosTot] * nTxMoe,2)
	aCols[nI][nPosBsIM] := 	Round(aCols[nI][nPosBas] * nTxMoe,2)
	aCols[nI][nPosVlIM] := 	Round(aCols[nI][nPosImp] * nTxMoe,2)
	aCols[nI][nPosBrutM] :=	aCols[nI][nPosBsIM] + aCols[nI][nPosVlIM]

	nVlImp1M += aCols[nI][nPosVlIM]
	nBsImp1M += aCols[nI][nPosBsIM]
	nTotalM += aCols[nI][nPosTotM]
	nBrutM += aCols[nI][nPosBrutM]
Next nI
M->F2_VLIMP1M := nVlImp1M
M->F2_BSIMP1M := nBsImp1M
M->F2_VLBRUTM := nBrutM
M->F2_VLMERCM := nTotalM
MaFisRef("NF_BASEIV1_C1","MT100",nBsImp1M)
MaFisRef("NF_VALIV1_C1","MT100",nVlImp1M)
MaFisRef("NF_VALMERC_C1","MT100",nTotalM)
MaFisRef("NF_TOTAL_C1","MT100",nBrutM)
If !IsBlind()
	aoSbx[1]:Refresh()
EndIf
lRet := .T.
return lRet
// Russia_R5

/*Funcion UpdValImp usada para validacion de tamano de campos y actualizacion a usado*/
Function UpdValImp()
	If  FindFunction("Upd2ValImp")
		Upd2ValImp()
	Else
		Help("",1,"Upd2ValImp",,STR0430 + "Upd2ValImp()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return


Function ValCposRG3668()
Local lRet    := .T.
	If  FindFunction("ValCpoRG3668")
		lRet := ValCpoRG3668()
	Else
		Help("",1,"ValCpoRG3668",,STR0430 + "ValCpoRG3668()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return(lRet)

/*
±±ºDesc.     ³Validacao do Codigo de Barras da Nota Fical                 º±±
±±ºParametros³ cAlias        - Alias do Arquivo (SF1,SF2)                 º±±
±±º          ³ cTexto        - Codigo de Barras                           º±±
±±º          ³ lValidaDv     - Se valida o DV do Codigo de Barras         º±±
±±º          ³ cFieldSERIE   - Memoria do Campo SERIE                     º±±
±±º          ³ cFieldESPECIE - Memoria do Campo ESPECIE                   º±±
±±ºUso       ³ Validacao do codigo de barras X Campos da Tela             º±±*/
Function LocxChkCB(cTexto, lValidaDv, cFieldESPECIE)
Local lValido		:= .F.
DEFAULT lValidaDV	:= .T.
	If  FindFunction("LocxCh2kCB")
		lValido := LocxCh2kCB(cTexto, lValidaDv, cFieldESPECIE)
	Else
		Help("",1,"LocxCh2kCB",,STR0430 + "LocxCh2kCB()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return lValido

/*
±±ºDesc.     ³Rotina para buscar o numero do documento quando usa impressoº±±
±±º          ³ra fiscal Hasar (Loc. Argentina)                            º±±
*/
Function GetNumCFis(cSerie,cEspecie)
Local cNumNota := ""
	If  FindFunction("GetNum2CFis")
		cNumNota := GetNum2CFis(cSerie,cEspecie)
	Else
		Help("",1,"GetNum2CFis",,STR0430 + "GetNum2CFis()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return(cNumNota)

Function LocXTipSer(cAlias,cTipoDoc)
Local cCodSerie  := "   "
	If  FindFunction("LocX2TipSer")
		cCodSerie := LocX2TipSer(cAlias,cTipoDoc)
	Else
		Help("",1,"LocX2TipSer",,STR0430 + "LocX2TipSer()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return (cCodSerie)

/*
±±ºDesc.     ³Selecao do Fornec.                                             º±±
±±º          ³Todos os Fornec.es listados possuem o mesmo CGC.               º±±
±±ºUso       ³ Selecao de Fornec., caso exista mais de um fornec. com        º±±
±±º          ³ o mesmo CGC da NF.                                    		 º±±*/
Function LocxSELCLI( cCGC)
Local aCliente	:= {}
	If  FindFunction("Locx2SELCLI")
		aCliente := Locx2SELCLI( cCGC)
	Else
		Help("",1,"Locx2SELCLI",,STR0430 + "Locx2SELCLI()",1,0) //"Rutina desatualizada, solicite paquete con actualizaciones:"
	Endif
Return aCliente

