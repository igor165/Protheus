#INCLUDE "FATA010.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "PROTHEUS.CH"
#DEFINE NMAX 300 
 
/*/


Ŀ
Program   FATA010    Autor Vendas & CRM            Data 20.01.2012  
Ĵ
Descrio Cadastro de Processo de Vendas.                               
Ĵ
Retorno   Nenhum                                                        
Ĵ
ParametrosNenhum                                                        
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                       
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                     
Ĵ
ٱ


/*/
Function Fata010()

Local oTableAtt := TableAttDef()

PRIVATE cCadastro := OemToAnsi(STR0001) //"Processo de Venda"
PRIVATE aRotina	  := MenuDef()


DEFINE FWMBROWSE oMBrowse ALIAS "AC1" DESCRIPTION STR0001 //"Processo de Venda"		
		oMBrowse:SetAttach( .T. ) 				  //Habilita as vises do Browse
		oMBrowse:SetViewsDefault( oTableAtt:aViews )
		//Se no for SIGACRM inibe a exibio do grfico
		If nModulo <> 73
			oMBrowse:SetOpenChart( .F. )
		EndIf 
		
		oMBrowse:SetTotalDefault('AC1_FILIAL','COUNT',STR0020) // "Total de Registros"
ACTIVATE FWMBROWSE oMBrowse

Return(.T.)


//------------------------------------------------------------------------------
/*/	{Protheus.doc} TableAttDef

Cria as vises e grficos.

@sample	TableAttDef()

@param		Nenhum

@return	ExpO - Objetos com as Visoes e Grficos.

@author	Cristiane Nishizaka
@since		28/04/2014
@version	12
/*/
//------------------------------------------------------------------------------
Static Function TableAttDef()

Local oTableAtt 	:= FWTableAtt():New()
Local oAtivos		:= Nil // Processos de Venda Ativos
Local oInativos		:= Nil // Processos de Venda Inativos

oTableAtt:SetAlias("AC1")

// Processos de Venda Ativos
oAtivos := FWDSView():New()
oAtivos:SetName(STR0022) // "Processos de Venda Ativos"
oAtivos:SetID("Ativos") 
oAtivos:SetOrder(1) // AC1_FILIAL+AC1_PROVEN
oAtivos:SetCollumns({"AC1_PROVEN","AC1_DESCRI","AC1_DTOTAL","AC1_HTOTAL"})
oAtivos:SetPublic( .T. )
oAtivos:AddFilter(STR0022, "AC1_MSBLQL == '2'") // "Processos de Venda Ativos"

oTableAtt:AddView(oAtivos)

// Processos de Venda Inativos
oInativos := FWDSView():New()
oInativos:SetName(STR0021) // "Processos de Venda Inativos"
oInativos:SetID("Inativos") 
oInativos:SetOrder(1) // AC1_FILIAL+AC1_PROVEN
oInativos:SetCollumns({"AC1_PROVEN","AC1_DESCRI","AC1_DTOTAL","AC1_HTOTAL"})
oInativos:SetPublic( .T. )
oInativos:AddFilter(STR0021, "AC1_MSBLQL == '1'") // "Processos de Venda Inativos"

oTableAtt:AddView(oInativos)

Return (oTableAtt)

/*/


Ŀ
Programa  MenuDef    Autor  Vendas & CRM           Data 01/09/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          	  1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function MenuDef()
     
Local nSize	:= 0

PRIVATE aRotina := {}


ADD OPTION aRotina Title STR0002 Action 'PesqBrw'			 OPERATION 1 ACCESS 0 //"Pesquisar"
ADD OPTION aRotina Title STR0003 Action 'VIEWDEF.FATA010' OPERATION 2 ACCESS 0 //"Visualizar"
ADD OPTION aRotina Title STR0004 Action 'VIEWDEF.FATA010' OPERATION 3 ACCESS 0 //"Incluir"
ADD OPTION aRotina Title STR0005 Action 'VIEWDEF.FATA010' OPERATION 4 ACCESS 0 //"Alterar"
ADD OPTION aRotina Title STR0006 Action 'VIEWDEF.FATA010' OPERATION 5 ACCESS 0 //"Excluir"    

If !Empty( Select( "AC9" ) ) 
	AAdd( aRotina, { STR0013,"MsDocument",0,7,0,NIL} ) //Conhecimento
EndIf 	

//Retira acoes de inclusao, alteracao e exclusao quando o MenuDef for acionado pelo Pipeline
If IsInCallStack("FATC020")
	nSize := Len(aRotina)
	aDel(aRotina,5)
	aDel(aRotina,4)
	aDel(aRotina,3)
	aSize(aRotina,nSize-3)
EndIf
    
aRotina:= CRMXINCROT("AC1",aRotina)

If ExistBlock("FT010MNU")
	ExecBlock("FT010MNU",.F.,.F.)
EndIf

Return(aRotina)

/*/


Ŀ
Funcao    ViewDef      Autor Vendas & CRM            Data  16/01/12 
Ĵ
Descrio  Definicao da View                                          	
Ĵ
Retorno    oView                                                       	
Ĵ
Parametros Nenhum														
ٱ


/*/
Static Function ViewDef()
Local oModel   := FWLoadModel( 'FATA010' )	// Cria um objeto de Modelo de dados baseado no ModelDef do fonte informado
Local oStruAC1 := FWFormStruct( 2, 'AC1' )	// Cria as estruturas a serem usadas na View
Local oStruAC2 := FWFormStruct( 2, 'AC2' ) // Cria as estruturas a serem usadas na View
Local oStruACZ := FWFormStruct( 2, 'ACZ' ) // Cria as estruturas a serem usadas na View
Local oView									// Interface de visualizao construda
Local aUsrMemo := If( ExistBlock( "FT010MEM" ), ExecBlock( "FT010MEM", .F.,.F. ), {} ) //Memos de Usurio
Local nLoop	   := 1 

                 
oStruAC2:SetProperty("AC2_STAGE",MVC_VIEW_CANCHANGE,.F.)

oStruAC1:RemoveField("AC1_CODMEM")
oStruAC2:RemoveField("AC2_CODMEM")  

If ValType( aUsrMemo ) == "A" .And. Len( aUsrMemo ) > 0
	For nLoop := 1 to Len( aUsrMemo )
		If aUsrMemo[ nLoop, 1 ] == "AC1"
			oStruAC1:RemoveField(aUsrMemo[ nLoop, 2 ])			
		ElseIf aUsrMemo[ nLoop, 1 ] == "AC2"
			oStruAC2:RemoveField(aUsrMemo[ nLoop, 2 ])
		EndIf
	Next nLoop
EndIf
 
oView := FWFormView():New()								// Cria o objeto de View
oView:SetContinuousForm()
oView:SetModel( oModel )									// Define qual Modelo de dados ser utilizado				
oView:AddField( 'VIEW_AC1', oStruAC1, 'AC1MASTER' )	// Adiciona no nosso View um controle do tipo formulrio (antiga Enchoice)
oView:AddGrid( 'VIEW_AC2' , oStruAC2, 'AC2DETAIL' )	// Adiciona no nosso View um controle do tipo Grid (antiga Getdados)
oView:AddGrid( 'VIEW_ACZ' , oStruACZ, 'ACZDETAIL' )	// Adiciona no nosso View um controle do tipo Grid (antiga Getdados)
oView:AddIncrementField( 'VIEW_AC2', 'AC2_STAGE' )		// Item Incremental do Grid
oView:AddIncrementField( 'VIEW_ACZ', 'ACZ_ITEM' )		// Item Incremental do Grid

If nModulo == 73
	oView:AddUserButton( STR0019, "",{ |oView| CRMA090( "AC1", AC1->( RECNO() ) ) },,,{MODEL_OPERATION_VIEW,MODEL_OPERATION_UPDATE} )  //"Anotaes"
EndIf

oView:CreateHorizontalBox( 'SUPERIOR'  , 30 )
oView:CreateHorizontalBox( 'INFERIOR'  , 70 )
//Cria pastas
oView:CreateFolder('PASTAS','INFERIOR')

oView:AddSheet( 'PASTAS', 'ABA01', STR0014) // Estagios
oView:AddSheet( 'PASTAS', 'ABA02', STR0015) // Regras

// Cria um "box" horizontal para receber cada elemento da view			
oView:CreateHorizontalBox( 'ABAS1'  , 100,,, 'PASTAS', 'ABA01' )	//Estagios
oView:CreateHorizontalBox( 'ABAS2' ,  100,,, 'PASTAS', 'ABA02' )	//Regras

// Relaciona o identificador (ID) da View com o "box" para exibio
oView:SetOwnerView( 'VIEW_AC1', 'SUPERIOR' )		
oView:SetOwnerView( 'VIEW_AC2', 'ABAS1' )
oView:SetOwnerView( 'VIEW_ACZ', 'ABAS2' )

Return oView

/*/


Ŀ
Funcao    ModelDef     Autor Vendas & CRM            Data  16/01/12 
Ĵ
Descrio  Definicao do Model                                         	
Ĵ
Retorno    oModel                                                      	
Ĵ
Parametros Nenhum														
ٱ


/*/
Static Function ModelDef()
 
// Cria as estruturas a serem usadas no Modelo de Dados
Local oStruAC1 := FWFormStruct( 1, 'AC1' )
Local oStruAC2 := FWFormStruct( 1, 'AC2' )
Local oStruACZ := FWFormStruct( 1, 'ACZ' )
Local oModel // Modelo de dados construdo
Local aUsrMemo := If( ExistBlock( "FT010MEM" ), ExecBlock( "FT010MEM", .F.,.F. ), {} ) //Memos de Usurio 
Local aMemoAC1 := { { 'AC1_CODMEM' , 'AC1_MEMO' } }
Local aMemoAC2 := { { 'AC2_CODMEM' , 'AC2_MEMO' } }
Local nLoop	 := 1
Local bCond	 := {||.T.}						// Condicao para soma.
Local aAux		:= {}
Local bCommit := { |oModel| FT010Cmt( oModel ) }
                           

// Campo para converter a hora em inteiro para somar o total de horas do processo de vendas      
oStruAC2:AddField(	AllTrim(STR0016)	,;  	// [01] C Titulo do campo
					AllTrim(STR0016)	,;   	// [02] C ToolTip do campo
     				"AC2_HRINT" 		,;    	// [03] C identificador (ID) do Field
         			"N" 				,;    	// [04] C Tipo do campo
            		5 					,;    	// [05] N Tamanho do campo
              		2 					,;    	// [06] N Decimal do campo
                	Nil 				,;    	// [07] B Code-block de validao do campo
                 	Nil					,;     	// [08] B Code-block de validao When do campo
                  	Nil 				,;    	// [09] A Lista de valores permitido do campo
                   	Nil 				,;  	// [10] L Indica se o campo tem preenchimento obrigatrio
                    Nil				 	,;   	// [11] B Code-block de inicializacao do campo
                    Nil 				,;  	// [12] L Indica se trata de um campo chave
                    Nil 				,;     	// [13] L Indica se o campo pode receber valor em uma operao de update.
                    .T. )              			// [14] L Indica se o campo  virtual

//Ŀ
// Criacao da Trigger. 
//
oStruAC2:AddTrigger("AC2_HDURAC","AC2_HRINT",Nil,{|| oModel:GetModel('AC2DETAIL'):SetValue('AC2_HRINT',HoraToInt(FwFldGet('AC2_HDURAC'))),HoraToInt(FwFldGet('AC2_HDURAC'))}) 
oStruACZ:SetProperty("ACZ_STAGE", MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, "FT310VdStd()"))  	

// Cria o objeto do Modelo de Dados
oModel := MPFormModel():New( 'FATA010' , NIL, {|oModel| A010Pos(oModel)}, bCommit )

If ValType( aUsrMemo ) == "A" .And. Len( aUsrMemo ) > 0
	For nLoop := 1 to Len( aUsrMemo )
		If aUsrMemo[ nLoop, 1 ] == "AC1"
			AAdd( aMemoAC1, { aUsrMemo[ nLoop, 2 ], aUsrMemo[ nLoop, 3 ] } )			
		ElseIf aUsrMemo[ nLoop, 1 ] == "AC2"
			AAdd( aMemoAC2, { aUsrMemo[ nLoop, 2 ], aUsrMemo[ nLoop, 3 ] } )
		EndIf
	Next nLoop
EndIf

FWMemoVirtual( oStruAC1, aMemoAC1)

FWMemoVirtual( oStruAC2, aMemoAC2)

// Adiciona ao modelo um componente de formulrio
oModel:AddFields( 'AC1MASTER', /*cOwner*/, oStruAC1 )
// Adiciona ao modelo uma componente de grid
oModel:AddGrid( 'AC2DETAIL', 'AC1MASTER', oStruAC2, {|oMdlAC2,  nLine, cAction, cField, xValue, xOldValue| FT010PreAC2(oMdlAC2, nLine, cAction, cField, xValue, xOldValue)} )
// Adiciona ao modelo uma componente de grid
oModel:AddGrid( 'ACZDETAIL', 'AC1MASTER', oStruACZ , , {|oMdl| A010ACZOK(oModel,oMdl)})

//Linhas unicas dos grids
oModel:GetModel( 'AC2DETAIL' ):SetUniqueLine( { 'AC2_STAGE'} )
oModel:GetModel( 'ACZDETAIL' ):SetUniqueLine( { 'ACZ_OPER','ACZ_EVENTO'} )

//Deixa opcional adicionar itens ao ACZ
oModel:GetModel( 'ACZDETAIL'):SetOptional( .T. )
 
oModel:AddCalc("CALCPIPE","AC1MASTER","AC2DETAIL","AC2_DDURAC","AC2__DTOT","SUM",/*bCond*/,/*bInitValue*/,;
STR0017,/*bFormula*/,TamSX3("AC1_DTOTAL")[1],TamSX3("AC1_DTOTAL")[2])	// "Dias"

oModel:AddCalc("CALCPIPE","AC1MASTER","AC2DETAIL","AC2_HRINT","AC2__HTOT","SUM",/*bCond*/,/*bInitValue*/,;
STR0018,/*bFormula*/,5,2) // "Horas" 

oMdlCalc := oModel:GetModel("CALCPIPE")		
oMdlCalc:AddEvents("CALCPIPE","AC2__DTOT","AC2__HTOT",{|| Ft010TPipe(oModel) })			

// Faz relacionamento entre os componentes do model
oModel:SetRelation( 'AC2DETAIL', { { 'AC2_FILIAL', 'xFilial( "AC2" )' }, { 'AC2_PROVEN', 'AC1_PROVEN' } }, AC2->( IndexKey( 1 ) ) )
oModel:SetRelation( 'ACZDETAIL', { { 'ACZ_FILIAL', 'xFilial( "ACZ" )' }, { 'ACZ_PROVEN', 'AC1_PROVEN' } }, ACZ->( IndexKey( 1 ) ) )

// Adiciona a descrio do Modelo de Dados
oModel:SetDescription( STR0001 ) //"Processo de Venda"

oModel:SetActivate({|| Ft010HrInt(oModel) })

// Retorna o Modelo de dados
Return oModel

//-------------------------------------------------------------------
/*/{Protheus.doc} CRMA980
Valida o estgio cadastrado quando  informado na regra

@param		Nenhum

@return	lRet, logico	, Verdadeiro se o estagio existe.

@author 	Squad CRM / FAT
@version	12.1.17 / Superior
@since		09/09/2017 
/*/
//-------------------------------------------------------------------
Function FT310VdStd()

Local oModel	:= FwModelActive()
Local oMdlAC2 := oModel:GetModel("AC2DETAIL")
Local oMdlACZ	:= oModel:GetModel("ACZDETAIL")	
Local nLine	:= 0
Local lRet 	:= .T.

nLine := oMdlAC2:GetLine()
lRet  := oMdlAC2:SeekLine({{"AC2_STAGE",oMdlACZ:GetValue("ACZ_STAGE")}})
oMdlAC2:GoLine(nLine)

If !lRet
	Help(" ",1,"REGNOIS")
EndIf

Return( lRet )
 
/*/


Ŀ
Funcao    A010Pos    Autor Vendas & CRM            Data 24.01.2012
Ĵ
Descrio Funcao de validacao da linha Ok                             
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosoModel                                                      
ٱ


/*/
Function A010Pos(oModel)

Local lRet 		:= .T.
Local oModelAC2 	:= oModel:GetModel("AC2DETAIL")
Local nLoop     	:= 0
Local nTotal    	:= 0

If oModel:getOperation() == MODEL_OPERATION_DELETE
	AD1->( dbSetOrder( 5 ) ) 
	If AD1->( dbSeek( xFilial( "AD1" ) + M->AC1_PROVEN ) ) 
		lRet := .F. 
		Help( " ", 1, "FT010OPOR" ) // Este processo nao pode ser excluido pois esta em uso por uma ou mais oportunidades 
	EndIf 
EndIf
If lRet .AND. (oModel:getOperation() == MODEL_OPERATION_INSERT .OR.;
				oModel:getOperation() == MODEL_OPERATION_UPDATE .OR.;
				oModel:getOperation() == MODEL_OPERATION_DELETE)

	For nLoop := 1 To oModelAC2:Length()
		oModelAC2:GoLine(nLoop)
		If !oModelAC2:IsDeleted()
			nTotal += FwFldGet("AC2_RELEVA")
		Else 
			//Ŀ
			// Permite excluir apenas se nao estiver em uso por oportunidade
			//
			AD1->( dbSetOrder( 5 ) )
			If AD1->( dbSeek( xFilial( "AD1" ) + M->AC1_PROVEN + FwFldGet("AC2_STAGE") ) )
				Help( " ", 1, "FT010ETPUS", , FwFldGet("AC2_STAGE") ) // A etapa nao pode ser excluida pois esta em uso por uma ou mais oportunidades
				lRet := .F.
				Exit
			EndIf		
		EndIf									
	Next nLoop
	
	If lRet
		If nTotal <> 100
			Help( " ", 1, "FT010PERC" ) // O total dos percentuais de contribuicao deve somar 100 %
			lRet := .F.
		EndIf
	EndIf	
			
EndIf
	
Return lRet

/*/


Ŀ
Funcao    A010AC2OK  Autor Vendas & CRM            Data 24.01.2012
Ĵ
Descrio Funcao de validacao da linha Ok                             
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosNenhum                                                      
ٱ


/*/
Function A010ACZOK(oModel,oMdl)

Local lRetorno		:= .T.
Local aSaveLines	:= FWSaveRows()
Local oModelAC2 	:= oModel:GetModel("AC2DETAIL")
Local nCntFor 		:= 0

If FwFldGet("ACZ_ACAO") == "2" .And. Empty(FwFldGet("ACZ_STAGE"))
	Help(" ",1,"FT010LOK03")
	lRetorno := .F.
EndIf
If FwFldGet("ACZ_ACAO") $ "13" .And. !Empty(FwFldGet("ACZ_STAGE"))
	Help(" ",1,"FT010LOK04")
	lRetorno := .F.
EndIf
If FwFldGet("ACZ_ACAO") == "2" .And. !Empty(FwFldGet("ACZ_STAGE"))
	For nCntFor := 1 To oModelAC2:Length()
		oModelAC2:GoLine(nCntFor)
		lRetorno := .F.
		If ( FwFldGet("AC2_STAGE") == FwFldGet("ACZ_STAGE") )
			lRetorno := .T.
			Exit
		EndIf
	Next nCntFor
	If !lRetorno
		Help(" ",1,"FT010LOK05")
	EndIf
EndIf

FwRestRows(aSaveLines)
Return(lRetorno)


/*/


Ŀ
Funcao    Ft010Visua Autor Eduardo Riera           Data 13.01.2000
Ĵ
Descrio Funcao de Tratamento da Visualizacao                        
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpC1: Alias do arquivo                                     
          ExpN2: Registro do Arquivo                                  
          ExpN3: Opcao da MBrowse                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
26/02/2007Michel W. MoscaBops.119229 - Implementacao da funcao       
                         FillGetDados() para preencher o Acols da    
                         rotina.                                     
                                                                     
ٱ


/*/
Function Ft010Visua(cAlias,nReg,nOpcx)

Local aArea     := GetArea()
Local aStruct   := {}
Local aTitles   := { STR0014,STR0015 } //"Estagios"###"Regras"
Local aObjects  := {}
Local aPosObj   := {}
Local aSizeAut  := MsAdvSize()
Local aHeadAC2  := {}
Local aColsAC2  := {}
Local aHeadACZ  := {}
Local aColsACZ  := {}
Local bWhile    := {|| .T. }
Local cQuery    := ""
Local cAliasAC2 := "AC2"
Local cAliasACZ := "ACZ"
Local lContinua := .T.
Local lQuery    := .F.
Local lInclui   := (nOpcx == 3)
Local lAltera   := (nOpcx == 4)
Local nUsadoAC2 := 0
Local nUsadoACZ := 0
Local nCntFor   := 0
Local nOpcA     := 0
Local nGd1      := 0
Local nGd2      := 0
Local nGd3      := 0
Local nGd4      := 0
Local oGetDad1
Local oGetDad2
Local oDlg

PRIVATE aGETS   := {}
PRIVATE aTELA   := {}
PRIVATE oFolder
If Type("cCadastro") == "U" .AND. Type("aRotina") == "U"
	PRIVATE cCadastro := OemToAnsi(STR0001) //"Processo de Venda"
EndIf

dbSelectArea("AC1")
dbSetOrder(1)
//Ŀ
// Inicializa a Variaveis da Enchoice.                  
//
RegToMemory( "AC1", .F., .T. )
            

//Ŀ
//Montagem do aCols e aHeader de AC2                    
//
Ft010AC2FG(nOpcx, @aHeadAC2, @aColsAC2)


//Ŀ
//Montagem do aCols e aHeader de ACZ                    
//
Ft010ACZFG(nOpcx, @aHeadACZ, @aColsACZ)

aObjects := {} 
AAdd( aObjects, { 315,  50, .T., .T. } )
AAdd( aObjects, { 100, 100, .T., .T. } )
aInfo := { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 } 
aPosObj := MsObjSize( aInfo, aObjects, .T. ) 

DEFINE MSDIALOG oDlg TITLE cCadastro From aSizeAut[7],00 To aSizeAut[6],aSizeAut[5] OF oMainWnd PIXEL 
EnChoice( cAlias ,nReg, nOpcx, , , , , aPosObj[1], , 3 )
oFolder := TFolder():New(aPosObj[2,1],aPosObj[2,2],aTitles,{"","","",""},oDlg,,,,.T.,.F.,aPosObj[2,4]-aPosObj[2,2],aPosObj[2,3]-aPosObj[2,1])

//Ŀ
// Define as posicoes da Getdados a partir do folder    
//
nGd1 := 2
nGd2 := 2
nGd3 := aPosObj[2,3]-aPosObj[2,1]-15
nGd4 := aPosObj[2,4]-aPosObj[2,2]-4

oGetDad2 := MsNewGetDados():New(nGd1,nGd2,nGd3,nGd4,IIF(!lInclui.And.!lAltera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{||Ft010LinOk(2,oGetDad1)},"AllwaysTrue()" ,,/*alteraveis*/,/*freeze*/,NMAX,/*fieldok*/,/*superdel*/,/*delok*/,oFolder:aDialogs[2],aHeadACZ,aColsACZ)
oGetDad1 := MsNewGetDados():New(nGd1,nGd2,nGd3,nGd4,IIF(!lInclui.And.!lAltera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{||Ft010LinOk(1)},"AllwaysTrue()" ,,/*alteraveis*/,/*freeze*/,,/*fieldok*/,/*superdel*/,/*delok*/,oFolder:aDialogs[1],aHeadAC2,aColsAC2)

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||oDlg:End()},{||oDlg:End()})

If ( lQuery )
	dbSelectArea(cAliasAC2)
	dbCloseArea()
	dbSelectArea(cAliasACZ)
	dbCloseArea()
	dbSelectArea(cAlias)
EndIf
RestArea(aArea)

Return(.T.)
/*/


Ŀ
Funcao    Ft010Inclu Autor Eduardo Riera           Data 11.01.2000
Ĵ
Descrio Funcao de Tratamento da Inclusao                            
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpC1: Alias do arquivo                                     
          ExpN2: Registro do Arquivo                                  
          ExpN3: Opcao da MBrowse                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
26/02/2007Michel W. MoscaBops.119229 - Implementacao da funcao       
                         FillGetDados() para preencher o Acols da    
                         rotina.                                     
                                                                     
                                                                     
ٱ


/*/
Function Ft010Inclu(cAlias,nReg,nOpcx)

Local aArea     := GetArea()
Local aTitles   := { STR0014,STR0015 } //"Estagios"###"Regras"
Local aObjects  := {}
Local aPosObj   := {}
Local aSizeAut  := MsAdvSize()
Local aHeadAC2  := {}
Local aColsAC2  := {}
Local aHeadACZ  := {}
Local aColsACZ  := {}
Local lInclui   := (nOpcx == 3)
Local lAltera   := (nOpcx == 4)
Local nGd1      := 0
Local nGd2      := 0
Local nGd3      := 0
Local nGd4      := 0
Local nUsadoAC2 := 0
Local nUsadoACZ := 0
Local nCntFor   := 0
Local nOpcA     := 0
Local nSaveSx8  := GetSx8Len()
Local oGetDad1
Local oGetDad2
Local oDlg

PRIVATE aGETS   := {}
PRIVATE aTELA   := {}

dbSelectArea("AC1")
dbSetOrder(1)
//Ŀ
// Inicializa a Variaveis da Enchoice.                  
//
RegToMemory( "AC1", .T., .T. )

//Ŀ
//Montagem do aCols e aHeader de AC2                    
//
Ft010AC2FG(nOpcx, @aHeadAC2, @aColsAC2)

//Ŀ
//Montagem do aCols e aHeader de ACZ                    
//
Ft010ACZFG(nOpcx, @aHeadACZ, @aColsACZ)

aObjects := {} 
AAdd( aObjects, { 315,  50, .T., .T. } )
AAdd( aObjects, { 100, 100, .T., .T. } )
aInfo := { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 } 
aPosObj := MsObjSize( aInfo, aObjects, .T. ) 

DEFINE MSDIALOG oDlg TITLE cCadastro From aSizeAut[7],00 To aSizeAut[6],aSizeAut[5] OF oMainWnd PIXEL 
EnChoice( cAlias ,nReg, nOpcx, , , , , aPosObj[1], , 3 )
oFolder := TFolder():New(aPosObj[2,1],aPosObj[2,2],aTitles,{"","","",""},oDlg,,,,.T.,.F.,aPosObj[2,4]-aPosObj[2,2],aPosObj[2,3]-aPosObj[2,1])

//Ŀ
// Define as posicoes da Getdados a partir do folder    
//
nGd1 := 2
nGd2 := 2
nGd3 := aPosObj[2,3]-aPosObj[2,1]-15
nGd4 := aPosObj[2,4]-aPosObj[2,2]-4

oGetDad2 := MsNewGetDados():New(nGd1,nGd2,nGd3,nGd4,IIF(!lInclui.And.!lAltera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{||Ft010LinOk(2,oGetDad1)},"AllwaysTrue()","+ACZ_ITEM",/*alteraveis*/,/*freeze*/,NMAX,/*fieldok*/,/*superdel*/,/*delok*/,oFolder:aDialogs[2],aHeadACZ,aColsACZ)
oGetDad1 := MsNewGetDados():New(nGd1,nGd2,nGd3,nGd4,IIF(!lInclui.And.!lAltera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{||Ft010LinOk(1)},"Ft010TudOk()",,/*alteraveis*/,/*freeze*/,,/*fieldok*/,/*superdel*/,/*delok*/,oFolder:aDialogs[1],aHeadAC2,aColsAC2)

ACTIVATE MSDIALOG oDlg ;
	ON INIT EnchoiceBar(oDlg,{||nOpcA:=If(oGetDad1:TudoOk().And.oGetDad2:TudoOk().And.Obrigatorio(aGets,aTela),1,0),If(nOpcA==1,(aColsAC2:=oGetDad1:aCols,aColsACZ:=oGetDad2:aCols,oDlg:End()),Nil)},{||oDlg:End()})
If ( nOpcA == 1 )
	Begin Transaction
		Ft010Grv(1,aHeadAC2,aColsAC2,aHeadACZ,aColsACZ)
		While (GetSx8Len() > nSaveSx8 )
			ConfirmSX8()
		END
		EvalTrigger()
	End Transaction
Else
	While (GetSx8Len() > nSaveSx8 )
		RollBackSX8()
	END
EndIf	

RestArea(aArea)

Return(.T.)
/*/


Ŀ
Funcao    Ft010Alter Autor Eduardo Riera           Data 12.01.2000
Ĵ
Descrio Funcao de Tratamento da Alteracao                           
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpC1: Alias do arquivo                                     
          ExpN2: Registro do Arquivo                                  
          ExpN3: Opcao da MBrowse                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
26/02/2007Michel W. MoscaBops.119229 - Implementacao da funcao       
                         FillGetDados() para preencher o Acols da    
                         rotina.                                     
                                                                     
                                                                     
ٱ


/*/
Function Ft010Alter(cAlias,nReg,nOpcx)

Local aArea     := GetArea()
Local aStruct   := {}
Local aTitles   := { STR0014,STR0015 } //"Estagios"###"Regras"
Local aObjects  := {}
Local aPosObj   := {}
Local aSizeAut  := MsAdvSize()
Local aHeadAC2  := {}
Local aColsAC2  := {}
Local aHeadACZ  := {}
Local aColsACZ  := {}
Local bWhile    := {|| .T. }
Local cQuery    := ""
Local cAliasAC2 := "AC2"
Local cAliasACZ := "ACZ"
Local nGd1      := 0
Local nGd2      := 0
Local nGd3      := 0
Local nGd4      := 0
Local nUsadoAC2 := 0
Local nUsadoACZ := 0
Local nCntFor   := 0
Local nOpcA     := 0
Local nSaveSx8  := GetSx8Len()
Local lContinua := .T.
Local lInclui   := (nOpcx == 3)
Local lAltera   := (nOpcx == 4)
Local lQuery    := .F.
Local oGetDad1
Local oGetDad2
Local oDlg

PRIVATE aGETS   := {}
PRIVATE aTELA   := {}

dbSelectArea("AC1")
dbSetOrder(1)
lContinua := SoftLock("AC1")
If ( lContinua )
	//Ŀ
	// Inicializa a Variaveis da Enchoice.                  
	//
	RegToMemory( "AC1", .F., .T. )

	//Ŀ
	//Montagem do aCols e aHeader de AC2                    
	//
	Ft010AC2FG(nOpcx, @aHeadAC2, @aColsAC2)

	//Ŀ
	//Montagem do aCols e aHeader de ACZ                    
	//
	Ft010ACZFG(nOpcx, @aHeadACZ, @aColsACZ)

EndIf
If ( lContinua )

	aObjects := {} 
	AAdd( aObjects, { 315,  50, .T., .T. } )
	AAdd( aObjects, { 100, 100, .T., .T. } )
	aInfo := { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 } 
	aPosObj := MsObjSize( aInfo, aObjects, .T. ) 

	DEFINE MSDIALOG oDlg TITLE cCadastro From aSizeAut[7],00 To aSizeAut[6],aSizeAut[5] OF oMainWnd PIXEL 
	EnChoice( cAlias ,nReg, nOpcx, , , , , aPosObj[1], , 3 )
	oFolder := TFolder():New(aPosObj[2,1],aPosObj[2,2],aTitles,{"","","",""},oDlg,,,,.T.,.F.,aPosObj[2,4]-aPosObj[2,2],aPosObj[2,3]-aPosObj[2,1])

	//Ŀ
	// Define as posicoes da Getdados a partir do folder    
	//
	nGd1 := 2
	nGd2 := 2
	nGd3 := aPosObj[2,3]-aPosObj[2,1]-15
	nGd4 := aPosObj[2,4]-aPosObj[2,2]-4

	oGetDad2 := MsNewGetDados():New(nGd1,nGd2,nGd3,nGd4,IIF(!lInclui.And.!lAltera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{||Ft010LinOk(2,oGetDad1)},"AllwaysTrue()","+ACZ_ITEM",/*alteraveis*/,/*freeze*/,NMAX,/*fieldok*/,/*superdel*/,/*delok*/,oFolder:aDialogs[2],aHeadACZ,aColsACZ)
	oGetDad1 := MsNewGetDados():New(nGd1,nGd2,nGd3,nGd4,IIF(!lInclui.And.!lAltera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{||Ft010LinOk(1)},"Ft010TudOk()",,/*alteraveis*/,/*freeze*/,,/*fieldok*/,/*superdel*/,/*delok*/,oFolder:aDialogs[1],aHeadAC2,aColsAC2)
	
	ACTIVATE MSDIALOG oDlg ;
		ON INIT EnchoiceBar(oDlg,{||nOpca:=If(oGetDad1:TudoOk().And.oGetDad2:TudoOk().And.Obrigatorio(aGets,aTela),1,0),If(nOpcA==1,(aColsAC2:=oGetDad1:aCols,aColsACZ:=oGetDad2:aCols,oDlg:End()),Nil)},{||oDlg:End()})
	If ( nOpcA == 1 )
		Begin Transaction
			Ft010Grv(2,aHeadAC2,aColsAC2,aHeadACZ,aColsACZ)
			While (GetSx8Len() > nSaveSx8 )
				ConfirmSX8()
			END
			EvalTrigger()
		End Transaction
	Else
		While (GetSx8Len() > nSaveSx8 )
			RollBackSX8()
		END
	EndIf
EndIf

If ( lQuery )
	dbSelectArea(cAliasAC2)
	dbCloseArea()
	dbSelectArea(cAliasACZ)
	dbCloseArea()
	dbSelectArea(cAlias)
EndIf
RestArea(aArea)

Return(.T.)
/*/


Ŀ
Funcao    Ft010Exclu Autor Eduardo Riera           Data 13.01.2000
Ĵ
Descrio Funcao de Tratamento da Exclusao                            
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpC1: Alias do arquivo                                     
          ExpN2: Registro do Arquivo                                  
          ExpN3: Opcao da MBrowse                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
26/02/2007Michel W. MoscaBops.119229 - Implementacao da funcao       
                         FillGetDados() para preencher o Acols da    
                         rotina.                                     
                                                                     
                                                                     
ٱ


/*/
Function Ft010Exclu(cAlias,nReg,nOpcx)

Local aArea     := GetArea()
Local aStruct   := {}
Local aTitles   := { STR0014,STR0015 } //"Estagios"###"Regras"
Local aObjects  := {}
Local aPosObj   := {}
Local aSizeAut  := MsAdvSize()
Local aHeadAC2  := {}
Local aColsAC2  := {}
Local aHeadACZ  := {}
Local aColsACZ  := {}
Local bWhile    := {|| .T. }
Local cQuery    := ""
Local cAliasAC2 := "AC2"
Local cAliasACZ := "ACZ"
Local lContinua := .T.
Local lInclui   := (nOpcx == 3)
Local lAltera   := (nOpcx == 4)
Local nGd1      := 0
Local nGd2      := 0
Local nGd3      := 0
Local nGd4      := 0
Local nUsadoAC2 := 0
Local nUsadoACZ := 0
Local nCntFor   := 0
Local nOpcA     := 0
Local lQuery    := .F.
Local oGetDad1
Local oGetDad2
Local oDlg

PRIVATE aGETS   := {}
PRIVATE aTELA   := {}

dbSelectArea("AC1")
dbSetOrder(1)
lContinua := SoftLock("AC1")
If ( lContinua )
	//Ŀ
	// Inicializa a Variaveis da Enchoice.                  
	//
	RegToMemory( "AC1", .F., .T. )
	
	//Ŀ
	//Montagem do aCols e aHeader de AC2                    
	//
	Ft010AC2FG(nOpcx, @aHeadAC2, @aColsAC2)

	//Ŀ
	//Montagem do aCols e aHeader de ACZ                    
	//
	Ft010ACZFG(nOpcx, @aHeadACZ, @aColsACZ)
EndIf

If ( lContinua )

	aObjects := {}
	AAdd( aObjects, { 315,  50, .T., .T. } )
	AAdd( aObjects, { 100, 100, .T., .T. } )
	aInfo := { aSizeAut[ 1 ], aSizeAut[ 2 ], aSizeAut[ 3 ], aSizeAut[ 4 ], 3, 3 } 
	aPosObj := MsObjSize( aInfo, aObjects, .T. )
	
	DEFINE MSDIALOG oDlg TITLE cCadastro From aSizeAut[7],00 To aSizeAut[6],aSizeAut[5] OF oMainWnd PIXEL 
	
	EnChoice( cAlias ,nReg, nOpcx, , , , , aPosObj[1], , 3 )

	oFolder := TFolder():New(aPosObj[2,1],aPosObj[2,2],aTitles,{"","","",""},oDlg,,,,.T.,.F.,aPosObj[2,4]-aPosObj[2,2],aPosObj[2,3]-aPosObj[2,1])

	//Ŀ
	// Define as posicoes da Getdados a partir do folder    
	//
	nGd1 := 2
	nGd2 := 2
	nGd3 := aPosObj[2,3]-aPosObj[2,1]-15
	nGd4 := aPosObj[2,4]-aPosObj[2,2]-4

	oGetDad2 := MsNewGetDados():New(nGd1,nGd2,nGd3,nGd4,IIF(!lInclui.And.!lAltera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{||Ft010LinOk(2,oGetDad1)},"AllwaysTrue()" ,"+ACZ_ITEM",/*alteraveis*/,/*freeze*/,NMAX,/*fieldok*/,/*superdel*/,/*delok*/,oFolder:aDialogs[2],aHeadACZ,aColsACZ)
	oGetDad1 := MsNewGetDados():New(nGd1,nGd2,nGd3,nGd4,IIF(!lInclui.And.!lAltera,0,GD_INSERT+GD_UPDATE+GD_DELETE),{||Ft010LinOk(1)},"Ft010TudOk()" ,,/*alteraveis*/,/*freeze*/,,/*fieldok*/,/*superdel*/,/*delok*/,oFolder:aDialogs[1],aHeadAC2,aColsAC2)

	ACTIVATE MSDIALOG oDlg ;
		ON INIT EnchoiceBar(oDlg,{||nOpca:=If(oGetDad1:TudoOk().And.oGetDad2:TudoOk(),1,0),If(nOpcA==1,(aColsAC2:=oGetDad1:aCols,aColsACZ:=oGetDad2:aCols,oDlg:End()),Nil)},{||oDlg:End()})

	If ( nOpcA == 1 )
		Begin Transaction
			If Ft010DelOk()
				Ft010Grv(3,aHeadAC2,aColsAC2,aHeadACZ,aColsACZ)
				EvalTrigger()
			EndIf				
		End Transaction
	EndIf
EndIf

If ( lQuery )
	dbSelectArea(cAliasAC2)
	dbCloseArea()
	dbSelectArea(cAliasACZ)
	dbCloseArea()
	dbSelectArea(cAlias)
EndIf
RestArea(aArea)

Return(.T.)
/*/


Ŀ
Funcao    Ft010LinOk Autor Eduardo Riera           Data 11.01.2000
Ĵ
Descrio Funcao de validacao da linha Ok                             
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosNenhum                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function Ft010LinOk(nGetDad,oGDStage)

Local lRetorno:= .T.
Local nPStage := aScan(aHeader,{|x| AllTrim(x[2])=="AC2_STAGE"})
Local nPDescri:= aScan(aHeader,{|x| AllTrim(x[2])=="AC2_DESCRI"})
Local nPStageR:= aScan(aHeader,{|x| AllTrim(x[2])=="ACZ_STAGE"})
Local nPEvento:= aScan(aHeader,{|x| AllTrim(x[2])=="ACZ_EVENTO"})
Local nPOper  := aScan(aHeader,{|x| AllTrim(x[2])=="ACZ_OPER"})
Local nPAcao  := aScan(aHeader,{|x| AllTrim(x[2])=="ACZ_ACAO"})
Local nCntFor := 0
Local aColsSt := {}
Local aHeadSt := {}
Local nUsado  := Len(aHeader)

If nGetDad == 1
	If ( !aCols[n][nUsado+1] )
		//Ŀ
		//Veririca os campos obrigatorios                               
		//
		If ( nPStage == 0 .Or. nPDescri == 0 )
			Help(" ",1,"OBRIGAT")
			lRetorno := .F.
		EndIf
		If ( lRetorno .And. (Empty(aCols[n][nPStage]) .Or. Empty(aCols[n][nPDescri])))
			Help(" ",1,"OBRIGAT")
			lRetorno := .F.
		EndIf
		//Ŀ
		//Verifica se nao ha estagios repitidos                         
		//
		If ( nPStage <> 0 .And. lRetorno )
			For nCntFor := 1 To Len(aCols)
				If ( nCntFor <> n .And. !aCols[nCntFor][nUsado+1])	
					If ( aCols[n][nPStage] == aCols[nCntFor][nPStage] )
						Help(" ",1,"FT010LOK01")
						lRetorno := .F.
					EndIf
				EndIf
		    Next nCntFor
		EndIf
	EndIf
ElseIf nGetDad == 2
	//Ŀ
	//Verifica se nao ha operacao+evento repetidos 
	//
	If ( nPOper <> 0 .And. nPEvento <> 0 .And. lRetorno )
		For nCntFor := 1 To Len(aCols)
			If ( nCntFor <> n .And. !aCols[nCntFor][nUsado+1])
				If ( aCols[n][nPOper]+aCols[n][nPEvento] == aCols[nCntFor][nPOper]+aCols[nCntFor][nPEvento] )
					Help(" ",1,"FT010LOK02")
					lRetorno := .F.
				EndIf
			EndIf
	    Next nCntFor
	EndIf
	If ( nPAcao <> 0 .And. nPStageR <> 0 .And. lRetorno )
		If aCols[n][nPAcao] == "2" .And. Empty(aCols[n][nPStageR])
			Help(" ",1,"FT010LOK03")
			lRetorno := .F.
		EndIf
		If aCols[n][nPAcao] $ "13" .And. !Empty(aCols[n][nPStageR])
			Help(" ",1,"FT010LOK04")
			lRetorno := .F.
		EndIf
		If aCols[n][nPAcao] == "2" .And. !Empty(aCols[n][nPStageR])
			aColsSt := oGDStage:aCols
			aHeadSt := oGDStage:aHeader
			nPStage := aScan(aHeadSt,{|x| AllTrim(x[2])=="AC2_STAGE"})
			For nCntFor := 1 To Len(aColsSt)
				lRetorno := .F.
				If ( aColsSt[nCntFor][nPStage] == aCols[n][nPStageR] )
					lRetorno := .T.				
					Exit
				EndIf
			Next nCntFor
			If !lRetorno
				Help(" ",1,"FT010LOK05")
			EndIf
		EndIf
		//Ŀ
		//Veririca os campos obrigatorios                               
		//
		If ( lRetorno .And. (!Empty(aCols[n][nPOper]) .Or. !Empty(aCols[n][nPEvento])) )
			If Empty(aCols[n][nPAcao])
				Help(" ",1,"OBRIGAT")
				lRetorno := .F.
			EndIf
		EndIf
	EndIf
EndIf

Return(lRetorno)

/*/


Ŀ
Funcao    Ft010Grv   Autor Eduardo Riera           Data 11.01.2000
Ĵ
Descrio Funcao de Gravacao do Processo de Venda                     
Ĵ
Sintaxe   Ft010Grv( ExpN1 )                                           
Ĵ
Retorno    .T.                                                         
Ĵ
ParametrosExpN1: [1] Inclusao                                         
                 [2] Alteracao                                        
                 [3] Exclusao                                         
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Static Function Ft010Grv(nOpc,aHeadAC2,aColsAC2,aHeadACZ,aColsACZ)

Local aArea     := GetArea()
Local aUsrMemo  := If( ExistBlock( "FT010MEM" ), ExecBlock( "FT010MEM", .F.,.F. ), {} ) 
Local aMemoAC1  := {}
Local aMemoAC2  := {} 
Local aRegAC2   := {}
Local aRegACZ   := {}

Local cAliasAC2 := ""
Local cAliasACZ := ""
Local cQuery    := ""
Local lGravou   := .F.

Local nCntFor   := 0
Local nCntFor2  := 0
Local nUsadoAC2 := Len(aHeadAC2)
Local nUsadoACZ := Len(aHeadACZ)   
Local nLoop     := 0 

Local nPStage   := aScan(aHeadAC2,{|x| AllTrim(x[2])=="AC2_STAGE"})
Local nPMEMO    := aScan(aHeadAC2,{|x| AllTrim(x[2])=="AC2_MEMO"})
           
If ValType( aUsrMemo ) == "A" .And. Len( aUsrMemo ) > 0
	For nLoop := 1 to Len( aUsrMemo )
		If aUsrMemo[ nLoop, 1 ] == "AC1"
			AAdd( aMemoAC1, { aUsrMemo[ nLoop, 2 ], aUsrMemo[ nLoop, 3 ] } )
		ElseIf aUsrMemo[ nLoop, 1 ] == "AC2"
			AAdd( aMemoAC2, { aUsrMemo[ nLoop, 2 ], aUsrMemo[ nLoop, 3 ] } )
		EndIf
	Next nLoop
EndIf

//Ŀ
//Guarda os registros em um array para atualizacao do estagio   
//
dbSelectArea("AC2")
dbSetOrder(1)
#IFDEF TOP
	If ( TcSrvType()<>"AS/400" )
		cQuery := "SELECT AC2.R_E_C_N_O_ AC2RECNO "
		cQuery += "FROM "+RetSqlName("AC2")+" AC2 "
		cQuery += "WHERE AC2.AC2_FILIAL='"+xFilial("AC2")+"' AND "
		cQuery +=       "AC2.AC2_PROVEN='"+M->AC1_PROVEN+"' AND "
		cQuery +=       "AC2.D_E_L_E_T_<>'*' "
		cQuery += "ORDER BY "+SqlOrder(AC2->(IndexKey()))
		
		cAliasAC2 := GetNextAlias()	
		cQuery    := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasAC2,.T.,.T.)
		dbSelectArea(cAliasAC2)
		While ( !Eof() )
			aadd(aRegAC2,AC2RECNO)
			dbSelectArea(cAliasAC2)
			dbSkip()
		END
		dbSelectArea(cAliasAC2)
		dbCloseArea()
		dbSelectArea("AC2")
	Else
#ENDIF
		dbSeek(xFilial("AC2")+M->AC1_PROVEN)
		While ( !Eof() .And. 	xFilial("AC2") == AC2->AC2_FILIAL .And.;
								M->AC1_PROVEN == AC2->AC2_PROVEN )
			aadd(aRegAC2,AC2->(RecNo()))
			dbSelectArea("AC2")
			dbSkip()
		END
#IFDEF TOP
EndIf
#ENDIF

//Ŀ
//Guarda os registros em um array para atualizacao da regra     
//
dbSelectArea("ACZ")
dbSetOrder(1)
#IFDEF TOP
	If ( TcSrvType()<>"AS/400" )
		cQuery := "SELECT ACZ.R_E_C_N_O_ ACZRECNO "
		cQuery += "FROM "+RetSqlName("ACZ")+" ACZ "
		cQuery += "WHERE ACZ.ACZ_FILIAL='"+xFilial("ACZ")+"' AND "
		cQuery +=       "ACZ.ACZ_PROVEN='"+M->AC1_PROVEN+"' AND "
		cQuery +=       "ACZ.D_E_L_E_T_<>'*' "
		cQuery += "ORDER BY "+SqlOrder(ACZ->(IndexKey()))

		cAliasACZ := GetNextAlias()	
		cQuery    := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasACZ,.T.,.T.)
		dbSelectArea(cAliasACZ)
		While ( !Eof() )
			aadd(aRegACZ,ACZRECNO)
			dbSelectArea(cAliasACZ)
			dbSkip()
		END
		dbSelectArea(cAliasACZ)
		dbCloseArea()
		dbSelectArea("ACZ")
	Else
#ENDIF
		dbSeek(xFilial("ACZ")+M->AC1_PROVEN)
		While ( !Eof() .And. 	xFilial("ACZ") == ACZ->ACZ_FILIAL .And.;
								M->AC1_PROVEN == ACZ->ACZ_PROVEN )
			aadd(aRegACZ,ACZ->(RecNo()))
			dbSelectArea("ACZ")
			dbSkip()
		END
#IFDEF TOP
EndIf
#ENDIF

Do Case
	//Ŀ
	//Inclusao / Alteracao                                          
	//
	Case nOpc <> 3
	
		//Ŀ
		//Atualizacao do CAbecalho                                      
		//
		dbSelectArea("AC1")
		dbSetOrder(1)
		If ( DbSeek(xFilial("AC1")+M->AC1_PROVEN) )
			RecLock("AC1")
		Else 
			RecLock("AC1",.T.)
		EndIf

		For nCntFor := 1 To AC1->(FCount())
			If ( FieldName(nCntFor)<>"AC1_FILIAL" )
				FieldPut(nCntFor,M->&(FieldName(nCntFor)))
			Else
				AC1->AC1_FILIAL := xFilial("AC1")
			EndIf
		Next nCntFor
		MSMM(AC1->AC1_CODMEM,,,M->AC1_MEMO,1,,,"AC1","AC1_CODMEM")	
		
		//Ŀ
		//Grava os campos memo de usuario                               
		//
	
		For nLoop := 1 To Len( aMemoAC1 ) 
			MSMM( AC1->( FieldGet( aMemoAC1[nLoop,1] ) ),,, M->&( aMemoAC1[nLoop,2] ),1,,,"AC1",aMemoAC1[nLoop,1])
		Next nLoop 
	
		AC1->(FkCommit())
			
		For nCntFor := 1 To Len(aColsAC2)
			If ( nCntFor > Len(aRegAC2) )
				If ( !aColsAC2[nCntFor][nUsadoAC2+1] )
					RecLock("AC2",.T.)
				EndIf
			Else
				AC2->(dbGoto(aRegAC2[nCntFor]))
				RecLock("AC2")
			EndIf
			If ( !aColsAC2[nCntFor][nUsadoAC2+1] )
				lGravou := .T.
				For nCntFor2 := 1 To nUsadoAC2
					If ( aHeadAC2[nCntFor2][10] <> "V" )					
						FieldPut(FieldPos(aHeadAC2[nCntFor2][2]),aColsAC2[nCntFor][nCntFor2])
					EndIf				
				Next nCntFor2
				//Ŀ
				//Grava os campos obrigatorios                                  
				//
				AC2->AC2_FILIAL := xFilial("AC2")
				AC2->AC2_PROVEN := M->AC1_PROVEN
				If ( nPMemo <> 0 .And. !Empty(aColsAC2[nCntFor][nPMemo]))
					MSMM(AC2->AC2_CODMEM,,,aColsAC2[nCntFor][nPMemo],1,,,"AC2","AC2_CODMEM")
				EndIf     
			
				//Ŀ
				//Grava os campos memo de usuario                               
				//
				For nLoop := 1 To Len( aMemoAC2 ) 
					MSMM(AC2->(FieldGet(aMemoAC2[nLoop,1])),,, GDFieldGet( aMemoAC2[nLoop,2], nCntFor ),1,,,"AC2",aMemoAC2[nLoop,1])
				Next nLoop 
			Else    
				If ( nCntFor <= Len(aRegAC2) )
			
					dbDelete()
					MSMM(AC2->AC2_CODMEM,,,,2)
					
					//Ŀ
					//Exclui os campos memo de usuario                              
					//
					For nLoop := 1 To Len( aMemoAC2 ) 
						MSMM(aMemoAC2[nLoop,1],,,,2)
					Next nLoop 
					
				EndIf
			EndIf
			MsUnLock()
		Next nCntFor

		For nCntFor := 1 To Len(aColsACZ)
			If ( nCntFor > Len(aRegACZ) )
				If ( !aColsACZ[nCntFor][nUsadoACZ+1] )
					RecLock("ACZ",.T.)
				EndIf
			Else
				ACZ->(dbGoto(aRegACZ[nCntFor]))
				RecLock("ACZ")
			EndIf
			If ( !aColsACZ[nCntFor][nUsadoACZ+1] )
				lGravou := .T.
				For nCntFor2 := 1 To nUsadoACZ
					If ( aHeadACZ[nCntFor2][10] <> "V" )					
						FieldPut(FieldPos(aHeadACZ[nCntFor2][2]),aColsACZ[nCntFor][nCntFor2])
					EndIf				
				Next nCntFor2
				//Ŀ
				//Grava os campos obrigatorios                                  
				//
				ACZ->ACZ_FILIAL := xFilial("ACZ")
				ACZ->ACZ_PROVEN := M->AC1_PROVEN
			Else
				If ( nCntFor <= Len(aRegACZ) )
					dbDelete()
				EndIf
			EndIf
			MsUnLock()
		Next nCntFor

	//Ŀ
	//Exclusao                                                      
	//		
	OtherWise
		For nCntFor := 1 To Len(aRegAC2)
			AC2->(dbGoto(aRegAC2[nCntFor]))
			RecLock("AC2")			
			dbDelete()
			MsUnLock()		
			MSMM(AC2->AC2_CODMEM,,,,2)		
		Next nCntFor

		//Ŀ
		// Descarrega o buffer para integridade referencial             
		//
		AC2->( FKCommit() ) 

		For nCntFor := 1 To Len(aRegACZ)
			ACZ->(dbGoto(aRegACZ[nCntFor]))
			RecLock("ACZ")			
			dbDelete()
			MsUnLock()		
		Next nCntFor

		//Ŀ
		// Descarrega o buffer para integridade referencial             
		//
		ACK->( FKCommit() ) 
		          
		MsDocument( "AC1", AC1->( Recno() ), 2, , 3 ) 
        
		dbSelectArea("AC1")	
		RecLock("AC1")
		dbDelete()
		MSMM(AC1->AC1_CODMEM,,,,2)
		
		//Ŀ
		//Exclui os campos memo de usuario                              
		//
		For nLoop := 1 To Len( aMemoAC1 ) 
			MSMM( AC1->( FieldGet( aMemoAC1[ nLoop, 1 ] ) ),,,,2)
		Next nLoop 
	
		MsUnLock()					
EndCase

//Ŀ
//Restaura a integridade da rotina                              
//
RestArea(aArea)
Return( .T. )

/*/


Ŀ
Funcao    Ft010TudOk Autor Sergio Silveira         Data 28/11/2000
Ĵ
Descrio Funcao TudOk                                                
Ĵ
Sintaxe    ExpL1 := Ft010TudOk()                                      
Ĵ
Retorno    ExpL1 -> Validacao                                         
Ĵ
ParametrosNenhum                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function Ft010TudOk()

Local lRet      := .T.

Local nPosRelev := GDFieldPos( "AC2_RELEVA" )
Local nPosStage := GDFieldPos( "AC2_STAGE" )

Local nLoop     := 0
Local nTotal    := 0
Local nPosDel   := Len( aHeader ) + 1

//Ŀ
// Verifica se existem linhas nao deletadas para a inclusao     
//
If Ascan(aCols,{|x| x[nPosDel] == .F. }) == 0
	Help(" ",1,"FT010NDEL")//Nao e possivel a gravacao do processo sem seus respectivos itens.
	lRet := .F.
Endif	

If lRet
	If !Empty( AScan( aCols, { |x| x[nPosRelev] > 0 } ) ) 
		For nLoop := 1 To Len( aCols )
			If !aCols[ nLoop, nPosDel ]
				nTotal += aCols[ nLoop, nPosRelev ]
			Else
				//Ŀ
				// Permite excluir apenas se nao estiver em uso por oportunidade
				//
				AD1->( dbSetOrder( 5 ) )
				If AD1->( dbSeek( xFilial( "AD1" ) + M->AC1_PROVEN + aCols[nLoop,nPosStage] ) )
					Help( " ", 1, "FT010ETPUS", , aCols[nLoop,nPosStage] ) // A etapa nao pode ser excluida pois esta em uso por uma ou mais oportunidades
					lRet := .F.
					Exit
				EndIf
			EndIf
		Next nLoop

		If lRet
			If nTotal <> 100
				Help( " ", 1, "FT010PERC" ) // O total dos percentuais de contribuicao deve somar 100 %
				lRet := .F.
			EndIf
		EndIf
		
	EndIf
EndIf

Return( lRet )

/*


Ŀ
Funcao    Ft010DelOk Autor Sergio Silveira         Data 18/01/2001
Ĵ
Descrio Validacao da exclusao                                       
Ĵ
Sintaxe    ExpL1 := Ft010DelOk()                                      
Ĵ
Retorno    ExpL1 -> Validacao                                         
Ĵ
ParametrosNenhum                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Static Function Ft010DelOk()

LOCAL lRet := .T.

AD1->( dbSetOrder( 5 ) ) 
If AD1->( dbSeek( xFilial( "AD1" ) + M->AC1_PROVEN ) ) 
	lRet := .F. 
	Help( " ", 1, "FT010OPOR" ) // Este processo nao pode ser excluido pois esta em uso por uma ou mais oportunidades 
EndIf 

Return( lRet ) 

          
/*/


Ŀ
Program   Ft010AC2FG Autor Michel W. Mosca         Data 26.02.2007  
Ĵ
Descrio Preenche o aHeader e aCols para tabela AC2.                   
Ĵ
Retorno   Nenhum                                                        
Ĵ
ParametrosFt010AC2FG(ExpN1, ExpA2, ExpA3)                               
          ExpN1 - Opcao Selecionada                                     
          ExpA2 - aHeader                                               
          ExpA3 - aCols                                                 
                                                                        
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                       
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                     
Ĵ
ٱ


/*/
Static Function Ft010AC2FG(nOpc, aHeadAC2, aColsAC2)
Local aArea := GetArea()
Local cSeek		:= ""	//Armazena a string de busca
Local cWhile	:= ""	//Armazena a condio de parada
Local bCond            	//Armazena a condicao para validar os registros
Local cQuery	:= ""   //Armazena a query para TOP

#IFDEF TOP

	cQuery := "SELECT AC2.*,AC2.R_E_C_N_O_ AC2RECNO "
	cQuery += "FROM "+RetSqlName("AC2")+" AC2 "
	cQuery += "WHERE AC2.AC2_FILIAL='"+xFilial("AC2")+"' AND "
	cQuery +=       "AC2.AC2_PROVEN='"+AC1->AC1_PROVEN+"' AND "
	cQuery +=       "AC2.D_E_L_E_T_<>'*' "
	cQuery += "ORDER BY "+SqlOrder(AC2->(IndexKey()))
	
	cQuery := ChangeQuery(cQuery)

#ENDIF

DbSelectArea("AC2")
DbCloseArea()       

cSeek	:= xFilial("AC2") + AC1->AC1_PROVEN
cWhile	:= "AC2->AC2_FILIAL + AC2->AC2_PROVEN"	
bCond	:= {||IIf(xFilial("AC2")  == AC2->AC2_FILIAL .AND. AC1->AC1_PROVEN == AC2->AC2_PROVEN,.T.,.F.)}    

FillGetDados(	nOpc/*nOpcX*/, "AC2"/*cAlias*/, 1/*nIndex*/, cSeek/*cSeek*/,; 
				{||&(cWhile)}/*{||&cWhile}*/, bCond/*{|| bCond,bAct1,bAct2}*/, /*aNoFields*/,; 
				/*aYesFields*/, /*lOnlyYes*/, cQuery/*cQuery*/, /*bMontAcols*/, IIf(nOpc==3, .T., .F.)/*lEmpty*/,; 
				@aHeadAC2/*aHeaderAux*/, @aColsAC2/*aColsAux*/, /*bAfterCols*/, /*bBeforeCols*/,;
				/*bAfterHeader*/, "AC2"/*cAliasQry*/, /*bCriaVar*/)

DbSelectArea("AC2")
DbCloseArea()

RestArea(aArea)
Return Nil

/*/


Ŀ
Program   Ft010ACZFG Autor Michel W. Mosca         Data 26.02.2007  
Ĵ
Descrio Preenche o aHeader e aCols para tabela ACZ.                   
Ĵ
Retorno   Nenhum                                                        
Ĵ
ParametrosFt010ACZFG(ExpN1, ExpA2, ExpA3)                               
          ExpN1 - Opcao Selecionada                                     
          ExpA2 - aHeader                                               
          ExpA3 - aCols                                                 
                                                                        
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                       
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                     
Ĵ
ٱ


/*/
Static Function Ft010ACZFG(nOpc, aHeadACZ, aColsACZ)
Local aArea := GetArea()
Local cSeek		:= ""	//Armazena a string de busca
Local cWhile	:= ""	//Armazena a condio de parada
Local bCond            	//Armazena a condicao para validar os registros
Local cQuery	:= ""   //Armazena a query para TOP
Local nCntFor			//Variavel utilizada em Loop


#IFDEF TOP
	cQuery := "SELECT ACZ.*,ACZ.R_E_C_N_O_ ACZRECNO "
	cQuery += "FROM "+RetSqlName("ACZ")+" ACZ "
	cQuery += "WHERE ACZ.ACZ_FILIAL='"+xFilial("ACZ")+"' AND "
	cQuery +=       "ACZ.ACZ_PROVEN='"+AC1->AC1_PROVEN+"' AND "
	cQuery +=       "ACZ.D_E_L_E_T_<>'*' "
	cQuery += "ORDER BY "+SqlOrder(ACZ->(IndexKey()))
	
	cQuery := ChangeQuery(cQuery)
#ENDIF

DbSelectArea("ACZ")
DbCloseArea()       

cSeek	:= xFilial("ACZ") + AC1->AC1_PROVEN
cWhile	:= "ACZ->ACZ_FILIAL + ACZ->ACZ_PROVEN"	
bCond	:= {||IIf(xFilial("ACZ")  == ACZ->ACZ_FILIAL .AND. AC1->AC1_PROVEN == ACZ->ACZ_PROVEN,.T.,.F.)}    

FillGetDados(	nOpc/*nOpcX*/, "ACZ"/*cAlias*/, 1/*nIndex*/, cSeek/*cSeek*/,; 
				{||&(cWhile)}/*{||&cWhile}*/, bCond/*{|| bCond,bAct1,bAct2}*/, /*aNoFields*/,; 
				/*aYesFields*/, /*lOnlyYes*/, cQuery/*cQuery*/, /*bMontAcols*/, IIf(nOpc==3, .T., .F.)/*lEmpty*/,; 
				@aHeadACZ/*aHeaderAux*/, @aColsACZ/*aColsAux*/, /*bAfterCols*/, /*bBeforeCols*/,;
				/*bAfterHeader*/, "ACZ"/*cAliasQry*/, /*bCriaVar*/)

//Preenche a coluna ACZ_ITEM, quando tratar-se de inclusao
If(nOpc==3 .AND. Len(aColsACZ)>0)
	For nCntFor	:= 1 To Len(aHeadACZ)
		If AllTrim(aHeadACZ[nCntFor,2]) == "ACZ_ITEM"
	   		aColsACZ[1][nCntFor] := StrZero(1,Len(ACZ->ACZ_ITEM))
	   		Exit
	 	EndIf
	Next nCntFor
EndIf

DbSelectArea("ACZ")
DbCloseArea()

RestArea(aArea)
Return Nil

//------------------------------------------------------------------------------
/*/{Protheus.doc} Ft010TPipe
Calcula a durao do pipeline em dias e horas.
@sample 	Ft010TPipe(oModel) 

@param		ExpO1	Modelo de Dados.
	
@return	ExpL	Falso 

@author	Anderson Silva
@since		06/05/2013       
@version	P12   
/*/         
//------------------------------------------------------------------------------

Function Ft010TPipe(oModel)

Local oMdlAC1	 	:= oModel:GetModel("AC1MASTER")
Local oMdlCalc		:= oModel:GetModel("CALCPIPE")
Local nDias 		:= oMdlCalc:GetValue("AC2__DTOT")
Local nTotHrs		:= oMdlCalc:GetValue("AC2__HTOT")
Local nDiasAux		:= 0 


While nTotHrs >= 24
	nDiasAux += 1
	nTotHrs -= 24
End

If ( oMdlAC1:GetOperation() ==  MODEL_OPERATION_INSERT ) .OR. ( oMdlAC1:GetOperation() == MODEL_OPERATION_UPDATE )
	oMdlAC1:SetValue("AC1_DTOTAL",nDias+nDiasAux)
	oMdlAC1:SetValue("AC1_HTOTAL",IntToHora(nTotHrs))
EndIf

Return(.F.) 

//------------------------------------------------------------------------------
/*/{Protheus.doc} Ft010HrInt
Converte as horas do grid AC2 em inteiro antes de abrir o formulario 
para calcular o total de horas do pipeline.

@sample 	Ft010HrInt(oModel) 

@param		ExpO1	Modelo de Dados.
	
@return	ExpL	Verdadeiro 

@author	Anderson Silva
@since		06/05/2013       
@version	P12   
/*/         
//------------------------------------------------------------------------------
Function Ft010HrInt(oModel)

Local oMdlAC2 := oModel:GetModel("AC2DETAIL")
Local nLinha	:= oMdlAC2:GetLine()
Local nX		:= 0

If ( oMdlAC2:GetOperation() ==  MODEL_OPERATION_INSERT ) .OR. ( oMdlAC2:GetOperation() == MODEL_OPERATION_UPDATE )   
	For nX := 1 To oMdlAC2:Length() 
		oMdlAC2:GoLine(nX)
		oMdlAC2:SetValue("AC2_HRINT",HoraToInt(oMdlAC2:GetValue('AC2_HDURAC')))	
	Next nX 
	oMdlAC2:GoLine(nLinha)
EndIf   

Return(.T.)  

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FtVrfTNotf
Verifica se o total de dias e horas da notificao  maior que os dias e horas de durao do estgio

@sample      FtVrfTNotf() 

@param             
       
@return    .T.   Verdadeiro se o total de dias e horas para notificao 
                   for menor que o total da durao
                   
            .F.   Falso se o total de dias e horas para notificao 
                   for maior que o total da durao


@author     Aline Kokumai
@since             10/05/2013       
@version    P11.80 
/*/
//------------------------------------------------------------------------------
Function FtVrfTNotf()

Local nDiaDur   := FWFLDGET("AC2_DDURAC") //Dias de durao do estagio
Local cHrDur    := FWFLDGET("AC2_HDURAC") //Horas de durao do estagio
Local nDiaNotf  := FWFLDGET("AC2_DNOTIF") //Dias de notificao do estgio
Local cHrNotf   := FWFLDGET("AC2_HNOTIF") //Horas de notificao do estgio
Local lRetorno  := Nil

If (nDiaNotf > nDiaDur) //Verifica se os dias para notificao  maior que o da durao
	lRetorno := .F.
ElseIf (nDiaNotf == nDiaDur) //Verifica se os dias para notificao  igual ao da durao
	If (Val(StrTran(cHrNotf,":","")) > Val(StrTran(cHrDur,":",""))) //Verifica se as horas para notificao  maior que a da durao
		lRetorno := .F.
	Else
		lRetorno := .T.
	EndIf
Else
	lRetorno := .T.
EndIf

//Ŀ
//   Problema: O perodo de notificao no pode ser superior ao perodo de 
//                     durao                                              
//   Solucao: Diminua o perodo de notificao                              
//                                                                          
//
Help( " ", 1, "AT010DRNOTIF" )

Return (lRetorno)

//------------------------------------------------------------------------------
/*/{Protheus.doc} FT010Cmt

Commit 

@sample 	FT010Cmt( oModel )

@param		oModel -  Modelo de dados
		

@return   	Nil

@author	Thamara Villa Jacomo
@since		06/02/2014
@version	12
/*/
//------------------------------------------------------------------------------
Static Function FT010Cmt( oModel )

Local aArea := GetArea()
Local nOper	:= oModel:GetOperation() 

If nOper == MODEL_OPERATION_DELETE
	//Ŀ
	// Exclusao de Anotaes    
	//		                                                                        
	If nModulo == 73
		CRMA090Del( "AC1", AC1->( Recno() ) )
	EndIf	
EndIf

RestArea( aArea )

FWFormCommit( oModel )

Return( .T. )

//------------------------------------------------------------------------------
/*/{Protheus.doc} FT010PreAC2

Pr-Validao da grid.

@sample 	FT010PreAC2( oMdlAC2, nLine, cAction, cField, xValue, xOldValue )
@param		oMdlAC2 -  Modelo de dados
@param 		nLine - Linha Atual
@param 		cAction - Ao do usurio (Insert, delete, undelete, update)
@param 		cField - Campo que esta recebendo a ao
@param 		xValue - Valor Atual
@param 		xOldValue - Valor antes da ao do usurio
		
@return   	lRet - Retorno lgico

@author		Vendas CRM
@since		09/04/2018
@version	12
/*/
//------------------------------------------------------------------------------
Static Function FT010PreAC2(oMdlAC2, nLine, cAction, cField, xValue, xOldValue)

Local lRet 		:= .T.
Local cAcao		:= ""

If cField == "AC2_ACAO" .And. cAction == "SETVALUE"
	cAcao := AllTrim(xValue)
	If !Empty( cAcao )
		If (At("(",cAcao) > 0 .And. At(")",cAcao) == 0) .Or.;
			(At("(",cAcao) == 0 .And. At(")",cAcao) > 0)
			lRet := .F.	
		EndIf
		If lRet
			lRet := FindFunction( cAcao )
		EndIf
		If !lRet
			Help("",1,"FT010NOFUN",,STR0023,1,0,,,,,,{STR0024}) //##"A funo informada no existe."##"Informe uma funo vlida." 
		EndIf
	EndIf
EndIf

Return lRet
