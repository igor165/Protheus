#Include "TECA120.ch"
#Include "PROTHEUS.CH"
#DEFINE  NUMITENS 999


/*


Ŀ
Funo     TECA120   Autor  Sergio Silveira        Data  13/09/99 
Ĵ
Descrio  Cadastro de Planos de Manutencao Preventiva                
Ĵ
Sintaxe    TECA120()                                                  
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Uso        SIGATEC                                                    
ٱ


*/

Function TECA120( cRotina )

Local aFixe := {}
Local aStruct
Local aCores

Local cArqTrab
Local cCond
Local cIndexKey

Private aRotina := MenuDef()
Private cCadastro := STR0001 // Planos de Manutencao Preventiva

If ValType( cRotina ) <> "C"
	mBrowse( 6, 1, 22, 75, "AA8" )
Else 	
	//Ŀ
	// Tratamento para chamada de outra rotina                      
	//
	If !Empty( nScan := AScan( aRotina, { |x| x[2] == cRotina } ) ) 
		cRoda := cRotina + "( 'AB8', AB8->( Recno() ), " + Str( nScan, 2 ) + ") " 		
		Eval( { || &( cRoda ) } ) 
	EndIf 	
EndIf

Return( nil )

/*/

Ŀ
Funo     MenuDef   Autor  Conrado Q. Gomes       Data  08.12.06 
Ĵ
Descrio  Definio do aRotina (Menu funcional)                      
Ĵ
Sintaxe    MenuDef()                                                  
Ĵ
Parametros                                                            
Ĵ
 Uso       TECA120                                                    
ٱ


/*/
Static Function MenuDef()
	//Ŀ
	// Define Array contendo as Rotinas a executar do programa      
	// ----------- Elementos contidos por dimensao ------------     
	// 1. Nome a aparecer no cabecalho                              
	// 2. Nome da Rotina associada                                  
	// 3. Usado pela rotina                                         
	// 4. Tipo de Transao a ser efetuada                          
	//    1 - Pesquisa e Posiciona em um Banco de Dados             
	//    2 - Simplesmente Mostra os Campos                         
	//    3 - Inclui registros no Bancos de Dados                   
	//    4 - Altera o registro corrente                            
	//    5 - Remove o registro corrente do Banco de Dados          
	//
	Local aRotina := {	{ STR0002	,"AxPesqui"		,0	,1	,0	,.F.	}	,;  // "Pesquisar"
						{ STR0003	,"At120Visu"	,0	,2	,0	,.T.	}	,;  // "Visualizar"
						{ STR0004	,"At120Incl"	,0	,3	,0	,.T.	}	,;  // "Incluir"
						{ STR0005	,"At120Alte"	,0	,4	,0	,.T.	}	,;  // "Alterar"
						{ STR0011	,"At120Copia"	,0	,4	,0	,.T.	}	,;  // "Copiar"
						{ STR0006	,"At120Excl"	,0	,2	,0	,.T.	}	}	// "Excluir"
Return(aRotina)

/*


Ŀ
Funo    At120Incl  Autor  Sergio Silveira        Data  14/09/99 
Ĵ
Descrio  Inclusao de Planos de Manutencao                           
Ĵ
Sintaxe    At120Incl( ExpC1, ExpN1, ExpN2 )                           
Ĵ
Parametros ExpC1->Alias / ExpN1 -> Num. Registro / ExpN2 -> Opcao     
Ĵ
Retorno    Nil                                                        
Ĵ
Uso                                                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
20/12/2006 Conrado Q.    Bops 115737: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


*/

Function At120Incl( cAlias, nReg, nOpcx )

Local aSize		:= {}
Local aInfo		:= {}
Local aPosObj	:= {}
Local aObjects	:= {}
Local bCampo	:= {||}
Local nOpca		:= Nil
Local nLoop		:= 0
Local oDlg		:= Nil
Local oGet		:= Nil

Private aTela	:= {}
Private aGets	:= {}
Private aCols	:= {}
Private aHeader	:= {}

Inclui := .T.

//Ŀ
// Verifica se existe algum dado no arquivo                     
//

dbSelectArea( cAlias )
dbSetOrder( 1 )

//Ŀ
// Monta a entrada de dados do arquivo                          
//
bCampo   := { |nCPO| FieldName(nCPO) }

//Ŀ
// Monta as variaveis da Enchoice 
//

For nLoop := 1 To FCount()
	M->&( Eval( bCampo, nLoop ) ) := CriaVar( Eval( bCampo, nLoop ) )
Next nLoop

//Ŀ
//Montagem aHeader, aCols
//
If Len(aHeader) == 0 .AND. Len(aCols) == 0
	FillGetDados(	nOpcx			,"AA9"			,1				,/*cSeek*/		,;
					/*{||cWhile}*/	,{|| .T. }		,/*aNoFields*/	,/*aYesFields*/	,; 
					/*lOnlyYes*/	,/*cQuery*/		,/*bMontCols*/	,.T.			,;
					/*aHeaderAux*/	,/*aColsAux*/	,/*bAfterCols*/	,/*bBeforeCols*/)
Endif

aCols[1][GdFieldPos("AA9_ITEM")] := "01"

nOpca       := 0
                                  
aSize := MsAdvSize()

aObjects := {}

AAdd( aObjects, { 100, 40, .T., .T. } )
AAdd( aObjects, { 100, 60, .T., .T. } )

aInfo := { aSize[1], aSize[2], aSize[3], aSize[4], 3, 3 } 

aPosObj := MsObjSize( aInfo, aObjects, .T. ) 

DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME 

	oDlg:Cargo := { Len( aCols ) }

	nLin := oDlg:Cargo[1]

	EnChoice( cAlias, nReg, nOpcx, , , , , aPosObj[1], , 3 )

	oGet := MSGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpcx,"At120LOK","At120TOK", "+AA9_ITEM",.T.,,,,NUMITENS)

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg,{ || nOpcA:=If(Obrigatorio(aGets,aTela).And.oGet:TudoOk(),1,0),If(nOpcA==1,oDlg:End(),Nil)},{||oDlg:End()})

If nOpca == 1
	//Ŀ
	// Efetua a gravacao              
	//
	At120Grava(1)
EndIf

Return( nOpca )

/*


Ŀ
Funo     At120Visu Autor  Sergio Silveira        Data  15/09/99 
Ĵ
Descrio  Visualizacao do plano de manutencao                        
Ĵ
Sintaxe    At120Visu( cAlias, nReg, nOpcx                             
Ĵ
Parametros ExpC1->Alias / ExpN1 -> Num. Registro / ExpN2 -> Opcao     
Ĵ
Retorno    Nil                                                        
Ĵ
Uso        SIGATEC                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
20/12/2006 Conrado Q.    Bops 115737: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


*/

Function At120Visu( cAlias, nReg, nOpcx )

Local aSize		:= {}
Local aInfo		:= {}
Local aPosObj	:= {}
Local aObjects	:= {}
Local bCampo	:= {||}
Local nOpca		:= 0
Local nLoop		:= 0
Local oDlg		:= Nil
Local oGet		:= Nil
Local cSeek		:= ""			// Seek para montagem da aCols
Local cWhile	:= ""			// While para montagem da aHeader

Private aTela	:= {}
Private aGets	:= {}
Private aHeader	:= {}
Private aCols	:= {}

Inclui := .F.
Altera := .F.

//Ŀ
// Verifica se existe algum dado no arquivo                     
//

dbSelectArea( cAlias )
dbSetOrder( 1 )

//Ŀ
// Monta a entrada de dados do arquivo                          
//

bCampo   := { |nCPO| FieldName(nCPO) }

//Ŀ
// Monta as variaveis da Enchoice 
//

For nLoop := 1 To FCount()
	M->&( Eval( bCampo, nLoop ) ) := FieldGet( nLoop )
Next nLoop

//Ŀ
//Montagem aHeader, aCols
//
cSeek	:= xFilial( "AA9" ) + M->AA8_PLANO
cWhile	:= "AA9->AA9_FILIAL + AA9->AA9_PLANO"

If Len(aHeader) == 0 .AND. Len(aCols) == 0
	FillGetDados(	nOpcx			,"AA9"			,1				,cSeek			,;
					{|| &cWhile }	,{|| .T. }		,/*aNoFields*/	,/*aYesFields*/	,; 
					/*lOnlyYes*/	,/*cQuery*/		,/*bMontCols*/	,/*lEmpty*/		,;
					/*aHeaderAux*/	,/*aColsAux*/	,/*bAfterCols*/	,/*bBeforeCols*/)
Endif

//Ŀ
// Desenha a janela               
//

aSize := MsAdvSize()

aObjects := {}

AAdd( aObjects, { 100, 40, .T., .T. } )
AAdd( aObjects, { 100, 60, .T., .T. } )

aInfo := { aSize[1], aSize[2], aSize[3], aSize[4], 3, 3 } 

aPosObj := MsObjSize( aInfo, aObjects, .T. ) 

DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME 

	EnChoice( cAlias, nReg, nOpcx, , , , , aPosObj[1], , 3 )

	oGet := MSGetDados():New( aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4], nOpcx,"At120LOK","At120TOK", , .F. )

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg,{ || nOpca := 1,oDlg:End() }, {|| nOpca := 0, oDlg:End()})

Return( nOpca )


/*


Ŀ
Funo     At120Alte Autor  Sergio Silveira        Data  15/09/99 
Ĵ
Descrio  Alteracao do plano de manutencao                           
Ĵ
Sintaxe    At120Alte( ExpC1, ExpN1, ExpN2 )                           
Ĵ
Parametros ExpC1->Alias / ExpN1 -> Num. Registro / ExpN2 -> Opcao     
Ĵ
Retorno    Nil                                                        
Ĵ
Uso        SIGATEC                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
20/12/2006 Conrado Q.    Bops 115737: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


*/

Function At120Alte( cAlias, nReg, nOpcx )

Local aSize		:= {}
Local aInfo		:= {}
Local aPosObj	:= {}
Local aObjects	:= {}
Local nLoop		:= 0
Local oDlg		:= Nil
Local cSeek		:= ""			// Seek para montagem da aCols
Local cWhile	:= ""			// While para montagem da aHeader

Private aTela	:= {}
Private aGets	:= {}
Private aHeader	:= {}
Private aCols	:= {}

Altera := .T.

//Ŀ
// Verifica se existe algum dado no arquivo     \                
//

dbSelectArea( cAlias )
dbSetOrder( 1 )

//Ŀ
// Monta a entrada de dados do arquivo                          
//
bCampo   := { |nCPO| FieldName(nCPO) }

//Ŀ
// Monta as variaveis da Enchoice 
//

For nLoop := 1 To FCount()
	M->&( Eval( bCampo, nLoop ) ) := FieldGet( nLoop )
Next nLoop

//Ŀ
//Montagem aHeader, aCols
//
cSeek	:= xFilial( "AA9" ) + M->AA8_PLANO
cWhile	:= "AA9->AA9_FILIAL + AA9->AA9_PLANO"

If Len(aHeader) == 0 .AND. Len(aCols) == 0
	FillGetDados(	nOpcx			,"AA9"			,1				,cSeek			,;
					{|| &cWhile }	,{|| .T. }		,/*aNoFields*/	,/*aYesFields*/	,; 
					/*lOnlyYes*/	,/*cQuery*/		,/*bMontCols*/	,/*lEmpty*/		,;
					/*aHeaderAux*/	,/*aColsAux*/	,/*bAfterCols*/	,/*bBeforeCols*/)
Endif

If Empty(aCols[1][GdFieldPos("AA9_ITEM")])
	aCols[1][GdFieldPos("AA9_ITEM")] := "01"
Endif

//Ŀ
// Desenha a janela               
//

nOpca       := 0

aSize := MsAdvSize()

aObjects := {}

AAdd( aObjects, { 100, 40, .T., .T. } )
AAdd( aObjects, { 100, 60, .T., .T. } )

aInfo := { aSize[1], aSize[2], aSize[3], aSize[4], 3, 3 } 

aPosObj := MsObjSize( aInfo, aObjects, .T. ) 

DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME 

	EnChoice( cAlias, nReg, nOpcx, , , , , aPosObj[1], , 3 )
	oGet := MSGetDados():New( aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4], nOpcx,"At120LOK","At120TOK","+AA9_ITEM", .T.;
		, , , , NUMITENS, , , , "At120G1DOK" )

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg,{ || nOpcA:=If(Obrigatorio(aGets,aTela).And.oGet:TudoOk(),1,0),If(nOpcA==1,oDlg:End(),Nil) }, { || oDlg:End() } )

If nOpca == 1
	//Ŀ
	// Faz a gravacao dos dados       
	//
	At120Grava(2)
EndIf

Return( nOpca )

/*


Ŀ
Funo     At120Excl Autor  Sergio Silveira        Data  15/09/99 
Ĵ
Descrio  Exclusao do plano de manutencao                            
Ĵ
Sintaxe    At120Excl( ExpC1, ExpN1, ExpN2 )                           
Ĵ
Parametros ExpC1->Alias / ExpN1 -> Num. Registro / ExpN2 -> Opcao     
Ĵ
Retorno    Nil                                                        
Ĵ
Uso        SIGATEC                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
20/12/2006 Conrado Q.    Bops 115737: Montagem do aCols e aHeader    
                         atravs da rotina FillGetDados.             
ٱ


*/

Function At120Excl( cAlias, nReg, nOpcx )

Local aSize		:= {}
Local aInfo		:= {}
Local aPosObj	:= {}
Local aObjects	:= {}
Local bCampo	:= { |nCPO| FieldName(nCPO) }
Local lOk		:= .T. 
Local nOpca		:= 0 
Local nLoop		:= 0
Local oDlg		:= Nil
Local oGet		:= Nil
Local cSeek		:= ""			// Seek para montagem da aCols
Local cWhile	:= ""			// While para montagem da aHeader

Private aTela	:= {}
Private aGets	:= {}
Private aHeader	:= {}
Private	aCols	:= {}

Inclui := .F.
Altera := .F.

//Ŀ
// Verifica se existe algum dado no arquivo                     
//

dbSelectArea( cAlias )
dbSetOrder( 1 )

//Ŀ
// Verifica se esta' na filial correta                          
//

//Ŀ
// Monta a entrada de dados do arquivo                          
//

bCampo   := { |nCPO| FieldName(nCPO) }

DbSelectArea("AA8")

//Ŀ
// Monta as variaveis da Enchoice 
//

For nLoop := 1 To FCount()
	M->&( Eval( bCampo, nLoop ) ) := FieldGet( nLoop )
Next nLoop

//Ŀ
//Montagem aHeader, aCols
//
cSeek	:= xFilial( "AA9" ) + M->AA8_PLANO
cWhile	:= "AA9->AA9_FILIAL + AA9->AA9_PLANO"

If Len(aHeader) == 0 .AND. Len(aCols) == 0
	lOk := FillGetDados(	nOpcx			,"AA9"		,1				,cSeek												,;
		   				{|| &cWhile }	,{|| .T. }		,/*aNoFields*/	,/*aYesFields*/										,; 
						/*lOnlyYes*/	,/*cQuery*/		,/*bMontCols*/	,/*lEmpty*/											,;
						/*aHeaderAux*/	,/*aColsAux*/	,/*bAfterCols*/	,{|| AtPlanAlt( AA9->AA9_PLANO, AA9->AA9_ITEM )	})
Endif

If lOk

	//Ŀ
	// Desenha a janela               
	//
	
	nOpca := 0
	aSize := MsAdvSize()
	
	aObjects := {}
	
	AAdd( aObjects, { 100, 40, .T., .T. } )
	AAdd( aObjects, { 100, 60, .T., .T. } )
	
	aInfo := { aSize[1], aSize[2], aSize[3], aSize[4], 3, 3 } 
	
	aPosObj := MsObjSize( aInfo, aObjects, .T. ) 
	
	DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL STYLE WS_DLGFRAME 
	
		EnChoice( cAlias, nReg, nOpcx, , , , , aPosObj[1], , 3 )
	
		oGet := MSGetDados():New( aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4], nOpcx,"At120LOK","At120TOK", , .F.,,,,NUMITENS)
	
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg,{ || nOpca := 1,;
			oDlg:End()}, {||oDlg:End()})
	
	//Ŀ
	// Se confirmou a exclusao        
	//
	If nOpca == 1
		At120Grava(3) 
	EndIf

EndIf 
	
Return( nOpca )


/*


Ŀ
Funo     At120LOK  Autor  Sergio Silveira        Data  14/09/99 
Ĵ
Descrio  LinOK da Getdados                                          
Ĵ
Sintaxe    ExpL1 := At120LOK()                                        
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    ExpL1 -> Validacao OK                                      
Ĵ
Uso        TECA120                                                    
ٱ


*/

Function At120LOK( oDlg )

Local nPDesc   := aScan(aHeader,{|x| AllTrim(x[2])=="AA9_DESC" })
Local nCntFor  := 0

Local lRetorno := .T.
//Ŀ
//Verifica os campos obrigatrios
//
If ( nPDesc > 0 )
	If ( !GDDeleted() .And. !Empty(aCols[n][nPDesc]) )
		For nCntFor := 1 To Len(aHeader)
			If ( AllTrim(aHeader[nCntFor][2]) == "AA9_UNIINI" .Or.;
				 AllTrim(aHeader[nCntFor][2]) == "AA9_INICIO" .Or.;
				 AllTrim(aHeader[nCntFor][2]) == "AA9_TMPSRV" .Or.;
				 AllTrim(aHeader[nCntFor][2]) == "AA9_CODPRB" )
			If ( Empty(aCols[n][nCntFor]) )
					Help(" ",1,"OBRIGAT")
					lRetorno := .F.
					Exit
				EndIf				 
			EndIf
		Next nCntfor
		
		//Ŀ
		// Dispara validacao do usuario  
		//
		If lRetorno 
			If ExistBlock( "AT120LOK" ) 
				lRetorno := ExecBlock( "AT120LOK", .f., .f. )
			EndIf 
		EndIf 			 
		
	EndIf
EndIf
Return( lRetorno )


/*


Ŀ
Funo     At120TOK  Autor  Sergio Silveira        Data  14/09/99 
Ĵ
Descrio  TudoOk da Getdados                                         
Ĵ
Sintaxe    ExpL1 := At120TOK()                                        
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    ExpL1 -> Validacao OK                                      
Ĵ
Uso        TECA120                                                    
ٱ


*/

Function At120TOK( )

LOCAL lRet := .T.

Return( lRet )


/*


Ŀ
Funo    At120Grava Autor  Sergio Silveira        Data  14/09/99 
Ĵ
Descrio  Faz a gravacao do plano de manutencao                      
Ĵ
Sintaxe    At120Grava                                                 
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Uso        TECA120                                                    
ٱ


*/

Function At120Grava(nOpcao)

LOCAL cSeekAA8
LOCAL cSeekAA9
LOCAL cPlano    := M->AA8_PLANO
LOCAL cCampoAh

LOCAL nLoop
LOCAL nLoop2
LOCAL nPosItem  := Ascan( aHeader, { |x| AllTrim( x[2] ) == "AA9_ITEM"  } )
LOCAL nPosDesc  := Ascan( aHeader, { |x| AllTrim( x[2] ) == "AA9_DESC"  } )
LOCAL nPosArq

LOCAL lFoundAA9
LOCAL lGravou	:= .F.

DEFAULT nOpcao := 1 
                  
Begin Transaction

If nOpcao <> 3 

	cSeekAA8 := xFilial( "AA8" ) + M->AA8_PLANO
	
	AA8->( dbSetOrder( 1 ) )
	If AA8->( DbSeek( cSeekAA8 ) )
		RecLock( "AA8", .F. )
	Else
		RecLock( "AA8", .T. )
		AA8->AA8_FILIAL  := xFilial( "AA8" )
		AA8->AA8_PLANO   := M->AA8_PLANO
	EndIf
	
	dbSelectArea( "AA8" )
	
	//Ŀ
	// Grava os demais campos inclusive especificos 
	//
	
	For nLoop := 1 To FCount()
		cCampo := FieldName( nLoop )
		If !( cCampo $ "AA8_FILIAL/AA8_PLANO" )
			FieldPut( nLoop, M->&cCampo )
		EndIf
	Next nLoop
	
	AA8->( MsUnlock() )  
	AA8->( FKCommit() ) 
	
	//Ŀ
	// Gravacao dos itens             
	//
	
	For nLoop := 1 To Len( aCols )
	
		cSeekAA9 := xFilial( "AA9" ) + M->AA8_PLANO + aCols[ nLoop, nPosItem ]
	
		AA9->( dbSetOrder( 1 ) )
	
		lFoundAA9 := AA9->( dbSeek( cSeekAA9 ) )
	
		If	aCols[ nLoop, Len( aHeader ) + 1 ] .Or. Empty(aCols[nLoop,nPosDesc])
	
			//Ŀ
			// Se o registro estiver excluido 
			//
	
			If lFoundAA9
	
				RecLock( "AA9", .F., .T. )
				AA9->( dbDelete() )
				AA9->( MsUnLock() )
	
			EndIf
	
		Else
	
			//Ŀ
			// Se nao estiver excluido        
			//
	        lGravou := .T.
	        
			If lFoundAA9
	
				RecLock( "AA9", .F. )
	
			Else
	
				//Ŀ
				// Grava campos chave             
				//
	
				RecLock( "AA9", .T. )
	
				AA9->AA9_FILIAL  := xFilial( "AA9" )
				AA9->AA9_PLANO   := cPlano
				AA9->AA9_ITEM    := aCols[ nLoop, nPosItem  ]
	
			EndIf
	
			//Ŀ
			// Faz a gravacao dos demais campos ( inclusive especificos ) 
			//
	
			dbSelectArea( "AA9" )
	
			For nLoop2 := 1 To Len( aHeader )
	
				cCampoAh  := AllTrim( aHeader[ nLoop2, 2 ] )
	
				If !( cCampoAh $ "AA9_PLANO/AA9_ITEM/AA9_FILIAL" )
	
					nPosArq := FieldPos( cCampoAh )
	
					If !Empty( nPosArq )
	
						FieldPut( nPosArq, aCols[ nLoop, nLoop2 ] )
	
					EndIf
	
				EndIf
	
			Next nLoop2
	
			//Ŀ
			// Grava o campo MEMO             
			//
	
			MSMM( AA9->AA9_CODMEM, , , GDFieldGet( "AA9_MEMO", nLoop ), 1, , , ;
						"AA9","AA9_CODMEM")
	
			AA9->( MsUnLock() )
	
		EndIf
	
	Next nLoop

Else 

	cSeekAA9 := xFilial( "AA9" ) + M->AA8_PLANO
	AA9->( dbSetOrder( 1 ) )

	//Ŀ
	// Exclui todos os itens          
	//
	If AA9->( dbSeek( cSeekAA9 ) )
		AA9->( dbEval( { || RecLock( "AA9", .F., .T. ),;
			AA9->( dbDelete() ), AA9->( MsUnLock() ) }, ,{ || cSeekAA9;
			== AA9->AA9_FILIAL + AA9->AA9_PLANO }, , ,.T. ) )
	EndIf
	
	AA9->( FKCommit() ) 

	//Ŀ
	// Exclui os cabecalho do Plano   
	//

	RecLock( "AA8", .F., .T. )
         AA8->( dbDelete() )
	AA8->( MsUnLock() )

EndIf 

//Ŀ
// Dispara ponto apos gravacao   
//
If ExistBlock( "AT120GRV" ) 
	ExecBlock( "AT120GRV", .f., .f., { nOpcao } )
EndIf            

End Transaction

Return( Nil )

/*


Ŀ
Funo     AtPlanAlt Autor  Sergio Silveira        Data  16/09/99 
Ĵ
Descrio  Valida se o item do plano pode ser alterado                
Ĵ
Sintaxe    ExpL1 := AtPlanAlt( [ ExpC1 ], [ ExpC2 ] )                 
Ĵ
Parametros ExpC1 -> Plano de Manutencao / ExpC2 -> Item do Plano      
Ĵ
Retorno    ExpL1 -> Validacao OK                                      
Ĵ
Uso        SIGATEC                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function AtPlanAlt( cPlano, cItem )

Local lRet := .T.

cPlano := If( ValType( cPlano ) == "C", cPlano, M->AA8_PLANO )
cItem  := If( ValType( cItem  ) == "C", cItem , GDFieldGet( "AA9_ITEM"  ) )

//Ŀ
// Verifica se existe agendamento para este item/plano com data 
// posterior a data atual                                       
//

ABE->( dbSetOrder( 2 ) )
ABE->( dbSeek( xFilial( "ABE" ) + cPlano + cItem + DToS( dDataBase ), .T. ) )

If !ABE->( Eof() ) .And.;
    (ABE->ABE_FILIAL+ABE->ABE_PLANO+ABE->ABE_ITEM == xFilial( "ABE" )+cPlano+cItem)
	Help( " ", 1, "ITEMAGEND" )
	lRet := .F.
EndIf

Return( lRet )

/*


Ŀ
Funo    At120G1DOK Autor  Sergio Silveira        Data  16/09/99 
Ĵ
Descrio  Validacao de exclusao da GetDados                          
Ĵ
Sintaxe    ExpL1 := At120G1DOK()                                      
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    ExpL1 -> Validacao OK                                      
Ĵ
Uso        SIGATEC                                                    
ٱ


*/

Function At120G1DOK( )

lRet := AtPlanAlt()

Return( lRet )

/*


Ŀ
Funo    At120Copia Autor  Sergio Silveira        Data  21/09/99 
Ĵ
Descrio  Copia o Plano de Manutencao para novo Codigo               
Ĵ
Sintaxe    At120Copia( ExpC1, ExpN1, ExpN2 )                          
Ĵ
Parametros ExpC1-> Alias, ExpN1->Recno, ExpN2 -> Opcao                
Ĵ
Retorno    Nenhum                                                     
Ĵ
Uso        SIGATEC                                                    
ٱ


*/

Function At120Copia( cAlias, nRecNo, nOpc )

LOCAL aDados    := {}   
LOCAL aDadosIt  := {}   
LOCAL aDadosLin := {}   
LOCAL aDados2   := {}   
LOCAL aDadosLin2:= {}   

LOCAL cPlanoOri := AA8->AA8_PLANO
LOCAL cPlanoDes := CriaVar( "AA8_PLANO" )
LOCAL cCont     := ""
LOCAL cSeekAA9  := ""
LOCAL cSeekSYP  := ""
LOCAL cNewMemo  := ""

LOCAL cOldMemo  := ""

Local nSaveSX8	 := GetSX8Len()
LOCAL nOpca     := 0 
LOCAL nRadio    := 1
LOCAL nLoop     := 0 
LOCAL nLoop2    := 0 
LOCAL nLoop3    := 0 
LOCAL nLoop4    := 0 

LOCAL oDlg
LOCAL oRadio
LOCAL oBut1
LOCAL oBut2
LOCAL oBut3 

nOpca := 0

DEFINE MSDIALOG oDlg TITLE STR0012 From ;
			9,0 To 22.5, 33 OF oMainWnd // Planos de Manutencao Preventiva

	@ 10, 10 SAY STR0014 PIXEL //  "Plano Origem"
	@ 10, 50 GET cPlanoOri       When .F.                      SIZE 25, 08 PIXEL

	@ 22, 10 SAY STR0015 PIXEL // "Plano Destino"
	@ 22, 50 MSGET cPlanoDes Picture "999999" Valid At120ValPl( cPlanoDes,;
			@oBut1 ) SIZE 25, 08 PIXEL
			
  	//Ŀ
	// Botao criado para receber o foco - nao retirar ! 
	//
	DEFINE SBUTTON oBut3 FROM 1000, 1000  TYPE 1 ACTION ( nOpca := 1,;
			oDlg:End() ) ENABLE of oDlg
			
	oBut3:bGotFocus := { || oRadio:SetFocus() } 			

	@ 40, 10 TO 88, 75 PIXEL PROMPT STR0016

	@ 50, 13 RADIO oRadio VAR nRadio 3D SIZE 40, 11 PROMPT STR0017,;
			STR0018, STR0019 of oDlg PIXEL // "Todos","Ativos", "Inativos"

	DEFINE SBUTTON oBut1 FROM 55, 89  TYPE 1 ACTION ( nOpca := 1,;
			oDlg:End() ) ENABLE of oDlg

	DEFINE SBUTTON oBut2 FROM 75, 89  TYPE 2 ACTION ( nOpca := 0,;
			oDlg:End() ) ENABLE of oDlg

	oBut1:Disable()

ACTIVATE MSDIALOG oDlg CENTERED

If nOpca == 1

	Do Case
	Case nRadio == 1
		cCont := "2|1"
	Case nRadio == 2
		cCont := "1"
	Case nRadio == 3
		cCont := "2"
	EndCase

	Begin Transaction

	//Ŀ
	// Efetua a copia dos Itens       
	//

	dbSelectArea( "AA9" )

	cSeekAA9 := xFilial( "AA9" ) + cPlanoOri

	AA9->( dbSetOrder( 1 ) )

	If AA9->( dbSeek( cSeekAA9 ) )

		aDadosIt := {}

		While !AA9->( Eof() ) .And. cSeekAA9 == AA9->AA9_FILIAL + ;
				AA9->AA9_PLANO

			//Ŀ
			// Pega apenas os itens selecionados pelo usuario 
			//

			If AA9->AA9_ATIVO $ cCont

				//Ŀ
				// Pega os dados do item anterior 
				//

				aDadosLin := {}

				For nLoop := 1 To AA9->( FCount() ) 
					AAdd( aDadosLin, AA9->( FieldGet( nLoop ) ) ) 
				Next nLoop

				AAdd( aDadosIt, aClone( aDadosLin ) )

			EndIf

			AA9->( dbSkip() )

		EndDo

	EndIf

	//Ŀ
	// Se pelo menos um item atende a condicao 
	//

	If !Empty( aDadosIt )
	
		//Ŀ
		// Efetua a Copia do Plano        
		//

		DbSelectArea("AA8")

		AA8->( dbGoto( nRecNo ) )

		aDados := {}

		For nLoop := 1 To AA8->( FCount() ) 
			AAdd( aDados, AA8->( FieldGet( nLoop ) ) ) 
		Next nLoop

		RecLock( "AA8", .T. )

		For nLoop := 1 To AA8->( FCount() )

			If AA8->( FieldName( nLoop ) ) <> "AA8_PLANO"
				AA8->( FieldPut( nLoop, aDados[ nLoop ] ) ) 
			EndIf

		Next nLoop

		AA8->AA8_PLANO := cPlanoDes

		AA8->( MsUnlock() )
		AA8->( FKCommit() ) 

		//Ŀ
		// Cria os novos registros com o novo numero de plano 
		//

		dbSelectArea("AA9")
		For nLoop := 1 To Len( aDadosIt )

			Reclock( "AA9", .T. )

			aDadosLin := aClone( aDadosIt[ nLoop ] )

			For nLoop2 := 1 To Len( aDadosLin )

				Do Case
				Case FieldName( nLoop2 ) == "AA9_PLANO"
	               AA9->AA9_PLANO  := cPlanoDes
				Case FieldName( nLoop2 ) == "AA9_CODMEM"

					//Ŀ
					// Pega a nova sequencia do campo memo 
					//
					cOldMemo := aDadosLin[ nLoop2 ]
					
					If !Empty( cOldMemo ) 
					
						nSaveSX8	:= GetSX8Len()
						cNewMemo := GetSX8Num( "SYP", "YP_CHAVE" )
	
						//Ŀ
						// Copia os itens do memo         
						//
	
						dbSelectArea("SYP")
						SYP->( dbSetOrder( 1 ) )
	
						aDados2    := {}
	
						cSeekSYP := xFilial( "SYP" ) + cOldMemo
	
						If SYP->( dbSeek( cSeekSYP ) )
	
							While !SYP->( Eof() ) .And. cSeekSYP == SYP->YP_FILIAL + ;
									SYP->YP_CHAVE
	
								aDadosLin2 := {}
	
								For nLoop3 := 1 To FCount()
									AAdd( aDadosLin2, FieldGet( nLoop3 ) )
								Next nLoop3
	
								AAdd( aDados2, AClone( aDadosLin2 ) )
	
								SYP->( dbSkip() )
	
							EndDo
	
						EndIf
	
						//Ŀ
						// Cria os novos registros com a nova chave 
						//
	
						For nLoop3 := 1 To Len( aDados2 )
	
							aDadosLin2 := aClone( aDados2[ nLoop3 ] )
	
							RecLock( "SYP", .T. )
	
							For nLoop4 := 1 To Len( aDadosLin2 )
								If FieldName( nLoop4 ) == "YP_CHAVE"
									SYP->YP_CHAVE := cNewMemo
								Else
									FieldPut( nLoop4, aDadosLin2[ nLoop4 ] )
								EndIf
							Next nLoop4
	
							SYP->( MsUnlock() )
	
						Next nLoop3
	
						AA9->AA9_CODMEM := cNewMemo
	
						While ( GetSX8Len() > nSaveSx8 )
							ConfirmSX8( )
						EndDo
	
						DbSelectArea("AA9")
						
					EndIf 	
	
				Otherwise

					//Ŀ
					// Copia os demais campos 
					//
					AA9->( FieldPut( nLoop2, aDadosLin[ nLoop2 ] ) )

				EndCase

			Next nLoop2

			AA9->( MsUnlock() )

		Next nLoop
		
		//Ŀ
		// Dispara ponto apos gravacao   
		//
		If ExistBlock( "AT120GRV" ) 
			ExecBlock( "AT120GRV", .f., .f., { 1 } )
		EndIf 

	Else
		//Ŀ
		// Caso nao exista nenhum item com a condicao especificada 
		//
		Help( " ", 1, "ITEPLANO" ) // Plano nao pode ser copiado sem itens
	EndIf

	End Transaction

EndIf

Return

/*


Ŀ
Funo    At120VaPl  Autor  Sergio Silveira        Data  27/09/99 
Ĵ
Descrio  Validacao do get do novo plano ( copia )                   
Ĵ
Sintaxe    ExpL1 := At120ValPl( ExpC1, ExpO1 )                        
Ĵ
Parametros ExpC1 -> Novo Plano / ExpO1 -> Objeto botao confirma       
Ĵ
Retorno    ExpL1 -> Validacao OK                                      
Ĵ
Uso        TECA120                                                    
ٱ


*/

Function At120ValPl( cPlanoDes, oBut1 )

LOCAL lRet := .T.

//Ŀ
// Pesquisa o numero do plano     
//

If !Empty( cPlanoDes )

	AA8->( dbSetOrder( 1 ) )
	lRet := !AA8->( dbSeek( xFilial( "AA8" ) + cPlanoDes  ) )

	If !lRet
		Help( " ", 1, "JAGRAVADO" ) // Ja existe plano com este numero
	EndIf

Else
	lRet := .F.
EndIf

//Ŀ
// Habilita / desabilta botao OK  
//

If !lRet
	oBut1:Disable()
Else
	oBut1:Enable()    
EndIf

Return( lRet )

