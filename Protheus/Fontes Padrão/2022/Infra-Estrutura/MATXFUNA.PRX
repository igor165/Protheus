#INCLUDE "EICCONST.CH"

Static __HeadProva
STATIC __Contabil

STATIC __lChgX5Fil
STATIC __cSX5NUM
STATIC __Ct105CTK		// Ponto de entrada complementar CTK
STATIC __GetMv
STATIC __SX3Cache	:= {}
STATIC __nXSX3Cache := 0
STATIC __lHasCTKSxe

STATIC __lFWSizeFilial
STATIC __lFWxFilial
 
STATIC __lConOutR
STATIC __lPLSDETPR

Static ISLOADDLL, PORT_OLD
//     ISLOADDLL  // Indica se foi ou nÆo inicializada a DLL
//     PORT_OLD    // Handle da £ltima porta processada
Static __lMTXMOEDA
Static __cUltEmpSF,__cUltFilSF,__nTamFil
Static __aArrCWO := NIL
Static __cStrCWO := NIL

Static __cEFDetProva
Static __MV_PLSATIV
Static __lCWOInDic := NIL

static __canUseTHash := GetBuild() >= '7.00.191205P'
static __findSx3Cache := __canUseTHash .And. FindFunction("_GtSx3Cached")
static __findSGetMvCache := __canUseTHash .And. FindFunction("_GetMvCached")
static __findTamSx3Cache := __canUseTHash .And. FindFunction("_EngTamSX3")

Static __cNumOP
Static __cItemOP
Static __cSeqOP

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ATENCAO : AO ALTERAR QUALQUER FUNCAO GENERICA DE MATERIAIS , FAVOR COMUNICAR³±±
±±³AO RESPONSAVEL PELO MODULO NA EQUIPE DE MATERIAIS. OBRIGADO.                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ DATA   ³ BOPS ³Prograd.³ALTERACAO                            			   ³±±
±±ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³04.08.99³23140A³Aline   ³Permitir utilizar valores c/decimais na cond.pgto  ³±±
±±³23.08.99³23299A³Aline   ³Inclusao de Timer na digitacao do N.da NF          ³±±
±±³25.08.99³16314A³Lucas   ³Inclusao da RDCoNF().                              ³±±
±±³08.09.99³Melhor³Bruno   ³Inclusao de parametro adicional na RdListBox().    ³±±
±±³13.09.99³Melhor³Bruno   ³Acerto para matar o Timer na ASx5Troca().          ³±±
±±³14.09.99³Pilar ³Julio   ³Mudan‡a interna de funcionamento das fun‡”es cont -³±±
±±³        ³      ³        ³beis de escrita no diretorio CPROVA                ³±±
±±³27.09.99³      ³Bruno   ³Posicionamento de arquivo na RDSELECT.             ³±±
±±³29.09.99³Pilar ³Julio   ³Criado Parametro lCria na HeadProva()              ³±±
±±³15.10.99³      ³CesarVal³Restaurar Area Anterior Somente se Houver Area     ³±±
±±³        ³      ³        ³Selecionada no ChkFile e TamSX3.                   ³±±
±±³21.01.00³      ³Pilar   ³Alterado parametro da funcao SALDO()               ³±±
±±³06.04.00³XXXXXX³Denis M ³Uso de cPaisLoc - Localizacoes para acerto no tama-³±±
±±³        ³      ³        ³nho de BOX-Entr.de Nota Fiscal - Funcao aSX5Troca. ³±±
±±³09.05.00³Melhor³Bruno   ³Corrigir chamada da RDConf().                      ³±±
±±³12.01.01³Melhor³Dourado ³Trocar o nome da funcao ChkF3DeCr() para ChkF3Loc()³±±
±±³        ³      ³        ³ajustar a comparacao da variavel colocando         ³±±
±±³        ³      ³        ³Alltrim(cTipo)                                     ³±±
±±³08.04.02³Melhor³Naldo   ³Passagem do Parametro Filial para SuperGetMv() para³±±
±±³        ³      ³        ³efetuar a Carga dos Parametros de Acordo com a Fili³±±
±±³        ³      ³        ³al Passada e Possibilitar que a propria  SuperGetMv³±±
±±³        ³      ³        ³"destrua" a Static __GetMv	qdo. chamada sem parame³±±
±±³        ³      ³        ³tros PCount() == 0.00							   ³±±
±±³06.12.02³Melhor³Naldo   ³Passagem de Novo Parametro para xFilial().         ³±±
±±³10.12.02³Melhor³Naldo   ³Aumentar o Tamanho do Size na BrwLegenda() para nao³±±
±±³        ³      ³        ³cortar a Descricao da Mensagem					   ³±±
±±³27.12.02³Melhor³Naldo   ³Passagem da Funcao PonDestroyStatic() em  RstMvBuff³±±
±±³        ³      ³        ³para inicializar as Statics utilizadas no SIGAPON  ³±±
±±³30.01.02³Melhor³Naldo   ³Alterada TamSx3() para apenas restaurar a ordem   e³±±
±±³        ³      ³        ³o posicionamento no SX3 e guardar o ultimo  posicio³±±
±±³        ³      ³        ³namento do campo para posterior comparacao         ³±±
±±³19/07/11³17078/³Emerson ³Inclusao de parametro adicional na RdListBox().    ³±±
±±³        ³  2011³        ³lPixel considera as coordenadas passadas em        ³±±
±±³        ³      ³        ³pixels (.T.) ou caracteres (.F.).                  ³±±
±±³27/04/12³10200/³Raquel  ³Correcao da funccao RecMoeda.                      ³±±
±±³        ³  2012³Hager   ³                                                   ³±±
±±³17/01/14³151105³Alfredo ³Se agregó la función POSTABCTB() que inicializa las³±± 
±±³        ³      ³Medrano ³tablas que usará el asiento estándar y la función  ³±±
±±³        ³      ³        ³EJEFOR() que obtiene el código ADVPL de la Fórmula.³±±
±±³        ³      ³        ³Se agregó la función POSTABCTB dentro de DEVPROVA()³±±
±±ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ATENCAO : AO ALTERAR QUALQUER FUNCAO GENERICA DE MATERIAIS , FAVOR COMUNICAR³±±
±±³AO RESPONSAVEL PELO MODULO NA EQUIPE DE MATERIAIS. OBRIGADO.                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
#INCLUDE "MATXFUNA.CH"
#INCLUDE "MSSERIAL.CH"

#INCLUDE "PROTHEUS.CH"
#INCLUDE "FILEIO.CH"

Static __aMoeda
Static __aSimbMoeda

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MesExtenso³ Autor ³ Wagner Xavier         ³ Data ³ 03.02.93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna o nome do mes por extenso                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MesExtenso ( ExpN1 )                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Numero do Mes                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MesExtenso( nMes )
Local cRet := " "
Local aMeses := { OemToAnsi(STR0001),OemToAnsi(STR0002),OemToAnsi(STR0003),; // "Janeiro" ### "Fevereiro" ### "Marco"
	OemToAnsi(STR0004),OemToAnsi(STR0005),OemToAnsi(STR0006),; // "Abril" ### "Maio" ### "Junho"
	OemToAnsi(STR0007),OemToAnsi(STR0008),OemToAnsi(STR0009),; // "Julho" ### "Agosto" ### "Setembro"
	OemToAnsi(STR0010),OemToAnsi(STR0011),OemToAnsi(STR0012) } // "Outubro" ### "Novembro" ### "Dezembro"

If nMes == NIL
	nMes := Month ( dDataBase )
ElseIf ValType( nMes ) = "C"
	nMes := Int ( Val ( nMes ) )
ElseIf ValType ( nMes ) = "D"
	nMes := Month ( nMes )
EndIf

If nMes > 0 .and. nMes <= 12
	cRet := aMeses [ nMes ]
EndIf

Return cRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Moeda    ³ Autor ³ Wagner Xavier         ³ Data ³ 16/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Devolve o valor do titulo/or‡amento em 1 determinada moeda ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpN1:=Moeda(ExpN1,ExpN2,ExpC1,ExpD1)                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Valor a ser tratado                                ³±±
±±³          ³ ExpD1 = Moeda desejada                                     ³±±
±±³          ³ ExpN1 = Carteira - Receber / Pagar / Or‡amento             ³±±
±±³          ³ ExpD1 = Data utilizada para conversao                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Moeda(nValor,nMoeda,cCart,dData)
Local cAlias:=Alias(),nValRet:=0,nValBase,cCampo,nVlrCampo

cMoeda  := AllTrim(Str(nMoeda,2))
cMoedaAtu:= ""
dData   := Iif(dData==NIL,dDataBase,dData)

Do Case
Case ( cCart == "R" )
	cMoedaAtu := AllTrim( Str( SE1 -> E1_MOEDA, 2) )
Case ( cCart == "P" )
	cMoedaAtu := AllTrim( Str( SE2 -> E2_MOEDA, 2) )
Case ( cCart == "O" )
	cMoedaAtu := StrZero ( SE7 -> E7_MOEDA, 1 )
OtherWise
	Help ( " ", 1, "SEMMOEDA" )
	Return 0
EndCase

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se moeda pesquisa e' igual a digitada, devolve o proprio valor ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cMoeda==cMoedaAtu
	Return nValor
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica em que moeda esta' o titulo                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SM2")
HelpMoeda(nMoeda,dData,"NOTAXAS")
If cMoedaAtu $ "01"
	cCampo:= "M2_MOEDA"+cMoeda
	nVlrCampo:= FieldGet(FieldPos(cCampo))
	//nValBase := Iif( SM2->M2_MOEDA&cMoeda > 0,nValor,0)
	nValBase:= Iif( nVlrCampo > 0,nValor,0)
	//nValRet:=nValBase/Iif(SM2->M2_MOEDA&cMoeda>0,SM2->M2_MOEDA&cMoeda,1)
	nValRet:=nValBase/Iif( nVlrCampo>0,nVlrCampo,1)
Else
	cCampo:= "M2_MOEDA"+cMoedaAtu
	nVlrCampo:= FieldGet(FieldPos(cCampo))
	//nValBase:= nValor*SM2->M2_MOEDA&cMoedaAtu
	nValBase:= nValor*nVlrCampo

	If !(cMoeda $ "01")
		//nValBase := Iif(SM2->M2_MOEDA&cMoeda > 0,nValBase,0)
		nValBase := Iif( nVlrCampo > 0,nValBase,0)
		//nValRet :=nValBase/Iif(SM2->M2_MOEDA&cMoeda>0,SM2->M2_MOEDA&cMoeda,1)
		nValRet := nValBase/Iif( nVlrCampo>0, nVlrCampo,1)
	Else
		nValRet := nValBase
	EndIf
EndIf
DbSelectArea(cAlias)
Return nValRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ xFilial  ³ Autor ³ Wagner Xavier         ³ Data ³ 16.10.92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a filial utilizada por um determinado arquivo.     ³±±
±±³          ³ ( Arquivo Corrente )                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ xFilial()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function xFilial( cAlias , cFilPastPar )
Local nSizeFil      := 2
DEFAULT cAlias		:= Alias()
DEFAULT cFilPastPar := cFilAnt

If Len(cAlias) == 3
	__lFWSizeFilial := Iif(ValType(__lFWSizeFilial)=="U",FindFunction("FWSizeFilial"),__lFWSizeFilial)
	__lFWxFilial    := Iif(ValType(__lFWxFilial)=="U",FindFunction("FWxFilial"),__lFWxFilial)

	//-- Atualiza o conteúdo da filial
	If __lFWSizeFilial
		If ( __cUltFilSF == Nil ) .Or. !(__cUltEmpSF+__cUltFilSF == cEmpAnt+cFilAnt ) .Or. ( __nTamFil == Nil )
			__cUltEmpSF := cEmpAnt
			__cUltFilSF := cFilAnt
			__nTamFil := FWSizeFilial()
		EndIf
		nSizeFil := __nTamFil
	EndIf

	If nSizeFil > 2 .And. __lFWxFilial
		cFilPastPar := FWxFilial(cAlias,cFilPastPar)
	Else
		IF ( At( cAlias + 'E', cArqTab ) > 0 )
			cFilPastPar	:= Pad(IF( Empty( cFilPastPar ) , cFilAnt , cFilPastPar ),nSizeFil)
		Else
			cFilPastPar := Space(nSizeFil)
		EndIF
	EndIf
Else
	cFilPastPar := Space(len(cFilAnt))
End
Return( cFilPastPar )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SaldoCC  ³ Autor ³ Wagner Xavier         ³ Data ³ 16.10.92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula o saldo atual de um determinado Centro de Custo/Con³±±
±±³          ³ ta. (Extra Contabil).                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SaldoCC(ExpC1,ExpC2,ExpN1,ExpN2)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Codigo Centro de Custo                                     ³±±
±±³Parametros³ Codigo da conta                                            ³±±
±±³Parametros³ Numero do Mes                                              ³±±
±±³Parametros³ Moeda                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SaldoCC(cCusto,cConta,nPer,nMoeda)
Local nSaldo
Local n
Local cAlias := Alias( )
Local nReg
nMoeda:=Iif(nMoeda==NIL,1,nMoeda)

If !Empty(cCusto) .And. !Empty(cConta)
	cCusto := Iif(Len(Trim(cCusto))< 9,Trim(cCusto)+Space( 9-Len(Trim(cCusto))),SubStr(cCusto,1, 9))
	cConta := Iif(Len(Trim(cConta))<20,Trim(cConta)+Space(20-Len(Trim(cConta))),SubStr(cConta,1,20))

	DbSelectArea("SI3")
	nReg := Recno()
	If !(DbSeek(xFilial()+cCusto+cConta+Str(nMoeda,1)))
		dbGoto(nReg)
		DbSelectArea(cAlias)
		Return 0
	EndIf
EndIf

nSaldo:=SI3->I3_SALINI

For n := 1 to nPer
	cSuf    := Strzero(n,2)
	nSaldo  := nSaldo-I3_DEB&cSuf+I3_CRE&cSuf
Next n
Return nSaldo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A370VerFor³ Autor ³ Claudinei M. Benzi    ³ Data ³ 10/11/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina verificadora da formula digitada na rotina de fórmula±±
±±           ³ e também no cadastro de fórmulas do Protheus Report.		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION A370VerFor(void, lReport, cFormula)
Local xResult,cForm,cStrForm, cAlias, aAlias := {}
Local bBlock:=ErrorBlock(),bErro := ErrorBlock( { |e| ChecErro(e) } )
Local i, cSavAlias := Alias()
Local cNomeRot := ''

Default lReport := .F.
Default cFormula := ""

Private lRet:=.T.

IF !lReport
	cForm:=&(ReadVar())
Else
	cForm:=cFormula
EndIf

cStrForm := UPPER(cForm)
For i:= 1 to Len(cStrForm)
	nPos := At("_",cStrForm)
	If nPos == 0
		Exit
	EndIf
	If Substr(cStrForm,nPos-3,1)$(">()-+*/[]{}'"+'"')
		cAlias := "S"+Subs(cStrForm,nPos-2,2)
	Else
		cAlias := Subs(cStrForm,nPos-3,2)
	EndIf
	If Select(cAlias) == 0 .and. ASCAN(aAlias,cAlias) == 0
		AADD(aAlias,cAlias)
	EndIf
	cStrForm := Substr(cStrForm,nPos+1,Len(cStrForm))
Next

If CanExeFor( cForm, @cNomeRot )
	IF !lReport
		BEGIN SEQUENCE

		xResult := &cForm

		For i:= 1 to Len(aAlias)
			If Select(aAlias[i]) > 0
				DbSelectArea(aAlias[i])
				DbCloseArea()
			EndIf
		Next

		END SEQUENCE
	EndIf
Else
	lRet := .F.
	Help( ,,'HELP', "ERROR", "Improper Function Use: " + cNomeRot, 1, 0)
EndIf


DbSelectArea(cSavAlias)
ErrorBlock(bBlock)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ RecMoeda ³ Autor ³ Claudinei M. Benzi    ³ Data ³ 10/11/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina de verIficacao de valor da moeda em detrminada data ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ nExp1:= RecMoeda(dExp1,cExp1)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nExp1:= Retorna valor da moeda solicitada                  ³±±
±±³          ³ dExp1:= Data recebida para posicionamento no Arq. de Moedas³±±
±±³          ³ cExp1:= Moeda a qual deseja-se verIficar o valor           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA370                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

FUNCTION RecMoeda(dData,cMoeda,lVlReal)

Local aArea   	:= GetArea()
Local nMoeda
Local nX, cX
Local lAchou 	:= .F.
Local cRotina:=""

DEFAULT __aMoeda := {CTOD("  /  /  ")}
DEFAULT lVlReal  := .F.

If ValType(dData) == "C"
	dData := STOD(dData)
EndIf
If ( ValType(cMoeda) = "N" )
	cMoeda := AllTrim(Str(cMoeda,2))
EndIf

If ( Empty(cMoeda) .Or. cMoeda == "0" )
	cMoeda := "1"
EndIf
nMoeda := Val(cMoeda)

If Empty(dData)       // Nao Pediu Nada
	Return 0
EndIf

If nMoeda == 1
	Return 1
EndIf

If __aMoeda[1] == dData
	Return __aMoeda[nMoeda]
EndIf

DbSelectArea("SM2")
If Len(__aMoeda) == 1          // Ainda nao vi o Tamanho do Array
	For nX := 2 to 99
		cX := AllTrim(Str(nX,2,0))
		If FieldPos("M2_MOEDA"+cX) > 0
			AADD(__aMoeda,0)
		Else
			Exit
		EndIf
	Next
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona arquivo SM2 na data mais proxima                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lVlReal
	DbSeek(dData,.T.)
	If ( Eof() )
		DbSkip(-1)
	EndIf
	lAchou := .T.
Else
	If !DbSeek(dData)
		__aMoeda[1] := dData
	Else
		lAchou := .T.
	Endif
Endif

If lAchou 
	For nX := 2 to Len(__aMoeda)
		cX := AllTrim(Str(nX,2,0))
		__aMoeda[nX] := FieldGet(FieldPos("M2_MOEDA"+cX))
	Next
Endif

RestArea(aArea)

IF cPaisLoc == "PAR" .AND. (ExistBlock("NVLRECMOE"))

	cRotina := Alltrim(funname())
	__aMoeda:= ExecBlock("NVLRECMOE",.F.,.F.,{dData,cRotina,__aMoeda,nMoeda})

EndIf

Return( __aMoeda[nMoeda] )

Function LimpaMoeda()
__aMoeda := Nil
return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Tabela   ³ Autor ³ Jorge Queiroz         ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Devolve o conteudo da tabela de acordo com a chave         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpC1 := Tabela(ExpC2,ExpC3)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conteudo da Tabela                                 ³±±
±±³          ³ ExpC2 = Codigo da Tabela                                   ³±±
±±³          ³ ExpC3 = Chave para a Tabela                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION Tabela(cTab,cXav,lPrint)
Local cRet		:=""
Local cMens 	:= ""
Local xAlias 	:= Alias()

Default	lPrint	:= .T.
DbSelectArea("SX5")
DbSeek( xFilial("SX5") + cTab + cXav)

If ( ! Found() .And. lPrint )
	If !( "FWCONFIGFILIAL" $ DWCallStack(,,.F.) )
		cMens := "SX5"+" "+STR0046+" "+cTab+" "+STR0047+" "+cXav  				//Tabela#Chave
		Help(" ",1,"NOTAB",,cMens,4,1)
	EndIf
Else
	cRet := AllTrim( X5Descri() )
EndIf

If !Empty(xAlias)
	DbSelectArea(xAlias)	
EndIf
Return cRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SaldoSB2 ³ Autor ³ Eveli Morasco         ³ Data ³ 15/04/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcula o saldo do arquivo SB2                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpN1 := SaldoSB2(ExpL1,ExpL2,ExpD1,ExpL3,ExpN1)           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Saldo devolvido pela funcao                        ³±±
±±³          ³ ExpL1 = Flag que indica se chamada da funcao ‚ utilizada p/³±±
±±³          ³ calculo de necessidade. Caso .T. deve considerar quantidade³±±
±±³          ³ a distribuir, pois a mesma apenas nao pode ser utilizada,  ³±±
±±³          ³ porem ja esta em estoque.                                  ³±±
±±³          ³ ExpL2 = Flag que indica se deve substrair o empenho do     ³±±
±±³          ³ saldo a ser retornado.                                     ³±±
±±³          ³ ExpD1 = Data final para filtragem de empenhos. Empenhos ate³±±
±±³          ³ esta data serao considerados no caso de leitura do SD4.    ³±±
±±³          ³ ExpL3 = Flag que indica se deve considerar o saldo de terc ³±±
±±³          ³ eiros em nosso poder ou nao (B2_QTNP).                     ³±±
±±³          ³ ExpL4 = Flag que indica se deve considerar nosso saldo em  ³±±
±±³          ³ poder de terceiros ou nao (B2_QNPT).                       ³±±
±±³          ³ ExpN1 = Qtd empenhada para esse movimento que nao deve ser ³±±
±±³          ³ subtraida                                                  ³±±
±±³          ³ ExpN2 = Qtd empenhada do Projeto para esse movimento que   ³±±
±±³          ³ nao deve ser subtraida                                     ³±±
±±³          ³ ExpL5 = Subtrai a Reserva do Saldo a ser Retornado?        ³±±
±±³          ³ ExpD2 = Data limite para composicao do saldo MV_TPSALDO="C"³±±
±±³          ³ ExpL6 = Subtrai a Quantidade Prevista no SA a ser Retornado³±±
±±³          ³         Obs.: Somente funciona se o MV_TPSALDO for "C"     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function SaldoSB2(lNecessidade,lEmpenho,dDataFim,lConsTerc,lConsNPT,cAliasSB2,nQtdEmp,nQtdPrj,lSaldoSemR,dDtRefSld,lConsEmpSA)
Local aAreaAnt   := GetArea()
Local aAreaSC2   := SC2->(GetArea())
Local aAreaSD4   := SD4->(GetArea())
Local aAreaSDC   := SDC->(GetArea())

Local cSeekSDC   := ""
Local cComparaSDC:= ""

Local nEmpenho   := 0
Local nEmpProj   := 0
Local nEmpenhoD4 := 0
Local nScanSD4   := 0
Local nRet       := 0

Local lProcessD4 := .T.
Local lEmpPrj    := .F.
Local lRastro    := .F.
Local lLocaliza  := .F.
Local lSaldoMov  := .F.
Local lCondEmp   := .F.
Local lQEmpNF	 := GetNewPar("MV_QEMPNF",.F.)	//Considera o campo B2_QEMPN no calculo do Saldo
Local lAtuSGJ	 := SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")
Local lMTSldSer  := lSaldoSemR
Local lConsAlmTer:= SuperGetMV("MV_SLDATER",.F.,.F.) 
Local nRecSB2	 := 0
Local cFilAlm	 := ""
Local cProdAlm	 := ""
Local cAlmTer 	 := GetMvNNR('MV_ALMTERC','80')
Local nQtAlmTer  := 0
Local nQtdLibP3	 := 0

Default cAliasSB2    := "SB2"
Default lNecessidade := .F.
Default lEmpenho     := .T.
Default lConsTerc    := .T.
Default lConsNPT     := .F.
Default lSaldoSemR   := .T.
Default lConsEmpSA   := .T.
Default nQtdEmp      :=  0
Default nQtdPrj      :=  0

If lAtuSGJ
	lQEmpNF	:= .F.
Endif

lEmpPrj    := ( nQtdPrj > 0 )
lSaldoMov  := ( Valtype(dDtRefSld)=="D" .And. GetMV("MV_TPSALDO")=="C" )
lCondEmp   := ( ValType(dDataFim) =="D" .And. GetMV("MV_CONDEMP")=="S" )

If ExistBlock("MTSLDSER") .And. ValType(lMTSldSer := ExecBlock("MTSLDSER",.F.,.F.,{(cAliasSB2)->B2_COD})) == "L"
	lSaldoSemR := lMTSldSer
EndIf

If (cAliasSB2)->B2_STATUS <> "2"
	nEmpenho   := (cAliasSB2)->(B2_QEMP)
	nEmpProj   := (cAliasSB2)->(B2_QEMPPRJ)
	nEmpenhoD4 :=0
	#IFDEF TOP
		If !lEmpPrj .And. lEmpenho .And. ( lSaldoMov .Or. lCondEmp )
			If __cNumOP == NIL
				AtuVarOper()
			EndIf
			lQuery 	   := .T.
			lLocaliza  := Localiza((cAliasSB2)->B2_COD)
			lRastro    := Rastro((cAliasSB2)->B2_COD)
			cAliasSD4  := GetNextAlias()
			aStructSD4 := SD4->( dbStruct() )

			cQuery := "SELECT D4_FILIAL,D4_COD,D4_LOCAL,D4_DATA,D4_QUANT,D4_OP,D4_LOTECTL,D4_NUMLOTE,D4_TRT "
			cQuery += "FROM " + RetSqlName("SD4") + " SD4 " 
			cQuery += "JOIN "+RetSqlName("SC2")+" SC2 "
			cQuery += "ON SC2.C2_FILIAL = '"+ xFilial("SC2")+"' AND "
			cQuery += "SC2.C2_NUM   	= " + __cNumOP  + " AND "
			cQuery += "SC2.C2_ITEM      = " + __cItemOP + " AND "
			cQuery += "SC2.C2_SEQUEN    = " + __cSeqOP  + " AND "
			cQuery += "SC2.C2_TPOP IN (' ','F') AND "
			cQuery += "SC2.D_E_L_E_T_ = ' '"
			cQuery +=      "WHERE "
			cQuery +=         "SD4.D4_FILIAL ='" + xFilial("SD4")			+ "' AND "
			cQuery +=         "SD4.D4_COD ='"    + (cAliasSB2)->B2_COD		+ "' AND "
			cQuery +=         "SD4.D4_LOCAL ='"  + (cAliasSB2)->B2_LOCAL	+ "' AND "
			cQuery +=         "SD4.D4_DATA <='"  + IIf(lSaldoMov,DTOS(dDtRefSld),DTOS(dDataFim)) + "' AND "
			cQuery +=         "SD4.D4_QUANT > 0 AND "
			cQuery +=         "SD4.D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery( cQuery )

			dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQuery ), cAliasSD4, .F., .T. )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Ajusta campos data e numericos                                            |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty( nScanSD4 := AScan( aStructSD4, { |x| x[1] == "D4_QUANT" } ) )
				TcSetField( cAliasSD4, aStructSD4[nScanSD4,1],aStructSD4[nScanSD4,2],aStructSD4[nScanSD4,3],aStructSD4[nScanSD4,4] )
			EndIf
			If !Empty( nScanSD4 := AScan( aStructSD4, { |x| x[1] == "D4_DATA" } ) )
				TcSetField( cAliasSD4, aStructSD4[nScanSD4,1],aStructSD4[nScanSD4,2],aStructSD4[nScanSD4,3],aStructSD4[nScanSD4,4] )
			EndIf

			While !Eof()
				// Se existe algum empenho com lote preenchido, assume empenho do SB2
				// pois os saldos dos lotes ja estao comprometidos com a colocacao
				// do empenho
				If lRastro .And. !Empty(D4_LOTECTL+D4_NUMLOTE)
					lProcessD4:=.F.
				EndIf
				// Se existe algum empenho com localizacao, assume empenho do SB2
				// pois os saldos das localizacoes ja estao comprometidos com a colocacao
				// do empenho
				If lProcessD4 .And. lLocaliza
					cSeekSDC   :=xFilial("SDC")+(cAliasSD4)->(D4_COD+D4_LOCAL+D4_OP+D4_TRT)
					cComparaSDC:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT"
					dbSelectArea("SDC")
					dbSeek(cSeekSDC)
					While lProcessD4 .And. !Eof() .And. cSeekSDC == &(cComparaSDC)
						If QtdComp(DC_QUANT) > QtdComp(0)
							lProcessD4:=.F.
							Exit
						EndIf
						dbSkip()
					End
				EndIf
				dbSelectArea(cAliasSD4)
				// Soma quantidade do empenho
				nEmpenhoD4+=(cAliasSD4)->D4_QUANT
				dbSkip()
			End
			If lProcessD4
				nEmpenho:=nEmpenhoD4
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Fecha a area de trabalho da query                                         |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			(cAliasSD4)->(dbcloseArea())
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Restaura Tabelas                                                          |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			RestArea(aAreaSC2)
			RestArea(aAreaSD4)
			RestArea(aAreaSDC)
		EndIf

	#ELSE
		If !lEmpPrj .And. lEmpenho .And. ( lSaldoMov .Or. lCondEmp )
			// Varre empenhos ate a data estipulada
			dbSelectArea("SC2")
			dbSetOrder(1)
			dbSelectArea("SDC")
			dbSetOrder(2)
			dbSelectArea("SD4")
			dbSetOrder(3)
			dbSeek(xFilial()+(cAliasSB2)->B2_COD+(cAliasSB2)->B2_LOCAL)
			While lProcessD4 .And. !Eof() .And. D4_FILIAL+D4_COD+D4_LOCAL == xFilial()+(cAliasSB2)->B2_COD+(cAliasSB2)->B2_LOCAL
				// Se existe algum empenho com lote preenchido, assume empenho do SB2
				// pois os saldos dos lotes ja estao comprometidos com a colocacao
				// do empenho
				If lRastro .And. !Empty(D4_LOTECTL+D4_NUMLOTE)
					lProcessD4:=.F.
				EndIf
				// Se existe algum empenho com localizacao, assume empenho do SB2
				// pois os saldos das localizacoes ja estao comprometidos com a colocacao
				// do empenho
				If lProcessD4 .And. lLocaliza
					cSeekSDC:=xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT
					cComparaSDC:="DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT"
					dbSelectArea("SDC")
					dbSeek(cSeekSDC)
					While lProcessD4 .And. !Eof() .And. cSeekSDC == &(cComparaSDC)
						If QtdComp(DC_QUANT) > QtdComp(0)
							lProcessD4:=.F.
							Exit
						EndIf
						dbSkip()
					End
				EndIf
				dbSelectArea("SD4")
				// Soma quantidade do empenho
				If QtdComp(D4_QUANT) > QtdComp(0) .And. D4_DATA <= IIf(lSaldoMov,dDtRefSld,dDataFim) .And. ;
					SC2->(dbSeek(xFilial("SC2")+SD4->D4_OP)) .And. SC2->C2_TPOP $ " F"
					nEmpenhoD4+=D4_QUANT
				EndIf
				dbSkip()
			End
			If lProcessD4
				nEmpenho:=nEmpenhoD4
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Restaura Tabelas                                                          |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			RestArea(aAreaSC2)
			RestArea(aAreaSD4)
			RestArea(aAreaSDC)
		EndIf
	#ENDIF

	// Caso baixe empenho nao subtrai a qtd empenhada para esse item
	If !lEmpPrj
		nEmpenho-=nQtdEmp
		nEmpenho:=Max(nEmpenho,0)
	Else
		nEmpProj-=nQtdPrj
		nEmpProj:=Max(nEmpProj,0)
	EndIf
	
	If (cAliasSB2)->B2_RESERVA > 0 .And. !lConsTerc .And. cAliasSb2 == "SB2" .And. (IsInCallStack("A410Grava") .Or. IsInCallStack("Ma410LbNfs") .Or. IsInCallStack("A440Libera")) .And. FindFunction("A440P3QtdLib")
		//Valida as quantidades liberadas de produtos de poder de terceiros
		nQtdLibP3 := A440P3QtdLib((cAliasSB2)->B2_COD,(cAliasSB2)->B2_LOCAL)
	EndIf
	
	If IsInCallStack('MATA650') .and. lConsNPT .and. lConsAlmTer .and. cAliasSb2 == 'SB2'
		cFilAlm:= (cAliasSB2)->B2_FILIAL
		cProdAlm:=(cAliasSB2)->B2_COD
		nRecSB2:= (cAliasSB2)->(Recno())
		(cAliasSB2)->(dbSetOrder(1))
		(cAliasSB2)->(MsSeek(cFilAlm+cProdAlm+cAlmTer))
		nQtAlmTer:= (cAliasSB2)->B2_QATU
		(cAliasSB2)->(DbGoto(nRecSB2))
	ENDIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Calculo do saldo Disponivel                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lSaldoMov
		// Calcula saldo ate o momento da data de referencia - MV_TPSALDO = 'C'
		nRet:=QtdComp( CalcEst((cAliasSB2)->B2_COD,(cAliasSB2)->B2_LOCAL,dDtRefSld+1)[1] - If(lSaldoSemR,(cAliasSB2)->B2_RESERVA,0) + nQtdLibP3 - If(lEmpenho,nEmpenho,0) - If(lNecessidade,0,(cAliasSB2)->B2_QACLASS) - Iif(lConsEmpSA,(cAliasSB2)->B2_QEMPSA,0) - If(lEmpenho,nEmpProj,0) - AvalQtdPre("SB2",1,NIL,cAliasSB2) - If(lConsTerc,0,(cAliasSB2)->B2_QTNP) - If(lQEmpNF,If(lSaldoSemR,(cAliasSB2)->B2_QEMPN,0),0) + If(lConsNPT,(cAliasSB2)->B2_QNPT+nQtAlmTer,0) )
	Else
	    // Calcula saldo da posicao atual - MV_TPSALDO = 'S'
		nRet:=QtdComp((cAliasSB2)->B2_QATU - If(lSaldoSemR,(cAliasSB2)->B2_RESERVA,0) + nQtdLibP3 - If(lEmpenho,nEmpenho,0) - If(lNecessidade,0,(cAliasSB2)->B2_QACLASS) - Iif(lConsEmpSA,(cAliasSB2)->B2_QEMPSA,0) - If(lEmpenho,nEmpProj,0) - AvalQtdPre("SB2",1,NIL,cAliasSB2) - If(lConsTerc,0,(cAliasSB2)->B2_QTNP) - If(lQEmpNF,If(lSaldoSemR,(cAliasSB2)->B2_QEMPN,0),0) + If(lConsNPT,(cAliasSB2)->B2_QNPT+nQtAlmTer,0) )
	EndIf
	RestArea(aAreaAnt)
EndIf
Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³SldBlqSB2 ³ Autor ³ Larson Zordan         ³ Data ³ 12/06/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica o status do saldo do armazem 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := SldBlqSB2(ExpC1,ExpC2,ExpC3,ExpL1)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Produto                                            ³±±
±±³          ³ ExpC2 = Armazem                                            ³±±
±±³          ³ ExpC3 = Alias do SB2                                       ³±±
±±³          ³ ExpL1 = Exibe Mensagem do Help                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 = (.T.) Disponivel  (.F.) Indisponivel               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function SldBlqSB2(cProd,cLocal,cAliasSB2,lMsg)
Local aAreaAnt    := GetArea()
Local lRet        := .T.
Local cMsg        := ""

DEFAULT cAliasSB2 := "SB2"
DEFAULT cProd     := ""
DEFAULT lMsg      := .T.

If !Empty(cProd)
	dbSelectArea(cAliasSB2)
	dbSeek(xFilial(cAliasSB2)+cProd+cLocal)
	cMsg := Rtrim(RetTitle("B2_COD"))+": " + cProd + Rtrim(RetTitle("B2_LOCAL"))+": " + cLocal
EndIf

If (cAliasSB2)->B2_STATUS == "2"
	If lMsg
		Help(" ",1,"SLDBLQSB2",,cMsg,3,0)
	EndIf
	lRet := .F.
EndIf

RestArea(aAreaAnt)
Return( lRet )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Formula  ³ Autor ³ Claudinei M. Benzi    ³ Data ³ 10/11/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Interpreta formula cadastrada                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ xExp1:= Formula(cExp1,nExp2)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ xExp1:= Retorna formula iterpretada                        ³±±
±±³          ³ cExp1:= Codigo da formula previamente cadastrada em SM4    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION Formula(cFormula)
Local xAlias, cForm:=" ", xValor
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Salva a integridade dos dados                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
xAlias := Alias()

DbSelectArea("SM4")
DbSeek(xFilial("SM4")+cFormula)
If Found()
	cForm := AllTrim(M4_FORMULA)
	If !Empty(xAlias)
		DbSelectArea(xAlias)
	EndIf
	xValor := &cForm
Else
	xValor := NIL
EndIf
If !Empty(xAlias)
	DbSelectArea(xAlias)
EndIf

Return xValor

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ xMoeda   ³ Autor ³ Wilson Junior         ³ Data ³ 13/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para conversao de valores entre Moedas              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ nExp4:= xMoeda(nExp1,nExp2,nExp3,dExp1)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nExp1:= Valor da Moeda de Partida                          ³±±
±±³          ³ nExp2:= Numero da Moeda de Partida                         ³±±
±±³          ³ nExp3:= Numero da Moeda de Destino                         ³±±
±±³          ³ nExp4:= Valor na Moeda de Destino                          ³±±
±±³          ³ dExp1:= Data base da Conversao                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION xMoeda(nValor,nMoedp,nMoedd,dData,nDecimal,nTaxap,nTaxad,lCallArr)
Local nValret
Local nRetPe
Local nTamDec
Local lArred := .T.
Default lCallArr := .F.
dData   := Iif(dData    == Nil,dDataBase,dData)
nDecimal:= Iif(nDecimal == Nil,2,nDecimal)
nMoedp  := Iif(nMoedp   == Nil,1,nMoedp)
nMoedp  := Iif(nMoedp   == 0,1,nMoedp)
nMoedd  := Iif(nMoedd   == Nil,1,nMoedd)
nTaxap  := Iif(nTaxap   == Nil,0,nTaxap)
nTaxad  := Iif(nTaxad   == Nil,0,nTaxad)
nTamDec := GetSx3Cache("E1_TXMOEDA", "X3_DECIMAL")

// Adicionado validação para efeito de performance no FINR130 e MATR550
If cPaisLoc == "BRA" .And. !(Alltrim(Upper(FunName())) $ "FINR130|MATR550|FINC021")
	If IsInCallStack("fa070Calc") .Or. IsInCallStack("fa070ValVR") .Or. IsInCallStack("FINA110") .Or. lCallArr
		If ( SE1->E1_MOEDA > 1 .And. SE1->E1_TXMOEDA > 0 .And. nDecimal <> nTamDec ) .OR. ( nDecimal <> nTamDec .AND. lCallArr )
			lArred	:=	.F.
		Endif
	Endif
EndIf

If nMoedd == nMoedp
	nValRet := nValor
Else
	nValRet := (nValor * Iif (nMoedp!=1,Iif(nTaxap==0,RecMoeda(dData,nMoedp),nTaxap) ,1 ))
	If !( !lArred .And. Iif (nMoedd!=1, Iif(nTaxad==0,RecMoeda(dData,nMoedd),nTaxad) ,1 ) == 1 )
		If cPaisLoc	== "RUS"
			nValRet := Round (nValRet / Iif (nMoedd!=1, Iif(nTaxad==0,RecMoeda(dData,nMoedd),nTaxad) ,1 ) ,nDecimal)
		Else
			nValRet := NoRound (nValRet / Iif (nMoedd!=1, Iif(nTaxad==0,RecMoeda(dData,nMoedd),nTaxad) ,1 ) ,nDecimal)
		Endif
	EndIf
EndIf

//Ponto de entrada para permitir alterar o valor da conversao da xMoeda
//com o intuito de adaptar as regras de arredondamento do cliente
__lMTXMOEDA := If(__lMTXMOEDA==Nil,ExistBlock("MTXMOEDA"),__lMTXMOEDA)
If __lMTXMOEDA
	nRetPe := ExecBlock("MTXMOEDA",.F.,.F.,{nValor,nMoedp,nMoedd,dData,nDecimal,nTaxap,nTaxad,nValRet})
	If ValType(nRetPe) == "N"
		nValRet := nRetPe
	EndIf
EndIf

Return (nValRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CalcEstSeg³ Autor ³ Wilson Junior         ³ Data ³ 23/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para calculo do Est.Seguranca                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ nExp2:= CalcEstSeg(cExp1)                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cExp1:= Formula enviada para interpretacao                 ³±±
±±³          ³ nExp2:= Estoque de seguranca Calculado                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcEstSeg(cFormula,cAliasSB1)

Local nRet := 0

DEFAULT cAliasSB1 := "SB1"

nRet := RetFldProd((cAliasSB1)->B1_COD,"B1_ESTSEG",cAliasSB1)

cFormula:=Iif(cFormula == Nil,"   ",cFormula)
If !Empty(cFormula)
	If cAliasSB1 # "SB1"
		SB1->(dbSetOrder(1))
		SB1->(dbSeek(xFilial("SB1") + (cAliasSB1)->(B1_COD)))
	Endif
	nRet:=Formula(cFormula)
	If ValType(nRet) # "N"
		Aviso('STR0026',OemToAnsi(STR0035)+SB1->B1_COD+OemToAnsi(STR0036),{'Ok'}) //"A formula de estoque de seguranca do produto "###" esta retornando valor incorreto. A formula sera desconsiderada"
		nRet:=RetFldProd(SB1->B1_COD,"B1_ESTSEG")
	EndIf
EndIf
Return (nRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³Media   ³ Autor ³ Wagner Xavier       ³ Data ³ 03.02.93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna a taxa media de uma moeda em um determinado mes/ano.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Media( ExpN1, ExpN2,ExpN3 )                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1 := Moeda                                ³±±
±±³      ³ExpN2 := Mes (Default Mes da database)                ³±±
±±³      ³ExpN3 := Ano (Default Ano da database)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Media( nMoeda, nMes, nAno )

Local cAlias := Alias( )
Local dDataIni
Local nMedia := 0
Local nDias  := 0

nMoeda := Iif( nMoeda = Nil .or. nMoeda = 0, 1, nMoeda )
nMes   := Iif( nMes  = Nil .or. nMes   = 0, Month( dDataBase ), nMes )
nAno   := Iif(nAno=Nil.or.nAno=0,Int(Val(SubStr(StrZero(Year(dDataBase),4),3,2))),nAno)

cMoeda := Str( nMoeda, 1 )

DbSelectArea("SM2")
dDataIni:=Ctod("01/"+Strzero(nMes,2)+"/"+StrZero(nAno,2), "ddmmyy")
DbSeek(dDataIni,.T.)
While !Eof() .and. Month(dDataIni)==Month(M2_DATA) .and. Year( M2_DATA ) == Year( dDataIni )

	If M2_MOEDA&cMoeda != 0
		nMedia += M2_MOEDA&cMoeda
		nDias++
	EndIf

	DbSkip( )

End

DbSelectArea( cAlias )

Return ( Iif ( nMedia != 0 , nMedia / nDias, 0 ) )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³ CalcSaldo³ Autor ³ Wagner Xavier       ³ Data ³ 16.10.92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula o saldo atual de uma determinada conta at‚ um deter³±±
±±³      ³ minado periodo.                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CalcSaldo(ExpN1)                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Numero do Periodo, Moeda                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcSaldo(nPer,nMoeda,lSaldant)
Local nSaldo := 0
Local nC,cAlias:= Alias()
Local lSoma, nDecimais, nOldSx3 := Sx3->(recno()),nOldOrd := Sx3->(indexord())

lSaldant := Iif(lSaldant==Nil,.T.,lSaldant)
nMoeda:=Iif(nMoeda==NIL,1,nMoeda)

DbSelectArea("SX3")
DbSetOrder(2)

If nMoeda == 1
	DbSeek("I1_SALANT")
	nDecimais := X3_DECIMAL
Else
	DbSeek("I7_SALANT")
	nDecimais := X3_DECIMAL
EndIf
DbSetOrder(nOldOrd)
DbGoTo(nOldSx3)

If nMoeda == 1
	DbSelectArea("SI1")
Else
	DbSelectArea("SI7")
EndIf

If lSaldant .or. nPer <= 12   // Esta no pr¢prio Ano, sempre considera
	nSaldo:=Iif(nMoeda==1,Round(I1_SALANT,nDecimais),Round(I7_SALANT,nDecimais))
EndIf

For nC:=1 To nPer

	lSoma := .t.

	If lSaldant
		lSoma := .t.
	ElseIf nPer == 12 .and. !lSaldant             // saldo anterior do Mes 01
		lSoma := .f.
	ElseIf nPer <= 12                      // ‚ do pr¢prio ano, sempre soma
		lSoma := .t.
	ElseIf nPer > 12 .and. nC <= 12 .and. !lSaldant  // ‚ do prox exerc, s¢ soma neste ano
		lSoma := .f.
	EndIf

	If lSoma
		cSuf:=Strzero(nC,2)
		nSaldo:=Iif(nMoeda==1, Round(nSaldo-Round(I1_DEBM&cSuf,nDecimais)+;
			Round(I1_CRDM&cSuf,nDecimais),nDecimais),;
			Round(nSaldo-Round(I7_DEBM&cSuf,nDecimais)+;
			Round(I7_CRDM&cSuf,nDecimais),nDecimais))
	EndIf
Next nC

DbSelectArea(cAlias)
Return Round(nSaldo,nDecimais)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ UpdatSint³ Autor ³ Antonio Maniero Jr.   ³ Data ³ 25.04.94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza arquivo que controla as contas sinteticas       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ UpdatSint(nMesA,cOp)                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UpdatSint( nMesA,cOp )
Local cVar
Local cX_Cont
Local cArea := Alias( )
Local nSizeFil := 2
cOp  := Iif( cOp==Nil,"N",cOp )

//-- Atualiza o conteúdo da filial
If FindFunction("FWSizeFilial")
	nSizeFil := FWSizeFilial()
EndIf

If cNumEmp == Nil
	cNumEmp := (SM0->M0_CODIGO + Pad(SM0->M0_CODFIL,nSizeFil))
EndIf
cVar := "MV_SIN" + SubStr(cNumEmp,1,2)+xFilial("SI1")
DbSelectArea("SX6")
DbSetOrder(1)
If !( DbSeek( Space(nSizeFil) + cVar ) )
	RecLock("SX6",.T.)
	Replace X6_FIL    With Space(nSizeFil)
	Replace X6_VAR    With "MV_SIN"+SubStr(cNumEmp,1,2)+xFilial("SI1")
	Replace X6_TIPO   With "C"
	Replace X6_CONTEUD  With Replicate("N",17)
	Replace X6_CONTENG  With Replicate("N",17)
	Replace X6_CONTSPA  With Replicate("N",17)
	Replace X6_DESCRIC  With "Parametro que indica qual o Per¡odo Contabil que"
	Replace X6_DESC1    With "teve suas contas sint‚ticas atualizadas. A cada "
	Replace X6_DESC2    With "caractere corresponde um per¡odo (S=SIM/N=NAO)."

	Replace X6_DSCSPA   With "Parametro que muestra cual es el periodo contable"
	Replace X6_DSCSPA1  With "que tuvo sus cuentas sint‚ticas actualizadas. Cada"
	Replace X6_DSCSPA2  With "caracter corresponde a un periodo (S=s¡ / N=no)."

	Replace X6_DSCENG   With "Parameter indicating the accounting period which"
	Replace X6_DSCENG1  With "has synthetic accounts updated. each character"
	Replace X6_DSCENG2  With "corresponds to one period (s=yes/n=no)"


EndIf

If Empty(X6_CONTEUD) .OR. Empty(X6_CONTENG) .OR. Empty(X6_CONTSPA)
	RecLock("SX6",.F.)
	Replace X6_CONTEUD  With Replicate("N",17)
	Replace X6_CONTENG  With Replicate("N",17)
	Replace X6_CONTSPA  With Replicate("N",17)
EndIf
cX_Cont    := Stuff( X6_CONTEUD,nMesA,1,cOp )
cX_ContSPA := Stuff( X6_CONTSPA,nMesA,1,cOp )
cX_ContENG := Stuff( X6_CONTENG,nMesA,1,cOp )

If Upper(SubStr( SX6->X6_CONTEUD, nMesA, 1 )) != Upper(cOp) .or. Upper(SubStr( SX6->X6_CONTSPA, nMesA, 1 )) != Upper(cOp) .or.Upper(SubStr( SX6->X6_CONTENG, nMesA, 1 )) != Upper(cOp)
	RecLock("SX6",.F.)
	Replace X6_CONTEUD With cX_Cont
	Replace X6_CONTENG With cX_ContENG
	Replace X6_CONTSPA With cX_ContSPA
EndIf

MsUnLock()

DbSelectArea(cArea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ CheckSint³ Autor ³ Antonio Maniero Jr.   ³ Data ³ 25.04.94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ VerIfica se as contas sinteticas estao atualizadas       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ CheckSint(nMes)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CheckSint(nPer,nMes,lExibe)
Local lRet:=.f.
Local cVar
Local cAlias := Alias( )
Local nSizeFil := 2

//-- Atualiza o conteúdo da filial
If FindFunction("FWSizeFilial")
	nSizeFil := FWSizeFilial()
EndIf

nMes  := Iif(nMes==Nil,nPer,nMes)
cVar  := "MV_SIN" + SubStr(cNumEmp,1,2)+xFilial("SI1")
lExibe:= Iif(lExibe==Nil,.T.,lExibe)
DbSelectArea("SX6")
DbSetOrder(1)
If !( DbSeek(Space(nSizeFil) + cVar ) )
	RecLock("SX6",.T.)
	Replace X6_FIL    With Space(nSizeFil)
	Replace X6_VAR    With "MV_SIN"+SubStr(cNumEmp,1,2)+xFilial("SI1")
	Replace X6_TIPO   With "C"
	Replace X6_CONTEUD  With Replicate("N",17)
	Replace X6_DESCRIC  With "Parametro que indica qual o Per¡odo Contabil que"
	Replace X6_DESC1    With "teve suas contas sint‚ticas atualizadas. A cada "
	Replace X6_DESC2    With "caractere corresponde um per¡odo (S=SIM/N=NAO)."
	MsUnlock()
EndIf

If Empty(X6_CONTEUD)
	RecLock("SX6")
	Replace X6_CONTEUD With Replicate("N",17)
	MsUnlock( )
EndIf

If Substr(GetMv("MV_SIN"+SubStr(cNumEmp,1,2)+xFilial("SI1")),nPer,1) == "N"
	If lExibe
		Set Device to Screen
		Help(" ",1,"ATUAL_SINT",,StrZero(nMes,2,0),3,5)
	EndIf
	lRet:=.t.
EndIf

DbSelectArea(cAlias)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³ Periodo  ³ Autor ³ Wagner Xavier       ³ Data ³ 25.02.94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Devolve o periodo contabil de acordo com exercicio atual   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Periodo(ExpD1,ExpN1)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Data,Moeda                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Sigacon Advanced.                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Periodo( dData, nMoeda)
Local nMes, cMes, cAno
Local cAlias := Alias( )
Local nCont
Private cPer

dData   := Iif(dData == Nil, dDataBase, dData)
nMoeda  := Iif(nMoeda == Nil, 1, nMoeda)

nMes := Month(dData)
If !(Str(nMoeda,1) $ GetMv("MV_MOEDMAT"))
	If Day(dData) > GetMv("MV_MESREF")
		nMes++
	EndIf
Else
	For nCont := 1 To 17
		If dData >= aTabela22[nCont][1] .And. dData <= aTabela22[nCont][2]
			nMes := nCont
			Exit
		EndIf
	Next nCont
	If nMes > 12
		nMes := nMes - 12
	EndIf
EndIf

cAno := Str(Year(dData),4)

If nMes > 12
	nMes := 1
	cAno := Str(Val(cAno)+1,4)
EndIf
cMes := Strzero(nMes,2)
DbSelectArea(cAlias)

Return cAno+cMes

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³DataInicio³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 31/08/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna array com as datas minimas para cada moeda.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DataInicio()                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ CONA100                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function DataInicio( )
Local aData := Array(5)
Local nMesIni:= 0
Local nMesFim:= 0
Local nMoeda := 0
Local cAno
Local dData
Local cDiaMes

For nMoeda:=1 To 5
	// Calculo da 1a data da contabilidade
	If Str(nMoeda,1) $ SuperGetMv("MV_MOEDMAT")
		// Se for Moeda Matriz, a data inicio e o 1o. elemento da tabela 22
		cDiaMes := SubStr(AllTrim(Tabela("22","01")),1,5)
		dData   := Ctod(cDiaMes + "/" + SuperGetMv("MV_EXERC"+Str(nMoeda,1)), "ddmmyy") 
	Else
		// Mes de encerramento da contabilidade
		nMesFim := SuperGetMv("MV_FECH"+Str(nMoeda,1))
		If nMesFim != 12
			cAno  := SuperGetMv("MV_EXERC"+Str(nMoeda,1))
		Else
			cAno  := Str(Val(SuperGetMv("MV_EXERC"+Str(nMoeda,1)))-1,4)
		EndIf
		// Mes de Inicio da contabilidade
		nMesIni := Iif(nMesFim+1 == 13, 1, nMesFim+1)
		If SuperGetMv("MV_MESREF") != 31               // Moeda # da Matriz 
			cDia := StrZero(SuperGetMv("MV_MESREF"),2) 
			dData:= 1 + Ctod(cDia +"/"+StrZero(nMesFim,2)+"/"+cAno, "ddmmyy")
		Else
			dData := 1+(LastDay(Ctod("01"+"/"+StrZero(nMesFim,2)+"/"+cAno, "ddmmyy")))
		EndIf
	EndIf
	aData[ nMoeda ] := dData
Next nMoeda
Return aData

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³DataFinal ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 31/08/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna array com as datas maximas para cada moeda.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DataFinal()                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ CONA100                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function DataFinal( )

Local aData := DataInicio( )
Local aMeses:= Array( 5 )
Local aAnos := Array( 5 )
Local nMoeda,cDiaMes
Local dData

For nMoeda:=1 To 5

	aMeses[nMoeda] := Month(aData[nMoeda])+17
	aAnos [nMoeda] := Year(aData[nMoeda])

	While aMeses[nMoeda] > 12
		aAnos[nMoeda]++
		aMeses[nMoeda] -= 12
	End

	If Str(nMoeda,1) $ SuperGetMv("MV_MOEDMAT") 
		// Se a moeda e da Matriz a data final e o ultimo elemento da tabela 22
		cDiaMes := SubStr(Tabela("22","17"),7,5)
		If Substr(cDiaMes,1,2) == "31"
			dData := LastDay(Ctod("01/" + Substr(cDiaMes,4,2) + "/" +  Str(aAnos[nMoeda],4), "ddmmyy"))
		Else
			dData   := Ctod(cDiaMes + "/" + Str(aAnos[nMoeda],4), "ddmmyy")
		EndIf
	Else
		dData := Ctod(StrZero(Day(aData[nMoeda]),2)+"/"+StrZero(aMeses[nMoeda],2)+"/"+StrZero(aAnos[nMoeda],4), "ddmmyy")
		dData --
		If SuperGetMv("MV_MESREF") != 31 
			cDia  := StrZero(SuperGetMv("MV_MESREF"),2)
			dData := Ctod(cDia +"/"+StrZero(Month(dData),2)+"/"+StrZero(Year(dData),4), "ddmmyy")
		EndIf
	EndIf
	aData[nMoeda] := dData
Next nMoeda
Return (aData)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³DataMoeda ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 31/08/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³VerIfica se o lancamento e' valido na data especIficada.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DataMoeda(ExpN1,ExpC1,ExpD1)                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ SIGACON                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function DataMoeda( nMoeda, cPeriodo, dDataLct )
Local nCont
Local lRet := .F.
Local nAno, nMes, dData, nPeriodo

dDataLct := Iif(dDataLct == Nil,dDataBase,dDataLct)

If Empty( nMoeda )
	Return .f.
EndIf
If dDataLct < aDataIni[nMoeda] .or. dDataLct > aDataFim[nMoeda]
	cPeriodo:=" "
	lRet := .f.
Else
	// Calculo do periodo p/ moedas da matriz
	If Str(nMoeda,1) $ GetMv("MV_MOEDMAT")
		For nCont := 1 To 17
			If dDataLct >= aTabela22[nCont][1] .And. dDataLct <= aTabela22[nCont][2]
				cPeriodo := StrZero(nCont,2)
				lRet    := .T.
				Exit
			EndIf
		Next nCont
		// Nao achou data na tabela. Tabela esta preenchida incorretamente
		If nCont == 18 .And. !lRet
			cPeriodo := " "
			Help(" ",1,"TABELA22")
		End
	Else
		nMes    := Month( dDataLct )
		nAno    := Year( dDataLct )
		dData   := aDataIni[nMoeda] - 1
		nPeriodo := nMes - Month( dData )
		If GetMv("MV_MESREF") < Day(dDataLct)
			nPeriodo++
		End
		While nAno > Year(dData)
			nPeriodo += 12
			nAno --
		End
		cPeriodo := StrZero(nPeriodo,2)
		lRet := .t.
	End
End
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³DataTabela³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 21/07/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna Array com todas as datas da Tabela 22. Analisa  se  ³±±
±±³      ³a tabela foi preenchida corretamente.               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³DataTabela(ExpN1)                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ SIGACON                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function DataTabela(lConf)
Local nCont, cRet
Local cMesIni1, cMesFim1, cMesIni2, cMesFim2
Local cAnoIni1, cAnoFim1, cAnoFim2
Local aTab[17][2]
Local nMoeda

lConf := Iif(lConf == Nil, .F., lConf)
If lConf    // Indica que a chamada e' do Configurador
	aDataIni := DataInicio()
End

// Como a tabela 22 e' a mesma para as moedas da matriz, considera apenas a
// primeira moeda da matriz

nMoeda := Val(SubStr(SuperGetMv("MV_MOEDMAT"),1,1)) 

For nCont := 1 To 17
	cRet    := Tabela("22",StrZero(nCont,2))
	cMesIni1 := SubStr(cRet,1,5)
	cMesFim1 := SubStr(cRet,7,5)
	If nCont > 1
		// O ano inicial da linha seguinte deve iniciar com o mesmo ano final
		// da linha anterior
		cAnoIni1 := cAnoFim2
		If SubStr(cMesFim2,4,2) > SubStr(cMesIni1,4,2)
			cAnoIni1 := Str(Val(cAnoFim2)+1,4)
			cAnoFim1 := cAnoIni1
		ElseIf SubStr(cMesIni1,4,2) > SubStr(cMesFim1,4,2)
			cAnoFim1 := Str(Val(cAnoIni1)+1,4)
		End
		If cAnoFim1 != Nil
			aTab[nCont][1] := Ctod(cMesIni1 + "/" + cAnoIni1, "ddmmyy")
			aTab[nCont][2] := Ctod(cMesFim1 + "/" + cAnoFim1, "ddmmyy")

			// VerIfica se o dia informado e' 31 e que se considera como default
			// o ultimo do mes.

			If SubStr(cMesIni1,1,2) == "31"
				aTab[nCont][1] := LastDay(Ctod("01/" + SubStr(cMesIni1,4,2) + "/" +;
					cAnoIni1, "ddmmyy"))
			End
			If SubStr(cMesFim1,1,2) == "31"
				aTab[nCont][2] := LastDay(Ctod("01/" + SubStr(cMesFim1,4,2) + "/" +;
					cAnoFim1, "ddmmyy"))
			End
		EndIf
	Else
		aTab[1][1]  := aDataIni[nMoeda]
		cAnoIni1  := Str(Year(aDataIni[nMoeda]),4)
		If SubStr(cMesIni1,4,2) > SubStr(cMesFim1,4,2)
			cAnoFim1 := Str(Val(cAnoIni1)+1,4)
		ElseIf SubStr(cMesIni1,4,2) == SubStr(cMesFim1,4,2)
			cAnoFim1 := cAnoIni1
		Else
			cAnoFim1 := cAnoIni1
		End
		If cAnoFim1 != Nil
			If SubStr(cMesFim1,1,2) == "31"
				aTab[1][2]:= LastDay(Ctod("01/" + SubStr(cMesFim1,4,2) + "/" + cAnoFim1, "ddmmyy"))
			Else
				aTab[1][2]:= Ctod(cMesFim1 + "/" + cAnoFim1, "ddmmyy")
			End
		End
	EndIf
	// Se a tabela 22 foi preenchida incorretamente, abandona o programa.
	If Empty(aTab[nCont][1]) .Or. Empty(aTab[nCont][2])
		//------------------------------------------------------------------
		// Retirado o tratamento para verificar o preenchimento da tabela 22,
		// pois a mesma não é mais utilizada na versão 11.
		//------------------------------------------------------------------
/*		Help (" ",1,"TABELA22" )
		If !lConf     // Se nao for chamada do Configurador, sai do programa
			Final(STR0032) //"Tabela 22 incorreta!"
		Else
			// Retorna ao Configurador que a tabela foi preenchida errada!
			aTab := {}
			Return aTab
		End*/
		aTab := {}
		Return aTab
	End

	// Armazena os valores que serao anteriores
	cMesIni2 := cMesIni1
	cMesFim2 := cMesFim1
	cAnoFim2 := cAnoFim1

Next
Return aTab

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³CalcData  ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 31/08/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula data inicial e final para um determinado periodo    ³±±
±±³      ³a partir de uma data qualquer.                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CalcData(ExpD1,ExpN2)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ CONA100                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcData(dData,nMoeda)

Local cDia,nMes,nAno,dDataIni,dDataFim,aDatas:={},nCont

dDataIni := Ctod("  /  /  ")
dDataFim := Ctod("  /  /  ")

If Str(nMoeda,1) $ GetMv("MV_MOEDMAT")
	For nCont := 1 To 17
		If dData >= aTabela22[nCont][1] .And. dData <= aTabela22[nCont][2]
			dDataIni := aTabela22[nCont][1]
			dDataFim := aTabela22[nCont][2]
		End
	Next nCont
ElseIf GetMv("MV_MESREF") != 31
	nDia  := GetMv("MV_MESREF")
	cDia  := StrZero(nDia,2)
	If Day(dData) <= nDia
		nMes  := Month(dData)-1
		nAno  := Year(dData)
		If nMes == 0
			nMes := 12
			nAno--
		End
		dDataIni := 1 + Ctod( cDia+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")
		nMes      := Month(dData)
		nAno      := Year(dData)
		dDataFim  := Ctod( cDia+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")
	Else
		nMes    := Month(dData)
		nAno    := Year(dData)
		dDataIni := 1 + Ctod( cDia+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")

		nMes    := Month(dData)+1
		nAno    := Year(dData)
		If nMes > 12
			nMes := 1
			nAno := Year(dData)+1
		End
		dDataFim := Ctod( cDia+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")
		If nMes == 2 .And. Val(cDia) >= 29 .And. Empty(dDataFim)
			dDataFim := LastDay(Ctod("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy"))
		EndIf
	End
Else
	nMes    := Month(dData)
	nAno    := Year(dData)
	dDataIni := Ctod("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")
	dDataFim := LastDay(Ctod("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy"))
End
AADD(aDatas,dDataIni)
AADD(aDatas,dDataFim)
Return aDatas

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³Periodata ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 31/08/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna a data inicial e final de um periodo de acordo com  ³±±
±±³      ³o periodo informado.                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CalcData(ExpN1,ExpN2)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ CONA100                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Periodata(nPer,nMoeda)

Local cDia,nMes,nAno,dDataIni,dDataFim,aDatas:={},nCont

dDataIni := Ctod("  /  /  ")
dDataFim := Ctod("  /  /  ")
If nPer != Nil .And. nPer != 0 .And. nPer <= 17
	If Str(nMoeda,1) $ GetMv("MV_MOEDMAT")
		dDataIni := aTabela22[nPer][1]
		dDataFim := aTabela22[nPer][2]
	ElseIf GetMv("MV_MESREF") != 31
		cDia    := StrZero(GetMv("MV_MESREF"),2)
		nAno    := Val(GetMv("MV_EXERC"+Str(nMoeda,1)))
		nMes    := GetMv("MV_FECH"+Str(nMoeda,1))
		If nMes != 12
			For nCont := 1 to nPer
				nMes++
				If nMes > 12
					nMes := 1
					nAno++
				End
			Next
		Else
			If nPer > 12
				nAno := Val(GetMv("MV_EXERC"+Str(nMoeda,1)))+1
			EndIf
		End
		nMes    := GetMv("MV_FECH"+Str(nMoeda,1)) - 12 + nPer
		If nMes > 12
			nMes := nMes - 12
		ElseIf nMes < 1
			nMes := 12 + nMes
		End
		dDataFim := Ctod( cDia+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")
		nMes--
		If nMes = 0
			nMes := 12
			nAno--
		End
		dDataIni := 1 + Ctod( cDia+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")
	Else
		nAno    := Val(GetMv("MV_EXERC"+Str(nMoeda,1)))
		nMes    := GetMv("MV_FECH"+Str(nMoeda,1))
		If nMes != 12
			For nCont := 1 to nPer
				nMes++
				If nMes > 12
					nMes := 1
					nAno++
				End
			Next nCont
		Else
			If nPer > 12
				nAno := Val(GetMv("MV_EXERC"+Str(nMoeda,1)))+1
			EndIf
		End
		nMes    := GetMv("MV_FECH"+Str(nMoeda,1)) - 12 + nPer
		If nMes > 12
			nMes := nMes - 12
		ElseIf nMes < 1
			nMes := 12 + nMes
		End
		dDataIni := Ctod("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")
		dDataFim := LastDay(Ctod("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy"))
	End
End
AADD(aDatas,dDataIni)
AADD(aDatas,dDataFim)
Return aDatas

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³CalcAnt ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 31/08/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula data inicial e final para o periodo anterior      ³±±
±±³      ³`a data informada. OBS: a data a ser informada devera ser   ³±±
±±³      ³obrigatoriamente a do inicio do periodo seguinte.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CalcAnt(ExpD1,ExpN2)                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ CONA100                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcAnt(dData,nMoeda)

Local cDia,nMes,nAno,dDataIni,dDataFim,aDatas:={},nCont

dDataIni := Ctod("  /  /  ")
dDataFim := Ctod("  /  /  ")

If Str(nMoeda,1) $ GetMv("MV_MOEDMAT")
	For nCont := 1 To 17
		If dData >= aTabela22[nCont][1] .And. dData <= aTabela22[nCont][2]
			Exit
		End
	Next nCont
	nCont--
	If nCont > 0 .And. nCont != 17
		dDataIni := aTabela22[nCont][1]
		dDataFim := aTabela22[nCont][2]
	End
ElseIf GetMv("MV_MESREF") != 31
	cDia    := StrZero(GetMv("MV_MESREF"),2)
	nMes    := Month(dData)-1
	nAno    := Year(dData)
	If nMes = 0
		nMes := 12
		nAno--
	End
	dDataIni := 1 + Ctod( cDia+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")
	dDataFim := dData - 1
Else
	nMes    := Month(dData) - 1
	nAno    := Year(dData)
	If nMes = 0
		nMes := 12
		nAno--
	End
	dDataIni := Ctod("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4), "ddmmyy")
	dDataFim := dData - 1
End
AADD(aDatas,dDataIni)
AADD(aDatas,dDataFim)
Return aDatas

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CalcLote  ³ Autor ³ Waldemiro L. Lustosa  ³ Data ³ 24/02/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Calcula a Necessidade para Geracao de Ordens de Producao ou ³±±
±±³          ³Solicitacoes de Compra de acordo com o Lote Economico.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpA1 := CalcLote(ExpC1,ExpN1,ExpC2)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ ExpA1 = Array Simples com Quantidades calculadas           ³±±
±±³          ³ ExpC1 = Produto a ser pesquisado                           ³±±
±±³          ³ ExpN1 = Necessidade de Producao                            ³±±
±±³          ³ ExpC2 = "C" - Comprado ou "F" - Fabricado                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcLote(cProduto,nNeces,cModo)
Local lUsaQtEm:= NIL
Local lMExcCall:=NIL
Local aQtd := {}
Local aArea := GetArea()
Local nToler,nQtdUlt, nLoteMin, cQuebra, aQtdNQ := {}, nQuant := 0
Local nx
Local lMVForcaLM := SuperGetMv("MV_FORCALM",.F.,.F.)
Local lMVSubsLE  := SuperGetMv("MV_SUBSLE",.F.,.T.)
Local aRetPE := {}

Private nB1_LM:=0,nB1_QE:=0,nB1_LE:=0,nB1_TOLER:=0, cMV_Quebra, nQtdNeces := 0

nNeces     :=IIF( nNeces > 0 , nNeces , 0 )
lUsaQtEm   :=IIF(lUsaQtEm  == NIL,GetMV("MV_USAQTEM") == "S",lUsaQtEm)
lMExcCall  :=IIF(lMExcCall == NIL,ExistBlock("MTCALCL"),lMExcCall)
cQuebra    :=Iif( cModo == "F" , GetMv("MV_QUEBROP") , GetMv("MV_QUEBRSC") )

DbSelectArea("SB1")
DbSetOrder(1)
If dbSeek(xFilial()+cProduto) .And. (QtdComp(nNeces) > QtdComp(0))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega variaveis com valor dos campos para poderem ser utiliza³
	//³ das no ponto de entrada MTCALCL                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nB1_LM:=RetFldProd(SB1->B1_COD,"B1_LM")
	nB1_QE:=RetFldProd(SB1->B1_COD,"B1_QE")
	nB1_LE:=RetFldProd(SB1->B1_COD,"B1_LE")
	nB1_TOLER:=RetFldProd(SB1->B1_COD,"B1_TOLER")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Executa execblock                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lMExcCall
		ExecBlock("MTCALCL",.F.,.F., {cQuebra, cModo, nNeces})

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica valor das variaveis apos ponto de entrada             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ValType(nB1_LM) # "N"
			nB1_LM:=RetFldProd(SB1->B1_COD,"B1_LM")
		EndIf
		If ValType(nB1_QE) # "N"
			nB1_QE:=RetFldProd(SB1->B1_COD,"B1_QE")
		EndIf
		If ValType(nB1_LE) # "N"
			nB1_LE:=RetFldProd(SB1->B1_COD,"B1_LE")
		EndIf
		If ValType(nB1_TOLER) # "N"
			nB1_TOLER:=RetFldProd(SB1->B1_COD,"B1_TOLER")
		EndIf
		If ValType(cMV_Quebra) == "C" .And. cMV_Quebra $ "SN"
			cQuebra := cMV_Quebra
		Endif
		If ValType(nQtdNeces) == "N"
			nNeces := nQtdNeces
		EndIf
	EndIf

	nLoteMin := Iif(cModo == "F", nB1_LM ,nB1_QE )

	If nB1_LE == 0 .And. nLoteMin > 0 .And. lMVSubsLE
		nB1_LE := nLoteMin
	Endif

	If nB1_LE > 0
		nToler := ( nB1_LE * nB1_TOLER ) / 100
		// Tenta Lote Minimo e apos isso Lote Economico
		If  nNeces <= nLoteMin .And. lUsaQtEm
			Aadd(aQtd,nLoteMin)
			nNeces := 0
		ElseIf nNeces < nB1_LE
			If lMVForcaLM .And. nLoteMin > 0
				For nx:=1 to Ceiling((IIF((nB1_LE/nLoteMin)>=1,(nB1_LE/nLoteMin),1)))
					aAdd(aQtd,nLoteMin)
				Next nx
			Else
				Aadd(aQtd,nB1_LE)
			EndIf
			nNeces := 0
		EndIf
		While nNeces > 0
			If nNeces < IIf(lMVForcaLM,IIf(cModo == "F", nB1_LM ,nB1_QE ),nB1_LE) - nToler
				If nLoteMin > 0
					If nNeces <= nLoteMin
						Aadd(aQtd, nLoteMin)
					Else
						If nNeces > ( Round( nNeces / nLoteMin ,0) * nLoteMin )
							nQtdUlt := ( Round( nNeces / nLoteMin ,0) +1 ) * nLoteMin
						Else
							nQtdUlt := Round( nNeces / nLoteMin ,0) * nLoteMin
						EndIf
						Aadd(aQtd,nQtdUlt)
					Endif
				Else
					Aadd(aQtd,nNeces)
				EndIf
			Else
				// Prote‡„o contra usu rios que fa‡am bobagem, caso a necessidade for maior que
				// 4096 vezes o Lote Econ“mico, antes de estourar este Array, jogo o restante da
				// necessidade no £ltimo elemento.
				If Len(aQtd) > 5000
					//Incluído a verificação do lote minimo, para tratar se o restante do saldo é ou não multiplo do lote mínimo.
					// Caso não seja, a lógica abaixo irá transformá-lo em multiplo do lote mínimo, conforme a regra do lote mínimo.
					If nLoteMin > 0
						If nNeces <= nLoteMin
							Aadd(aQtd, nLoteMin)
						Else
							If nNeces > ( Round( nNeces / nLoteMin ,0) * nLoteMin )
								nQtdUlt := ( Round( nNeces / nLoteMin ,0) +1 ) * nLoteMin
							Else
								nQtdUlt := Round( nNeces / nLoteMin ,0) * nLoteMin
							EndIf
							Aadd(aQtd,nQtdUlt)
						Endif
					Else
						Aadd(aQtd,nNeces)
					EndIf
				Else
					If lMVForcaLM
						If cModo == "F"
							Aadd(aQtd,IIF(nB1_LM == 0,nNeces,nB1_LM))
						Else
							Aadd(aQtd,IIF(nB1_QE == 0,nNeces,nB1_QE))
						EndIf
					Else
						Aadd(aQtd,IIF(nB1_LE == 0,nNeces,nB1_LE))
					EndIf
				EndIf
				If nNeces <= IIf(lMVForcaLM,IIf(cModo == "F", nB1_LM ,nB1_QE ),nB1_LE) + nToler
					nNeces := 0
				EndIf
			EndIf

			nNeces -= aQtd[Len(aQtd)]
		End
	Else
		Aadd(aQtd,Max(nLoteMin,nNeces))
	EndIf
Else
	Aadd(aQtd,nNeces)
EndIf

If cQuebra == "N"
	For nX := 1 to Len(aQtd)
		nQuant += aQtd[nX]
	Next
	Aadd(aQtdNQ,nQuant)
Endif

RestArea(aArea)

If ExistBlock("CALCLELM")
	aRetPE := ExecBlock("CALCLELM",.F.,.F.,{cProduto,nNeces,If(cQuebra == "N",aQtdNQ ,aQtd)})
	If ValType(aRetPE) == "A"
		If cQuebra == "N"
			aQtdNQ := aClone(aRetPE)
		Else
			aQtd := aClone(aRetPE)
		EndIf
	EndIf
EndIf

Return Iif( cQuebra == "N", aQtdNQ , aQtd )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³MScan   ³ Autor ³ Gilson do NAscimneto  ³ Data ³05/04/94  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Procura no aARRAY, a posicao correta para os tres campos   ³±±
±±³      ³ informados                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ MATA930,MATA100 e MATA460                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MScan(aArray,cCampo1,cCampo2,nPos1,nPos2,cCampo3) // COCACOLA
Local i,nRet:=0

nPos1:=Iif(nPos1==NIL,1,nPos1)
nPos2:=Iif(nPos2==NIL,2,nPos2)

For i:= 1 to Len(aArray)
	If aArray[i,nPos1]==cCampo1 .and. aArray[i,nPos2]==cCampo2 .and. aArray[i,20]==cCampo3 // COCACOLA
		nRet := i
		Exit
	EndIf
Next i
Return(nRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ LibLock()³ Autor ³ Gilson do NAscimneto  ³ Data ³05/04/94  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Liberar atraves da MsUnLock() os registros marcados pela   ³±±
±±³      ³ SoftLock()                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LibLock(aArray)
Local nX
For nX :=1 to Len(aArray)
	DbSelectArea(aArray[nX][1])
	DbGoTo(aArray[nX][2])
	MsUnLock()
Next nX
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ ExisteSx6³ Autor ³ Wagner Xavier       ³ Data ³ 22/05/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ VerIfica se um determinado parametro existe no SX6.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpX1 := GetMV(ExpC1)                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpX1 = Conteudo da variavel devolvido pela funcao       ³±±
±±³      ³ ExpC1 = Nome da variavel a ser pesquisada no SX6       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function ExisteSx6( cVar )
Local cAlias,lRet := .T.
Local nSizeFil := 2
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Armazena a area anterior                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cAlias := ALIAS( )
DbSelectArea( "SX6" )
If !( DbSeek( Upper( cFilAnt + SubStr(cVar,1,10)) ) )
	//-- Atualiza o conteúdo da filial
	If FindFunction("FWSizeFilial")
		nSizeFil := FWSizeFilial()
	EndIf
	If !(DbSeek( Upper(Space(nSizeFil)+SubStr(cVar,1,10))))
		lRet := .F.
	End
End
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Volta para area anterior                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( cAlias )
Return lRet

/*/{Protheus.doc} EanDigito
Cálculo do digito de controle para c¢digo EAN
@author Wagner Xavier
@since 28/06/95
@version 1.0
@return Caracter, digito de controle que foi calculado
@param cCodigo, characters, Codigo EAN a ser calculado
@param lB1_CODBAR, logical, Uso no campo B1_CODBAR da tabela SB1
@type function
/*/
Function EanDigito( cCodigo, lB1_CODBAR )
Local j			:= 0
Local nMultiplicador
Local nSoma 	:= 0
Local nResultado:= 0
Local nDigito	:= 0
Local nTam		:= 0
Local cRet		:= ""
Local lEanCalc	:= .T.

DEFAULT lB1_CODBAR := .T.

// Se estou calculando para o campo B1_CODBAR da tabela SB1
If lB1_CODBAR
	// Devo verificar se deve ou não ser feito o calculo do digito de controle
	lEanCalc := SuperGetMv("MV_EANCALC",,.T.) //Parâmetro que define se o último digito será ou não calculado
EndIf

If lEanCalc
	cCodigo := AllTrim( cCodigo )
	nTam := len(cCodigo)
	//-----------------------------------------------------------------//
	//Alterado função para utilizar modulo 10 de Calculo do EAN			//
	//-----------------------------------------------------------------//

	For j:= 1 To nTam    // Somatoria do conteudo do campo
		nMultiplicador := Iif( ( j % 2) == 0 , 1, 3 ) // varia entre 3 e 1
		nSoma += Int(Val(SubStr(cCodigo,(nTam+1)-j,1))) * nMultiplicador
	Next j

	nResultado := Int(nSoma / 10 ) + Iif(( nSoma % 10 ) > 0, 1 , 0 )  // Prox Multiplo 10
	nDigito   := nResultado * 10 - nSoma
	cRet := Str( nDigito , 1 )
EndIf

Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ AvalImp  ³ Autor ³ Luiz Claudio Barbosa  ³ Data ³ 02.07.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Configura a impressora atraves dos parametros              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ @ pRow(),pCol() Say AvalImp(nLimt,lCompct)                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nLimt   := Numero de Colunas Impressas                     ³±±
±±³          ³ lCompct := .T. Compactado ,//, .F. Descompactado           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AvalImp(nLimt)
Local cDriver:="SPACE(1)", aDriver := ReadDriver()
lCompct := If(aReturn[4] == 1, .T., .F.)

If aReturn[5] != 2			//Somente se nao for via Windows
	If nLimt == 80
		If lCompct
			cDriver := aDriver[1]
		Else
			cDriver := aDriver[2]
		End
	ElseIf nLimt == 132
		If lCompct
			cDriver := aDriver[3]
		Else
			cDriver := aDriver[4]
		End
	ElseIf nLimt == 220
		If lCompct
			cDriver := aDriver[5]
		Else
			cDriver := aDriver[6]
		End
	End
Endif

Return(&cDriver)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³TamSX3    ³ Autor ³ Rosane L. Chene       ³ Data ³ 21.07.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³VerIfica tamanho do campo no SX3                    		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCampo (Nome do Campo a ser pesquisado)              	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Retorna o Array com o tamanho campo e nr.decimais          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function TamSX3( cCampo )

Local nRecSX3 
Local aRetorno := {}
Local nTamanho := 0

Default cCampo := ''

cCampo := Upper(cCampo) 

nRecSX3 := SX3->(RecNo())

if __findTamSx3Cache
	aRetorno := _EngTamSX3(cCampo)
else 
	nTamanho := GetSx3Cache(cCampo,"X3_TAMANHO")
	If nTamanho<>Nil
		aRetorno := {nTamanho,GetSx3Cache(cCampo,"X3_DECIMAL"),GetSx3Cache(cCampo,"X3_TIPO")}
	EndIf
endif

SX3->(dbGoto(nRecSX3))

Return(aRetorno)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  	 ³TamSX1    ³ Autor ³ Claudio Donizete Souza³ Data ³ 23.10.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verifica tamanho do parametro no SX1                    	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cGrupo, cParam (Nome do Grupo e e Param. a ser pesquisado) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Retorna o Array com o tamanho Param e nr.decimais          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TamSX1(cGrupo,cParam)
Local aTam  := {}
Local nOrdSx1 := SX1->(Indexord())
Local nRegSx1 := SX1->(Recno())

SX1->(DbSetOrder(1))
If Sx1->(DbSeek(Pad(cGrupo,Len(SX1->X1_GRUPO))+Pad(cParam,Len(SX1->X1_ORDEM))))
	aTam := {SX1->X1_TAMANHO,SX1->X1_DECIMAL}
EndIf

Sx1->(DbSetOrder(nOrdSx1))
Sx1->(DbGoTo(nRegSx1))

Return aTam
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³fReadLn   ³ Autor ³ Claudio D. de Souza   ³ Data ³ 24/10/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta funcao tenta ler uma linha a partir do arquivo especi- ³±±
±±³          ³ficado pelo fHandle. Sera assumido que a linha termina com  ³±±
±±³          ³um CR / LF.			                                         ³±±
±±³          ³O retorno da linha sera o parametro cbuffer que precisa ser ³±±
±±³          ³passado por referencia. Esta versao ‚ bufferizada para      ³±±
±±³          ³melhor performance                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fReadLn( nHandle, @cLinha, 1024 )	-> .T. Se a linha foi lida³±±
±±³          ³                                     .F. Fim do arquivo	  ³±±
±±³          ³fHandle  - Handle retornado por FOpen() ou fCreate()        ³±±
±±³          ³cBuffer  - Onde a linha sera retornada (por referencia.)    ³±±
±±³          ³nMaxLine - Tamanho maximo da linha                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³Generica																	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION FReadLn(fHandle, cBuffer, nMaxLine,lCrLf )
LOCAL cLine, nEol, nNumRead, nSavePos

cLine   := Space(nMaxLine)
cBuffer := ""

DEFAULT lCrLf := .T.

// Salva posi‡ao corrente do arquivo para reposicionar posteriormente
nSavePos := fSeek(fHandle,0,FS_RELATIVE)
nNumRead := FRead(fHandle, @cLine, nMaxLine)

//Procura a combinacao CR+LF na linha lida
//Caso nao possua CR+LF, verifica se o mesmo possui apenas o LF no final da linha (padrao Machintosh)
IF (nEol := At(CHR(13)+CHR(10), SubStr(cLine, 1, nNumRead))) == 0

	//Procura o LF na linha lida
	If (nEol := At(CHR(10), SubStr(cLine, 1, nNumRead))) != 0
		cBuffer := SubStr(cLine, 1, nEol)     // Copia ate o EOL
		FSeek(fHandle, nSavePos + nEol , FS_SET)
	Else
		cBuffer := cLine                     // Fim da linha lida ou EOF
	Endif

	lCrLf := .F.
ELSE
	cBuffer := SubStr(cLine, 1, nEol - 1)  // Copia ate o EOL

	// Posiciona na proxima linha (skip) ...
	FSeek(fHandle, nSavePos + nEol + 1, FS_SET)
	lCrLf := .T.
ENDIF

RETURN nNumRead != 0        // Se a ultima leitura nao teve sucesso ou eof
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ MSSavEnv ³ Autor ³ Juan Jose Pereira   ³ Data ³ 25.07.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Salva/Restaura Set's do Ambiente                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ aSets:=MSSavEnv(aSets)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aSavEnv:=Array que devera ser pilha dos Set's              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MSSavEnv(aNewSets)

Local aSets:={}

If aNewSets == nil
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria Pilha de Sets    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	AADD(aSets,Alias())
	AADD(aSets,IndexOrd())
	AADD(aSets,Recno())
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restaura Pilha de Sets  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	DbSelectArea(aNewSets[1])
	DbSetOrder(aNewSets[2])
	DbGoTo(aNewSets[3])
	AADD(aSets,Alias())
	AADD(aSets,IndexOrd())
	AADD(aSets,Recno())
EndIf

Return aSets

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³CtCalMedia³ Autor ³ Wagner Xavier       ³ Data ³ 03.02.93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula a taxa media das moedas estrangeiras em um determi-³±±
±±³      ³ nado mes.                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtCalMedia(ExpD1)                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Data Inicial                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CtCalMedia(dData)
Local aTotMoeda := {0,0,0,0,0}
Local aDias     := {0,0,0,0,0}
Local aMedias[5]
Local nMoedas
Local aDatas[2]
Local aData1 := {}
Local aData2 := {}
Local aDataMedias[5][2]
Local aSortIni, aSortFim
Local dDataIni, dDataFim, nElem
Local cAlias := Alias()
Local nCont

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ CONNOMED- criado para que nao execute o calculo da media pois³
//³           qdo o cadastro de moedas e muito grande fica lento ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("CONNOMED",.F.,.F.)
	Return {0,0,0,0,0}
EndIf
nMoedas := ContaMoeda()
For nCont:= 1 To nMoedas
	aDatas:= CalcData(dData,nCont)
	Aadd(aData1,aDatas[1])
	Aadd(aData2,aDatas[2])
	aDataMedias[nCont][1]:= aDatas[1]
	aDataMedias[nCont][2]:= aDatas[2]
Next nCont

aSortIni := aClone(aData1)
aSortFim := aClone(aData2)
aSort(aSortIni)
aSort(aSortFim,,,{ |x,y| x > y })

dDataIni := aSortIni[1]
dDataFim := aSortFim[1]

DbSelectArea("SM2")
DbSeek(dDataIni,.T.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calcula dolar M‚dio neste periodo                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
While !Eof() .and. M2_DATA <= dDataFim
	For nCont := 2 To nMoedas
		cCont := Str(nCont,1)
		If M2_MOEDA&cCont != 0
			If M2_DATA >= aData1[nCont] .And. M2_DATA <= aData2[nCont]
				aTotMoeda[nCont] += M2_MOEDA&cCont
				aDias[nCont] := aDias[nCont]+1
			End
		End
	Next nCont
	DbSkip()
End

aMedias[1]:= 0
For nCont := 2 To nMoedas
	aMedias[nCont] := aTotMoeda[nCont]/aDias[nCont]
Next nCont

DbSelectArea(cAlias)
Return aMedias

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ContaMoeda³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 21/07/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Conta quantas moedas estao sEndo usadas pelo sistema     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ContaMoeda()                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ContaMoeda()

Local nCont, nMoedas:=0
Local nMaxMoedas := GetNewPar("MV_MAXMOED",5)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ O default sao 5 moedas em uso. Neste caso posso verificar se ³
//³ se todas estao sendo realmente usadas.                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nMaxMoedas == 5 .Or. nMaxMoedas < 1 .Or. nMaxMoedas > 5
	For nCont := 1 To nMaxMoedas
		If !Empty(GetMv("MV_MOEDA"+Alltrim(Str(nCont))))
			nMoedas++
		Endif
	Next nCont
Else
	nMoedas := nMaxMoedas
EndIf

Return nMoedas

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³ Saldo  ³ Autor ³ Wagner Xavier       ³ Data ³ 16.10.92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula o saldo atual de uma determinada conta at‚ um deter³±±
±±³      ³ minado mes.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Saldo(ExpC1,ExpN1,ExpN2                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Codigo da conta, Mes, Moeda                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Saldo(cConta,nPer,nMoeda,nAno)
Local nSaldo
Local nC, cMoeda , cArea
Local nOrder,nRecno
Local dData
Private cMes
cConta:=Trim ( cConta ) + Space ( 20 - Len ( Trim ( cConta ) ) )

nMoeda := Iif( nMoeda = Nil, 1, nMoeda )
cMoeda := Str( nMoeda, 1 )
cArea  := Iif( nMoeda == 1 , "SI1" , "SI7" )

If Empty(nAno)
	If nPer <= 12
		dData := Ctod("01/"+StrZero(nPer,2)+"/"+StrZero(Year(dDataBase),4), "ddmmyy")
	EndIf
Else
	If nPer <= 12
		dData := Ctod("01/"+Strzero(nPer,2)+"/"+AllTrim(Str(nAno,4)), "ddmmyy")
	EndIf
EndIf

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Verifica qual e'o periodo de acordo com mˆs    ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nPer <= 12
	If ! DataMoeda(nMoeda, @cMes, dData)
		Return 0
	End
	nPer := Val(cMes)
EndIf

DbSelectArea ( cArea )
nOrder:=IndexOrd()
nRecno:=Recno()
DbSetOrder(1)
DbSeek ( cFilial + cConta + Iif(nMoeda==1,"",cMoeda ) )

nSaldo:=Iif(nMoeda==1,I1_SALANT,I7_SALANT)
cMoeda:=Str(nMoeda,1)

For nC=1 TO nPer
	cSuf:=Strzero(nC,2)
	nSaldo:=Iif(nMoeda==1,nSaldo-I1_DEBM&cSuf+I1_CRDM&cSuf,;
		nSaldo-I7_DEBM&cSuf+I7_CRDM&cSuf)
Next nC
DbSetOrder(nOrder)
DbGoTo(nRecno)
Return nSaldo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³SX5NumNota³ Autor ³Eduardo Riera          ³ Data ³27.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica qual a serie de Nota a ser considerada             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Serie escolhida                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: cSerie                                               ³±±
±±³          ³ExpC2: Tipo de Numeracao utilizada                          ³±±
±±³          ³       [1] Numeracao controla pelo SX5                      ³±±
±±³          ³       [2] Numeracao controla pelo SXE/SXF                  ³±±
±±³          ³       [3] Numeracao controla pelo SD9                      ³±±
±±³          ³ExpC3: Filial a ser apresentada na tela                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Sx5NumNota(cSerNF,cTpNrNfs,cFilTela,cTab,cAliTp,cSerieId,dDEmissao)

Local nVezes    := 0
Local nTamNota  := Len(SF2->F2_DOC)
Local lContinua := .T.
Local lLockSX5  := .T.
Local lSx5Nota  := ExistBlock("SX5NOTA")
Local nTimeOut  := GetNewPar("MV_NOTAOUT",20)*1000
Local nOpcA     := 0
Local aSerNF    := {}
Local aSerNFAnt := {}
Local cNumNF    := ""
Local oDlg
Local oQual
Local oTimer
Local oBmp
Local oBold
Local cCadastro := OemToAnsi(STR0015) //"Notas"
Local cFilSx5   := xFilial("SX5")
Local lValRPS   := ExistBlock("MTVALRPS")
Local nSizeFil  := 2
Local cFilEF    := ""
Local lGrpCNPJ  := MaIsNumCgc() // Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local lUsaNewKey:= TamSX3("F2_SERIE")[1] == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cQuery    := ""
Local cQryAlias := ""
Local aFilCGC   := {}
Local cNDocMax	:= ""
Local cDocAnt 	:= ""
Local nX		:= 0
Local aSerieDOC := {}
Local cMaxSD9	:= ""
Local cMaxSF2	:= ""
Local cAliasSX5	:= ""
Local cQuerySX5	:= ""
// Verifica permissao para alterar numero da nota (utilizado apenas para MV_ESTADO = SC)
Local lCanChange:= SuperGetMv("MV_MUDANUM",,.F.)
Local lD9DocExcl:= SD9->(ColumnPos("D9_DOCEXCL")) > 0

DEFAULT cTpNrNfs := "1"
DEFAULT cFilTela := cFilAnt
DEFAULT cTab	 := "01"
DEFAULT cAliTp	 := 'NFF'
DEFAULT cSerieId := cSerNF
DEFAULT dDEmissao:= dDataBase
// Verifica se arquivo criado no meio da versao 710 existe
If cTpNrNfs == "3"
	SX3->(dbSetOrder(1))
	If !(SX3->(dbSeek("SD9")))
		cTpNrNfs := "1"
	EndIf
EndIf
lLockSX5 := IIf(cTpNrNFS == "1",lLockSX5,.F.)

IF __lChgX5Fil == Nil
	__lChgX5FIL := ExistBlock("CHGX5FIL")
Endif

IF __lChgX5FIL
	cFilSx5 := ExecBlock("CHGX5FIL",.f.,.f.)
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Trava o parametro do SX6 por seguranca                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cTpNrNfs <> "3"
	If ( GetMv("MV_NUMITEN",.T.) )

		While ( lContinua .And. !SX6->(MsRLock()) )
			Inkey(1)
			nVezes++
			If ( nVezes > 200 )
				lContinua := .F.
			EndIf
		EndDo
	Else
		lContinua := .F.
	EndIf
EndIf

//-- Atualiza o conteúdo da filial
If FindFunction("FWSizeFilial")
	nSizeFil := FWSizeFilial()
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Defini filial do xe xf												   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PadR(cSerNF,3) == "PLS"
	cFilEF := PadR(xFilial("SE1")+X2PATH("SE1"),45+nSizeFil)
Else
	cFilEF := PadR(xFilial("SF2")+X2PATH("SF2"),45+nSizeFil)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica as series de notas fiscais validas                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lContinua )

	DBSelectArea("SX5")
	DBSetOrder(1)

	If cTpNrNFS == "3"

		cAliasSX5	:= GetNextAlias()

		If lGrpCNPJ
			aFilCGC := MatFilCgc(SM0->M0_CGC,"SF2") // Retorna o Compartilhamento conforme CNPJ
		EndIf

		cQuerySX5 := " SELECT X5_CHAVE SERIE, X5_DESCRI DOC "
		cQuerySX5 += " FROM " + RetSqlName("SX5") + " SX5 "
		cQuerySX5 += " WHERE SX5.X5_TABELA = '" + cTab + "'"
		cQuerySX5 += " AND SX5.X5_FILIAL = '" + cFilSX5 + "'"

		//Ignora as series do SIGALOJA
		cQuerySX5 += " AND SX5.X5_CHAVE NOT IN ( 'CPF', 'CP' )"
		cQuerySX5 += " AND SX5.D_E_L_E_T_ = ' ' "
		cQuerySX5 += " ORDER BY " + SqlOrder( SX5->(IndexKey()) )


		cQuerySX5 := ChangeQuery(cQuerySX5)

		DBUseArea(.T.,"TOPCONN",TcGenQry(,,cQuerySX5),cAliasSX5,.T.,.T.)

		While (cAliasSX5)->(!Eof())

			cMaxSD9		:= ""
			cMaxSF2		:= ""
			cAliasSD9	:= GetNextAlias()
			cQuerySD9	:= " SELECT COALESCE(MAX(SD9.D9_DOC),' ') MAX_DOCSD9"
			cQuerySD9	+= " FROM " + RetSqlName("SD9") +  " SD9 "

			If lGrpCNPJ
				cQuerySD9 += " WHERE SD9.D9_CNPJ  = '" + SM0->M0_CGC + "'"
			Else
				cQuerySD9 += " WHERE SD9.D9_FILIAL = '" + xFilial("SD9") + "'"
			EndIF

			If lUsaNewKey
				cQuerySD9 += " AND SD9.D9_SDOC  = '" + (cAliasSX5)->SERIE + "'"
			Else
				cQuerySD9 += " AND SD9.D9_SERIE = '" + (cAliasSX5)->SERIE + "'"
			EndIf

			If lD9DocExcl
				cQuerySD9 += " AND (SD9.D9_DTUSO <> ' ' OR SD9.D9_DOCEXCL = 'S')"
			Else
				cQuerySD9 += " AND SD9.D9_DTUSO <> ' ' "
			EndIf
			cQuerySD9 += " AND SD9.D_E_L_E_T_ = ' ' "

			cQuerySD9 := ChangeQuery(cQuerySD9)

			DBUseArea(.T.,"TOPCONN",TcGenQry(,,cQuerySD9),cAliasSD9,.T.,.T.)

			cMaxSD9 := (cAliasSD9)->MAX_DOCSD9

			(cAliasSD9)->(DBCloseArea())

			If Empty(cMaxSD9)

				If lGrpCNPJ
					aFiliais := aFilCGC[3]
				Else
					aFiliais := {xFilial("SD9")}
				EndIf

				cMaxSF2  := SF2MaxDoc((cAliasSX5)->SERIE, aFiliais, lUsaNewKey)

			EndIf

			If Empty(cMaxSD9) .And. Empty(cMaxSF2)
				cMaxSF2 := (cAliasSX5)->DOC
			EndIf

			aAdd(aSerieDOC, {(cAliasSX5)->SERIE,cMaxSD9,cMaxSF2})

			(cAliasSX5)->(DBSkip())
		End

		For nX := 1 To Len(aSerieDOC)

			If SX5->( DBSeek(cFilSX5+cTab+aSerieDOC[nX][1]) )
				// Mantem nota com tamanho 6, se alterado pelo usuario. Para retornar ao tamanho 9 e necessario
				// alterar a tabela "01" pelo configurador.
				// O tamanho padrão para a numeração da nota fiscal no Protheus é de 9 caracteres.
				If cPaisloc == "BRA"
					//Caso o F2_DOC seja maior ou igual ao permitido, assume a numeração com o tamanho de 9 caracteres.
					If Len(AllTrim(SX5->X5_DESCRI)) == 9 .And. Len(SF2->F2_DOC) >= 9
						nTamNota := 9
					ElseIf Len(AllTrim(SX5->X5_DESCRI)) < Len(SF2->F2_DOC)
						nTamNota := 6
					Else
						nTamNota  := Len(SF2->F2_DOC)
					EndIf
				Else
					nTamNota  := Len(SF2->F2_DOC)
				EndIf

				If !Empty(aSerieDOC[nX][2]) 		//MAXSD9
					cNDocMax := Soma1( AllTrim( aSerieDOC[nX][2] ), nTamNota )
				ElseIf !Empty(aSerieDOC[nX][3]) 	//MAXSF2
					cNDocMax := Soma1( AllTrim( aSerieDOC[nX][3] ), nTamNota )
				Else
					cNDocMax := StrZero(1,nTamNota)
				EndIf

				//Se tiver permissão para mudar a numeração da nota fiscal, verifica na SD9 se não houve salto na numeração.
				If lCanChange .And. !Empty(aSerieDOC[nX][2])
					cDocAnt := ChkSD9Skip(PadR(SX5->X5_CHAVE,3),cNDocMax,lGrpCNPJ,lUsaNewKey)
					If !Empty(cDocAnt) .And. PadR(cDocAnt,nTamNota) <> cNDocMax
						cNDocMax := PadR(cDocAnt,nTamNota)
					EndIf
				EndIf

				aAdd( aSerNF,{PadR(SX5->X5_CHAVE,3), cNDocMax })

				If ( lSx5Nota )
					If ( ! ExecBlock("SX5NOTA",.F.,.F.,{cFilSX5, SX5->X5_TABELA, SX5->X5_CHAVE, SX5->(X5Descri(,,,,.F.))}) )
						aSize(aSerNF,Len(aSerNF)-1)
					EndIf
				EndIf

			EndIf

		Next nX

	Else

		SX5->( MsSeek(cFilSX5+cTab,.F.) )

		While ( SX5->X5_FILIAL == cFilSX5 .And. ;
				SX5->X5_TABELA == cTab .And. lContinua )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se a S‚rie for CPF, n„o mostra no aChoice, pois ‚ utilizada ³
			//³ internamente para emissao de Cupom Fiscal.             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (SX5->X5_CHAVE <> PADR("CPF",Len(SX5->X5_CHAVE))) .And. (SX5->X5_CHAVE <> PADR("CP",Len(SX5->X5_CHAVE)))
				nVezes := 0
				While ( IIf(lLockSX5,!SX5->(MsRLock()),.F.) .And. lContinua )
					nVezes ++
					If ( nVezes > 20 )
						aSerNF   := {}
						lContinua := .F.
					EndIf
				EndDo
				If lContinua
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Quando a Numeracao eh controlado pelo SXE/SXF                           ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If cTpNrNFS == "2"
						cNumNF := GetSX8Num(cAliTp,,PadR(SX5->X5_CHAVE,3)+cFilEF)
						// Mantem nota com tamanho 6, se alterado pelo usuario. Para retornar ao tamanho 9 e necessario
						// alterar a tabelas SXE/SXF.
						If cPaisloc == "BRA" .And. Len(AllTrim(cNumNF)) < Len(SF2->F2_DOC)
							nTamNota := 6
						Else
							nTamNota  := Len(SF2->F2_DOC)
						EndIf
						RollBackSx8()
						AADD( aSerNF,{PadR(SX5->X5_CHAVE,3),StrZero(Val(cNumNF),nTamNota)})
					Else
						// Mantem nota com tamanho 6, se alterado pelo usuario. Para retornar ao tamanho 9 e necessario
						// alterar a tabela "01" pelo configurador.
						// O tamanho padrão para a numeração da nota fiscal no Protheus é de 9 caracteres.
						If cPaisloc == "BRA"
							//Caso o F2_DOC seja maior ou igual ao permitido, assume a numeração com o tamanho de 9 caracteres.
							If Len(AllTrim(SX5->X5_DESCRI)) == 9 .And. Len(SF2->F2_DOC) >= 9
								nTamNota := 9
							ElseIf Len(AllTrim(SX5->X5_DESCRI)) < Len(SF2->F2_DOC)
								nTamNota := 6
							Else
								nTamNota  := Len(SF2->F2_DOC)
							EndIf
						Else
							nTamNota  := Len(SF2->F2_DOC)
						EndIf

						AADD( aSerNF,{PadR(SX5->X5_CHAVE,3), MaConvNNota( X5Descri(,,,,.F.), nTamNota ) })

					EndIf
					If ( lSx5Nota )
						If ( ! ExecBlock("SX5NOTA",.F.,.F.,{cFilSX5, SX5->X5_TABELA, SX5->X5_CHAVE, SX5->(X5Descri(,,,,.F.))}) )
							aSize(aSerNF,Len(aSerNF)-1)
						EndIf
					EndIf
				EndIf
			EndIf
			dbSelectArea("SX5")
			dbSkip()
		EndDo
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Montagem da janela de exibicao                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( Len(aSerNF) != 0 )

	aSerNFAnt := aClone(aSerNF)
	DEFINE MSDIALOG oDlg TITLE CCADASTRO+" - "+Alltrim(RetTitle("A1_FILIAL"))+" "+cFilTela FROM 0,0 TO 264,378 OF oMainWnd	PIXEL

	DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD

	@  0, -25 BITMAP oBmp RESNAME "PROJETOAP" oF oDlg SIZE 55, 1000 NOBORDER WHEN .F. PIXEL
	@ 14, 30 TO 16 ,400 LABEL '' OF oDlg PIXEL
	@ 03, 40 SAY STR0016 + " / " + CCADASTRO FONT oBold PIXEL

	If FindFunction("A103UnlkPC")
		 oTimer:= TTimer():New(nTimeOut,{|| A103UnlkPC(),oDlg:End() },oDlg)
	Else
		 oTimer:= TTimer():New(nTimeOut,{|| oDlg:End() },oDlg)
	EndIf
	oTimer:Activate()

	@ 025,040 LISTBOX oQual VAR cVarQ ;
		FIELDS HEADER OemToAnsi(STR0016),cCadastro ; //"Serie"
		SIZE 140,080 ;
		ON DBLCLICK (If(SX5Troca(@aSerNF,oQual:nAt,@oTimer,nTimeOut,oQual,cTpNrNfs),(oQual:Refresh(),If(lCanChange,lMudouNum := .T.,)),oDlg:End())) NOSCROLL PIXEL

	oQual:SetArray(aSerNF)
	oQual:bLine := { || {aSerNf[oQual:nAT,1],aSerNf[oQual:nAT,2]}}
	DEFINE SBUTTON FROM 113,119 TYPE 1 ACTION If	(	cTpNrNfs $ "2",;
	IIf( VldSX5Num(aSerNF[oQual:nAt][2],aSerNF[oQual:nAt][1],.T., ;
	IIf( lUsaNewKey , SerieNfId("SF2",4,"F2_SERIE",dDEmissao,A460Especie(aSerNF[oQual:nAt][1]),aSerNF[oQual:nAt][1]) , Nil ) ),;
	(nOpcA:=oQual:nAt,oDlg:End()),nil),(nOpcA:=oQual:nAt,oDlg:End())) ENABLE OF oDlg PIXEL

	If ( cModulo != "TMK" )
		If FindFunction("A103UnlkPC")
			 DEFINE SBUTTON FROM 113,152 TYPE 2 ACTION (A103UnlkPC(),oDlg:End()) ENABLE OF oDlg
		Else
			 DEFINE SBUTTON FROM 113,152 TYPE 2 ACTION (oDlg:End()) ENABLE OF oDlg
		EndIf
	EndIf
	ACTIVATE MSDIALOG oDlg VALID (oTimer:End(),.T.) CENTERED
	If ( lContinua .And. nOpcA != 0 )
		cSerNF  := aSerNF[nOpcA][1]
		cNumNF  := aSerNF[nOpcA][2]
		cSerieId:= IIf( lUsaNewKey , SerieNfId("SF2",4,"F2_SERIE",dDEmissao,A460Especie(cSerNF),cSerNF) , cSerNF )
	Else
		lContinua := .F.
	EndIf
Else
	Help(" ",1,"A460FLOCK")
	lContinua := .F.
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de entrada para validar a serie escolhida com a emissao de RPS³
//³referente a Nota Fiscal Eletronica de ISS de Sao Paulo              ³
//³SC9 posicionado e serie escolhida passada por parametro             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lContinua .And. lValRPS
	lContinua := Execblock("MTVALRPS",.F.,.F.,{cSerNF, cNumNF})
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Trava o registro escolhido                                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lContinua )
	If cTpNrNFS == "1"
		dbSelectArea("SX5")
		dbSetOrder(1)
		If ( MsSeek(cFilSX5+cTab+cSerNF) )
			nVezes := 0
			While ( !SX5->(MsRLock()) )
				nVezes ++
				If ( nVezes > 10 )
					Help(" ",1,"A460FLOCK")
					lContinua := .F.
					Exit
				EndIf
				Sleep(100)
			EndDo
			If ( lContinua )
				SX5->X5_DESCRI  := cNumNF
				SX5->X5_DESCSPA := cNumNF
				SX5->X5_DESCENG := cNumNF
			EndIf
		EndIf
	ElseIf cTpNrNFS == "2"
		__cSX5NUM := cNumNF

		cNumNF := GetSX8Num(cAliTp,,PadR(cSerNF,3)+cFilEF)

		RollBackSX8()
		If __cSX5NUM == cNumNF
			__cSX5NUM := Nil
		Else
			 cNumNF := __cSX5NUM
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Destrava os registro do SX5                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SX5->(MsRUnLock())
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Destrava o parametro                                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( GetMv("MV_NUMITEN",.T.) )
	SX6->(MsRUnLock())
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Compatibilizacao com versoes antigas                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cSerie  := cSerNF
cNumero := cNumNF
// Verifica se o usuario alterou o numero da nota em MV_TPNRNFS == "3" ou "2" (sistema deve respeitar o novo numero)
If nOpcA <> 0 .And. cNumero <> aSerNFAnt[nOpcA][2] .And. (cTpNrNfs == "3" .Or. cTpNrNfs == "2")
	lMudouNum := .T.
EndIf
Return(lContinua)

//-------------------------------------------------------------------
/*/{Protheus.doc} SF2MaxDoc
Retorna a numeração da última nota fiscal utlizada nas filiais

@author Squad CRM/Faturamento
@since 22/11/2019
@version P12

@param cSerie, character, Série da nota fiscal utilizada
@param aFiliais, array, Vetor contendo as filiais para o CNPJ
@param lUsaNewKey, logic, Se utiliza o novo formato de gravação do Id
@return cSF2Max, character, Número da última nota fiscal utilizada nas filiais

/*/
//-------------------------------------------------------------------
Static Function SF2MaxDoc(cSerie, aFiliais, lUsaNewKey)

Local nX		:= 0
Local nFiliais	:= 0
Local nFilLimit	:= 10	//Limite de filiais que será processada na query da SF2
Local nCount	:= 0
Local cSF2Max	:= ""
Local cFilOR	:= ""
Local cQuerySF2	:= ""
Local cWhereSF2 := ""
Local cQueryAux := ""
Local aSF2Max	:= {}
Local cAliasSF2	:= GetNextAlias()

Default cSerie 	   := ""
Default aFiliais   := {}
Default lUsaNewKey := .F.

nFiliais := Len(aFiliais)

//Se limite de filiais for maior que as filiais por CNPG, faz uma query única
If nFilLimit > nFiliais
	nFilLimit := nFiliais
EndIf

cQuerySF2 := " SELECT COALESCE(MAX(SF2.F2_DOC),' ') MAX_DOCSF2 "
cQuerySF2 += " FROM " + RetSqlName("SF2") +  " SF2"
cQuerySF2 += " WHERE "

If lUsaNewKey
	cWhereSF2 += " AND SF2.F2_SDOC  = '" + cSerie + "'"
Else
	cWhereSF2 += " AND SF2.F2_SERIE = '" + cSerie + "'"
EndIf

cWhereSF2 += " AND SF2.D_E_L_E_T_ = ' ' "

For nX := 1 To nFiliais

	nCount += 1
	cFilOR += "SF2.F2_FILIAL = '" + aFiliais[nX] + "'"

	If nCount == nFilLimit

		cQueryAux := cQuerySF2 + " ( " +  cFilOR + " ) " + cWhereSF2

		cQueryAux := ChangeQuery(cQueryAux)

		DBUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryAux),cAliasSF2,.T.,.T.)

		If !Empty( (cAliasSF2)->MAX_DOCSF2 )
			aAdd(aSF2Max,(cAliasSF2)->MAX_DOCSF2)
		EndIf

		(cAliasSF2)->(DBCloseArea())

		cFilOR := ""
		nCount := 0

		If (nFiliais - nX) < nFilLimit
			nFilLimit := (nFiliais - nX)
		EndIf

	Else
		cFilOR += " OR "
	EndIf

Next nX

If !Empty(aSF2Max)
	aSort(aSF2Max)
	cSF2Max := aSF2Max[Len(aSF2Max)]
EndIf

aSize(aSF2Max,0)

Return (cSF2Max)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Sx5Troca  ³ Autor ³Eduardo Riera          ³ Data ³28.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Efetua a Troca do Numero da Nota                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpA1: Series de Nota Fiscal de Saida.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com as series da nota fiscal                   ³±±
±±³          ³ExpN2: Item da Nota de Saida                                ³±±
±±³          ³ExpO3: Objeto Timer                                         ³±±
±±³          ³ExpN4: Time Out.                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Sx5Troca(aSerNf,nItem,oTimer,nTimeOut,oQual,cTpNrNfs)

Local aDim      := {}
Local bValidNum := { || .T. }
Local cCadastro := OemToAnsi(STR0017) //"Numero"
Local cNumero   := aSerNf[nItem][2]
Local cSerie    := aSerNf[nItem][1]
Local lContinua := .T.
Local lValid    := .F.
Local nCol      := 2
Local nRow      := oQual:nAt
Local oOwner    := oQual:oWnd
Local oDlg
Local oTimer2
Local oGet1
Local oRect
Local oBtn
Local lCanChange  := SuperGetMv("MV_MUDANUM",,.F.)

Default cTpNrNfs:=  "1"

// Verifica se arquivo criado no meio da versao 710 existe
If cTpNrNfs == "3"
	SX3->(dbSetOrder(1))
	If !(SX3->(dbSeek("SD9")))
		cTpNrNfs := "1"
	EndIf
EndIf

If cTpNrNfs # "3" .Or. lCanChange
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada para validacao da digitacao do numero                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock( "NFSVLNUM" )
		bValidNum := { |x,y| ExecBlock( "NFSVLNUM", .F., .F., { x,y } ) }
	EndIf

	oTimer:Deactivate()

	oRect := tRect():New(0,0,0,0)    // obtem as coordenadas da celula (lugar onde
	oQual:GetCellRect(nCol,,oRect)    // a janela de edicao deve ficar)
	aDim  := {oRect:nTop,oRect:nLeft,oRect:nBottom,oRect:nRight}

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria uma janela invisivel para permitir a edicao do campo sobre o browse ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DEFINE MSDIALOG oDlg OF oOwner  FROM 0, 0 TO 0, 0 STYLE nOR( WS_VISIBLE, WS_POPUP ) PIXEL

	oTimer2 := TTimer():New(nTimeOut,{|| lContinua := .F.,oDlg:End() },oDlg)
	oTimer2:Activate()

	@ 0,0 MSGET oGet1 VAR cNumero SIZE 0,0 OF oDlg FONT oOwner:oFont PICTURE "@!" PIXEL ;
				HASBUTTON WHEN Substr(cAcesso,50,1) == "S"

	oGet1:Move(-2,-2, (aDim[ 4 ] - aDim[ 2 ]) + 4, aDim[ 3 ] - aDim[ 1 ] + 4 )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Botao criado para receber o foco - nao retirar                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	@ 0,0 BUTTON oBtn PROMPT "X" SIZE 0,0 OF oDlg
	oBtn:bGotFocus := {|| oDlg:nLastKey := VK_RETURN, If( lValid := ( !Empty(cNumero) .And. Eval( bValidNum, cNumero, cSerie ) ), oDlg:End(0), oGet1:SetFocus() ) }

	ACTIVATE MSDIALOG oDlg ON INIT oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restaura a listbox                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oQual:nAt := nRow
	SetFocus(oQual:hWnd)
	oQual:Refresh()

	oTimer:Activate()

	If lValid
		aSerNf[nItem][2] := cNumero
	EndIf
EndIf

Return(lContinua)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NxtSX5Nota³ Rev.  ³Eduardo Riera          ³ Data ³07.12.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica o proximo numero de nota fiscal disponivel         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpC1: Numero da Nota Fiscal                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Serie da Nota fiscal                                 ³±±
±±³          ³ExpC2: Indicador de liberacao do Lock do SX5                ³±±
±±³          ³ExpL3: Tipo de numeracao de nota fiscal de saida            ³±±
±±³          ³       [1] Numeracao controla pelo SX5                      ³±±
±±³          ³       [2] Numeracao controla pelo SXE/SXF                  ³±±
±±³          ³       [3] Numeracao controla pelo SD9                      ³±±
±±³          ³ExpL4: Indicador de alteração do Num da Nf sugerida         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NxtSX5Nota( cIniSER, lLibera , cTpNrNFS , lAvanca, cTab, cAliTp, cSerieId, lVerSE1 )
Local aArea   	:= GetArea()
Local cNewNUM 	:= ""
Local cFilSx5 	:= xFilial("SX5")
Local cMaxNF  	:= SuperGetMv("MV_MAXNF",.F.,'') //-- No. Maximo da Nota Fiscal
Local cNumNota	:= ""
Local lLockX5 	:= .F.
Local lLockX6 	:= .F.
Local nCnt01  	:= 0
Local nTamNota	:= TamSX3("F2_DOC")[1]
Local nRecnoSX6	:= 0
Local nSizeFil  := 2
LOCAL cFilEF	:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa as variaveis DEFAULT                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT cTpNrNFS    := "1"
DEFAULT __lChgX5FIL := ExistBlock("CHGX5FIL")
DEFAULT lLibera     := .T.
DEFAULT __cSX5Num   := ""
DEFAULT lAvanca     := .F.
DEFAULT cTab		:= '01'
DEFAULT cAliTp		:= 'NFF'
DEFAULT cSerieId    := cIniSER
DEFAULT lVerSE1		:= .T.

// Verifica se arquivo criado no meio da versao 710 existe
If cTpNrNfs == "3"
	SX3->(dbSetOrder(1))
	If !(SX3->(dbSeek("SD9")))
		cTpNrNfs := "1"
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o ponto de entrada para tratamento de filial do SX5            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF __lChgX5FIL
	cFilSx5 := ExecBlock("CHGX5FIL",.f.,.f.)
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Cria um semaforo no parametro MV_NUMITEN                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SX6" )
If GETMV("MV_NUMITEN",.T.)
	While !lLockX6 .And. (++nCnt01 < 200)
			lLockX6 := MsRLock()
		If !lLockX6
			Inkey(1)
		EndIf
	EndDo


	If lLockX6
		nRecnoSX6 := SX6->( Recno() )
		If cTpNrNFS == "1"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pesquisa a serie da nota selecionada                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea( "SX5" )
			DbSetOrder(1)
			If MsSeek( cFilSx5 + cTab + cIniSER,.F. )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tenta locar o SX5 sem controle de transacao                            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				While !lLockX5 .And. (++nCnt01 < 200)
					If InTransact()
						lLockX5 := RecLock("SX5")
					Else
						lLockX5 := MsRLock()
					EndIf
					If !lLockX5
						Inkey(1)
					EndIf
				EndDo
				// Gera nota com 6 ou 9 digitos, de acordo com o numero informado pelo usuario na tabela "01"
				// (quando MV_TPNRNFS = 1), ou SXE/SXF (quando MV_TPNRNFS = 2)
				If cPaisloc == "BRA" .And. Len(AllTrim(SX5->X5_DESCRI)) < nTamNota
					nTamNota := 6
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pega o proximo numero de nota fiscal disponivel                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lLockX5
				cNumNota := MaConvNNota( X5Descri(,,,,.F.),nTamNota )
				cNewNUM  := ChkSX5Nota(cIniSER,cNumNota,.T.,nTamNota,cFilSx5,cTpNrNFS,cTab,cAliTp,cSerieId, lVerSE1 )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o Proximo numero de nota fiscal                               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (Val( cNewNUM ) >= Val(X5Descri(,,,,.F.)))
					SX5->X5_DESCRI  := SomaIt( cNewNum )
					SX5->X5_DESCSPA := SomaIt( cNewNum )
					SX5->X5_DESCENG := SomaIt( cNewNum )
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Libera o SX5                                                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lLibera .And. !InTransact() //Nao retirar
					SX5->(MsRUnLock())
				EndIf
			Else
				Final( STR0034 ) //"Problema Numeracao NF"
			EndIf
		ElseIf cTpNrNFS == "2"
			//-- Atualiza o conteúdo da filial
			If FindFunction("FWSizeFilial")
				nSizeFil := FWSizeFilial()
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pega o proximo numero de nota fiscal disponivel                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ`
			If PadR(cIniSER,3) == "PLS"
				cFilEF := PadR(xFilial("SE1")+X2PATH("SE1"),45+nSizeFil)
			Else
				cFilEF := PadR(xFilial("SF2")+X2PATH("SF2"),45+nSizeFil)
			EndIf

			cNewNum := GetSX8Num(cAliTp,,PadR(cIniSER,3)+cFilEF)

			If !Empty(__cSX5Num)
                //A variavel lAvanca, será enviado pelo Modulo SIGALOJA, para definir se é possivel
                // alterar o numero da Nota sugerida.
				If __cSX5Num < cNewNum .Or. lAvanca
					RollBackSX8()
					While cNewNum < __cSX5Num .And. lAvanca
						cNewNum := GetSX8Num(cAliTp,,PadR(cIniSER,3)+cFilEF)
					EndDo
					cNewNum := __cSX5Num
				Else
					__cSX5Num := ""
				EndIf
			EndIf

			// Gera nota com 6 ou 9 digitos, de acordo com o numero informado pelo usuario na tabela "01"
			// (quando MV_TPNRNFS = 1), ou SXE/SXF (quando MV_TPNRNFS = 2)
			If cPaisloc == "BRA" .And. Len(AllTrim(cNewNum)) < nTamNota
				nTamNota := 6
			EndIf

			cNewNUM := ChkSX5Nota(cIniSER,cNewNum,.T.,nTamNota,cFilSx5,cTpNrNFS,cTab,cAliTp,cSerieId)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Libera o SX6                                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !InTransact() //Nao retirar
			SX6->(MsGoto( nRecnoSX6 ) )
			SX6->(MsRUnLock())
		EndIf
	Else
		Final( STR0034 + " - NxtSX5Nota ") //"Problema Numeracao NF"
	EndIf

EndIf

//-- Valida se o Proximo numero da Nota Fiscal e' maior do que o numero informado no parametro MV_MAXNF (No. Maximo da Nota)
If !Empty(cNewNum) .And. !Empty(cMaxNF)
	If cNewNum > cMaxNF
		Final( STR0042 + cMaxNF )
	EndIf
EndIf

RestArea(aArea)
Return( cNewNUM )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ChkSX5Nota³ Rev.  ³Eduardo Riera          ³ Data ³07.12.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o numero da nota fiscal nao foi utilizado       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpC1: Numero da Nota Fiscal                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Serie da Nota fiscal                                 ³±±
±±³          ³ExpC2: Numero da Nota Fiscal                                ³±±
±±³          ³ExpL3: Indicador de liberacao do Lock do SX5                ³±±
±±³          ³ExpN4: Tamanho do numero da nota fiscal                     ³±±
±±³          ³ExpC5: Filial de pesquisa                                   ³±±
±±³          ³ExpC6: Tipo de numeracao de nota fiscal de saida            ³±±
±±³          ³       [1] Numeracao controla pelo SX5                      ³±±
±±³          ³       [2] Numeracao controla pelo SXE/SXF                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ChkSX5Nota(cIniSER,cIniNUM,lNoLock,nTamNota,cFilSx5,cTpNrNfs,cTab,cAliTp,cSerieId, lVerSE1 )

Local aArea   	:= GetArea()
Local aAreaSX5	:= SX5->(GetArea())
Local aAreaSX6	:= SX6->(GetArea())
Local cNewNUM 	:= ""
Local lLockX5 	:= Nil
Local lLockX6 	:= Nil
Local nCounter	:= 0
Local nRecnoSX6	:= 0
Local nSizeFil  := 2
LOCAL cFilEF 	:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa as variaveis DEFAULT                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT lNoLock := .F.
DEFAULT lLockX5 := lNoLock .Or. cTpNrNFS=="2"
DEFAULT lLockX6 := lNoLock .Or. cTpNrNFS=="2"
DEFAULT nTamNota:= TamSX3("F2_DOC")[1]
DEFAULT cFilSX5 := xFilial("SX5")
DEFAULT cTpNRNFS:= "1"
DEFAULT cTab	:= "01"
DEFAULT cAliTp	:= 'NFF'
DEFAULT cSerieId:= cIniSER
DEFAULT lVerSE1 := .T.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Cria um semaforo no parametro MV_NUMITEN                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SX6" )
If GETMV("MV_NUMITEN",.T.)
	While !lLockX6 .And. (++nCnt01 < 200)
		If InTransact()
			lLockX6 := RecLock("SX6")
		Else
			lLockX6 := MsRLock()
		EndIf
	EndDo
	If lLockX6
		nRecnoSX6 := SX6->( Recno() )
		If cTpNrNfs == "1"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Tenta locar o SX5 sem controle de transacao                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea( "SX5" )
			dbSetOrder(1)
			If MsSeek( cFilSx5+cTab+cIniSER,.F.)
				While !lLockX5 .And. (++nCnt01 < 200)
					If InTransact()
						lLockX5 := RecLock("SX5")
					Else
						lLockX5 := MsRLock()
					EndIf
				EndDo
				If lLockX5
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica se o numero da nota eh valido                                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nCounter := 0
					While ( ChkF3Nota( cSerieId,cIniNUM ) .Or.;
							ChkF3Deneg( cSerieId,cIniNUM ) .Or. ;
							ChkF2Nota( cSerieId,cIniNUM ) .Or. ;
	 						ChkE1Nota( cSerieId, cIniNUM, lVerSE1 ) .Or. ; // Se lVerSE1 == .T., continua a verificar a numeração da SE1, Se lVerSE1 == .F., não verifica a SE1 pois não gerará SE1 nesse momento
							ChkF1Nota( cSerieId,cIniNUM ) )
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Pega o proximo numero da nota                                          ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						cIniNUM := Soma1( cIniNUM , nTamNota )

						If (++nCounter > 200)
							Final( STR0034 ) //"Problema Numeracao NF"
						EndIf
					EndDo
					cNewNUM := cIniNUM
					If !lNoLock .And. !InTransact() //Nao retirar
						SX5->(MsRUnLock())
					EndIf
				EndIf
			EndIf
		Else
			//-- Atualiza o conteúdo da filial
			If FindFunction("FWSizeFilial")
				nSizeFil := FWSizeFilial()
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Defini filial do xe xf												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If PadR(cIniSER,3) == "PLS"
				cFilEF := PadR(xFilial("SE1")+X2PATH("SE1"),45+nSizeFil)
			Else
				cFilEF := PadR(xFilial("SF2")+X2PATH("SF2"),45+nSizeFil)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se o numero da nota eh valido                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nCounter := 0
			FreeUsedCode(.T.)
			While ( ChkF3Nota( cSerieId,cIniNUM ) .Or.;
					ChkF3Deneg( cSerieId,cIniNUM ) .Or. ;
					ChkF2Nota( cSerieId,cIniNUM ) .Or. ;
					ChkE1Nota( cSerieId,cIniNUM ) .Or. ;
					ChkF1Nota( cSerieId,cIniNUM ) ) .Or.;
					!MayIUseCode(cAliTp+cFilAnt+cSerieId+cIniNum)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Pega o proximo numero da nota                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(__cSX5Num)
					If __lSx8
						ConfirmSx8()
					EndIf
					cIniNum := GetSX8Num(cAliTp,,PadR(cIniSER,3)+cFilEF)
				Else
					__cSX5Num := Soma1( __cSX5Num , nTamNota )
					cIniNUM   := GetSX8Num(cAliTp,,PadR(cIniSER,3)+cFilEF)

					If __cSX5Num < cIniNUM
						cIniNUM := __cSX5Num
						RollBackSX8()
					Else
						__cSX5Num := ""
					EndIf
				EndIf
				FreeUsedCode()
			EndDo
			cNewNUM := cIniNUM
		EndIf
		If !lNoLock .And. !InTransact() //Nao retirar
			SX6->( MsGoto( nRecnoSX6 ) )
			SX6->(MsRUnLock())
		EndIf
	EndIf
EndIf
RestArea(aAreaSX5)
RestArea(aAreaSX6)
RestArea(aArea)
Return( cNewNUM )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ChkF1Nota ³ Rev.  ³Eduardo Riera          ³ Data ³07.12.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o numero da nota fiscal nao foi utilizado (SF1) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o numero ja foi utilizado                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Serie da Nota fiscal                                 ³±±
±±³          ³ExpC2: Numero da Nota Fiscal                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ChkF1Nota( cIniSER,cIniNUM )

Local aArea    := GetArea()
Local aAreaSF1 := SF1->(GetArea())
#IFDEF TOP
Local cQuery   := ""
#ENDIF
Local lBack    := .F.
Local lGrpCNPJ := MaIsNumCgc() // Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local aFilCGC  := {"",""}

#IFDEF TOP
	If TcSrvType()<>"AS/400"
		SF1->(dbCommit())
		cQuery := " SELECT COUNT(*) SF1NOTA "
		cQuery += " FROM "+RetSqlName("SF1")+" SF1 "

		If lGrpCNPJ // Utilizando o conceito de Agrupamento por CNPJ

			aFilCGC := MatFilCgc(SM0->M0_CGC,"SF1") // Retorna o Compartilhamento conforme CNPJ

			cQuery += " WHERE SF1.F1_FILIAL IN "+ FormatIN(aFilCGC[1],aFilCGC[2]) +" AND "


		Else

			cQuery += " WHERE SF1.F1_FILIAL='"+xFilial("SF1")+"' AND "

		Endif

		cQuery += " SF1.F1_SERIE='"+cIniSer+"' AND "
		cQuery += " SF1.F1_DOC='"+cIniNUm+"' AND "
		cQuery += " SF1.F1_FORMUL='S' AND "
		cQuery += " SF1.D_E_L_E_T_=' ' "

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"CHKF1NOTA",.T.,.T.)

		If CHKF1NOTA->SF1NOTA > 0
			lBack := .T.
		EndIf
		CHKF1NOTA->(dbCloseArea())
		dbSelectArea("SF1")
	Else
#ENDIF
	DbSelectArea( "SF1" )
	DbSetOrder( 1 )
	If MsSeek( xFilial("SF1")+cIniNUM+cIniSER,.F. )
		While !Eof() .And. (xFilial("SF1")+cIniNUM+cIniSER) == (SF1->F1_FILIAL+SF1->F1_DOC+SF1->F1_SERIE) .And. !lBack
			If (SF1->F1_FORMUL == "S")
				lBack := .T.
			EndIf
			DbSelectArea("SF1")
			DbSkip()
		EndDo
	EndIf
	#IFDEF TOP
	EndIf
	#ENDIF
RestArea(aAreaSF1)
RestArea(aArea)
Return( lBack )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ChkF2Nota ³ Rev.  ³Eduardo Riera          ³ Data ³07.12.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o numero da nota fiscal nao foi utilizado (SF2) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o numero ja foi utilizado                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Serie da Nota fiscal                                 ³±±
±±³          ³ExpC2: Numero da Nota Fiscal                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ChkF2Nota( cIniSER, cIniNUM )

Local aArea		:= GetArea()
Local aAreaSF2	:= SF2->(GetArea())
Local lBack     := .F.
Local lGrpCNPJ  := MaIsNumCgc() // Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local aFilCGC   := {"",""}
Local nFor      := 0

#IFDEF TOP
Local cQuery   := ""
#ENDIF

If lGrpCNPJ
	aFilCGC := MatFilCgc(SM0->M0_CGC,"SF2") // Retorna o Compartilhamento conforme CNPJ

EndIf

#IFDEF TOP
If TcSrvType()<>"AS/400"

	cQuery := " SELECT COUNT(*) QTD_SF2" + CRLF
	cQuery += " FROM " +  RetSqlName("SF2") + " SF2" + CRLF
	cQuery += " WHERE" + CRLF
	cQuery += "    SF2.F2_FILIAL      " + IIf( lGrpCNPJ, "in " + FormatIN(aFilCGC[1],aFilCGC[2]), " = '" + xFilial("SF2") + "'" ) + CRLF
	cQuery += "    AND SF2.F2_SERIE   = '" + PADR( cIniSER, TamSX3("F2_SERIE")[1] ) + "'" + CRLF
	cQuery += "    AND SF2.F2_DOC     = '" + PADR( cIniNUM, TamSX3("F2_DOC  ")[1] ) + "'" + CRLF
	cQuery += "    AND SF2.D_E_L_E_T_ = ' '"

	cQuery := ChangeQuery(cQuery)

	If Select("CHKF2NOTA") > 0
		CHKF2NOTA->(dbCloseArea())
	EndIf

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"CHKF2NOTA")

	If CHKF2NOTA->QTD_SF2 > 0
		lBack := .T.
	EndIf

	CHKF2NOTA->(dbCloseArea())

Else
#ENDIF

	DbSelectArea( "SF2" )
	DbSetOrder( 1 )
	// Necessario PADR quando tamanho do campo F2_DOC e' maior que o numero da nota selecionada pelo usuário.
	// ocorria problema no posicionamento quando era gerado uma nota com serie "" e o numero ja existia para outra serie.
	If lGrpCNPJ

		For nFor := 1 To Len( aFilCGC[3] )
			If MsSeek( aFilCGC[3][nFor] + PADR(cIniNUM,TamSX3("F2_DOC")[1]) + PADR(cIniSER,TamSX3("F2_SERIE")[1] ),.F. )
				lBack := .T.
				Exit
			EndIf
		Next nFor

	Else

		lBack := MsSeek( xFilial("SF2") + PADR(cIniNUM,TamSX3("F2_DOC")[1]) + PADR(cIniSER,TamSX3("F2_SERIE")[1] ),.F. )

	EndIf

#IFDEF TOP
EndIf
#ENDIF

RestArea(aAreaSF2)
RestArea(aArea)
Return( lBack )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ChkE1Nota ³ Rev.  ³Eduardo Riera          ³ Data ³14.08.2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o numero do titulo nao foi utilizado            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o numero ja foi utilizado                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Serie da Nota fiscal                                 ³±±
±±³          ³ExpC2: Numero da Nota Fiscal                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ChkE1Nota( cIniSER, cIniNUM, lVerSE1 )

Local aArea    := GetArea()
Local aAreaSE1 := SE1->(GetArea())
Local lBack    := .F.
Local lGrpCNPJ := MaIsNumCgc() // Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local aFilCGC  := {"",""}

#IFDEF TOP
Local cQuery   := ""
#ENDIF

DEFAULT lVerSE1 := .T.

If "SF2->F2_SERIE"$SuperGetMv("MV_1DUPREF",.F.) .AND. lVerSE1
#IFDEF TOP
	If TcSrvType()<>"AS/400"
		SE1->(dbCommit())
		cQuery := "SELECT COUNT(E1_FILIAL) TITULOS "
		cQuery += "FROM "+RetSqlName("SE1")+" SE1 "

		If lGrpCNPJ // Utilizando o conceito de Agrupamento por CNPJ

			aFilCGC := MatFilCgc(SM0->M0_CGC,"SE1") // Retorna o Compartilhamento conforme CNPJ

			cQuery += "WHERE SE1.E1_FILIAL IN "+ FormatIN(aFilCGC[1],aFilCGC[2]) +" AND "


		Else

			cQuery += "WHERE SE1.E1_FILIAL='"+xFilial("SE1")+"' AND "

		Endif
		cQuery += "SE1.E1_PREFIXO='"+cIniSer+"' AND "
		cQuery += "SE1.E1_NUM='"+cIniNUM+"' AND "
		cQuery += "SE1.E1_TIPO='"+MVNOTAFIS+"' AND "
		cQuery += "SE1.D_E_L_E_T_=' ' "

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"CHKE1NOTA")

		If CHKE1NOTA->TITULOS > 0
			lBack := .T.
		EndIf
		CHKE1NOTA->(dbCloseArea())
		dbSelectArea("SE1")
	Else
#ENDIF
	DbSelectArea( "SE1" )
	DbSetOrder( 1 )
	MsSeek( xFilial("SE1")+cIniSER+cIniNUM,.F. )
	While !Eof() .And. xFilial("SE1") == SE1->E1_FILIAL .And.;
		cIniSer == SE1->E1_PREFIXO .And.;
		cIniNum == SE1->E1_NUM
		If SE1->E1_TIPO == MVNOTAFIS
			lBack := .T.
		EndIf
		DbSelectArea( "SE1" )
		dbSkip()
	EndDo
#IFDEF TOP
	EndIf
#ENDIF
EndIf

RestArea(aAreaSE1)
RestArea(aArea)
Return( lBack )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ChkF3Nota ³ Rev.  ³Eduardo Riera          ³ Data ³07.12.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o numero da nota fiscal nao foi utilizado (SF3) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o numero ja foi utilizado                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Serie da Nota fiscal                                 ³±±
±±³          ³ExpC2: Numero da Nota Fiscal                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function ChkF3Nota( cIniSER,cIniNUM )

Local aArea    := GetArea()
Local aAreaSF3 := SF3->(GetArea())
Local lBack    := .F.
#IFDEF TOP
Local cQuery   := ""
#ENDIF
Local lGrpCNPJ := MaIsNumCgc() // Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local aFilCGC  := {"",""}

If cPaisLoc == "BRA"
	#IFDEF TOP
		If TcSrvType()<>"AS/400"
			SF3->(dbCommit())
			cQuery := "SELECT COUNT(*) SF3NOTA "
			cQuery += "FROM "+RetSqlName("SF3")+" SF3 "

			If lGrpCNPJ // Utilizando o conceito de Agrupamento por CNPJ

				aFilCGC := MatFilCgc(SM0->M0_CGC,"SF3") // Retorna o Compartilhamento conforme CNPJ

				cQuery += " WHERE SF3.F3_FILIAL IN "+ FormatIN(aFilCGC[1],aFilCGC[2]) +" AND "

			Else

				cQuery += "WHERE SF3.F3_FILIAL='"+xFilial("SF3")+"' AND "

			Endif

			cQuery += "SF3.F3_SERIE='"+cIniSer+"' AND "
			cQuery += "SF3.F3_NFISCAL='"+cIniNum+"' AND "
			cQuery += "SF3.F3_DTCANC='"+Space(8)+"' AND "
			cQuery += "(SF3.F3_CFO LIKE '5%' OR SF3.F3_CFO LIKE '6%' OR SF3.F3_CFO LIKE '7%' OR SF3.F3_FORMUL='S' ) AND "
			cQuery += "SF3.D_E_L_E_T_=' ' "

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"CHKF3NOTA",.T.,.T.)

			If CHKF3NOTA->SF3NOTA > 0
				lBack := .T.
			EndIf
			CHKF3NOTA->(dbCloseArea())
			dbSelectArea("SF3")
		Else
	#ENDIF
		DbSelectArea( "SF3" )
		DbSetOrder( 5 )
		If MsSeek( xFilial("SF3")+cIniSER+cIniNUM,.F.)
			If Substr(SF3->F3_CFO,1,1) < "5"
				While !Eof() .And. (xFilial("SF3")+cIniSER+cIniNUM) == (SF3->F3_FILIAL+SF3->F3_SERIE+SF3->F3_NFISCAL) .And. !lBack
					If (SF3->F3_FORMUL == "S" .Or.Substr(SF3->F3_CFO,1,1) > "5") .And.Empty(SF3->F3_DTCANC)
						lBack := .T.
					EndIf
					DbSelectArea("SF3")
					DbSkip()
				EndDo
			Else
				If Empty(SF3->F3_DTCANC)
					lBack := .T.
				EndIf
			EndIf
		EndIf
		#IFDEF TOP
		EndIf
		#ENDIF
Else
	//Somente usado para NF de Faturamento, nas Localizacoes as devolucoes e
	// complemento tem suas rotinas proprias de validacoes Bruno/Dourado
	DbSelectArea( "SF3" )
	DbSetOrder(5)
	If DbSeek( xFilial("SF3")+cIniSER+cIniNUM,.F. )
		While !Eof() .And. (xFilial("SF3")+cIniSER+cIniNUM) == (SF3->F3_FILIAL+SF3->F3_SERIE+SF3->F3_NFISCAL) .And. !lBack
			If Alltrim(SF3->F3_ESPECIE) $MVNOTAFIS .And. SF3->F3_TIPOMOV == "V"
				If GetMv("MV_CONTNF")=="M" .Or. SF3->F3_TIPO $ "N "
					If Empty(SF3->F3_DTCANC)
						lBack := .T.
						Exit
					Else
						lBack := .F.
					Endif
				Endif
			Endif
			SF3->(dbSkip())
		Enddo
	EndIf
Endif
RestArea(aAreaSF3)
RestArea(aArea)
Return( lBack )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ ChkF3LOC³ Autor ³   Ben Hur/Dourado     ³ Data ³ 06.10.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consiste numero da proxima Nota Fiscal - SF3               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := ChkF3Loc(ExpC1,ExpC2,ExpC3)                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 := Serie da Nota                                     ³±±
±±³          ³ ExpC2 := Numero da Nota                                    ³±±
±±³          ³ ExpC3 := Especie da Factura NF /NCC/NDC/NFE...             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA461 , MATA467                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ChkF3Loc( cIniSER , cIniNUM , cEspecie)

Local lBack   := .F.
Local aArea   := GetArea()
Local aAreaF3 := NIL

DEFAULT  cEspecie := CriaVar("F3_ESPECIE")
DEFAULT	ciniSer	:=	CriaVar("F3_SERIE")

cIniSer := cIniSer + Space(3-Len(cIniSer))
DbSelectArea( "SF3" )
aAreaF3 := GetArea()
DbSetOrder( 5 )
//Somente usado para nota Debito e Credito
// complemento tem suas rotinas proprias de validacoes
//Bruno/Dourado.

DbSeek( xFilial("SF3")+cIniSER+cIniNUM,.f. )
While !Eof() .And. (xFilial("SF3")+cIniSER+cIniNUM) == (SF3->F3_FILIAL+SF3->F3_SERIE+SF3->F3_NFISCAL)
	If Sf3->F3_TIPOMOV == "V"
		If GetMv("MV_CONTNF")=="I"
			If Alltrim(SF3->F3_ESPECIE) == Alltrim(cEspecie)
				If Empty(SF3->F3_DTCANC)
					lBack := .T.
					Exit
				Else
					lBack := .F.
				Endif
			Endif
		Else
			If Empty(SF3->F3_DTCANC)
				lBack := .T.
				Exit
			Else
				lBack := .F.
			Endif
		Endif
	Endif
	DbSkip()
Enddo

RestArea( aAreaF3 )
RestArea( aArea )

Return( lBack )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ ValidMasc³ Autor ³ Marcos Bregantim    ³ Data ³19.09.95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida a mascara digitada como parametro do relatorio    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Relatorios Faturamento                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function ValidMasc(cProduto,cMascara)
Local lRet := .T., ni:=0

If cMascara != Replicate("*",Len(cMascara)) .And. cMascara != Replicate("?",Len(cMascara)) .And. !Empty(cMascara)
	For ni := 1 to Len(cProduto)
		If SubStr(cProduto,ni,1) != SubStr(cMascara,ni,1) .And. !(SubStr(cMascara,ni,1) $ "*?")
			lRet := .F.
			Exit
		EndIf
	Next
EndIf
Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³RetAsc    ³Autor ³ Cristiane Maeda    ³ Data ³ 29/09/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna Letra quando ultrapassado o n. Max de digitos     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³cExpA := RetAsc(cExp1,nExp2,lExp3)                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cExpA - String Formada com Letras (.T.), ou Numeros (.F.)   ³±±
±±³      ³cExp1 - String a Ser Convertida                   ³±±
±±³      ³nExp2 - Tamanho m ximo da String de Retorno           ³±±
±±³      ³lExp3 - .T. : String c/ numeros e retorno em letras       ³±±
±±³      ³(Ex. "100",Tamanho 2, .T. )  - Retorna "A0"    ³±±
±±³      ³     .F. : String c/ Letras e Retorno em Numeros      ³±±
±±³      ³(Ex. "A0",Tamanho 2, .F. ) - Retorna "100"     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ CFGx031.PRG                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RetAsc(cString,nTamanho,lVolta)
Local i,cStr

cString := Iif(ValType(cString) == "N",Str(cString),cString)
cStr := AllTrim(Iif(Val(cString) > 0,Str(Val(cString)),cString))
If lVolta
	i := Len(cStr)
	If i > nTamanho
		j := 1
		If nTamanho == 1
			cStr := Chr(55 + Val(Substr(cStr,j,2))) +  Substr(cStr,j+2)
		Else
			While j < nTamanho
				cStr := Chr(55 + Val(Substr(cStr,j,2))) +  Substr(cStr,j+2)
				j := Len(cStr)
			End
		EndIf
	EndIf
Else
	cString := cStr
	cStr := ""
	For i := 1 To nTamanho
		If IsAlpha(Substr(cString,i,1))
			cStr += AllTrim(Str(Asc(Substr(cString,i,1))-55))
		Else
			cStr += Substr(cString,i,1)
		EndIf
	Next i
EndIf

cStr := Replicate("0",nTamanho - Len(cStr) ) + cStr
Return cStr

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ MsgDbg ³ Autor ³ Ary             ³ Data ³ 11/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Debug para FiveWin                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ DEBUG xExp1,xExp2,xExp3,...                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MsgDbg(aStr)
Local cStr := "",i
For i:= 1 to Len(aStr)
	If !Empty(cStr)
		cStr += CHR(13)
	EndIf
	cStr+= cValToChar(aStr[i])
Next
MsgStop(cStr,"Debug")
Return nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³ MontaF3  ³ Autor ³ Wagner Xavier        ³ Data ³ 19.09.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Habilita ou nao a tecla F3                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MontaF3(cArq)
If cArq == nil
	Set Key -2 To      //F3
Else
	SetKey( -2, {|a,b,c| ConPad1(a,b,c,cArq)} )
End
Return (.t.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³FilterInSe³ Autor ³ Wilson            ³ Data ³ 19.09.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Habilita ou nao a tecla F3                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function FilterInSerVer(cFor)
#IFNDEF AXS
	Return .f.
#ELSE
	IF "AX"$RddName()
		RETURN (AX_ExprValid(cFor))
	Else
		Return .f.
	Endif
#ENDIF

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³CalcDesc  ³ Autor ³ Cristina Ogura      ³ Data ³ 24/05/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Calcula descontos em cascatas de um valor.            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CalcDesc(Exp1,Exp2,Exp3,Exp4)                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nValor - valor a ser calculado o desconto             ³±±
±±³      ³nDesc1 - desconto 1                           ³±±
±±³      ³nDesc2 - desconto 2                           ³±±
±±³      ³nDesc3 - desconto 3                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ valor do desconto                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcDesc( nValor, nDesc1, nDesc2, nDesc3)
Local nTotDesc:= 0

nTotDesc := ROUND(nValor*nDesc1/100,2)
nTotDesc := nTotDesc + ROUND((nValor-nTotDesc)*nDesc2/100,2)
nTotDesc := nTotDesc + ROUND((nValor-nTotDesc)*nDesc3/100,2)

Return (nTotDesc)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ A360Cond ³ Autor ³ Ben-Hur M Castilho    ³ Data ³ 08/05/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Executa a Validacao da Condicao de Pagamento           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ void A360Cond()                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ MATA360                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function A360Cond()

Local lBack  := .T.,;
	nNumEl := 0
aTp8:={}

Begin Sequence

	Do Case
	Case A360CndErr( M->E4_TIPO,M->E4_COND,@nNumEl )
		Help( " ",1,"A360TIPO" ) ; lBack := .F.

	Case ((M->E4_TIPO == "1") .And. (nNumEl < 01)) ; Break( nil )
	Case ((M->E4_TIPO == "2") .And. (nNumEl # 01)) ; Break( nil )
	Case (M->E4_TIPO == "3")
		If  ( nNumEl < 03 )
			Break( nil )
		Else
			aCondic := StrTokArr2( M->E4_COND ,"," )
			If ( Val( aCondic[1] ) <= 0 )
				Help( NIL, NIL, "VldTipo3", NIL, STR0060, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0061} )
				lBack := .F.
			EndIf
		EndIf
	Case ((M->E4_TIPO == "4") .And. (nNumEl # 03)) ; Break( nil )
	Case ((M->E4_TIPO == "5") .And. (nNumEl # 03)) ; Break( nil )
	Case ((M->E4_TIPO == "6") .And. (nNumEl # 04)) ; Break( nil )
	Case ((M->E4_TIPO == "7") .And. (nNumEl # 13)) ; Break( nil )
	Case ((M->E4_TIPO == "C") .And. (nNumEl < 01)) ; Break( nil )
	Case ((M->E4_TIPO == "D") .And. (nNumEl < 01)) ; Break( nil )
	Case ((M->E4_TIPO == "8"))
		If nNumEl < 01
			Break( nil )
		Else
			aTp8:=ArrayTP8(M->E4_COND)
			If Len(aTP8) = 0
				Break( Nil )
			EndIf
		EndIf
	Case ((M->E4_TIPO == "9") .And. (nNumEl > 01)) ; Break( nil )
	Case (M->E4_TIPO == "A" .Or. M->E4_TIPO == "B" )
	EndCase
	Recover

	Help( " ",1,"A360TIP"+M->E4_TIPO ) ; lBack := .F.
End Sequence

Return( lBack )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³A360CndErr³ Autor ³ Ben-Hur m Castilho    ³ Data ³ 08/05/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ VerIfica o Tipo e  Condicao Digitados                ³±±
±±³      ³ Validacoes em Condicao, Conforme Descricao do Manual FAT   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ logical A360CndErr( ExpC1,ExpC2,@ExpN1 )             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Retorna .T. se Erro Ocorreu e .F. se Ok              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 - Tipo da Condicao de Pagamento                ³±±
±±³      ³ ExpC2 - Condicao da Condicao de Pagamento            ³±±
±±³      ³ ExpN1 - Variavel Por Referencia que Sera Preenchida com    ³±±
±±³      ³      o Numero de Itens Dentro do Campo Condicao.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ MATA360                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A360CndErr( cTipo,cCondicao,nNumEl )

Local lBack  := .T.,;
	nCnt01 := 0,;
	cLetra := "",;
	aNumEl := { "" }
IF cTipo == "A"
	Return(.f.)
Endif

If (At( cTipo,"123456789BCD" ) # 0)

	If Empty( (cCondicao := AllTrim( cCondicao )) )

		lBack := .F.
	Else

		If (Left( cCondicao,1 ) $ "[1234567890%]")

			lBack := .F.

			For nCnt01 := 1 To Len( cCondicao )

				Do Case
				Case IsDigit( (cLetra := SubStr( cCondicao,nCnt01,1 )) ) .And. (cTipo # "9") .And. (cTipo # "8")
					aNumEl[ Len( aNumEl ) ] += cLetra

				Case (cTipo == "9") .And. (cLetra $ "0%")
					aNumEl[ Len( aNumEl ) ] += cLetra

				Case (cTipo == "8") .And. (cLetra $ "[1234567890.]")
					aNumEl[ Len( aNumEl ) ] += cLetra

				Case (cLetra == ",")
					AAdd( aNumEl,"" )

				OtherWise
					nCnt01 := 1000 ; lBack := .T.
				EndCase
			Next
		EndIf
	EndIf
EndIf

nNumEl := (Len( aNumEl )-If( Empty( ATail( aNumEl ) ),1,0 ))

Return( lBack )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³A360Tipo  ³ Autor ³ Cristina Ogura      ³ Data ³ 14/05/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ VerIfica quando o Tipo da Condicao for 9, os campos de IPI ³±±
±±³      ³ e ICM Solidario so podem ser preenchido com N ou branco.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ logical A360Tipo (ExpC1)                       ³±±
±±³      ³ ExpC1 - quando for "T" - campo E4_TIPO                     ³±±
±±³      ³    - quando for ""  - campo E4_IPI e E4_SOLID           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Retorna .T. se Erro Ocorreu e .F. se Ok              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ MATA360                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function A360Tipo(cVar)

/*
	As validações executadas por esta função foram transportadas para as funções Mt360PrVdF e A360Pos, que estão
	no programa MATA360.PRX.
	A A360Tipo ainda não foi removida deste fonte, pois tal alteração ocorreu no período de manutenção do release
	12.1.19 e possui chamada via dicionário SX3. Em consonância a isto, a expedição do dicionário SX3 da versão
	12.1.20 está sendo preparada de modo que as chamadas para esta função na validação dos campos E4_TIPO, E4_IPI
	e E4_SOLID não existam mais.
	Portanto, assim que ocorrer a expedição do dicionário da versão 12.1.20, esta função A360Tipo também poderá
	ser removida deste programa fonte.
*/
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³CloseSFILE³ Autor ³ Ricardo Luiz da Silva ³ Data ³ 26/06/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao para fechar arquivos do sistema, exceto SX's.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := CloseSFILE( ExpC1 )                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 - Alias do(s) Arquivo(s) que nao serao fechados    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 - .T. Se Ok e .F. Se Ocorrerem Problemas         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function CloseSFILE( cFilAlias )


If Empty( cFilAlias ) .And. ;
		ValType( cFilAlias ) != "C"
	Return .F.
EndIf

If !("SM2" $ cFilAlias)
	cFilAlias := cFilAlias+"/SM2"
EndIf

If !("SM4" $ cFilAlias)
	cFilAlias := cFilAlias+"/SM4"
EndIf

DbSelectArea( "SX2" ) ; DbSetOrder( 1 ) ; DbGoTop()

While !Eof()
	If !("SX" $ SX2->X2_CHAVE) .And. ;
			!(SX2->X2_CHAVE $ cFilAlias)
		If (Select( SX2->X2_CHAVE ) # 0)
			(SX2->X2_CHAVE)->(DbCloseArea())
		EndIf
	EndIf
	SX2->(DbSkip(1))
End

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³A010LojProc³ Autor ³ Cristina M. Ogura    ³ Data ³ 20.05.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ VerIfica se a loja digitada esta no SA2              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A010LojProc()                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ MATA010                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A010LojProc()
Local lRet	 	:= .T.
Local lRun		:= .F.
Local cAlias 	:= Alias()
Local cVar 	 	:= AllTrim( ReadVar() )
Local cCodForn	:= Nil
Local cLojForn	:= Nil
Local cCpoForn	:= ''
Local cCpoLoja	:= ''

Do Case
Case cVar == 'M->B1_LOJPROC'
	cCpoForn	:= 'B1_PROC'
	cCpoLoja	:= 'B1_LOJPROC'
	lRun		:= .T.
Case cVar == 'M->S4_LOJPROC'
	cCpoForn	:= 'S4_PROC'
	cCpoLoja	:= 'S4_LOJPROC'
	lRun		:= .T.
EndCase

If lRun .And. !( Empty( GetMemVar( cCpoForn ) ) ) .And. !( Empty( GetMemVar( cCpoLoja ) ) )
	SA2->(dbSetOrder(1))
	cCodForn := Padr( GetMemVar( cCpoForn ), TamSx3( cCpoForn )[ 1 ] )
	cLojForn := Padr( GetMemVar( cCpoLoja ), TamSx3( cCpoLoja )[ 1 ] )
	lRet	 := SA2->(dbSeek(FWxFilial("SA2") + cCodForn + cLojForn))
EndIf

dbSelectArea( cAlias )
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³FBuscaCpo  ³Autor ³ J. Ricardo        ³ Data ³ 02/02/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para posicionamento e retorno de um campo de 1 arq. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³FBuscaCpo(Alias,Ordem,Expressao,Campo)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ SIGAPLAN                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FBuscaCpo(cAlias,nOrdem,cExpr,cCpo)
Local cSavAlias := Alias(), nRecno := Recno(), cRet
Local nSavOrdem := IndeXord()
DbSelectArea(cAlias)
DbSetOrder(nOrdem)
DbSeek(cExpr)
cRet := &(cCpo)
DbSelectArea(cSavAlias)
DbSetOrder(nSavOrdem)
DbGoTo(nRecno)
Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³MsFCreate  ³Autor ³ J. Ricardo        ³ Data ³ 02/02/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para Redirecionamento do MSFCREATE()            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³MsMSFCREATE(cFile,nAtribute)                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MSFCREATE(cFile,nAtribute)
Local nHdl := FCREATE(cFile,nAtribute)
Return nHdl

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³CriaEstru ³ Autor ³ Gilson Nascimento   ³ Data ³ 09/07/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria Estrutura atraves do dicinario de dados.          ³±±
±±³      ³ (AVERAGE/MICROSIGA)                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExprA1:=CriaEstru(ExprA2,ExprA3,ExprC1)              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Retorna array com Estrutura                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³ SIGAEIC                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function CriaEstru(aArray,aCriaHeader,cArq)
Local cAliasAnt:=Alias(),nx,aEstruc:={}
Local nTot:=If(cArq # Nil,1,Len(aArray)),nPos
For nx:=1 to nTot
	DbSelectArea("SX3")
	DbSetOrder(1)
	If aArray[nx] # Nil
		nPos := At("_",aArray[nx])
		//      cArq:= "S"+Subs(aArray[nx],1,2)
		cArq :=If(nPos>3,Subs(aArray[nx],1,3),"S"+Subs(aArray[nx],1,2))
	EndIf
	DbSeek( cArq )
	While !EOF() .And. (x3_arquivo == cArq)
		cCampo :=Iif( aArray[nx] # Nil,aArray[nx],Trim(x3_campo) )
		If X3uso(x3_usado) .and. Trim(x3_campo) == cCampo
			//If Trim(x3_campo) == cCampo

			AADD(aEstruc, {cCampo,x3_tipo,x3_tamanho,x3_decimal} )

			AADD(aCriaHeader,{ Trim(X3Titulo()), cCampo, x3_picture,;
				x3_tamanho, x3_decimal, x3_valid,;
				x3_usado, x3_tipo, x3_arquivo, x3_context } )

			If aArray[nx] # Nil
				Exit
			EndIf
		EndIf
		DbSkip()
	End
Next nx
If !Empty(cAliasAnt)
	DbSelectArea(cAliasAnt)
EndIf
Return aEstruc

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³MSGetPos  ³ Autor ³ Gilson Nascimento   ³ Data ³ 09/07/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Ajusta os registros no index para utilizacao na GetDadDB   ³±±
±±³      ³ (AVERAGE/MICROSIGA)                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MSGetPos(alias)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³ SIGAEIC                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
FUNCTION MSGetPos(cAlias)
Local cALiasOld:=Alias(),i,cRet
DbSelectArea(cAlias)
For i:=1 to FCount()
	If !Empty(FieldGet(i))
		cRet := "A"
		Exit
	EndIf
	cRet:="B"
Next i
If !Empty(cAliasOld)
	DbSelectArea(cAliasOld)
EndIf
Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ GetIdMemo³ Autor ³ Gilson Nascimento   ³ Data ³ 09/07/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Busca proximo numero no SX6                      ³±±
±±³      ³ (AVERAGE/MICROSIGA)                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GetIdMemo()                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³ SIGAEIC                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
FUNCTION GetIdMemo()
Local cAliasOld:=Alias(),cRet
cRet:=GETMV("MV_IDMEMO")
DbSelectArea("SX6")
While !MsRLock();End
Replace X6_CONTEUD With StrZero(Val(cRet)+1,6)
dbUnLock()
If !Empty(cAliasOld)
	DbSelectArea(cAliasOld)
EndIf
Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ MontACols³ Autor ³ Gilson Nascimento   ³ Data ³ 09/07/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta aCols especIfico para GETDADDB e Campos diversos Arq.³±±
±±³      ³ (AVERAGE/MICROSIGA)                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MontACols()                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³ SIGAEIC                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function MontACols(cAlias,cSeek,aCols,nUsado,cExpr1,cExpr2)
Local nReg,nCnt,cCpoFil:=PrefixoCpo(cAlias)+"_FILIAL"
Local nElem,lDados:=.T.,nIni
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona ponteiro do arquivo cabeca e inicializa variaveis³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea(cAlias)
nReg:=Recno()
DbSeek(cSeek)
nCnt := 0
While !EOF() .and. &(cCpoFil) == cFilial .And. &(cExpr1)
	lDados:=.F.
	nReg:=Recno()
	nCnt++
	DbSelectArea("SX3")
	DbSeek(cAlias)
	While !EOF() .And. x3_arquivo == cAlias
		//If X3USO(x3_usado) .AND. cNivel >= x3_nivel .And. &(cExpr2)
		nElem:=Ascan(aHeader,{|x|x[2]==(x3_campo)})
		If nElem > 0
			//nUsado++
			If x3_context # "V"
				aCOLS[nCnt][nElem] := &(cAlias+"->"+x3_campo)
			ElseIf x3_context == "V"
				aCOLS[nCnt][nElem] := CriaVar(AllTrim(x3_campo))
			EndIf
		EndIf
		DbSkip()
	End
	DbSelectArea(cAlias)
	DbSkip()
End
If (!Found() .and. lDados) .or. (!lDados .and. nCnt < Len(aCols))
	nIni:=If(nCnt==0,1,++nCnt)
	For nCnt:=nIni to Len(aCols)
		DbSelectArea("SX3")
		DbSeek(cAlias)
		While !EOF() .And. x3_arquivo == cAlias
			//If X3USO(x3_usado) .AND. cNivel >= x3_nivel .And. &(cExpr2)
			nElem:=Ascan(aHeader,{|x|x[2]==(x3_campo)})
			If nElem > 0
				//nUsado++
				aCOLS[nCnt][nElem] := CriaVar(AllTrim(x3_campo))
			EndIf
			DbSkip()
		End
	Next nCnt
	DbSelectArea(cAlias)
EndIf
DbGoTo(nReg)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ MSAguarde³ Autor ³ Gilson Nascimento   ³ Data ³ 09/07/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta Tela de Processamento para Multiplas mensagems com   ³±±
±±³      ³ opcao de Aguarde Processamento sem a Gauge.            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MSAguarde                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³ SIGAEIC (AVERAGE/MICROSIGA)                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/


Function MSAguarde( bAction, cTitle ,cMsg,lAbort)
Local oDlg, oTimer
Local lEnd := .f.

If IsBlind()
	Eval( bAction )
Else
	DEFAULT lAbort := .f.
	DEFAULT bAction := { || nil }, cMsg := OemToAnsi(STR0018), cTitle := OemToAnsi(STR0019) //"Processando..." ### "Aguarde"

	DEFINE MSDIALOG oDlg FROM 12,35 TO 19.5, 75 TITLE OemToAnsi(cTitle) STYLE DS_MODALFRAME STATUS

	@ 10, 20  SAY oText VAR OemToAnsi(cMsg) SIZE 130, 10 PIXEL OF oDlg FONT oDlg:oFont

	If lAbort
		DEFINE SBUTTON FROM 31.5,127.5 TYPE 2 ACTION (lAbortPrint := .t.,lEnd := .t.) ENABLE OF oDlg
	Else
		DEFINE SBUTTON FROM 31.5,127.5 TYPE 2 OF oDlg
	EndIf
	oDlg:bStart = { || Eval( bAction, @lEnd ),lEnd := .t., oDlg:End() }
	nBmp := 1

	ACTIVATE DIALOG oDlg VALID lEnd CENTERED
Endif
Return nil

Static Function _xChgBmp(nBmp,oBmp)
Local nResto := If(nBmp%4==0,4,nBmp%4)
Local cBmp := "CLOCK"+StrZero(nResto,2,0)

oBmp:cResName := cBmp
oBmp:SetBmp()
oBmp:Display()
Return

Function MSProcTxt(cMSG)
If cMsg != nil
	oText:SetText(cMSG)
EndIf
SysRefresh()
Return nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³Getx3BOXE ³ Autora³ Cristiane Maeda     ³ Data ³ 04/10/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Mostra campo de acordo com Item selecionado em SeleSx3Box   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³SeleSx3Box                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³Enchoice                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/

Function GetX3BoxE(cCombo,nSubx,nTamCpo,cAlias)
Local cItem := "" ,nInitcBox ,aCombo:={}, nTam
Local cAxPr := cAlias+"->"+AllTrim(Subs(aGets[nSubx],9,10))
Local cCampo := &(cAxPr)
aCombo := RetSx3Box(cCombo,@nInitcBox,@nTam,nTamCpo)
nIniPos := Ascan(aCombo,{|x| cCampo $ x[2]})
nIniPos := Iif(nIniPos == 0,Len(aCombo),nIniPos)

If Empty(cCampo) .and. nInitcBox < Len(aCombo) .and. cAlias == "M"
	cCampo := aCombo[nInitcBox,3]
	&cAxPr := aCombo[nInitcBox,2]
Else
	cCampo := aCombo[nIniPos,3]
EndIf

Return cCampo



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³RetSx3BOX ³ Autora³ Cristiane Maeda     ³ Data ³ 04/10/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta Array de acordo com Item selecionado em SeleSx3Box   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³RetSx3Box                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³Enchoice                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function RetSx3Box(cCombo,nInitCBox,nTam,nTamCpo,cInitValue)
Local  cDescItem,cItem,aCombo:={},nTamDesc:=0,cDesc,ni,lInitValue, lHasInit

lHasInit := !Empty(cInitValue)
nTam:=0

While .T.
	lInitValue:=.F.
	cDescItem := AllTrim(Substr(cCombo,1,At(";",cCombo)-1))
	cDesc := AllTrim(Subs(cDescItem,AT("=",cDescItem)+1))
	nTamDesc := Iif(Len(cDesc)>nTamDesc,Len(cDesc),nTamDesc)

	cItem := AllTrim(Substr(cDescItem,1,At("=",cDescItem)-1))

	If ( "&" $ cItem ) .And. ( ! lHasInit )
		lInitValue:=.T.
	EndIf

	cItem := StrTran(cItem,"&","",1)
	cItem := cItem+Space(nTamCpo-Len(cItem))
	cItem := Subs(cItem,1,nTamCpo)

	IF Len(cItem) == 0
		cDescItem := " "+cDescItem
	Endif

	If lInitValue
		cInitValue:= cItem
	EndIf

	If !Empty(cDescItem)
		AADD(aCombo,{cDescItem,cItem,cDesc})
	EndIf

	cCombo := Substr(cCombo,At(";",cCombo)+1)
	If At(";",cCombo) == 0
		cDescItem := AllTrim(cCombo)
		cDesc := AllTrim(Subs(cDescItem,AT("=",cDescItem)+1))
		nTamDesc := Iif(Len(cDesc)>nTamDesc,Len(cDesc),nTamDesc)
		cItem := AllTrim(Substr(cDescItem,1,At("=",cDescItem)-1))
		cItem := StrTran(cItem,"&","",1)
		IF Len(cItem) == 0
			cDescItem := " "+cDescItem
		Endif
		cItem := cItem+Space(nTamCpo-Len(cItem))
		cItem := Subs(cItem,1,nTamCpo)
		If !Empty(cDescItem)
			AADD(aCombo,{cDescItem,cItem,cDesc})
		EndIf
		Exit
	EndIf
	If Len(Substr(cDescItem,At("=",cDescItem)+1)) > nTam
		//  nTam := Len(Substr(cDescItem,At("=",cDescItem)+1))
		nTam := Len(AllTrim(cDescItem))
	EndIf
End

For ni:= 1 to Len(aCombo)
	aCombo[ni,3] := aCombo[ni,3]+Space(nTamDesc-Len(aCombo[ni,3]))
Next

If Len(Substr(cDescItem,At("=",cDescItem)+1)) > nTam
	// nTam := Len(Substr(cDescItem,At("=",cDescItem)+1))
	nTam := Len(AllTrim(cDescItem))
EndIf
AADD(aCombo,{Space(nTam),Space(Len(aCombo[1,2])),Space(nTamDesc) } )
nInitCBox := Ascan(aCombo,{|x| "&" $ x[1]})
If nInitcBox > 0
	aCombo[nInitCbox] := {AllTrim(StrTran(aCombo[nInitCBox,1],"&","",1)),aCombo[nInitCBox,2],aCombo[nInitCBox,3]}
Endif
IF lHasInit
	nInitCBox := Ascan(aCombo,{|x| x[2] == cInitValue})
Endif
IF nInitcBox == 0
	nInitcBox := Len(aCombo)
   cInitValue := aCombo[nInitcBox,2]
EndIf

Return aCombo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³Getx3BOX  ³ Autora³ Cristiane Maeda     ³ Data ³ 04/10/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Mostra campo de acordo com Item selecionado em SeleSx3Box   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³SeleSx3Box                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³Enchoice                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function GetX3Box(cCombo,nSubx,nTamCpo)
Local cItem := "" ,nInitcBox ,aCombo:={}, nTam
Local cAxPr := "Acols[n][" + LTrim(STR(nSubx)) + "]"
Local cCampo := ""

If Len(aCols) > 0 .and. n > 0 .and. n <= Len(aCols)
	cCampo := &(cAxPr)
	aCombo := RetSx3Box(cCombo,@nInitcBox,@nTam,nTamCpo)
	nIniPos := Ascan(aCombo,{|x| cCampo $ x[2]})
	nIniPos := Iif(nIniPos == 0,Len(aCombo),nIniPos)
	cCampo := aCombo[nIniPos,3]
EndIf
Return cCampo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ FmtLin() ³ Autor ³ Juan Jose Pereira   ³ Data ³ 04.01.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Formata linha para impressao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION FmtLin(aValores,cFundo,cPictN,cPictC,nLin,lImprime,bCabec,nTamLin)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis da funcao                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local cConteudo:='', cLetra:=''
Local nPos:=0, i:=0, j:=0
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Sets para a Funcao, mudar se necessario               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local cPictNPad:='@E 999,999,999.99'
Local cPictCPad:='@!'
Local cCharOld  :='#'
Local cCharBusca:='±'
Local cTipoFundo:=ValType(cFundo)
Local nFor:=1
Local aArea := GetArea()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Troca # por cCharBusca pois existem dados com # que devem    ³
//³ ser impressos corretamente.                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cTipoFundo == "C"
	cFundo:=StrTran(cFundo,cCharOld,cCharBusca)
ElseIf cTipoFundo == "A"
	For i:=1 to Len(cFundo)
		cFundo[i]:=StrTran(cFundo[i],cCharOld,cCharBusca)
	Next i
EndIf

aValores:=Iif(Empty(aValores),{},aValores)
aValores:=Iif(cTipoFundo=="C",aValores,{})
lImprime:=Iif(lImprime==NIL,.t.,lImprime)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Substitue o caracter cCharBusca por "_" nas strings          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nFor:=1 To Len(aValores)
	If ValType(aValores[nFor])=="C"
		If At(cCharBusca,aValores[nFor]) > 0
			aValores[nFor]:=StrTran(aValores[nFor],cCharBusca,"_")
		EndIf
	EndIf
Next
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Efetua quebra de pagina com impressao de cabecalho        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If bCabec!=NIL .and. nLin>55
	nTamLin:=Iif(nTamLin==NIL,220,nTamLin)
	@ nLin++,00 PSAY "+"+Replic("-",nTamLin-2)+"+"
	Eval(bCabec)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Rotina de substituicao                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For i:=1 to Len(aValores)
	If ValType(aValores[i])=='A'
		If !Empty(aValores[i,2])
			cConteudo:=Transform(aValores[i,1],aValores[i,2])
		Else
			If Type(aValores[i,1])=='N'
				cConteudo:=Str(aValores[i,1])
			Else
				cConteudo:=aValores[i,1]
			EndIf
		EndIf
	Else
		cPictN:=Iif(Empty(cPictN),cPictNPad,cPictN)
		cPictC:=Iif(Empty(cPictC),cPictCPad,cPictC)
		aValores[i]:=Iif(aValores[i]==NIL,"",aValores[i])
		If ValType(aValores[i])=='N'
			cConteudo:=Transform(aValores[i],cPictN)
		Else
			cConteudo:=Transform(aValores[i],cPictC)
		EndIf
	EndIf
	nPos:=0
	cFormato:=""
	nPos:=At(cCharBusca,cFundo)
	If nPos>0
		cLetra:=cCharBusca
		j:=nPos
		While cLetra==cCharBusca
			cLetra:=Substr(cFundo,j,1)
			If cLetra==cCharBusca
				cFormato+=cLetra
			EndIf
			j++
		End
		If Len(cFormato)>Len(cConteudo)
			If ValType(aValores[i]) <> 'N'
				cConteudo+=Space(Len(cFormato)-Len(cConteudo))
			Else
				cConteudo := Space(Len(cFormato)-Len(cConteudo))+ cConteudo
			EndIf
		Endif
		cFundo:=Stuff(cFundo,nPos,Len(cConteudo),cConteudo)
	EndIf
Next
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Imprime linha formatada                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lImprime
	If cTipoFundo=="C"
		@ nLin++,00 PSAY cFundo
	Else
		For i:=1 to Len(cFundo)
			@ nLin++,00 PSAY cFundo[i]
		Next
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Devolve array de dados com mesmo tamanho mas vazio        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aValores)>0
	aValores:=Array(Len(aValores))
EndIf
RestArea(aArea)
RETURN (cFundo)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Fim da Funcao                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ Interrupcao()  ³ Autor ³ Juan Jose Pereira ³ Data ³07/02/96³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Avalia se houve interrupcao pelo usuario             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION Interrupcao(lEnd)

Local lRet:=.f.


SysRefresh()
If lEnd
	lRet:=.t.
EndIf

If lRet
	@ 00, 00 PSAY OemToAnsi(STR0020) //'INTERROMPIDO PELO USUARIO...'
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ GetPorta ³ Autor ³ Wagner Xavier       ³ Data ³ 06.06.94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ VerIfica qual a porta sera utilizada para um perIferico.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ SigaLoja                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetPorta( cPerIferico )
Local nPorta
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ COM1 = 0      ³
//³ COM2 = 1      ³
//³ COM3 = 2      ³
//³ COM4 = 3      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPerIferico == "C"      //Cupom
	nPorta := Val(SubStr(GetMv("MV_PORTCUP"),4,1))-1
ElseIf cPerIferico == "F"      //Fiscal
	nPorta := Val(SubStr(GetMv("MV_PORTFIS"),4,1))-1
ElseIf cPerIferico == "H"  //Cheque
	nPorta := Val(SubStr(GetMv("MV_PORTCHEQ"),4,1))-1
ElseIf cPerIferico == "G"  //Gaveta
	nPorta := Val(SubStr(GetMv("MV_PORTGAV"),4,1))-1
End
Return nPorta

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³CloseOpen()   ³ Autor ³ Gilson Nascimento ³ Data ³27/12/96³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fechar e Abrir uma lista de Arquivos.                ³±±
±±³Expressao ³ CloseOpen(aExpr1,aExpr2)                       ³±±
±±³      ³ aExpr1 = Array com os alias a serem fechados.          ³±±
±±³      ³ aExpr2 = Array com os alias a serem abertos.           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CloseOpen(aArqF,aArqA)
Local nxz:=0,lRet:=.F.,cOldAlias:=ALIAS()
If Len(aArqF) > 0
	For nxz:=1 to Len(aArqF)
		If Select(aArqF[nxz]) > 0
			DbSelectArea(aArqF[nxz])
			dbCloseArea()
		EndIf
	Next nxz
EndIf
If Len(aArqA) > 0
	For nxz:=1 to Len(aArqA)
		If !ChkFile(aArqA[nxz],.F.)
			HELP(" ",1,"ArqEmUso",,aArqA[nxz],3,4)
			lRet := .T.
		EndIf
	Next nxz
EndIf
DbSelectArea(cOldAlias)
Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³DevZfranca   ³Autor³Juan Jose Pereira   ³ Data ³ 04/03/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³VerIfica se a nota e' de devolucao de vEnda p/ Z.Franca     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function DevZFranca(cCodProd)

Local lRet:=.F.

If cTipo=="D".and.!Empty(SA1->A1_SUFRAMA).and.!SA1->A1_CALCSUF=="N"
	SB1->(DbSeek(xFilial()+cCodProd))
	lRet:=(!SB1->B1_IMPZFRC=="S")
EndIf

Return (lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ PutMvPar     ³Autor ³ Alexander Santos     ³Data³ 03/03/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza o conteudo do parametro no sx6 e na matriz __GetMV³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PutMvPar( cVar , xValor, cFilx)
	LOCAL nX 		:= 1
	if __findSGetMvCache
		_sputParCache( cVar , xValor, cFilx)
	else
		DEFAULT cFilx 	:= cFilAnt
		DEFAULT __GetMV	:= {}
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o conteudo do parametro no sx6									|
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If PutMv(cVar,xValor) .And. Len(__GetMv) > 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza matriz static usada na supergetmv e getnewpar					|
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( nX := aScan( __GetMv , { |x| x[1] == cFilx .And. x[2] == cVar } ) ) > 0
				__GetMv[nX,3] := xValor
			EndIF
		EndIf
	endif
Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GetNewPar    ³Autor ³ Wagner Xavier        ³Data³ 01/10/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Le um parametro ou assume um valor default (cRet)          ³±±
±±³          ³ Pode ser utlizado para ler um determinado parametro ou     ³±±
±±³          ³ assumir um valor preferencial quando da n„o existˆncia do  ³±±
±±³          ³ parametro em quest„o.                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetNewPar( cVar , cRet , cFil )
Return( SuperGetMv( cVar , .F. , cRet , cFil ) )
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³SuperGetMV³ Rev.  ³ Eduardo Riera         ³ Data ³29.03.2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de pesquisa dos parametros (SX6) com Cache           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpX1: Retorna o conteudo do parametro                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Nome de parametro a ser pesquisado                   ³±±
±±³          ³ExpL2: Indica se o help deve ser demonstrado                ³±±
±±³          ³ExpC3: Default do parametro caso nao exista                 ³±±
±±³          ³ExpC4: Filial para Pesquisa do Parametro                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function SuperGetMv( cParametro , lHelp , cDefault , cFil )

Local cSvFilAnt		:= cFilAnt
Local xResultado	:= NIL
Local nX			:= 0.00
if __findSGetMvCache	
	IF PCount() == 0.00
		_sgetmvreset()
	else
		xResultado := _GetMvCached( cParametro , lHelp , cDefault , cFil )
	endif
else
	IF PCount() == 0.00

		__GetMV := NIL

	Else

		DEFAULT __GetMV		:= {}
		DEFAULT cFil		:= cFilAnt

		cFilAnt	:= cFil

		nX := aScan( __GetMv , { |x| x[1] == cFilAnt .And. x[2] == cParametro } )
		IF nX > 0
			xResultado := __GetMv[ nX , 3 ]
		Else
			xResultado := GetMv( cParametro , lHelp , cDefault )
			aAdd( __GetMv , { cFilAnt , cParametro , xResultado } )
		EndIF

		cFilAnt := cSvFilAnt

	EndIF
Endif
Return( xResultado )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³RstMvBuff ³ Rev.  ³ Eduardo Riera         ³ Data ³29.03.2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Reset do cache do SX6                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function RstMvBuff()
if __findSx3Cache 	
	_sgtsx3reset()
endif
if __findSGetMvCache
	_sgetmvreset()
endif
if __findTamSx3Cache
	_etamsx3reset()
endif
__GetMv 	:= {}
__SX3Cache  := {}
__nXSX3Cache:= 0
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Limpa o cache da tabela de precos                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF FindFunction( "MARELETABPRC" )
	MaReleTabPrc()
EndIF

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Limpa o cache das regras de desconto                         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF FindFunction( "MARELERDES" )
	MaReleRDes()
EndIF

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³  Limpa o cache do Cadastro de Verbas do Modulo SIGAGPE        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF FindFunction( "CLEARSTATIC" )
	ClearStatic()
EndIf

Return( NIL )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³ RDSelect() ³ Autor ³ Jose Lucas          ³ Data ³ 25/05/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Simular markbrowse a ser ultizado via chamada no Rdmake,   ³±±
±±³          ³ desvinculado das op‡oes do array aRotina.                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ nOpcao:=RDSelect(cAlias,cCpoMark,cCpoCond,aCampos,cTitle,  ³±±
±±³          ³         cMsg,cFilter,lInverte)                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias   := Alias do arquivo utilizado no RDMarkBrow.      ³±±
±±³          ³ cCpoMark := Campo de controle ex: E1_OK.                   ³±±
±±³          ³ cCpoCond := Condicao CamposObjeto RDMarkBrowse.            ³±±
±±³          ³ aCampos  := Array contEndo as campos/colunas de Edicao ou  ³±±
±±³          ³             Visualizacao.                                  ³±±
±±³          ³ cTitle   := Titulo a ser impressp na janela de Dialogo     ³±±
±±³          ³ cFilter  := Expressao de filtro para selecao dos regitros  ³±±
±±³          ³ cMarca   := cMarca ( cMarca:=GetMark() ).                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ nOpcao == 1 Confirma a selecao ou 2 Abandona selecao       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso     ³ RDMakes.                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function RDSelect(cAlias,cCpoMark,cCpoCond,aCampos,cTitle,cMsg,cFilter,cMarca,lInverte,aCoordIn,aCoordExt,cRDM,aButtons)
Local nRec
Local oDlgMark, nOpca
Local oValor  := 0
Local cCpoFilial := Subs(cAlias,2,2)+"_FILIAL"
Private cMarcaRDM:= Iif(ValType(cMarca) == Nil,"",cMarca)
Private nValorSel:= 0

DEFAULT aButtons := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega os valores por default se nao for pasados os parametr³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If ValType(aCoordIn)=="U"
	aCoordIn:={34,1,132,315}
EndIf
If ValType(aCoordExt)=="U"
	aCoordExt:={9,0,28,80}
EndIf
DbSelectArea(cAlias)
If cAlias != "TRB"
	bWhile := { || xFilial( cAlias ) == &(cCpoFilial) }
	DbSeek(xFilial( cAlias ) )
Else
	bWhile := { || ! Eof() }
	DbGoTop()
EndIf

nOpca :=0
DbGoTop()
DEFINE MSDIALOG oDlgMark TITLE OemToAnsi(cTitle) From aCoordExt[1],aCoordExt[2] To aCoordExt[3],aCoordExt[4]

@ 1.4,.8 Say OemToAnsi(cMsg)
If ValType(cRDM)#"U" .and. ExistBlock(cRDM)
	@2.1,.8 Say   OemToAnsi(STR0041)    // "Valor Selecionado "
  	@2.1,10 Say oValor VAR nValorSel Picture "@E 999,999,999,999.99"  //Valid Execute(ExecBlock('pepe',.f.,.f.))
EndIf
oMark := MsSelect():New(cAlias,cCpoMark,cCpoCond,aCampos,@lInverte,@cMarca,aCoordIn)
If ValType(cRDM)=="U"
	oMark:bMark := {|| RdMark(cAlias, oMark, cMarca, cCpoMark, lInverte)}
ElseIf ExistBlock(cRDM)
	oMark:bMark := {|| RdMark(cAlias, oMark, cMarca, cCpoMark, lInverte),nValorSel:=ExecBlock(cRDM,.f.,.f.),oValor:Refresh()}
EndIf
oMark:oBrowse:lhasMark = .T.
oMark:oBrowse:lCanAllmark := .T.
If ValType(cRDM)#"U"  .and. ExistBlock(cRDM)
	oMark:oBrowse:bAllMark := {|| nValorSel:=ExecBlock(cRDM,.f.,.f.),oValor:Refresh(),oMark:oBrowse:Refresh(.t.)}
Else
	oMark:oBrowse:bAllMark := {|| RdMarkAll(cAlias, oMark, cMarca, cCpoMark)}
EndIf

ACTIVATE MSDIALOG oDlgMark CENTERED ON INIT;  //LUCAS 31/07/99 MARISOL
	EnchoiceBar(oDlgMark,;
	{ || nOpca:=1, If(RdConf(),oDlgMark:End(),Nil ) },;
	{ || nOpca:=0, oDlgMark:End()},Nil, aButtons)

Return( nOpca )


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³ RDMark   ³ Autor ³ Jose Lucas          ³ Data ³ 20/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Marcar e Desmarcar regitros do MarkBrowse.                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ bMark := {|| RdMarkAll(cAlias, oMark, cMarca, cCpoMark)}   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias := Alias do arquivo utilizado no RDMarkBrowse.      ³±±
±±³          ³ oMark  := Objeto RDMarkBrowse.                             ³±±
±±³          ³ cMarca := cMarca ( cMarca:=GetMark() ).                    ³±±
±±³          ³ cCpoMark := Campo de controle ex: E1_OK.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ oMark:oBrowse:bMark                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ RDSelect()                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function RDMark( cAlias, oMark, cMarca, cCpoMark, lInverte )

If IsMark(cCpoMark,cMarca,lInverte)
	Reclock( cAlias,.F.)
	If !lInverte
		Replace &(cCpoMark) With cMarca
	Else
		Replace &(cCpoMark) With "  "
	EndIf
	MsUnlock()
Else
	Reclock( cAlias,.F.)
	If !lInverte
		Replace &(cCpoMark) With "  "
	Else
		Replace &(cCpoMark) With cMarca
	EndIf
	MsUnlock()
EndIf
oMark:oBrowse:Refresh()
Return( .T. )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³ RDMarkAll³ Autor ³ Jose Lucas          ³ Data ³ 20/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inverter a marca para todos regitros marcados/desmarcados. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ bAllMark:={|| RdMarkAll(cAlias, oMark, cMarca, cCpoMark)}  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias := Alias do arquivo utilizado no RDMarkBrow.        ³±±
±±³          ³ oMark  := Objeto RDMarkBrowse.                             ³±±
±±³          ³ cMarca := cMarca ( cMarca:=GetMark() ).                    ³±±
±±³          ³ cCpoMark := Campo de controle ex: E1_OK.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ oMark:oBrowse:bAllMark                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ RDSelect()                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function RDMarkAll( cAlias, oMark, cMarca, cCpoMark )
Local nRecno:=Recno()

DbSelectArea( cAlias )
DbGoTop()
Do While !Eof()
	RecLock(cAlias,.F.)
	If Empty(&(cCpoMark))
		Replace &(cCpoMark) With cMarca
	Else
		Replace &(cCpoMark) With "  "
	EndIf
	MsUnlock()
	DbSkip()
End
DbGoTo(nRecno)
oMark:oBrowse:Refresh()
Return( .T. )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³ RDListBox³ Autor ³ Jose Lucas          ³ Data ³ 20/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fazer um LISTBOX/TWBROWSE para rotinas disparadas por arq. ³±±
±±³          ³ RDMAKES.                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ oLbx := RDListBox(nRow,nCol,nWidth,nHeight,aArray,aCab,;   ³±±
±±³          ³                    aColunas,aPicture,lEdit)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nRow,nCol := Coordenadas para o ListBox ( Linha,coluna )   ³±±
±±³          ³ nWidth := Comprimento em pixel do ListBox                  ³±±
±±³          ³ nHeight := Altura em pixel do ListBox                      ³±±
±±³          ³ aArray := Array contEndo as colunas de Edicao/Visualizacao.³±±
±±³          ³ aCab := Array contEndo os cabecalhos para as colunas.      ³±±
±±³          ³ aPicture := Array contEndo as pictures para as colunas.    ³±±
±±³          ³ lEdit := Determina se as colunas serao editadas ou nao.    ³±±
±±³          ³ lPixel := Considera as coordenadas passadas em pixels (.T.)³±±
±±³          ³           ou caracteres (.F.).                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ oLbx := Objeto do ListBox.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ RDMakes                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function RDListBox( nRow,nCol,nWidth,nHeigh,aArray,aCab,aColunas,aPicture,lEdit,bDblClk,lPixel )
Local oLbx
Default lPixel := .F.
lEdit    := Iif( lEdit==NIL,.F.,lEdit )
aColunas  := Iif(aColunas==NIL,{},aColunas)

oLbx := TWBrowse():New( nRow, nCol, nWidth, nHeigh,,aCab,aColunas,,,,,,,,,,,,, .F.,,lPixel,, .F.,,, )
oLbx:SetArray(aArray)
oLbx:bLine:={ || RDbLine(oLbx,aArray,aCab,aPicture) }
If bDblClk # Nil
	oLbx:blDblClick :=      bDblClk
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Estar  Disponivel somente na versao 4.07                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lEdit
	//oLbx:lAutoEdit:=.T.
EndIf
Return( oLbx )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ RDbLine     ³ Autor ³ Jos‚ Lucas         ³ Data ³ 17/05/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retornar um array para Codigo Block do Methodo bLine do    ³±±
±±³          ³ LISTBOX (TWBrowse).                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ aLine := RDbLine( oLbx,aArray,aCab,aPicture )              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ oLbx := Objeto correspondente ao LISTBOX/TWBROWSE.         ³±±
±±³          ³ aArray:= Array contEndo os campos de Edicao/Visualizacao.  ³±±
±±³          ³ aCab  := Array contEndo os cabecalhos para os campos.      ³±±
±±³          ³ aPicture := Array contEndo as pictures para os campos.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aLine := Array para tratamento pelo methodo bLine.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ RdListBox()                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function RDbLine(oLbx,aArray,aCab,aPicture)
Local nI:=0, aLine:={}

aPicture  := Iif(aPicture==NIL,{},aPicture)

For nI := 1 To Len(aCab)
	If Len(aPicture) > 0
		Do Case
		Case ValType(aArray[oLbx:nAt,nI])=="N"
			AAdd( aLine,Transform(aArray[oLbx:nAt,nI],aPicture[nI]) )
		Case ValType(aArray[oLbx:nAt,nI])=="D"
			AAdd( aLine,Dtoc(aArray[oLbx:nAt,nI]) )
		Otherwise
			AAdd( aLine,aArray[oLbx:nAt,nI] )
		EndCase
	Else
		AAdd( aLine,aArray[oLbx:nAt,nI] )
	EndIf
Next nI
Return( aLine )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MsOpenPort³ Autor ³ Wilson                ³ Data ³ 05/12/96 ³±±
±±³          ³          ³ Autor ³ Alan Candido(1)       ³ Data ³ 26/03/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Abre a porta de comunicacao com as Impressoras de Cheque   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ P1 - Handle da porta                                       ³±±
±±³          ³ P2 - Parametros de inicializacao, no formato               ³±±
±±³          ³      COMn, baud, parity, data, stop                        ³±±
±±³          ³      Caso um parametro seja omitido sera assumido o padrao ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±³          ³ (1) Adequa‡Æo de uso as novas DLL de 16 e 32 bits          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
#define DEFAULT_VALUE  -1

Static function BeginMSSer()
return 77 // simula a inicialização da DLL

Static function EndMSSer()
return 0 // simula a finalização da DLL

Static function MSOpen()
return (ExecInClient(EIC_SER_OPEN, {})[1] = "0")

Static function MSClose()
return (ExecInClient(EIC_SER_CLOSE, {})[1] = "0")

Static function MSOpened()
return val(ExecInClient(EIC_SER_OPENED, {})[1])

Static function MSGetLineStatus()
return val(ExecInClient(EIC_SER_GETLINESTATUS, {})[1])

Static function MSIsPolling()
return val(ExecInClient(EIC_SER_ISPOLLING, {})[1])

Static function MSPausePolling()
return val(ExecInClient(EIC_SER_PAUSEPOLLING, {})[1])

Static function MSContinuePolling()
return val(ExecInClient(EIC_SER_CONTINUEPOLLING, {})[1])

Static function MSCountRX()
return val(ExecInClient(EIC_SER_COUNTRX, {})[1])

Static function MSOutFreeSpace()
return val(ExecInClient(EIC_SER_OUTFREESPACE, {})[1])

Static function MSSEndData(ABuffer, ASize)
return val(ExecInClient(EIC_SER_SENDDATA, {ABuffer, str(ASize)})[1])

Static function MSGetPort()
return val(ExecInClient(EIC_SER_GETPORT, {})[1])

Static function MSGetBaud()
return val(ExecInClient(EIC_SER_GETBAUDRATE, {})[1])

Static function MSGetBaudValue()
return val(ExecInClient(EIC_SER_GETBAUDRATEVALUE, {})[1])

Static function MSGetDataBits ()
return val(ExecInClient(EIC_SER_GETDATABITS, {})[1])

Static function MSGetStopBits ()
return val(ExecInClient(EIC_SER_GETSTOPBITS, {})[1])

Static function MSGetParity()
return val(ExecInClient(EIC_SER_GETPARITY, {})[1])

Static function MSGetHwFlow()
return val(ExecInClient(EIC_SER_GETHWFLOW, {})[1])

Static function MSGetSwFlow()
return val(ExecInClient(EIC_SER_GETSWFLOW, {})[1])

Static function MSGetInBufSize()
return val(ExecInClient(EIC_SER_GETINBUFSIZE, {})[1])

Static function MSGetOutBufSize()
return val(ExecInClient(EIC_SER_GETOUTBUFSIZE, {})[1])

Static function MSGetPacketSize()
return val(ExecInClient(EIC_SER_GETPACKETSIZE, {})[1])

Static function MSGetPakTimeout()
return val(ExecInClient(EIC_SER_GETPACKETTIMEOUT, {})[1])

Static function MSGetPakMode()
return val(ExecInClient(EIC_SER_GETPACKETMODE, {})[1])

Static function MSGetPollingDelay()
return val(ExecInClient(EIC_SER_GETPOLLINGDELAY, {})[1])

Static function MSGetEnableDTROnOpen ()
return val(ExecInClient(EIC_SER_GETENABLEDTRONOPEN, {})[1])

Static function MSGetOutTO()
return val(ExecInClient(EIC_SER_GETOUTPUTTIMEOUT, {})[1])

Static function MSGetInpTO()
return val(ExecInClient(EIC_SER_GETINPUTTIMEOUT, {})[1])

Static function MSGetCheckLineStatus ()
return val(ExecInClient(EIC_SER_GETCHECKLINESTATUS, {})[1])

Static function MSToggleDTR(OnOff)
Local nRet
If OnOff
	nRet = val(ExecInCliente(EIC_SER_TOGGLEDTR, {'1'})[1])
Else
	nRet = val(ExecInCliente(EIC_SER_TOGGLEDTR, {'0'})[1])
EndIf
return nRet

Static function MSToggleRTS(OnOff)
Local nRet
If OnOff
	nRet = val(ExecInCliente(EIC_SER_TOGGLERTS, {'1'})[1])
Else
	nRet = val(ExecInCliente(EIC_SER_TOGGLERTS, {'0'})[1])
EndIf
return nRet

Static function MSSetPort(APortNumber) // use as constantes de MSSerial.ch //
return val(ExecInClient(EIC_SER_SETPORT, {str(APortNumber)})[1])

Static function MSSetBaudRate (ABaudRate) // use as constantes de MSSerial.ch
return val(ExecInClient(EIC_SER_SETBAUDRATE, {str(ABaudRate)})[1])

Static function MSSetBaudValue(ABaudRateValue)
return val(ExecInClient(EIC_SER_SETBAUDRATEVALUE, {str(ABaudRateValue)})[1])

Static function MSSetDataBits (ADataBits) // use as constantes de MSSerial.ch
return val(ExecInClient(EIC_SER_SETDATABITS, {str(ADataBits)})[1])

Static function MSSetStopBits (AStopBit)  // use as constantes de MSSerial.ch
return val(ExecInClient(EIC_SER_SETSTOPBITS, {str(AStopBit)})[1])

Static function MSSetParity(AParity)  // use as constantes de MSSerial.ch
return val(ExecInClient(EIC_SER_SETPARITY, { str(AParity) })[1])

Static function MSSetHwFlow(AHwFlow) // use as constantes de MSSerial.ch
return val(ExecInClient(EIC_SER_SETHWFLOW, {str(AHwFlow)})[1])

Static function MSSetSwFlow(ASwFlow) // use as constantes de MSSerial.ch
return val(ExecInClient(EIC_SER_SETSWFLOW, {str(ASwFlow)})[1])

Static function MSSetInBufSize(ABufferSize)
return val(ExecInClient(EIC_SER_SETINBUFSIZE, {str(ABufferSize)})[1])

Static function MSSetOutBufSize(ABufferSize)
return val(ExecInClient(EIC_SER_SETOUTBUFSIZE, {str(ABufferSize)})[1])

Static function MSSetPackSize(APackSize)
return val(ExecInClient(EIC_SER_SETPACKETSIZE, {str(APackSize)})[1])

Static function MSSetPackTimeout(ATimeout) // em milisegundos
return val(ExecInClient(EIC_SER_SETPACKETTIMEOUT, {str(ATimeOut)})[1])

Static function MSSetPackMode(APackMode) // use as constantes de MSSerial.ch
return val(ExecInClient(EIC_SER_SETPACKETMODE, {str(APackMode)})[1])

Static function MSSetPollingDelay(ADelay) // em milisegundos
return val(ExecInClient(EIC_SER_SETPOLLINGDELAY, {str(aPar1)})[1])

Static function MSSetEnableDTROnOpen (onOff)
Local nRet
If OnOff
	nRet = val(ExecInCliente(EIC_SER_SETENABLEDTRONOPEN, {'1'})[1])
Else
	nRet = val(ExecInCliente(EIC_SER_SETENABLEDTRONOPEN, {'0'})[1])
EndIf
return nRet

Static function MSSetOutTO(ATimeout) // em milisegundos
return val(ExecInClient(EIC_SER_SETOUTPUTTIMEOUT, {str(ATimeOut)})[1])

Static function MSSetInpTO(ATimeout) // em milisegundos
return val(ExecInClient(EIC_SER_SETINPUTTIMEOUT, {str(ATimeOut)})[1])

Static function MSSetCheckLineStatus (ALineStatus)
return val(ExecInClient(EIC_SER_SETCHECKLINESTATUS, {str(ALineStatus)})[1])

Static function MSSEndByte(AByte)
return val(ExecInClient(EIC_SER_SENDBYTE, { substr(AByte,1,1) })[1])

Static function MSSetPortName (APortName)
return val(ExecInClient(EIC_SER_SETPORTNAME, { APortName })[1])

Static function MSGetPortName (APortName)
Local aResult := ExecInClient(EIC_SER_GETPORTNAME, { })
APortName := aResult[2]
return val(aResult[1])

Static function MSSEndChar(AChar)
return val(ExecInClient(EIC_SER_SENDCHAR, { Subs(AChar,1,1) })[1])

Static function MSSEndStr(AString)
return val(ExecInClient(EIC_SER_SENDSTR, { AString })[1])

Static function MSReadBuffer(ABuffer, ASizeBuffer)
Local aResult := ExecInClient(EIC_SER_READBUFFER, { })
ABuffer := aResult[2]
return val(aResult[1])

Static function MSReadByte(AByte)
Local aResult := ExecInClient(EIC_SER_READBYTE, { })
If len(aResult) <> 2
	AByte := ''
Else
	AByte := aResult[2]
EndIf
return val(aResult[1])

Static function MSReadChar(AChar)
Local aResult := ExecInClient(EIC_SER_READCHAR, { })
aPar1 := aResult[2]
return val(aResult[1])

Static function MSFlushBuffers(OnOffBufIn, OnOffBufOut)
Local cBufIn := Iif(OnOffBufIn, "1", "0")
Local cBufOut := Iif(OnOffBufOut, "1", "0")

return val(ExecInClient(EIC_SER_FLUSHBUFFERS, { cBufIn, cBufOut })[1])

Static function MSSEndDtEx(ABuffer, ASize, ATimeout)
return val(ExecInClient(EIC_SER_SENDDATAEX, { ABuffer, str(ASize), str(ATimeout) })[1])

Static function MSReadData(ABuffer, ASize)
Local aResult := ExecInClient(EIC_SER_READDATA, { })
ABuffer := aResult[2]
ASize := val(aResult[1])
return ASize

Static function MSSEndWait(ABuffer, ATime) // em milisegundos
return val(ExecInClient(EIC_SER_SENDWAIT, { ABuffer, str(ATime) })[1])


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MsOpenPort³ Autor ³ Wilson                ³ Data ³ 05/12/96 ³±±
±±³          ³          ³ Autor ³ Alan Candido(1)       ³ Data ³ 26/03/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Abre a porta de comunicacao com as Impressoras de Cheque   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ P1 - Handle da porta                                       ³±±
±±³          ³ P2 - Parametros de inicializacao, no formato               ³±±
±±³          ³      COMn, baud, parity, data, stop                        ³±±
±±³          ³      Caso um parametro seja omitido sera assumido o padrao ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±³          ³ (1) Adequa‡Æo de uso as novas DLL de 16 e 32 bits          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
#define DEFAULT_VALUE  -1

function MsOpenPort(hPort, cParam, lModem)
Local ;
	cPort   := "",;
	nBaud   := DEFAULT_VALUE,;
	nParity := DEFAULT_VALUE,;
	nData   := DEFAULT_VALUE,;
	nStop   := DEFAULT_VALUE,;
	nPos    := 0, ;
	cAux    := ""

DEFAULT ISLOADDLL := 0
DEFAULT PORT_OLD := 0

cAux := Trim(cParam)

// VerIfica se a DLL já foi inicializada

If (ISLOADDLL = 0)
	nRet := BeginMSSer()
	If nRet < 0
		MsgStop("BeginMSSer: Initialization error " + str(nRet))
		return (.F.)
	EndIf
EndIf

// Determina qual a porta        // sintaxe PORTA:VELOC,PARIDADE,TAM,BIT
nPos := at(":", cAux)  //‚ ":" e nao ","
If nPos <> 0
	cPort := substr(cAux, 1, nPos - 1)

	cAux := Trim(substr(cAux, nPos + 1))
	// Determina a velocidade de conexao
	nPos := at(",", cAux)
	If nPos <> 0
		nBaud := val(substr(cAux, 1, nPos - 1))

		cAux := Trim(substr(cAux, nPos + 1))
		// Determina a paridade
		nPos := at(",", cAux)
		If nPos <> 0
			nParity := VAL(substr(cAux, 1, nPos-1))

			cAux := Trim(substr(cAux, nPos + 1))
			// Determina tamanho dos dados
			nPos := at(",", cAux)
			If nPos <> 0
				nData := VAL(substr(cAux, 1, nPos-1))

				cAux := Trim(substr(cAux, nPos + 1))
				// Determina bit de paridade
				nPos := at(",", cAux)
				If nPos == 0
					nStop := VAL(substr(cAux, 1, Len(cAux)))
				EndIf
			EndIf
		EndIf
	EndIf
Else
	cPort := cAux
EndIf

// Seta os parametros da porta
If at(":", cPort) = 0
	cPort := cPort + ':'
EndIf

If MSSetPortName(cPort) < 0
	MsgStop("MSSetPortName: Invalid port name " + cParam)
	return(.F.)
EndIf

If nBaud <> DEFAULT_VALUE
	If MSSetBaudValue(nBaud) < 0
		MsgStop("MSSetBaudValue: Invalid baud value " + cParam)
		Return(.F.)
	EndIf
EndIf

If nParity <> DEFAULT_VALUE
	If MSSetParity(nParity) < 0
		MsgStop("MSSetParity: Invalid parity value " + cParam)
		return (.F.)
	EndIf
EndIf

If nData <> DEFAULT_VALUE
	If MSSetDataBits(nData) < 0
		MsgStop("MSSetDataBits: Invalid data bit value " + cParam)
		Return(.F.)
	EndIf
EndIf

If nStop <> DEFAULT_VALUE
	If nStop = 1
		nStop = 0
	ElseIf nStop = 1.2
		nStop = 1
	Else
		nStop = 2
	End

	If MSSetStopBits(nStop) < 0
		MsgStop("MSSetStopBits: Invalid stop bit value " + cParam)
		Return(.F.)
	EndIf
EndIf

// Abre a porta

If .not. MSOpen()
	return(.F.)
EndIf

hPort := val(left(right(cPort,2),1))

PORT_OLD := hPort
ISLOADDLL++

// VerIfica se eh uma porta valida - se for um MODEM
If lModem <> NIL
	cResult := MSGetAnswer(hPort, "ATZ"+chr(13), 30)

	If cResult  == ""  // nao eh um modem
		MsClosePort(hPort)
		hPort := 0
		PORT_OLD := -1
	Else
		MSGetAnswer(hPort, "ATE"+chr(13), 30) // desliga Echo de modem
	EndIf
EndIf

Return (hPort > 0)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MsClosePor³ Autor ³ Wilson                ³ Data ³ 05/12/96 ³±±
±±³          ³          ³ Autor ³ Alan Candido(1)       ³ Data ³ 26/03/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Fecha a porta de comunicacao com as Impressoras de Cheque  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ P1 - Handle da porta                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±³          ³ (1) Adequa‡Æo de uso as novas DLL de 16 e 32 bits          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MsClosePort(hPort)

If PORT_OLD <> hPort
	MSSetPort(hPort)
	PORT_OLD = hPort
EndIf

If .not. MSClose()
	MsgStop("MSClose: Close error " + str(hPort))
	Return(.F.)
EndIf

// Finaliza a DLL se for o caso
ISLOADDLL--

If ISLOADDLL == 0
	EndMSSer()
EndIf

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MsWrite   ³ Autor ³ Wilson                ³ Data ³ 05/12/96 ³±±
±±³          ³          ³ Autor ³ Alan Candido(1)       ³ Data ³ 26/03/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Envia o Texto a ser impresso                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ P1 - Handle da porta                                       ³±±
±±³          ³ P2 - Texto                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±³          ³ (1) Adequa‡Æo de uso as novas DLL de 16 e 32 bits          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MSWrite(hPort, cText)
Local lResult

If PORT_OLD <> hPort
	MSSetPort(hPort)
	PORT_OLD = hPort
EndIf
lResult := MSSEndStr(cText)
return(lResult)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MsRead    ³ Autor ³ Alan Candido          ³ Data ³ 26/03/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Le dados da porta serial                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ P1 - Handle da porta                                       ³±±
±±³          ³ P2 - Texto (passar por referencia)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Le o buffer da porta serial identIficada pelo Handle.      ³±±
±±³          ³ Se a leitura foi bem suscedida, retorna True.              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MSRead(hPort, cText)
Local nResult

If PORT_OLD <> hPort
	MSSetPort(hPort)
	PORT_OLD = hPort
End If

nResult := MSReadBuff(@cText)
Return(.not. (nResult < 0))

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MsGetByte  ³ Autor ³ Alan Candido          ³ Data ³ 13/05/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Le um Byte na porta de comunicacao em (P2) Segundos         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ P1 - Handle da porta                                        ³±±
±±³          ³ P2 - Tempo de TimeOut                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Le um byte da porta serial retornando-o caso haja time-out  ³±±
±±³          ³ será retornado chr(0)                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MSGetByte(hPort, nTempo)
Local nTimeout, cByte

If PORT_OLD <> hPort
	MSSetPort(hPort)
	PORT_OLD = hPort
End If

nTimeout := MSGetInpTO()
If MSSetInpTO(nTempo * 1000) < 0
	msgStop("MSGetByte: Error in MSSetTimeOut")
	cByte := " "
Else
	cByte := " "
	If MSReadByte(@cByte) < 1
		cByte := ""
	Else
		cByte := substr(cByte,1,1)
	EndIf
	MSSetInpTO(nTimeout)
EndIf

return (cByte)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MSGetAnswer³ Autor ³ Alan Candido          ³ Data ³ 13/05/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Lˆ uma String na porta de comunicacao em (P3) Segundos      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ P1 - DLL                                                    ³±±
±±³          ³ P2 - Strings de palavras + CHR(13), separado por (;)        ³±±
±±³          ³ P3 - Tempo de TimeOut                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MSGetAnswer(hPort, cStrs, nTempo)
Local cResult;

If PORT_OLD <> hPort
	MSSetPort(hPort)
	PORT_OLD = hPort
End If
cResult := ""
MsClearBuffer(hPort)
MSSEndStr(cStrs)
nSec := seconds() + nTempo

While .T.
	If (seconds() > nSec)
		exit
	End If

	sysRefresh()

	MSRead(hPort, @cResult)

	If !(cResult == "")
		exit
	End If
End


Return (cResult)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MsClearBuffer³ Autor ³ Wilson/Pedro Hiroshi ³ Data ³ 17/03/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Limpa o Buffer da porta de comunicacao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ P1 - DLL                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MsClearBuffer(hPort)
While (MsGetByte(hPort, 1) != "");End
Return Nil



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³ RdConf() ³ Autor ³ Jose Lucas            ³ Data ³31.08.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Mensagem de confirmacao antes de executar o processamento  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ RdSelect()														        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RdConf()	// LUCAS 31/07/99 MARISOL ARGENTINA
Local lRet:=.T.
Local lNoSel:=.F.
Local nRecTmp
If cPaisLoc="EQU" .and. FunName()=="FINA096"
	nRecTmp :=TMP089->(Recno())
   TMP089->(DbGoTop())
	While !TMP089->(EOF())
		If TMP089->E1_OK == cMarcaE1
		   lNoSel:=.T.
         If !A096ConSEF((xFilial('SEF')+'R'+TMP089->E1_BCOCHQ+TMP089->E1_AGECHQ+TMP089->E1_CTACHQ+SUBSTR(TMP089->E1_NUM,1,Len(SEF->EF_NUM))+TMP089->E1_PREFIXO),6,nModo)
            lRet:=.F.
            MsgAlert(OemToAnsi(STR0048))  //"¡El Registro fue desmarcado!"
            TMP089->E1_OK := ""
         Endif
      Endif
      TMP089->(DbSkip())
   Enddo
	TMP089->(DbGoTo(nRecTmp))
	If lRet
		If lNoSel
			Return( MsgYesNo(OemToAnsi(STR0030),OemToAnsi(STR0031)) )  //"confirma la generacion","atencion"
		Else
			MsgAlert(OemToAnsi(STR0049))  //"¡No hay items seleccionados!"
			Return(lNoSel)
		Endif
	Else
      Return(lRet)
   Endif
Endif
Return( MsgYesNo(OemToAnsi(STR0030),OemToAnsi(STR0031)) )  //"confirma la generacion","atencion"
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³HeadProva ³ Autor ³ Wagner Xavier         ³ Data ³ 06/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava o Header do arquivo  Contra Prova           		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³HeadProva(cExp1,cExp2,cExp3,cExp5)                  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Lote,Programa,Operador,Arquivo,lCria,aDadosProva            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    	 ³Generico                                    	 	 		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function HeadProva(cLote,cPrograma,cOperador,cArquivo,lCria,aDadosProva)
Local nRetHandle := 65536	// NAO MEXA NESTE NUMERO
Local aRetHead   := {}
LOCAL lConFile   := Existblock("CONFILE")

FINVARCTB()
//
// Elementos de __HeadProva
// [1] Lote cont bil
// [2] Programa
// [3] Operador
// [4] Nome do Arquivo no CProva
// [5] Handle do Arquivo	-5 		Inicializa‡„o
//									-1 		Erro
//									n >= 0 	Arquivo gerado.
//
// Array com dados para utilizacao multi-thread
Default aDadosProva:={}

__HeadProva := {cLote,cPrograma,cOperador,"", -5 }
lCria       := If( lCria = NIL , .f. , lCria )

If !CtbInUse()		// M¢dulo SIGACON

	If lCria
		aRetHead := CriaCProva(cLote,cPrograma,cOperador)
		__HeadProva[4] := aRetHead[1]	// Nome do Arquivo
		cArquivo       := aRetHead[1]	// Nome do Arquivo (X Referˆncia)
		__HeadProva[5] := aRetHead[2]	// Handle do Arquivo
		nRetHandle		:= aRetHead[2] // Handle do Arquivo
		If lConFile
			Execblock("CONFILE",.f.,.f.,{cArquivo,nRetHandle} )
		Endif
	EndIf

Else							// M¢dulo SIGACTB

	IF lCria
		// AQUI! No SIGACTB n„o vai criar cProva ! N„o pode for‡ar cria‡„o
		alert("HeadProva n„o pode for‡ar cria‡„o de Arquivo")
	Endif

Endif

// Array com dados para utilizacao multi-thread
aDadosProva:=ACLONE(__HeadProva)

Return nRetHandle


/**********************************************************
*
* Funcao Chamada pela DetProva em uso pelo SIGACON para cria‡„o do
* arquivo de Lan‡amento no CProva
*/
Static Function CriaCProva(cLote,cPrograma,cOperador,lSimula)

Local cData
Local cProva
Local nTrys:=0, cNum
Local cSet
Local nHdlPrv := -1
Local cArquivo:=""

Default lSimula	:= .F.

cSet := Set(_SET_DATEFORMAT)
Set(_SET_DATEFORMAT,"dd/mm/yyyy")

cData := DTOC(dDataBase)

If ExistBlock("LOTECONT") .And. !lSimula
	cLote := ExecBlock("LOTECONT",.F.,.F.,{cPrograma})
EndIf

cProva   := GetMv("MV_PROVA")
cNum     := GetSX8Num("CPR")

cPrograma := SubStr(cPrograma+Space(8-Len(cPrograma)),1,8)

cArquivo:=cProva+"SP"+cEmpAnt+cNum+".DMG"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria o arquivo de LOG para LA               		  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nHdlPrv:=MSFCREATE(cArquivo,0)

nTrys := 0
DO While nHdlPrv < 0
	nTrys++
	If nTrys > 60
		If MsgYesNo(OemToAnsi(STR0025),OemtoAnsi(STR0026))
			nTrys := 0
			Loop
		Else
			RollBackSX8()
			HELP(" ",1,"HDLNAOGERA")
			Exit
		EndIf
	EndIf
	Inkey(.5)
	nHdlPrv:=MSFCREATE(cArquivo,0)
End

If nHdlPrv >= 0
	FWRITE(nHdlPrv,"00"+cData+cLote+cPrograma+IIf(cOperador == Nil .Or. Empty(cOperador),"Admini",cOperador)+Pad(xFilial("SI2")+Space(12),12)+Space(268)+CHR(13)+CHR(10),312)
	ConfirmSX8()
	Commit
EndIf

Set(_SET_DATEFORMAT,cSet)

Return {cArquivo,nHdlPrv}


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RodaProva ³ Autor ³ Wagner Xavier         ³ Data ³ 06/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava o rodape do arquivo de Contra Prova                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³RodaProva(ExpN1)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Valor Total dos Lancamentos a serem gerados                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function RodaProva(nHdlPrv,nTotal,aDadosProva)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Assume dados de aDadosProva caso os mesmos tenham sido       ³
//³ enviados                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType(aDadosProva) == "A"
	__HeadProva:=ACLONE(aDadosProva)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gravar o TOTAL do Arquivo gerado                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If __HeadPRova[5] >= 0 .and. !CtbInUse()
	fWrite(__HeadProva[5],Str(nTotal,16,2)+Space(292)+"FF"+CHR(13)+CHR(10),312)
	dbCommit()
EndIf

Return .t.
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DetProva  ³Autor  ³ Pilar Sanchez         ³ Data ³           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de contabilizacao das linhas detalhes da tabela de    ³±±
±±³          ³Contra-Prova                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Handle do arquivo de Contra-Prova                     ³±±
±±³          ³ExpC2: Codigo do lancamento padrao                           ³±±
±±³          ³ExpC3: Nome da rotina de origem                              ³±±
±±³          ³ExpC4: Numero do lote de contabilizacao                      ³±±
±±³          ³ExpN5:                                                       ³±±
±±³          ³ExpL6:                                                       ³±±
±±³          ³ExpC7:                                                       ³±±
±±³          ³ExpL8: Indica contabilizacao do rateio do ctas a pagar  (OPC)³±±
±±³          ³ExpC9: Otimizacao da chave de busca do relacionamento   (OPC)³±±
±±³          ³       Se informada evita a pesquisa da chave de integracao  ³±±
±±³          ³       entre as tabelas contabilizadas e a tabela de contabi-³±±
±±³          ³       lizacao                                               ³±±
±±³          ³ExpAA: Otimizacao dos lancamentos padronizados.         (OPC)³±±
±±³          ³       Array conteudo os dados da tabela de regras de contabi³±±
±±³          ³       lizacao na seguinte estrutura:                        ³±±
±±³          ³       [x][y][z]                                             ³±±
±±³          ³       [x] Array com os codigos de lancamento padronizados   ³±±
±±³          ³       [y] Array com as linhas detalhes da tabela de regras  ³±±
±±³          ³           de contabilizacao                                 ³±±
±±³          ³       [z][1] Nome do campo da tabela de regras de contabili-³±±
±±³          ³              zacao ( CT5 ).                                 ³±±
±±³          ³       [z][2] Conteudo do campo da tabela de regras de conta-³±±
±±³          ³              bilizacao ( CT5 ).                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Valor contabilizado                                   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar a tabela de contra-  ³±±
±±³          ³prova com os dados gerados a partir das regras de contabili- ³±±
±±³          ³zacao.                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function DetProva(nHdlPrv,cPadrao,cPrograma,cLote,nLinha,lExecuta,cCriterio,lRateio,	;
					cChaveBusca,aCT5,lPosiciona,aFlagCTB,aTabRecOri,aDadosProva,lSimula,;
					cTabCTK,cTabCT2,cTabCV3,cCtaRec)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas na contabilizacao via CTB               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aArea      := GetArea()
Local cAliasPos	 := Alias()
Local aStruCT5   := CT5->(dbStruct())
Local aStruCTK   := CTK->(dbStruct())
Local aVlrCT5    := {}
Local cAliasCT5  := "CT5"
Local cQuery     := ""
Local cSeqChave  := ""
Local cCampoCTK  := ""
Local cCampoCT5  := ""
Local cValor     := ""
Local cHistorico := ""
Local cHist      := ""
Local cHAglut	 := ""
Local lQuery     := .F.
Local nContador  := 0
Local nValor     := 0
Local nTotal     := 0
Local nPosCtk    := 0
Local nPosCt5    := 0
Local nPLanpad   := 0
Local nPSequen   := 0
Local nPSbLote   := 0
Local nPHist     := 0
Local nPHAglut	 := 0
Local nPTpSald	 := 0
Local nPMoedLC	 := 0
Local nPOrigem	 := 0
Local nPosCtaRec := 0
Local nX         := 0
Local nY         := 0
Local nZ         := 0
Local nLen       := 0
Local nPosDC	 := 0
Local nSaveSX8	:= GetSX8Len()
Local cChaveCTK	 := ""
Local cChaveCT2	 := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas na contabilizacao via SIGACON           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aContas    := Array(30)
Local RetcProva  := {}
Local j          := 0
Local n          := 0
Local cSet       := ""
Local cValor1    := ""
Local cValor2    := ""
Local cValor3    := ""
Local cValor4    := ""
Local cValor5    := ""
Local cNitInt    := ""
Local nPosAFlag  := 0
Local lAchouCTK
Local cTabOrigem := ""
Local nRecOrigem := 0
Local lAS400	 := TcSrvType() == "AS/400"
Local lRedStorn  := cPaisLoc == "RUS" .And. SuperGetMv("MV_REDSTOR",.F.,.F.) // CAZARINI - 05/04/2017 - Parameter to activate Red Storn
Local lPls

Static lCT5TABORI := Nil
Static lCT5RECORI := Nil
Static lCTKTABORI := Nil
Static lCTKRECORI := Nil
Static lCTKRECDES := Nil
Static lCTKRECCV3 := Nil
Static lCTKIDORIG := Nil
Static lCV3TABORI := Nil
Static lCV3RECORI := Nil
Static lCV3RECDES := Nil

Default lPosiciona 	:= .T.
Default lSimula		:= .F.
Default cTabCTK 	:= "CTK"
Default cTabCT2 	:= "CT2"
Default cTabCV3 	:= "CV3"
Default cCtaRec		:= "" //Conta de Receita - Utilizada para o EFD-Contribuicoes

If __cEFDetProva == Nil .Or. !(__cEFDetProva==cEmpAnt+cFilAnt)
	__cEFDetProva := cEmpAnt+cFilAnt
	__MV_PLSATIV := GetNewPar("MV_PLSATIV",.F.)
EndIf

If __MV_PLSATIV <> Nil
	lPls := __MV_PLSATIV
EndIf


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Assume dados de aDadosProva caso os mesmos tenham sido       ³
//³ enviados                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType(aDadosProva) == "A"
	__HeadProva:=ACLONE(aDadosProva)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o arquivo de de contra-prova foi criado correta- ³
//³ mente.                                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If __HeadProva[5] == -1
	Return(0)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa os parametros default's da funcao                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT lRateio	 := .F.
DEFAULT lExecuta := .T.
DEFAULT cCriterio:= Space(8)
DEFAULT nLinha   := 0
DEFAULT aCT5     := {}

PUBLIC LanceiCtb := .F.

If ( __lHasCTKSxe == NIL )
	__lHasCTKSxe := FindFunction('HASCTKSXE')
EndIf

If (__Ct105Ctk == Nil)
	__Ct105CTK := ExistBlock("CT105CTK")
Endif

If __lConOutR == Nil
	__lConOutR := FindFunction("CONOUTR")
EndIf

cPrograma := PadR(AllTrim(UPPER(cPrograma)),10)

If __lConOutR
	ConOutR("*DETPROVAINI*|INICIO DA MONTAGEM DO DETPROVA.|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
EndIf

If lPls
	If "FIN" $ cPrograma
		If __lPLSDETPR == Nil
			__lPLSDETPR := findFunction("PLSDETPR")
		EndIf
	EndIf
EndIf

//Não contabiliza registro do PLS nas ROTINAS do BACKOFFICE
if __lPLSDETPR

	if PLSDETPR( cPadrao, cTabOrigem, cAliasPos, @aFlagCTB )
		Return(0)
	endIf

endIf

If __lCWOInDic == NIL
	__lCWOInDic := Iif(AliasInDic("CWO"), .T., .F.)
Endif
If __lCWOInDic
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Prepara y inicializa las tablas que usará cada punto de asieto³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	POSTABCTB(cPadrao)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica qual o metodo de contabilizacao deve ser feito:     ³
//³ CTB ou CON.                                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !CtbInUse()
	//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	// Fun‡„o de DETALHE no m¢dulo Cont bil - SIGACON
	// Grava‡„o dos Detalhes em Arquivo no Disco (\CPROVA)
	//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	cSet := Set(_SET_DATEFORMAT)
	Set(_SET_DATEFORMAT,"dd/mm/yyyy")
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³               ARQUIVO DE LOG-LANC AUT                   ³
	³               Mem¢ria de Calculos                       ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³                 HEADER DO ARQUIVO                       ³
	³ Descricao       Tamanho     Pos Ini     Pos Fim         ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³ Marca de In¡cio    002       001         002            ³
	³ Data Base          010       003         013            ³
	³ Lote               004       014         018            ³
	³ Programa           008       019         027            ³
	³ Operador           006       028         034            ³
	³ Filial             002       035         037            ³
	³ Filler             278       038         260            ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³                 DETALHE DO ARQUIVO                      ³
	³ Descricao       Tamanho     Pos Ini     Pos Fim         ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³ Tipo Lancamento    001       001         001            ³
	³ Codigo da Conta    020       002         021            ³
	³ Contra Partida     020       022         041            ³
	³ Valor Moeda 1      016       042         057            ³
	³ Moedas             005       058         062            ³
	³ Historico          040       063         102            ³
	³ Valor Moeda 2      016       103         118            ³
	³ Valor Moeda 3      016       119         134            ³
	³ Valor Moeda 4      016       135         150            ³
	³ Valor Moeda 5      016       151         166            ³
	³ C Custo Debito     009       167         175            ³
	³ C Custo Credito    009       176         184            ³
	³ Cod/Seq Lanc Pad   005       185         189            ³
	³ Data de Vencimento 010       190         199            ³
	³ Origem do lanc.    040       200         239            ³
	³ Ident Inter CP     001       240         240            ³
	³ Nome do Programa   010       241         250            ³
	³ Item Debito        009       251         259            ³
	³ Item Credito       009       260         268            ³
	³ Filler             042       269         310            ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³                TOTALIZADOR DO ARQUIVO                   ³
	³ Descricao       Tamanho     Pos Ini     Pos Fim         ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³  Valor Total       016       001         016            ³
	³  Filler            294       017         300            ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	/*/
	DbSelectArea("SI5")
	dbSetOrder(1)
	DbSeek(cFilial+cPadrao)
	While !Eof() .And. I5_FILIAL == cFilial .And. cPadrao==I5_CODIGO

		aContas[1]:=I5_DC
		aContas[4] :=0
		aContas[7] :=0
		aContas[8] :=0
		aContas[9] :=0
		aContas[10]:=0

		cValor1 :=Trim(I5_CPOVAL1)
		cValor2 :=Trim(I5_CPOVAL2)
		cValor3 :=Trim(I5_CPOVAL3)
		cValor4 :=Trim(I5_CPOVAL4)
		cValor5 :=Trim(I5_CPOVAL5)
		If cPaisLoc == "COL" //Tratamento de Terceros - Local.Colombia
			cNitInt :=Trim(I5_NIT)
		Endif

		If cCriterio $ "FINA050/FINA100"
			If lExecuta
				If AllTrim(Upper(cValor1)) == "VALOR" .or. "VLRINSTR" $ Upper(cValor1)
					DbSkip()
					Loop
				End
			EndIf
			If !lExecuta
				If ! (AllTrim(Upper(cValor1)) == "VALOR" .or. "VLRINSTR" $ Upper(cValor1))
					DbSkip()
					Loop
				End
			End
		End

		If !Empty(cValor1)
			aContas[4]:=&(cValor1)
		End
		If !Empty(cValor2)
			aContas[7]:=&(cValor2)
		EndIf
		If !Empty(cValor3)
			aContas[8]:=&(cValor3)
		EndIf
		If !Empty(cValor4)
			aContas[9]:=&(cValor4)
		EndIf
		If !Empty(cValor5)
			aContas[10]:=&(cValor5)
		EndIf

		If cPaisLoc == "COL" // Tratamento de Terceiros - Local.Colombia
			If !Empty(cNitInt)
				aContas[19]:=&(cNitInt)
				aContas[19]:=If( Len(aContas[19])>13,Subs(aContas[19],1,14),PadR( aContas[19],14))
			Else
				aContas[19]:= Space(14)
			EndIf
		Endif
		If GetMv("MV_CTVALZR") == "N"
			nValor := aContas[4]
		Else
			nValor := aContas[4]+aContas[7]+aContas[8]+aContas[9]+aContas[10]
		EndIf

		cHistorico:=AllTrim(TranslCta(I5_HISTORI,240))

		If (aContas[1] == "-" .Or. nValor > 0)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ VerIfica se na Conta devera estar o Debito ou Credito³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aContas[2] :=TranslCta(I5_DEBITO, 20)  //Interpreta d‚bito
			aContas[3] :=TranslCta(I5_CREDITO,20)  //Interpreta cr‚dito
			aContas[17]:=TranslCta(I5_ITEMD,9)
			aContas[18]:=TranslCta(I5_ITEMC,9)

			If __HeadProva[5] == -5
				//
				// Cria o cabe‡alho do lan‡amento cont bil caso n„o tenha sido criado
				//
				RetcProva := CriaCProva(__HeadProva[1],__HeadProva[2],__HeadProva[3],lSimula)

				__HeadProva[4] := RetcProva[1]	// Nome do Arquivo
				__HeadProva[5] := RetcProva[2]	// Handle do Arquivo
			EndIf
			nHdlPrv := __HeadProva[5]

			aContas[5]:=I5_MOEDAS
			LanceiCtb := .T.
			If Len(cHistorico) > 40
				For n := 1 to Len(cHistorico) Step 40
					cHist := Substr(cHistorico,n,40)
					aContas[6] := cHist + Space(40 - Len(cHist))
					If n == 1
						aContas[11] :=TranslCta(I5_CCD, 9)      //Interpreta C.Custo D‚bito
						aContas[12] :=TranslCta(I5_CCC, 9)      //Interpreta C.Custo Cr‚dito
						aContas[13] :=I5_CODIGO+I5_SEQUENC
						aContas[14] :=TranslDta(I5_DTVENC)      //Interpreta data de vencimento
						aContas[15] :=TranslCta(I5_ORIGEM,40)   //Interpreta a origem
						aContas[16] :=Substr(I5_INTERCP,1,1)      //Inter Company
						aContas[17] :=TranslCta(I5_ITEMD,9)     // Item Debito
						aContas[18] :=TranslCta(I5_ITEMC,9)     // Item Credito
					Else
						aContas[1]  := "-"
						aContas[2]  := Space(20)
						aContas[3]  := Space(20)
						aContas[4]  := 0
						aContas[7]  := 0
						aContas[8]  := 0
						aContas[9]  := 0
						aContas[10] := 0
						aContas[11] := Space(9)
						aContas[12] := Space(9)
						aContas[13] := I5_CODIGO+I5_SEQUENC
						aContas[14] := TranslDta(I5_DTVENC)       //Interpreta data de vencimento
						aContas[15] := TranslCta(I5_ORIGEM,40)    //Interpreta a origem
						aContas[16] := Substr(I5_INTERCP,1,1)     //Inter Company
						aContas[17] := Space(9)
						aContas[18] := Space(9)
						If cPaisLoc ==  "COL" //Tratamento de Terceiros - Local.Colombia
							aContas[19] := Space(14)
						Endif
					EndIf
					If cPaisLoc == "COL" //Tratamento de Terceiros
						FWRITE(nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
							Str(aContas[4],16,2)+aContas[5]+aContas[6]+;
							Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
							Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
							aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
							aContas[15]+aContas[16]+cPrograma+aContas[17]+;
							aContas[18]+aContas[19]+Space(28)+CHR(13)+CHR(10),312)
					Else
						FWRITE(nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
							Str(aContas[4],16,2)+aContas[5]+aContas[6]+;
							Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
							Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
							aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
							aContas[15]+aContas[16]+cPrograma+aContas[17]+;
							aContas[18]+Space(42)+CHR(13)+CHR(10),312)
					Endif
					nTotal += nValor
				Next n
			Else
				aContas[6]  := cHistorico + Space(40 - Len(cHistorico))
				aContas[11] := TranslCta(I5_CCD, 9)     //Interpreta C.Custo D‚bito
				aContas[12] := TranslCta(I5_CCC, 9)     //Interpreta C.Custo Cr‚dito
				aContas[13] := I5_CODIGO+I5_SEQUENC
				aContas[14] := TranslDta(I5_DTVENC)  //Interpreta data de vencimento
				aContas[15] := TranslCta(I5_ORIGEM,40)    //Interpreta a origem
				aContas[16] := Substr(I5_INTERCP,1,1)   //Inter Company
				aContas[17] := TranslCta(I5_ITEMD,9)    //Item Debito
				aContas[18] := TranslCta(I5_ITEMC,9)    //Item Credito
				If cPaisLoc ==  "COL" //Tratamento de Terceiros - Local.Colombia
					FWRITE(nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
						Str(aContas[4],16,2)+aContas[5]+aContas[6]+;
						Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
						Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
						aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
						aContas[15]+aContas[16]+cPrograma+aContas[17]+;
						aContas[18]+aContas[19]+Space(28)+CHR(13)+CHR(10),312)
				Else
					FWRITE(nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
						Str(aContas[4],16,2)+aContas[5]+aContas[6]+;
						Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
						Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
						aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
						aContas[15]+aContas[16]+cPrograma+aContas[17]+;
						aContas[18]+Space(42)+CHR(13)+CHR(10),312)
				Endif
				nTotal+=nValor
			EndIf
		EndIf
		DbSelectArea("SI5")
		nLinha++
		DbSkip()
	EndDo
	Set(_SET_DATEFORMAT,cSet)
Else
	//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
	//  Fun‡„o de DETALHE no m¢dulo SIGACTB -> Contabilidade Gerencial
	//  Grava‡„o dos dados na tabela CTK
	//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
	DEFAULT cPrograma := FunName()
	DEFAULT aFlagCTB := {}
	nPosAFlag := Len(aFlagCTB)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se a tabelas do SIGACTB estao disponiveis           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Select("CTK") == 0
		ChkFile("CTK")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe moeda cadastrada no SIGACTB                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aVlrCT5 := Array(__nQuantas)
	//Se nao existir moeda cadastrada no SIGACTB.
	If Len(aVlrCT5) = 0
		MsgAlert(STR0040)	//Nao existe nenhuma moeda cadastrada no modulo SIGACTB.
		Return(0)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se esta configurada a configuração de lançamentos on line   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If FindFunction( "CTBCFGLANC" ) .And. !lSimula .And. !IsBlind()
		CtbCfgLanc(cPadrao)
	EndIF

	#IFDEF TOP
	If !lAS400				///SE NÃO FOR AS/400
		If lCTKRECORI == Nil
			lCTKRECORI := CTK->(FieldPos("CTK_RECORI") > 0)
		Endif
		If lCTKTABORI == Nil
			lCTKTABORI := CTK->(FieldPos("CTK_TABORI") > 0)
		Endif
		If lCTKRECDES == Nil
			lCTKRECDES := CTK->(FieldPos("CTK_RECDES") > 0)
		Endif
		If lCTKRECCV3 == Nil
			lCTKRECCV3 := CTK->(FieldPos("CTK_RECCV3") > 0)
		Endif
		If lCV3TABORI == Nil
			lCV3TABORI := CV3->(FieldPos("CV3_TABORI") > 0)
		Endif
		If lCV3RECORI == Nil
			lCV3RECORI := CV3->(FieldPos("CV3_RECORI") > 0)
		Endif
		If lCV3RECDES == Nil
			lCV3RECDES := CV3->(FieldPos("CV3_RECDES") > 0)
		Endif

		/// VERIFICA SE TODOS OS CAMPOS FORAM CRIADOS PARA RASTREAMENTO SEM CONFIGURACAO
		If lCTKTABORI .or. lCTKRECORI .or. lCTKRECDES .or. lCTKRECCV3  .or. lCV3TABORI  .or. lCV3RECORI .or. lCV3RECDES
			If !( lCTKTABORI .and. lCTKRECORI .and. lCTKRECDES .and. lCTKRECCV3  .and. lCV3TABORI  .and. lCV3RECORI .and. lCV3RECDES )
				If IsBlind()
					CONOUT("DETPROVA-MATXFUNA - Verify Fields: CTK_TABORI,CTK_RECORI,CTK_RECDES,CTK_RECCV3,CV3_TABORI,CV3_RECORI,CV3_RECDES.")
				Else
					MsgInfo(STR0043+CRLF+;
					STR0044+CRLF+;
					"CTK_TABORI (Char - 3)"+CRLF+;
					"CTK_RECORI (Char - 17)"+CRLF+;
					"CTK_RECDES (Char - 17)"+CRLF+;
					"CTK_RECCV3 (Char - 17)"+CRLF+;
					"CV3_TABORI (Char - 3)"+CRLF+;
					"CV3_RECORI (Char - 17)"+CRLF+;
					"CV3_RECDES (Char - 17).",STR0045)
					//STR0043="Campos de rastreamento de lançamentos e remarcação de flags."
					//STR0044="Verifique criacao campos: "
					//STR0045="Lançamento Contabil - ATENCAO ! Administrador."
				EndIf
			EndIf
		EndIf
	EndIf
	#ENDIF

	If __lConOutR
		ConOutR("*DETPROVA*|INIF|ARQUIVOS DE REGRAS PARA DRILL DOWN.|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Arquivos de regras para drill down                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cChaveBusca == Nil
		If !lSimula
			cChaveBusca := CtRelation(cPadrao,lPosiciona)
		Else
			cChaveBusca := ""
		EndIf
	EndIf

	If __lConOutR
		ConOutR("*DETPROVA*|FINF|ARQUIVOS DE REGRAS PARA DRILL DOWN.|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
		ConOutR("*DETPROVA*|INIF|PESQUISA OS LANCAMENTOS PADROES A SEREM EXECUTADOS|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pesquisa os lancamentos padroes a serem executados           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nX := aScan(aCT5,{|x| x[1] == cPadrao})
	If nX == 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicializa o array de otimizacao dos lancamentos padronizados³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aadd(aCT5,{cPadrao,{}})
		nX := Len(aCT5)

		DbSelectArea("CT5")
		dbSetOrder(1)
		#IFDEF TOP
			If !lAS400				///SE NÃO FOR AS/400
				lQuery   := .T.
				cAliasCT5:= "DETPROVA"

				cQuery := ""
				For nY := 1 To Len(aStruCT5)
					cQuery += ","+aStruCT5[nY][1]
				Next nY
				cQuery := "SELECT "+SubStr(cQuery,2)+" "
				cQuery += "FROM "+RetSqlName("CT5")+" CT5 "
				cQuery += "WHERE CT5.CT5_FILIAL='"+xFilial("CT5")+"' AND "
				cQuery += "CT5.CT5_LANPAD='"+cPadrao+"' AND "
				cQuery += "CT5.D_E_L_E_T_=' ' "
				cQuery += "ORDER BY "+SqlOrder(CT5->(IndexKey()))

				//RETIRADO PARA PERFORMANCE - ANSI NAO HA NECESSIDADE DE PASSAR PELA CHANGEQUERY
				If ! ( Alltrim(Upper(TCGetDB())) $ "MSSQL|MSSQL7|ORACLE" )
					cQuery := ChangeQuery(cQuery)
				EndIf

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCT5,.T.,.T.)

				For nY := 1 To Len(aStruCT5)
					If aStruCT5[nY][2] <> "C" .and. aStruCT5[nY][2] <> "M"
						TcSetField(cAliasCT5,aStruCT5[nY][1],aStruCT5[nY][2],aStruCT5[nY][3],aStruCT5[nY][4])
					EndIf
				Next nY
			Else
		#ENDIF
			MsSeek(xFilial("CT5")+cPadrao)
		#IFDEF TOP
			EndIf
		#ENDIF
		nZ := 0

		If __lConOutR
			ConOutR("*DETPROVA*|FINF|PESQUISA OS LANCAMENTOS PADROES A SEREM EXECUTADOS|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
			ConOutR("*DETPROVA*|INIF|ADICIONANDO NA ARRAY OS LANCAMENTOS PADROES A SEREM EXECUTADOS|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
		EndIf

		While !Eof() .And. (cAliasCT5)->CT5_FILIAL == xFilial("CT5") .And.;
				cPadrao == (cAliasCT5)->CT5_LANPAD

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Indica que o lancamento padrao esta inativo                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If CT5->(FieldPos("CT5_STATUS") > 0)
				If (cAliasCT5)->CT5_STATUS == "2"
					dbSelectArea(cAliasCT5)
					dbSkip()
					Loop
				EndIf
			EndIf

			nZ++
			aadd(aCT5[nX][2],{})
			For nY := 1 To (cAliasCT5)->(FCount())
				aadd(aCT5[nX][2][nZ],{(cAliasCT5)->(FieldName(nY)),(cAliasCT5)->(FieldGet(nY))})
			Next nY

			dbSelectArea(cAliasCT5)
			dbSkip()
		EndDo
		If lQuery
			dbSelectArea(cAliasCT5)
			dbCloseArea()
			dbSelectArea("CT5")
		EndIf

		If __lConOutR
			ConOutR("*DETPROVA*|FINF|ADICIONANDO NA ARRAY OS LANCAMENTOS PADROES A SEREM EXECUTADOS|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
		EndIf
	EndIf

	//Essa condicao foi incluida, porque quando o arquivo CT5 estava em branco, sem
	//nenhum lancamento padrao cadastrado, ocorria erro de "Array out of bound"
	If Len(aCt5[nX,2]) > 0
		If __lConOutR
			ConOutR("*DETPROVA*|INIF|TRATAMENTO DOS LPS DA ARRAY|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
		EndIf

		// Ponto de entrada para tratamento do conteudo do CT5
		If Existblock("CT5CPOS") .And. !lSimula
			Execblock("CT5CPOS",.F.,.F.,{aCT5[nX]})
		Endif

		#IFDEF TOP
		If !lAS400				///SE NÃO FOR AS/400
			/////////////////////////////////////////////////////////////////////////////////////////////
			/// TRATAMENTO PARA O RASTREAMENTO DO REGISTRO DE ORIGEM DO LANÇAMENTO INDEPENDENTE DE CHAVE
			/////////////////////////////////////////////////////////////////////////////////////////////
			/// SE A TABELA E RECNO DE ORIGEM FORAM PASSADOS NA DETPROVA ...
			If ValType(aTabRecOri) == "A" .and. Len(aTabRecOri) > 0
				cTabOrigem := aTabRecOri[1]
				nRecOrigem := aTabRecOri[2]
			EndIf

			If lCT5TABORI == Nil
				lCT5TABORI := CT5->(FieldPos("CT5_TABORI") > 0)		/// TABELA DE ORIGEM DO LANÇAMENTO
			Endif
			If lCT5RECORI == Nil
				lCT5RECORI := CT5->(FieldPos("CT5_RECORI") > 0)		/// IDENTIFICADOR DE REGISTRO NA ORIGEM
			Endif
			If lCTKIDORIG == Nil
				lCTKIDORIG := CTK->(FieldPos("CTK_IDORIG") > 0)		/// IDENTIFICADOR DE REGISTRO NA ORIGEM (UUID)
			EndIf

			/// SE A TABELA OU RECNO DE ORIGEM ESTIVEREM EM BRANCO - VERIFICA SE EXISTE REGRA NOS CAMPOS DO CT5 ...
			If (Empty(cTabOrigem) .or. nRecOrigem <= 0) .and. lCT5TABORI .and. lCT5RECORI
				nPT5TABORI := aScan( aCT5[nX,2][1], {|x| x[1] == "CT5_TABORI" })
				nPT5RECORI := aScan( aCT5[nX,2][1], {|x| x[1] == "CT5_RECORI" })
				If nPT5TABORI > 0 .and. nPT5RECORI > 0
					cTabOrigem := &(AllTrim(aCT5[nX,2][1][nPT5TABORI][2]))
					nRecOrigem := iif(empty((AllTrim(aCT5[nX,2][1][nPT5RECORI][2]))),0,Val(&(AllTrim(aCT5[nX,2][1][nPT5RECORI][2]))))
					If ValType(nRecOrigem) <> "N"
						nRecOrigem := 0
					EndIf
				EndIf
			EndIf

			//////////////////////////////////////////////////////////////////////
			/// TRATAMENTO PARA O RASTREAMENTO DO REGISTRO DE ORIGEM DO LANÇAMENTO
			//////////////////////////////////////////////////////////////////////
			If (Empty(cTabOrigem) .or. nRecOrigem <= 0) .and. (lCTKRECORI .AND. lCTKTABORI) .And. !lSimula
				/// SE TABELA OU RECNO AINDA ESTIVEREM EM BRANCO - VERIFICA REGRA PADRAO DE ACORDO COM O LP ...
				nRecOrigem := RetRecnoLP(cPadrao,@cTabOrigem,cAliasPos)
			EndIf
		EndIf
		#ENDIF
		If __lConOutR
			ConOutR("*DETPROVA*|FINF|TRATAMENTO DOS LPS DA ARRAY|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Execucao dos lancamentos padronizados                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPLanpad   := aScan(aCT5[nX,2][1],{|x| x[1] == "CT5_LANPAD"})
		nPSequen   := aScan(aCT5[nX,2][1],{|x| x[1] == "CT5_SEQUEN"})
		nPSbLote   := aScan(aCT5[nX,2][1],{|x| x[1] == "CT5_SBLOTE"})
		nPHist     := aScan(aCT5[nX,2][1],{|x| x[1] == "CT5_HIST"})
		nPHAglut   := aScan(aCT5[nX,2][1],{|x| x[1] == "CT5_HAGLUT"})
		nPMoedLC   := aScan(aCT5[nX,2][1],{|x| x[1] == "CT5_MOEDLC"})
		nPTpSald   := aScan(aCT5[nX,2][1],{|x| x[1] == "CT5_TPSALD"})
		nPOrigem   := aScan(aCT5[nX,2][1],{|x| x[1] == "CT5_ORIGEM"})

		If __lConOutR
			ConOutR("*DETPROVA*|INIF|EXECUTANDO AS REGRAS DOS LPS E GERANDO A CONTRA-PROVA|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
		EndIf
		For nY := 1 To Len(aCT5[nX,2])

			aVlrCT5   := AFill(aVlrCT5,0)
			nContador := 0

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se nao for continuacao de historico                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPosCT5 := aScan(aCT5[nX,2][nY],{|x| x[1] == "CT5_DC"})
			If aCT5[nX,2][nY][nPosCT5][2] <> "4"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se existem valores a serem contabilizados.          ³
				//³                                                              ³
				//³ Como os valores podem ser expressoes complexas estes sao     ³
				//³ armazenados na variavel aVlrCt5 para que nao haja necessidade³
				//³ de serem executados novamente.                               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nZ := 1 To __nQuantas
					nValor    := 0
					cCampoCT5 := "CT5_VLR"+StrZero(nZ,2)
					nPosCT5 := aScan(aCT5[nX,2][nY],{|x| x[1] == cCampoCT5 })
					If nPosCT5 > 0
						cValor := AllTrim(aCT5[nX,2][nY][nPosCT5][2])
						nValor := &(cValor)
						If Empty(nValor) .Or. iif(lRedStorn, nValor = 0 , nValor <= 0)
							nContador++
						Else
							aVlrCT5[nZ] := nValor
							nTotal += nValor
						EndIf
					EndIf
				Next nZ
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se houver valores para contabilizar                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nContador <> __nQuantas
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria semaforo para lancamento na tabela de contra-prova      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If __HeadProva[5] == -5
					
					CTK->(DbSetOrder(1))
					

					If __lConOutR
						ConOutR("*DETPROVA*|INIF|BUSCANDO A CHAVE DE SEQUENCIA DE CONTABILIZAçãO|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
					EndIf

					lAchouCTK := .T.
					// Gerar o codigo para a sequencia do lancamento. Se o codigo gerado ja foi utilizado,
					// despreza-lo e continuar gerando ate encontrar um que nao exista no CTK.
					While lAchouCTK
						If ( ! __lHasCTKSxe )
							cSeqChave := GetSx8Num("CTK","CTK_SEQUEN",,1)
						Else
							cSeqChave := GetSx8Num("_CT")
						EndIf

						lAchouCTK := CTK->( MsSeek( xFilial("CTK")+cSeqChave,.F. ) )

						If __lConOutR .AND. lAchouCTK
							ConOutR("*DETPROVA*|ERRO|BUSCANDO A CHAVE DE SEQUENCIA DE CONTABILIZAçãO|PROGRAMA|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|" + cSeqChave )
						Endif
					End

					__HeadProva[4] := cSeqChave		// Sequencia de Lan‡amento
					__HeadProva[5] := 1024			// Handle FIXO

					If __lConOutR
						ConOutR("*DETPROVA*|FINF|BUSCANDO A CHAVE DE SEQUENCIA DE CONTABILIZAçãO|PROGRAMA|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|" + cSeqChave )
					EndIf
				Else
					cSeqChave  := __HeadProva[4]
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Inicia a gravacao da tabela de contra-prova                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("CTK")
				
			
				DbSetOrder(1)

				If __lConOutR
					ConOutR("*DETPROVA*|INIF|GRAVANDO CONTRA-PROVA|PROGRAMA|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
				EndIf

				RecLock("CTK",.T.)
				#IFDEF TOP
				If !lAS400				///SE NÃO FOR AS/400
					If lCTKTABORI
						CTK->CTK_TABORI	:= cTabOrigem
					EndIf
					If lCTKIDORIG .And. FindFunction("CTBRetIDO")
						CTK->CTK_IDORIG := CTBRetIDO(cTabOrigem)						
					EndIf
					If lCTKRECORI
						CTK->CTK_RECORI	:= ALLTRIM(STR(INT(nRecOrigem)))
					EndIf
                EndIf
                #ENDIF
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ As tabelas CTK e CT5 possuem campos comuns. Desta maneira    ³
				//³ devem ser repassado para os campos da tabela CTK os valores  ³
				//³ contidos nos campos da tabela CT5.                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nPosCtk := 1 To CTK->(FCount())
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Obtem o nome do campo de destino na tabela CTK               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cCampoCTK := CTK->(FieldName(nPosCTK))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Obtem o nome do campo de origem na tabela CT5                ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cCampoCT5 := "CT5_" + SubStr(cCampoCTK,5)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Transfere os valores do campo                                ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nPosCT5 := aScan(aCT5[nX,2][nY],{|x| x[1] == cCampoCT5 })
					If nPosCT5 > 0
						Do Case
						Case SubStr(cCampoCT5,1,7)=="CT5_VLR"
							nValor := Val(SubStr(cCampoCT5,8,2))
							If nValor <= Len(aVlrCT5)
								If aVlrCT5[nValor] > 0 .or. lRedStorn
									CTK->(FieldPut(nPosCTK,aVlrCT5[nValor]))
								EndIf
							EndIf
						Case aStruCTK[nPosCTK][2] == "N"
							cValor	:= AllTrim(aCT5[nX,2][nY][nPosCT5][2])
							If !Empty(cValor)
								nValor := &(cValor)
								CTK->(FieldPut(nPosCTK,nValor))
							Else
								CTK->(FieldPut(nPosCTK,0))
							EndIf
						Case aStruCTK[nPosCTK][2] == "C"
							If !(cCampoCT5 $ "CT5_USERGI/CT5_USERGA/CT5_TABORI/CT5_RECORI")
								If cCampoCT5 == "CT5_SBLOTE"
									cValor := aCT5[nX,2][nY][nPosCT5][2]
								ElseIf cCampoCT5 == "CT5_FILIAL"
									cValor := xFilial("CTK")
								ElseIf cCampoCT5 == "CT5_TPSALD"
									cValor := aCT5[nX,2][nY][nPosCT5][2]
								ElseIf cCampoCT5 == "CT5_MLTSLD"
									cValor := aCT5[nX,2][nY][nPosCT5][2]
								ElseIf cCampoCT5 == "CT5_CTRLSD"
									cValor := aCT5[nX,2][nY][nPosCT5][2]
								ElseIf cCampoCT5 == "CT5_SEQUEN"
									cValor := aCT5[nX,2][nY][nPosCT5][2]
								Else
									cValor := AllTrim(TransLcta(aCT5[nX,2][nY][nPosCT5][2],240))
									If cCampoCT5 == "CT5_HIST"
										cHistorico := cValor
									ElseIf cCampoCT5 == "CT5_HAGLUT"
										If Empty(cValor) // SE HAGLUT ESTIVER EM BRANCO ASSUME HISTORICO.
											cValor := cHistorico
										EndIf
										cHAglut := cValor
									EndIf
								EndIf
								CTK->(FieldPut(nPosCTK,cValor))
							EndIf
							/*
							If !(cCampoCT5 $ "CT5_USERGI/CT5_USERGA/CT5_TABORI/CT5_RECORI")
								If cCampoCT5 == "CT5_SBLOTE"
									cValor := aCT5[nX,2][nY][nPosCT5][2]
								ElseIf cCampoCT5 == "CT5_FILIAL"
									cValor := xFilial("CTK")
								Else
									cValor := AllTrim(TransLcta(aCT5[nX,2][nY][nPosCT5][2],240))
									If cCampoCT5 == "CT5_HIST"
										cHistorico := cValor
									ElseIf cCampoCT5 == "CT5_HAGLUT"
										If Empty(cValor)			/// SE HAGLUT ESTIVER EM BRANCO ASSUME HISTORICO.
											cValor := cHistorico
										EndIf
										cHAglut := cValor
									EndIf
								EndIf
								CTK->(FieldPut(nPosCTK,cValor))
							EndIf
							*/
						Case aStruCTK[nPosCTK][2] == "D"
							cValor := Ctod(AllTrim(TranslDta(aCT5[nX,2][nY][nPosCT5][2])))
							cValor := IIf(Empty(cValor),Ctod(""),cValor)
							CTK->(FieldPut(nPosCTK,cValor))
						EndCase
					EndIf
				Next nPosCTK
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava os campos nao relacionados com a tabela CT5            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRateio
					CTK->CTK_CONTAB := "4"	// Contabilizacao de Rateio Contas a Pagar
				Else
					CTK->CTK_CONTAB := "2"	// Contabilizado automaticamente
				EndIf
				CTK->CTK_FILIAL	:= xFilial("CTK")
				CTK->CTK_ROTINA	:= cPrograma
				CTK->CTK_KEY	:= cChaveBusca
				CTK->CTK_LP		:= aCT5[nX,2][nY][nPLanPad][2]
				CTK->CTK_LPSEQ	:= aCT5[nX,2][nY][nPSequen][2]
				CTK->CTK_SEQUEN	:= cSeqChave
				CTK->CTK_SBLOTE	:= aCT5[nX,2][nY][nPSbLote][2]
				CTK->CTK_DATA	:= dDataBase
				CTK->CTK_LOTE	:= cLote

				If __Ct105CTK .And. !lSimula
					ExecBlock("CT105CTK", .F., .F., aCT5[nX,2][nY])
				Endif
				CTK->(MsUnlock())

				//-------------------------------------------------------
				// Obtencao da conta de Receita para o EFD-Contribuições
				//-------------------------------------------------------
				nPosCtaRec := aScan(aCT5[nX,2][1],{|x| x[1] == "CT5_CTAREC"})

				If nPosCtaRec > 0
					If aCT5[nX,2][nY][nPosCtaRec][2] == "2"
						cCtaRec := CTK->CTK_DEBITO
					ElseIf aCT5[nX,2][nY][nPosCtaRec][2] == "3"
						cCtaRec := CTK->CTK_CREDIT
					EndIf
				EndIf

				If __lConOutR
					ConOutR("*DETPROVA*|FINF|GRAVANDO CONTRA-PROVA|PROGRAMA|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
					ConOutR("*DETPROVA*|INIF|GRAVANDO FLAGS DE CONTABILIZAÇÃO|PROGRAMA|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
				EndIf

				If nPosAFlag > 0
					/// GUARDA O PRIMEIRO REGISTRO DE CTK PARA O LANCAMENTO (RODA DO FINAL P/ COMEÇO P/ NAO PRECISAR DE ASORT)
					nPosFlagOri	:= nPosAFlag
					n1StCTK	:= 0
					While aFlagCTB[nPosAFlag][5] == 0			/// PODE HAVER MAIS DE UM REGISTRO NA TAB ORIGEM
						aFlagCTB[nPosAFlag][5] := CTK->(Recno())
						n1StCTK	:= CTK->(Recno())
						nPosAFlag--
						If nPosAFlag <= 0
							Exit
						EndiF
					EndDo

				 	/// GUARDA O ULTIMO REGISTRO DE CTK PARA O LANCAMENTO. (RODA DO FINAL P/ COMEÇO P/ NAO PRECISAR DE ASORT)
					nPosAFlag := nPosFlagOri
					While aFlagCTB[nPosAFlag][5] == n1StCTK			/// PODE HAVER MAIS DE UM REGISTRO NA TAB ORIGEM
						aFlagCTB[nPosAFlag][6] := CTK->(Recno())
						nPosAFlag--									/// VOLTA UMA POSIÇÃO NO ARRAY
						If nPosAFlag <= 0
							Exit
						EndiF
					EndDo
				EndIf											/// ANTES DOS REGISTROS DE HISTORICO COMPLEMENTAR

				If __lConOutR
					ConOutR("*DETPROVA*|FINF|GRAVANDO FLAGS DE CONTABILIZAÇÃO|PROGRAMA|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
					ConOutR("*DETPROVA*|INIF|CONFIRMANDO NUMERAÇÃO DO SXEF - CONFIRMSX8|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
				EndIf

				While (GetSX8Len() > nSaveSX8)
					ConfirmSX8()
				EndDo

				If __lConOutR
					ConOutR("*DETPROVA*|FINF|CONFIRMANDO NUMERAÇÃO DO SXEF - CONFIRMSX8|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
					ConOutR("*DETPROVA*|INIF|GRAVACAO DO ARQUIVO DE RASTREAMENTO - CV3|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Gravacao do Arquivo de Rastreamento => CV3                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("CV3")
				
				DbSetOrder(1)
				

				If !Empty(CTK->CTK_KEY) .And. (CTK->CTK_VLR01 + CTK->CTK_VLR02 + CTK->CTK_VLR03 + CTK->CTK_VLR04 + CTK->CTK_VLR05) > 0

					NewCV3byCTK(lSimula,cTabCTK,cTabCT2)			/// CRIA NOVO REGISTRO NO CV3 BASEADO NO CTK POSICIONADO (CTBXFUN.PRX)

					FKCOMMIT()
				EndIf

				If __lConOutR
					ConOutR("*DETPROVA*|FINF|GRAVACAO DO ARQUIVO DE RASTREAMENTO - CV3|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
					ConOutR("*DETPROVA*|INIF|VERIFICA SE HAVERA QUEBRA DE HISTORICO|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
				EndIf

				dbSelectArea("CTK")

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se havera quebra de historico                       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nPHAglut > 0 .and. Empty(cHAglut)
					cHAglut	:= AllTrim(TransLcta(aCT5[nX,2][nY][nPHAglut][2],240))
				EndIf
				If nPHist > 0
					If Empty(cHistorico)
						cHistorico 	:= AllTrim(TransLcta(aCT5[nX,2][nY][nPHist][2],240))
					EndIf
					If Empty(cHAglut)
						cHAglut := cHistorico
					EndIf
					lCTKHAGLUT := CTK->(FieldPos("CTK_HAGLUT") > 0)
					nLen := Len(CTK->CTK_HIST)
					If Len(cHistorico) > nLen
						For nZ := nLen + 1 To Len(cHistorico) Step nLen
							cHist := SubStr(cHistorico,nZ,nLen)
							RecLock("CTK",.T.)
							CTK->CTK_DC			:= "4"
							CTK->CTK_HIST		:= cHist

							If lCTKHAGLUT .and. nZ <= Len(cHAglut)
								CTK->CTK_HAGLUT	:= SubStr(cHAglut,nZ,nLen)
							EndIf
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Grava os campos nao relacionados com a tabela CT5            ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lRateio
								CTK->CTK_CONTAB := "4"					// Contabilizacao de Rateio Contas a Pagar
							Else
								CTK->CTK_CONTAB := "2"					// Contabilizado automaticamente
							EndIf
							CTK->CTK_FILIAL	:= xFilial("CTK")
							CTK->CTK_ROTINA	:= cPrograma
							CTK->CTK_KEY	:= cChaveBusca
							CTK->CTK_LP		:= aCT5[nX,2][nY][nPLanPad][2]
							CTK->CTK_LPSEQ	:= aCT5[nX,2][nY][nPSequen][2]
							CTK->CTK_SEQUEN	:= cSeqChave
							CTK->CTK_SBLOTE	:= aCT5[nX,2][nY][nPSbLote][2]
							CTK->CTK_DATA	:= dDataBase
							CTK->CTK_LOTE	:= cLote
							CTK->CTK_TPSALD	:= aCT5[nX,2][nY][nPTpSald][2]
							CTK->CTK_MOEDLC	:= aCT5[nX,2][nY][nPMoedLC][2]
							CTK->CTK_ORIGEM	:=AllTrim(TransLcta(aCT5[nX,2][nY][nPOrigem][2],Len(CTK->CTK_ORIGEM)))

							#IFDEF TOP
								If lCTKTABORI
									CTK->CTK_TABORI	:= cTabOrigem
								EndIf
								If lCTKRECORI
									CTK->CTK_RECORI	:= ALLTRIM(STR(INT(nRecOrigem)))
								EndIf
			                #ENDIF

							If __Ct105CTK .And. !lSimula
								ExecBlock("CT105CTK", .F., .F., aCT5[nX,2][nY])
							Endif
							MsUnlock()
						Next nZ
					EndIf
				EndIf

				LanceiCtb := .T.

				If __lConOutR
					ConOutR("*DETPROVA*|FINF|VERIFICA SE HAVERA QUEBRA DE HISTORICO|"+cPrograma+"|LP|"+cPadrao+"|SEQCHAVE|"+cSeqChave )
				EndIf
			EndIf
		Next nY
	EndIf
EndIf

// Array com dados para utilizacao multi-thread
aDadosProva:=ACLONE(__HeadProva)

If __lConOutR
	ConOutR("*DETPROVAFIN*|INICIO DA MONTAGEM DO DETPROVA.|PROGRAMA|"+cPrograma+"|LP|"+cPadrao)
EndIf

If lRedStorn
	nTotal := ABS(nTotal) // Red storn - Return positive value to be recorded in CT2 as CTK (negative, if negative)
Endif

RestArea(aArea)
Return(nTotal)

/*********************** Retorna o Handle do Arquivo .LAN em uso
*
*/
function GetHProva()
Return __HeadProva[5]

/*********************** Retorna o Nome do Arquivo .LAN em uso
*
*/
function GetHFile()
Return __HeadProva[4]

/*********************** Manipula o Handle da contabilizacao atual
*
*/
function PutHFile(cFileCtb,nHandle)
DEFAULT nHandle := 0
If Empty(cFileCtb)
	__HeadProva[5] := -5
ElseIf nHandle <> 0
	__HeadProva[5] := nHandle
Endif
__HeadProva[4] := cFileCtb
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CtbInUse  ³ Autor ³ J£lio Wittwer         ³ Data ³14.01.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verificar se o m¢dulo SIGACTB est  ativo para contabiliza‡„o³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CtbInUse()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Retorna .T. para SIGACTB / .F. para SIGACON                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CtbInUse()

If __Contabil = NIL
	__Contabil := "CTB" //GetMv("MV_MCONTAB")
Endif
Return __Contabil == "CTB"

Function ResetCtb()
__Contabil = NIL
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³IntePms   ³ Autor ³ Wagner Mobile Costa   ³ Data ³27.07.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Identifica se usa a integracao PMS com os outros modulos    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³IntePms()                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Retorna .T. para Usa PMS / .F. para nao USA                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function IntePms()
Local lIntePms := (SuperGetMv("MV_INTPMS") = "S")
Return(lIntePms)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VldSX5Num ³ Autor ³ Edson Maricate        ³ Data ³26.06.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Validacao do Numero da NF digitada com Formulario Proprio.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³VldSX5Num(cNumNF,cSerNF,lMostraHelp)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Retorna .T. / .F.                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³SX5NumNota                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VldSX5Num(cIniNUM,cIniSER,lMostraHelp,cSerieId,lRusULCD)
Local lRet := .T.
Default lMostraHelp := .T.
DEFAULT cSerieId := cIniSER
Default lRusULCD := .F.

If ChkF3Nota( cSerieId,cIniNUM ) .Or. ;
		ChkF2Nota( cSerieId,cIniNUM ) .Or. ;
		ChkF1Nota( cSerieId,cIniNUM )
	If !lRusULCD .And. lMostraHelp
	HELP("  ",1,"EXISTNF")
	EndIf
	lRet := .F.
EndIf


Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetCondVei³ Autor ³ Valdir                ³ Data ³01.08.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna a condicao de pagto ref. a veiculo/oficina			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³RetCondVei()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Processo automatico                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function RetCondVei()
Local nRecno :=SE4->(Recno())
Local nOrdem :=SE4->(IndexOrd())
Local cReturn:='   '

SE4->(DbSetOrder(1))
SE4->(DBSeek(xFilial("SE4")))
While ! SE4->(eof()) .and. xFilial("SE4") == SE4->E4_FILIAL
	If SE4->E4_TIPO =='A'
		cReturn := SE4->E4_CODIGO
		Exit
	EndIf
	SE4->(DbSkip())
End
If Empty(cReturn)
	HELP(" ",1,"NCONDVEI")
EndIf
SE4->(DbSetorder(nOrdem))
SE4->(DbGoto(nRecno))
Return cReturn


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³BrwLegenda   ³Rev.  ³ Edson Maricate      ³ Data ³ 04/08/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Janela contendo uma legenda das cores para mBrowse.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³BrwLegenda(cTitulo,cMensagem,aCores)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cTitulo    :Titulo da Janela                                ³±±
±±³          ³cMensagem  :Mensagem exibida                                ³±±
±±³          ³aCores     :Array contendo as cores                         ³±±
±±³          ³nXSize     :Tamanho do Bitmap para ajuste da mensagem       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Analista  ³ Data/Bops/Ver ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Marcelo K.³03/11/04³8.11  ³QNC:003307/2004-00: Ajuste na criacao dos   ³±±
±±³          ³        ³      ³bitmaps das legendas                        ³±±
±±³          ³        ³      ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION BrwLegenda(cTitulo,cMensagem,aCores,nXSize)

Local nY       				:= 0
Local nX       				:= 0
Local aBmp[Len(aCores)]
Local aSays[Len(aCores)]
Local oDlgLeg
Local oModal

DEFAULT  nXSize := 14

If FindFunction("FWChkColors")
	aCores := FWChkColors( aCores )
EndIF

oModal := FWDialogModal():New()
oModal:SetFreeArea(320/2,((Len(aCores)*20)+35)/2)
oModal:SetEscClose(.T.)
oModal:SetTitle(cTitulo)
oModal:createDialog()
oModal:addCloseButton()
oDlgLeg := oModal:GetPanelMain()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³No onclick do usuario a tela sera fechada³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oDlgLeg:bLClicked:= {||oDlgLeg:End()}

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fonte especifico para a descricao das legendas³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD

	//@ 13,0 TO 014,400 LABEL '' OF oDlgLeg PIXEL
	//@ 03,2 SAY cMensagem OF oDlgLeg PIXEL SIZE 100,009 FONT oBold
	For nX := 1 to Len(aCores)
		@ (nX*10),08 BITMAP aBmp[nX] RESNAME aCores[nX][1] OF oDlgLeg SIZE 8,8 PIXEL NOBORDER
		aBmp[nX]:lStretch := .T.
		@ (nX*10),(nXSize/2) + 11 SAY If((nY+=1)==nY,aCores[nY][2]+If(nY==Len(aCores),If((nY:=0)==nY,"",""),""),"") OF oDlgLeg PIXEL
	Next nX
	nY := 0

oModal:Activate()

Return(NIL)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ MascSaldo Autor  ³ Wilson Junior       ³ Data ³ 16.10.92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula o saldo atual de uma determinada Mascara de um deter
±±³      ³ minado mes.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Saldo(ExpC1,ExpN1,ExpN2                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Codigo da conta, Mes, Moeda                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Generico                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MascSaldo(cConta,nPer,nMoeda,nAno)
Local cAlias := Alias()
Local ni, nSaldo := 0
Local cFil := xFilial("SI1")
#IFNDEF TOP
	Local cStart := ""
	Local cEnd   := ""
	Local cByte  := ""
	Local lOk
	Local nOrd := SI1->(IndexOrd())
	Local nReg := SI1->(Recno())
#ELSE
	Local cQuery
#ENDIF

#IFDEF TOP
	For ni:= 1 to Len(cConta)
		IF Subs(cCOnta,ni,1) == "?"
			cConta := Subs(cCOnta,1,ni-1)+"_"+Subs(cConta,ni+1)
		Endif
	Next
	cQuery := "SELECT I1_CODIGO FROM "+RetSqlName("SI1")+" WHERE I1_FILIAL = '"+cFil+"' AND "
	cQuery += "I1_CODIGO LIKE '"+cConta+"' AND "
	IF TcSrvType() == "AS/400"
		cQuery += "@DELET@ <> '*'"
	Else
		cQuery+= "D_E_L_E_T_ <> '*'"
	Endif
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), '__TRBSI1', .F., .T.)
	While !Eof()
		IF Len(Alltrim(cConta)) != Len(Alltrim(I1_CODIGO))
			dbSkip()
			Loop
		Endif
		nSaldo += Saldo(I1_CODIGO,nPer,nMoeda,nAno)
		dbSelectArea("__TRBSI1")
		dbSKip()
	End
	dbCloseArea()
#ELSE
	For ni := 1 to Len(SI1->I1_CODIGO)
		IF Subs(cConta,ni,1) == "?"
			Exit
		Endif
		cStart += Subs(cConta,ni,1)
		cEnd += Subs(cConta,ni,1)
	Next
	cStart += Space(Len(SI1->I1_CODIGO)-Len(cStart))
	cEnd += Replicate("z",Len(SI1->I1_CODIGO)-Len(cEnd))
	dbSelectArea("SI1")
	dbSeek(cFil+cStart,.t.)
	While !Eof() .and. I1_CODIGO <= cEnd .and. I1_FILIAL == cFil
		lOk := .t.
		IF Len(Alltrim(cConta)) != Len(Alltrim(I1_CODIGO))
			lOk := .f.
		Endif
		IF lOK
			For ni := 1 To Len(cConta)
				cByte := Subs(cConta,ni,1)
				IF Subs(I1_CODIGO,ni,1) != cByte .and. cByte != "?"
					lOk := .f.
				Endif
				IF !lOk
					Exit
				Endif
			Next
		Endif
		IF lOk
			nSaldo += Saldo(I1_CODIGO,nPer,nMoeda,nAno)
			dbSelectArea("SI1")
		Endif
		dbSkip()
	End
	SI1->(dbGoto(nReg))
	SI1->(dbSetOrder(nOrd))
#ENDIF
IF !Empty(cAlias)
	dbSelectArea(cAlias)
Endif
Return nSaldo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ SimbToMoeda³ Autor ³ Lucas               ³ Data ³ 17.07.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retornar o n£mero da moeda com base no Simbolo, base SX6.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpN1 := SimbToMoeda(ExpC1)		                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 := Simbolo da Moeda				                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpN1 := N£mero da Moeda  				                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                						                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SimbToMoeda(cSimbMoeda)
Local cMoeda	:= "1"
Local nMoedaCor	:=  0
Local nFilSize	:= FWSizeFilial()
Local lAchou	:= .F.

While SX6->(Dbseek(FWxFilial()+"MV_SIMB"+cMoeda)) .And. !Empty(GetMv("MV_SIMB"+cMoeda))
	If Alltrim(GetMv("MV_SIMB"+cMoeda))	==	Alltrim(cSimbMoeda)
		nMoedaCor:=	Val(cMoeda)
		Exit
		lAchou:= .T.
	Endif
	cMoeda	:=	Alltrim(Str(Val(cMoeda)+1))
	SX6->(DbSkip())
Enddo

If !lAchou
	While SX6->(Dbseek(Space(nFilSize)+"MV_SIMB"+cMoeda)) .And. !Empty(GetMv("MV_SIMB"+cMoeda))
		If Alltrim(GetMv("MV_SIMB"+cMoeda))	==	Alltrim(cSimbMoeda)
			nMoedaCor:=	Val(cMoeda)
			Exit
		Endif
		cMoeda	:=	Alltrim(Str(Val(cMoeda)+1))
		SX6->(DbSkip())
	Enddo
EndIf

Return(nMoedaCor)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Bloco de Fun‡”es Gr ficas TChart para Protheus                        ³±±
±±³ Autor..: J£lio Wittwer                        Data...: 28.05.1999     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ As fun‡”es abaixo declaradas foram criadas para o Fluxo de Caixa do   ³±±
±±³ m¢dulo financeiro (FINC020.PRW), e agora disponibilizadas para uso    ³±±
±±³ gen‚rico.                                                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

Exemplo de Utiliza‡„o para Protheus
...

DEFINE MSDIALOG oDlg FROM 10,10 TO 400,500;
	TITLE "Grafico TESTE" PIXEL

oGrafico := GRF_CreateNew(oDlg)		// Cria o gr fico

GRF_ChartType(oGrafico,1)				// Define um gr fico de Linhas
GRF_WinSet(oGrafico,50,5,300,450)	// Define coordenadas dentro do dialogo oDlg
GRF_Chart3d(oGrafico,.T.)				// Define aparencia 3D

GRF_InitData(oGrafico)					// Zera a s‚rie de Dados

For nConta:=1 to 26
	GRF_SetData(oGrafico,0,0,aleatorio(300,nConta),chr(64+nConta))
Next

GRF_EndData(oGrafico,500)		// Finaliza entrada de dados setando t¡tulo ?!

/// Pergunta por a‡„o do Usu rio  ///

GRF_Destroy(oGrafico)	// Destroi o Grafico, liberando recursos
...

ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Tabela de Cores p/ fun‡„o GRF_SetData()

00 Preto				  01 Marrom				02 Verde				  03 Verde Oliva
04 Azul Navy			  05 Purpura			06 Ciano				  07 Cinza
08 Prata				  09 Vermelho			10 Visgo				  11 Amarelo
12 Azul				  13 Fuchsia			14 Aqua				  15 Cinza Claro
16 Cinza Escuro		  17 Branco
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/


Function GRF_CreateNew( oWnd, nSeries )
/*/ ----------------------------------------------------------------------
* Cria o Objeto Chart. Recebe como parametro a Janerla / Dialogo
* onde deve ser criado o Gr fico. Retorna o Handle do Objeto, utilizado
* pelas fun‡”es de parametriza‡„o.
* ----------------------------------------------------------------------/*/
Local aResp
Local aVetor
Default nSeries := 1
aVetor := { str(oWnd:hWnd), str(nSeries) }
aResp  := ExecInClient(EIC_GRCREATENEW,aVetor)
Return Val( aResp[1] )

Function GRF_Destroy(oHandle)
/*/ ----------------------------------------------------------------------
* Destroi o Objeto Gr fico criado. Recebe como parametro o
* Handle do Objeto gerado pela fun‡„o GRF_CreateNew()
* ----------------------------------------------------------------------/*/
Local aVetor:={str(oHandle)}
ExecInClient(EIC_GRDESTROY,aVetor)
Return NIL

Function GRF_ChartType(oHandle,nTipo)
/*/ ----------------------------------------------------------------------
* Seta o tipo do Gr fico, dentre os tipos pre-definidos:
* 1 - Gr fioco de Linhas
* 2 - Gr fico de Barras
* 6 - Gr fico de Area
* Ainda depende de implementa‡„o. Se for utilizada para mudar
* o tipo de um gr fico j  com a s‚rie de dados preenchida,
* ela ZERA a s‚rie de dados do gr fico atual.
* ----------------------------------------------------------------------/*/
Local aVetor:={str(oHandle),str(nTipo)}				// oVbx:ChartType
ExecInClient(EIC_GRCHARTTYPE,aVetor)
Return NIL

Function GRF_FixedGAP(oHandle,nParam)
/*/ ----------------------------------------------------------------------
* Criada por compatibilidade, por enquanto n„o faz nada.
* ----------------------------------------------------------------------/*/
Local aVetor:={str(oHandle),str(nParam)}
ExecInClient(EIC_GRFIXEDGAP,aVetor)
Return NIL

Function GRF_Chart3D(oHandle,lSeta3D)
/*/ ----------------------------------------------------------------------
* Seta se a Aparˆncia do Gr fico ser  2D (.f.) ou 3D (.t.)
* ----------------------------------------------------------------------/*/
Local aVetor:={str(oHandle),If(lSeta3D,"1","0")}	// oVbx:Chart3D
ExecInClient(EIC_GRCHART3D,aVetor)
Return NIL

Function GRF_InitData( oHandle, P1, P2, P3, P4, P5 )
/*/ ----------------------------------------------------------------------
* Criada por compatibilidade, apenas reseta a s‚rie de dados do Gr fico.
* ----------------------------------------------------------------------/*/
Local aVetor := {}
AADD(aVetor,str(oHandle))
ExecInClient(EIC_GRINITDATA,aVetor)
Return NIL

Function GRF_SetData(oHandle,nSerie,nColuna,nValor,cCaption,nCor,nSerieToAdd)
/*/ ----------------------------------------------------------------------
* Fun‡„o de Setar os elementos da S‚rie de Dados do Gr fico
* Internamente apenas interpreta os parƒmetros nValor (conteudo
* numerico da coluna) e cCaption (Titulo da Coluna). nCor ‚ um parƒmetro
* opcional, obedecendo … tabela de convers”es de cores citada no
* in¡cio do bloco de fun‡”es.
* Funciona internamente como um AADD, acrescentando uma nova coluna ao gr fico.
* ----------------------------------------------------------------------/*/
Local aVetor:={}
Default nSerieToAdd := 1
AADD(aVetor,str(oHandle))
AADD(aVetor,Str(nValor))	// ArrayAt 17,nColuna
AADD(aVetor,cCaption)		// ArrayAt 70,nColuna
AADD(aVetor,str(if(nCor=NIL,9,nCor))) // Default=Vermelho
AADD(aVetor,str( nSerieToAdd ))
ExecInClient(EIC_GRSETDATA,aVetor)
Return NIL

Function GRF_EndData(oHandle,nScale,P1,P2,P3)
* ----------------------------------------------------------------------
* Finaliza a entrada de dados no gr fico, setando o t¡tulo do mesmo
* para "1:"+str(nScale)...
* ----------------------------------------------------------------------/*/
Local aVetor:={}
AADD(aVetor,str(oHandle))
AADD(aVetor,str(nScale))	// ArrayAt 26,3
ExecInClient(EIC_GRENDDATA,aVetor)
Return NIL

Function GRF_WinSet(oHandle,nTop,nLeft,nBottom,nRight,nGrid,nWall,nStyle,nNumCols)
/*/ ----------------------------------------------------------------------
* Seta as coordenadas do gr fico na tela em PIXEL. Parametros
* nGrid, nWall e nStyle n„o s„o atualmente interpretados.
* nNumCols recebe o numero de colunas do gr fico (Default = 5)
* ----------------------------------------------------------------------/*/
Local aVetor:={}
AADD(aVetor,str(oHandle))
AADD(aVetor,str(nTop))
AADD(aVetor,str(nLeft))
AADD(aVetor,str(nBottom))
AADD(aVetor,str(nRight))
AADD(aVetor,str(if(nNumCols=NIL,5,nNumCols))) // Default 5 Colunas
ExecInClient(EIC_GRWINSET,aVetor)
Return NIL


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³IsMoney	³ Autor ³ Fernando Machima      ³ Data ³26/10/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se a forma de pagamento e dinheiro comparando com ³±±
±±³			 ³ os simbolos das moedas(MV_SIMB1,MV_SIMB2,...)              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ IsMoney(cForma)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cForma = Forma de pagamento                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³LOJA,FRONT LOJA e FINANCEIRO  							  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function IsMoney(cForma)

Local lRet := .T.
Local nX   := 1
Local aArea := GetArea()

If (__aSimbMoeda == Nil) .or. Empty(__aSimbMoeda)
	__aSimbMoeda := {}
	dbSelectArea("SM2")
	While FieldPos("M2_MOEDA"+Ltrim(Str(nX))) > 0
		Aadd(__aSimbMoeda,Upper(GetMV("MV_SIMB"+Ltrim(Str(nX)))))
		nX++
	Enddo
EndIf

lRet := Ascan(__aSimbMoeda,{|x| Trim(x) == Trim(Upper(cForma))}) > 0

RestArea(aArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³IntTMS    ³ Autor ³ Patricia A. Salomao   ³ Data ³05.11.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Identifica se usa a integracao TMS com os outros modulos    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³IntTMS()                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function IntTMS()

Local lIntTMS := SuperGetMv("MV_INTTMS", .F., .F.)

//--Se nao for TOP esta funcao precisa retornar Falso,
//--mesmo que o parametro esteja True, devido as validacoes
//--de outros modulos em codebase
#IFNDEF TOP
	lIntTMS := .F.
#ENDIF

Return(lIntTMS)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ aSX5Troca³ Autor ³                       ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Da get no numero da nota fiscal e na serie                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA460 , MATA510, MATA100                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function aSX5Troca(nIt,aSerNF,nTimeOut)
Local cCadastro := OemToAnsi(STR0017) //"Numero"
Local oTimer
Local lOk
Local oDlg
cNumero  := aSerNf[nIt,2]
cSerie   := aSerNf[nIt,1]
vNumero  := cNumero
lSX5Troca := .T.

While .T.
	oTimer:= TTimer():New(nTimeOut*1000,{|| oDlg:End() })
	DEFINE MSDIALOG oDlg TITLE cCadastro From 12,60 To 15,80 OF oMainWnd
	If cPaisLoc $ "BRA|MEX"
		If cPaisLoc == "BRA"
		@ .8,.8 MSGET cNumero Picture "@!" When Substr(cAcesso,50,1) == "S" VALID lOk := VldSX5Num(cNumero,cSerie) SIZE 25,08 OF oDlg
		Else
		@ .8,.8 MSGET cNumero Picture "@!" When Substr(cAcesso,50,1) == "S" VALID lOk := VldSX5Num(cNumero,cSerie) SIZE 75,08 OF oDlg
		Endif
	Else
		@ .8,.8 MSGET cNumero Picture "@!" When Substr(cAcesso,50,1) == "S" VALID lOk := VldSX5Num(cNumero,cSerie) SIZE 65,08 OF oDlg
	Endif
	DEFINE SBUTTON FROM 10,166  TYPE 1 ACTION oDlg:End() ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg ON INIT oTimer:Activate()
	If lOk
		aSerNf[nIt,2] := cNumero
		cSerie :=aSerNf[nIt,1]
	EndIf
	If xValNota(cNumero,cSerie)
		Exit
	EndIf
End
Return aSerNf

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o  ³ xvalnota ³ Autor ³ Claudinei M. Benzi    ³ Data ³        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida nota informada                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso    ³ Sx5NumNota                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function xvalnota(cNumero,cSerie)
Local lRet:=.T.

If Empty(cNumero)
	HELP(" ",1,"NVAZIO")
	lRet:=.F.
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MATA330   ºAutor  ³Ricardo Goncalves   º Data ³  02/15/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna o nome do campo com maior comprimento dentro da lisº±±
±±º          ³ ta                                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ <cListField> - Lista de campos separados por ponto-e-vírgu-º±±
±±º          ³ la                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP6                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaiorCampo( cListField )
Local cMaiorCampo	:= ''
Local cField		:= ''
Local aFields		:= {}
Local i				:= 0
Local LastSize		:= 0
Local OldArea		:= Select()

cListField:= Upper(cListField)

/* -------------------------------------------------------------------------
Alimentando array com campos para comparação
------------------------------------------------------------------------- */
For i:= 1 To Len( cListField )
	If Subs( cListField, i, 1 ) = ';'
		Aadd( aFields, cField )
		cField:= ''
	Else
		cField += Subs( cListField, i, 1 )
	EndIf
Next

Aadd( aFields, cField )

dbSelectArea( 'SX3' )
dbSetOrder( 2 )

/* -------------------------------------------------------------------------
Verificando qual é o maior campo da lista
------------------------------------------------------------------------- */
For i:= 1 To Len(aFields)
	If dbSeek(aFields[i]) .and. (X3_TAMANHO > LastSize)
		cMaiorCampo:= aFields[i]
		LastSize  := X3_TAMANHO
	EndIf
Next

If OldArea != -1
	Select(OldArea)
EndIf

Return (cMaiorCampo)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³IntACD    ³ Autor ³ ACD                   ³ Data ³09.04.2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Identifica se usa a integracao ACD com os outros modulos    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³IntACD()                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IntACD(lMsg)
Static lIntAcd:= NIL
DEFAULT lMsg := .f.
If lIntAcd ==NIL
	lIntAcd := (GetNewPar("MV_INTACD","0") =="1")
EndIf
If lMsg .and. ! lIntAcd
	Aviso(STR0037,STR0038,{STR0039},2) //"Aviso"###"Opcao disponivel somente apos a integracao do ACD"###"Cancelar"
EndIf
Return lIntAcd

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MATXFUNA  ºAutor  ³Ricardo Goncalves   º Data ³  07/08/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna a estrutura do arquivo de trabalho para o recalculoº±±
±±º          ³ do custo médio                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP6                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTRBStru(nOpc)
Local aRet		:={}
Local nSizeFil	:= 2
Local nTamanho	:= 0
Local aTam		:= {}
Local cIndRdmk  := ""

Default nOpc := 1

If nOpc == 1 //-- Campos
	//-- Atualiza o conteúdo da filial
	If FindFunction("FWSizeFilial")
		nSizeFil := FWSizeFilial()
	EndIf

	AADD(aRet,{ "TRB_FILIAL"	,"C",nSizeFil,0 } )
	AADD(aRet,{ "TRB_FILTRA"	,"C",nSizeFil,0 } )
	AADD(aRet,{ "TRB_ALIAS"	,"C",03,0 } )
	AADD(aRet,{ "TRB_RECNO"	,"N",12,0 } )
	AADD(aRet,{ "TRB_ORDEM"	,"C",03,0 } )

	nTamanho := SomaCampos("D3_OP+D1_FORNECE+D3_DOC+D2_SERIE+D3_NUMSEQ+D1_DTDIGIT+D3_CF+D3_NIVEL")
	AADD(aRet,{ "TRB_CHAVE"	,"C",nTamanho,0 } )

	AADD(aRet,{ "TRB_NIVEL"	,"C",03,0 } )
	AADD(aRet,{ "TRB_NIVSD3"	,"C",01,0 } )
	aTam:= TamSX3("B1_COD")
	AADD(aRet,{ "TRB_COD"	,"C",aTam[1], 0 } )
	AADD(aRet,{ "TRB_DTBASE"	,"D",08,0 } )
	aTam:= TamSX3("D3_OP")
	AADD(aRet,{ "TRB_OP"		,"C",aTam[1],0 } )
	aTam:= TamSX3("D3_NUMSEQ")
	AADD(aRet,{ "TRB_CF"		,"C",03,0 } )
	AADD(aRet,{ "TRB_SEQ"	,"C",aTam[1],0 } )
	AADD(aRet,{ "TRB_SEQPRO"	,"C",aTam[1],0 } )
	AADD(aRet,{ "TRB_DTORIG"	,"D",08,0 } )
	AADD(aRet,{ "TRB_RECSD1"	,"N",12,0 } )
	AADD(aRet,{ "TRB_TES"	,"C",03,0 } )
	aTam:= TamSX3(MaiorCampo("D1_DOC;D2_DOC;D3_DOC"))
	AADD(aRet,{ "TRB_DOC"	,"C",aTam[1],0 } )
	aTam:= TamSX3(MaiorCampo("D1_SERIE;D2_SERIE"))
	AADD(aRet,{ "TRB_SERIE"	,"C",aTam[1],0 } )
	AADD(aRet,{ "TRB_TIPO"	,"C",01,0 } )
	aTam:= TamSX3("B2_LOCAL")
	AADD(aRet,{ "TRB_LOCAL"	,"C",aTam[1],0 } )
	AADD(aRet,{ "TRB_RECSBD"	,"N",12,0 } )
	AADD(aRet,{ "TRB_RECTRB"	,"N",12,0 } )
	AADD(aRet,{ "TRB_TIPONF"	,"C",01,0 } )
	aTam:= TamSX3("B2_QFIM")
	AADD(aRet,{ "TRB_QINI"	,"N",aTam[1],aTam[2] } )
	AADD(aRet,{ "TRB_QUANT"	,"N",aTam[1],aTam[2] } )
	AADD(aRet,{ "TRB_QFIM"	,"N",aTam[1],aTam[2] } )
	AADD(aRet,{ "TRB_FLAG"	,"L",01,0})
	AADD(aRet,{ "TRB_RNOAUX" ,"N",12,0 } )
	AADD(aRet,{ "TRB_USATRA" ,"C",01,0 } )
	aTam:= TamSX3("D1_ITEM")
	AADD(aRet,{ "TRB_ITEM"   ,"C",aTam[1],0 } )
	AADD(aRet,{ "TRB_MOD" 	,"C",01,0 } )
	AADD(aRet,{ "TRB_THREAD ","C",15,0 } )
Else //-- Indices
	AADD(aRet,"TRB_FILIAL+TRB_ORDEM+TRB_COD+TRB_NIVEL+TRB_NIVSD3+TRB_CHAVE+TRB_SEQ")
	AADD(aRet,"TRB_FILIAL+TRB_ALIAS+TRB_SEQ")
	AADD(aRet,"DTOS(TRB_DTBASE)+TRB_SEQPRO+TRB_ORDEM+TRB_NIVEL+TRB_NIVSD3+TRB_CHAVE+TRB_SEQ")
	AADD(aRet,"TRB_FILIAL+TRB_ALIAS+TRB_DOC+TRB_SERIE+TRB_ITEM")
	AADD(aRet,"DTOS(TRB_DTORIG)+TRB_SEQ+TRB_NIVEL+TRB_NIVSD3")
	AADD(aRet,"TRB_FILIAL+TRB_USATRA+TRB_ALIAS+TRB_COD+TRB_FILTRA")
	AADD(aRet,"TRB_THREAD+TRB_FILIAL+TRB_ORDEM+TRB_COD+TRB_NIVEL+TRB_NIVSD3+TRB_CHAVE+TRB_SEQ")
	AADD(aRet,"TRB_FILIAL+TRB_COD+TRB_LOCAL")
	AADD(aRet,"STR(TRB_RECNO, 12, 0)+TRB_ALIAS")
	AADD(aRet,"DTOS(TRB_DTBASE)+TRB_ORDEM+TRB_CHAVE")
	If ExistBlock("MA330IND") .And. ValType(cIndRdmk := ExecBlock("MA330IND",.F.,.F.)) == "C"
		AADD(aRet,cIndRdmk)
	EndIf
EndIf

Return (aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MATXFUNA  ºAutor  ³Ricardo Goncalves   º Data ³  07/08/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna a estrutura do arquivo TRX usado no recalculo do cusº±±
±±º          ³to médio                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP6                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function GetTRXStru(nOpc)
Local aRet:= {}
Local nSizeFil  := 2

Default nOpc := 1

If nOpc == 1 //-- Campos
	//-- Atualiza o conteúdo da filial
	If FindFunction("FWSizeFilial")
		nSizeFil := FWSizeFilial()
	EndIf

	AADD(aRet,{"TRX_FILIAL"	,"C",nSizeFil,0 } )
	AADD(aRet,{"TRX_DATA"		,"D",08,0 } )
	aTam:= TamSX3("D3_OP")
	AADD(aRet,{"TRX_OP"		,"C",aTam[1],0 } )
	aTam:= TamSX3("B1_COD")
	AADD(aRet,{"TRX_COD"		,"C",aTam[1],0 } )
	aTam:= TamSX3("B2_LOCAL")
	AADD(aRet,{"TRX_LOCAL"	,"C",aTam[1],0 } )
	aTam:=TamSX3("D3_QUANT")
	AADD(aRet,{"TRX_QUANT"	,"N",aTam[1],aTam[2] } )
	AADD(aRet,{"TRX_QPERDA"	,"N",aTam[1],aTam[2] } )
	AADD(aRet,{"TRX_TOTAL"	,"N",aTam[1],aTam[2] } )
	AADD(aRet,{"TRX_TPERDA"	,"N",aTam[1],aTam[2] } )
	AADD(aRet,{"TRX_QTDPRC"	,"N",aTam[1],aTam[2] } )
	AADD(aRet,{"TRX_RNOAUX"	,"N",12,0 } )
Else //-- Indices
	AADD(aRet,"TRX_FILIAL+DTOS(TRX_DATA)+TRX_OP+TRX_COD+TRX_LOCAL")
	AADD(aRet,"TRX_FILIAL+STR(TRX_RNOAUX, 12, 0)")
EndIf
Return (aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MATXFUNA  ºAutor  ³Ricardo Goncalves   º Data ³  15/07/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna a estrutura do arquivo TRT usado no recalculo do cusº±±
±±º          ³to médio                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP6                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function GetTRTStru(lCstPart,nPartes,nOpc)
Local nx		:= 0
Local nz		:= 0
Local aRet		:= {}
Local aRegraCP 	:= {}
Local aLogsPart := {}
Local lCheck	:= (lCstPart == nil) .and. (nPartes == nil)

Default nOpc := 1

If nOpc == 1 //-- Campos
	If lCheck
		If ExistBlock("MA330CP")
			aRegraCP:=ExecBlock("MA330CP",.F.,.F.)
			If ValType(aRegraCP) # "A"
				aRegraCP:={}
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se os campos do custo em partes estao Ok            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aRegraCP) > 0
			lCstPart:=MA330AvlCp(aRegracp,aLogsPart)
		EndIf

		nPartes:= Len(aRegraCP)
	EndIf

	aTam:=TamSX3("B1_FILIAL")
	AADD(aRet,{ "TRB_FILIAL"	,"C",aTam[1],0 } )
	aTam:=TamSX3("B1_COD")
	AADD(aRet,{ "TRB_COD"		,"C",aTam[1],0 } )
	aTam:=TamSX3("B2_QFIM")
	AADD(aRet,{ "TRB_QFIM"	,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_QFIM2")
	AADD(aRet,{ "TRB_QFIM2"	,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_VFIM1")
	AADD(aRet,{ "TRB_VFIM1"	,"N",aTam[1]+2,aTam[2]} )
	aTam:=TamSX3("B2_VFIM2")
	AADD(aRet,{ "TRB_VFIM2"	,"N",aTam[1]+2,aTam[2]} )
	aTam:=TamSX3("B2_VFIM3")
	AADD(aRet,{ "TRB_VFIM3"	,"N",aTam[1]+2,aTam[2]} )
	aTam:=TamSX3("B2_VFIM4")
	AADD(aRet,{ "TRB_VFIM4"	,"N",aTam[1]+2,aTam[2]} )
	aTam:=TamSX3("B2_VFIM5")
	AADD(aRet,{ "TRB_VFIM5"	,"N",aTam[1]+2,aTam[2]} )
	aTam:=TamSX3("B2_CM1")
	AADD(aRet,{ "TRB_CM1"		,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_CM2")
	AADD(aRet,{ "TRB_CM2"		,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_CM3")
	AADD(aRet,{ "TRB_CM3"		,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_CM4")
	AADD(aRet,{ "TRB_CM4"		,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_CM5")
	AADD(aRet,{ "TRB_CM5"		,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_QFIM")
	AADD(aRet,{ "TRB_QTDMOD"	,"N",aTam[1]+2,0       } )
	aTam:=TamSX3("B2_CM1")
	AADD(aRet,{ "TRB_TOTCM1"	,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_CM2")
	AADD(aRet,{ "TRB_TOTCM2"	,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_CM3")
	AADD(aRet,{ "TRB_TOTCM3"	,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_CM4")
	AADD(aRet,{ "TRB_TOTCM4"	,"N",aTam[1]+2,aTam[2] } )
	aTam:=TamSX3("B2_CM5")
	AADD(aRet,{ "TRB_TOTCM5"	,"N",aTam[1]+2,aTam[2] } )
	AADD(aRet,{ "TRB_PRCREA"	,"L",1,0 } )
	AADD(aRet,{ "TRB_RNOAUX"  ,"N",12,0 } )

	// Caso utilize custo em partes cria os campos no arquivo de trabalho
	If lCstPart
		For nz:=1 to nPartes + 1
			For nx:=1 to 5
				aTam:=TamSX3("B2_CM1")
				AADD(aRet,{ "TRB_CP"+StrZero(nz,2,0)+StrZero(nx,2,0),"N",aTam[1]+2,aTam[2]})
				aTam:=TamSX3("B2_VFIM1")
				AADD(aRet,{ "TRB_VF"+StrZero(nz,2,0)+StrZero(nx,2,0),"N",aTam[1]+2,aTam[2]})
				aTam:=TamSX3("B2_CM1")
				AADD(aRet,{ "TRB_TP"+StrZero(nz,2,0)+StrZero(nx,2,0),"N",aTam[1]+2,aTam[2]})
			Next nx
		Next nz
	EndIf
Else //-- Indices
	AADD(aRet,"TRB_FILIAL+TRB_COD")
	AADD(aRet,"TRB_FILIAL+STR(TRB_RNOAUX, 12, 0)")
EndIf

Return (aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MATXFUNA  ºAutor  ³Marcelo Pimentel    º Data ³  08/07/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna a estrutura do arquivo de trabalho para o recalculoº±±
±±º          ³ do custo médio                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP7                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTRAStru(nOpc)
Local aRet	   := {}
Local aTam     := {}
Local nSizeFil := 2

Default nOpc := 1

If nOpc == 1 //-- Campos
	//-- Atualiza o conteúdo da filial
	If FindFunction("FWSizeFilial")
		nSizeFil := FWSizeFilial()
	EndIf

	AADD(aRet,{ "TRA_FILIAL"	,"C",nSizeFil,0 } )
	AADD(aRet,{ "TRA_NUMSEQ"	,"C",06,0 } )
	AADD(aRet,{ "TRA_CF"	    ,"C",03,0 } )
	aTam:= TamSX3("B1_COD")
	AADD(aRet,{ "TRA_COD"	,"C",aTam[1],0 } )
	AADD(aRet,{ "TRA_RNOAUX" ,"N",12,0 } )
Else //-- Indices
	AADD(aRet,"TRA_FILIAL+TRA_NUMSEQ+TRA_CF+TRA_COD")
	AADD(aRet,"TRA_FILIAL+STR(TRA_RNOAUX, 12, 0)")
EndIf
Return (aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MATXFUNA  ºAutor  ³Marcelo Pimentel    º Data ³  25/10/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna a estrutura do arquivo de trabalho para a Virada   º±±
±±º          ³ de Saldos ( Relatorio de Divergencias )                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ PROTHEUS                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTRCStru()
Local aCampos  := {}
Local aTam     := {}
Local nSizeFil := 2

//-- Atualiza o conteúdo da filial
If FindFunction("FWSizeFilial")
	nSizeFil := FWSizeFilial()
EndIf

AADD(aCampos,{ "TRC_FILIAL"	,"C",nSizeFil,0 } )
aTam:= TamSX3("B1_COD")
AADD(aCampos,{ "TRC_COD"	,"C",aTam[1],0 } )
aTam:= TamSX3("B2_LOCAL")
AADD(aCampos,{ "TRC_LOCAL"	,"C",aTam[1],0 } )
AADD(aCampos,{ "TRC_ALIAS"	,"C",03,0 } )
aTam:= TamSX3("B2_QFIM")
AADD(aCampos,{ "TRC_QFIM"	,"N",aTam[1],aTam[2] } )
AADD(aCampos,{ "TRC_DIVERG"	,"N",aTam[1],aTam[2] } )

Return (aCampos)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MATXFUNA  ºAutor  ³Marcelo Pimentel    º Data ³  13/02/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna a estrutura do arquivo de trabalho para o recalculoº±±
±±º          ³ do custo médio                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ PROTHEUS                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTRDStru(nOpc)
Local aRet  :={}
Local nSizeFil := 2

Default nOpc := 1

If nOpc == 1 //-- Campos
	//-- Atualiza o conteúdo da filial
	If FindFunction("FWSizeFilial")
		nSizeFil := FWSizeFilial()
	EndIf

	AADD(aRet,{ "TRD_FILIAL"	,"C",nSizeFil,0 } )
	AADD(aRet,{ "TRD_CGC"	,"C",14,0 } )
Else //-- Indices
	AADD(aRet,"TRD_FILIAL+TRD_CGC")
EndIf
Return (aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GetTRJStruºAutor  ³Microsiga S/A       º Data ³  14/09/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna a estrutura do arquivo SBJ para utilizar no        º±±
±±º          ³ no relatorio MATR282.                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ PROTHEUS                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTRJStru()
Local aCampos  :={}
Local aStru    :={}
Local nX       :=0

aStru := SBJ->(dbStruct())

For nX := 1 to Len(aStru)
	If aStru[nX,1] $ "BJ_FILIAL|BJ_COD|BJ_LOCAL|BJ_LOTECTL|BJ_NUMLOTE|BJ_DATA|BJ_QINI|BJ_QISEGUM"
		aAdd(aCampos,aStru[nX])
	EndIf
Next nX
If Len(aCampos) > 1
	AADD(aCampos,{ "BJ_RNOAUX" ,"N",12,0 } )
EndIf

Return (aCampos)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GetTRKStruºAutor  ³Microsiga S/A       º Data ³  14/09/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna a estrutura do arquivo SBK para utilizar no        º±±
±±º          ³ no relatorio MATR282.                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ PROTHEUS                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTRKStru()
Local aCampos  :={}
Local aStru    :={}
Local nX       :=0

aStru := SBK->(dbStruct())

For nX := 1 to Len(aStru)
	If aStru[nX,1] $ "BK_FILIAL|BK_COD|BK_LOCAL|BK_LOTECTL|BK_NUMLOTE|BK_DATA|BK_QINI|BK_QISEGUM|BK_LOCALIZ|BK_NUMSERI"
		aAdd(aCampos,aStru[nX])
	EndIf
Next nX
If Len(aCampos) > 1
	AADD(aCampos,{ "BK_RNOAUX" ,"N",12,0 } )
EndIf
Return (aCampos)


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A093SB1     ³ Autor ³ Marcelo Iuspa      ³ Data ³ 07/09/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Abre busca nos produtos do configurador na conpad do SB1   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA093                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A093SB1()
Local oDlg		 // Dialog
Local oBox       // Listbox
Local aSavAre := SaveArea1({"SBP", "SX2"})
Local cTitle  := Nil
Local lOk     := .F.
Local nLine   := 0
Local aCampos := {"BP_BASE", "BP_DESCR"}
Local aFields := {}
Local aHeaSBP := {}
Local aRegs   := {}

dbSelectarea("SX2")
dbSetOrder(1)
dbSeek("SBP")
cTitle := x2nome()
// Area sera restaurada mais abaixo

aEval(aCampos, {|z| Aadd(aHeaSBP, RetTitle(z))})

CursorWait()

dbSelectArea("SBP")
dbSeek(cSeek := xFilial("SBP"))
do While ! Eof() .And. BP_FILIAL == xFilial("SBP")
	If SBP->BP_DISPUSO # "1"
		dbSkip()
		Loop
	Endif
	Aadd(aRegs, SBP->(RecNo()))
	Aadd(aFields, {})
	aEval(aCampos, {|z| Aadd(aTail(aFields), FieldGet(FieldPos(z)))})
	dbSkip()
Enddo
CursorArrow()

RestArea1(aSavAre)

If Len(aFields) == 0
	Aviso("A093SB1", STR0059,{"OK"})
Else
	DEFINE MSDIALOG oDlg TITLE cTitle FROM 00,00 TO 250,500 PIXEL OF oMainWnd
	@ 02,02 TO 120,210 LABEL "" PIXEL OF oDlg
	oBox := TWBrowse():New( 05, 04, 205, 115,{|| {NOSCROLL } },aHeaSBP,, oDlg,,,,{|| nLine:= oBox:nAt},{|| lOk := .T., oDlg:End()},,,,,,, .F.,, .T.,, .F.,,, )
	oBox:SetArray(aFields)
	oBox:bLine:={|| aFields[oBox:nAt]}
	oBox:Refresh()

	DEFINE SBUTTON FROM 05,215 TYPE 1 ENABLE OF oDlg ACTION (lOk:=.T.,oDlg:End())
	DEFINE SBUTTON FROM 25,215 TYPE 2 ENABLE OF oDlg ACTION oDlg:End()
	ACTIVATE MSDIALOG oDlg CENTERED

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Na confirmacao posiciona no titulo selecionado.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lOk .And. nLine > 0
		SBP->(dbGoto(aRegs[nLine]))
	EndIf
EndIf

Return(lOk)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ SaveArea1   ³ Autor ³ Marcelo Iuspa		   ³ Data ³ 01/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Salva varias WorkAreas para serem restaurados depois 		 ³±±
±±³ 		 ³ Salva tambem WorkArea corrente								 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Array com varios alias a serem salvos (Ex.: {"SB1", "SA1"})   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ Array com dados das WorkAreas								 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SaveArea1(aAlias)
Local aRet := {}
aAlias := If(aAlias = Nil, {}, aAlias)
aEval(aAlias, {|x| If(Select(x) > 0, Aadd(aRet, {x, ( x )->(IndexOrd()), ( x )->(RecNo()) }), Nil)})
Aadd(aRet, {Alias(), IndexOrd(), RecNo()})
Return(aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ RestArea1   ³ Autor ³ Marcelo Iuspa		   ³ Data ³ 01/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Restaura WorkAreas salvadas por SaveArea1					 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Array retornado por SaveArea1								 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ .T.															 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RestArea1(aSave)
aEval(aSave, {|x| If(Select(x[1]) > 0, (dbSelectArea(x[1]), dbSetOrder(x[2]), dbGoto(x[3])), Nil)})
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³FrtSetMoed³ Autor ³ Fernando Machima      ³ Data ³ 20/01/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Inicializa o array de taxa de moeda(__aMoeda - static) na   ³±±
±±³          ³carga dos arquivos do FrontLoja                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³FrtSetMoeda()                          				      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FRTA010A  												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FrtSetMoeda()

__aMoeda := Nil

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GetSx3Cach³ Autor ³Eduardo Riera          ³ Data ³18.11.2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Obtem os dados de cache da tabela SX3                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpU1: Valor solicitado                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Campo do dicionario                                  ³±±
±±³          ³ExpC2: Campo do SX3                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GetSx3Cache(cSX3Campo,cCampo)

Local nX
Local nY
Local nOrdSX3
Local uValor

If Select("SX3") == 0
	Return
EndIf
if __findSx3Cache
	uValor := _GtSx3Cached(cSX3Campo,cCampo)
else
	cSX3Campo := PadR( cSX3Campo , 10 )

	If __nXSX3Cache <> 0 .And. __SX3CACHE[ __nXSX3Cache ][ 1 ] == cSX3Campo
		nX := __nXSX3Cache
	Else
		nX := aScan( __SX3CACHE,{ |x| x[ 1 ] == cSX3Campo } )
		__nXSX3Cache := nX
	EndIf

	nY := SX3->( FieldPos( cCampo ) )

	If nX == 0

		nOrdSX3 := SX3->( IndexOrd() )

		SX3->( dbSetOrder( 2 ) )

		If SX3->( MsSeek( cSX3Campo ) )

			aAdd( __SX3CACHE , { cSX3Campo, Array( SX3->( Fcount() ) ) } )

			nX := Len( __SX3CACHE )

			__nXSX3Cache := nX

			__SX3CACHE[ nX ][ 2 ][ nY ] := SX3->( FieldGet( nY ) )

			uValor := __SX3CACHE[ nX ][ 2 ][ nY ]
		EndIf

		SX3->( dbSetOrder( nOrdSX3 ) )

	Else

		If __SX3CACHE[ nX ][ 2 ][ nY ] == NIL

			If cSX3Campo <> SX3->X3_CAMPO

				nOrdSX3  := SX3->( IndexOrd() )

				SX3->( dbSetOrder( 2 ) )

				SX3->( MsSeek( cSX3Campo ) )

				SX3->( dbSetOrder( nOrdSX3 ) )

			EndIf

			__SX3CACHE[ nX ][ 2 ][ nY ] := SX3->( FieldGet( nY ) )

		Endif

		uValor := __SX3CACHE[ nX ][ 2 ][ nY ]

	EndIf
	
endif
Return( uValor )
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ MascSaldoCTB| Autor ³ Paulo Eduardo         ³ Data ³ 15.07.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula o saldo atual de uma determinada Mascara de um deter  ³±±
±±³          ³ minado mes.                               				     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                 					 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MascSaldoCTB(cConta,dData,cMoeda,cTpSald,nQualSaldo)
Local cAlias := Alias(), nReg := CT1->(Recno()), nOrd := CT1->(IndexOrd())
Local cStart := "", cEnd := "", ni, lOK, cByte, nSaldo := 0, cQuery := ""
Local cFil := xFilial("CT1")

cTpSald		:= Iif(Empty(cTpSald),"1",cTpSald)
nQualSaldo	:= Iif(nQualSaldo==Nil,1,nQualSaldo)

#IFDEF TOP
	For ni:= 1 to Len(cConta)
		IF Subs(cCOnta,ni,1) == "?"
			cConta := Subs(cCOnta,1,ni-1)+"_"+Subs(cConta,ni+1)
		Endif
	Next
	cQuery := "SELECT CT1_CONTA FROM "+RetSqlName("CT1")+" WHERE CT1_FILIAL = '"+cFil+"' AND "
	cQuery += "CT1_CONTA LIKE '"+AllTrim(cConta)+"' AND "
	IF TcSrvType() == "AS/400"
		cQuery += "@DELET@ <> '*'"
	Else
		cQuery+= "D_E_L_E_T_ <> '*'"
	Endif
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), '__TRBCT1', .F., .T.)
	While !Eof()
		IF Len(Alltrim(cConta)) != Len(Alltrim(CT1_CONTA))
			dbSkip()
			Loop
		Endif
		nSaldo += SaldoCT7(CT1_CONTA,dData,cMoeda,cTpSald,"CTBXFUN")[nQualSaldo]
		dbSelectArea("__TRBCT1")
		dbSKip()
	End
	dbCloseArea()
#ELSE
	For ni := 1 to Len(CT1->CT1_CONTA)
		IF Subs(cConta,ni,1) == "?"
			Exit
		Endif
		cStart += Subs(cConta,ni,1)
		cEnd += Subs(cConta,ni,1)
	Next
	cStart += Space(Len(CT1->CT1_CONTA)-Len(cStart))
	cEnd += Replicate("z",Len(CT1->CT1_CONTA)-Len(cEnd))
	dbSelectArea("CT1")
	dbSeek(cFil+cStart,.t.)
	While !Eof() .and. CT1_CONTA <= cEnd .and. CT1_FILIAL == cFil
		lOk := .t.
		IF Len(Alltrim(cConta)) != Len(Alltrim(CT1_CONTA))
			lOk := .f.
		Endif
		IF lOK
			For ni := 1 To Len(cConta)
				cByte := Subs(cConta,ni,1)
				IF Subs(CT1_CONTA,ni,1) != cByte .and. cByte != "?"
					lOk := .f.
				Endif
				IF !lOk
					Exit
				Endif
			Next
		Endif
		IF lOk
			nSaldo += SaldoCT7(CT1_CONTA,dData,cMoeda,cTpSald,"CTBXFUN")[nQualSaldo]
			dbSelectArea("CT1")
		Endif
		dbSkip()
	End
	CT1->(dbGoto(nReg))
	CT1->(dbSetOrder(nOrd))
#ENDIF
IF !Empty(cAlias)
	dbSelectArea(cAlias)
Endif
Return nSaldo


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ MaAllNum   ³ Autor ³ Sergio Silveira     ³ Data ³ 10/12/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Indica se uma string e formada apenas por numeros          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := MaAllNum(ExpC1)                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 := String                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 := Retorno                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                						                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function MaAllNum(cString)

Local lRet  := .T.
Local nLoop := 0

For nLoop := 1 To Len( cString )
	If !IsDigit( SubStr( cString, nLoop, 1 ) )
		lRet := .F.
		Exit
	EndIf
Next nLoop

Return(lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ MaConvNNota³ Autor ³ Sergio Silveira     ³ Data ³ 10/12/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Preenche o numero da nota fiscal com zeros a esquerda      ³±±
±±³          ³ mesmo quando o conteudo for alfanumerico                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpC1 := MaConvNNota(ExpC1)		                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 := Simbolo da Moeda				                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpN1 := N£mero da Moeda  				                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                						              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MaConvNNota(cX5Descri,nTamNota)

Local cNumNota   := ""
Local cParcNum   := ""
DEFAULT nTamNota := Len( SF2->F2_DOC )

If MaAllNum( AllTrim( cX5Descri ) )
  	cNumNota := StrZero( Val( cX5Descri ),nTamNota,0 )
Else
	cParcNum := AllTrim( cX5Descri )
	cNumNota := Replicate( "0",nTamNota - Len( cParcNum ) ) + cParcNum
EndIf

Return( cNumNota )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CanExeFor ³ Autor ³ Ernani Forastieri    ³ Data ³ 28/09/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para validar se nao ha rotinas de menu e funções de ³±±
±±           ³ cadastro no campo fórmulas. 								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CanExeFor( cExpressao, cNomeRot )
Local cAux   := Upper( StrTran( cExpressao, ' ', '' ) )
Local cCarac := '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ'
Local cLit   := ''
Local lRet   := .T.
Local nPos   := 0

If !FindFunction( 'FWFindMnuAdmin' )
	Return lRet
EndIf

While ( nPos := At( '(', cAux ) ) > 0
	cLit := ''
	nAux := nPos - 1

	While Subs( cAux, nAux, 1 ) $ cCarac .AND. nAux > 0
		cLit := Subs( cAux, nAux, 1 ) + cLit
		nAux--
	End

	If cLit != "CELL"
		If !Empty(cLit) .And. (FWFindMnuAdmin(cLit,,,.T.) .Or. Subs(cLit,1,10) $ "AXCADASTRO|AXINCLUI|AXALTERA|AXDELETA|MBROWSE")
			cNomeRot := cLit
			lRet := .F.
			Exit
		EndIf
	EndIf
	cAux := SubStr( cAux, nPos + 1 )

End

If lRet
	If Upper(Subs(cExpressao, 1, 4)) == "SPF_"
		nPos := At( '(', cExpressao )
		cNomeRot := Subs(cExpressao, 1, nPos-1)
		lRet := .F.
	EndIf
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VerFormRep ³ Autor ³ Marcia Junko        ³ Data ³ 19/01/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao criada para verificar se o tratamento das fórmulas  ³±±
±±           ³ está compatível com a Lib para a utilização via TReport.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Validação no cadastro de fórmulas do Protheus Report       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function VerFormRep()
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ CarregaTipoFrete³ Autor ³ Julio C.Guerato  ³ Data ³ 13/09/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega Tipos de Frete 										³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ CarregaTipoFrete()							  		        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CarregaTipoFrete()
Local aFrete:={}

aFrete  := {" ","C-CIF","F-FOB","T-Por Conta Terceiros","R-Por Conta Remetente","D-Por Conta Destinatário","S-Sem Frete"}

Return aFrete

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ RetTipoFrete³ Autor ³ TOTVS       		  ³ Data ³ 13/09/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorno o Tipo de Frete										³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ RetTipoFrete(ExpC1,ExpN1,ExpN2)				  		        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SIGACOM													    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function RetTipoFrete(cFrete)
Local cRet:=""

cFrete:=Trim(cFrete)

If cFrete=="C"
	cRet:="C-CIF"
ElseIf cFrete=="F"
	cRet:="F-FOB"
ElseIf cFrete=="T"
	cRet:="T-Por Conta Terceiros"
ElseIf cFrete=="R"
	cRet:="R-Por Conta Remetente"
ElseIf cFrete=="D"
	cRet:="D-Por Conta Destinatário"
ElseIf cFrete=="S"
	cRet:="S-Sem Frete"
Else
	cRet:=""
EndIf

Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ChkF3Deneg³ Rev.  ³Vendas e CRM           ³ Data ³06.03.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se o numero da nota fiscal nao foi denegado        ³±±
±±³          ³ou cancelada ou inutilizada pela Sefaz (SF3)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica que o numero ja foi utilizado e está denegada ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Serie da Nota fiscal                                 ³±±
±±³          ³ExpC2: Numero da Nota Fiscal                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function ChkF3Deneg( cIniSER,cIniNUM )

Local aArea    := GetArea()
Local aAreaSF3 := SF3->(GetArea())
Local lBack    := .F.
#IFDEF TOP
Local cQuery   := ""
#ENDIF
Local lGrpCNPJ := MaIsNumCgc() // Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local aFilCGC  := {"",""}

If cPaisLoc == "BRA"
	#IFDEF TOP
		If TcSrvType()<>"AS/400"
			SF3->(dbCommit())
			cQuery := "SELECT F3_ENTRADA,F3_NFISCAL,F3_SERIE,F3_CLIEFOR,F3_LOJA,F3_CFO,F3_ESTADO,F3_EMISSAO,F3_DTCANC,F3_CODRSEF,F3_FORMUL "
			cQuery += "FROM "+RetSqlName("SF3")+" SF3 "

			If lGrpCNPJ // Utilizando o conceito de Agrupamento por CNPJ

				aFilCGC := MatFilCgc(SM0->M0_CGC,"SF3") // Retorna o Compartilhamento conforme CNPJ

				cQuery += " WHERE SF3.F3_FILIAL IN "+ FormatIN(aFilCGC[1],aFilCGC[2]) +" AND "

			Else

				cQuery += "WHERE SF3.F3_FILIAL='"+xFilial("SF3")+"' AND "

			Endif
			cQuery += "SF3.F3_SERIE='"+cIniSer+"' AND "
			cQuery += "SF3.F3_NFISCAL='"+cIniNum+"' AND "
			//cQuery += "SF3.F3_DTCANC NOT IN ('') AND "
			cQuery += "(SF3.F3_CFO LIKE '5%' OR SF3.F3_CFO LIKE '6%' OR SF3.F3_CFO LIKE '7%' OR SF3.F3_FORMUL='S' ) AND "
			cQuery += "SF3.D_E_L_E_T_=' ' "

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"CHKF3NOT",.T.,.T.)

			If !(Empty(CHKF3NOT->F3_DTCANC)) .And. !(Empty(CHKF3NOT->F3_CODRSEF))
				If CHKF3NOT->F3_CODRSEF $ RetCodDene() .Or. CHKF3NOT->F3_CODRSEF $ "'101','102','151'"
			   		lBack := .T.
				EndIf
			EndIf
			dbCloseArea()
			dbSelectArea("SF3")
		Else
	#ENDIF
		DbSelectArea( "SF3" )
		DbSetOrder( 5 )
		If MsSeek( xFilial("SF3")+cIniSER+cIniNUM,.F.)
			While !Eof() .And. (xFilial("SF3")+cIniSER+cIniNUM) == (SF3->F3_FILIAL+SF3->F3_SERIE+SF3->F3_NFISCAL) .And. !lBack
				If (SF3->F3_FORMUL == "S" .Or. Substr(SF3->F3_CFO,1,1) > "5")
					If !(Empty(SF3->F3_DTCANC)) .And. !(Empty(SF3->F3_CODRSEF))
						If SF3->F3_CODRSEF $ RetCodDene() .Or. SF3->F3_CODRSEF $ "'101','102','151'"
			   				lBack := .T.
						EndIf
					EndIf
				EndIf
				DbSelectArea("SF3")
				DbSkip()
			EndDo
		EndIf
		#IFDEF TOP
		EndIf
	#ENDIF
Endif

If lBack .And. IsInCallStack("FTVDENota") .And. SuperGetMV("MV_LJNFSXE") .And. (SuperGetMV("MV_TPNRNFS")<>"1")
	Help(" ",1,"LJ040NOTA")
Endif

RestArea(aAreaSF3)
RestArea(aArea)
Return( lBack )

//---------------------------------------------------------------
/*/{Protheus.doc} MaIsNumCgc
Funcao para verificar a utilizacao da numeracao de documentos de
saida agrupadas por CNPJ atraves da tabela SD9

@author Daniel Magalhaes
@since 17/09/2013
@version MP11.8
@return logic, T/F para a utilizacao de numeracao de doc de saida por CNPJ
/*/
//---------------------------------------------------------------
Function MaIsNumCgc()
Local aArea      := GetArea()
Local lRelease   := GetRpoRelease("R8")
Local lMVFATGCGC := GetMv("MV_FATGCGC",,.F.)
Local cMVTpNrNFS := GetMV("MV_TPNRNFS",,"1")
Local lCpoSD9    := SD9->(FieldPos("D9_CNPJ")) > 0 .And. SD9->(FieldPos("D9_FILORI")) > 0 // Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local lRet       := .F.
Local cQuery     := ""
Local cQryAl     := GetNextAlias()
Local cConctAs   := ""

//Valida se esta no release correto e o parametro para agrupamento por CNPJ esta ativo
If lRelease .And. lMVFATGCGC

	//Verifica se os campos de controle estao cadastrados no dicionario de dados
	If lCpoSD9
		lRet := .T.
	Else
		Final("Configure os campos de controle de numeração D9_CNPJ e D9_FILORI.")
	EndIf

EndIf

If cMVTpNrNFS == "3"
	cConctAs := IIf( AllTrim(Upper(TCGetDB())) $ "ORACLE" , "" , " AS" )

	If lRet
		//Filial preenchida E Data de Uso em branco
		cQuery := " select" + CRLF
		cQuery += "    count(*)" + cConctAs + " ERR_QTD" + CRLF
		cQuery += " from" + CRLF
		cQuery += "    " + RetSqlName("SD9") + cConctAs + " SD9" + CRLF
		cQuery += " where" + CRLF
		cQuery += "    SD9.D9_FILIAL     <> '" + Space( FWSizeFilial() ) + "'" + CRLF
		cQuery += "    and SD9.D9_DTUSO   = ''" + CRLF
		cQuery += "    and SD9.D_E_L_E_T_ = ' '" + CRLF

	Else
		//Filial em branco
		cQuery := " select" + CRLF
		cQuery += "    count(*)" + cConctAs + " ERR_QTD" + CRLF
		cQuery += " from" + CRLF
		cQuery += "    " + RetSqlName("SD9") + cConctAs + " SD9" + CRLF
		cQuery += " where" + CRLF
		cQuery += "    SD9.D9_FILIAL      = '" + Space( FWSizeFilial() ) + "'" + CRLF
		cQuery += "    and SD9.D_E_L_E_T_ = ' '" + CRLF
	EndIf

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQryAl,.F.,.T.)

	If !(cQryAl)->( Eof() ) .And. (cQryAl)->ERR_QTD > 0
		Final( "Foram encontradas inconsistências no SD9, execute a rotina MATA470" )
	EndIf

	(cQryAl)->( DbCloseArea() )

EndIf

RestArea(aArea)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MatFilCgc
Pesquisa no cadastro de empresas (SM0) as filiais que utilizam o
numero de CNPJ informado pelo parametro

@author By Wise Consulting
@since 11/09/2013
@version MP11.5

@param cCgcEmp, character, String contendo o numero do CNPJ do grupo de filiais a serem pesquisados
@param cAliasFil, character, Alias para verificar o compartilhamento entre empresas, unidades de negocio e filiais
@return array, Vetor contendo as filiais para o CNPJ
@obs
Formato do array de retorno
aRet[1] := "E1U1F1;E1U1F2" //String concatenada
aRet[2] := ";" //Caracter Separador
aRet[3] := {"E1U1F1","E1U1F2"} //Vetor por filial
/*/
//-------------------------------------------------------------------
Function MatFilCgc( cCgcEmp, cAliasFil )
Local aArea   := GetArea()
Local aAreaM0 := SM0->( GetArea() )
Local aRet    := {}
Local aAux    := {}
Local cGrEmp  := SM0->M0_CODIGO
Local cFilTmp := ""
Local cFilRet := ""
Local nPos    := 0

Default cCgcEmp   := ""
Default cAliasFil := "SF2"

SM0->( DbSetOrder(1) )

SM0->( DbSeek( cGrEmp ) )

//Varre o grupo de empresa atual
While !SM0->( Eof() ) .And. SM0->M0_CODIGO == cGrEmp

	//Verifica o CNPJ
	If AllTrim(SM0->M0_CGC) == AllTrim(cCgcEmp)

		//Executa o xFilial para o alias
		cFilTmp := SM0->M0_CODFIL
		cFilTmp := FWxFilial( cAliasFil, cFilTmp )

		//Se ja nao teve nenhuma ocorrencia, adiciona no retorno
		If ( nPos := aScan( aAux, cFilTmp ) == 0 )
			aAdd( aAux, cFilTmp )

			cFilRet += IIf( Empty(cFilRet), "", ";" ) + cFilTmp
		EndIf
	EndIf

	SM0->( DbSkip() )
EndDo

aAdd( aRet, cFilRet )
aAdd( aRet, ";"     )
aAdd( aRet, aAux    )

SM0->( RestArea( aAreaM0 ) )
RestArea( aArea )
Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MatDocCgc
Funcao para retornar o ultimo documento de saida gerado para o
cnpj da filial conforme a serie do documento

@author By Wise Consulting
@since 20/09/2013
@version MP11.8

@param cCgcEmp, character, String contendo o numero do CNPJ do grupo de filiais a serem pesquisados
@param cSerDoc, character, Serie do documento de saida
@param nTamDoc, numeric, Quantidade de digitos do numero do documento
@return character, Numero do proximo documento para a serie e cnpj
/*/
//-------------------------------------------------------------------
Function MatDocCgc( cCgcEmp, cSerDoc, nTamDoc, cSerieId )
Local aArea     := GetArea()
Local aAreaAD0  := AD0->( GetArea() )
Local cNumDoc   := ""
Local cQuery    := ""
Local cQryAlias := GetNextAlias()
Local aFilCGC   := {}
Local lUsaNewKey:= TamSX3("F2_SERIE")[1] == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cConctAs  := ""

Default cCgcEmp := SM0->M0_CGC
Default cSerDoc := Space( TamSX3("AD0_SERIE")[1] )
Default nTamDoc := 6 //Conforme definicao na funcao SX5NumNota para a condicao ( cPaisloc == "BRA" .And. Len(AllTrim(cNumNF)) < Len(SF2->F2_DOC) )
Default cSerieId:= cSerDoc

If lUsaNewKey
	AD0->( DbSetOrder(2) )
Else
	AD0->( DbSetOrder(1) )
EndIf

If !Empty(cSerDoc)

	If AD0->( DbSeek( xFilial("AD0")+cCgcEmp + cSerDoc ) )

		cNumDoc := AD0->AD0_DOC

	Else
		cConctAs := IIf( AllTrim(Upper(TCGetDB())) $ "ORACLE" , "" , " AS" )

		cQuery := " select" + CRLF
		cQuery += "    coalesce(max( SD9.D9_DOC ), 'NOREG')" + cConctAs + " MAX_DOC" + CRLF
		cQuery += " from" + CRLF
		cQuery += "    " + RetSqlName("SD9") + cConctAs + " SD9" + CRLF
		cQuery += " where" + CRLF
		cQuery += "    SD9.D9_CNPJ        = '" + cCgcEmp + "'" + CRLF

		If lUsaNewKey
			cQuery += "    and SD9.D9_SDOC   = '" + cSerDoc + "'" + CRLF
 		Else
			cQuery += "    and SD9.D9_SERIE   = '" + cSerDoc + "'" + CRLF
 		EndIf

		cQuery += "    and SD9.D9_DTUSO  <> ''" + CRLF
		cQuery += "    and SD9.D_E_L_E_T_ = ' '"

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQryAlias,.T.,.T.)

		If !(cQryAlias)->( Eof() ) .And. (cQryAlias)->MAX_DOC <> 'NOREG'

			cNumDoc := Soma1( AllTrim( (cQryAlias)->MAX_DOC ), nTamDoc )

		Else

			(cQryAlias)->( DbCloseArea() )

			aFilCGC := MatFilCgc(SM0->M0_CGC,"SF2") // Retorna o Compartilhamento conforme CNPJ
			cQryAlias := GetNextAlias()

			cQuery := " select" + CRLF
			cQuery += "    coalesce(max( SF2.F2_DOC ), 'NOREG')" + cConctAs + " MAX_DOC" + CRLF
			cQuery += " from" + CRLF
			cQuery += "    " + RetSqlName( "SF2" ) + cConctAs + " SF2" + CRLF
			cQuery += " where" + CRLF
			cQuery += "    SF2.F2_FILIAL      in " + FormatIN(aFilCGC[1],aFilCGC[2]) + CRLF

			If lUsaNewKey
				cQuery += "    and SF2.F2_SDOC    = '" + cSerDoc + "'" + CRLF
			Else
				cQuery += "    and SF2.F2_SERIE   = '" + cSerDoc + "'" + CRLF
			EndIf

			cQuery += "    and SF2.D_E_L_E_T_ = ' '"

			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQryAlias,.T.,.T.)

			If !(cQryAlias)->( Eof() ) .And. (cQryAlias)->MAX_DOC <> 'NOREG'

				cNumDoc := Soma1( AllTrim( (cQryAlias)->MAX_DOC ), nTamDoc )

			EndIf

			(cQryAlias)->( DbCloseArea() )

		EndIf

		If !VldSX5Num( cNumDoc, cSerDoc, .F. ) .Or. Empty(cNumDoc)
			cNumDoc := StrZero(1,nTamDoc)
		EndIf

		RecLock("AD0",.T.)

		AD0->AD0_FILIAL:= xFilial("AD0")
		AD0->AD0_CNPJ  := cCgcEmp

		SerieNfId("AD0",1,"AD0_SERIE",,,, IIf(Empty(cSerieId) .And. !Empty(cSerDoc),cSerDoc,cSerieId))

		AD0->AD0_DOC   := cNumDoc
		AD0->( MsUnlock() )

	EndIf

EndIf

AD0->( RestArea( aAreaAD0 ) )
RestArea(aArea)

Return cNumDoc

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MSOpenTemp³ Rev.  ³TOTVS S/A              ³ Data ³15.01.2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³Funcao utilizada para verificar se o ambiente do cliente    ³±±
±±³          ³esta preparado para utilizar a nova funcao FWOpenTemp.      ³±±
±±³          ³OBSERVACAO: A nova funcao ira criar o arquivo temporario    ³±±
±±³          ³em memoria.                                                 ³±±
±±³          ³IMPORTANTE: A nova funcao somente pode ser utilizada em modo³±±
±±³          ³EXCLUSIVO!!!                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Nome do Alias Temporario             (OBRIGATORIO)   ³±±
±±³          ³ExpA1: Estrutura para criacao do temporario (OBRIGATORIO)   ³±±
±±³          ³ExpC2: Nome Fisico do Arquivo Temporario    (OPCIONAL)      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. -> Arquivo aberto                                ³±±
±±³          ³       .F. -> Arquivo nao foi aberto                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MSOpenTemp(cAliasTemp,aStrucTemp,cArqTemp)

Default cAliasTemp := GetNextAlias()
Default aStrucTemp := {}
Default cArqTemp   := Nil

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³__lNewTemp -> Variavel estatica utilizada para avaliar se o ³
//³              ambiente possui os requisitos para utilizar o |
//³              arquivo temporario em memoria.                |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
__lNewTemp :=	FindFunction("FWOpenTemp")	.And. GetBuild() >= "7.00.121227P-20130730"

// Arquivo Temporario em Memoria
If  __lNewTemp

	If cArqTemp == Nil .Or. Empty(cArqTemp)
		cArqTemp := FWOpenTemp(cAliasTemp,aStrucTemp)
	Else
		FWOpenTemp(cAliasTemp,aStrucTemp,cArqTemp)
	EndIf

// Arquivo Temporario em Disco
Else

	cArqTemp := CriaTrab(aStrucTemp)
	dbUseArea(.T.,,cArqTemp,cAliasTemp,.F.,.F.)

EndIf

Return (Select(cAliasTemp)>0)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MSCloseTemp ³ Rev. ³TOTVS S/A             ³ Data ³15.01.2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³Funcao utilizada para verificar se o ambiente do cliente    ³±±
±±³          ³esta preparado para utilizar a nova funcao FWCloseTemp.     ³±±
±±³          ³OBSERVACAO: A nova funcao ira apagar o arquivo temporario   ³±±
±±³          ³em memoria.                                                 ³±±
±±³          ³IMPORTANTE: A nova funcao somente pode ser utilizada em modo³±±
±±³          ³EXCLUSIVO!!!                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela temporario                           ³±±
±±³          ³ExpC2: Nome fisico do arquivo temporario                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nulo                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MSCloseTemp(cAliasTemp,cArqTemp)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³__lNewTemp -> Variavel estatica utilizada para avaliar se o ³
//³              ambiente possui os requisitos para utilizar o |
//³              arquivo temporario em memoria.                |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
__lNewTemp :=	FindFunction("FWOpenTemp")	.And. GetBuild() >= "7.00.121227P-20130730"

// Fecha o arquivo temporario que esta em memoria
If __lNewTemp

	//Fecha o arquivo temporario em memoria
	FWCLOSETEMP(cAliasTemp)

// Fecha a tabela temporaria e Apaga o arquivo em disco
Else

	//Fecha a tabela temporaria
	If Select(cAliasTemp)>0
		(cAliasTemp)->(dbCloseArea())
	EndIf
	//Apaga o arquivo temporario em disco
	If !(cArqTemp==Nil .Or. Empty(cArqTemp))
		Ferase(cArqTemp)
	EndIf
EndIf

Return Nil

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³ POSTABCTB  ³ Autor ³ Guadalupe Santacruz ³ Data ³06/02/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Prepara la tabla que usara el asiento estándar.            ³±±
±±³Descri‡…o ³ Selecciona los registros de la tabla CWO.                  ³±±
±±³			  ³ Asiento estándar (cwo_codpto=ct5_lanpad),         	        ³±±
±±³	          ³ y que sea de usuario (cwo _tipo='U') 					    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ POSTABCTB()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                	      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATXFUNA                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum						                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function POSTABCTB(cLandPad)

//Local cLandPad 	:= CT5->CT5_LANPAD // Código asiento estándar
Local cTipUsua	:= 'U'
Local cTipFIN		:= 'F'
Local nX:=0
Local cQry:=''
Local cfilcwo:=xFilial("CWO")
Local cAliasCWO:=''
Local nRegTbl:=0
Local cValLlave:=''
Local cLlave:=''

Default cLandPad 	:= CT5->CT5_LANPAD // Código asiento estándar

If __aArrCWO==NIL
	__aArrCWO := {}
	__cStrCWO := ""

	cAliasCWO:=CriaTrab(Nil,.F.)
	cQry:=	"SELECT  CWO_TABLA,CWO_LLAVE,CWO_CACHE, CWO_FILIAL,CWO_INDVAL, CWO_TIPO, CWO_CODPTO FROM "+RetSqlName("CWO") +" CWO WHERE "
	cQry+= " ( CWO_TIPO ='"+cTipUsua+"' OR CWO_TIPO ='"+cTipFIN+"') AND  CWO.D_E_L_E_T_  = ' '"
	cQry+= " ORDER BY CWO_FILIAL,CWO_CODPTO,CWO_TIPO "
	cQry := ChangeQuery(cQry)

	DbUseArea( .T., 'TOPCONN', TCGENQRY(,, cQry), cAliasCWO, .T., .T. )

	Do While  (cAliasCWO)->(!Eof())
		//Cachear la llave para evitar el GOTO en la CWO
		aadd(__aArrCWO,{(cAliasCWO)->CWO_FILIAL,(cAliasCWO)->CWO_CODPTO,(cAliasCWO)->CWO_CACHE,(cAliasCWO)->CWO_TABLA,(cAliasCWO)->CWO_LLAVE,{},VAL((cAliasCWO)->CWO_INDVAL), (cAliasCWO)->CWO_TIPO})
		__cStrCWO += (cAliasCWO)->CWO_CODPTO+"|"
		(cAliasCWO)->(DBSKIP())
	EndDo

	(cAliasCWO)->(DBCLOSEAREA())
EndIf

If cLandPad$__cStrCWO
	nx	:=aScan(__aArrCWO,{|x| allTrim(x[1])==allTrim(cfilcwo) .AND. allTrim(x[2])==allTrim(cLandPad)})

	do while  nx<=len(__aArrCWO) .and. nx>0 .AND.   cfilcwo==__aArrCWO[nx,1] .AND. cLandPad ==__aArrCWO[nx,2]


			If __aArrCWO[nx,8] == "U"
				DbSelectArea(__aArrCWO[nx,4])
				cLLave	  :=  __aArrCWO[nx,4]+"->("+ALLTRIM(__aArrCWO[nx,5])+")"
				cValLlave:=&cLLave



				//Si usa cache para esta tabla

				iF __aArrCWO[nx,3] == "1"

					//Verificar si la llave ya está cacheada

					nPos		:=	Ascan(__aArrCWO[nx,6],{|x| x[1]==cValLlave})

					//Si está, posiciono la tabla directamente


					If nPos > 0
						&(__aArrCWO[nx,4]+"->(MsGoTo("+alltrim(str(__aArrCWO[nx,6,npos,2]))+"))")

					//Si no está chacheada, la busco y la cacheo

					Else
						DBSETORDER(__aArrCWO[nx,7])
						If MsSeek(cValLlave)
							Aadd(__aArrCWO[nx,6],{cValLlave,(__aArrCWO[nx,4])->(Recno())})
						Endif
					Endif
				Else
					(MsSeek(cValLlave))
				Endif
			Else

				&(ALLTRIM(__aArrCWO[nx,5]))

			Endif

			nx++
	enddo
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³ EjeFor     ³ Autor ³ Alfredo Medrano     ³ Data ³16/01/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Regresará como resultado el código ADVPL (cwk_advpl)       ³±±
±±³			 ³ mediante el código de la fórmula del Asiento estándar.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ EjeFor(ExpC1)                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ xValor : código ADVPL                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATXFUNA                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1  :  código de la fórmula del Asiento estándar        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function EjeFor(cFormula)
Local cForm		:= " "
Local cAliCWK 	:= "CWK"
Local xRegreso:=Nil

DbSelectArea(cAliCWK)
(cAliCWK )->(dbSetOrder(1))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³La fórmula debe existir en el catálogo de formula (CWK).	³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If (cAliCWK )->(dbSeek(xFilial(cAliCWK )+cFormula))
	cForm := AllTrim((cAliCWK )->CWK_ADVPL )

	xRegreso:=&cForm
Else
 	Aviso( OemToAnsi(STR0056),OemToAnsi(STR0054) + cFormula + OemToAnsi(STR0055) + CT5->CT5_LANPAD , {OemToAnsi(STR0056)} ) //"Error. No se encontró la Formula " // " del asiento " // "Ok"
EndIf

Return xRegreso

//-------------------------------------------------------------------
/*/{Protheus.doc} blockUpd12
Exibe mensagem sobre bloqueio da utilização de updates na versão 12

@author Henrique Brugugnoli
@since 26/01/2015
@version 12
/*/
//-------------------------------------------------------------------
function blockUpd12()

local cMensagem := ""
local cCaption := "Bloqueio de Update"
local aButtons := {"Fechar","Mais Infos"}
local nReturn := 0
local cLink := "http://tdn.totvs.com/pages/viewpage.action?pageId=181965468"

cMensagem += "A partir da versão 12, o uso deste update foi descontinuado em função do novo procedimento para atualização do modelo de dados, o release incremental."
cMensagem += CRLF
cMensagem += CRLF
cMensagem += 'Para maiores informações clique abaixo em "Mais Infos" e saiba como funciona o novo procedimento.'

nReturn := aviso(cCaption,cMensagem,aButtons)

if ( nReturn == 2 )
	shellExecute( "Open", cLink, "", "", 1 )
endif

return


/*/{Protheus.doc} SomaCampos
//TODO retorna a soma do tamanho dos campos informados que foram separados por + para definição da variavel tipo char
//     quando utiliza para contatenação de valores
@author reynaldo
@since 14/02/2018
@version 1.0
@return numerico, tamanho definido
@param cListField, characters, os campos desejados separados por +
@type function
/*/
Function SomaCampos( cListField )
Local cField	:= ''
Local aFields	:= {}
Local i			:= 0
Local nSize		:= 0
Local aOldArea	:= GetArea()

cListField:= Upper(cListField)

/* -------------------------------------------------------------------------
Alimentando array com campos para comparaçao
------------------------------------------------------------------------- */
For i:= 1 To Len( cListField )
	If Subs( cListField, i, 1 ) == '+'
		Aadd( aFields, cField )
		cField:= ''
	Else
		cField += Subs( cListField, i, 1 )
	EndIf
Next i

Aadd( aFields, cField )

dbSelectArea( 'SX3' )
dbSetOrder( 2 )

/* -------------------------------------------------------------------------
Acumulando o tamaho dos campos encontrados na lista
------------------------------------------------------------------------- */
For i:= 1 To Len(aFields)
	If dbSeek(aFields[i])
		nSize += X3_TAMANHO
	EndIf
Next

RestArea(aOldArea)
Return(nSize)

//-------------------------------------------------------------------
/*/{Protheus.doc} ChkSD9Skip
Retorna o próximo número para a série selecionada, se houver pulo na
numeração no mesmo dia que está sendo faturado.
Obs.: Mesma regra utilizada na preparação do documento de saída (MATA461)

@author Squad CRM & FAT
@since 22/02/2019
@version 12
@param cSerieNF, character, Série do documento de saída
@param cNDocMax, character, Número do próximo documento de saída
@param lGrpCNPJ, logic, Numeração por agrupamento de CNPJ
@param lUsaNewKey, logic, Se utiliza o novo formato de gravação do Id
@return cRetNum, character, Número do próximo documento
/*/
//-------------------------------------------------------------------
Static Function ChkSD9Skip(cSerieNF,cNDocMax,lGrpCNPJ,lUsaNewKey)

Local cQry 		:= ""
Local cAliasNew := ""
Local dDtVazia  := CToD("")
Local cDocAnt	:= ""
Local cRetNum	:= ""
Local cCondWhere := ""
Local lD9DocExcl:= SD9->(ColumnPos("D9_DOCEXCL")) > 0

If lUsaNewKey
	cCondWhere := If(lGrpCNPJ,'D9_CNPJ == "'+SM0->M0_CGC +'" .And. D9_SDOC == "' + cSerieNF + '" ';
	,'D9_FILIAL == "'+xFilial("SD9")+'" .And. D9_SDOC == "' + cSerieNF + '" ' )
Else
	cCondWhere := If(lGrpCNPJ,'D9_CNPJ == "'+SM0->M0_CGC +'" .And. D9_SERIE == "' + cSerieNF + '" ';
	,'D9_FILIAL == "'+xFilial("SD9")+'" .And. D9_SERIE == "' + cSerieNF + '" ' )
EndIf

// Obtem o ultimo documento do dia anterior
cAliasNew := GetNextAlias()

cQry := "SELECT MAX(D9_DOC) D9_DOC FROM " + RetSqlName( "SD9" )

If lGrpCNPJ // Utilizando o conceito de agrupamento por CNPJ
	cQry += " WHERE D9_CNPJ = '" + SM0->M0_CGC + "' AND "
Else
	cQry += " WHERE D9_FILIAL = '" + xFilial("SD9") + "' AND "
Endif

If lUsaNewKey
	cQry += " D9_SDOC = '" + cSerieNF + "'
Else
	cQry += " D9_SERIE = '" + cSerieNF + "' 
EndIf

If lD9DocExcl
	cQry += "AND (( D9_DTUSO <> '" + Space(8) + "' AND D9_DTUSO < '" + DTOS(dDataBase) + "' AND D9_DOC <> '" + Space(Len(cNDocMax)) + "') OR D9_DOCEXCL = 'S')"
Else
	cQry += "AND D9_DTUSO <> '" + Space(8) + "' AND D9_DTUSO < '" + DTOS(dDataBase) + "' AND D9_DOC <> '" + Space(Len(cNDocMax)) + "'"
EndIf

cQry += " AND D_E_L_E_T_ = ' '"

cQry := ChangeQuery(cQry)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAliasNew,.F.,.T.)
If (cAliasNew)->(!(Eof())) .And. !Empty((cAliasNew)->D9_DOC)
	cDocAnt := (cAliasNew)->D9_DOC
	dbSelectArea("SD9")

	If lGrpCNPJ
		If lUsaNewKey
			SD9->(dbSetOrder(9)) // D9_CNPJ+D9_SDOC+DTOS(D9_DTUSO)+D9_DOC
		Else
			SD9->(dbSetOrder(4)) // D9_CNPJ+D9_SERIE+DTOS(D9_DTUSO)+D9_DOC
		EndIf
		SD9->(dbSeek(SM0->M0_CGC + cSerieNF + DToS(dDtVazia) + cDocAnt,.T.))
	Else
		If lUsaNewKey
			SD9->(dbSetOrder(6)) // D9_FILIAL+D9_SDOC+DTOS(D9_DTUSO)+D9_DOC
		Else
			SD9->(dbSetOrder(1)) // D9_FILIAL+D9_SERIE+DTOS(D9_DTUSO)+D9_DOC
		EndIf
		SD9->(dbSeek(xFilial("SD9") + cSerieNF + DToS(dDtVazia) + cDocAnt,.T.))
	EndIf

	While SD9->(!Eof()) .And. &cCondWhere
		If !Empty(SD9->D9_DTUSO) .Or. (lD9DocExcl .And. SD9->D9_DOCEXCL == 'S')
			SD9->(DBSkip())
		Else
			cRetNum := SD9->D9_DOC
			Exit
		EndIf
	EndDo
EndIf

(cAliasNew)->(DBCloseArea())
Return cRetNum

//Funcão de exec de teste para testar o comportamento antigo
function __disX3Cache()
	__findSx3Cache := .f.
	__findSGetMvCache := .f.
	__findTamSx3Cache := .f.
return

/*/{Protheus.doc} AtuVarOper
Função responsável por inicializar as variáveis staticas
@type function
@version 12
@author Squad Entradas
@since 06/04/2022
/*/
Static Function AtuVarOper()
Local nNumOP   := TamSX3("C2_NUM")[1]
Local nItemOP  := TamSX3("C2_ITEM")[1]
Local nSeqOP   := TamSX3("C2_SEQUEN")[1]
Local cSubstr  := If(TCGetDB() $ "ORACLE/POSTGRES","SUBSTR","SUBSTRING")

__cNumOP   := cSubstr + "(D4_OP,1," + cValToChar(nNumOP) + ")"
__cItemOP  := cSubstr + "(D4_OP," + cValToChar(nNumOP + 1) + "," + cValToChar(nItemOP) + ")"
__cSeqOP   := cSubstr + "(D4_OP," + cValToChar(nNumOP + nItemOP + 1) + "," + cValToChar(nSeqOP) + ")"

Return

