#Include "PCPXFUN.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWADAPTEREAI.CH"
#INCLUDE "fwlibversion.ch"

Static lIntSFC		:= ExisteSFC("SC2") .And. !IsInCallStack("AUTO650")

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±0±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Rodrigo Sart³14/10/98³XXXXXX³ Acerto na funcao ConvTime()              ³±±
±±³Rodrigo Sart³18/06/99³15632A³Acertada verificacao de Saldo por Operacao³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ ChkPCP   ³ Autor ³ Waldemiro L. Lustosa  ³ Data ³ 30/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Avalia o parƒmetro MV_PRECISA e os campos com binarios.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAPCP                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ChkPCP(lAltera)
Local lRet := .T.

Default lAltera := .F.

If lAltera
	DbSelectArea("SH7")
	DbSelectArea("SH9")
	SH7->(DbGoTop())
	SH9->(DbGoTop())
	If !(SH7->(EOF()) .Or. SH9->(EOF()))
		lRet := .F.
		Help(" ",1,"SH7SH9DADOS",,"Somente é possivel alterar o parametro MV_PRECISA, se as tabelas SH7 e SH9 estiverem vazias. Somente assim é possivel garantir a integridade das informações")
	EndIf
EndIf

Return( lRet )

	/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³A680Prod	³ Autor ³ Marcelo Bomura Abe	³ Data ³ 19.01.94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Pega o Campo Produto para a funcao CONPAD1 no CASE=SH8. 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³A680Prod													  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³MATA680													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A680Prod()
dbSelectArea("SC2")
dbSeek(cFilial+SubStr(SH8->H8_OP,1,6)+SubStr(SH8->H8_OP,7,2)+SubStr(SH8->H8_OP,9,3)+Right(SH8->H8_OP,Len(SC2->C2_ITEMGRD)) )
dbSelectArea("SH8")
Return SC2->C2_PRODUTO
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³A680SalOpe³ Autor ³ Marcelo Bomura Abe	³ Data ³ 19.01.94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Calcula o Saldo Por Operacao Alocada.						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³A680SalOpe(Void)											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³MATA680													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A680SalOpe()
Local nSaldoPCP:=0
Local nRet:=0
Local aArea:=GetArea()

dbSelectArea("SC2")
If dbSeek(cFilial+SubStr(SH8->H8_OP,1,6)+SubStr(SH8->H8_OP,7,2)+SubStr(SH8->H8_OP,9,3)+Right(SH8->H8_OP,Len(SC2->C2_ITEMGRD)) )
	dbSelectArea("SH6")
	dbSetOrder(1)
	dbSeek(xFilial()+SH8->H8_OP+SC2->C2_PRODUTO+SH8->H8_OPER)
	While !Eof() .And. H6_FILIAL+H6_OP+H6_PRODUTO+H6_OPERAC == xFilial("SH8")+SH8->H8_OP+SC2->C2_PRODUTO+SubStr(SH8->H8_OPER,1,2)
		If SH8->H8_RECURSO == SH6->H6_RECURSO .And. SH8->H8_SEQROTA == SH6->H6_SEQ .And. SH8->H8_DESDOBR == SH6->H6_DESDOBR
			If SH8->H8_SEQCARG == SH6->H6_SEQCARG
				nSaldoPCP += H6_QTDPROD+H6_QTDPERD+H6_PERDANT
			EndIf
		Endif
		dbSkip()
	End
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica saldo no arquivo de operacoes (caso nao tenha ocorrido³
//³ apontamento de todas operacoes) ou saldo no arquivo de OPs     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nRet:=Max(0,SH8->H8_QUANT - nSaldoPCP)
RestArea(aArea)
Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Bit2Tempo ³ Autor ³ Waldemiro L. Lustosa  ³ Data ³ 08/10/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Tranforma Numero de Bits em Tempo de Operacao              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpC1=Bit2Tempo(ExpN2)                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Retorna o tempo de Operacao no formato "HHHH:MM"   ³±±
±±³          ³ ExpN2 = Numero de Bits a ser transformado                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAPCP                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Bit2Tempo(nBits,lAvalia)
Local nHoras, cTempo, nBitsMin, nMinutos, nTamHoras
Local nPrecisao := GetMV("MV_PRECISA")

nHoras := Int( nBits / nPrecisao )

nTamHoras := IIf( lAvalia == NIL, 4, Len(Alltrim(Str(nHoras,8,0))) )

nTamHoras := IIf( nTamHoras == 1, 2, nTamHoras )

cTempo := StrZero( nHoras, nTamHoras, 0)

nBitsMin := ( ( nBits / nPrecisao ) - Int( nBits / nPrecisao ) ) * nPrecisao
nMinutos := ( 60 / nPrecisao ) * nBitsMin

cTempo += ":"+StrZero( nMinutos, 2, 0)

Return cTempo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ PosiMaq  ³ Autor ³ Ary Medeiros          ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a posicao da maquina dentro do arquivo binario     ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpN1=Posimaq(ExpC2,ExpA3)                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Retorna a posiao da maquina                        ³±±
±±³          ³ ExpC2 = Codigo da maquina a ser localizada                 ³±±
±±³          ³ ExpA3= Array com dados do arquivo binario                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAPCP                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PosiMaq(cMaq,cIndex)
Return((At(cMaq,cIndex)-1)/7)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ ChkBatchOP  ³ Autor ³ Waldemiro Lustosa  ³ Data ³ 27/02/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Fun‡„o que verifica se todas as OPs/SCs filhas foram gera- ³±±
±±³          ³ das a partir das Ordens de Produ‡„o cadastradas.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA690                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ChkBatchOP()
Local lRet := .F.
Local cAlias := Alias()

a650RegOPI(@lRet)
dbSelectArea(cAlias)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³  TransHora  ³ Autor ³ Waldemiro Lustosa  ³ Data ³ 17/01/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Avalia a Picture a ser impressa para Horas (C)entesimais ou ³±±
±±³          ³(N)ormais.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ TransHora(ExpC1,ExpC2,ExpN1,ExpC3)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Campo a ser impresso                               ³±±
±±³          ³ ExpC2 = Tipo de hora utilizada (MV_TPHR)                   ³±±
±±³          ³ ExpN1 = Coluna em que deve ser impresso o campo            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TransHora(cCpo,cTipo,nColuna,cTot)
Local cPict,nHora,nMinuto,cString
cCampo:=cCpo
If cTot==NIL
	cTot:=""
Else
	cCpo := cTot
Endif
If cTipo=="C"
	@ li,nColuna PSay &cCpo Picture PesqPictQT(Subs(cCampo,6,Len(cCampo)-5),9)
Else
	nHora	  := Int(&cCpo)
	nMinuto := (&cCpo-nHora)*(.6)*100
	cString := StrZero(nHora,5)+StrZero(nMinuto,2)
	@ li,nColuna+1 PSay Transform(cString,'@R 99999:99')
Endif
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ ConvTime ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 12.03.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Converte o tempo em bits para impressao de acordo com o    ³±±
±±³          ³ parametro selecionado (MV_TPHR). Se o parametro do tempo   ³±±
±±³          ³ estiver centesimal, o retorno ser  numerico, se estiver    ³±±
±±³          ³ normal o retorno ser  caracter.                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ConvTime(ExpN1,ExpN2,ExpC1)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Tempo em Bits                                      ³±±
±±³          ³ ExpN2 = Tempo no formato centesimal                        ³±±
±±³          ³ ExpC1 = Tempo no formato normal                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ RELATORIOS PCP                                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConvTime(nBits,nTempoCen,cTempoNor,cForcaTipo)
Static cTipoTemp:=""
Local nPos:=0,nTempo:=CriaVar("G2_TEMPAD")
Local cTempo:=""
Default cForcaTipo := ""
If Empty(cTipoTemp)
	cTipoTemp:=GetMV("MV_TPHR")
EndIf
If !Empty(cForcaTipo)
	cTipoTemp:=cForcaTipo
EndIf
If nBits # NIL .And. ValType(nBits) == "N"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Obtem o horario no formato NORMAL (00:00)                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cTempo:=Bit2Tempo(nBits)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso necessario obtem o horario no formato CENTESIMAL (00.00)³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cTipoTemp == "C"
		nPos	:=AT(":",cTempo)
		nTempo:=Val(Substr(cTempo,1,nPos-1)+"."+Substr(cTempo,nPos+1))
		nTempo:=Int(nTempo)+(((nTempo-Int(nTempo))/60)*100)
	EndIf
ElseIf nTempoCen # NIL .And. ValType(nTempoCen) == "N"
	If cTipoTemp == "C"
		nTempo:=nTempoCen
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Tranf. o horario CENTESIMAL (0.00) no formato NORMAL (00:00) ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cTempo:=StrZero(nTempoCen,5,2)
		nPos  :=AT(".",cTempo)
		cTempo:=(Substr(cTempo,1,nPos-1)+":"+Substr(cTempo,nPos+1,2))
	EndIf
ElseIf cTempoNor # NIL .And. ValType(cTempoNor) == "C"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Obtem o horario no formato NORMAL (00:00)                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cTipoTemp == "N"
		cTempo:=cTempoNor
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Caso necessario obtem o horario no formato CENTESIMAL (00.00)³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPos	:=AT(":",cTempoNor)
		nTempo:=Val(Substr(cTempoNor,1,nPos-1)+"."+Substr(cTempoNor,nPos+1))
		nTempo:=Int(nTempo)+(((nTempo-Int(nTempo))/60)*100)
	EndIf
EndIf
Return IF(cTipoTemp=="C",nTempo,cTempo)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ TimePict ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 12.03.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna a picture para hora centesimal ou normal           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ TimePict()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ RELATORIOS PCP                                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TimePict()
Static cTipoTemp:=""
Local cPicture:=""
If Empty(cTipoTemp)
	cTipoTemp:=GetMV("MV_TPHR")
EndIf
If cTipoTemp == "C"
	cPicture := "@E " +Replicate("9",TamSx3("H6_TEMPO")[1]-3) +".99"
EndIf
Return cPicture

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ConvTimeH6 ³ Autor ³ Marcelo Iuspa         ³ Data ³ 03/10/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Converte tempo centesimal para o formato solicitado         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ ExpC1:=ConvTimeH6(ExpN1, ExpC2)                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Tempo convertido de acordo com parametro informado  ³±±
±±³          ³ ExpN1 = Identifica qual o formato de hora desejado, sendo:  ³±±
±±³          ³         1=Retorna de acordo com MTA680 (mv_par03);          ³±±
±±³          ³         2=Retorna de acordo com MV_TPHR                     ³±±
±±³          ³         3=Retorna formato normal                            ³±±
±±³          ³         4=Retorna formato centesimal                        ³±±
±±³          ³ ExpC2 = Hora a ser convertida. Se Nil, usa H6_TEMPO         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA680/MATA681                                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
*
* REMOVER ESTA FUNCAO POSTERIORMENTE (Obs. Em 27/01/2003)
*
Function ConvTimeH6(nTipo, cTime)
// mv_par03 - Tempo do Apontamento (1) Normal (2) Centesimal
// nTipo: 1=Retorna de acordo com MTA680 (mv_par03);
//        2=Retorna de acordo com MV_TPHR
//        3=Retorna formato normal
//        4=Retorna formato centesimal
// Obs  : Parametro recebido devera ser sempre no formato centesimal
Local nPar03    := Posicione("SX1", 1, "MTA68003", "X1_PRESEL")
Local cTpHr     := GetMV("MV_TPHR")
Local nPos, nTempo, nHoras, nMinutos
Local cResult

cTime := If(cTime==Nil,SH6->H6_TEMPO,cTime)
nTipo := If(nTipo==Nil,1,nTipo)
If nTipo == 4 .Or. (nTipo == 1 .And. nPar03 == 2) .Or. (nTipo == 2 .And. cTpHr == "C")
	cResult := cTime
Else
	nPos     := AT(":", If(":" $ cTime, cTime, PesqPict("SH6","H6_TEMPO")))
	nTempo   := Val(StrTran(cTime,':','.'))
	nHoras	 := Int(nTempo)
	nMinutos := (nTempo - Int(nTempo)) * 60
	cResult  := StrZero(nHoras,nPos-1)+":"+StrZero(nMinutos,2)
Endif
Return(cResult)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³TimeH6     ³ Autor ³ Marcelo Iuspa         ³ Data ³ 27/01/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Converte H6_TEMPO para centesimal ou normal                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ ExpC1:=TimeH6(ExpC1)                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Formato do tempo a ser retornado                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA680/MATA681                                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TimeH6(cFormato, cFieldH6, cAlias)
// mv_par03 - Tempo do Apontamento (1) Normal (2) Centesimal
Local nPar03   := Posicione("SX1", 1, "MTA68003", "X1_PRESEL")
Local nForOri  := Nil
Local cForOri  := Nil
Local nField   := Nil
Default cAlias := "SH6"
Static cTpHr

If cTpHr == Nil
	cTpHr := GetMV("MV_TPHR")
Endif

nForOri := If(!Empty((cAlias)->H6_TIPOTEM), (cAlias)->H6_TIPOTEM, nPar03)
cForOri := If(nForOri == 1, "N", "C")

nField := (cAlias)->(FieldPos(If(cFieldH6 == Nil, "H6_TEMPO", Upper(cFieldH6))))

Return(A680ConvHora((cAlias)->(FieldGet(nField)), cForOri, If(cFormato == Nil, cTpHr, cFormato)))



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³OpenSemSH8	 ³ Autor ³ Erike Yuri       ³ Data ³12/12/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria semaforo para SH8 permitindo exclusividade no tabela  ³±±
±±³          ³ por filial.                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 :Mostara Help caso nao consiga exclusividade no SH8  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAPCP       ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function OpenSemSH8(lShowHelp)
Local lRet := LockByName("SH8USO"+cNumEmp,.T.,.T.,.T.)
DEFAULT lShowHelp := .T.

If !lRet .And. lShowHelp
	Help(" ",1,"SH8EmUso")
EndIf

Return ( lRet  )



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ClosSemSH8	 ³ Autor ³ Erike Yuri       ³ Data ³12/12/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fecha semaforo do SH8 permitindo que o mesmo fique disponi-³±±
±±³          ³ vel para a filial corrente.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAPCP       ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ClosSemSH8()
Return UnLockByName("SH8USO"+cNumEmp,.T.,.T.,.T.)



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³IsLockSH8		 ³ Autor ³ Erike Yuri       ³ Data ³12/12/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna informacao se SH8 esta locado (exclusivo) para al- ³±±
±±³          ³ gum processo, ou nao.                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1: Mostara Help caso nao consiga exclusividade no SH8  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAPCP       ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsLockSH8(lShowHelp)
Local lLock := LockByName("SH8USO"+cNumEmp,.T.,.T.,.T.)
Local lRet	:= .T.
DEFAULT lShowHelp := .T.

If lLock
	UnLockByName("SH8USO"+cNumEmp,.T.,.T.,.T.)
	lRet := .F.
EndIf

If lRet .And. lShowHelp
	Help(" ",1,"SH8EmUso")
EndIf

Return ( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³OPGeraQIP ºAutor  ³Andre Anjos         º Data ³  06/30/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Gera integracao com Inspecao de Processos (SIGAQIP) quando º±±
±±º          ³ houver (o registro no arquivo SC2 deve estar posicionado e º±±
±±º          ³ com lock aplicado).										  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650, MATA651 e MATA720                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function OPGeraQIP()
Local aArea     := GetArea()
Local aRetEsp   := {}
Local cQipPcp   := SuperGetMV("MV_QINSPEC",.F.,"1")
Local lIntQIP   := If(cModulo=="QIP",.T.,IntQIP())
Local lMT650QIP := If(ExistBlock("MT650QIP"),ExecBlock("MT650QIP",.F.,.F.),.T.)
Local lQPMTA650 := .T.
Local nNumCqPr  := Posicione("SB1",1,FwxFilial("SB1")+SC2->C2_PRODUTO, "B1_NUMCQPR")
Local nVerifica := 0

DEFAULT lOpQIP    := .T.

If cQipPcp == "1" .and. !lMT650QIP
	lOpQIP := .F.
	RETURN
EndIf

If Existblock ("QPMTA650")
  lQPMTA650 := Execblock ("QPMTA650",.F.,.F.)
Endif

If SC2->C2_TPOP == "F"  .And. lQPMTA650 //.And. nNumCqPr <> 0
	If IntQIP(SC2->C2_PRODUTO,"1",If(cModulo=="QIP","E","T")) //Define a integracao com o QIP
		If SC2->C2_VERIFI == 0
			nVerifica := QIPSitInsPro(.T.)
		EndIF
		aRetEsp := QIPRevRot(SC2->C2_PRODUTO)
		RecLock("SC2",.F.)
		If nVerifica <> 0
			SC2->C2_VERIFI := nVerifica
			If nVerifica == 2 //Gera o Codigo do Certificado de Qualidade
				SC2->C2_LAUDO  := "A"
				SC2->C2_CERQUA := QA_SEQUSX6("QIP_CEQU",TamSX3("C2_CERQUA")[1],"S","Certificado Qualidade")
			EndIf
		EndIF
		SC2->C2_REVI   := aRetEsp[1]
		SC2->C2_GRUPO  := aRetEsp[3]
		SC2->C2_IDEINV := INVERTE(SC2->C2_NUM) //Ordem invertida p/ controle de Skip-Lote
		MsUnlock()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o Movimento OP x Lotes	(Integracao QIP x PCP)		 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		QIPAtualiza("SC2",1)
	ElseIf lMT650QIP .And. lIntQIP .And. SuperGetMV("MV_QINSPEC",.T.,"1") == "2"	//Por Apontamento
		aRetEsp := QIPRevRot(SC2->C2_PRODUTO)
		RecLock("SC2",.F.)
		SC2->C2_VERIFI := 1
		SC2->C2_REVI   := aRetEsp[1]
		SC2->C2_GRUPO  := aRetEsp[3]
		SC2->C2_IDEINV := INVERTE(SC2->C2_NUM)
		MsUnlock()
	EndIf
EndIf

RestArea(aArea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³COMXFUN_V  ³ Autor ³Andre Anjos		    ³ Data ³ 30/06/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao utilizada para verificar a ultima versao do fonte   ³±±
±±³			 ³ PCPXFUN.PRX aplicado no rpo do cliente, assim verificando  ³±±
±±³			 ³ a necessidade de uma atualizacao neste fonte.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ EST/PCP/FAT/COM	                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PCPXFUN_V
Local nRet := 20090630 // 30 de junho de 2009
Return nRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UsrGrEng  ³ Autor ³ Rodrigo T. Silva      ³ Data ³ 04.11.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna os Grupos de Engenharia do Usuario.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do usuario a ser verificado.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetA1 = Array contendo os codigos dos grupos.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function UsrGrEng(cUser)
Local aArea 	 := GetArea()
Local cGrupoUser := ""

If !Empty(cUser)
	dbSelectArea("SGK")
	dbSetOrder(2)
	If dbSeek(xFilial()+cUser)
		cGrupoUser := SGK->GK_GRAPROV
	EndIf
Endif

RestArea(aArea)
Return cGrupoUser


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaAlcEng ³ Autor ³ Rodrigo T. Silva		³ Data ³03.11.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Controla a alcada dos documentos (SGN- Alcadas Engenharia) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MaAlcEng(ExpA1,ExpD1,ExpN1)				               	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com informacoes do documento                 ³±±
±±³          ³       [1] Numero do documento                              ³±±
±±³          ³       [2] Tipo de Documento                                ³±±
±±³          ³       [3] Codigo do Usuario                                ³±±
±±³          ³       [4] Grupo do Aprovador                               ³±±
±±³          ³       [5] Observacao			                              ³±±
±±³          ³ ExpD1 = Data de referencia 				                  ³±±
±±³          ³ ExpN1 = Operacao a ser executada                           ³±±
±±³          ³       1 = Inclusao do documento                            ³±±
±±³          ³       2 = Transferencia para Superior                      ³±±
±±³          ³       3 = Exclusao do documento                            ³±±
±±³          ³       4 = Aprovacao do documento                           ³±±
±±³          ³       5 = Estorno da Aprovacao                             ³±±
±±³          ³       6 = Bloqueio Manual da Aprovacao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaAlcEng(aDocto,dDataRef,nOper,lRegSGn)
Local cDocto	:= If(aDocto[1]==Nil,"",aDocto[1])
Local cTipoDoc	:= If(aDocto[2]==Nil,"",aDocto[2])
Local cUsuario	:= If(aDocto[3]==Nil,"",aDocto[3])
Local cGrupo	:= If(aDocto[4]==Nil,"",aDocto[4])
Local cObs      := If(Len(aDocto)>4,If(aDocto[5]==Nil, "",aDocto[5]),"")
Local dDataLib  := IIF(dDataRef==Nil,dDataBase,dDataRef)
Local aArea		:= GetArea()
Local aAreaSGN	:= SGN->(GetArea())
Local lRetorno	:= .T.
Local lFirstNiv := .T.
Local lAchou	:= .F.
Local cNivIgual := ""
Local cAuxNivel := ""
Local cTipoLib  := ""
Local cQuery    := ""
Local lExistSGN	:= .F.
DEFAULT lRegSGn := .F.

DEFAULT dDataRef := dDataBase
Default lAutomacao := .F.

If Empty(cGrupo)
	cGrupo := UsrGrEng(SGG->GG_USUARIO)
Endif

nRec := ' '

If lRetorno
	Do Case
		Case nOper == 1 //Inclusao do Documento
			SGM->(dbSetOrder(2))
			If !Empty(cGrupo) .And. SGM->(dbSeek(xFilial("SGM")+cGrupo))
				While !Eof() .And. SGM->(GM_FILIAL+GM_COD)	 == xFilial("SGM")+cGrupo
					If lFirstNiv
						cAuxNivel := SGM->GM_NIVEL
						lFirstNiv := .F.
					EndIf

					//Verifica se o item ja existem para aprovação, senao inclui
					cAliasTmp   := GetNextAlias()
					cQuery := " SELECT COUNT(GN_NUM) AS CONT "
					cQuery += " FROM "+ RetSqlName( "SGN" ) +" SGN "
					cQuery += " WHERE "
					cQuery += " GN_FILIAL = '" + xFilial( "SGN" ) + "' "
					cQuery += " AND GN_TIPO = 'SGG' "
					cQuery += " AND GN_NUM  = '"+cDocto+  "' "
					cQuery += " AND GN_USER = '"+SGM->GM_USER+  "' "
					cQuery += " AND GN_NIVEL = '"+SGM->GM_NIVEL+  "' "
					cQuery += " AND D_E_L_E_T_ = ''  "
					cQuery := ChangeQuery(cQuery)

					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp,.T.,.T.)

					If ((cAliasTmp)->CONT > 0 )
						lExistSGN := .T.
						lRegSGn	  := .T.
					EndIf
					(cAliasTmp)->(dbCloseArea())

					IF ! lExistSGN
						Reclock("SGN",.T.)
						SGN->GN_FILIAL	:= xFilial("SGN")
						SGN->GN_TIPO	:= cTipoDoc
						SGN->GN_NUM 	:= cDocto
						SGN->GN_USER	:= SGM->GM_USER
						SGN->GN_NIVEL	:= SGM->GM_NIVEL
						SGN->GN_STATUS	:= IIF(SGM->GM_NIVEL == cAuxNivel,"02","01")
						SGN->GN_TIPOLIB	:= SGM->GM_TPLIBER
						SGN->GN_EMISSAO := dDataBase
						MsUnlock()
					EndIf

					SGM->(dbSkip())

					lExistSGN := .F.

				EndDo
			EndIf
			lRetorno := lFirstNiv
		Case nOper == 2 //Transferencia da Alcada para o Superior
			If SGN->(!Eof()) .And. SGN->(GN_FILIAL+GN_TIPO+GN_NUM) == xFilial("SGN")+cTipoDoc+cDocto
				// Carrega dados do Registro a ser tranferido e exclui
				cTipoDoc := SGN->GN_TIPO
				cAuxNivel:= SGN->GN_STATUS
				cNextNiv := SGN->GN_NIVEL
				dDataRef := SGN->GN_EMISSAO
				cAprovOri:= SGN->GN_USERLIB
				cTipoLib := SGN->GN_TIPOLIB
				Reclock("SGN",.F.,.T.)
				dbDelete()
				MsUnlock()

				// Inclui Registro para Aprovador Superior
				Reclock("SGN",.T.)
				SGN->GN_FILIAL	:= xFilial("SGN")
				SGN->GN_NUM		:= cDocto
				SGN->GN_TIPO	:= cTipoDoc
				SGN->GN_NIVEL	:= cNextNiv
				SGN->GN_USER	:= cUsuario
				SGN->GN_STATUS	:= cAuxNivel
				SGN->GN_EMISSAO := dDataRef
				SGN->GN_TIPOLIB := cTipoLib
				SGN->GN_OBS     := cObs
				MsUnlock()
			EndIf
			lRetorno := .T.
		Case nOper == 3 //-- Rejeicao
			SGN->(dbSetOrder(2))
			If SGN->(dbSeek(xFilial("SGN")+cTipoDoc+cDocto+cUsuario))
				Reclock("SGN",.F.)
				GN_STATUS	:= "04"
				GN_DATALIB	:= dDataLib
				GN_USERLIB	:= cUsuario
				SGN->GN_OBS := cObs
				nRecno	 	:= SGN->(Recno())
				MsUnlock()
				SGN->(dbSetOrder(1))
				While SGN->(!Eof()) .And. SGN->(GN_FILIAL+GN_TIPO+GN_NUM) == xFilial("SGN")+cTipoDoc+cDocto
					If SGN->GN_STATUS <> "04"
						Reclock("SGN",.F.)
						GN_STATUS	:= "06"
						GN_DATALIB	:= dDataLib
						GN_USERLIB	:= cUsuario
						GN_OBS	    := STR0025+AllTrim(UsrRetName(cUsuario)) +"." //Rejeitado pelo usuário
						MsUnlock()
					EndIf
					SGN->(dbSkip())
				EndDo
			EndIf
		Case nOper == 4 //Aprovacao do documento
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona a Tabela SGM pelo Aprovador de Origem caso o Documento tenha sido ³
			//| transferido por Ausência Temporária ou Transferência superior e o aprovador |
			//| de destino não fizer parte do Grupo de Aprovação.                           |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SGM")
			dbSetOrder(3)
			dbSeek(xFilial("SGM")+cGrupo+cUsuario)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Libera a pre-estrutura pelo aprovador				³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SGN")
			dbSetOrder(2)
			dbSeek(xFilial("SGN")+cTipoDoc+cDocto+cUsuario)
			While !Eof() .And. xFilial("SGN")+cTipoDoc+cDocto+cUsuario == SGN->(GN_FILIAL+GN_TIPO+GN_NUM+GN_USER)
				cAuxNivel := SGN->GN_NIVEL
				If SGN->GN_STATUS == "02"
					Reclock("SGN",.F.)
					SGN->GN_STATUS	:= "03"
					SGN->GN_OBS		:= If(Len(aDocto)>4,aDocto[5],"")
					SGN->GN_DATALIB	:= dDataLib
					SGN->GN_USERLIB	:= cUsuario
					MsUnlock()
				EndIf
				nRec := SGN->(RecNo())
				dbSkip()
			EndDo
			SGN->(dbSetOrder(1))
			dbSeek(xFilial("SGN")+cTipoDoc+cDocto+cAuxNivel)
			While !Eof() .And. xFilial("SGN")+cTipoDoc+cDocto == SGN->(GN_FILIAL+GN_TIPO+GN_NUM)
				If cAuxNivel == SGN->GN_NIVEL .And. SGN->GN_STATUS != "03" .And. SGN->GN_TIPOLIB $ "U"
					lRetorno := .F.
					Exit
				EndIf
				If cAuxNivel == SGN->GN_NIVEL .And. SGN->GN_STATUS != "03" .And. SGN->GN_TIPOLIB $ "NE"
					Reclock("SGN",.F.)
					SGN->GN_STATUS	:= "05"
					SGN->GN_DATALIB	:= dDataLib
					SGN->GN_USERLIB	:= SGM->GM_USER
					SGN->GN_OBS		:= STR0026+" "+AllTrim(UsrRetName(SGM->GM_USER)) +"." //Aprovado pelo usuário
					MsUnlock()
				EndIf
				If SGN->GN_NIVEL > cAuxNivel .And. SGN->GN_STATUS != "03" .And. !lAchou
					lAchou := .T.
					cNextNiv := SGN->GN_NIVEL
				EndIf
				If lAchou .And. SGN->GN_NIVEL == cNextNiv .And. SGN->GN_STATUS != "03"
					Reclock("SGN",.F.)
					SGN->GN_STATUS := If(SGM->GM_TPLIBER=="E","05",;
						If(( Empty(cNivIgual) .Or. cNivIgual == GN_NIVEL ) .And. cStatusAnt <> "01" ,"02",GN_STATUS))
					If SGN->GN_STATUS == "05"
						SGN->GN_DATALIB	:= dDataLib
					EndIf
					MsUnlock()
					cNivIgual := GN_NIVEL
					lAchou    := .F.
				Endif
				cStatusAnt := SGN->GN_STATUS
				dbSkip()
			EndDo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Reposiciona e verifica se ja esta totalmente liberado.       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(nRec)
				dbGoto(nRec)
				If lRetorno
					While !Eof() .And. xFilial("SGN")+cTipoDoc+cDocto == SGN->(GN_FILIAL+GN_TIPO+GN_NUM)
						If SGN->GN_STATUS != "03" .And. SGN->GN_STATUS != "05"
							lRetorno := .F.
						EndIf
						dbSkip()
					EndDo
				EndIf
			EndIf
		Case nOper == 6 //Bloqueio manual
			dbSelectArea("SGN")
			dbSetOrder(1)
			dbSeek(xFilial("SGN")+cTipoDoc+cDocto+cAuxNivel)

			If !lAutomacao
				Reclock("SGN",.F.)
				GN_STATUS   := "07"
				GN_OBS	    := If(Len(aDocto)>4,aDocto[5],"")
				GN_DATALIB  := dDataRef
				GN_USERLIB	:= cUsuario
				cAuxNivel   := GN_NIVEL
				MsUnlock()
			EndIf
			lRetorno 	:= .F.

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Bloqueia todos os Aprovadores do Nível  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nRec := RecNo()

			While !Eof() .And. xFilial("SGN")+cTipoDoc+cDocto+cAuxNivel == SGN->(GN_FILIAL+GN_TIPO+GN_NUM+GN_NIVEL)
				If SGN->GN_STATUS != "07"
					Reclock("SGN",.F.)
					SGN->GN_STATUS	:= "08"
					SGN->GN_OBS	    := STR0027+AllTrim(UsrRetName(cUsuario)) +"." //Bloqueado pelo usuário
					SGN->GN_DATALIB	:= dDataRef
					SGN->GN_USERLIB	:= cUsuario
					MsUnlock()
				EndIf
				dbSkip()
			EndDo
	EndCase
	If ExistBlock("MTALCDOC")
		Execblock("MTALCDOC",.F.,.F.,{aDocto,dDataRef,nOper})
	Endif
EndIf

RestArea(aAreaSGN)
RestArea(aArea)

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GrpEng 	³ Autor ³ Rodrigo Toledo        ³ Data ³ 18.11.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna se o usuario possui ao menos um grupo de engenharia³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do usuario.                				  ³±±
±±³			 ³ ExpC2 = Codigo do engenheiro.               				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Achou = .T. / .F.                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GrpEng(cCodUsu,cCodEng)
Local aArea    	:= GetArea()
Local lAchou	:= .F.
Local cGrupo	:= ""
Local nRecno	:= 0
cCodEng := IIF(Empty(cCodEng),RetCodUsr(),cCodEng)

dbSelectArea("SGL")
dbSetOrder(2)
dbSeek(xFilial("SGL")+cCodUsu)
While !Eof() .And. SGL->GL_USER == cCodUsu
	cGrupo := SGL->GL_COD
	nRecno := SGL->(Recno())
	dbSelectArea("SGL")
	dbSetOrder(1)
	dbSeek(xFilial("SGL")+cGrupo)
	While !Eof() .And. SGL->GL_COD == cGrupo
		If SGL->GL_USER == cCodEng
			lAchou := .T.
		EndIf
		SGL->(dbSkip())
	End
	If lAchou
		Exit
	EndIf
	SGL->(dbSetOrder(2))
	SGL->(dbGoto(nRecno))
	SGL->(dbSkip())
End

RestArea(aArea)
Return lAchou

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ PCPLOAD  ºAutor  ³Leonardo Quintania  º Data ³  04/01/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao executada na entrada do modulo SIGAPCP.             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAPCP													  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PCPLOAD()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Realiza Bloqueio automatico de Inventario com base no parametro MV_BLQINVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MATA271(.T.)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ PCPINITFUN ºAutor  ³ TOTVS S/A        º Data ³  21/01/2014 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Executa as funcoes de inicializacao do modulo de compras    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAPCP                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PCPINITFUN()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ MA215CHECK - Funcao utilizada para verificar se no momento da abertura  |
//³              do modulo existem tabelas exclusivas abertas pela rotina   |
//|              MATA215 ou por outro processo.                             |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MA215CHECK()

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CusFabItem   ³ Autor ³ Andre Anjos           ³Data  ³ 20/12/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o custo de fabricacao de um item.					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cProd: codigo do produto.							    	  ³±±
±±³          ³ nTipo: identifica a modalidade de custo desejada:			  ³±±
±±³          ³ 			1- Mensal (SB9 - B9_CM)								  ³±±
±±³          ³ 			2- On-Line (SB2 - B2_CM)							  ³±±
±±³          ³ 			3- Reposicao (SB1 - B1_CUSTD)						  ³±±
±±³          ³ 			4- Ultima compra (SB1 - B1_UPRC)					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aRet: valores de custo divididos da seguinte forma:            ³±±
±±³          ³ 			aRet[1]- custo material								  ³±±
±±³          ³ 			aRet[2]- custo de preparacao (setup)				  ³±±
±±³          ³ 			aRet[3]- custo GGF									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CusFabItem(cProd,nTipo,nQuant)
Local aRet    := {0,0,0}
Local nRecBkp := 0
Local aHoras  := {}
Local aValSub := {}

Default nQuant := 1

SB1->(dbSetOrder(1))
SB9->(dbSetOrder(1))
SB2->(dbSetOrder(1))
SG1->(dbSetOrder(1))
SG2->(dbSetOrder(1))

//-- Processa itens da estrutura
If SG1->(dbSeek(xFilial("SG1")+cProd))
	While !SG1->(EOF()) .And. SG1->(G1_FILIAL+G1_COD) == xFilial("SG1")+cProd
		nQuantComp := ExplEstr(nQuant)

		//-- Soma custo do material (se materia prima)
		If nQuantComp > 0
			SB1->(dbSeek(xFilial("SB1")+SG1->G1_COMP))
			nRecBkp := SG1->(Recno())
			If !SG1->(dbSeek(xFilial("SG1")+SG1->G1_COMP))
				Do Case
					Case nTipo == 1
						SB9->(dbSeek(xFilial("SB9")+SB1->(B1_COD+B1_LOCPAD)+Replicate("z",8),.T.))
						SB9->(dbSkip(-1))
						If SB9->(B9_FILIAL+B9_COD) == xFilial("SB9")+SB1->B1_COD
							aRet[1] += nQuantComp * SB9->B9_CM1
						EndIf
					Case nTipo == 2 .or. nTipo == 5 //online ou offline
						If SB2->(dbSeek(xFilial("SB2")+SB1->(B1_COD+B1_LOCPAD)))
							aRet[1] += nQuantComp * SB2->B2_CM1
						EndIf
					Case nTipo == 3
						aRet[1] += nQuantComp * xMoeda(RetFldProd(SB1->B1_COD,"B1_CUSTD"),Val(RetFldProd(SB1->B1_COD,"SB1->B1_MCUSTD")),1,RetFldProd(SB1->B1_COD,"B1_UCALSTD"),2)
					Case nTipo == 4
						aRet[1] += nQuantComp * RetFldProd(SB1->B1_COD,"B1_UPRC")
				EndCase
			Else
				//-- Faz chamada recursiva se fabricado para obter custos dos filhos
				aValSub := CusFabItem(SG1->G1_COD,nTipo,nQuantComp)
				aRet[1] += aValSub[1]
				aRet[2] += aValSub[2]
				aRet[3] += aValSub[3]
			EndIf
			SG1->(dbGoTo(nRecBkp))
		EndIf

		SG1->(dbSkip())
	End

	//-- Soma custo das horas de producao do item
	If SB1->B1_FANTASM <> 'S'
		aHoras := CusRoteiro(cProd,nTipo)
		aRet[2] += aHoras[1]
		aRet[3] += aHoras[2]
	EndIf
Else
	SB1->(dbSeek(xFilial("SB1")+cProd))

	//-- Soma custo do material (se materia prima)
	Do Case
		Case nTipo == 1
			SB9->(dbSeek(xFilial("SB9")+SB1->(B1_COD+B1_LOCPAD)+Replicate("z",8),.T.))
			SB9->(dbSkip(-1))
			If SB9->(B9_FILIAL+B9_COD) == xFilial("SB9")+SB1->B1_COD
				aRet[1] += SB9->B9_CM1
			EndIf
		Case nTipo == 2 .or. nTipo == 5 //online ou offline
			If SB2->(dbSeek(xFilial("SB2")+SB1->(B1_COD+B1_LOCPAD)))
				aRet[1] += SB2->B2_CM1
			EndIf
		Case nTipo == 3
			aRet[1] += xMoeda(RetFldProd(SB1->B1_COD,"B1_CUSTD"),Val(RetFldProd(SB1->B1_COD,"SB1->B1_MCUSTD")),1,RetFldProd(SB1->B1_COD,"B1_UCALSTD"),2)
		Case nTipo == 4
			aRet[1] += RetFldProd(SB1->B1_COD,"B1_UPRC")
	EndCase
EndIf

Return aRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ CusRoteiro   ³ Autor ³ Andre Anjos           ³Data  ³ 20/12/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna os custos (preparacao e operacao) de fabricacao de um  ³±±
±±³          ³ item (unitario) considerando-se seu roteiro padrao.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cProduto: codigo do produto.									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aRet: quantidade de horas gastas na fabricacao				  ³±±
±±³          ³ 		aRet[1]: custo das horas de preparacao.					  ³±±
±±³          ³ 		aRet[2]: custo das horas de operacao.					  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function CusRoteiro(cProduto,nTipo)
Local nOperTot := 0
Local nPrepTot := 0
Local nHrsOper := 0
Local nHrsPrep := 0
Local nQuant   := 1
Local nQtdeAux := 0
Local nCustoUn := 0
Local cRoteiro := A650VldRot(cProduto,If(Empty(SB1->B1_OPERPAD),"01",SB1->B1_OPERPAD))

PRIVATE nPrecisao := SuperGetMV("MV_PRECISA",.F.,4)
PRIVATE lCusFil   := SuperGetMV("MV_CUSFIL",.F.,"A") == "F"
PRIVATE lCusEmp	  := SuperGetMv("MV_CUSFIL",.F.,"A") == "E"
PRIVATE dInicio   := SuperGetMV("MV_ULMES",.F.,SToD("19970101"))+1
PRIVATE lBat 	  := .T.
PRIVATE lOpenTRT  := .F.

SH7->(dbSetOrder(1))
SH1->(dbSetOrder(1))

SG2->(dbSetOrder(1))
SG2->(dbSeek(xFilial("SG2")+cProduto+cRoteiro))
While !SG2->(EOF()) .And. SG2->(G2_FILIAL+G2_PRODUTO+G2_CODIGO) == xFilial("SG2")+cProduto+cRoteiro
	//-- Posiciona recurso
	SH1->(dbSeek(xFilial("SH1")+SG2->G2_RECURSO))

	//-- Calcula tempo de duracao baseado no Tipo de Operacao
	If SG2->G2_TPOPER $ " 1"
		nHrsOper := Round(nQuant*(If(Empty(A690HoraCt(SG2->G2_TEMPAD)),1,A690HoraCt(SG2->G2_TEMPAD))/If(Empty(SG2->G2_LOTEPAD),1,SG2->G2_LOTEPAD)),5)
		If SH1->H1_MAOOBRA # 0
			nHrsOper := Round(nHrsOper/SH1->H1_MAOOBRA,5)
		EndIf
	ElseIf SG2->G2_TPOPER == "4"
		nQtdeAux := nQuant % If(Empty(SG2->G2_LOTEPAD),1,SG2->G2_LOTEPAD)
		nQtdeAux := Int(nQuant) + If(nQtdeAux > 0,If(Empty(SG2->G2_LOTEPAD),1,SG2->G2_LOTEPAD) - nQtdeAux,0)
		nHrsOper := Round(nQtdeAux * (If(Empty(A690HoraCt(SG2->G2_TEMPAD)),1,A690HoraCt(SG2->G2_TEMPAD)) / If(Empty(SG2->G2_LOTEPAD),1,SG2->G2_LOTEPAD)),5)
		If SH1->H1_MAOOBRA # 0
			nHrsOper := Round(nHrsOper/SH1->H1_MAOOBRA,5)
		EndIf
	ElseIf SG2->G2_TPOPER == "2" .Or. SG2->G2_TPOPER == "3"
		nHrsOper := If(Empty(A690HoraCt(SG2->G2_TEMPAD)),1,A690HoraCt(SG2->G2_TEMPAD))
	EndIf

	nHrsPrep := A690HoraCt(If(Empty(SG2->G2_FORMSTP),SG2->G2_SETUP,Formula(SG2->G2_FORMSTP)))	//-- Soma setup
	nHrsPrep += A690HoraCt(SG2->G2_TEMPEND)				//-- Soma tempo fim da operacao

	nCustoUn := CusUnitMOD(nTipo,SH1->H1_CODIGO,@lOpenTRT)

	//-- Acumula custo nas variaveis de retorno
	nOperTot += nHrsOper * nCustoUn
	nPrepTot += nHrsPrep * nCustoUn

	SG2->(dbSkip())
End

Return {nPrepTot,nOperTot}

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CusUnitMODºAutor  ³Microsiga           º Data ³  02/22/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Retorna o custo unitario da mao de obra.                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ nTipo: identifica a modalidade de custo desejada:		  º±±
±±º          ³ 			1- Mensal (SB9 - B9_CM)							  º±±
±±º          ³ 			2- On-Line (SB2 - B2_CM)						  º±±
±±º          ³ 			3- Reposicao (SB1 - B1_CUSTD)					  º±±
±±º          ³ 			4- Ultima compra (SB1 - B1_UPRC)				  º±±
±±º          ³ cRecurso: código do recurso da MOD.						  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CusUnitMOD(nTipo,cRecurso,lOpenTRT)
Local nRet 	     := 0
Local cProdMod   := PadR(APrModRec(cRecurso),TamSX3("B1_COD")[1])
Local lCusFil    := AllTrim(SuperGetMV('MV_CUSFIL' ,.F.,"A")) $ "F|E"
Local lExistProc := .F.
Local cIDProc    := StaticCall(MATA330,VERIDPROC)

#IFDEF TOP
lExistProc := ExistProc(GetSPName("MAT004","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT007","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT009","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT016","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT052","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT054","19"), cIDProc)
#ENDIF

//-- Obtem custo unitario da mao de obra
SB1->(dbSetOrder(1))
SB1->(dbSeek(xFilial("SB1")+cProdMod))

Do Case
	Case nTipo == 1 //Mensal
		SB9->(dbSeek(xFilial("SB9")+cProdMod+SB1->B1_LOCPAD+Replicate("z",8),.T.))
		SB9->(dbSkip(-1))
		If SB9->B9_COD == cProdMod
			nRet := SB9->B9_CM1
		EndIf
    Case nTipo == 3 //Reposição
			nRet := xMoeda(SB1->B1_CUSTD,Val(SB1->B1_MCUSTD),1,SB1->B1_UCALSTD,2)
	Case nTipo == 5 //Offline
		//Busca o custo dos saldos atuais.
		If SB2->(dbSeek(xFilial("SB2")+cProdMod+SB1->B1_LOCPAD))
			nRet := SB2->B2_CM1
		EndIf
    Otherwise
		//-- Faz o calculo on-line
		If lCusFil
			StaticCall(MATA330,A330TRT,Nil,Nil,.F.,0,@lOpenTRT,lExistProc,{{.T.,cFilAnt}})
		EndIf
		//online, recalcula o mod.
		A330Mod(SB1->B1_COD,SB1->B1_CCCUSTO,SB1->B1_GCCUSTO)
		//Busca o custo dos saldos atuais.
		If SB2->(dbSeek(xFilial("SB2")+cProdMod+SB1->B1_LOCPAD))
			nRet := SB2->B2_CM1
		EndIf
EndCase

TRT->(dbCloseArea())
lOpenTRT := .F.

Return nRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPIntgPPI

Função para verificação de integração com o PC-Factory

@author  Lucas Konrad França
@version P12
@since   13/08/2015
@return  lRet  - Indica se existe a integração com o PC-Factory.
           .T. -> Integração ativa
           .F. -> Integração não ativa.
/*/
//-------------------------------------------------------------------------------------------------
/*

   Para realizar a integração com o PPI:
   Parametrizar a integração, no programa PCPA109
   A função PCPIntgPPI()->.T./.F. irá verificar se a integração está ativa.
   Com a integração ativa, deve-se criar a tabela temporária para realização dos filtros. Função PCPTmpPPI(cTable)->Nome da temp table.
   Para realizar a comunicação, verificar os filtros parametrizados. Função PCPFiltPPI(cTable, cValue, cPont, cTemp)-> .T./.F.
   Se a função PCPFiltPPI retornar .T., utilizar o Adapter da mensagem que se deseja enviar para o PPI.
   Com a mensagem gerada, utilizar a função PCPWebsPPI(cXml)->{lStatus,cMsg} para realizar o envio da mensagem.
   Após o envio da mensagem, criar o XML fisicamente com a função PCPXmLPPI(cStatus, cTransac, cRegist, cDtEnvio, cHrEnvio, cXml)->Nome XML,
     Esta função já verifica o parâmetro para criação do arquivo físico na tabela SOD.
   E no final, deve criar a tabela SOF, utilizando a função PCPCriaSOF(cTransac, cRegist, cStatus, cGeraXml, cNomeXml, cDtEnvio, cHrEnvio, cUsu, cMsgRet, cXml).

*/
Function PCPIntgPPI()
   Local aArea := GetArea()
   Local lRet  := .F.

   //Verifica se existe cadastro da integração com o PPI que esteja ativa.
   dbSelectArea("SOD")
   SOD->(dbSetOrder(1))
   If SOD->(dbSeek(xFilial("SOD")+"1"))
      lRet := .T.
      If (ExistBlock('PCPXFUNPPI'))
         lRet := ExecBlock('PCPXFUNPPI',.F.,.F.,FunName())
      EndIf
   EndIf
   RestArea(aArea)
Return lRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPWebsPPI

Função para enviar o XML para o PCFactory

@param cXml     - Conteúdo do XML gerado.
@param cCaminho - Caminho do webservice (SOD->OD_CAMINHO)

@return aRet - Array com o retorno do PCFactory
         [1] Status do envio. 1 - OK, 2 - Pendente, 3 - Erro
         [2] Mensagem de retorno do PCFactory
         [3] XML enviado ao PCFactory
         [4] XML recebido do PCFactory

@author  Lucas Konrad França
@version P12
@since   13/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPWebsPPI(cXml, cCaminho)
	Local aRet       := {"","","",""}
	Local aRetPar    := {}
	Local cError     := ""
	Local cWarning   := ""
	Local cReturn    := ""
	Local cXmlUtf8   := ""
	Local cOperation := ""
	Local aOperation := {}
	Local nPos       :=  0
	Local lMV_COPPI  := SuperGetMv("MV_COPPI",.F.,.F.)
	Default cCaminho := ""

	Static oWsPPI

	Private oRet

	If Empty(cCaminho)
		dbSelectArea("SOD")
		SOD->(dbSetOrder(1))
		If SOD->(dbSeek(xFilial("SOD")+"1"))
			cCaminho := AllTrim(SOD->OD_CAMINHO)
		Else
			aRet[1] := "2"
			aRet[2] := STR0005 //"Não existe caminho de WebService cadastrado. Verifique os parâmetros da integração."
		EndIf
	EndIf

	If lMV_COPPI .and. oWsPPI == Nil
		oWsPPI:= TWsdlManager():New()

		If !oWsPPI:parseUrl(cCaminho)
			aRet[1] := "2"
			aRet[2] := STR0035 + STR0039 + AllToChar(oWsPPI:cError) //"Não foi possível realizar a conexão com o WebService do TOTVS MES. Favor verificar as configurações de conexão. Erro: "
			oWsPPI := Nil
		EndIf
	EndIF

	//LOGS - Parâmetro de geração de log´s, quando necessitar de maiores informações sobre erros de conexão.
	//oWsPPI:lVerbose := .T.

	//Se já tiver o objeto instanciado, não instancia novamente.
	If lMV_COPPI // Utiliza nova conexão dos arquivos WSD
		aOperation := oWsPPI:ListOperations()
		nPos := aScan(aOperation, {|x| Upper(x[1]) == "RECEIVEMESSAGE"})
		If nPos > 0
			cOperation := aOperation[nPos][1]
		Else
			aRet[1] := "2"
			aRet[2] := STR0060 //"O link é um wsdl válido. Porém não contém os métodos utilizados para integração com o TOTVS MES. Favor verificar as configurações de conexão."
		EndIf

		If !oWsPPI:SetOperation(cOperation)
			aRet[1] := "2"
			aRet[2] := STR0059 + cOperation + STR0039 + AllToChar(oWsPPI:cError) //"Não conseguiu setar a operação XXXX. Erro:"
		EndIf
	Else
		//Se já tiver o objeto instanciado, não instancia novamente.
		If Type('oWsInteg') == "O"
			oWsPPI  := oWsInteg
			aRetPar := {.T.,""}
		Else
			//Instancia o WS Client do PPI
			oWsPPI := WSPCFactory():New()

			//Carrega os parâmetros do WS
			aRetPar := oWsPPI:getLinks(cCaminho)
		EndIf
	EndIf

	cXml := StrTran(cXml,CHR(129),"")
	cXml := StrTran(cXml,CHR(141),"")
	cXml := StrTran(cXml,CHR(143),"")
	cXml := StrTran(cXml,CHR(144),"")
	cXml := StrTran(cXml,CHR(157),"")

	cXmlUtf8 := EncodeUTF8(cXml)
	If cXmlUtf8 != Nil
		cXml := cXmlUtf8
	EndIf

	cXml := StrTran(cXml,CHR(129),"")
	cXml := StrTran(cXml,CHR(141),"")
	cXml := StrTran(cXml,CHR(143),"")
	cXml := StrTran(cXml,CHR(144),"")
	cXml := StrTran(cXml,CHR(157),"")

	If lMV_COPPI
		cXml := "<![CDATA[" + cXml + "]]>"

		If !oWsPPI:setValue(0,cXml)
			aRet[1] := "2"
			aRet[2] := STR0061 + STR0039 + AllToChar(oWsPPI:cError) //"Não foi possível utilizar o XML. Erro: "
			aRet[3] := cXml
		EndIf

		//Solicita Autorização
		SOE->(dbSetOrder(1))
		If SOE->(dbSeek(xFilial("SOE")+"SEGURANCA")) .And. SOE->(ColumnPos("OE_CHAR1"))
			If !Empty(SOE->OE_CHAR1) .And. !Empty(SOE->OE_MEMO1)
				oWsPPI:AddHttpHeader( "Authorization", " Basic "+Encode64(AllTrim(SOE->OE_CHAR1)+":"+AllTrim(SOE->OE_MEMO1) ))
			EndIf
		EndIf

		//Envia a mensagem para o PPI
		If oWsPPI:SendSoapMsg()
			cReturn := oWsPPI:GetParsedResponse()
			nPos := At("<TOTVSMESSAGE", UPPER(cReturn))
			If nPos > 0
				cReturn := SubStr(cReturn, nPos)
				nPos := At("</TOTVSMESSAGE>", UPPER(cReturn))
				If nPos > 0
					cReturn := SubStr(cReturn, 1, nPos+14)
				Else
					aRet[1] := "2"
					aRet[2] := StrTran(cReturn,CHR(09)," ")
					aRet[3] := cXml
					aRet[4] := cReturn
				EndIf
			Else
				aRet[1] := "2"
				aRet[2] := StrTran(cReturn,CHR(09)," ")
				aRet[3] := cXml
				aRet[4] := cReturn
			EndIf
			//Recupera o retorno da mensagem
      		oRet := XmlParser(cReturn,"_",@cError,@cWarning)
		EndIf
	Else
		If aRetPar[1]
			//Envia a mensagem para o PPI
			If oWsPPI:receiveMessage(cXml)
				//Recupera o retorno da mensagem
				cReturn := EncodeUTF8(oWsPPI:creceiveMessageResult)
				oRet    := XmlParser(cReturn,"_",@cError,@cWarning)
			Else
				//Não conectou com o WS da PPI.
				aRet[1] := "2"
				aRet[2] := STR0035 //"Não foi possível realizar a conexão com o WebService do TOTVS MES. Verifique as configurações de conexão."
			EndIf
		Else
			//Não conectou com o WS da PPI.
			aRet[1] := "2"
			aRet[2] := aRetPar[2]
		EndIf
	EndIF

	If aRet[1] == ""
		aRet[3] := cXml
		aRet[4] := cReturn
		If oRet != Nil .And. Empty(cError) .And. Empty(cWarning)
			//Integração realizada com sucesso
			If Type("oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_Status:Text") != "U" .And. ;
			   Upper(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_Status:Text) == "OK"
				aRet[1] := "1"
				aRet[2] := "OK"
			Else
				//Ocorreu algum erro durante a integração.
				If Type("oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_Status:Text") != "U" .And.;
				   Upper(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_Status:Text) == "ERROR"
					aRet[1] := "3"
					aRet[2] := getMessage() //Retorna o código do erro: descrição do erro.
				EndIf
			EndIf
			FwFreeObj(oRet)
			oRet := Nil
		Else
			aRet[1] := "3"
			aRet[2] := STR0040 //"Não foi possível realizar o parse do XML de retorno do TOTVS MES."
		EndIf
    EndIf

Return aRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} getMessage

Retorna a mensagem de erro do PCFactory. Faz a leitura do objeto oRet, deve estar definido como Private

@return cMessage - String contendo as mensagens do PCFactory.

@author  Lucas Konrad França
@version P12
@since   04/09/2015
/*/
//-------------------------------------------------------------------------------------------------
Static Function getMessage()
   Local cMessage := ""
   Local nI       := 0

   If Type("oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message") == "O"
      //Retornou apenas uma mensagem
      If Type("oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message:_Code:Text") != "U" .And. ;
         Type("oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message:Text") != "U"
         //Adiciona uma quebra de linha
         cMessage := CHR(10)
         //Adiciona a mensagem.
         cMessage += AllTrim(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message:_Code:Text) + ": " +;
                     AllTrim(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message:Text)
      EndIf
   Else
      If Type("oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message") == "A"
         //Retornou várias mensagens
         For nI := 1 To Len(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message)
            If XmlChildEx(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message[nI],"_CODE") != Nil
               If AllTrim(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message[nI]:_Code:Text) == "9999" .And.;
                  AT('THE LIST OF ERRORS HAS VALUES', Upper(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message[nI]:Text)) > 0
                  //Se é o erro que apenas replica todos os erros da lista, não adiciona na mensagem.
                  Loop
               EndIf
               //Adiciona uma quebra de linha
               cMessage += CHR(10)
               //Adiciona a mensagem.
               cMessage += AllTrim(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message[nI]:_Code:Text) + ": " +;
                           AllTrim(oRet:_TotvsMessage:_ResponseMessage:_ProcessingInformation:_ListOfMessages:_Message[nI]:Text)
            EndIf
         Next nI
      EndIf
   EndIf
Return cMessage

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPCriaSOF

Função para criação da tabela SOF - Integração PCP Protheus x PCFactory

@param cTransac - Nome da tabela que está sendo enviada ao PCFactory.
@param cRegist  - Código do registro que está sendo enviado.
@param cStatus  - Status do envio. 1 - OK; 2 - Pendente; 3 - Erro.
@param cGeraXml - Gerou XML. 1 - Sim; 2 - Não.
@param cNomeXml - Nome do arquivo XML gerado.
@param cDtEnvio - Data de envio do XML.
@param cHrEnvio - Hora de envio do XML.
@param cUsu     - Usuário que enviou o XML para o PCFactory.
@param cMsgRet  - Mensagem de retorno do PCFactory.
@param cXml     - Conteúdo do XML gerado.

@author  Lucas Konrad França
@version P12
@since   13/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPCriaSOF(cTransac, cRegist, cStatus, cGeraXml, cNomeXml, cDtEnvio, cHrEnvio, cUsu, cMsgRet, cXml)
	Local aArea      := GetArea()
	Local cQuery     := ""
	Local cAliasSOF  := GetNextAlias()
	Local cRotina    := FunName()
	Local lDelSOF    := .T.
	Local lTratEsp   := .F.
	Local lDelSOFEst := .F.

	Local lGeraXML   := .F.
	Local cDiretorio := ""
	Local cDirEnv    := ""
	Local cDirPend   := ""

	dbSelectArea("SOD")
	SOD->(dbSetOrder(1))
	If SOD->(dbSeek(xFilial("SOD")+"1"))
		If cStatus == "1"
    		cDiretorio := SOD->OD_DIRENV
    	Else
        	cDiretorio := SOD->OD_DIRPEND
    	EndIf
    	cDirEnv  := SOD->OD_DIRENV
      	cDirPend := SOD->OD_DIRPEND

	  	If SOD->OD_GERAXML == "1"
        	lGeraXML := .T.
    	EndIf
   	EndIf

	If AllTrim(cGeraXml) == "2"
		cNomeXml := ""
	EndIf

	If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cNomeXml))) .And. (cTransac $ "SB2|SB8|SBF") .And. AllTrim(Upper(cRotina)) != "PCPA110"
    	lDelSOF := .F.
	EndIf

	If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cNomeXml))) .And. (cTransac $ "SB2|SB8|SBF") .And. AllTrim(Upper(cRotina)) == "PCPA110"
		lTratEsp := .T.
	EndIf

	If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cNomeXml))) .And. (cTransac $ "SB2|SB8|SBF")
		lDelSOFEst := .T.
	EndIf

	If lDelSOF
   		//Procura na SOF pela transação e registro
   		cQuery := " SELECT R_E_C_N_O_ RECSOF "
   		cQuery +=   " FROM " + RetSqlName("SOF") + " SOF "
   		cQuery +=  " WHERE SOF.OF_FILIAL  = '" + xFilial("SOF") + "' "
   		cQuery +=    " AND SOF.OF_TRANSAC = '" + cTransac + "' "
   		cQuery +=    " AND SOF.OF_REGIST  = '" + cRegist  + "' "

        If lTratEsp //Se for via PCPA110 excluir somente aquele registro
		   cQuery +=    " AND SOF.OF_DTENVIO  = '" + cDtEnvio  + "' "
		   cQuery +=    " AND SOF.OF_HRENVIO  = '" + cHrEnvio  + "' "
		EndIf

   		cQuery +=    " AND SOF.D_E_L_E_T_ = ' ' "

   		cQuery := ChangeQuery(cQuery)

   		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSOF,.T.,.T.)

   		//Se encontrou, apaga o registro
   		If !(cAliasSOF)->(Eof())
      		SOF->(dbGoTo((cAliasSOF)->(RECSOF)))

      		RecLock("SOF",.F.)
      		SOF->(dbDelete())
      		SOF->(MsUnLock())
   		EndIf

   		(cAliasSOF)->(dbCloseArea())
	EndIf

	//Insere o novo registro na SOF
	RecLock("SOF",.T.)
	SOF->OF_FILIAL  := xFilial("SOF")
	SOF->OF_TRANSAC := cTransac
	SOF->OF_REGIST  := cRegist
	SOF->OF_STATUS  := cStatus
    SOF->OF_GERAXML := cGeraXml
    SOF->OF_NOMEXML := cNomeXml
    SOF->OF_DTENVIO := StoD(cDtEnvio)
    SOF->OF_HRENVIO := cHrEnvio
    SOF->OF_USU     := cUsu
    SOF->OF_MSGRET  := cMsgRet
    SOF->OF_XML     := cXml
    SOF->OF_PROGRAM := PCPRotXml(cXml)

	//Se está reprocessando o arquivo, gera a data/hora de reprocessamento.
    If AllTrim(Upper(cRotina)) == "PCPA110"
       	SOF->OF_DATPROC := Date()
       	SOF->OF_HORPROC := Time()
    EndIf
   	SOF->(MsUnLock())
   	RestArea(aArea)

	If lDelSOFEst

		//Se tiver mais de um registro com o Status 1 para o registro em questão
		//Deixar o último e apagar os demais
		//Os registros com status 2 deve manter para ser enviado para o MES

		//Se o status do registro processado for '2' pode apagar todos os regitros com status 1
		//Se o status do registro processado for '1' deve procurar se existe registro com status 2
		//Se não existir deve manter o último registro com o status 1
		//Se existir pode apagar todos os registros com status 1
		If cStatus == '1'
			lPrimeiro := .T.

			//Procura quantidade de registros para o registro em questão com status 2
			cAliasSOF  := GetNextAlias()
   			cQuery := " SELECT R_E_C_N_O_ RECNOSOF "
   			cQuery +=   " FROM " + RetSqlName("SOF") + " SOF "
   			cQuery +=  " WHERE SOF.OF_FILIAL  = '" + xFilial("SOF") + "' "
   			cQuery +=    " AND SOF.OF_TRANSAC = '" + cTransac + "' "
   			cQuery +=    " AND SOF.OF_REGIST  = '" + cRegist  + "' "
			cQuery +=    " AND SOF.OF_STATUS  <>  '1' "
   			cQuery +=    " AND SOF.D_E_L_E_T_ = ' ' "

			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSOF,.T.,.T.)
			If !(cAliasSOF)->(Eof())
				//Se existir pode apagar todos os registros com status 1
				lPrimeiro := .F.
			EndIf
			(cAliasSOF)->(dbCloseArea())
		Else
			//Se o status do registro processado for '2' pode apagar todos os regitros com status 1
			lPrimeiro := .F.
		EndIf

		cAliasSOF  := GetNextAlias()
   		cQuery := " SELECT R_E_C_N_O_ RECNOSOF "
   		cQuery +=   " FROM " + RetSqlName("SOF") + " SOF "
   		cQuery +=  " WHERE SOF.OF_FILIAL  = '" + xFilial("SOF") + "' "
   		cQuery +=    " AND SOF.OF_TRANSAC = '" + cTransac + "' "
   		cQuery +=    " AND SOF.OF_REGIST  = '" + cRegist  + "' "
		cQuery +=    " AND SOF.OF_STATUS  =  '1' "
   		cQuery +=    " AND SOF.D_E_L_E_T_ = ' ' "
		cQuery +=    " ORDER BY RECNOSOF DESC "

   		cQuery := ChangeQuery(cQuery)

   		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSOF,.T.,.T.)

   		//Se encontrou, apaga o registro
   		While !(cAliasSOF)->(Eof())
	  	 	If lPrimeiro
			   //O primeiro registro é o mais atual, então não exclui.
			   //Deve-se sempre manter o mais atual, os demais serão excluídos
				lPrimeiro = .F.
			Else
				SOF->(dbGoTo((cAliasSOF)->(RECNOSOF)))

				If lGeraXML //Apagar o XML
            		cNomeXml := retXmlName(SOF->OF_STATUS, SOF->OF_REGIST, DtoS(SOF->OF_DTENVIO), SOF->OF_HRENVIO, cTransac)
            		If SOF->OF_STATUS == "1"
               			FErase(AllTrim(cDirEnv)+cNomeXml)
            		Else
               			FErase(AllTrim(cDirPend)+cNomeXml)
            		EndIf
				EndIf

				RecLock("SOF",.F.)
    			SOF->(dbDelete())
      			SOF->(MsUnLock())
			EndIf

			(cAliasSOF)->(dbSkip())
		EndDo
		(cAliasSOF)->(dbCloseArea())
	EndIf

Return

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPXmlPPI

Função para criação arquivo físico do XML.

@param cStatus   - Status do envio. 1 - OK; 2 - Pendente; 3 - Erro.
@param cTransac  - Nome da tabela que está sendo enviada ao PCFactory.
@param cRegist   - Código do registro que está sendo enviado.
@param cDtEnvio  - Data de envio do XML.
@param cHrEnvio  - Hora de envio do XML.
@param cXml       - XML enviado.

@return cNomeXml - Retorna o nome do XML criado.

@author  Lucas Konrad França
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPXmlPPI(cStatus, cTransac, cRegist, cDtEnvio, cHrEnvio, cXml)
	Local aArea      := GetArea()
	Local lGeraXML   := .F.
	Local lRet       := .T.
	Local cDiretorio := ""
	Local cDirEnv    := ""
	Local cDirPend   := ""
	Local cNomeXml   := ""
	Local cQuery     := ""
	Local cAliasSOF  := GetNextAlias()
	Local cMsg       := ""
	Local nHandle    := 0
	Local cRotina    := FunName()
	Local lDelSOF    := .T.
	Local lTratEsp   := .F.

    If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cXml))) .And. (cTransac $ "SB2|SB8|SBF") .And. AllTrim(Upper(cRotina)) != "PCPA110"
    	lDelSOF := .F.
	EndIf

	If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cXml))) .And. (cTransac $ "SB2|SB8|SBF") .And. AllTrim(Upper(cRotina)) == "PCPA110"
		lTratEsp := .T.
	EndIf

	dbSelectArea("SOD")
	SOD->(dbSetOrder(1))
	If SOD->(dbSeek(xFilial("SOD")+"1"))
		If cStatus == "1"
    		cDiretorio := SOD->OD_DIRENV
    	Else
        	cDiretorio := SOD->OD_DIRPEND
    	EndIf
    	cDirEnv  := SOD->OD_DIRENV
      	cDirPend := SOD->OD_DIRPEND

	  	If SOD->OD_GERAXML == "1"
        	lGeraXML := .T.
    	EndIf
   	EndIf

	If lGeraXML

    	//Valida se o diretório está válido.
    	If !ExistDir(cDiretorio)
        	cMsg := STR0036 + AllTrim(cDiretorio) + STR0037 //"O diretório '" XXX "' é inválido."
        	lRet := .F.
    	EndIf

		If lRet
	 		If lDelSOF
        		//Verifica se existe um arquivo do mesmo item com ok/pendencia/erro
         		cQuery := " SELECT R_E_C_N_O_ RECSOF "
         		cQuery +=   " FROM " + RetSqlName("SOF") + " SOF "
         		cQuery +=  " WHERE SOF.OF_FILIAL  = '" + xFilial("SOF") + "' "
         		cQuery +=    " AND SOF.OF_TRANSAC = '" + cTransac + "' "
         		cQuery +=    " AND SOF.OF_REGIST  = '" + cRegist  + "' "

				If lTratEsp //Se for via PCPA110 excluir somente aquele registro
		   			cQuery +=    " AND SOF.OF_DTENVIO  = '" + cDtEnvio  + "' "
		   			cQuery +=    " AND SOF.OF_HRENVIO  = '" + cHrEnvio  + "' "
				EndIf

				cQuery +=    " AND SOF.D_E_L_E_T_ = ' ' "

         		cQuery := ChangeQuery(cQuery)

         		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSOF,.T.,.T.)
         		If !(cAliasSOF)->(Eof())
            		//Se existir uma pendência, exclui o XML.
            		SOF->(dbGoTo((cAliasSOF)->(RECSOF)))
            		cNomeXml := retXmlName(SOF->OF_STATUS, SOF->OF_REGIST, DtoS(SOF->OF_DTENVIO), SOF->OF_HRENVIO, cTransac)
            		If SOF->OF_STATUS == "1"
               			FErase(AllTrim(cDirEnv)+cNomeXml)
            		Else
               			FErase(AllTrim(cDirPend)+cNomeXml)
            		EndIf
         		EndIf
         		(cAliasSOF)->(dbCloseArea())
			EndIf

			//Retira barra
			cRegist:= STRTRAN(cRegist, "/", "-")

			 //Inicia criação do arquivo XML
         	cNomeXml := retXmlName(cStatus, cRegist, cDtEnvio, cHrEnvio, cTransac)

        	nHandle := FCreate(AllTrim(cDiretorio)+cNomeXml)

        	If nHandle > -1
            	FWrite(nHandle,cXml)
            	FClose(nHandle)
            	cMsg := cNomeXml
         	Else
            	lRet := .F.
            	cMsg := STR0038 + AllTrim(cDiretorio) + STR0039 + Str(FError()) //"Erro ao criar o arquivo XML no diretório '" XXX "'. Erro: "
         	EndIf
         	//Fim criação do arquivo XML.
      	EndIf
	EndIf
	RestArea(aArea)

Return {lRet, cMsg}

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} retXmlName

Função para criação arquivo físico do XML.

@param cStatus   - Status do envio. 1 - OK; 2 - Pendente; 3 - Erro.
@param cRegist   - Código do registro que está sendo enviado.
@param cDtEnvio  - Data de envio do XML.
@param cHrEnvio  - Hora de envio do XML.
@param cTransac  - Tabela que está gerando o XML.

@return cNomeXml - Retorna o nome do XML criado.

@author  Lucas Konrad França
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Static Function retXmlName(cStatus, cRegist, cDtEnvio, cHrEnvio, cTransac)
   Local cNomeXml := ""

   cHrEnvio := StrTran(cHrEnvio,":")

   Do Case
      Case cStatus == "1"
         cNomeXml := "OK_"
      Case cStatus == "2"
         cNomeXml := "PEND_"
      Case cStatus == "3"
         cNomeXml := "ERR_"
   EndCase

   Do Case
      Case cTransac == "SB1" // Produto
         cNomeXML += "ITEM_"
      Case cTransac $ "SH1|CYB" // Recurso
         cNomeXml += "MACHINE_"
      Case cTransac == "NNR" // Local de estoque
         cNomeXml += "WAREHOUSE_"
      Case cTransac == "SC2" //Ordem de produção
         cNomeXml += "PRODUCTIONORDER_"
      Case cTransac == "SG1" //Estrutura
         cNomeXml += "ITEMSTRUCTURE_"
      Case cTransac == "SG2" //Roteiro de operações
         cNomeXml += "ITEMSCRIPT_"
      Case cTransac == "CYH" //Recursos (chão de fábrica)
         cNomeXml += "RESOURCE_"
      Case cTransac == "SH4" //Ferramentas (PCP)
         cNomeXml += "RESOURCE_"
      Case cTransac == "SBE" //Endereço
         cNomeXml += "ADDRESSSTOCK_"
      Case cTransac == 'SB2' // Saldo Estoque
         cNomeXml += "ITEMSTOCKLEVEL_"
      Case cTransac == 'SB8' // Saldo Estoque
         cNomeXml += "ITEMSTOCKLEVEL_"
      Case cTransac == 'SBF' // Saldo Estoque
         cNomeXml += "ITEMSTOCKLEVEL_"
   EndCase
   cNomeXml += AllTrim(cDtEnvio) + AllTrim(cHrEnvio) + "_" + AllTrim(cRegist) + ".xml"
Return cNomeXml

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPxDtXml

Função para recuperar a data/hora de envio que foi registrado no XML.

@param cXml   - String com o XML enviado

@return aRet - Array com a data e hora de envio.
          [1] - Data de envio AAAAMMDD
          [2] - Hora de envio HH:MM:SS

@author  Lucas Konrad França
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPxDtXml(cXml)
   Local cError     := ""
   Local cWarning   := ""
   Local aRet       := {"",""}

   Private oXml

   cXml := PCPxForXML(cXml)

   oXml := XmlParser(cXml, "_", @cError, @cWarning)
   If oXml != Nil .And. Empty(cError) .And. Empty(cWarning)
      aDtHrEnvio := StrTokArr(oXml:_TOTVSMessage:_MessageInformation:_GeneratedOn:Text,"T")
      aRet[1]    := SubStr(aDtHrEnvio[1],1,4)+SubStr(aDtHrEnvio[1],6,2)+SubStr(aDtHrEnvio[1],9,2)
      aRet[2]    := aDtHrEnvio[2]
      FwFreeObj(oXml)
      oXml := Nil
   EndIf

Return aRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPxForXML

Função para retirar o caracter especial & do XML.

@param cXml   - String com o XML enviado
@return cXml - String com o XML sem o caracter especial &

@author  Michele Lais Girardi
@version P12
@since   04/02/2022
/*/
//-------------------------------------------------------------------------------------------------
Function PCPxForXML(cXml)

	cXml := StrTran( cXml, "&", " " )

Return cXml

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPRotXml

Função para recuperar a rotina que gerou o xml.

@param cXml   - String com o XML enviado

@return cRotina - Rotina que gerou o XML. Ex: MATA650

@author  Lucas Konrad França
@version P12
@since   24/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPRotXml(cXml)
   Local cError    := ""
   Local cWarning  := ""
   Local cRotina   := ""

   Private oXml

   oXml := XmlParser(cXml, "_", @cError, @cWarning)
   If oXml != Nil .And. Empty(cError) .And. Empty(cWarning)
      If Type('oXml:_TOTVSMessage:_MessageInformation:_Product:_Name') != "U"
         cRotina := oXml:_TOTVSMessage:_MessageInformation:_Product:_Name:Text
      EndIf
      FwFreeObj(oXml)
      oXml := Nil
   EndIf

Return cRotina

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPEvntXml

Função para recuperar o evento que foi enviado no XML

@param cXml   - String com o XML enviado

@return cEvent - Evento do XML. upsert/delete

@author  Lucas Konrad França
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPEvntXml(cXml)
   Local cError     := ""
   Local cWarning   := ""
   Local cEvent     := ""

   Private oXml

   oXml := XmlParser(cXml, "_", @cError, @cWarning)
   If oXml != Nil .And. Empty(cError) .And. Empty(cWarning)
      If Type("oXml:_TOTVSMessage:_BusinessMessage:_BusinessEvent:_Event") != "U"
         cEvent := oXml:_TOTVSMessage:_BusinessMessage:_BusinessEvent:_Event:Text
      EndIf
      FwFreeObj(oXml)
      oXml := Nil
   EndIf

Return cEvent

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPFiltPPI

Função para realizar o filtro da integração com o PCFactory, conforme cadastros na tabela SOE.

@param cTable - Nome da tabela que será filtrada.
@param cValue - Valor que será adicionado no filtro
@param cPont  - Indica a forma que será referenciado um campo.
						Exemplo: Para acessar o M->B1_COD, o parâmetro cPont deve ser igual a "M".
									 Para acessar o SB1->B1_COD, o parâmetro cPont deve ser igual a "SB1".
									 Quando for necessário acessar um valor de um modelo (oModel), deve ser
									 passado o parâmetro como "oModel:GetValue('?')", e a variável oModel deve ser Private.

@return lRet - .T. se o registro será integrado, .F. se não será integrado.

@author  Lucas Konrad França
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPFiltPPI(cTable, cValue, cPont)
   Local aArea     := GetArea()
   Local aCampos   := {}
   Local lRet      := .T.
   Local nI        := 0
   Local cQuery    := ""
   Local cFiltro   := ""

   //Verifica se existe algum filtro para a tabela na SOE
   dbSelectArea("SOE")
   SOE->(dbSetOrder(1))
   If SOE->(dbSeek(xFilial("SOE")+cTable))
      cFiltro := SOE->OE_FILTRO
      //Troca as aspas duplas por simples.
      cFiltro := StrTran(cFiltro,'"',"'")
   EndIf

   //Se existe algum filtro cadastrado, realiza a consulta para verificar se o item será integrado.
   If !Empty(cFiltro)
      If ValType(cValue) == "N"
         cValue := cValToChar(cValue)
      EndIf

      cFiltro := cFiltro
      cFiltro := StrTran(cFiltro," AND "," .AND. ")
      cFiltro := StrTran(cFiltro," OR "," .OR. ")
      cFiltro := StrTran(cFiltro," ="," ==")
      cFiltro := StrTran(cFiltro,AllTrim(cTable)+"."," ")
      cFiltro := convLike(cFiltro)
      cFiltro := conTamInf(cFiltro,cTable)
      cFiltro := aJustFlds(cFiltro,cTable,cPont)
	  lRet := &(cFiltro)
   EndIf
   RestArea(aArea)
Return lRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} aJustFlds

Ajusta os campos da string de filtro.

@param cFiltro - Filtro que será utilizado
@param cTable - Nome da tabela que será filtrada.
@param cPont - Ponteiro que está sendo utilizado

@return cFiltro - Filtro com os campos corretos

@author  Lucas Konrad França
@version P12
@since   28/12/2016
/*/
//-------------------------------------------------------------------------------------------------
Static Function aJustFlds(cFiltro,cTable,cPont)
	Local cNome      := ""
	Local cCampo     := ""
	Local cNewCampo  := ""
	Local cNewFiltro := cFiltro
	Local nI         := 0
	Local nX         := 0
	Local aCampos    := {}

	If SubStr(cTable,1,1) == "S"
		cNome := SubStr(cTable,2,2) + "_"
	Else
		cNome := AllTrim(cTable)+"_"
	EndIf

	For nI := 1 To Len(cFiltro)
		//Encontrou um campo
		If SubStr(cFiltro, nI, Len(cNome)) == cNome
			For nX := nI To Len(cFiltro)
				If SubStr(cFiltro,nX,1) $ " ')"
					cCampo := SubStr(cFiltro, nI, nX-nI)
					//Se já processou esse campo.
					If aScan(aCampos,cCampo) > 0
						Exit
					EndIf
					//Quando existir o caracter '?' dentro do cPont, significa
					//que os valores devem ser pegos de um model.
					//Ex: oModel:GetValue('?')
					//o '?' deverá ser substituido pelo nome do campo que é
					//necessário recuperar o valor.
					//Caso não exista o '?' na cPont, utiliza ponteiro para
					//recuperar o valor do campo.
					//Ex: M->B1_COD || SB1->B1_COD
					If AT("?",cPont) > 0
						cNewCampo := StrTran(cPont,"?",AllTrim(cCampo))
					Else
						cNewCampo := AllTrim(cPont) + "->" + AllTrim(cCampo)
					EndIf
					cNewFiltro := StrTran(cNewFiltro,AllTrim(cCampo),AllTrim(cNewCampo))
					aAdd(aCampos,AllTrim(cCampo))
					Exit
				EndIf
			Next nX
		EndIf
	Next nI
Return cNewFiltro

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} conTamInf

Ajusta o tamanho das informações no filtro.

@param cFiltro - Filtro que será utilizado
@param cTable - Nome da tabela que será filtrada.

@return cFiltro - Filtro com o tamanho dos valores corrigidos.

@author  Lucas Konrad França
@version P12
@since   28/04/2016
/*/
//-------------------------------------------------------------------------------------------------
Static Function conTamInf(cFiltro,cTable)
	Local cNome    := ""
	Local cCampo   := ""
	Local cTipo    := ""
	Local cValor   := ""
	Local cSubs    := ""
	Local cSubsAux := ""
	Local nI       := 1
	Local nX       := 0
	Local nJ       := 0
	Local nTam     := 0
	Local lPula    := .F.

	If SubStr(cTable,1,1) == "S"
		cNome := SubStr(cTable,2,2) + "_"
	Else
		cNome := AllTrim(cTable)+"_"
	EndIf

	While nI <= Len(cFiltro)
		//Encontrou um campo
		If SubStr(cFiltro, nI, Len(cNome)) == cNome
			nTam  := 0
			cTipo := ""
			For nX := nI To Len(cFiltro)
				If SubStr(cFiltro,nX,1) == " "
					cCampo := SubStr(cFiltro, nI, nX-nI)
					//Verifica se este campo está sendo utilizando em uma instrução LIKE. Se sim, ignora este campo.
					lPula := .F.
					For nJ := nI To 1 Step -1
						If SubStr(cFiltro, nJ, 1) == " "
							If nJ > 1 .And. SubStr(cFiltro, nJ-1, 1) == " "
								Loop
							EndIf
							If nJ > 1 .And. SubStr(cFiltro, nJ-1, 1) == "$"
								lPula := .T.
							EndIf
							Exit
						EndIf
					Next nJ
					If lPula
						Exit
					EndIf
					aRet   := TamSX3(AllTrim(cCampo))
					If Len(aRet) > 0
						nTam   := aRet[1]
						cTipo  := aRet[3]
					EndIf
					Exit
				EndIf
			Next nX
			If cTipo == "C"
				//Se é do tipo Char, busca o valor que está no filtro para corrigir o tamanho.
				cValor := ""
				For nX := nI To Len(cFiltro)
					If SubStr(cFiltro,nX,1) == "'"
						For nJ := nX+1 To Len(cFiltro)
							If SubStr(cFiltro,nJ,1) == "'"
								cValor := SubStr(cFiltro,nX+1,nJ-nX-1)
								Exit
							EndIf
						Next nJ
						Exit
					EndIf
				Next nX
				If !Empty(cValor)
					cSubs := SubStr(cFiltro,nI, nJ-nI+1)
					cSubsAux := cSubs
					cSubs := StrTran(cSubs,"'"+cValor+"'","'"+PadR(cValor,nTam)+"'")
					cFiltro := StrTran(cFiltro,cSubsAux,cSubs)
				EndIf
			ElseIf cTipo == "D"
				//Se é do tipo Data, busca o valor que está no filtro para adicionar a função StoD()
				cValor := ""
				For nX := nI To Len(cFiltro)
					If SubStr(cFiltro,nX,1) == "'"
						For nJ := nX+1 To Len(cFiltro)
							If SubStr(cFiltro,nJ,1) == "'"
								cValor := SubStr(cFiltro,nX+1,nJ-nX-1)
								Exit
							EndIf
						Next nJ
						Exit
					EndIf
				Next nX
				If !Empty(cValor)
					cSubs := SubStr(cFiltro,nI, nJ-nI+1)
					cSubsAux := cSubs
					cSubs := StrTran(cSubs,"'"+cValor+"'","StoD('"+cValor+"')")
					cFiltro := StrTran(cFiltro,cSubsAux,cSubs)
				EndIf
			EndIf
		EndIf
		nI ++
	EndDo

Return cFiltro

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} convLike

Converte as expressões "Like" do SQL para expressões em ADVPL, para ser utilizado do dbSetFilter

@param cFiltro - Filtro que será utilizado

@return cFiltro - Filtro convertido

@author  Lucas Konrad França
@version P12
@since   28/04/2016
/*/
//-------------------------------------------------------------------------------------------------
Static Function convLike(cFiltro)
	Local nI      := 1
	Local nX      := 1
	Local cCampo  := ""
	Local cExpres := ""
	Local cAux    := ""

	While AT("NOT LIKE",cFiltro) > 0
		cCampo  := ""
		cExpres := ""
		For nI := AT("NOT LIKE",cFiltro)-2 To 1 Step -1
			//Encontra o campo que foi feito o NOT LIKE, para fazer a inversão.
			//Ex: B1_COD NOT LIKE '%ABC%' deve ser transformado em ! 'ABC' $ B1_COD
			If SubStr(cFiltro,nI,1) == " "
			   cCampo := SubStr(cFiltro, nI, AT("NOT LIKE",cFiltro)-nI)
			   Exit
			EndIf
		Next nI
		If !Empty(cCampo)
			//Encontra o valor da expressão
			For nI := AT("NOT LIKE",cFiltro) To Len(cFiltro)
				If SubStr(cFiltro, nI, 2) == "'%"
					For nX := nI To Len(cFiltro)
						If SubStr(cFiltro, nX, 2) == "%'"
							cExpres := SubStr(cFiltro, nI+2, nX-nI-2)
							Exit
						EndIf
					Next nX
					Exit
				EndIf
			Next nI
			If !Empty(cExpres)
				cAux := " ! '" + cExpres + "' $ " + cCampo
				cFiltro := StrTran(cFiltro,cCampo + "NOT LIKE '%"+cExpres+"%'",cAux)
			EndIf
		EndIf
	EndDo
	While AT("LIKE",cFiltro) > 0
		cCampo  := ""
		cExpres := ""
		For nI := AT("LIKE",cFiltro)-2 To 1 Step -1
			//Encontra o campo que foi feito o NOT LIKE, para fazer a inversão.
			//Ex: B1_COD LIKE '%ABC%' deve ser transformado em 'ABC' $ B1_COD
			If SubStr(cFiltro,nI,1) == " "
			   cCampo := SubStr(cFiltro, nI, AT("LIKE",cFiltro)-nI)
			   Exit
			EndIf
		Next nI
		If !Empty(cCampo)
			//Encontra o valor da expressão
			For nI := AT("LIKE",cFiltro) To Len(cFiltro)
				If SubStr(cFiltro, nI, 2) == "'%"
					For nX := nI To Len(cFiltro)
						If SubStr(cFiltro, nX, 2) == "%'"
							cExpres := SubStr(cFiltro, nI+2, nX-nI-2)
							Exit
						EndIf
					Next nX
					Exit
				EndIf
			Next nI
			If !Empty(cExpres)
				cAux := " '" + cExpres + "' $ " + cCampo
				cFiltro := StrTran(cFiltro,cCampo + "LIKE '%"+cExpres+"%'",cAux)
			EndIf
		EndIf
	EndDo
Return cFiltro

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} getStrVal

Retorna um valor em formato de string para adicionar no SQL Insert

@param uValue - Valor que será formatado para string
@param cTipo  - Tipo de dado cadastrado no SX3

@return cValue -> valor formatado em string.

@author  Lucas Konrad França
@version P12
@since   01/09/2015
/*/
//-------------------------------------------------------------------------------------------------
Static Function getStrVal(uValue, cTipo)
   Local cValue := "''"

   Do Case
      Case cTipo == "C"
         If ValType(uValue) != "C" .Or. Empty(uValue)
            uValue := " "
         EndIf
         cValue := "'" + uValue + "'"
      Case cTipo == "N"
         If ValType(uValue) != "N" .Or. Empty(uValue)
            uValue := 0
         EndIf
         cValue := cValToChar(uValue)
      Case cTipo == "D"
         If (ValType(uValue) != "N" .And. ValType(uValue) != "D") .Or. Empty(uValue)
            uValue := StoD('19000101')
         EndIf
         If ValType(uValue) == "D"
            cValue := "StoD('"+DtoS(uValue)+"')"
         Else
            If ValType(uValue) == "N"
               cValue := "StoD('"+cValToChar(uValue)+"')"
            Else
               cValue := "'" + uValue + "'"
            EndIf
         EndIf
      Case cTipo == "L"
         If ValType(uValue) != "L" .Or. Empty(uValue)
            uValue := .F.
         EndIf
         If uValue
            cValue := ".T."
         Else
            cValue := ".F."
         EndIf
      Otherwise
         cValue := "'" + uValue + "'"
   End

Return cValue

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPRetTmp

Volta o nome da tabela temporária na variável cTmpPPI

@param cProgram - Programa que está executando a integração
@param cTemp    - Nome da tabela temporária anterior

@author  Lucas Konrad França
@version P12
@since   29/10/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPRetTmp(cPrograma, cTemp)

   If FunName() != cPrograma
      If Type('cTmpPPI') == "C"
         If Select(cTmpPPI) >= 0
            TCDelFile(cTmpPPI)
         EndIf
         If AllTrim(cTmpPPI) != AllTrim(cTemp)
            cTmpPPI := cTemp
         Else
            cTmpPPI := Nil
         EndIf
      EndIf
   EndIf
Return

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPGtSeqOG

Busca uma sequência para utilização na inclusão da tabela SOG.

@param cTransac  - Indica a transação da tabela SOG
@param cRecurso  - Recurso da tabela SOG
@param cOp        - Ordem de produção da tabela SOG
@param cProduto  - Código do produto da tabela SOG
@param nQuant    - Quantidade da tabela SOG
@param dDtApont  - Data inicial de apontamento da tabela SOG
@param cHrApont  - Hora inicial de apontamento da tabela SOG
@param dDtFApont - Data final de apontamento da tabela SOG
@param cHrFApont - Hora final de apontamento da tabela SOG
@param cStatus   - Status da tabela SOG
@param cOperac   - Operação de apontamento da tabela SOG

@return nSeq - Sequência que será utilizada

@author  Lucas Konrad França
@version P11
@since   26/11/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPGtSeqOG(cTransac, cRecurso, cOp, cProduto, nQuant, dDtApont, cHrApont, dDtFApont, cHrFApont, cStatus, cOperac)
   Local nSeq      := 0
   Local cQuery    := ""
   Local aBkpArea  := GetArea()
   Local cAliasQry := GetNextAlias()

   cQuery := " SELECT MAX(OG_SEQ) SEQUENCIA "
   cQuery +=   " FROM " + RetSqlName("SOG") + " SOG "
   cQuery +=  " WHERE SOG.OG_FILIAL  = '" + xFilial("SOG") + "' "
   cQuery +=    " AND SOG.OG_TRANSAC = '" + cTransac + "'"
   cQuery +=    " AND SOG.OG_RECURSO = '" + Iif(cRecurso==Nil,' ', cRecurso) + "'"
   cQuery +=    " AND SOG.OG_OP      = '" + Iif(cOp==Nil,' ', cOp) + "'"
   cQuery +=    " AND SOG.OG_PRODUTO = '" + Iif(cProduto==Nil,' ',cProduto) + "'"
   cQuery +=    " AND SOG.OG_QUANTID = "  + Iif(nQuant==Nil,'0',cValToChar(nQuant))
   cQuery +=    " AND SOG.OG_DTAPONT = '" + Iif(dDtApont==Nil,' ',DtoS(dDtApont)) + "'"
   cQuery +=    " AND SOG.OG_HRAPONT = '" + Iif(cHrApont==Nil,' ',cHrApont)+ "'"
   cQuery +=    " AND SOG.OG_DTFIMAP = '" + Iif(dDtFApont==Nil,' ',DtoS(dDtFApont)) + "'"
   cQuery +=    " AND SOG.OG_HRFIMAP = '" + Iif(cHrFApont==Nil,' ',cHrFApont) + "'"
   cQuery +=    " AND SOG.OG_STATUS  = '" + cStatus + "'"
   cQuery +=    " AND SOG.OG_OPERAC  = '" + Iif(cOperac==Nil,' ',cOperac) + "'"

   cQuery := ChangeQuery(cQuery)
   dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
   If !(cAliasQry)->(Eof())
      nSeq := (cAliasQry)->(SEQUENCIA) + 1
   Else
      nSeq := 1
   EndIf
   (cAliasQry)->(dbCloseArea())
   RestArea(aBkpArea)
Return nSeq

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPCriaSOG

Insere um novo registro na tabela SOG.

@param cTransac  - Indica a transação da tabela SOG
@param cRecurso  - Recurso da tabela SOG
@param cOp        - Ordem de produção da tabela SOG
@param cProduto  - Código do produto da tabela SOG
@param nQuant    - Quantidade da tabela SOG
@param dDtApont  - Data inicial de apontamento da tabela SOG
@param cHrApont  - Hora inicial de apontamento da tabela SOG
@param dDtFApont - Data final de apontamento da tabela SOG
@param cHrFApont - Hora final de apontamento da tabela SOG
@param oRcvXml   - Objeto com o XML que foi recebido.
@param cStatus   - Status da tabela SOG
@param cEstorno  - Indica se é um registro de estorno
@param cOperac   - Operação de apontamento da tabela SOG
@param cMsg      - Mensagem que será gravada na tabela SOG.
@param cMotv     - Código do motivo de parada/refugo
@param cTpMv     - Tipo do movimento ('E'ntrada/'S'aida)
@param cPrdDst   - Código do produto destino
@param cPrdOrg   - Código do produto origem
@param cLocOrg   - Código do local origem
@param cLocDst   - Código do local destino

@author  Lucas Konrad França
@version P11
@since   26/11/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPCriaSOG(cTransac, cRecurso, cOp, cProduto, nQuant, dDtApont, cHrApont, dDtFApont, cHrFApont, oRcvXml, cStatus, cEstorno, cOperac, cMsg, cMotv, cTpMv, cPrdDst, cPrdOrg, cLocOrg, cLocDst, cIdMes)

   Local nSeq := 0
   Local nTry := 0

   Default cRecurso  := ''
   Default cOp       := ''
   Default cProduto  := ''
   Default nQuant    := 0
   Default dDtApont  := StoD("")
   Default cHrApont  := ""
   Default dDtFApont := StoD("")
   Default cHrFApont := ""
   Default cStatus   := '1'
   Default cEstorno  := '1'
   Default cOperac   := ''
   Default cMsg      := 'OK'
   Default cMotv     := ""
   Default cTpMv     := ""
   Default cPrdDst   := ""
   Default cPrdOrg   := ""
   Default cLocOrg   := ""
   Default cLocDst   := ""
   Default cIdMes    := ""

   //Utiliza semáforo para não incluir registros com chave duplicada na tabela SOG, quando receber várias mensagens iguais.
   nTry := 0
   While !LockByName("INSERTSOG"+cEmpAnt+cFilAnt,.T.,.T.)
      nTry++
      If nTry > 1000
      	//Conout("Excedeu o limite de tentativas (1000) para travar a tabela SOG e inserir os dados.")
      	Return
      EndIf
      //Conout("Tentativa " + cValToChar(nTry) + " para gravar a tabela SOG.")
      Sleep(100)
   End

   //Utiliza semáforo para não incluir registros com chave duplicada na tabela SOG, quando receber várias mensagens iguais.
   //If LockByName("INSERTSOG"+cEmpAnt+cFilAnt,.T.,.T.)
      nSeq := PCPGtSeqOG(cTransac, cRecurso, cOp, cProduto, nQuant, dDtApont, cHrApont, dDtFApont, cHrFApont, cStatus, cOperac)

      RecLock("SOG",.T.)
      SOG->OG_FILIAL  := xFilial("SOG")
      SOG->OG_TRANSAC := cTransac
      SOG->OG_RECURSO := cRecurso
      SOG->OG_OP      := cOp
      SOG->OG_PRODUTO := cProduto
      SOG->OG_QUANTID := nQuant
      SOG->OG_DTAPONT := dDtApont
      SOG->OG_HRAPONT := cHrApont
      SOG->OG_DTFIMAP := dDtFApont
      SOG->OG_HRFIMAP := cHrFApont
      SOG->OG_DATA    := Date()
      SOG->OG_HORA    := Time()
      SOG->OG_XML     := XMLSaveStr(oRcvXml)
      SOG->OG_OPERAC  := cOperac
      SOG->OG_MSGRET  := cMsg
      SOG->OG_STATUS  := cStatus
      SOG->OG_ESTORNO := cEstorno
      SOG->OG_SEQ     := nSeq
      SOG->OG_MOTIVO := cMotv
      SOG->OG_TPMV   := cTpMv
      SOG->OG_PRODST := cPrdDst
      SOG->OG_PROORG := cPrdOrg
      SOG->OG_LOCORG := cLocOrg
      SOG->OG_LOCDST := cLocDst
      SOG->OG_IDMES := cIdMes
      MsUnlock()
      UnLockByName("INSERTSOG"+cEmpAnt+cFilAnt,.T.,.T.)
   //EndIf

Return Nil

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPAtuSOH

Função para Inserir/Atualizar registros na tabela SOH

@param cTransac	- Transação que está sendo executada.
@param cIdMes		- ID do TOTVS MES.
@param cMsg		- Mensagem de retorno do Protheus
@param cStatus	- Status da integração ('0' - Processando, '1' - OK, '2' - Erro)

@return Nil

@author  Lucas Konrad França
@version P11
@since   10/08/2016
/*/
//-------------------------------------------------------------------------------------------------
Function PCPAtuSOH(cTransac, cIdMes, cMsg, cStatus)
Default cMsg     := ""
Default cStatus  := "0"
Default lAutomacao := .F.

cIdMes := PadR(cIdMes, TamSX3("OH_IDMES")[1])


dbSelectArea("SOH")
SOH->(dbSetOrder(1))
If SOH->(dbSeek(xFilial("SOH")+cIdMes))
	//Atualiza o registro
	If !lAutomacao
		RecLock("SOH",.F.)
			SOH->OH_MSG    := cMsg
			SOH->OH_STATUS := cStatus
		SOH->(MsUnLock())
	EndIf
Else
	//Inclui o registro
	RecLock("SOH",.T.)
		SOH->OH_FILIAL  := xFilial("SOH")
		SOH->OH_TRANSAC := cTransac
		SOH->OH_IDMES   := cIdMes
		SOH->OH_MSG     := cMsg
		SOH->OH_STATUS  := cStatus
		If cStatus == "0"
			//Grava a data/hora de início do processamento
			SOH->OH_DATA := DATE()
			SOH->OH_HORA := Time()
		EndIf
	SOH->(MsUnLock())
EndIf

Return

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPVldIMes

Valida se é permitido executar a integração TOTVS MES com o ID informado na mensagem.

@param cIdMes			- ID do TOTVS MES.
@param cMsg			- Mensagem de retorno. Passar por referência (@cMsg)
@param cStatus		- Status do processamento (0=Em processamento;1=Ok;2=Erro). Passar por referência (@cStatus)
@param lReprocess	- Identifica se o registro deverá ser processado novamente, caso tenha sido processando anteriormente com erro.

@return lRet			- Identifica se a integração será executada ou não.

@author  Lucas Konrad França
@version P11
@since   10/08/2016
/*/
//-------------------------------------------------------------------------------------------------
Function PCPVldIMes(cIdMes, cMsg, cStatus,lReprocess)
Local lRet := .T.

Default lReprocess := .F.

dbSelectArea("SOH")
SOH->(dbSetOrder(1))
If SOH->(dbSeek(xFilial("SOH")+PadR(cIdMes,TamSX3("OH_IDMES")[1])))
	cStatus := SOH->OH_STATUS
	If SOH->OH_STATUS == "0"
		cMsg := "ID " + AllTrim(cIdMes) + STR0043 //" está sendo processado pelo Protheus."
		lRet := .F.
	ElseIf SOH->OH_STATUS == "1"
		cMsg := "ID " + AllTrim(cIdMes) + STR0044 + AllTrim(SOH->OH_MSG) //" já processado. Status: "
		lRet := .F.
	ElseIf SOH->OH_STATUS == "2"
		If lReprocess
			lRet := .T.
		Else
			cMsg := "ID " + AllTrim(cIdMes) + STR0044 + AllTrim(SOH->OH_MSG) //" já processado. Status: "
			lRet := .F.
		EndIf
	EndIf
Else
	lReprocess := .F.
EndIf
If !lRet
	lReprocess := .F.
EndIf
cMsg := StrTran(cMsg," Reprocessado.","")
Return lRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPIntgMRP

Busca o parâmetro da integração com o PPI Multitask para a rotina do MRP.

@return cInteg - Parâmetro da integração. 1 - Não integra; 2 - Gera pendência; 3 - Integra.

@author  Lucas Konrad França
@version P11
@since   27/11/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPIntgMRP()
   Local cInteg := "1"

   dbSelectArea("SOE")
   SOE->(dbSetOrder(1))
   If SOE->(dbSeek(xFilial("SOE")+"SC2"))
      cInteg := Iif(Empty(SOE->OE_PARINTG),"1",AllTrim(SOE->OE_PARINTG))
   EndIf
Return cInteg

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPObrigat

Verifica se os campos obrigatórios foram informados.

@param cTable	- Tabela que será verificada

@return lRet	- Indica se os campos estão válidos.

@author  Lucas Konrad França
@version P11
@since   15/08/2016
/*/
//-------------------------------------------------------------------------------------------------
Function PCPObrigat(cTable)
Local lRet    := .T.
/*Local aAreaX3 := SX3->(GetArea())
Local nI      := 0

SX3->(dbSetOrder(1))
If SX3->(dbSeek(cTable))
	While SX3->(!Eof()) .And. AllTrim(SX3->X3_ARQUIVO) == AllTrim(cTable)
		If SX3->X3_CONTEXT != "V" .And. X3Obrigat(SX3->X3_CAMPO) .And. Empty(&("M->"+SX3->X3_CAMPO)) .And. X3USO(SX3->X3_USADO,10)
			If ValType(&("M->"+SX3->X3_CAMPO)) == "N" .And. &("M->"+SX3->X3_CAMPO) == Nil .Or. ValType(&("M->"+SX3->X3_CAMPO)) != "N"
				Help( ,, 'Help',, STR0041 + AllTrim(SX3->X3_CAMPO) + " - " + AllTrim(SX3->X3_DESCRIC) + STR0042 , 1, 0 ) //"Campo obrigatório '" X3_CAMPO - X3_DESCRIC "' não informado."
				lRet := .F.
				Exit
			EndIf
		EndIf
		SX3->(dbSkip())
	End
EndIf
SX3->(RestArea(aAreaX3))*/
Return lRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPIntgAPS

Busca o parâmetro da integração com o PPI Multitask para a rotina do APS.

@return cInteg - Parâmetro da integração. 0 - Não integra; 1 - Integra.

@author  Michelle Ramos Henriques
@version P12
@since   23/10/2017
/*/
//-------------------------------------------------------------------------------------------------
Function PCPIntgAPS()
   Local cInteg := "0"

   If SOE->(ColumnPos("OE_VAR4"))
      dbSelectArea("SOE")
      SOE->(dbSetOrder(1))
      If SOE->(dbSeek(xFilial("SOE")+"SC2"))
         cInteg := Iif(Empty(SOE->OE_VAR4),"1",AllTrim(OE_VAR4))
      EndIf
   EndIf
Return cInteg

//-------------------------------------------------------------------
/*/{Protheus.doc} PCPREVTAB
Função para gravação do campo Revisão, se grava na SB1, SBZ ou ambas
@author  Thiago.Zoppi
@since   28/08/2018
@version P12
@param cCodPro		- Produto a ser alerado a revisão
@param cRevisao		- Revisão a ser grava no produto SBZ, SB1 ou ambos.
@return Nil

Quando as tabelas SG1 e SBZ estiverem com modo exclusivo e
MV_ARQPROD = "SBZ" - gravar revisão no campo BZ_REVATU
e além dos parametros acima se a SB1 for exclusiva, também gravar
nos campos BZ_REVATU e B1_REVATU.
/*/
//-------------------------------------------------------------------
FUNCTION PCPREVTAB(cCodPro,cRevisao)
Local aArea			:= GetArea()
Local lModFilSG1	:= FWModeAccess("SG1",3)== "E"  //Filial
Local lModFilSBZ	:= FWModeAccess("SBZ",3)== "E"	//Filial
Local lModFilSB1	:= FWModeAccess("SB1",3)== "E" //Filial
Local lARQPRODBZ	:= SuperGetMV("MV_ARQPROD",.F.,"SB1") == "SBZ"
Local lRevFil		:= SuperGetMv("MV_REVFIL",.F.,.F.) // controla revisao estrutura por filial SBZ

	dbSelectArea("SBZ")
	If FieldPos("BZ_REVATU") > 0 .AND. lModFilSG1 .AND. lModFilSBZ .AND. lARQPRODBZ .and. lRevFil

		dbSelectArea("SBZ")
		aAreaSBZ:=GetArea()
		dbSetOrder(1)
		If dbSeek(xFilial("SBZ")+cCodPro)
			RecLock("SBZ",.F.)
			Replace BZ_REVATU With cRevisao
			MsUnlock()
			RestArea(aAreaSBZ)

				IF lModFilSB1
					dbSelectArea("SB1")
					aAreaSB1:=GetArea()
					dbSetOrder(1)
					If dbSeek(xFilial("SB1")+cCodPro)
						RecLock("SB1",.F.)
						Replace B1_REVATU With cRevisao
						MsUnlock()
					EndIf
					RestArea(aAreaSB1)
				EndIf

		ELSE

			dbSelectArea("SB1")
			aAreaSB1:=GetArea()
			dbSetOrder(1)
			If dbSeek(xFilial("SB1")+cCodPro)
				RecLock("SB1",.F.)
				Replace B1_REVATU With cRevisao
				MsUnlock()
			EndIf
			RestArea(aAreaSB1)

		EndIf

	ELSE

		dbSelectArea("SB1")
		aAreaSB1:=GetArea()
		dbSetOrder(1)
		If dbSeek(xFilial("SB1")+cCodPro)
			RecLock("SB1",.F.)
			Replace B1_REVATU With cRevisao
			MsUnlock()
		EndIf
		RestArea(aAreaSB1)

	EndIf
RestArea(aArea)
RETURN

//-------------------------------------------------------------------
/*/{Protheus.doc} PCPREVATU
Função que retorna a revisao do produto.
@author  Thiago.Zoppi
@since   28/08/2018
@version P12
@param cCodPro		- Produto a ser alerado a revisão
@return cRevisao	- Revisão dp produto
/*/
//-------------------------------------------------------------------
FUNCTION PCPREVATU(cCodPro)
Local aArea			:= GetArea()
Local aAreaSB1		:= SB1->(GetArea())
Local aAreaSBZ		:= SBZ->(GetArea())
Local cDadosProd	:= SuperGetMV("MV_ARQPROD",.F.,"SB1")
Local cRevisao		:= ''
Local cQuery		:= ''
Local cWhereBZ		:= ', BZ_REVATU '
Local lRevAtuCpo    := .T.
Local lRevFil		:= SuperGetMv("MV_REVFIL",.F.,.F.) // controla revisao estrutura por filial SBZ

If FieldPos("BZ_REVATU") < 0
	lRevAtuCpo := .F.
	cWhereBZ   := ''
EndIf

cQuery	:= "SELECT B1_COD, BZ_COD, B1_REVATU "+cWhereBZ+" "
cQuery  += " FROM "+RetSqlName('SB1')+ " SB1 "
cQuery  += " LEFT JOIN "+RetSqlName('SBZ')+ " SBZ ON (BZ_FILIAL = '"+xFilial("SBZ")+"' AND BZ_COD = B1_COD AND SBZ.D_E_L_E_T_ = ' ')"
cQuery	+= " WHERE "
cQuery	+= " SB1.B1_FILIAL = '"+xFilial("SB1")+"' AND "
cQuery	+= " SB1.B1_COD = '"+cCodPro+"' AND "
cQuery	+= " SB1.D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)
dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"QRYSBZ",.F.,.T.)

If !Empty(QRYSBZ->B1_REVATU)
	cRevisao := QRYSBZ->B1_REVATU
Else
	cRevisao :=Criavar("B1_REVATU",.F.)
EndIf

IF cDadosProd == "SBZ" .AND. lRevFil .AND. lRevAtuCpo
	If !Empty(QRYSBZ->BZ_REVATU)
		cRevisao := QRYSBZ->BZ_REVATU
	EndIf
EndIf

QRYSBZ->(DbCloseArea())

RestArea(aAreaSB1)
RestArea(aAreaSBZ)
RestArea(aArea)

RETURN cRevisao

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³ Estrut   ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 03/08/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Faz a explosao de uma estrutura a partir do SG1            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ ExpA1:= Estrut(ExpC1,ExpN1,ExpL1,ExpL2)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do produto a ser explodido                  ³±±
±±³          ³ ExpN2 = Quantidade base para explosao da estrutura         ³±±
±±³          ³ ExpL3 = Identifica se explode somente primeiro nivel       ³±±
±±³          ³ ExpL4 = Identifica se explode PRE-ESTRUTURA                ³±±
±±³          ³ ExpL5 = Identifica se considera produto bloqueado          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observa‡„o³ Como e uma funcao recursiva precisa ser criada uma variavel³±±
±±³          ³ private nEstru com valor 0 antes da chamada da fun‡„o.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function Estrut(cProduto,nQuant,lOneLevel,lPreEstru,lPrdBlq)
LOCAL nRegi
LOCAL nQuantItem := 0
LOCAL cCodigo,cComponente,cTrt,cGrOpc,cOpc
Local aArea := GetArea()

DEFAULT lOneLevel := .F.
DEFAULT lPreEstru := .F.
DEFAULT lPrdBlq   := .T.

nQuant:=IF(nQuant == NIL,1,nQuant)
nEstru++
If nEstru == 1
	aEstrutura:={}
EndIf
dbSelectArea(If(lPreEstru,"SGG","SG1"))
dbSetOrder(1)
dbSeek(xFilial()+cProduto)
While !Eof() .And. If(lPreEstru,GG_FILIAL+GG_COD,G1_FILIAL+G1_COD) == xFilial()+cProduto
	nRegi:=Recno()
	cCodigo    :=If(lPreEstru,GG_COD,G1_COD)
	cComponente:=If(lPreEstru,GG_COMP,G1_COMP)
	cTrt       :=If(lPreEstru,GG_TRT,G1_TRT)
	cGrOpc     :=If(lPreEstru,GG_GROPC,G1_GROPC)
	cOpc       :=If(lPreEstru,GG_OPC,G1_OPC)
	If cCodigo != cComponente

		If !lPrdBlq
			SB1->(DbSetOrder(1))
			If SB1->(DbSeek(xFilial("SB1")+cComponente))
	            If SB1->B1_MSBLQL=="1"
	            	dbSkip()
	            	Loop
	            EndIf
	        EndIf
        EndIf

		nProcura:=aScan(aEstrutura,{|x| x[1] == nEstru .And. x[2] == cCodigo .And. x[3] == cComponente .And. x[5] == cTrt})
		If nProcura  = 0
			nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru)
			AADD(aEstrutura,{nEstru,cCodigo,cComponente,nQuantItem,cTrt,cGrOpc,cOpc,Recno()})
		Else
			nProcura:=aScan(aEstrutura,{|x| x[1] == nEstru .And. x[2] == cCodigo .And. x[3] == cComponente .And. x[5] == cTrt .And. x[4] == 0 })
			If nProcura > 0
				nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru)
				If nQuantItem > 0
					aEstrutura[nProcura,4] := nQuantItem
					aEstrutura[nProcura,6] := cGrOpc
					aEstrutura[nProcura,7] := cOpc
					aEstrutura[nProcura,8] := Recno()
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se existe sub-estrutura               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !lOneLevel
			nRecno:=Recno()
			dbSeek(xFilial()+cComponente)
			IF Found()
				cCodigo:=If(lPreEstru,GG_COD,G1_COD)
				Estrut(cCodigo,nQuantItem,nil,lPreEstru,lPrdBlq)
				nEstru --
			Else
				MsGoto(nRecno)
				nProcura:=aScan(aEstrutura,{|x| x[1] == nEstru .And. x[2] == cCodigo .And. x[3] == cComponente .And. x[5] == cTrt})
				If nProcura  = 0
					nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru)
					AADD(aEstrutura,{nEstru,cCodigo,cComponente,nQuantItem,cTrt,cGrOPc,cOpc,Recno()})
				Else
					nProcura:=aScan(aEstrutura,{|x| x[1] == nEstru .And. x[2] == cCodigo .And. x[3] == cComponente .And. x[5] == cTrt .And. x[4] == 0 })
					If nProcura > 0
						nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru)
						If nQuantItem > 0
							aEstrutura[nProcura,4] := nQuantItem
							aEstrutura[nProcura,6] := cGrOpc
							aEstrutura[nProcura,7] := cOpc
							aEstrutura[nProcura,8] := Recno()
						EndIf
					EndIf
				EndIf
			Endif
		EndIf
	EndIf
	MsGoto(nRegi)
	dbSkip()
Enddo
RestArea(aArea)
Return(aEstrutura)

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPVldRev

Verifica se a revisão do prduto na estrutura informada é valida

@param cProd  - Produto pai
@param cRev   - Revisão Estrutura


@return lRet - .T. - Existe Revisão; .F. Não existe Revisão

@author  FABIO DAVID CORTES
@version P12
@since   17/04/2017
/*/
//-------------------------------------------------------------------------------------------------
Function PCPVldRev(cProd,cRev)
	Local cQuery    := ""
	Local aBkpArea  := GetArea()
	Local cAliasQry := GetNextAlias()
	Local lRet		    := .F.

	dbSelectArea("SG5")
	dbSetOrder(1)
	If MsSeek( xFilial("SG5")+cProd+cRev)
		lRet	 := .T.
	Else
		cQuery := " SELECT G1_COMP "
		cQuery += " FROM " + RetSqlName("SG1") + " SG1 "
		cQuery += " WHERE SG1.G1_FILIAL  = '" + xFilial("SG1") + "' "
		cQuery += " AND SG1.G1_COD     = '" + cProd + "'"
		cQuery += " AND '" + cRev + "' BETWEEN G1_REVINI AND G1_REVFIM "
		cQuery += " AND D_E_L_E_T_ <> '*' "

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
		If !(cAliasQry)->(Eof())
			lRet	 := .T.
		Else
			lRet	 := .F.
		EndIf
		(cAliasQry)->(dbCloseArea())
		RestArea(aBkpArea)
	EndIf


Return lRet

/*/{Protheus.doc} PCPXSldSB2
@param 01 cFilialArm, characters, indica a filial do produto a ter seu saldo pesquisado
@param 02 cProduto  , characters, indica o produto a ter seu saldo pesquisado
@param 03 cLocal    , characters, indica o armazém do produto a ter seu saldo pesquisado
@return nSaldo, numeric, saldo em estoque para o Produto e Local

@author Marcelo Neumann
@since 14/03/2019
@version 1.0
/*/
Function PCPXSldSB2(cFilialArm, cProduto, cLocal)

	Local aArea     := GetArea()
	Local cAliasSB2 := GetNextAlias()
	Local cQuerySB2 := ""
	Local nSaldo    := 0

	cQuerySB2 := "SELECT *"
	cQuerySB2 +=  " FROM " + RetSqlName("SB2")
	cQuerySB2 += " WHERE B2_FILIAL  = '" + xFilial("SB2",cFilialArm) + "'"
	cQuerySB2 +=   " AND B2_COD     = '" + cProduto + "'"
	cQuerySB2 +=   " AND B2_LOCAL   = '" + cLocal + "'"
	cQuerySB2 +=   " AND D_E_L_E_T_ = ' '"

	dbUseArea(.T., "TOPCONN", TcGenQry( , , cQuerySB2), cAliasSB2, .T., .T.)
	While (cAliasSB2)->(!Eof())
		nSaldo += SaldoSB2(/*lNecessidade*/,/*lEmpenho*/,/*dDataFim*/,/*lConsTerc*/,/*lConsNPT*/,cAliasSB2,/*nQtdEmp*/,/*nQtdPrj*/,/*lSaldoSemR*/,/*dDtRefSld*/,/*lConsEmpSA*/)
		dbSkip()
	End
	(cAliasSB2)->(dbCloseArea())

	RestArea(aArea)

Return nSaldo

/*/{Protheus.doc} PCPXLocCmp
Retorna o local de consumo (armazém) do componente:
	1. Pesquisa pelo armazém na estrutura:
		Através do código do produto pai, componente, TRT e revisão do componente.
		Campo: G1_LOCCONS

	2. Se não possuir armazém na estrutura, pesquisa pelo armazém no centro de trabalho:
		Através do roteiro padrão do produto pai (B1_OPERPAD)
		Checa a operação onde o componente é utilizado (SGF) ou última operação (SG2).
		Com a operação, identifica-se o centro de trabalho (G2_CTRAB).
		No cadastro de centro de trabalho deve-se buscar o local de consumo.
		Campo: HB_LOCAL.

	3. Se não existir armazém no centro de trabalho, pesquisar o armazém no produto.
		Campo: B1_LOCPAD

@param 01 cProd   , characters, código do produto
@param 02 cComp   , characters, código do componente
@param 03 cTrt    , characters, sequência (TRT) do componente na estrutura
@param 04 cRevisao, characters, revisão a ser considerada na busca do componente
@param 05 dData   , date      , data a ser considerada na busca da versão da produção
@param 06 nQuant  , numeric   , quantidade a ser considerada na busca da versão da produção
@return aLocal, array, local de consumo do componente:
                       [1] Código do local
					   [2] Indicador da Origem: 1 (Estrutura)
					                            2 (Centro de Trabalho)
												3 (Versão da Produção)
												4 (Produto)

@author Marcelo Neumann
@since 17/12/2018
@version 1.0
/*/
Function PCPXLocCmp(cProd, cComp, cTrt, cRevisao, dData, nQuant)

    Local aArea     := GetArea()
	Local aAreaSG1  := SG1->(GetArea())
	Local aAreaSG2  := SG2->(GetArea())
	Local aAreaSB1  := SB1->(GetArea())
	Local aAreaSGF  := SGF->(GetArea())
	Local aAreaSHB  := SHB->(GetArea())
	Local cAliasQry := GetNextAlias()
	Local cQuery    := ""
	Local cRotPad   := ""
	Local cOperac   := ""
	Local cCenTrab  := ""
	Local cLocal    := ""
	Local nOrigem   := 0
	Local aLocal    := {}

	Default dData   := dDataBase

	//1. Pesquisa pelo armazém na estrutura
	BeginSQL Alias cAliasQry
		SELECT SG1.G1_LOCCONS
		  FROM %Table:SG1% SG1
		 WHERE SG1.G1_FILIAL = %XFilial:SG1%
		   AND SG1.G1_COD    = %Exp:cProd%
		   AND SG1.G1_COMP   = %Exp:cComp%
		   AND SG1.G1_TRT    = %Exp:cTrt%
		   AND %Exp:cRevisao% BETWEEN SG1.G1_REVINI AND SG1.G1_REVFIM
		   AND SG1.%NotDel%
	EndSQL
	If !(cAliasQry)->(Eof())
		cLocal  := (cAliasQry)->G1_LOCCONS
		nOrigem := 1
	EndIf
	(cAliasQry)->(dbCloseArea())

	//2. Se não possuir armazém na estrutura, pesquisa pelo armazém no centro de trabalho
	If Empty(cLocal)
		//Busca o roteiro padrão do produto pai
		dbSelectArea("SB1")
		SB1->(dbSetOrder(1))
		If SB1->(MsSeek(xFilial("SB1") + cProd))
			//Verifica se o roteiro existe
			dbSelectArea("SG2")
			SG2->(dbSetOrder(1))
			If SG2->(MsSeek(xFilial("SG2") + cProd + SB1->B1_OPERPAD))
				cRotPad := SB1->B1_OPERPAD
			EndIf
		EndIf

		//Se existir um roteiro padrão do produto pai
		If !Empty(cRotPad)
			//Busca a operação cadastrada para o Roteiro-Produto-Componente
			dbSelectArea("SGF")
			SGF->(dbSetOrder(2))
			If SGF->(MsSeek(xFilial("SGF") + cProd + cRotPad + cComp + cTrt))
				cOperac := SGF->GF_OPERAC
			EndIf

			//Busca o Centro de Trabalho
			cQuery := "SELECT SG2.G2_CTRAB"                              + ;
					   " FROM " + RetSqlName("SG2") + " SG2"             + ;
					  " WHERE SG2.G2_FILIAL  = '" + xFilial("SG2") + "'" + ;
						" AND SG2.G2_PRODUTO = '" + cProd          + "'" + ;
						" AND SG2.G2_CODIGO  = '" + cRotPad        + "'" + ;
						" AND SG2.D_E_L_E_T_ = ' '"

			If !Empty(cOperac)
				//Se existe a amarração na SGF, busca pela operação
				cQuery += " AND SG2.G2_OPERAC = '" + cOperac + "'"
			Else
				//Se não, busca a última operação
				cQuery += " ORDER BY SG2.G2_OPERAC DESC"
			EndIf
			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T., "TOPCONN", TCGENQRY( , , cQuery), cAliasQry, .T., .T.)
			If (cAliasQry)->(!Eof())
				cCenTrab := (cAliasQry)->G2_CTRAB
			End
			(cAliasQry)->(dbCloseArea())

			//Se encontrou o Centro de Trabalho, busca o Local cadastrado para ele
			If !Empty(cCenTrab)
				dbSelectArea("SHB")
				SHB->(dbSetOrder(1))
				If SHB->(MsSeek(xFilial("SHB") + cCenTrab))
					cLocal  := SHB->HB_LOCAL
					nOrigem := 2
				EndIf
			EndIf
		EndIf
	EndIf

	//3. Se não existir armazém no centro de trabalho, pesquisa o armazém da versão da produção
	If Empty(cLocal)
		//Busca a Versão de Produção
		cQuery := "SELECT SVC.VC_LOCCONS"                            + ;
		           " FROM " + RetSqlName("SVC") + " SVC"             + ;
		          " WHERE SVC.VC_FILIAL  = '" + xFilial("SVC") + "'" + ;
		            " AND SVC.VC_PRODUTO = '" + cProd          + "'" + ;
		            " AND (SVC.VC_DTINI  = ' ' OR SVC.VC_DTINI <= '" + DToS(dData) + "')" + ;
		            " AND (SVC.VC_DTFIM  = ' ' OR SVC.VC_DTFIM >= '" + DToS(dData) + "')" + ;
		            " AND SVC.D_E_L_E_T_ = ' '"

		If !Empty(nQuant)
			cQuery += " AND SVC.VC_QTDDE  <= '" + cValToChar(nQuant) + "'"
			cQuery += " AND SVC.VC_QTDATE >= '" + cValToChar(nQuant) + "'"
		EndIf

		cQuery += " ORDER BY SVC.R_E_C_N_O_"
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T., "TOPCONN", TCGENQRY( , , cQuery), cAliasQry, .T., .T.)
		If (cAliasQry)->(!Eof())
			cLocal := (cAliasQry)->VC_LOCCONS
			nOrigem := 3
		End
		(cAliasQry)->(dbCloseArea())
	EndIf

	//4. Se não existir armazém na versão da produção, pesquisa o armazém no produto
	If Empty(cLocal)
		dbSelectArea("SB1")
		SB1->(dbSetOrder(1))
		If SB1->(MsSeek(xFilial("SB1") + cComp))
			cLocal  := SB1->B1_LOCPAD
			nOrigem := 4
		EndIf
	EndIf

	aAdd(aLocal, cLocal )
	aAdd(aLocal, nOrigem)

	SG1->(RestArea(aAreaSG1))
	SG2->(RestArea(aAreaSG2))
	SB1->(RestArea(aAreaSB1))
	SGF->(RestArea(aAreaSGF))
	SHB->(RestArea(aAreaSHB))
	RestArea(aArea)

Return aLocal

//-------------------------------------------------------------------
/*/{Protheus.doc} VisOpcPcp(cProduto,mOpc,cOpc,nExibeAll)
Função que abre uma janela popup para visualização dos opcionais.
@author Lucas Konrad França
@since 09/09/2014
@param cProduto - Código do produto. Utilizado quando existir o mOpc
@param mOpc - Valor do memo dos opcionais, que será transformado em um array.
@param cOpc - String concatenada com os opcionais, no formato GGGIIII/ (Grupo, Item)
@param nExibeAll - Utilizado quando existir o mOpc, indicará se serão considerados todos os opcionais (2), ou somente
        o opcional do produto passado por parâmetro.
@version 1.0
@return .T.
/*/
//-------------------------------------------------------------------
Function VisOpcPcp(cProduto,mOpc,cOpc,nExibeAll)
   Local aOpc     := { }
   Local aHeader  := { }
   Local aSizes   := { }
   //Local cREPGOPC := GetMv("MV_REPGOPC")
   Local oDlg
   Local oPanel
   Local oGroup
   Local oBrowse

   Default nExibeAll := 1
   Default lAutomacao := .F.

   aOpc := aClone(ListOpc(cProduto,mOpc,cOpc,nExibeAll))

   If !Empty(mOpc)
      aAdd(aHeader,SubStr(STR0046,1,Len(STR0046)-1)) //Produto
      aAdd(aHeader,STR0047) //Descrição
      aAdd(aSizes,60)
      aAdd(aSizes,100)
      aAdd(aSizes,30)
      aAdd(aSizes,70)
      aAdd(aSizes,30)
      aAdd(aSizes,70)
   Else
      aAdd(aSizes,60)
      aAdd(aSizes,100)
      aAdd(aSizes,60)
      aAdd(aSizes,100)
   EndIf

   aAdd(aHeader,STR0048) //Grupo
   aAdd(aHeader,STR0047) //Descrição
   aAdd(aHeader,AllTrim(STR0049)) //Item
   aAdd(aHeader,STR0047) //Descrição

   If Len(aOpc) > 0

      //If cREPGOPC == "S"
      //   aSort(aOpc, , , {|x,y|(x[1]+x[3]+x[5] < y[1]+y[3]+y[5])})
      //Else
      //   aSort(aOpc, , , {|x,y|(x[3]+x[5] < y[3]+y[5])})
      //EndIf
	  If !lAutomacao
		DEFINE MSDIALOG oDlg TITLE STR0050 FROM 0,0 TO 350,800 PIXEL

		oPanel:= tPanel():Create(oDlg, 1, 1,,,,,,, 350, 800)
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT

		oGroup:= TGroup():New(05,07,152,396,STR0050,oPanel,,,.T.)

		oBrowse := TWBrowse():New(14,12,380,135,,aHeader,aSizes,oPanel,,,,,,,,,,,,.F.,,.T.,,.F.,,.T.,.T.)
		oBrowse:SetArray(aOpc)
		If !Empty(mOpc)
			oBrowse:bLine := {||{ aOpc[oBrowse:nAT,01],aOpc[oBrowse:nAt,02],aOpc[oBrowse:nAt,03],aOpc[oBrowse:nAt,04],aOpc[oBrowse:nAt,05],aOpc[oBrowse:nAt,06]}}
		Else
			oBrowse:bLine := {||{ aOpc[oBrowse:nAT,03],aOpc[oBrowse:nAt,04],aOpc[oBrowse:nAt,05],aOpc[oBrowse:nAt,06]}}
		EndIf

		DEFINE SBUTTON FROM 158,370 TYPE 1 ACTION (oDlg:End()) ENABLE OF oPanel
		ACTIVATE MSDIALOG oDlg CENTER
	 EndIf
   Else
      Help( ,, 'Help',, STR0051 , 1, 0 )
   EndIf
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} ListOpcPcp(cProduto,mOpc,cOpc,nExibeAll)
Função que interpreta os opcionais concatenados, e retorna um array com as descrições dos grupos e dos itens opcionais.
@author Lucas Konrad França
@since 09/09/2014
@param cProduto - Código do produto. Utilizado quando existir o mOpc
@param mOpc - Valor do memo dos opcionais, que será transformado em um array.
@param cOpc - String concatenada com os opcionais, no formato GGGIIII/ (Grupo, Item)
@param nExibeAll - Utilizado quando existir o mOpc, indicará se serão considerados todos os opcionais (2), ou somente
        o opcional do produto passado por parâmetro.
@version 1.0
@return aOpc
/*/
//-------------------------------------------------------------------
Function ListOpcPcp(cProduto,mOpc,cOpc,nExibeAll)
   Local aOpc    := { }
   /*
      aOpc: Array que contém os grupos e os itens opcionais.
      Exemplo: String "02 01  /ROD02  /"
      Irá retornar um array da seguinte maneira
      aOpc[1][1] := "Produto" Obs: Somente quando for do tipo MEMO(_MOPC), se for Char (_OPC), irá retornar nulo.
      aOpc[1][2] := "Descrição do produto" Obs: Somente quando for do tipo MEMO(_MOPC), se for Char (_OPC), irá retornar nulo.
      aOpc[1][3] := "02 "                             GA_GROPC
      aOpc[1][4] := "Descrição do grupo de opcionais" GA_DESCGRP
      aOpc[1][5] := "01  "                            GA_OPC
      aOpc[1][6] := "Descrição do item opcional"      GA_DESCOPC
      aOpc[2][1] := "Produto" Obs: Somente quando for do tipo MEMO(_MOPC), se for Char (_OPC), irá retornar nulo.
      aOpc[2][2] := "Descrição do produto" Obs: Somente quando for do tipo MEMO(_MOPC), se for Char (_OPC), irá retornar nulo.
      aOpc[2][3] := "ROD"                             GA_GROPC
      aOpc[2][4] := "Descrição do grupo de opcionais" GA_DESCGRP
      aOpc[2][5] := "02  "                            GA_OPC
      aOpc[2][6] := "Descrição do item opcional"      GA_DESCOPC
   */
   Local aMOpc    := { }
   Local nI       := 0
   Local nIOpc    := 0
   Local nTamGrp  := TamSX3("GA_GROPC")[1]
   Local nTamItm  := TamSX3("GA_OPC")[1]
   Local nTamProd := TamSX3("B1_COD")[1]
   Local aOldArea := GetArea()
   Local lFirst   := .T.
   Default nExibeAll := 1

   If Empty(nExibeAll)
      nExibeAll := 1
   EndIf

   If !Empty(cOpc) .And. Empty(mOpc)
      dbSelectArea("SGA")
      SGA->(dbSetOrder(1))
      For nI := 1 To Len(cOpc)
         If( SGA->(dbSeek(xFilial("SGA") + SubStr(cOpc,nI,(nTamGrp+nTamItm)))))
            aAdd(aOpc,{Nil,Nil,SGA->GA_GROPC,;
                       SGA->GA_DESCGRP,;
                       SGA->GA_OPC,;
                       SGA->GA_DESCOPC})
            nI = nI + nTamGrp + nTamItm
         EndIf
      Next
   Else
      dbSelectArea("SB1")
      SB1->(dbSetOrder(1))
      dbSelectArea("SGA")
      SGA->(dbSetOrder(1))

      aMOpc := Str2Array(mOpc,.F.)

      If aMOpc == Nil
         If !Empty(mOpc)
            For nI := 1 To Len(mOpc)
               If( SGA->(dbSeek(xFilial("SGA") + SubStr(mOpc,nI,(nTamGrp+nTamItm)))))
                  aAdd(aOpc,{Nil,Nil,SGA->GA_GROPC,;
                             SGA->GA_DESCGRP,;
                             SGA->GA_OPC,;
                             SGA->GA_DESCOPC})
                  nI = nI + nTamGrp + nTamItm
               EndIf
            Next nI
            If Len(aOpc) < 1
               aAdd(aOpc,{"","","","","",""})
            EndIf
            Return aOpc
         Else
            Return {{"","","","","",""}}
         EndIf
      EndIf

      For nI := 1 To Len(aMOpc)
         If AllTrim(aMOpc[nI][2]) == "/"
            Loop
         EndIf
         If SubStr(aMOpc[nI][1],Iif(((Len(aMOpc[nI][1])-(nTamProd*2))-5) < 1,1,(Len(aMOpc[nI][1])-(nTamProd*2))-5),nTamProd) == cProduto .Or. nExibeAll == 2
            If SB1->(dbSeek(xFilial("SB1") + SubStr(aMOpc[nI][1],Iif(((Len(aMOpc[nI][1])-(nTamProd*2))-5) < 1,1,(Len(aMOpc[nI][1])-(nTamProd*2))-5),nTamProd) ))
               For nIOpc := 1 To Len(aMOpc[nI][2])
                  If( SGA->(dbSeek(xFilial("SGA") + SubStr(aMOpc[nI][2],nIOpc,(nTamGrp+nTamItm)))))
                     If aScan(aOpc, {|x| x[1] == SB1->B1_COD .And. ;
                                         x[3] == SGA->GA_GROPC .And. ;
                                         x[5] == SGA->GA_OPC } ) == 0
                        aAdd(aOpc,{SB1->B1_COD,;
                                   SB1->B1_DESC,;
                                   SGA->GA_GROPC,;
                                   SGA->GA_DESCGRP,;
                                   SGA->GA_OPC,;
                                   SGA->GA_DESCOPC})
                     EndIf
                     nIOpc = nIOpc + nTamGrp + nTamItm
                  EndIf
               Next nI
            EndIf
         EndIf
      Next

   EndIf
   RestArea(aOldArea)
Return aOpc

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ MtPeOpcPcpºAutor  ³Andre Anjos        º Data ³  17/12/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao que verifica se para determinado produto ha cadastroº±±
±±º          ³ de opcionais X cliente, retornando o opcional do cadastro. º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ EST/PCP/FAT												  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MtPeOpcPcp(cProduto,cCliente,aGrupos)
Local cRet 		:= ""
Local nX  		:= 0
Local nPos		:= 0
Local cFamilia := A093VldBase(cProduto)

	SDJ->(dbSetOrder(1))
	SDJ->(dbSeek(xFilial("SDJ")+cCliente+cFamilia))
	While SDJ->(!EOF()) .And. SDJ->(DJ_FILIAL+DJ_CLIENTE+DJ_TIENDA+DJ_FAMILIA) == xFilial("SDJ")+cCliente+cFamilia
		nPos := aScan(aGrupos,{|x| x == SDJ->DJ_GPOOPC})
		If nPos > 0
			cRet += SDJ->(DJ_GPOOPC+DJ_ITEOPC)+"/"
		EndIf
		SDJ->(dbSkip())
	End
Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o    ³ OpcTdOkPcp                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Autor     ³ Rodrigo de Almeida Sartorio              ³ Data ³ 12/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Verifica se esta tudo Ok na selecao dos opcionais          ³±±
±±³           ³ e monta string com os opcionais selecionados               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³ OpcTudOk(ExpC1,ExpA1,ExpA2,ExpA3,ExpC2)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 = Codigo do produto                                  ³±±
±±³           ³ ExpA1 = Array utilizado na marcacao                        ³±±
±±³           ³ ExpA2 = Array com os grupo de Opcionais                    ³±±
±±³           ³ ExpA3 = Registros selecionados                             ³±±
±±³           ³ ExpC2 = String com os Opcionais selecionados               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Uso      ³ Selecao de Opcionais                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function OpcTdOkPcp(cProduto,aArray,aGrupos,aRegs,cOpcionais,cProg,aOpcionAUX,cOpcMark)
LOCAL nAcho:=0,nString:=0,i, i1
LOCAL lRet:=.T.
LOCAL aTam:=TAMSX3("GA_OPC")
LOCAL cDefault:=""
LOCAL cBackOpc:=cOpcionais
Local aArea := GetArea()
Local lObrigat := .T.
Local cOpcSB1  := ""
Local lOpcPadrao:= SuperGetMV("MV_REPGOPC",.F.,"N") == "N"

Default cOpcMark := ""

If cProg # "MATA010"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida se todos grupos tiveram um item selecionado ou possuem³
	//³opcional default cadastrado no SB1                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SB1->(dbSetOrder(1))
	For i:=1 to Len(aGrupos)
		lObrigat := .T.
		nAcho := IIF(ASCAN(aArray,{|x| x[4] == aGrupos[i] .And. x[8]}) != 0,ASCAN(aArray,{|x| x[4] == aGrupos[i] .And. x[1]}),1)
		// Pesquisa no array se grupo nao teve item marcado
		//nAcho:=ASCAN(aArray,{|x| x[4] == aGrupos[i] .And. x[1]})
		// Caso nao achou item marcado procura opcional default
		If nAcho == 0
			If SGA->(dbSeek(xFilial("SGA")+aGrupos[i]))
				lObrigat := Iif(SGA->GA_OBG=="0",.F.,.T.)
			EndIf

			If lObrigat .And. SB1->(dbSeek(xFilial("SB1")+cProduto))
				If FunName() $ "MATA712"
      				cOpcSB1 := Iif(!Empty(SB1->B1_OPC),SB1->B1_OPC,SB1->B1_MOPC)
				Else
					cOpcSB1 := Iif(Empty(SB1->B1_MOPC),SB1->B1_OPC,SB1->B1_MOPC)
   				EndIf

				If !Empty(cOpcSB1)
					// Verifica se o grupo esta na primeira posicao
					If Substr(cOpcSB1,1,Len(SGA->GA_GROPC)) == aGrupos[i]
						nString:=1
					Else
						// Procura grupo nas posicoes seguintes
						nString:=AT("/"+aGrupos[i],cOpcSB1)
					EndIf
					If nString > 0
						nString:=IF(nString=1,1,nString+1)
						cDefault:=Substr(cOpcSB1,nString,Len(SGA->GA_GROPC+SGA->GA_OPC))
						nAcho:=0
						nAcho:=ASCAN(aArray,{|x| Substr(x[3],1,Len(SGA->GA_OPC)) == Substr(cDefault,Len(SGA->GA_GROPC)+1) })
						If nAcho > 0
							cOpcionais+=cDefault+"/"
						EndIf
					EndIf
				EndIf
				// Caso nao achou o grupo no campo de opcionais default
				If nString <=0 .Or. nAcho <= 0
					If lObrigat
						Help ("",1,"MARCAGRUPO",,aGrupos[i],1,22)
						lRet:=.F.
						// Restaura os opcionais digitados anteriormente
						cOpcionais:=cBackOpc
						Exit
					Else
						cOpcionais += Space(Len(SGA->GA_GROPC)+Len(SGA->GA_OPC)) + "/"
					EndIf
				EndIf
			EndIf
		EndIf
	Next i
EndIf
// Monta a string de retorno
If lRet
	If !Empty(aOpcionAUX)
		For i:=1 to Len(aArray)
			If aArray[i,1]
				For i1:=1 to Len(aOpcionAUX)
					If aOpcionAUX[i1,3]  == aArray[i,3] .And.;
						aOpcionAUX[i1,4] == aArray[i,4]
						aOpcionAUX[i1,1] := .T.
					EndIf
				Next i1
			Else
				For i1:=1 to Len(aOpcionAUX)
					If aOpcionAUX[i1,3]  == aArray[i,3] .And.;
						aOpcionAUX[i1,4] == aArray[i,4]
						aOpcionAUX[i1,1] := .F.
					EndIf
				Next i1
			EndIf
		Next i

		For i:=1 to Len(aOpcionAUX)
			If aOpcionAUX[i,1]
				If !lOpcPadrao
					cOpcionais+=aOpcionAUX[i,4]+Substr(aOpcionAUX[i,3],1,aTam[1])+"/"
				Else
					If AT(aOpcionAUX[i,4]+Substr(aOpcionAUX[i,3],1,aTam[1])+"/",cOpcionais) < 1 .And. ;
						AT(aOpcionAUX[i,4]+Substr(aOpcionAUX[i,3],1,aTam[1])+"/",cOpcMark) < 1
						cOpcionais+=aOpcionAUX[i,4]+Substr(aOpcionAUX[i,3],1,aTam[1])+"/"
					EndIf
				EndIf
				AADD(aRegs,{aOpcionAUX[i,7],aOpcionAUX[i,6],aOpcionAUX[i,9]})
			EndIf
		Next i
	Else
		For i:=1 to Len(aArray)
			If aArray[i,1]
				If !lOpcPadrao
					cOpcionais+=aArray[i,4]+Substr(aArray[i,3],1,aTam[1])+"/"
				Else
					If AT(aArray[i,4]+Substr(aArray[i,3],1,aTam[1])+"/",cOpcionais) < 1 .And. ;
						AT(aArray[i,4]+Substr(aArray[i,3],1,aTam[1])+"/",cOpcMark) < 1
						cOpcionais+=aArray[i,4]+Substr(aArray[i,3],1,aTam[1])+"/"
					EndIf
				EndIf

				AADD(aRegs,{aArray[i,7],aArray[i,6],aArray[i,9]})
			EndIf
		Next i
	EndIf
EndIf
RestArea(aArea)
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ MarkOpcPcp  ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 17/12/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao recursiva que permite a selecao de Opcionais .      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MarkOpc(ExpC1,ExpC2,ExpA1,ExpC3,ExpC4)                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Produto a ter os opcionais escolhidos.             ³±±
±±³          ³ ExpC2 = Retorno da string com os opcionais selecionados.   ³±±
±±³          ³ ExpA1 = Array com retorno de toda estrutura utilizada      ³±±
±±³          ³ ExpC3 = Produto pai da Estrutura                           ³±±
±±³          ³ ExpC4 = String com os produtos da estrutura                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MarkOpcPcp(cProduto,cRet,aRetorOpc,cProdPai,cProdAnt,cProg,cOpcMarc,lVisual,nNivel,nQtd,dDataVal,cRevisao,lPreEstr,lexiste,nDecimais)

Static oOk,oNo,oBr

Local aArea		:=GetArea()
Local cCadastro	:=STR0052+cProduto //"Opcionais Disponiveis - "
Local nAcho		:=0
Local nString	:=0
Local i			:=0
Local nOpca		:=1
Local aGrupos	:={}
Local aRegs		:={}
Local cOpcionais:="" // Variavel utilizada para retorno da string
Local nTamDif	:=(Len(SGA->GA_OPC)+Len(SGA->GA_DESCOPC)+13)-(Len(SGA->GA_GROPC)+Len(SGA->GA_DESCGRP)+3)
Local lOpcPadrao:= SuperGetMV("MV_REPGOPC",.F.,"N") == "N"

Local aOpcionais:={}
Local aOpcionAUX :={}
Local aSize     :={}
Local aPosObj   :={}
Local aInfo     :={}
Local aObjects  :={}
Local nDifSize  :=0
Local lRet      :=.T.
Local lSELEOPC  :=ExistBlock("SELEOPC")
Local lAddOpc   :=ExistBlock("ADDOPC")
Local lGeraOPI  := SuperGetMV("MV_GERAOPI")
Local aCopyRegs :={}
Local oDlg,oOpc,cOpc
Local lGerOPI	:= ExistBlock("MTGEROPI")
Local lRetOPI   := .T.
Local nQuantItem:= 1
Local lRetOpc 	:= .F.
Local aOpcRET	:= {}
Local lTela		:= .T.
Local nQtdAx  := 0
Local cOpcSele := ""
Local cOpcComp := ""
Local cOpcDefa := ""
Local lOpcDefa := .F.
Local lMTOPCADD := ExistBlock("MTOPCADD")
Local lPCPREVATU	:= FindFunction('PCPREVATU')
Local cRevAtual 	:= ''
Local dDataCmp      := Nil
Default cProg 	  :=""
Default cOpcMarc  :=""
Default lVisual   :=.F.
Default nQtd      :=0
Default dDataVal  :=dDataBase
Default lPreEstr  :=.F.
Default nDecimais := TamSX3("D4_QUANT")[2]

cProduto := PadR(cProduto,Len(SB1->B1_COD))
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso nao exista cria array que registra todos os niveis da estrutura    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("aRetorOpc") <> "A"
	aRetorOpc:={}
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta titulo da janela com o codigo do produto+descricao    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SB1->(dbSetOrder(1))
If SB1->(MsSeek(xFilial("SB1")+cProduto))
	cCadastro:=STR0052+AllTrim(cProdPai)+If(!Empty(cProdPai)," - > ","")+Rtrim( cProduto )+" / " + Left(SB1->B1_DESC,25) //"Opcionais Disponiveis - "
	If Empty(cOpcMarc)
		cOpcMarc := Iif(Empty(RetFldProd(SB1->B1_COD,"B1_MOPC")),RetFldProd(SB1->B1_COD,"B1_OPC"),RetFldProd(SB1->B1_COD,"B1_MOPC"))
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Estrutura do array dos opcionais                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
// 1 Marcado (.T. ou .F.)
// 2 Titulo("0") ou Item("1")
// 3 Item Opcional+Descricao Opcional
// 4 Grupo de Opcionais
// 5 Registro no SG1
// 6 Nivel no SG1
// 7 Recno do SG1
// 8 Componente Ok (.T.) ou Vencido (.F.)
// 9 Codigo do componente
//10 Default ?

If Empty(cOpcDefa)
	dbSelectArea("SB1")
	dbSetOrder(1)
	lAchouB1 := MsSeek(xFilial("SB1")+cProduto)
	If lAchouB1
		cOpcDefa := SB1->B1_OPC
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Varre a estrutura do produto                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(IIf(lPreEstr,"SGG","SG1"))
dbSetOrder(1)
dbSeek(xFilial()+cProduto)
Do While !Eof() .And. IIf(lPreEstr,SGG->GG_FILIAL+SGG->GG_COD == xFilial("SGG")+cProduto,SG1->G1_FILIAL+SG1->G1_COD == xFilial("SG1")+cProduto)

	If !lPreEstr
		If SB1->B1_GRADE == "S" .AND. Empty(cRevisao) .AND. cProg == "MATA650"
			cRevisao := PCPREVATU(cProduto)
		EndIf

		//cRevAtual := PCPREVATU(SG1->G1_COD)
		If !(cRevisao >= SG1->G1_REVINI .AND. cRevisao <= SG1->G1_REVFIM)
			dbSkip()
			Loop
		EndIf
	EndIf

	If !Empty(IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC)) .And. !Empty(IIf(lPreEstr,SGG->GG_OPC,SG1->G1_OPC))
		lExisteOpc := .T.
		cOpcArq := If(lPreEstr,SGG->GG_GROPC+SGG->GG_OPC,SG1->G1_GROPC+SG1->G1_OPC)

		If (!Empty(cOpcDefa) .And. !Empty(cOpcArq) .And. !(cOpcArq $ cOpcDefa)) .Or. (Empty(cOpcDefa) .Or. Empty(cOpcArq))
			lOpcDefa := .F.
		Else
			lOpcDefa := .T.
		EndIf

		// Caso ja tenha opcionais preenchidos, pesquisa se nao ‚ o grupo
		// atual
		If !Empty(cRet)
			// Verifica se ‚ a primeira posicao
			If Substr(cRet,1,Len(SGA->GA_GROPC)) == IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC)
				nString:=1
			Else
				// Procura grupo no campo de opcionais default
				nString:=AT("/"+IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC),cRet)
			EndIf
			If nString > 0 .And. lOpcPadrao
				cOpcSele := SubStr(cRet,Iif(nString==1,1,nString+1),Len(SGA->GA_GROPC)+Len(SGA->GA_OPC))
				cOpcComp := IIf(lPreEstr,SGG->GG_GROPC+SGG->GG_OPC,SG1->G1_GROPC+SG1->G1_OPC)

				//somente incluir se o opcional do componente for o opcional selecionado
				If cOpcSele == cOpcComp
					If SGA->(dbSeek(xFilial("SGA")+IIf(lPreEstr,SGG->GG_GROPC+SGG->GG_OPC,SG1->G1_GROPC+SG1->G1_OPC)))
						// Verifica se o grupo ja foi incluido
						nAcho:=ASCAN(aGrupos,IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC))
						//Valida datas e revisao
						If !Empty(nQtd)
							nQuantItem := Round(ExplEstr(nQtd,dDataVal,"",cRevisao,,lPreEstr,,,,,,.T.,.F.),nDecimais)
						EndIf
						If nAcho == 0
							AADD(aGrupos,IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC))
							// Adiciona titulo ao array
							AADD(aOpcionAUX,{.F.,"0",SGA->GA_GROPC+" - "+SGA->GA_DESCGRP+Space(nTamDif),SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),QtdComp(nQuantItem)>QtdComp(0),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
						EndIf

						// Verifica se o grupo ja foi digitado neste nivel
						nAcho:=ASCAN(aOpcionAUX,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno())})
						If nAcho == 0
							// Adiciona item ao array
							AADD(aOpcionAUX,{.T.,;
					  			"1",;
					  			SGA->GA_OPC+" - "+SGA->GA_DESCOPC,;
					  			SGA->GA_GROPC,;
					  			SGA->(Recno()),;
					  			IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),;
					  			IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),;
					  			QtdComp(nQuantItem)!=QtdComp(0),;
					  			IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),;
					  			lOpcDefa})
						Else
							// Verifica se o grupo e produto ja foi digitado neste nivel
							nAcho:=ASCAN(aOpcionAUX,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno()) .And. x[9] == SG1->G1_COMP })
							If nAcho == 0
								// Adiciona item ao array
								If SG1->G1_INI > dDataBase .Or. SG1->G1_FIM < dDataBase
									AADD(aOpcionAUX,{.T.,"1",SGA->GA_OPC+" - "+SGA->GA_DESCOPC,SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),QtdComp(nQuantItem,.T.)>QtdComp(0,.T.),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
								Else
									AADD(aOpcionAUX,{.T.,"1",SGA->GA_OPC+" - "+SGA->GA_DESCOPC,SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),.T.,IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
				dbSkip()
				Loop
			EndIf
		EndIf
		If SGA->(dbSeek(xFilial("SGA")+IIf(lPreEstr,SGG->GG_GROPC+SGG->GG_OPC,SG1->G1_GROPC+SG1->G1_OPC)))
			//-- Ponto de Entrada para validar os Opcionais
			If	lSELEOPC
				lRet := ExecBlock('SELEOPC',.F.,.F.,{lPreEstr,cRevisao})
				If ValType(lRet) <> 'L'
					lRet := .T.
				EndIf
				If !lRet //-- Se o Opcional nao for valido
					If lPreEstr
					    SGG->(dbSkip())
					Else
						SG1->(dbSkip())
					EndIf
					Loop
				EndIf
			EndIf

			// Verifica se o grupo ja foi incluido
			nAcho:=ASCAN(aGrupos,IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC))
			//Valida datas e revisao
			If !Empty(nQtd)
				nQuantItem := Round(ExplEstr(nQtd,dDataVal,"",cRevisao,,lPreEstr,,,,,,.T.,.F.),nDecimais)
			EndIf
			If nAcho == 0
				AADD(aGrupos,IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC))
				// Adiciona titulo ao array
				AADD(aOpcionais,{.F.,"0",SGA->GA_GROPC+" - "+SGA->GA_DESCGRP+Space(nTamDif),SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),QtdComp(nQuantItem)!=QtdComp(0),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
				AADD(aOpcionAUX,aClone(aTail(aOpcionais)))
			EndIf

			// Verifica se o grupo ja foi digitado neste nivel
			nAcho:=ASCAN(aOpcionais,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno())})
			If nAcho == 0
				// Adiciona item ao array
					AADD(aOpcionais,{OpcSelec(cOpcMarc, SGA->GA_GROPC+SGA->GA_OPC, cProdAnt, IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT)),;
						  "1",;
						  SGA->GA_OPC+" - "+SGA->GA_DESCOPC,;
						  SGA->GA_GROPC,;
						  SGA->(Recno()),;
						  IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),;
						  IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),;
						  QtdComp(nQuantItem)!=QtdComp(0),;
						  IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),;
						  lOpcDefa})

					AADD(aOpcionAUX,aClone(aTail(aOpcionais)))
			Else
				// Verifica se o grupo e produto ja foi digitado neste nivel
				nAcho:=ASCAN(aOpcionAUX,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno()) .And. x[7] == IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())) })
				If nAcho == 0
					// Adiciona item ao array
					If SG1->G1_INI > dDataBase .Or. SG1->G1_FIM < dDataBase
						AADD(aOpcionAUX,{SGA->GA_GROPC+SGA->GA_OPC $ cOpcMarc,"1",SGA->GA_OPC+" - "+SGA->GA_DESCOPC,SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),QtdComp(nQuantItem,.T.)>QtdComp(0,.T.),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
						nAcho:=ASCAN(aOpcionais,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno())})
						If nAcho > 0
							aOpcionais[nAcho,8] := .T.
						EndIf
					Else
						AADD(aOpcionAUX,{SGA->GA_GROPC+SGA->GA_OPC $ cOpcMarc,"1",SGA->GA_OPC+" - "+SGA->GA_DESCOPC,SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),.T.,IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
						nAcho:=ASCAN(aOpcionais,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno())})
						If nAcho > 0
							aOpcionais[nAcho,8] := .T.
						EndIf
					EndIf
				Else
					If QtdComp(nQuantItem,.T.)!=QtdComp(0,.T.)
						aOpcionAUX[nAcho,8] := .T.
						nAcho:=ASCAN(aOpcionais,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno())})
						If nAcho > 0
							aOpcionais[nAcho,8] := .T.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		// Caso nao tenha opcionais neste nivel, guarda o registro para
		// pesquisar em niveis inferiores
		If !Empty(nQtd)
			//Valida datas e revisao
			nQuantItem := Round(ExplEstr(nQtd,dDataVal,"",cRevisao,,lPreEstr,,,,,,.T.,.F.),nDecimais)
		EndIf

		//Se o componente não estiver válido, não adiciona em aRegs para processar próximos níveis.
		If (!Empty(nQtd) .And. !Empty(nQuantItem)) .Or. (Empty(nQtd))
			AADD(aRegs,{IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP)})
		EndIf
	EndIf
	dbSkip()
EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso tenha opcionais neste nivel, monta a tela de sele‡ao   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aOpcionais) > 0
	// Valor padrao para DIALOG
	nOpca:=0
	// Sorteia array com grupos
	ASORT(aGrupos)
	// Sorteia array com opcionais
	ASORT(aOpcionais,,,{|x,y| x[4]+x[2]+x[3] < y[4]+y[2]+y[3] })
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se ha opcional X cliente						   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cProg == "MATA410" .And. AllTrim(M->C5_SOLOPC) == '2'
	   cOpcionais := MtPesqOpc(cProduto,M->(C5_CLIENTE+C5_LOJACLI),aGrupos)
	   aEval(aOpcionais, {|x| If(x[4]+Substr(x[3],1,Len(SGA->GA_OPC)) $ cOpcionais,x[1]:=.T.,x[1]:=.F.) })
	   cOpcionais := ""
	   lTela := !OpcTudOk(cProduto,aOpcionais,aGrupos,@aRegs,@cOpcionais,cProg,.F.,cRet)
	EndIf
	If lTela
		If !IsBlind()
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Le na resource os bitmaps utilizados no Listbox p/ sele‡ao  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If oOk == NIL
				oOk := LoadBitmap( GetResources(), "LBOK")
			EndIf
			If oNo == NIL
				oNo := LoadBitmap( GetResources(), "LBNO")
			EndIf
			If oBr == NIL
				oBr := LoadBitmap(GetResources(),'')
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula automaticamente as dimensoes dos objetos            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aSize := MsAdvSize(.F.)
			aObjects := {}
			AAdd( aObjects, { 100,  20, .T., .F. } )
			AAdd( aObjects, { 100, 100, .T., .T., .T. } )
			AAdd( aObjects, { 100,  15, .T., .F. } )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Diminui o tamanho retornado e garante que a largura da Dialog nao ultrapasse 600 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nDifSize := 0
			If ( aSize[ 5 ] - 80 ) > 600
				nDifSize := aSize[ 5 ] - 80 - 600
			EndIf

			aSize[ 3 ] -= 40 + nDifSize / 2
			aSize[ 4 ] -= 40

			aSize[ 5 ] -= 80 + nDifSize
			aSize[ 6 ] -= 80

			aInfo   := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 2 }
			aPosObj := MsObjSize( aInfo, aObjects )

			Do While .T.

				DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL

				@ 05, 03 SAY cCadastro OF oDlg PIXEL

				@ 15, 00 TO 17, 2000 PIXEL

				If lMTOPCADD
					aOpcRet := ExecBlock("MTOPCADD",.F.,.F.,{aOpcionais})
				EndIf

				@ aPosObj[2,1],aPosObj[2,2] LISTBOX oOpc VAR cOpc Fields HEADER "",STR0053,STR0054,"Default",iif(len(aOpcRet) > 0,aOpcRet[1,1],' ')  SIZE aPosObj[2,3],aPosObj[2,4] ON DBLCLICK If(!lVisual,(aOpcionais:=OpcTroca(oOpc:nAt,aOpcionais),oOpc:Refresh()),) NOSCROLL OF oDlg PIXEL  //"Grupos/Itens Opcionais"###"Validade Componente"
				oOpc:SetArray(aOpcionais)
				oOpc:bLine := { || {If(aOpcionais[oOpc:nAt,2]=="0",oBr,IF(aOpcionais[oOpc:nAt,1],oOk,oNo)),aOpcionais[oOpc:nAt,3],If(aOpcionais[oOpc:nAt,2]=="0","",If(aOpcionais[oOpc:nAt,8]," Ok",STR0055)),If(aOpcionais[oOpc:nAt,2]=="0","",If(aOpcionais[oOpc:nAt,10],STR0056,STR0057)),iif (len(aOpcRet)>1,aOpcRet[oOpc:nAt+1,2],' ')}} //" Vencido"
				DEFINE SBUTTON FROM aPosObj[3,1]+2,aPosObj[3,4] - 57 TYPE 1 ACTION (IF(If(!lVisual .OR. (!INCLUI .And. !ALTERA),OpcTudOk(cProduto,aOpcionais,aGrupos,@aRegs,@cOpcionais,cProg,aOpcionAUX,cRet),.T.),(nOpca:=1,oDlg:End()),)) ENABLE OF oDlg PIXEL
				DEFINE SBUTTON FROM aPosObj[3,1]+2,aPosObj[3,4] - 27 TYPE 2 ACTION (nOpca:=0,oDlg:End()) ENABLE OF oDlg PIXEL
				ACTIVATE MSDIALOG oDlg CENTERED
				If nOpcA == 1 .Or. lVisual
					Exit
				ElseIf nOpca == 0
					Exit
				EndIf
			EndDo
		Else
			IF (ASCAN(aOpcionais,{|x| x[8]})) > 0
				IF OpcTudOk(cProduto,aOpcionais,aGrupos,@aRegs,@cOpcionais,,aOpcionAUX,cRet)
					nOpcA := 1
				EndIf
			Else
				nOpcA := 1
			EndIf
		EndIf
	Else
		nOpcA := 1
	EndIf
	If !lOpcPadrao
		cRet+=cOpcionais
	Else
		If AT(cOpcionais,cRet) < 1
			cRet+=cOpcionais
		EndIf
	EndIf
	// Este trecho foi removido pois nas chamadas recursivas o opcional selecionado no nivel anterior estava sendo substituido indevidamente
	//If !lOpcPadrao .And. nNivel > 1
	//	aRetorOpc[Len(aRetoropc),2]:=cOpcionais
	//EndIf
Else
	If Len(aOpcionAUX) > 0
		OpcTudOk(cProduto,aOpcionais,aGrupos,@aRegs,@cOpcionais,cProg,aOpcionAUX,cRet)
		If !lOpcPadrao
			cRet+=cOpcionais
		Else
			If AT(cOpcionais,cRet) < 1
				cRet+=cOpcionais
			EndIf
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para adicionar mais opcionais ao array aRegs.	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 If lAddOpc
	aCopyRegs := aClone(aRegs)
	aRegs     := ExecBlock('ADDOPC',.F.,.F.,{aRegs,cProdAnt,cOpcionais})
	If ValType(aRegs) <> 'A'
		aRegs := aClone(aCopyRegs)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para a utilizado para verificar a 		    ³
//³ necessidade de gerar ou nao OPs intermediarias				³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lGerOPI
	lRetOPI:=ExecBlock("MTGEROPI",.F.,.F.)
	If ValType(lRetOPI) # "L"
		lRetOPI:=.T.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Na inclusao manual de OPs, nao deve analisar opcionais de           ³
//³outros niveis da estrutura, quando o parametro MV_GERAOPI for Falso ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If /*lRetOPI .And.*/ (  lGeraOPI .Or. (!( "C2_PRODUTO" $ ReadVar())))                                   // qdo vier da inclusão da OP (mata650) e MV_GERAOPI = .F., não tem
	ASORT(aRegs,,,{|x,y| x[2] < y[2]})                                                              // sentido o cursor estar posicionado no produto para funcionar o MV_GERAOPI
	// Varre o array para que sejam selecionados os itens restantes
	For i:=1 to Len(aRegs)

		SB1->(MsSeek(xFilial("SB1")+aRegs[i,3] ))

		If IIf(lPreEstr,SGG->(dbSeek(xFilial("SGG")+aRegs[i,3])),SG1->(dbSeek(xFilial("SG1")+aRegs[i,3])))  .And. (lGeraOPI == .T. .OR. SB1->B1_FANTASM == 'S') .And. lRetOPI
			If lPreEstr
				SGG->(MsGoto(aRegs[i,1]))
			Else
				SG1->(MsGoto(aRegs[i,1]))
			EndIf
			// Adiciona no array que registra todos os niveis da estrutura
			AADD(aRetorOpc,{cProdAnt+IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT),cOpcionais})
			nNivel+=1
			dDataCmp := dDataVal

            nQtdAx := Round(ExplEstr(nQtd,dDataVal,"",cRevisao,,lPreEstr),nDecimais)
			SB1->(MsSeek(xFilial("SB1")+IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP)))
			IF (SG1->G1_INI <= dDataVal .And. SG1->G1_FIM >= dDataVal)
				If IsInCallStack("MATA650")
					If SB1->B1_FANTASM == 'S' .Or. lGeraOPI
						Do Case
							Case RetFldProd(SB1->B1_COD,"B1_TIPE") == "H"
								dDataCmp -= Int(RetFldProd(SB1->B1_COD,"B1_PE")/24)
							Case SB1->B1_TIPE == "S"
								dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 7)
							Case SB1->B1_TIPE == "M"
								dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 30)
							Case SB1->B1_TIPE == "A"
								dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 365)
							OtherWise
								dDataCmp -= RetFldProd(SB1->B1_COD,"B1_PE")
						EndCase
						cRevAtual :=  IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )
						lRetOpc := MarkOpcPcp(IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),@cRet,aRetorOpc,IIf(lPreEstr,SGG->GG_COD,SG1->G1_COD),cProdAnt+IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT),cProg,cOpcMarc,lVisual,nNivel,nQtdAx,dDataCmp,cRevAtual,lPreEstr,@lExisteOpc,nDecimais)
						If !lRetOpc
							nOpca := 0
						EndIf
						nNivel-=1
					EndIf
				Else
					Do Case
						Case RetFldProd(SB1->B1_COD,"B1_TIPE") == "H"
							dDataCmp -= Int(RetFldProd(SB1->B1_COD,"B1_PE")/24)
						Case SB1->B1_TIPE == "S"
							dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 7)
						Case SB1->B1_TIPE == "M"
							dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 30)
						Case SB1->B1_TIPE == "A"
							dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 365)
						OtherWise
							dDataCmp -= RetFldProd(SB1->B1_COD,"B1_PE")
					EndCase
					cRevAtual :=  IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )
					lRetOpc := MarkOpcPcp(IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),@cRet,aRetorOpc,IIf(lPreEstr,SGG->GG_COD,SG1->G1_COD),cProdAnt+IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT),cProg,cOpcMarc,lVisual,nNivel,nQtdAx,dDataCmp,cRevAtual,lPreEstr,@lExisteOpc,nDecimais)
					If !lRetOpc
						nOpca := 0
					EndIf
					nNivel-=1
				EndIf
			EndIf
		Else
			If lPreEstr
				SGG->(MsGoto(aRegs[i,1]))
			Else
				SG1->(MsGoto(aRegs[i,1]))
			EndIf
			//If !lOpcPadrao
				// Adiciona no array que registra todos os niveis da estrutura
				AADD(aRetorOpc,{cProdAnt+IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT),SG1->G1_GROPC+SG1->G1_OPC+"/"})
			//EndIf
		EndIf
	Next I
EndIf
RestArea(aArea)
Return nOpcA == 1

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ SeleOpcPcp³ Autor ³Rodrigo de A. Sartorio³ Data ³ 12/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a selecao de opcionais de acordo com os parametros ³±±
±±³          ³ recebidos.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SeleOpcPcp(ExpN1)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Expressao numerica usada para indicar o tipo de    ³±±
±±³          ³ entrada de dados (1) Enchoice (2) GetDados (3) GetDB       ³±±
±±³          ³ (4) Get Fixo                                               ³±±
±±³          ³ ExpC2 = Nome do Programa                                   ³±±
±±³          ³ ExpC3 = Codigo do Produto                                  ³±±
±±³          ³ ExpL4 = Verifica se Produto e uma referencia               ³±±
±±³          ³ ExpC5 = Retorno com a string de opcionais                  ³±±
±±³          ³ ExpC6 = Opcionais marcados                                 ³±±
±±³          ³ ExpC7 = Campo com o nome do produto pai                    ³±±
±±³          ³ ExpL8 = Visualiza janela de selecao de opcionais           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SeleOpcPcp(nTipo,cProg,cProd,lReferencia,cRet,cOpcMarc,cCampo,lVisual,nQtd,dDataVal,cRevisao,lPreEstr,mRet,nDecimais)
Local nz		:= 0
Local nPosOpc	:= 0
Local nPosMOpc	:= 0
Local cProduto	:= ""
Local cVarOpc	:= ""
Local cVarMOpc	:= ""
Local nEnd		:= ""
Local nEndOpc	:= 0
Local nEndMOpc	:= 0
Local cVar		:= ""
Local aTam		:= {}
Local aBack		:= {}
Local aArea		:= GetArea()
Local lSeleOpc	:= .T.
Local lRet		:= .T.
Local oModel    := FWModelActive()
Local lMVC 		:= oModel <> NIL .And. AllTrim(Upper(oModel:GetSource())) == AllTrim(Upper(cProg))
Local oView
Local lMark		:= .F.
Local aFields

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Parametro utilizado para indicar se permite repetir o mesmo grupo de    |
//| opcionais em varios niveis ou nao.                                      |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lOpcPadrao:= GetNewPar("MV_REPGOPC","N") == "N"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Ponto de entrada utilizado para inibir a tela de selecao de opcionais.  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lMTSeleOp := ExistBlock("MTSELEOP")

Default cRet	  :=""
Default cOpcMarc  :=""
Default lVisual   :=.F.
Default cCampo    :=ReadVar()
Default nQtd 	  :=0
Default lPreEstr  :=.F.
Default mRet      := ""
Default nDecimais := TamSX3("D4_QUANT")[2]

cProg       := If(cProg		 	== NIL, "", cProg)
lReferencia := If(lReferencia	== NIL, .F., lReferencia)
cProduto	:= If(cProd			== NIL,&(ReadVar()),cProd)

IF empty(dDataVal) .AND. cProg == "MATA650" .and. SB1->B1_GRADE == "S"
	dDataVal := dDataBase
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Caso nao exista cria array que registra todos os niveis da estrutura    |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("aRetorOpc") <> "A"
	aRetorOpc:={}
EndIf

If cProg $ "MATA010|MATA010M|MATA018"
	lRet     := .F.
	If cProg == "MATA010" .Or. cProg == "MATA010M"
		cCampo := "M->B1_COD"
	Else
		cCampo := "M->BZ_COD"
	EndIf
	cProduto :=  cProd
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica atraves de parametro se deve ou nao verificar      ³
//³ cadastramento de opcionais                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(GetMV("MV_SELEOPC",.T.)) .Or. (GetMV("MV_SELEOPC",.T.) .And. GetMV("MV_SELEOPC") == "S")
	If	lMTSeleOp
		lSeleOpc:= ExecBlock("MTSELEOP",.F.,.F.,{cRet,cProd,cProg})
	EndIf
	If lSeleOpc
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Define qual campo deve ser atualizado                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cMODULO = "EEC"
			cVarOpc  := Substr(cCAMPO,4,AT("_",cCAMPO)-3)+"OPC"
			cVarMOpc := Substr(cCAMPO,4,AT("_",cCAMPO)-3)+"MOP"
		Else
			cVarOpc  := Substr(cCampo,4,AT("_",cCAMPO)-3)+"OPC"
			cVarMOpc := Substr(cCampo,4,AT("_",cCAMPO)-3)+"MOPC"
		EndIf
		aTam     := TAMSX3(cVarOpc)
		cVarOpc  := cVarOpc+Space(10-Len(cVarOpc))
		cVarMOpc := cVarMOpc+Space(10-Len(cVarMOpc))

		cVar := Iif(lOpcPadrao,cVarOpc,cVarMOpc)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se os campos estao em uso                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		// Selecao em Enchoice
		If lMVC
			oView := FWViewActive()
			If oView <> NIL
				aFields := oView:GetListFields()
				If aScan(aFields, {|x| AllTrim(Upper(x[2])) == AllTrim(Upper(cVarOpc)) }) > 0 .Or. aScan(aFields, {|x| AllTrim(Upper(x[2])) == AllTrim(Upper(cVarMOpc)) }) > 0
					lMark := .T.
				EndIf
			EndIf
		Else
			If nTipo == 1
				nEnd     := Ascan(aGets,{ |x| Substr(x,9,10) == Iif(lOpcPadrao,cVarOpc,cVarMOpc )} )
				nEndOpc  := Ascan(aGets,{ |x| Substr(x,9,10) == cVarOpc  } )
				nEndMOpc := Ascan(aGets,{ |x| Substr(x,9,10) == cVarMOpc } )
				If nEndOpc > 0 .Or. nEndMOpc > 0
					lMark := .T.
				EndIf
				// Selecao em GetDados ou Selecao em GetDb
			ElseIf nTipo == 2 .Or. nTipo == 3
				// Obtem posicao dos opcionais em caso de GetDados
				nPosOpc  := Ascan(aHeader,{ |x| x[2] == cVarOpc  })
				nPosMOpc := Ascan(aHeader,{ |x| x[2] == cVarMOpc })
				If nPosOpc > 0 .Or. nPosMOpc > 0
					lMark := .T.
				EndIf
				// Selecao em Get Fixo
			ElseIf nTipo == 4
				lMark := .T.
			EndIf
		EndIf

		If lMark
			// Funcao recursiva para selecao de opcionais
			lExisteOpc := .F.

			If Empty(cRevisao)
				cRevisao := CriaVar("B1_REVATU")
				If cProg # "MATA650"
					cRevisao := PCPREVATU(cProduto)
				EndIf
			EndIf

			lRet:=MarkOpcPcp(cProduto,@cRet,aRetorOpc,"",cProduto,cProg,cOpcMarc,lVisual,1,nQtd,dDataVal,cRevisao,lPreEstr,@lExisteOpc,nDecimais)

			IF !lExisteOpc
				cRet := ""
				aRetorOpc := {}
			EndIF

		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava no array somente a arvore dos itens que tem opcional  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aRetorOpc) > 0 .And. !lOpcPadrao
			aBack:=ACLONE(aRetorOpc)
			aRetorOpc:={}
			For nz:=1 to Len(aBack)
				If !Empty(aBack[nz,2])
					AADD(aRetorOpc,aBack[nz])
				EndIf
			Next nz
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Preenche o conteudo dos campos com os opcionais selecionados³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lVisual
			If ((!Empty(cRet) .And. lOpcPadrao) .Or. (Len(aRetorOpc) > 0 .And. !lOpcPadrao ) .Or. (nTipo == 2 .And. !Empty(cRet)) )
				// Selecao em Enchoice
				If lMVC
					//Verifica se existe o campo _OPC no modelo para atribuir o valor.
					If !Empty(FwFindId(cVarOpc))
						FWFldPut(cVarOpc,PADR(cRet,aTam[1]),,oModel,.F., .T.)
					EndIf
					//Verifica se existe o campo _MOPC no modelo para atribuir o valor.
					If !Empty(FwFindId(cVarMOpc))
						FWFldPut(cVarMOpc,Array2STR(aRetorOpc,.F.),,oModel,.F., .T.)
					EndIf
				Else
					// Selecao em Enchoice
					If nTipo == 1
						If cMODULO = "EEC"
							&(Substr(cCampo,1,7)+"OPC"):=PADR(cRet,TamSX3(Substr(cCAMPO,4,AT("_",cCAMPO)-3)+"OPC")[1])
							cVar := Substr(cCAMPO,4,AT("_",cCAMPO)-3)+"MOP"
							SX3->(dbSetOrder(2))
							If SX3->(dbSeek(cVar))
								&(Substr(cCampo,1,7)+"MOPC"):=Array2STR(aRetorOpc,.F.)
							EndIf
						Else
							&(Substr(cCampo,1,6)+"OPC"):=PADR(cRet,TamSX3(Substr(cCampo,4,AT("_",cCAMPO)-3)+"OPC")[1])
							cVar := Substr(cCampo,4,AT("_",cCAMPO)-3)+"MOPC"
							SX3->(dbSetOrder(2))
							If SX3->(dbSeek(cVar))
								&(Substr(cCampo,1,6)+"MOPC"):=Array2STR(aRetorOpc,.F.)
							EndIf
						EndIf
						If nEndOpc > 0
							nEndOpcAT  := aScan(atela,{|x| Subs(x[5],2,2) == Subs(aGets[nEndOpc],1,2) })
							aTela[nEndOpcAT][Val(Subs(aGets[nEndOpc],3,1))*2] := cRET+Space(Len(aTela[nEndOpcAT][Val(Subs(aGets[nEndOpc],3,1))*2])-Len(cRet))
						EndIf
						If nEndMOpc > 0
							nEndMOpcAT := aScan(atela,{|x| Subs(x[5],2,2) == Subs(aGets[nEndMOpc],1,2) })
							aTela[nEndMOpcAT][Val(Subs(aGets[nEndMOpc],3,1))*2] := Array2STR(aRetorOpc,.F.)
						EndIf
						// Selecao em GetDados
					ElseIf nTipo == 2
						If nPosOpc > 0
							aCols[n,nPosOpc] := PADR(cRet,aTam[1])
						EndIf
						If nPosMOpc > 0 .and. len(aRetorOpc) > 0
							aCols[n,nPosMOpc] := Array2STR(aRetorOpc,.F.)
						EndIf
						// Selecao em GetDb
					ElseIf nTipo == 3
						If nPosMOpc > 0
							&("TMP1->"+cVarMOpc):= Array2STR(aRetorOpc,.F.)
						EndIf
						If nPosOpc > 0
							&("TMP1->"+cVarOpc):= PADR(cRet,aTam[1])
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		RestArea(aArea)
	EndIf
EndIf
If Len(aRetorOpc) > 0
	mRet := Array2STR(aRetorOpc,.F.)
EndIf
lRefresh:=.T.
Return If(nTipo==4,cRet,lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} OpcSelPcp()
Verifica se o opcional foi selecionado para o componente/nivel atual.

@param cOpcMarc	- String com os opcionais selecionados.
@param cOpc		- Grupo+Opcional da tabela SGA.
@param cProdAnt	- String com os produtos da estrutura.
@param cCompTrt - Componente + sequência da estrutura.

@author Lucas Konrad França
@since 02/09/2016
@version P12
@return lRet
/*/
//--------------------------------------------------------------------
Function OpcSelPcp(cOpcMarc, cOpc, cProdAnt, cCompTrt)
Local lRet	:= .F.
Local aOpc	:= Str2Array(cOpcMarc,.F.)
Local nI	:= 0

If aOpc != Nil .And. Len(aOpc) > 0 .And. !Empty(aOpc[1])
	For nI := 1 To Len(aOpc)
		If aOpc[nI,1] == cProdAnt + cCompTrt
			If cOpc $ aOpc[nI,2]
				lRet := .T.
			EndIf
			Exit
		EndIf
	Next nI
Else
	lRet := cOpc $ cOpcMarc
EndIf

Return lRet

/*/{Protheus.doc} PCPPergSB1
Função para validar se o produto tem estrutura ou pré-estrutura
Uso: Consulta Padrão SB1CMP

@author brunno.costa
@since 08/10/2018
@version 12

@param nOpcao, numérico, indica:
- 1 para verificar se o produto possui estrutura
- 2 para verificar se o produto possui pré-estrutura
- 3 para indicar o nome da consulta padrão a ser utilizada - PCPA135
@param cVarRef   , caracter, indica o nome da variável de referência                                  - 'nOpcao = 3'
@param nDefPre   , numérico, conteúdo utilizado para comparação com cVarRef em caso de Pré-Estrutura  - 'nOpcao = 3'
@param nDefEstr  , numérico, conteúdo utilizado para comparação com cVarRef em caso de Estrutura      - 'nOpcao = 3'
@param lConsCpos , logico, indica se avalia (pré-)estrutura com base em campos relacionados da SB1    - 'nOpcao = 1 ou 2'
@param lMsSeekBco, logico, indica se avalia os registros da SB1 válidos com base em MsSeek na SG1/SGG - 'nOpcao = 1 ou 2'
							true  = usa MsSeek
							false = usa DbUseArea
@return lRet , Lógico  , Caso .T. adiciona o registro, caso .F. registro não é mostrado.
@type function
/*/
//-------------------------------------------------------------------
Function PCPPergSB1(nOpcao, cVarRef, nDefPre, nDefEstr, lConsCpos, lMsSeekBco)

	Local aAreaOLD
	Local cProduto 	   := SB1->B1_COD
	Local oReturn
	Local cBanco        := TCGetDB()

	Default cVarRef    := "MV_PAR01"
	Default nDefPre    := 1
	Default nDefEstr   := 2
	Default lConsCpos  := .T.
	Default lMsSeekBco := .T.
	Default lAutomacao := .F.

	If nOpcao == 1
		oReturn  	:= .T.
		If !lConsCpos .OR. (Empty(SB1->B1_REVATU) .AND. Empty(SB1->B1_UREV) .AND. SB1->B1_QB == 0)
			If lMsSeekBco
				If !SG1->(MsSeek(xFilial("SG1") + cProduto)) // Verifica se o produto tem estrutura.
					oReturn := .F.
				EndIf
			Else
				IF cBanco == "MSSQL"
					cQuery :=  " SELECT TOP 1 G1_COD "
				Else
					cQuery :=  " SELECT G1_COD "
				EndIf
				cQuery +=  " FROM " + RetSqlName("SG1")
				cQuery +=  " WHERE D_E_L_E_T_=' ' "
				cQuery +=        " AND G1_FILIAL ='" + xFilial("SG1", SB1->B1_FILIAL) + "' "
				cQuery +=        " AND G1_COD ='" + SB1->B1_COD + "' "
				IF cBanco == "ORACLE"
					cQuery +=        " AND ROWNUM = 1 "
				ElseIF cBanco == "POSTGRES"
					cQuery +=        " ORDER BY 1 LIMIT 1 "
				EndIf
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SB1SG1",.F.,.F.)
				dbSelectArea("SB1SG1")
				If SB1SG1->(Eof())
					oReturn := .F.
				EndIf
				SB1SG1->(dbCloseArea())
			EndIf
		EndIf
		DbSelectArea("SB1") //Retorna Alias SB1 como ativo para evitar error.log

	ElseIf nOpcao == 2
		oReturn  	:= .T.
		If !lConsCpos .OR. SB1->B1_QBP == 0
			If lMsSeekBco
				If !SGG->(MsSeek(xFilial("SGG") + cProduto)) // Verifica se o produto tem pré-estrutura.
					oReturn := .F.
				EndIf
			Else
				IF cBanco == "MSSQL"
					cQuery :=  " SELECT TOP 1 GG_COD "
				Else
					cQuery :=  " SELECT GG_COD "
				EndIf
				cQuery +=  " FROM " + RetSqlName("SGG")
				cQuery +=  " WHERE D_E_L_E_T_=' ' "
				cQuery +=        " AND GG_FILIAL ='" + xFilial("SGG", SB1->B1_FILIAL) + "' "
				cQuery +=        " AND GG_COD ='" + SB1->B1_COD + "' "
				IF cBanco == "ORACLE"
					cQuery +=        " AND ROWNUM = 1 "
				ElseIF cBanco == "POSTGRES"
					cQuery +=        " ORDER BY 1 LIMIT 1 "
				EndIf
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SB1SGG",.F.,.F.)
				dbSelectArea("SB1SGG")
				If SB1SGG->(Eof())
					oReturn := .F.
				EndIf
				SB1SGG->(dbCloseArea())
			EndIf
		EndIf
		DbSelectArea("SB1") //Retorna Alias SB1 como ativo para evitar error.log

	ElseIf nOpcao == 3
		If ValType(&(cVarRef)) == "N"
			If &(cVarRef) == nDefPre
				If lMsSeekBco
					aAreaOLD 	:= SGG->(GetArea()) // Salva área posicionada.
					dbSelectArea("SGG")
					SGG->(dbSetOrder(1))
				EndIf
				If !lAutomacao
					oReturn := ConPad1(,,,"SB1PGG")
				Endif
				If lMsSeekBco
					RestArea(aAreaOLD) // Retorna área salva.
				EndIf

			ElseIf &(cVarRef) == nDefEstr
				If lMsSeekBco
					aAreaOLD 	:= SG1->(GetArea()) // Salva área posicionada.
					dbSelectArea("SG1")
					SG1->(dbSetOrder(1))
				EndIf
				If !lAutomacao
					oReturn := ConPad1(,,,"SB1PG1")
				EndIf
				If lMsSeekBco
					RestArea(aAreaOLD) // Retorna área salva.
				EndIf

			EndIf
		Else
			If &(cVarRef) != "Estrutura"
				If lMsSeekBco
					aAreaOLD 	:= SGG->(GetArea()) // Salva área posicionada.
					dbSelectArea("SGG")
					SGG->(dbSetOrder(1))
				EndIf
				If !lAutomacao
					oReturn := ConPad1(,,,"SB1PGG")
				EndIf
				If lMsSeekBco
					RestArea(aAreaOLD) // Retorna área salva.
				EndIf

			Else
				If lMsSeekBco
					aAreaOLD 	:= SG1->(GetArea()) // Salva área posicionada.
					dbSelectArea("SG1")
					SG1->(dbSetOrder(1))
				EndIf
				If !lAutomacao
					oReturn := ConPad1(,,,"SB1PG1")
				EndIf
				If lMsSeekBco
					RestArea(aAreaOLD) // Retorna área salva.
				EndIf

			EndIf
		EndIf

	EndIf

Return oReturn

/*/{Protheus.doc} PCPExisCmp
Verifica se o componente faz parte da estrutura/pré-estrutura - Query's no banco
@author brunno.costa
@since 12/12/2018
@version 1.0
@param lPreEstrutura, lógico   , indicador lógico se o produto é de pré-estrutura
@param cProduto     , caracter , código do produto a ser avaliado
@param cComponente  , caracter , código do componente a ser avaliado
@param cRevisao     , caracter , código da revisão do produto pai a ser avaliada
@param lGetPath     , lógico   , indica se retorna por referência os caminhos
@param aPaths       , array    , array com os caminhos do componente na estrutura, retorno por referência
                                 aPaths[x] := {Path, Componente, Nivel}
@return Nil
/*/
Function PCPExisCmp(lPreEstrutura, cProduto, cComponente, cRevisao, lGetPath, aPaths)

	Local aArea        := GetArea()
	Local aAreaSB1     := SB1->(GetArea())
	Local cAliasTop    := GetNextAlias()
	Local cAliasSelect := Iif(lPreEstrutura, RetSqlName( "SGG" ), RetSqlName( "SG1" ))
	Local cBanco       := TCGetDB()
	Local cJoinRecur   := ""
	Local cQuery       := ""
	Local cQueryBase   := ""
	Local cWherePai    := ""
	Local lReturn      := .F.

	Default lPreEstrutura := .T.
	Default cProduto      := ""
	Default cComponente   := ""
	Default cRevisao      := Posicione("SB1",1,xFilial("SB1")+cProduto,"B1_REVATU")
	Default lGetPath      := .F.
	Default aPaths        := {}

	If !Empty(cProduto) .and. !Empty(cComponente)

		//Prepara trechos exclusivos para SG1
		If !lPreEstrutura
			cWherePai  := " AND G1_REVINI <= '" + cRevisao + "' AND G1_REVFIM >= '" + cRevisao + "' "

			cJoinRecur := " INNER JOIN " + RetSqlName( "SB1" ) + " b1 "
			cJoinRecur += "     ON b1.B1_COD = rec.G1_COD "
			cJoinRecur += "     AND b1.B1_REVATU BETWEEN rec.G1_REVINI AND rec.G1_REVFIM "
		EndIf

		//Cria Query base para todos os bancos
		cQueryBase := " WITH EstruturaRecursiva(G1_COMP, G1_REVINI, G1_REVFIM, G1_COD, Nivel, Path)  "
		cQueryBase += " AS ( "
		cQueryBase += "     SELECT "
		cQueryBase += "         G1_COMP, "
		cQueryBase += " 		G1_REVINI, "
		cQueryBase += " 		G1_REVFIM, "
		cQueryBase += " 		G1_COD, "
		cQueryBase += " 		1 as Nivel, "
		cQueryBase += " 		Cast(G1_COMP AS VarChar(255)) AS Path "
		cQueryBase += "  	FROM " + cAliasSelect
		cQueryBase += "  	WHERE G1_COD = '" + cProduto + "' and D_E_L_E_T_ = ' ' "
		cQueryBase += cWherePai
		cQueryBase += "  	UNION ALL  "
		cQueryBase += "  	SELECT "
		cQueryBase += "  	    estrutura.G1_COMP, "
		cQueryBase += " 		estrutura.G1_REVINI, "
		cQueryBase += " 		estrutura.G1_REVFIM, "
		cQueryBase += " 		estrutura.G1_COD, "
		cQueryBase += "  	    rec.Nivel + 1 AS Nivel,  "
		cQueryBase += " 		Cast((rec.Path || '|' || estrutura.G1_COMP) AS VarChar(255)) Path   "
		cQueryBase += "  	FROM " + cAliasSelect + " estrutura "
		cQueryBase += "  	    INNER JOIN EstruturaRecursiva rec   "
		cQueryBase += "  	         ON estrutura.G1_COD = rec.G1_COMP  "
		cQueryBase += cJoinRecur
		cQueryBase += "  	WHERE rec.Path NOT LIKE '%|' || estrutura.G1_COMP || '%' "
		cQueryBase += "  	   AND  estrutura.D_E_L_E_T_ = ' ' "
		cQueryBase += "   ) "
		cQueryBase += " SELECT G1_COMP as Componente, Nivel, Path "
		cQueryBase += " FROM EstruturaRecursiva  "
		cQueryBase += " WHERE G1_COMP = '" + cComponente + "' "

		//Atribui Query Padrão
		cQuery := cQueryBase

		//Realiza ajustes da Query para cada banco
		If cBanco == "ORACLE"

			//Limita a 1 registro
			If !lGetPath
				cQuery += "        AND ROWNUM = 1 "
			EndIf

			//Ordena por Path
			cQuery += "  ORDER BY 3 "

		ElseIf cBanco == "POSTGRES"

			//Altera sintaxe da clausula WITH
			cQuery := StrTran(cQuery, 'WITH ', 'WITH recursive ')

			//Ordena por Path
			cQuery += "  ORDER BY 3 "

			//Limita a 1 registro
			If !lGetPath
				cQuery += " LIMIT 1 "
			EndIf

			//Corrige Falhas internas de Binário - POSTGRES
			cQuery := StrTran(cQuery,chr(13)," ")
			cQuery := StrTran(cQuery,chr(10)," ")
			cQuery := StrTran(cQuery,chr(09)," ")

		//ElseIf cBanco == "MSSQL"
		Else
			//Substitui concatenação || por +
			cQuery := StrTran(cQuery, '||', '+')

			//Limita a 1 registro
			If !lGetPath
				cQuery := StrTran(cQuery, 'G1_COMP as Componente', 'TOP 1 G1_COMP as Componente')
			EndIf

			//Ordena por Path
			cQuery += "  ORDER BY 3 "
		EndIf

		If lPreEstrutura
			cQuery := StrTran(cQuery, 'G1_', 'GG_')
		EndIf
	EndIf

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)
	If !(cAliasTop)->(Eof())
		lReturn := .T.
	EndIf
	If lGetPath
		While !(cAliasTop)->(Eof())
			aAdd(aPaths, {(cAliasTop)->Path, (cAliasTop)->Componente, (cAliasTop)->Nivel})
			(cAliasTop)->(DbSkip())
		EndDo
	EndIf
	(cAliasTop)->(dbCloseArea())
	RestArea(aAreaSB1)
	RestArea(aArea)

Return lReturn

/*/{Protheus.doc} PCPCnvPerg
Converte a Pergunta SX1 em chamada ParamBox
@author brunno.costa
@since 12/12/2018
@version 1.0
@param cPergunta, caracter, código da pergunta do configurador
@param lShow    , lógico  , indica se deve exibir a pergunta ou não
@param aOpcoes  , array   , array com as opções especiais para substituição do ParamBox
                  [1] Tipo do parametro
                   1 - MsGet
                     [2] : Descricao
                     [3] : String contendo o inicializador do campo
                     [4] : String contendo a Picture do campo
                     [5] : String contendo a validacao
                     [6] : Consulta F3
                     [7] : String contendo a validacao When
                     [8] : Tamanho do MsGet
                     [9] : Flag .T./.F. Parametro Obrigatorio ?
                   2 - Combo
                     [2] : Descricao
                     [3] : Numerico contendo a opcao inicial do combo
                     [4] : Array contendo as opcoes do Combo
                     [5] : Tamanho do Combo
                     [6] : Validacao
                     [7] : Flag .T./.F. Parametro Obrigatorio ?
					 [8] : String contendo a validacao When

					[***Demais opções não homologadas***]

@param lRecursiva, lógico  , indica chamada recursiva - recupera conteúdo anterior do MV_PAR
@param cTitulo   , caracter, título que será apresentado na tela
@param bOk       , bloco   , bloco de validação do botão ok
@param aButtons  , array   , array de botões conforme padrão ParamBox
@param lCentered , lógico  , indica se a ParamBox será aberta centralizada
@param nPosX     , numérico, indicador de posição X de abertura da ParamBox
@param nPosy     , numérico, indicador de posição Y de abertura da ParamBox
@param cLoad     , caracter, nome da rotina utilizada no ParamSave
@param lCanSave  , lógico  , indica se permite que o usuário administrador salve/bloqueie os parâmetros padrões
@param lUserSave , lógico  , indica se qualquer usuário permite salvar os parâmetros padrões (pré requisito lCanSave)
@return lReturn  , lógico  , indica se a tela de parâmetros foi confirmada ou cancelada

Ao utilizar, CUIDADO com:
--> Tamanhos inicializadores padrões e Pictures de campos get, necessário repassar devido limitação da FwSX1Util();
--> Chamadas de CONSULTAS PADRÕES, necessário repassar devido limitação da FwSX1Util();
--> Notar INEXISTÊNCIA de HELP;
/*/
Function PCPCnvPerg(cPergunta, lShow, aOpcoes, lRecursiva, cTitulo, bOk, aButtons, lCentered, nPosX, nPosy, cLoad, lCanSave, lUserSave)
	Local lReturn   := .T.
	Local aParamBox := {}
	Local oPergunta := FWSX1Util():New()
	Local oAux
	Local nInd
	Local aRet
	Local lOpc      := !Empty(aOpcoes)
	Local aCombo    := {}
	Local cTitPergun:= ""

	Default lRecursiva := .F.
	Default cTitulo    := STR0058 //"Parâmetros:"
	DEFAULT bOk        := {|| (.T.)}
	DEFAULT aButtons   := {}
	DEFAULT lCentered  := .T.
	DEFAULT nPosX      := 0
	DEFAULT nPosY      := 0
	DEFAULT cLoad      := ProcName(1)
	DEFAULT lCanSave   := .F.
	DEFAULT lUserSave  := .F.
	DEFAULT lAutomacao := .F.

	//Recupera conteúdo anterior
	If lRecursiva
		For nInd := 1 to Len(aOpcoes)
			aOpcoes[nInd][3] := &("MV_PAR" + PadL(nInd, 2, '0'))
		Next nInd
	EndIf

	oPergunta:AddGroup(cPergunta)
	oPergunta:SearchGroup()
	oAux := oPergunta:aGrupo[1][2]

	For nInd := 1 to Len(oAux)
		cTitPergun := AllTrim(StrTran(oAux[nInd]:CX1_Pergunt, "?", ""))
		If oAux[nInd]:CX1_GSC == "G"	//GET
			If oAux[nInd]:CX1_TIPO == "C"		// Tipo caractere
				aAdd(aParamBox,{Iif(!lOpc .OR. aOpcoes[nInd][1] == Nil, 1             , aOpcoes[nInd][1]),;
								Iif(!lOpc .OR. aOpcoes[nInd][2] == Nil, cTitPergun    , aOpcoes[nInd][2]),;
								Iif(!lOpc .OR. aOpcoes[nInd][3] == Nil, Space(15)     , aOpcoes[nInd][3]),;
								Iif(!lOpc .OR. aOpcoes[nInd][4] == Nil, ""            , aOpcoes[nInd][4]),;
								Iif(!lOpc .OR. aOpcoes[nInd][5] == Nil, ""            , aOpcoes[nInd][5]),;
								Iif(!lOpc .OR. aOpcoes[nInd][6] == Nil, ""            , aOpcoes[nInd][6]),;
								Iif(!lOpc .OR. aOpcoes[nInd][7] == Nil, ""            , aOpcoes[nInd][7]),;
								Iif(!lOpc .OR. aOpcoes[nInd][8] == Nil, 100           , aOpcoes[nInd][8]),;
								Iif(!lOpc .OR. aOpcoes[nInd][9] == Nil, .F.           , aOpcoes[nInd][9])})

			ElseIf oAux[nInd]:CX1_TIPO == "N"	// Tipo numérico
				aAdd(aParamBox,{Iif(!lOpc .OR. aOpcoes[nInd][1] == Nil, 1             , aOpcoes[nInd][1]),;
								Iif(!lOpc .OR. aOpcoes[nInd][2] == Nil, cTitPergun    , aOpcoes[nInd][2]),;
								Iif(!lOpc .OR. aOpcoes[nInd][3] == Nil, 0             , aOpcoes[nInd][3]),;
								Iif(!lOpc .OR. aOpcoes[nInd][4] == Nil, "@E 99,999.99", aOpcoes[nInd][4]),;
								Iif(!lOpc .OR. aOpcoes[nInd][5] == Nil, ""            , aOpcoes[nInd][5]),;
								Iif(!lOpc .OR. aOpcoes[nInd][6] == Nil, ""            , aOpcoes[nInd][6]),;
								Iif(!lOpc .OR. aOpcoes[nInd][7] == Nil, ""            , aOpcoes[nInd][7]),;
								Iif(!lOpc .OR. aOpcoes[nInd][8] == Nil, 100           , aOpcoes[nInd][8]),;
								Iif(!lOpc .OR. aOpcoes[nInd][9] == Nil, .F.           , aOpcoes[nInd][9])})

			ElseIf oAux[nInd]:CX1_TIPO == "D"	// Tipo data
				aAdd(aParamBox,{Iif(!lOpc .OR. aOpcoes[nInd][1] == Nil, 1             , aOpcoes[nInd][1]),;
								Iif(!lOpc .OR. aOpcoes[nInd][2] == Nil, cTitPergun    , aOpcoes[nInd][2]),;
								Iif(!lOpc .OR. aOpcoes[nInd][3] == Nil, Ctod(Space(8)), aOpcoes[nInd][3]),;
								Iif(!lOpc .OR. aOpcoes[nInd][4] == Nil, ""            , aOpcoes[nInd][4]),;
								Iif(!lOpc .OR. aOpcoes[nInd][5] == Nil, ""            , aOpcoes[nInd][5]),;
								Iif(!lOpc .OR. aOpcoes[nInd][6] == Nil, ""            , aOpcoes[nInd][6]),;
								Iif(!lOpc .OR. aOpcoes[nInd][7] == Nil, ""            , aOpcoes[nInd][7]),;
								Iif(!lOpc .OR. aOpcoes[nInd][8] == Nil, 50            , aOpcoes[nInd][8]),;
								Iif(!lOpc .OR. aOpcoes[nInd][9] == Nil, .F.           , aOpcoes[nInd][9])})
			EndIf
		EndIf

		If oAux[nInd]:CX1_GSC == "C"	//COMBO
			aCombo := {}
			aAdd(aCombo, oAux[nInd]:CX1_DEF01)
			aAdd(aCombo, oAux[nInd]:CX1_DEF02)
			If !Empty(oAux[nInd]:CX1_DEF03)
			 	aAdd(aCombo, oAux[nInd]:CX1_DEF03)
			EndIf
			If !Empty(oAux[nInd]:CX1_DEF04)
			 	aAdd(aCombo, oAux[nInd]:CX1_DEF04)
			EndIf
			If !Empty(oAux[nInd]:CX1_DEF05)
			 	aAdd(aCombo, oAux[nInd]:CX1_DEF05)
			EndIf
			If aOpcoes[nInd][4] == Nil .OR. Empty(aOpcoes[nInd][4])
				aOpcoes[nInd][4] := aClone(aCombo)
			Endif

			aAdd(aParamBox,{Iif(!lOpc .OR. aOpcoes[nInd][1] == Nil, 2             , aOpcoes[nInd][1]),;
							Iif(!lOpc .OR. aOpcoes[nInd][2] == Nil, cTitPergun    , aOpcoes[nInd][2]),;
							Iif(!lOpc .OR. aOpcoes[nInd][3] == Nil, 1             , aOpcoes[nInd][3]),;
							Iif(!lOpc .OR. aOpcoes[nInd][4] == Nil, aCombo        , aOpcoes[nInd][4]),;
							Iif(!lOpc .OR. aOpcoes[nInd][5] == Nil, 100           , aOpcoes[nInd][5]),;
							Iif(!lOpc .OR. aOpcoes[nInd][6] == Nil, ""            , aOpcoes[nInd][6]),;
							Iif(!lOpc .OR. aOpcoes[nInd][7] == Nil, .F.           , aOpcoes[nInd][7]),;
							Iif(!lOpc .OR. aOpcoes[nInd][8] == Nil, Nil           , aOpcoes[nInd][8]),;
							Iif(!lOpc .OR. aOpcoes[nInd][9] == Nil, Nil           , aOpcoes[nInd][9])})
		EndIf

	Next nInd
	If !lAutomacao
		lReturn := ParamBox(aParamBox, cTitulo, @aRet, bOk, aButtons, lCentered, nPosX, nPosy, Nil /*oDlgWizard*/, cLoad, lCanSave, lUserSave)
	Else
		aRet := {}
	EndIf
	If lReturn
		//Corrige Conteúdo Numérico de Retorno dos Combos
		For nInd := 1 to Len(aRet)
			If oAux[nInd]:CX1_GSC == "C";
				.AND. ValType(&("MV_PAR" + PadL(nInd, 2, '0'))) != "N";
				.AND. aOpcoes[nInd][4] != Nil;
				.AND. !Empty(aOpcoes[nInd][4])

				If oAux[nInd]:CX1_TIPO == "N"
					&("MV_PAR" + PadL(nInd, 2, '0')) := aScan(aOpcoes[nInd][4], {|x| AllTrim(x) == AllTrim(aRet[nInd])})
				Else
					&("MV_PAR" + PadL(nInd, 2, '0')) := cValToChar(aScan(aOpcoes[nInd][4], {|x| AllTrim(x) == AllTrim(aRet[nInd])}))
				EndIf
			EndIf
		Next nInd
	EndIf

Return lReturn


//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPa650PPI

Realiza a integração com o PC-Factory - PPI Multitask

@param cXml    - XML que será enviado. Caso não seja passado esse parametro, será realizada
                 a chamada do Adapter para criação do XML.
                 Se for passado esse parâmetro, não será exibida a mensagem de erro caso exista,
                 nem será considerado o filtro da tabela SOE.
@param cCodigo - Obrigatório quando utilizado o parâmetro cXml. Contém o código da OP (NUM+ITEM+SEQUEN)
@param lTable  - Indica se será utilizado variáveis de memória ou do registro posicionado para recuperar os valores.
                 .T. -> (SC2->C2_NUM)
                 .F. -> (M->C2_NUM)
@param lPendAut - Indica se será gerada a pendência sem realizar a pergunta para o usuário, caso ocorra algum erro.
@param lExclusao - Indica se está chamando para rotina de exclusão.
@param lFiltra   - Identifica se será realizado ou não o filtro do registro.

@author  Lucas Konrad França
@version P12
@since   02/09/2015
@return  lRet  - Indica se a integração com o PC-Factory foi realizada.
           .T. -> Integração Realizada
           .F. -> Integração não realizada.
/*/
//-------------------------------------------------------------------------------------------------
Function PCPa650PPI(cXml, cOp, lTable, lPendAut, lExclusao, lFiltra)
	Local aArea     := GetArea()
	Local aRetArq   := {}
	Local aRetData  := {}
	Local aRetWS    := {}
	Local aRetXML   := {}
	Local aRotinas  := {}
	Local cIntMrp   := Iif(Type('cIntgPPI')=="C",cIntgPPI,"1")
	Local cGerouXml := ""
	Local cNomeXml  := ""
	Local cOperacao := ""
	Local cPont     := "M"
	Local cRoteiro  := ""
	Local lMRP      := .F.
	Local lRet      := .T.

	//Variável utilizada para identificar que está sendo executada a integração para o PPI dentro do MATI650.
	Private lRunPPI   := .T.
	Private cPonteiro := ""

	Default cXml      := ""
	Default cOp       := ""
	Default lTable    := .F.
	Default lPendAut  := .F.
	Default lExclusao := .F.
	Default lFiltra   := .T.

	aAdd(aRotinas,"MATA650")
	aAdd(aRotinas,"MATA651")
	aAdd(aRotinas,"PCPA111")
	aAdd(aRotinas,"PCPA110")
	aAdd(aRotinas,"PCPA124")
	aAdd(aRotinas,"MATA380")
	aAdd(aRotinas,"MATA381")
	aAdd(aRotinas,"MATA690")
	aAdd(aRotinas,"MATA712")
	aAdd(aRotinas,"SFCA310")
	aAdd(aRotinas,"MATA637")
	aAdd(aRotinas,"PCPA107")
	aAdd(aRotinas,"PCPA114")
	aAdd(aRotinas,"PCPA145")
	aAdd(aRotinas,"PCPA146")

	//Neste momento, não irá realizar a integração com as ordens que são geradas
	//a partir do MRP, por questão de performance.
	//A integração das ordens geradas pelo MRP será realizada posteriormente, em uma thread separada.
	If (Type('lProj711') == "L" .And. lProj711 == .T.) .Or. (aScan(aRotinas,{|x| x == AllTrim(FunName())}) <= 0 .AND. !(Type('l650Auto') == "L" .And. l650Auto))
		Return .T.
	EndIf

	If FunName() $ "MATA712|PCPA107|PCPA146|PCPA145"
		lMRP := .T.
	EndIf

	//Se está executando o MRP, e o parâmetro está configurado para não integrar, não faz nada.
	If lMRP .And. cIntMrp == "1"
		Return .T.
	EndIf

	If Type('INCLUI') != "L"
		INCLUI := .F.
		ALTERA := .T.
	EndIf

	If lTable
		cPont := "SC2"
	Else
		cPont := "M"
	EndIf

	cPonteiro := cPont

	If Empty(cXml)
		If lExclusao
			cOperacao := Lower(STR0064) //"excluir"
		Else
			If INCLUI
				cOperacao := Lower(STR0062) //"incluir"
			Else
				cOperacao := Lower(STR0063) //"alterar"
			EndIf
		EndIf
		cOp := &(cPont+'->(C2_NUM+C2_ITEM+C2_SEQUEN)')
	Else
		If PCPEvntXml(cXml) == "delete"
			lExclusao := .T.
		EndIf
	EndIf

	If lExclusao
		INCLUI := .F.
		ALTERA := .F.
	EndIf

	//Realiza filtro na tabela SOE, para verificar se a ordem de produção entra na integração.
	If !Empty(cXml) .Or. !lFiltra .Or. PCPFiltPPI("SC2", cOp,cPont)
		If Empty(cXml) .And. Empty(&(cPont+'->C2_ROTEIRO')) .And. !lExclusao
			If lPendAut .Or. (Type('l650Auto') == "L" .And. l650Auto)
				dbSelectArea("SB1")
				SB1->(dbSetOrder(1))
				If SB1->(dbSeek(xFilial("SB1")+&(cPont+'->C2_PRODUTO')))
					cRoteiro := Iif(Empty(SB1->B1_OPERPAD),"01",SB1->B1_OPERPAD)
					If cPont == "SC2"
						RecLock("SC2",.F.)
							SC2->C2_ROTEIRO := cRoteiro
						SC2->(MsUnLock())
					Else
						&(cPont+'->C2_ROTEIRO') := cRoteiro
					EndIf
				EndIf
			Else
				Aviso(STR0065,STR0066,{"Ok"},2) //"Roteiro não informado. Para ordens de produção que são integradas com o TOTVS MES este campo é obrigatório."
				lRet := .F.
			EndIf
		EndIf

		If lRet
			//Adapter para criação do XML
			If Empty(cXml)
				aRetXML := MATI650("", TRANS_SEND, EAI_MESSAGE_BUSINESS,"2.004")
			Else
				aRetXML := {.T.,cXml}
			EndIf
			/*
			aRetXML[1] - Status da criação do XML
			aRetXML[2] - String com o XML
			*/

			If aRetXML[1]
				//Retira os caracteres especiais
				aRetXML[2] := EncodeUTF8(aRetXML[2])

				//Se está realizando a exclusão das ops previstas pelo MRP, apenas salva o XML para processar
				//posteriormente. Isso é feito para não afetar muito na performance do MRP.
				If lMRP .And. IsInCallStack("MTApagaPre")
					aAdd(aDelOpsPPI,{aRetXML[2],cOp})
					Return .T.
				EndIf

				//Busca a data/hora de geração do XML
				aRetData := PCPxDtXml(aRetXML[2])
				/*
					aRetData[1] - Data de geração AAAAMMDD
					aRetData[1] - Hora de geração HH:MM:SS
				*/

				//Envia o XML para o PCFactory
				If lMRP .And. cIntMrp == "2"
					aRetWS := {"2",STR0067} //"Pendente processamento MRP."
				Else
					aRetWS := PCPWebsPPI(aRetXML[2])
				EndIf
				/*
					aRetWS[1] - Status do envio (1 - OK, 2 - Pendente, 3 - Erro.)
					aRetWS[2] - Mensagem de retorno do PPI
				*/
				If aRetWS[1] != "1" .And. Empty(cXml)
					If lPendAut .Or. (Type('l650Auto') == "L" .And. l650Auto) .Or. lMRP
						lRet := .T.
					Else
						//"Atenção! Ocorreram erros na integração com o TOTVS MES. Erro: "
						// XXXXXX
						// XXXXXX
						// "Deseja incluir/alterar/excluir a ordem de produção no protheus e gerar pendência para integração?"
						If !MsgYesNo(STR0068 + AllTrim(aRetWS[2]) +CHR(10)+;
									STR0069 + AllTrim(cOperacao) +STR0070)
							lRet := .F.
						EndIf
					EndIf
				EndIf

				If lRet
					//Cria o XML fisicamente no diretório parametrizado
					aRetArq := PCPXmLPPI(aRetWS[1],"SC2",cOp,aRetData[1],aRetData[2],aRetXML[2])
					/*
						aRetArq[1] Status da criação do arquivo. .T./.F.
						aRetArq[2] Nome do XML caso tenha criado. Mensagem de erro caso não tenha criado o XML.
					*/
					If !aRetArq[1]
						If Empty(cXml) .And. (!lPendAut .And. (Type('l650Auto') == "L" .And. !l650Auto))
							Alert(aRetArq[2])
						EndIf
					Else
						cNomeXml := aRetArq[2]
					EndIf

					If Empty(cNomeXml)
						cGerouXml := "2"
					Else
						cGerouXml := "1"
					EndIf

					//Cria a tabela SOF
					PCPCriaSOF("SC2",cOp,aRetWS[1],cGerouXml,cNomeXml,aRetData[1],aRetData[2],__cUserId,aRetWS[2],aRetXML[2])

					//Array com as ops intermediárias que tiveram erro.
					If Type('aIntegPPI') == "A"
						If aRetWS[1] != "1"
							aAdd(aIntegPPI,{cOp,aRetWS[2]})
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	//Tratativa para retornar .F. mesmo quando é pendência automática;
	//Utilizado apenas para o programa de sincronização e carga máquina.
	If (AllTrim(FunName()) == "PCPA111" .Or. ;
		AllTrim(FunName()) == "MATA690" .Or. ;
		AllTrim(FunName()) == "MATA381" .Or. ;
		AllTrim(FunName()) == "MATA380" .Or. ;
		IsInCalLStack("SFCA315AV")      .Or. ;
		IsInCallStack("MATA637SC2") ) .And. Len(aRetWS) > 0 .And. aRetWS[1] != "1"
		lRet := .F.
	EndIf

	RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650AvalPV ³ Autor ³ Sergio S. Fuzinaka   ³ Data ³ 14.04.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Executa a avaliacao do Pedido de Venda.                     ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PCP650AvPV()
	Local aArea     := GetArea()
	Local aAreaSC2  := SC2->( GetArea() )
	Local aAreaSC6  := SC6->( GetArea() )
	Local aAreaSD3  := SD3->( GetArea() )
	Local aAreaSB2  := SB2->( GetArea() )
	Local cAliasQry := ""
	Local cItemOP   := ""
	Local cItemPV   := ""
	Local cLocal    := ""
	Local cNumOP    := ""
	Local cNumPV    := ""
	Local cProduto  := ""
	Local lContinua := .T.
	Local lExclui   := .T.

	If SC6->C6_TPOP == "F" //OP Firme
		If !Empty(SC6->C6_NUMOP) //Gerado OP
			cNumPV   := SC6->C6_NUM
			cItemPV  := SC6->C6_ITEM
			cProduto := SC6->C6_PRODUTO
			cLocal   := SC6->C6_LOCAL
			cNumOP   := SC6->C6_NUMOP
			cItemOP  := SC6->C6_ITEMOP

			//Verifica a tabela SGJ
			cAliasQry := GetNextAlias()
			BeginSQL Alias cAliasQry
			 SELECT SUM(GJ_QUANT) AS SUM_QUANT
			   FROM %Table:SGJ% SGJ
			  WHERE SGJ.GJ_FILIAL  = %XFilial:SGJ%
			    AND SGJ.GJ_NUMPV   = %Exp:cNumPV%
			    AND SGJ.GJ_ITEMPV  = %Exp:cItemPV%
			    AND SGJ.GJ_PRODUTO = %Exp:cProduto%
			    AND SGJ.GJ_LOCAL   = %Exp:cLocal%
			    AND SGJ.GJ_NUMOP   = %Exp:cNumOP%
			    AND SGJ.GJ_ITEMOP  = %Exp:cItemOP%
			    AND SGJ.%NotDel%
			EndSQL
			If (cAliasQry)->(Eof()) .Or. (cAliasQry)->SUM_QUANT == 0
				lExclui   := .T.
				lContinua := .F.
			Else
				If (cAliasQry)->SUM_QUANT == SC6->C6_QTDVEN
					lExclui   := .F.
					lContinua := .F.
				EndIf
			EndIf
			(cAliasQry)->(dbCloseArea())

			//Verifica se tem quantidade produzida
			If lContinua
				BeginSQL Alias cAliasQry
				  SELECT 1
				    FROM %Table:SGJ% SGJ
				   INNER JOIN %Table:SC2% SC2
				      ON SC2.C2_FILIAL  = %XFilial:SC2%
				     AND SC2.C2_NUM     = SGJ.GJ_NUMOP
				     AND SC2.C2_ITEM    = SGJ.GJ_ITEMOP
				     AND SC2.C2_SEQUEN  = SGJ.GJ_SEQUEN
				     AND SC2.C2_ITEMGRD = SGJ.GJ_ITGRDOP
				   WHERE SGJ.GJ_FILIAL  = %XFilial:SGJ%
				     AND SGJ.GJ_NUMPV   = %Exp:cNumPV%
				     AND SGJ.GJ_ITEMPV  = %Exp:cItemPV%
				     AND SGJ.GJ_PRODUTO = %Exp:cProduto%
				     AND SGJ.GJ_LOCAL   = %Exp:cLocal%
				     AND SGJ.GJ_NUMOP   = %Exp:cNumOP%
				     AND SGJ.GJ_ITEMOP  = %Exp:cItemOP%
				     AND SC2.C2_QUJE    > 0
				     AND SGJ.%NotDel%
				     AND SC2.%NotDel%
				EndSQL
				If !(cAliasQry)->(Eof())
					lExclui   := .F.
					lContinua := .F.
				EndIf
				(cAliasQry)->(dbCloseArea())
			EndIf

			//Verifica se tem movimentação não estornada
			If lContinua
				BeginSQL Alias cAliasQry
				  SELECT 1
				    FROM %Table:SGJ% SGJ
				   INNER JOIN %Table:SD3% SD3
				      ON SD3.D3_FILIAL   = %XFilial:SD3%
				     AND SD3.D3_OP       = (SGJ.GJ_NUMOP || SGJ.GJ_ITEMOP || SGJ.GJ_SEQUEN || SGJ.GJ_ITGRDOP)
				   WHERE SGJ.GJ_FILIAL   = %XFilial:SGJ%
				     AND SGJ.GJ_NUMPV    = %Exp:cNumPV%
				     AND SGJ.GJ_ITEMPV   = %Exp:cItemPV%
				     AND SGJ.GJ_PRODUTO  = %Exp:cProduto%
				     AND SGJ.GJ_LOCAL    = %Exp:cLocal%
				     AND SGJ.GJ_NUMOP    = %Exp:cNumOP%
				     AND SGJ.GJ_ITEMOP   = %Exp:cItemOP%
				     AND SD3.D3_ESTORNO <> 'S'
				     AND SGJ.%NotDel%
				     AND SD3.%NotDel%
				EndSQL
				If !(cAliasQry)->(Eof())
					lExclui   := .F.
					lContinua := .F.
				EndIf
				(cAliasQry)->(dbCloseArea())
			EndIf

			//Exclui todas as OPs originadas pelo pedido
			If lExclui
				cAliasQry := GetNextAlias()
				BeginSQL Alias cAliasQry
				  SELECT GJ_NUMOP, GJ_ITEMOP, GJ_SEQUEN, GJ_ITGRDOP
				    FROM %Table:SGJ% SGJ
				   WHERE SGJ.GJ_FILIAL  = %XFilial:SGJ%
				     AND SGJ.GJ_NUMPV   = %Exp:cNumPV%
				     AND SGJ.GJ_ITEMPV  = %Exp:cItemPV%
				     AND SGJ.GJ_PRODUTO = %Exp:cProduto%
				     AND SGJ.GJ_LOCAL   = %Exp:cLocal%
				     AND SGJ.GJ_NUMOP   = %Exp:cNumOP%
				     AND SGJ.GJ_ITEMOP  = %Exp:cItemOP%
				     AND SGJ.%NotDel%
				EndSQL

				dbSelectArea("SC2")
				SC2->(dbSetOrder(1))

				While (cAliasQry)->(!Eof())
					If SC2->(dbSeek(xFilial("SC2") + (cAliasQry)->GJ_NUMOP + (cAliasQry)->GJ_ITEMOP + (cAliasQry)->GJ_SEQUEN + (cAliasQry)->GJ_ITGRDOP))
						A650RotAut(5)
					EndIf
					(cAliasQry)->(dbSkip())
				End
				(cAliasQry)->(dbCloseArea())
			Endif
		Else
			dbSelectArea("SGJ")
			dbSetOrder(1)
			If dbSeek( xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL) )
				If SC6->C6_QTDVEN < SGJ->GJ_QUANT
					A650DelSGJ("I")		//Estorno de Empenho SGJ/SB2
				Endif
			Endif
		Endif
	Endif

	RestArea(aArea)
	RestArea(aAreaSC2)
	RestArea(aAreaSC6)
	RestArea(aAreaSD3)
	RestArea(aAreaSB2)

Return


/*/{Protheus.doc} CalcEntreg
Varre a estrutura do produto e calcula o prazo de entrega, considerando
o maior tempo de determinado "nó" da estrutura.

@author lucas.franca
@since 27/12/2018
@version P12
@param cProduto, character, Código do produto da ordem de produção
@param nQuant  , numeric  , Quantidade da ordem de produção
@param dDataEnt, date     , Data de início da ordem de produção
@return nMaxPrazo, numeric, Prazo total para entrega dos componentes.
/*/
Function PCPCalcEnt(cProduto,nQuant,dDataEnt)
	Local aArea      := GetArea()
	Local aAreaSG1	 := SG1->(GetArea())
	Local aEstrutura := {}
	Local cQuery     := ""
	Local cAliasTop  := "GETSTRUCT"
	Local cBanco     := TCGetDB()
	Local cArqProd   := SuperGetMV("MV_ARQPROD",.F.,"SB1")
	Local nIndEstru  := 0
	Local nIndReg    := 0
	Local nRegistro  := 0
	Local nMaxPrazo  := 0
	Local nPrazoEstr := 0
	Local nPrazo     := 0
	Local nQtdEstru  := 0
	Local dDataEstru := Date()
	Local lRevFil    := SuperGetMv("MV_REVFIL",.F.,.F.)

	Default dDataEnt := dDataBase

	dbSelectArea("SBZ")
	If !FieldPos("BZ_REVATU") > 0
		lRevFil := .F.
	EndIf

	cQuery :=  " WITH ALLESTRUTURAS(G1_COD,G1_COMP,CAMINHO) "
	cQuery +=    " AS (SELECT G1ANCORA.G1_COD, "
	cQuery +=               " G1ANCORA.G1_COMP, "
	cQuery +=               " CAST(G1ANCORA.R_E_C_N_O_ AS VARCHAR(1024)) AS CAMINHO "
	cQuery +=          " FROM " + RetSqlName("SG1") + " G1ANCORA "
	cQuery +=         " WHERE G1ANCORA.G1_FILIAL  = '"+ xFilial("SG1") +"'"
	cQuery +=           " AND G1ANCORA.D_E_L_E_T_ = ' ' "
	cQuery +=           " AND G1ANCORA.G1_COD     = '"+ cProduto +"'"
	cQuery +=           " AND G1ANCORA.G1_INI     <= '"+ DtoS(dDataBase) +"'"
	cQuery +=           " AND G1ANCORA.G1_FIM     >= '"+ DtoS(dDataBase) +"'"

	//Validação da revisão --- Os componentes devem estar dentro da revisão atual do produto PAI.
	If cArqProd == "SBZ" .And. lRevFil
		//Valida com a revisão atual da SB1 (B1_REVATU)
		cQuery +=       " AND ( "
		cQuery +=  ChangeQuery("SELECT ISNULL(SBZ.BZ_REVATU, SB1.B1_REVATU ) "               +;
		                       " FROM " + RetSqlName("SB1") + " SB1 "                        +;
							   " LEFT OUTER JOIN " + RetSqlName("SBZ") + " SBZ "             +;
							                " ON SBZ.BZ_FILIAL  = '" + xFilial("SBZ") + "' " +;
								           " AND SBZ.D_E_L_E_T_ = ' ' "                      +;
								           " AND SBZ.BZ_COD     = SB1.B1_COD "               +;
		                      " WHERE SB1.B1_FILIAL  = '" + xFilial("SB1") + "' "            +;
		                        " AND SB1.D_E_L_E_T_ = ' ' "                                 +;
		                        " AND SB1.B1_COD     = G1ANCORA.G1_COD ")
		cQuery +=           " ) "
		cQuery += " BETWEEN G1ANCORA.G1_REVINI AND G1ANCORA.G1_REVFIM "
	Else
		//Valida com a revisão atual da SB1 (B1_REVATU)
		cQuery +=       " AND (SELECT SB1.B1_REVATU "
		cQuery +=              " FROM " + RetSqlName("SB1") + " SB1 "
		cQuery +=             " WHERE SB1.B1_FILIAL  = '" + xFilial("SB1") + "' "
		cQuery +=               " AND SB1.D_E_L_E_T_ = ' ' "
		cQuery +=               " AND SB1.B1_COD     = G1ANCORA.G1_COD ) "
		cQuery +=       " BETWEEN G1ANCORA.G1_REVINI AND G1ANCORA.G1_REVFIM "
	EndIf
	cQuery +=         " UNION ALL "
	cQuery +=         " SELECT ESTRUTURA.G1_COD, "
	cQuery +=                " ESTRUTURA.G1_COMP, "
	cQuery +=                " CAST(REC.CAMINHO || '|' || CAST(ESTRUTURA.R_E_C_N_O_ AS VARCHAR(10)) AS VARCHAR(1024)) AS CAMINHO "
	cQuery +=           " FROM "+ RetSqlName("SG1") +" ESTRUTURA "
	cQuery +=          " INNER JOIN ALLESTRUTURAS REC "
	cQuery +=             " ON ESTRUTURA.G1_COD = REC.G1_COMP "
	cQuery +=          " WHERE ESTRUTURA.D_E_L_E_T_ = ' ' "
	cQuery +=            " AND ESTRUTURA.G1_FILIAL  = '"+ xFilial("SG1") +"'"
	cQuery +=       " ) "
	cQuery += " SELECT ALLESTRUTURAS.G1_COD, "
	cQuery +=        " ALLESTRUTURAS.G1_COMP, "
	cQuery +=        " ALLESTRUTURAS.CAMINHO "
	cQuery +=   " FROM ALLESTRUTURAS "
	cQuery +=  " WHERE NOT EXISTS (SELECT 1 "
	cQuery +=                      " FROM "+ RetSqlName("SG1") +" SG1 "
	cQuery +=                     " WHERE SG1.G1_FILIAL = '"+ xFilial("SG1") +"'"
	cQuery +=                       " AND SG1.D_E_L_E_T_ = ' ' "
	cQuery +=                       " AND ALLESTRUTURAS.G1_COMP = SG1.G1_COD) "

	If cBanco == "POSTGRES"
		cQuery := StrTran(cQuery, 'WITH ', 'WITH RECURSIVE ')
	EndIf

	If cBanco != "POSTGRES" .And. cBanco != "ORACLE"
		cQuery := StrTran(cQuery, '||', '+')
	EndIf

	cQuery := StrTran(cQuery,chr(13)," ")
	cQuery := StrTran(cQuery,chr(10)," ")
	cQuery := StrTran(cQuery,chr(09)," ")

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)

	While (cAliasTop)->(!Eof())
		aAdd(aEstrutura,StrTokArr((cAliasTop)->(CAMINHO),"|"))
		(cAliasTop)->(dbSkip())
	End
	(cAliasTop)->(dbCloseArea())

	For nIndEstru := 1 To Len(aEstrutura)
		//Percorre todas as estruturas e verifica qual delas possui o maior prazo.
		/**
		aEstrutura[1] (array com os recnos de cada nível da estrutura)
		aEstrutura[1][1] (caracter, recnos do registro da SG1)
		aEstrutura[1][2] (caracter, recnos do registro da SG1)
		aEstrutura[2] (array com os recnos de cada nível da estrutura)
		aEstrutura[2][1] (caracter, recnos do registro da SG1)
		aEstrutura[2][2] (caracter, recnos do registro da SG1)
		 */

		//Variável de controle - prazo da estrutura corrente.
		nPrazoEstr := 0
		//Variável de controle - Quantidade do componente na estrutura
		nQtdEstru  := nQuant

		//Variável de controle - Data da estrutura
		dDataEstru := dDataEnt

		For nIndReg := 1 To Len(aEstrutura[nIndEstru])
			nRegistro := Val(aEstrutura[nIndEstru][nIndReg])
			SG1->(dbGoTo(nRegistro))
			nQtdEstru := ExplEstr(nQtdEstru,nil,nil,nil,nil,.F.)
			If nQtdEstru > 0
				nPrazo := CalcPrazo(SG1->G1_COMP,SG1->G1_QUANT,,,.F.,dDataEstru)
				nPrazoEstr += nPrazo
				dDataEstru -= nPrazo
			Else
				Exit
			EndIf
		Next nIndReg

		//Verifica se o prazo desta estrutura é o maior prazo e armazena na variável nMaxPrazo.
		If nPrazoEstr > nMaxPrazo
			nMaxPrazo := nPrazoEstr
		EndIf
	Next nIndEstru

	SG1->(RestArea(aAreaSG1))
	RestArea(aArea)
Return nMaxPrazo

/*/{Protheus.doc} vldOpACD
Verifica se uma OP pode ser excluída quando existe integração do SIGAACD x SIGASFC.
Será utilizada a OP que estiver posicionada na SC2.

@author lucas.franca
@since 03/09/2018
@return lRet	- Indica se a OP pode ser excluída ou não, de acordo com a integração do SIGAACD x SIGASFC.
/*/
Function PCPvlOpACD()
	Local lRet      := .T.
	Local lIntACD   := SuperGetMV("MV_INTACD",.F.,"0") == "1"
	Local cAliasCZH := "VERCZH"
	Local aArea     := {}

	If lIntSFC .And. lIntACD
		aArea := GetArea()

		//Busca movimentações realizadas no SIGAACD para essa ordem que ainda não foram integrados com o SFC.
		cQuery := "SELECT COUNT(*) TOTAL "
		cQuery +=  " FROM " + RetSqlName("CZH") + " CZH "
		cQuery += " WHERE CZH.CZH_FILIAL = '" + xFilial("CZH") + "' "
		cQuery +=   " AND CZH.D_E_L_E_T_ = ' ' "
		cQuery +=   " AND CZH.CZH_NRORPO = '" + SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) + "' "
		cQuery +=   " AND CZH.CZH_STTR   = '1' " //Movimentações pendentes de integração com o SFC.

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCZH,.T.,.T.)

		If (cAliasCZH)->(TOTAL) > 0
			lRet := .F.
			Help( ,  , "Help", ,STR0071 + AllTrim(SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)) + ".",; // "Existem movimentações realizadas para esta ordem de produção no módulo SIGAACD. Não será possível excluir a ordem de produção XXXX."
				 1, 0, ,,,,,{STR0072}) //"Para excluir a ordem de produção, realize o estorno das movimentações do módulo SIGAACD."
		EndIf

		(cAliasCZH)->(dbCloseArea())

		RestArea(aArea)
	EndIf
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MATA650SG2()
Função de consulta específica SG2002

@author  Renan Roeder
@version P12
@since   26/06/2017
/*/
//-------------------------------------------------------------------
Function PCPA650SG2()
   Local oDlg, oLbx
   Local aCpos  := {}
   Local aRet   := {}
   Local cQuery := ""
   Local cAlias := GetNextAlias()
   Local lRet   := .F.
   Local cFilSG2 := xFilial("SG2")

   DEFAULT l650Auto	   := .F.
   DEFAULT lAutomacao  := .F.

   cQuery := " SELECT DISTINCT SG2.G2_CODIGO, SG2.G2_PRODUTO "
   cQuery +=   " FROM " + RetSqlName("SG2") + " SG2 "
   cQuery +=  " WHERE SG2.D_E_L_E_T_ = ' ' "
   cQuery +=    " AND SG2.G2_FILIAL  = '" + cFilSG2 + "' "
   If !Empty(M->C2_PRODUTO)
      cQuery += " AND SG2.G2_PRODUTO = '" + M->C2_PRODUTO + "' "
   EndIf
   cQuery += " ORDER BY 2,1 "

   cQuery := ChangeQuery(cQuery)

   dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

   While (cAlias)->(!Eof())
      aAdd(aCpos,{(cAlias)->(G2_CODIGO), (cAlias)->(G2_PRODUTO)})
      (cAlias)->(dbSkip())
   End
   (cAlias)->(dbCloseArea())

   If Len(aCpos) < 1
      aAdd(aCpos,{" "," "})
   EndIf

   If !l650Auto .and. !lAutomacao
      DEFINE MSDIALOG oDlg TITLE STR0073  FROM 0,0 TO 240,500 PIXEL //"Roteiro de operações"

      @ 10,10 LISTBOX oLbx FIELDS HEADER STR0074 /*"Roteiro"*/, STR0075 /*"Produto"*/  SIZE 230,95 OF oDlg PIXEL

      oLbx:SetArray( aCpos )
      oLbx:bLine     := {|| {aCpos[oLbx:nAt,1], aCpos[oLbx:nAt,2]}}
      oLbx:bLDblClick := {|| {oDlg:End(), lRet:=.T., aRet := {oLbx:aArray[oLbx:nAt,1],oLbx:aArray[oLbx:nAt,2]}}}


      DEFINE SBUTTON FROM 107,213 TYPE 1 ACTION (oDlg:End(), lRet:=.T., aRet := {oLbx:aArray[oLbx:nAt,1],oLbx:aArray[oLbx:nAt,2]})  ENABLE OF oDlg
      ACTIVATE MSDIALOG oDlg CENTER
   EndIF

   If Len(aRet) > 0 .And. lRet
      If Empty(aRet[1])
         lRet := .F.
      Else
         SG2->(dbSetOrder(1))
         SG2->(dbSeek(cFilSG2+aRet[2]+aRet[1]))
      EndIf
   EndIf
Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A650IntSFCºAutor  ³Andre Anjos		 º Data ³  02/05/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Gera integracao com Chao de Fabrica.                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ nOpc: 3- Inclusao				  						  º±±
±±º			 ³ 		 4- Alteracao				  						  º±±
±±º			 ³ 		 5- Exclusao				  						  º±±
±±º			 ³ nEvento: 1- Inclusao de OP pai						  	  º±±
±±º			 ³ nEvento: 2- Alteracao para geracao das operacoes			  º±±
±±º			 ³ nEvento: 3- Alteracao para geracao dos empenhos			  º±±
±±º			 ³ nEvento: 4- Inclusao de OP filha							  º±±
±±º			 ³ nEvento: 5- Alteracao do cadastro						  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PCPIntSFC(nOpc, nEvento, cError, cNome, oModel, cAlias)
Local aArea      := GetArea()
Local lRet       := .T.
Local aCpoCYQ    := {}
Local aCpoCY9    := {}
Local aCpoCYD    := {}
Local aCpoCYP    := {}
Local nX         := 0
Local nY         := 0
Local nItErro    := 0
Local aAux       := {}
Local aBackup    := Array(2)
Local cRoteiro   := ' '
Local aAreaSG2   := {}
Local lModelEnv  := .T.
Private l010Auto := .F.
Default cAlias   := IIf(nOpc # 5 .And. (nEvento==1 .OR. nEvento==5), "M", "SC2")
Default oModel   := .F.

If ValType(oModel) == "L"
	oModel		:= FWLoadModel("SFCA100")
	lModelEnv	:= .F.
EndIf

If Type("Inclui") == "L"
	aBackup[1] := INCLUI
EndIf

If Type("Altera") == "L"
	aBackup[2] := ALTERA
EndIf

If Empty(cRoteiro := &(cAlias+"->C2_ROTEIRO") )
	If Empty(cRoteiro := Posicione("SB1",1,xFilial("SB1")+&(cAlias+"->C2_PRODUTO"),"B1_OPERPAD"))
		cRoteiro := Posicione("SG2",1,xFilial("SG2")+&(cAlias+"->C2_PRODUTO")+StrZero(1,TamSX3("G2_CODIGO")[1]),"G2_CODIGO")
	EndIf
EndIf

SG2->(dbSetOrder(1))
If &(cAlias+"->C2_TPOP") == "F" .And. SG2->(dbSeek(xFilial("SG2")+&(cAlias+"->C2_PRODUTO")+cRoteiro))
	SB1->(dbSetOrder(1))
	SB1->(dbSeek(xFilial("SB1")+&(cAlias+"->C2_PRODUTO")))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Define campos a serem atualizados no cabecalho do cadastro de Ordem Pr - SFC ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nOpc == 3
		aAdd(aCpoCYQ,{"CYQ_NRORPO",&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")})
		aAdd(aCpoCYQ,{"CYQ_CDAC",&(cAlias+"->C2_PRODUTO")})
		aAdd(aCpoCYQ,{"CYQ_DSAC",SB1->B1_DESC})
		aAdd(aCpoCYQ,{"CYQ_CDDP",&(cAlias+"->C2_LOCAL")})
		aAdd(aCpoCYQ,{"CYQ_QTOR",&(cAlias+"->C2_QUANT")})
		aAdd(aCpoCYQ,{"CYQ_TPORPO","1"})
		aAdd(aCpoCYQ,{"CYQ_CDUN",&(cAlias+"->C2_UM")})
		aAdd(aCpoCYQ,{"CYQ_CDPDOR",&(cAlias+"->(C2_PEDIDO+C2_ITEMPV)")})
		aAdd(aCpoCYQ,{"CYQ_TPST","1"})
		aAdd(aCpoCYQ,{"CYQ_TPSTOR","2"})
		aAdd(aCpoCYQ,{"CYQ_TPRPOR",Posicione("CZ3",1,xFilial("CZ3")+SB1->B1_COD,"CZ3_TPRPOR")})
		aAdd(aCpoCYQ,{"CYQ_CDES",xFilial("SC2")})
		aAdd(aCpoCYQ,{"CYQ_CDGE",SB1->B1_GRUPO})
		aAdd(aCpoCYQ,{"CYQ_DSGE",Posicione("SBM",1,xFilial("SBM")+SB1->B1_GRUPO,"BM_DESC")})
		aAdd(aCpoCYQ,{"CYQ_VLPSLQ",SB1->B1_PESO})
		aAdd(aCpoCYQ,{"CYQ_VLPSBR",SB1->B1_PESBRU})

		SF5->(dbSeek(xFilial("SF5")+SuperGetMV("MV_TMPAD",.F.,"")))
		aAdd(aCpoCYQ,{"CYQ_TPMOD","1"})
		aAdd(aCpoCYQ,{"CYQ_TPGGF",If(SF5->F5_TRANMOD = "S","2","1")})
	EndIf

	If nOpc # 5 .And. (nEvento == 1 .Or. nEvento == 4 .Or. nEvento == 5)
		aAdd(aCpoCYQ,{"CYQ_DTBGOR",&(cAlias+"->C2_DATPRI")})
		aAdd(aCpoCYQ,{"CYQ_DTEDOR",&(cAlias+"->C2_DATPRF")})
	EndIf

	//oModel := FWLoadModel("SFCA100")
	oModel:SetOperation(nOpc)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quando se tratar de alteracao ou exclusao primeiramente o registro devera ser posicionado ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nOpc # 3
		dbSelectArea("CYQ")
		dbSetOrder(1)
		dbSeek(xFilial("CYQ")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)"))
	EndIf

	N := 1

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ativa o modelo de dados ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lRet := oModel:Activate()

	If nOpc # 5
		aAux := oModel:GetModel("CYQMASTER"):GetStruct():GetFields()

		For nX := 1 To Len(aCpoCYQ)
			If aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCpoCYQ[nX,1])}) > 0
				If !(oModel:SetValue("CYQMASTER",aCpoCYQ[nX,1],aCpoCYQ[nX,2]))
					lRet := .F.
					Exit
				EndIf
			EndIf
		Next nX
	EndIf

	If lRet .And. nOpc == 4 .And. nEvento == 2
		SG2->(dbSetOrder(1))
		SHY->(dbSetOrder(1))
		SHY->(dbSeek(xFilial("SHY")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")))
		While !SHY->(EOF()) .And. SHY->(HY_FILIAL+HY_OP) == xFilial("SHY")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")
		    SG2->(dbSeek(xFilial("SG2")+&(cAlias+"->C2_PRODUTO+SHY->(HY_ROTEIRO+HY_OPERAC)")))

		    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Define campos da folder 'Operacoes da Ordem' a serem atualizados no cadastro de OP  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aAdd(aCpoCY9,{})

			aAdd(aTail(aCpoCY9),{"CY9_NRORPO",SHY->HY_OP})
			aAdd(aTail(aCpoCY9),{"CY9_CDAT",SHY->HY_OPERAC})
			aAdd(aTail(aCpoCY9),{"CY9_DSAT",SHY->HY_DESCRI})
			aAdd(aTail(aCpoCY9),{"CY9_CDAC",&(cAlias+"->C2_PRODUTO")})
			aAdd(aTail(aCpoCY9),{"CY9_DSAC",Posicione("SB1",1,xFilial("SB1")+&(cAlias+"->C2_PRODUTO"),"B1_DESC")})
			aAdd(aTail(aCpoCY9),{"CY9_TPAT","1"})
			aAdd(aTail(aCpoCY9),{"CY9_CDCETR",SHY->HY_CTRAB})
			aAdd(aTail(aCpoCY9),{"CY9_DSCETR",Posicione("SHB",1,xFilial("SHB")+SHY->HY_CTRAB,"HB_NOME")})
			aAdd(aTail(aCpoCY9),{"CY9_TPUNTE","1"})
			aAdd(aTail(aCpoCY9),{"CY9_QTTEMQ",SHY->HY_TEMPOM})
			aAdd(aTail(aCpoCY9),{"CY9_QTTESU",SHY->HY_TEMPOS})
			aAdd(aTail(aCpoCY9),{"CY9_CDRT",SHY->HY_ROTEIRO})
			aAdd(aTail(aCpoCY9),{"CY9_CDFE",SHY->HY_FERRAM})
			aAdd(aTail(aCpoCY9),{"CY9_QTAT",SHY->HY_QUANT})
			aAdd(aTail(aCpoCY9),{"CY9_TPTE",If(SG2->G2_TPOPER=="3","1",If(SG2->G2_TPOPER=="4","3",SG2->G2_TPOPER))})
			aAdd(aTail(aCpoCY9),{"CY9_QTLOPA",SG2->G2_LOTEPAD})
			aAdd(aTail(aCpoCY9),{"CY9_LGCERP",Posicione("CYI",1,xFilial("CYI")+SHY->HY_CTRAB,"CYI_LGCERP")})

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Define campos da folder 'Rede Pert' a serem atualizados no cadastro de OP  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SHY->(dbSkip())
			If !SHY->(EOF()) .And. SHY->(HY_FILIAL+HY_OP) == xFilial("SHY")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")
				aAdd(aCpoCYD,{})

				aAdd(aTail(aCpoCYD),{"CYD_NRORPO",SHY->HY_OP})
				aAdd(aTail(aCpoCYD),{"CYD_CDAC",SG2->G2_PRODUTO})
				aAdd(aTail(aCpoCYD),{"CYD_CDACPV",SG2->G2_PRODUTO})
				aAdd(aTail(aCpoCYD),{"CYD_CDRT",SHY->HY_ROTEIRO})
				aAdd(aTail(aCpoCYD),{"CYD_CDRTPV",SHY->HY_ROTEIRO})
				aAdd(aTail(aCpoCYD),{"CYD_CDAT",SHY->HY_OPERAC})
				aAdd(aTail(aCpoCYD),{"CYD_CDATPV",SG2->G2_OPERAC})

				aAreaSG2 := SG2->(GetArea())

				SG2->(dbSetOrder(1))
				SG2->(dbSeek(xFilial("SG2")+&(cAlias+"->C2_PRODUTO+SHY->(HY_ROTEIRO+HY_OPERAC)")))

				If SG2->G2_TPSOBRE == "2"
					aAdd(aTail(aCpoCYD),{"CYD_VLPNOV",SG2->G2_TEMPSOB})
				ElseIf SG2->G2_TPSOBRE == "1"
					aAdd(aTail(aCpoCYD),{"CYD_VLPNOV",100})
				ElseIf SG2->G2_TPSOBRE == "3"
					nVlpnov := Round((SG2->G2_TEMPSOB * 100) / SG2->G2_TEMPAD,2)
					If nVlpnov > 100
						nVlpnov := 100
					EndIf
					aAdd(aTail(aCpoCYD),{"CYD_VLPNOV",nVlpnov})
				EndIf

				RestArea(aAreaSG2)

				aAdd(aTail(aCpoCYD),{"CYD_QTTETS",SG2->G2_TEMPEND})
			EndIf
		End

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Quando alteracao deleta linhas das grids 'Operacoes' e 'Rede' para nova inclusao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 To oModel:GetModel("CY9DETAIL"):GetQtdLine()
			oModel:GetModel("CY9DETAIL"):GoLine(nX)
			oModel:GetModel("CY9DETAIL"):SetValue("CY9_IDAT","0")
			oModel:GetModel("CY9DETAIL"):DeleteLine()
		Next nX

		For nX := 1 To oModel:GetModel("CYDDETAIL"):GetQtdLine()
			oModel:GetModel("CYDDETAIL"):GoLine(nX)
			oModel:GetModel("CYDDETAIL"):DeleteLine()
		Next nX

		aAux := oModel:GetModel("CY9DETAIL"):GetStruct():GetFields()

		For nY := 1 To Len(aCpoCY9)
			oModel:GetModel("CY9DETAIL"):AddLine()

			For nX := 1 To Len(aCpoCY9[nY])
				If aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCpoCY9[nY,nX,1])}) > 0
					If !(oModel:SetValue("CY9DETAIL",aCpoCY9[nY,nX,1],aCpoCY9[nY,nX,2]))
						lRet := .F.
						nItErro := Len(oModel:GetModel("CY9DETAIL"):aCols)
						Exit
					EndIf
				EndIf
			Next nX

			If !lRet
				Exit
			EndIf
		Next nY

		If Empty(nItErro) .And. lRet
			aAux := oModel:GetModel("CYDDETAIL"):GetStruct():GetFields()

			For nY := 1 To Len(aCpoCYD)
				oModel:GetModel("CYDDETAIL"):AddLine()

				For nX := 1 To Len(aCpoCYD[nY])
					If aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCpoCYD[nY,nX,1])}) > 0
						If !(oModel:SetValue("CYDDETAIL",aCpoCYD[nY,nX,1],aCpoCYD[nY,nX,2]))
							lRet := .F.
							nItErro := Len(oModel:GetModel("CYDDETAIL"):aCols)
							Exit
						EndIf
					EndIf
				Next nX

				If !lRet
					Exit
				EndIf
			Next nY
		EndIf
	EndIf

	If lRet .And. nOpc == 4 .And. nEvento == 3
		SGF->(dbSetOrder(2))
		SHY->(dbSetOrder(1))
		SHY->(dbSeek(xFilial("SHY")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")))
		If !SHY->(dbSeek(xFilial("SHY")+SHY->(HY_OP+HY_ROTEIRO)+Replicate("z",TamSX3("G2_OPERAC")[1]),.T.))
			SHY->(dbSkip(-1))
		EndIf
		SD4->(dbSetOrder(2))
		SD4->(dbSeek(xFilial("SD4")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")))
		While !SD4->(EOF()) .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")
			aAdd(aCpoCYP,{})

			aAdd(aTail(aCpoCYP),{"CYP_NRORPO",SD4->D4_OP})
			aAdd(aTail(aCpoCYP),{"CYP_CDMT",SD4->D4_COD})
			aAdd(aTail(aCpoCYP),{"CYP_NRSQMT",SD4->D4_TRT})
			aAdd(aTail(aCpoCYP),{"CYP_DSMT",Posicione("SB1",1,xFilial("SB1")+SD4->D4_COD,"B1_DESC")})
			aAdd(aTail(aCpoCYP),{"CYP_DSACPI",Posicione("SB1",1,xFilial("SB1")+&(cAlias+"->C2_PRODUTO"),"B1_DESC")})
			aAdd(aTail(aCpoCYP),{"CYP_CDACPI",&(cAlias+"->C2_PRODUTO")})
			aAdd(aTail(aCpoCYP),{"CYP_CDRT",SHY->HY_ROTEIRO})
			If SGF->(dbSeek(xFilial("SGF")+&(cAlias+"->C2_PRODUTO")+SHY->HY_ROTEIRO+SD4->D4_COD))
				aAdd(aTail(aCpoCYP),{"CYP_CDAT",SGF->GF_OPERAC})
			Else
				aAdd(aTail(aCpoCYP),{"CYP_CDAT",SHY->HY_OPERAC})
			EndIf
			aAdd(aTail(aCpoCYP),{"CYP_CDDP",SD4->D4_LOCAL})
			aAdd(aTail(aCpoCYP),{"CYP_CDLO",SD4->D4_LOTECTL})
			aAdd(aTail(aCpoCYP),{"CYP_QTMT",SD4->D4_QUANT})
			aAdd(aTail(aCpoCYP),{"CYP_CDUN",Posicione("SB1",1,xFilial("SB1")+SD4->D4_COD,"B1_UM")})
			aAdd(aTail(aCpoCYP),{"CYP_DTMT",SD4->D4_DATA})
			aAdd(aTail(aCpoCYP),{"CYP_TPST","1"})

			SD4->(dbSkip())
		End

		aAux := oModel:GetModel("CYPDETAIL"):GetStruct():GetFields()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Quando alteracao deleta linhas das grids 'Operacoes' e 'Rede' para nova inclusao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 To oModel:GetModel("CYPDETAIL"):GetQtdLine()
			oModel:GetModel("CYPDETAIL"):GoLine(nX)
			oModel:GetModel("CYPDETAIL"):DeleteLine()
		Next nX

		For nY := 1 To Len(aCpoCYP)
			oModel:GetModel("CYPDETAIL"):AddLine()

			For nX := 1 To Len(aCpoCYP[nY])
				If aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCpoCYP[nY,nX,1])}) > 0
					If !(oModel:SetValue("CYPDETAIL",aCpoCYP[nY,nX,1],aCpoCYP[nY,nX,2]))
						lRet := .F.
						nItErro := nX
						Exit
					EndIf
				EndIf
			Next nX

			If !lRet
				Exit
			EndIf
		Next nY
	EndIf

	If lRet
		If (lRet := oModel:VldData())
			lRet := oModel:CommitData()
		EndIf
	EndIf

	If !lRet
		A010SFCErr(oModel,@cError,nItErro,cNome,SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD))
	EndIf

	oModel:DeActivate()
	RestArea(aArea)
EndIf

If aBackup[1] # NIL
	INCLUI := aBackup[1]
EndIf

If aBackup[2] # NIL
	ALTERA := aBackup[2]
EndIf

If !lModelEnv
	oModel:Destroy()
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650VldPV  ³ Autor ³ Sergio S. Fuzinaka   ³ Data ³ 15.04.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Executa validacao na rotina de alteracao do Pedido de Venda ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PCPVldPV()

Local lRet		:= .T.
Local aArea		:= GetArea()
Local aAreaSC2	:= SC2->( GetArea() )
Local aAreaSD3	:= SD3->( GetArea() )
Local nQtdVen	:= IIf( ReadVar() == "M->C6_QTDVEN", &( ReadVar() ), 0 )	//C6_QTDVEN

If SC6->C6_TPOP == "F" .And. !Empty( SC6->C6_NUMOP ) .And. nQtdVen <> SC6->C6_QTDVEN	//Gerado OP

	dbSelectArea("SGJ")
	dbSetOrder(1)
	If dbSeek( xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL+C6_NUMOP+C6_ITEMOP) )
		dbSelectArea("SC2")
		dbSetOrder(1)
		If dbSeek(xFilial("SC2")+SGJ->(GJ_NUMOP+GJ_ITEMOP+GJ_SEQUEN+GJ_ITGRDOP))
			If SC2->C2_QUJE > 0		//Qtd. produzida
				lRet := .F.
				Help(" ",1,"A410ALTPV")
			Else
				dbSelectArea("SD3")
				dbSetOrder(1)
				If dbSeek(xFilial("SD3")+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD))
					While !Eof() .And. SD3->(D3_FILIAL+D3_OP) == SC2->C2_FILIAL+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
						If SD3->D3_ESTORNO <> "S"
							lRet := .F.
							Help(" ",1,"A410ALTPV")
						Endif
						SD3->(dbSkip())
					Enddo
				Endif
			Endif
			If lRet
				If Aviso(STR0076 ,STR0077 +SC2->C2_NUM+"/"+SC2->C2_ITEM+ STR0078 +CHR(13)+CHR(10)+CHR(13)+CHR(10)+"Confirma a alteração?",{"Sim","Nao"}) == 2
					// "Atenção",  "Este item gerou a OP ",   ", a alteração da quantidade irá excluí-la!",
					lRet := .F.
				Endif
			Endif
		Endif
	Endif

Endif

RestArea( aAreaSD3 )
RestArea( aAreaSC2 )
RestArea( aArea )

Return( lRet )

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A390PPI    ³Autor ³Ana Paula dos Santos  ³ Data ³ 20/05/2021³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³Integração PPI                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function PCP390PPI(cProduto, cLocal, cSerie, cLoteCtl, cNumLote,;
                        cDtValid, nQuant, cTipMov, cSeq, cDoc, cEvent, aDelete)

Default cEvent  := 'upsert'
Default cTipMov := '3'

If IsInCallStack("A220Deleta") .OR. IsInCallStack("A220AtuSD5")
	Return
EndIf

// Integração com TOTVS MES
if PCPIntgPPI()
	dbSelectArea("SOE")
	SOE->(dbSetOrder(1))
	If SOE->(dbSeek(xFilial("SOE")+"SB2")) .AND. ALLTRIM(SOE->OE_VAR3) == '1'

		//Enviar saldo que está sendo distribuido para o lote na tag QuantityUpdated
		MATA225PPI( cProduto,; // Produto
					cLocal,; // Armazém
					'',; // Localização
					cSerie,; // Número de série
					cLoteCtl,; // Lote
					cNumLote,; // Sub-lote
					cDtValid,;  // Data
					nQuant,; // Quantidade
					cTipMov,; // Tipo de movimento
					cSeq,; // Sequencia
					cDoc,; // Documento
					aDelete,; //Registros excluidos
					cEvent) // Ação
	Endif
Endif

Return

/*/{Protheus.doc} PCPMETRIC
Função para integrar ID de métrica com o dashboard CAROL
@type  Function
@author ana.paula
@since 08/09/2021
@version P12.1.27
@param 01 cIdProg, Character, Subrotina que esta gerando da metrica
@param 02 aArrayID, Array   , Array que contem o ID da métrica e o valor a ser integrado
@param 03 lPutInfo, Logic   , Indica que deve ser executada a função FWLSPutASyncInfo após o addMetrics. Utilizado em rotinas que não são chamadas pelo MENU.
@param 04 lUseCustom, Logic , Indica que deve irá usar a classe FwCustomMetrics.
@param 05 cRotina, Character, Rotina que está definindo a métrica.
/*/
Function PCPMETRIC(cIdProg, aArrayID, lPutInfo, lUseCustom, cRotina)

	Local cBanco := Upper(TcgetDB())
	Local nX     := 0

	Default lPutInfo   := .F.
	Default lUseCustom := .F.

	If !lUseCustom .and. FwLibVersion() >= "20200727"
		For nX := 1 To Len(aArrayID)
			FWMetrics():addMetrics(cIdProg, {aArrayID[nX]})
		Next nX
		If lPutInfo
			FWLSPutASyncInfo("LS006", , "10", cIdProg)
		EndIf
	ElseIf FwLibVersion() >= "20210517" .and. !("|"+cBanco+"|" $ "|OPENEDGE|INFORMIX|DB2|")
		FwCustomMetrics():setSumMetric(cIdProg, aArrayID[1], aArrayID[2], /*dDateSend*/, /*nLapTime*/, cRotina)
	EndIf

Return
